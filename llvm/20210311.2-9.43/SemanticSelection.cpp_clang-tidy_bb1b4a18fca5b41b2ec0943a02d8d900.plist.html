<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "content": "//===--- CollectMacros.h -----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n\n#include \"AST.h\"\n#include \"Protocol.h\"\n#include \"SourceCode.h\"\n#include \"index/SymbolID.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct MacroOccurrence {\n  // Instead of storing SourceLocation, we have to store the token range because\n  // SourceManager from preamble is not available when we build the AST.\n  Range Rng;\n  bool IsDefinition;\n};\n\nstruct MainFileMacros {\n  llvm::StringSet<> Names;\n  llvm::DenseMap<SymbolID, std::vector<MacroOccurrence>> MacroRefs;\n  // Somtimes it is not possible to compute the SymbolID for the Macro, e.g. a\n  // reference to an undefined macro. Store them separately, e.g. for semantic\n  // highlighting.\n  std::vector<MacroOccurrence> UnknownMacros;\n  // Ranges skipped by the preprocessor due to being inactive.\n  std::vector<Range> SkippedRanges;\n};\n\n/// Collects macro references (e.g. definitions, expansions) in the main file.\n/// It is used to:\n///  - collect macros in the preamble section of the main file (in Preamble.cpp)\n///  - collect macros after the preamble of the main file (in ParsedAST.cpp)\nclass CollectMainFileMacros : public PPCallbacks {\npublic:\n  explicit CollectMainFileMacros(const SourceManager &SM, MainFileMacros &Out)\n      : SM(SM), Out(Out) {}\n\n  void FileChanged(SourceLocation Loc, FileChangeReason,\n                   SrcMgr::CharacteristicKind, FileID) override {\n    InMainFile = isInsideMainFile(Loc, SM);\n  }\n\n  void MacroDefined(const Token &MacroName, const MacroDirective *MD) override {\n    add(MacroName, MD->getMacroInfo(), /*IsDefinition=*/true);\n  }\n\n  void MacroExpands(const Token &MacroName, const MacroDefinition &MD,\n                    SourceRange Range, const MacroArgs *Args) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void MacroUndefined(const clang::Token &MacroName,\n                      const clang::MacroDefinition &MD,\n                      const clang::MacroDirective *Undef) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifdef(SourceLocation Loc, const Token &MacroName,\n             const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifndef(SourceLocation Loc, const Token &MacroName,\n              const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Defined(const Token &MacroName, const MacroDefinition &MD,\n               SourceRange Range) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void SourceRangeSkipped(SourceRange R, SourceLocation EndifLoc) override {\n    if (!InMainFile)\n      return;\n    Position Begin = sourceLocToPosition(SM, R.getBegin());\n    Position End = sourceLocToPosition(SM, R.getEnd());\n    Out.SkippedRanges.push_back(Range{Begin, End});\n  }\n\nprivate:\n  void add(const Token &MacroNameTok, const MacroInfo *MI,\n           bool IsDefinition = false);\n  const SourceManager &SM;\n  bool InMainFile = true;\n  MainFileMacros &Out;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "content": "//===--- Compiler.h ----------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Shared utilities for invoking the clang compiler.\n// Most callers will use this through Preamble/ParsedAST, but some features like\n// CodeComplete run their own compile actions that share these low-level pieces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILER_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILER_H\n\n#include \"GlobalCompilationDatabase.h\"\n#include \"TidyProvider.h\"\n#include \"index/Index.h\"\n#include \"support/ThreadsafeFS.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n\nnamespace clang {\nnamespace clangd {\n\nclass IgnoreDiagnostics : public DiagnosticConsumer {\npublic:\n  static void log(DiagnosticsEngine::Level DiagLevel,\n                  const clang::Diagnostic &Info);\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const clang::Diagnostic &Info) override;\n};\n\n// Options to run clang e.g. when parsing AST.\nstruct ParseOptions {\n  // (empty at present, formerly controlled recovery AST, include-fixer etc)\n};\n\n/// Information required to run clang, e.g. to parse AST or do code completion.\nstruct ParseInputs {\n  tooling::CompileCommand CompileCommand;\n  const ThreadsafeFS *TFS;\n  std::string Contents;\n  // Version identifier for Contents, provided by the client and opaque to us.\n  std::string Version = \"null\";\n  // Prevent reuse of the cached preamble/AST. Slow! Useful to workaround\n  // clangd's assumption that missing header files will stay missing.\n  bool ForceRebuild = false;\n  // Used to recover from diagnostics (e.g. find missing includes for symbol).\n  const SymbolIndex *Index = nullptr;\n  ParseOptions Opts = ParseOptions();\n  TidyProviderRef ClangTidyProvider = {};\n};\n\n/// Builds compiler invocation that could be used to build AST or preamble.\nstd::unique_ptr<CompilerInvocation>\nbuildCompilerInvocation(const ParseInputs &Inputs, clang::DiagnosticConsumer &D,\n                        std::vector<std::string> *CC1Args = nullptr);\n\n/// Creates a compiler instance, configured so that:\n///   - Contents of the parsed file are remapped to \\p MainFile.\n///   - Preamble is overriden to use PCH passed to this function. It means the\n///     changes to the preamble headers or files included in the preamble are\n///     not visible to this compiler instance.\n///   - llvm::vfs::FileSystem is used for all underlying file accesses. The\n///     actual vfs used by the compiler may be an overlay over the passed vfs.\n/// Returns null on errors. When non-null value is returned, it is expected to\n/// be consumed by FrontendAction::BeginSourceFile to properly destroy \\p\n/// MainFile.\nstd::unique_ptr<CompilerInstance> prepareCompilerInstance(\n    std::unique_ptr<clang::CompilerInvocation>, const PrecompiledPreamble *,\n    std::unique_ptr<llvm::MemoryBuffer> MainFile,\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem>, DiagnosticConsumer &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILER_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "content": "//===--- Protocol.h - Language Server Protocol Implementation ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains structs based on the LSP specification at\n// https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md\n//\n// This is not meant to be a complete implementation, new interfaces are added\n// when they're needed.\n//\n// Each struct has a toJSON and fromJSON function, that converts between\n// the struct and a JSON representation. (See JSON.h)\n//\n// Some structs also have operator<< serialization. This is for debugging and\n// tests, and is not generally machine-readable.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n\n#include \"URI.h\"\n#include \"index/SymbolID.h\"\n#include \"support/MemoryTree.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nenum class ErrorCode {\n  // Defined by JSON RPC.\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n\n  ServerNotInitialized = -32002,\n  UnknownErrorCode = -32001,\n\n  // Defined by the protocol.\n  RequestCancelled = -32800,\n  ContentModified = -32801,\n};\n// Models an LSP error as an llvm::Error.\nclass LSPError : public llvm::ErrorInfo<LSPError> {\npublic:\n  std::string Message;\n  ErrorCode Code;\n  static char ID;\n\n  LSPError(std::string Message, ErrorCode Code)\n      : Message(std::move(Message)), Code(Code) {}\n\n  void log(llvm::raw_ostream &OS) const override {\n    OS << int(Code) << \": \" << Message;\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n// URI in \"file\" scheme for a file.\nstruct URIForFile {\n  URIForFile() = default;\n\n  /// Canonicalizes \\p AbsPath via URI.\n  ///\n  /// File paths in URIForFile can come from index or local AST. Path from\n  /// index goes through URI transformation, and the final path is resolved by\n  /// URI scheme and could potentially be different from the original path.\n  /// Hence, we do the same transformation for all paths.\n  ///\n  /// Files can be referred to by several paths (e.g. in the presence of links).\n  /// Which one we prefer may depend on where we're coming from. \\p TUPath is a\n  /// hint, and should usually be the main entrypoint file we're processing.\n  static URIForFile canonicalize(llvm::StringRef AbsPath,\n                                 llvm::StringRef TUPath);\n\n  static llvm::Expected<URIForFile> fromURI(const URI &U,\n                                            llvm::StringRef HintPath);\n\n  /// Retrieves absolute path to the file.\n  llvm::StringRef file() const { return File; }\n\n  explicit operator bool() const { return !File.empty(); }\n  std::string uri() const { return URI::createFile(File).toString(); }\n\n  friend bool operator==(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File == RHS.File;\n  }\n\n  friend bool operator!=(const URIForFile &LHS, const URIForFile &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File < RHS.File;\n  }\n\nprivate:\n  explicit URIForFile(std::string &&File) : File(std::move(File)) {}\n\n  std::string File;\n};\n\n/// Serialize/deserialize \\p URIForFile to/from a string URI.\nllvm::json::Value toJSON(const URIForFile &U);\nbool fromJSON(const llvm::json::Value &, URIForFile &, llvm::json::Path);\n\nstruct TextDocumentIdentifier {\n  /// The text document's URI.\n  URIForFile uri;\n};\nllvm::json::Value toJSON(const TextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, TextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct VersionedTextDocumentIdentifier : public TextDocumentIdentifier {\n  /// The version number of this document. If a versioned text document\n  /// identifier is sent from the server to the client and the file is not open\n  /// in the editor (the server has not received an open notification before)\n  /// the server can send `null` to indicate that the version is known and the\n  /// content on disk is the master (as speced with document content ownership).\n  ///\n  /// The version number of a document will increase after each change,\n  /// including undo/redo. The number doesn't need to be consecutive.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<std::int64_t> version;\n};\nllvm::json::Value toJSON(const VersionedTextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, VersionedTextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct Position {\n  /// Line position in a document (zero-based).\n  int line = 0;\n\n  /// Character offset on a line in a document (zero-based).\n  /// WARNING: this is in UTF-16 codepoints, not bytes or characters!\n  /// Use the functions in SourceCode.h to construct/interpret Positions.\n  int character = 0;\n\n  friend bool operator==(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) ==\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator!=(const Position &LHS, const Position &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator<=(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <=\n           std::tie(RHS.line, RHS.character);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Position &, llvm::json::Path);\nllvm::json::Value toJSON(const Position &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Position &);\n\nstruct Range {\n  /// The range's start position.\n  Position start;\n\n  /// The range's end position.\n  Position end;\n\n  friend bool operator==(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) == std::tie(RHS.start, RHS.end);\n  }\n  friend bool operator!=(const Range &LHS, const Range &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) < std::tie(RHS.start, RHS.end);\n  }\n\n  bool contains(Position Pos) const { return start <= Pos && Pos < end; }\n  bool contains(Range Rng) const {\n    return start <= Rng.start && Rng.end <= end;\n  }\n};\nbool fromJSON(const llvm::json::Value &, Range &, llvm::json::Path);\nllvm::json::Value toJSON(const Range &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Range &);\n\nstruct Location {\n  /// The text document's URI.\n  URIForFile uri;\n  Range range;\n\n  friend bool operator==(const Location &LHS, const Location &RHS) {\n    return LHS.uri == RHS.uri && LHS.range == RHS.range;\n  }\n\n  friend bool operator!=(const Location &LHS, const Location &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const Location &LHS, const Location &RHS) {\n    return std::tie(LHS.uri, LHS.range) < std::tie(RHS.uri, RHS.range);\n  }\n};\nllvm::json::Value toJSON(const Location &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Location &);\n\nstruct TextEdit {\n  /// The range of the text document to be manipulated. To insert\n  /// text into a document create a range where start === end.\n  Range range;\n\n  /// The string to be inserted. For delete operations use an\n  /// empty string.\n  std::string newText;\n};\ninline bool operator==(const TextEdit &L, const TextEdit &R) {\n  return std::tie(L.newText, L.range) == std::tie(R.newText, R.range);\n}\nbool fromJSON(const llvm::json::Value &, TextEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const TextEdit &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TextEdit &);\n\nstruct TextDocumentItem {\n  /// The text document's URI.\n  URIForFile uri;\n\n  /// The text document's language identifier.\n  std::string languageId;\n\n  /// The version number of this document (it will strictly increase after each\n  /// change, including undo/redo.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<int64_t> version;\n\n  /// The content of the opened text document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentItem &, llvm::json::Path);\n\nenum class TraceLevel {\n  Off = 0,\n  Messages = 1,\n  Verbose = 2,\n};\nbool fromJSON(const llvm::json::Value &E, TraceLevel &Out, llvm::json::Path);\n\nstruct NoParams {};\ninline llvm::json::Value toJSON(const NoParams &) { return nullptr; }\ninline bool fromJSON(const llvm::json::Value &, NoParams &, llvm::json::Path) {\n  return true;\n}\nusing InitializedParams = NoParams;\n\n/// Defines how the host (editor) should sync document changes to the language\n/// server.\nenum class TextDocumentSyncKind {\n  /// Documents should not be synced at all.\n  None = 0,\n\n  /// Documents are synced by always sending the full content of the document.\n  Full = 1,\n\n  /// Documents are synced by sending the full content on open.  After that\n  /// only incremental updates to the document are send.\n  Incremental = 2,\n};\n\n/// The kind of a completion entry.\nenum class CompletionItemKind {\n  Missing = 0,\n  Text = 1,\n  Method = 2,\n  Function = 3,\n  Constructor = 4,\n  Field = 5,\n  Variable = 6,\n  Class = 7,\n  Interface = 8,\n  Module = 9,\n  Property = 10,\n  Unit = 11,\n  Value = 12,\n  Enum = 13,\n  Keyword = 14,\n  Snippet = 15,\n  Color = 16,\n  File = 17,\n  Reference = 18,\n  Folder = 19,\n  EnumMember = 20,\n  Constant = 21,\n  Struct = 22,\n  Event = 23,\n  Operator = 24,\n  TypeParameter = 25,\n};\nbool fromJSON(const llvm::json::Value &, CompletionItemKind &,\n              llvm::json::Path);\nconstexpr auto CompletionItemKindMin =\n    static_cast<size_t>(CompletionItemKind::Text);\nconstexpr auto CompletionItemKindMax =\n    static_cast<size_t>(CompletionItemKind::TypeParameter);\nusing CompletionItemKindBitset = std::bitset<CompletionItemKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, CompletionItemKindBitset &,\n              llvm::json::Path);\nCompletionItemKind\nadjustKindToCapability(CompletionItemKind Kind,\n                       CompletionItemKindBitset &SupportedCompletionItemKinds);\n\n/// A symbol kind.\nenum class SymbolKind {\n  File = 1,\n  Module = 2,\n  Namespace = 3,\n  Package = 4,\n  Class = 5,\n  Method = 6,\n  Property = 7,\n  Field = 8,\n  Constructor = 9,\n  Enum = 10,\n  Interface = 11,\n  Function = 12,\n  Variable = 13,\n  Constant = 14,\n  String = 15,\n  Number = 16,\n  Boolean = 17,\n  Array = 18,\n  Object = 19,\n  Key = 20,\n  Null = 21,\n  EnumMember = 22,\n  Struct = 23,\n  Event = 24,\n  Operator = 25,\n  TypeParameter = 26\n};\nbool fromJSON(const llvm::json::Value &, SymbolKind &, llvm::json::Path);\nconstexpr auto SymbolKindMin = static_cast<size_t>(SymbolKind::File);\nconstexpr auto SymbolKindMax = static_cast<size_t>(SymbolKind::TypeParameter);\nusing SymbolKindBitset = std::bitset<SymbolKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, SymbolKindBitset &, llvm::json::Path);\nSymbolKind adjustKindToCapability(SymbolKind Kind,\n                                  SymbolKindBitset &supportedSymbolKinds);\n\n// Convert a index::SymbolKind to clangd::SymbolKind (LSP)\n// Note, some are not perfect matches and should be improved when this LSP\n// issue is addressed:\n// https://github.com/Microsoft/language-server-protocol/issues/344\nSymbolKind indexSymbolKindToSymbolKind(index::SymbolKind Kind);\n\n// Determines the encoding used to measure offsets and lengths of source in LSP.\nenum class OffsetEncoding {\n  // Any string is legal on the wire. Unrecognized encodings parse as this.\n  UnsupportedEncoding,\n  // Length counts code units of UTF-16 encoded text. (Standard LSP behavior).\n  UTF16,\n  // Length counts bytes of UTF-8 encoded text. (Clangd extension).\n  UTF8,\n  // Length counts codepoints in unicode text. (Clangd extension).\n  UTF32,\n};\nllvm::json::Value toJSON(const OffsetEncoding &);\nbool fromJSON(const llvm::json::Value &, OffsetEncoding &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, OffsetEncoding);\n\n// Describes the content type that a client supports in various result literals\n// like `Hover`, `ParameterInfo` or `CompletionItem`.\nenum class MarkupKind {\n  PlainText,\n  Markdown,\n};\nbool fromJSON(const llvm::json::Value &, MarkupKind &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, MarkupKind);\n\n// This struct doesn't mirror LSP!\n// The protocol defines deeply nested structures for client capabilities.\n// Instead of mapping them all, this just parses out the bits we care about.\nstruct ClientCapabilities {\n  /// The supported set of SymbolKinds for workspace/symbol.\n  /// workspace.symbol.symbolKind.valueSet\n  llvm::Optional<SymbolKindBitset> WorkspaceSymbolKinds;\n\n  /// Whether the client accepts diagnostics with codeActions attached inline.\n  /// textDocument.publishDiagnostics.codeActionsInline.\n  bool DiagnosticFixes = false;\n\n  /// Whether the client accepts diagnostics with related locations.\n  /// textDocument.publishDiagnostics.relatedInformation.\n  bool DiagnosticRelatedInformation = false;\n\n  /// Whether the client accepts diagnostics with category attached to it\n  /// using the \"category\" extension.\n  /// textDocument.publishDiagnostics.categorySupport\n  bool DiagnosticCategory = false;\n\n  /// Client supports snippets as insert text.\n  /// textDocument.completion.completionItem.snippetSupport\n  bool CompletionSnippets = false;\n\n  /// Client supports completions with additionalTextEdit near the cursor.\n  /// This is a clangd extension. (LSP says this is for unrelated text only).\n  /// textDocument.completion.editsNearCursor\n  bool CompletionFixes = false;\n\n  /// Client supports hierarchical document symbols.\n  /// textDocument.documentSymbol.hierarchicalDocumentSymbolSupport\n  bool HierarchicalDocumentSymbol = false;\n\n  /// Client supports signature help.\n  /// textDocument.signatureHelp\n  bool HasSignatureHelp = false;\n\n  /// Client supports processing label offsets instead of a simple label string.\n  /// textDocument.signatureHelp.signatureInformation.parameterInformation.labelOffsetSupport\n  bool OffsetsInSignatureHelp = false;\n\n  /// The supported set of CompletionItemKinds for textDocument/completion.\n  /// textDocument.completion.completionItemKind.valueSet\n  llvm::Optional<CompletionItemKindBitset> CompletionItemKinds;\n\n  /// The documentation format that should be used for textDocument/completion.\n  /// textDocument.completion.completionItem.documentationFormat\n  MarkupKind CompletionDocumentationFormat = MarkupKind::PlainText;\n\n  /// Client supports CodeAction return value for textDocument/codeAction.\n  /// textDocument.codeAction.codeActionLiteralSupport.\n  bool CodeActionStructure = false;\n\n  /// Client advertises support for the semanticTokens feature.\n  /// We support the textDocument/semanticTokens request in any case.\n  /// textDocument.semanticTokens\n  bool SemanticTokens = false;\n  /// Client supports Theia semantic highlighting extension.\n  /// https://github.com/microsoft/vscode-languageserver-node/pull/367\n  /// clangd no longer supports this, we detect it just to log a warning.\n  /// textDocument.semanticHighlightingCapabilities.semanticHighlighting\n  bool TheiaSemanticHighlighting = false;\n\n  /// Supported encodings for LSP character offsets. (clangd extension).\n  llvm::Optional<std::vector<OffsetEncoding>> offsetEncoding;\n\n  /// The content format that should be used for Hover requests.\n  /// textDocument.hover.contentEncoding\n  MarkupKind HoverContentFormat = MarkupKind::PlainText;\n\n  /// The client supports testing for validity of rename operations\n  /// before execution.\n  bool RenamePrepareSupport = false;\n\n  /// The client supports progress notifications.\n  /// window.workDoneProgress\n  bool WorkDoneProgress = false;\n\n  /// The client supports implicit $/progress work-done progress streams,\n  /// without a preceding window/workDoneProgress/create.\n  /// This is a clangd extension.\n  /// window.implicitWorkDoneProgressCreate\n  bool ImplicitProgressCreation = false;\n\n  /// Whether the client implementation supports a refresh request sent from the\n  /// server to the client.\n  bool SemanticTokenRefreshSupport = false;\n};\nbool fromJSON(const llvm::json::Value &, ClientCapabilities &,\n              llvm::json::Path);\n\n/// Clangd extension that's used in the 'compilationDatabaseChanges' in\n/// workspace/didChangeConfiguration to record updates to the in-memory\n/// compilation database.\nstruct ClangdCompileCommand {\n  std::string workingDirectory;\n  std::vector<std::string> compilationCommand;\n};\nbool fromJSON(const llvm::json::Value &, ClangdCompileCommand &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at any time, via the\n/// `workspace/didChangeConfiguration` notification.\n/// LSP defines this type as `any`.\nstruct ConfigurationSettings {\n  // Changes to the in-memory compilation database.\n  // The key of the map is a file name.\n  std::map<std::string, ClangdCompileCommand> compilationDatabaseChanges;\n};\nbool fromJSON(const llvm::json::Value &, ConfigurationSettings &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at `initialize` time.\n/// LSP defines this type as `any`.\nstruct InitializationOptions {\n  // What we can change throught the didChangeConfiguration request, we can\n  // also set through the initialize request (initializationOptions field).\n  ConfigurationSettings ConfigSettings;\n\n  llvm::Optional<std::string> compilationDatabasePath;\n  // Additional flags to be included in the \"fallback command\" used when\n  // the compilation database doesn't describe an opened file.\n  // The command used will be approximately `clang $FILE $fallbackFlags`.\n  std::vector<std::string> fallbackFlags;\n\n  /// Clients supports show file status for textDocument/clangd.fileStatus.\n  bool FileStatus = false;\n};\nbool fromJSON(const llvm::json::Value &, InitializationOptions &,\n              llvm::json::Path);\n\nstruct InitializeParams {\n  /// The process Id of the parent process that started\n  /// the server. Is null if the process has not been started by another\n  /// process. If the parent process is not alive then the server should exit\n  /// (see exit notification) its process.\n  llvm::Optional<int> processId;\n\n  /// The rootPath of the workspace. Is null\n  /// if no folder is open.\n  ///\n  /// @deprecated in favour of rootUri.\n  llvm::Optional<std::string> rootPath;\n\n  /// The rootUri of the workspace. Is null if no\n  /// folder is open. If both `rootPath` and `rootUri` are set\n  /// `rootUri` wins.\n  llvm::Optional<URIForFile> rootUri;\n\n  // User provided initialization options.\n  // initializationOptions?: any;\n\n  /// The capabilities provided by the client (editor or tool)\n  ClientCapabilities capabilities;\n  /// The same data as capabilities, but not parsed (to expose to modules).\n  llvm::json::Object rawCapabilities;\n\n  /// The initial trace setting. If omitted trace is disabled ('off').\n  llvm::Optional<TraceLevel> trace;\n\n  /// User-provided initialization options.\n  InitializationOptions initializationOptions;\n};\nbool fromJSON(const llvm::json::Value &, InitializeParams &, llvm::json::Path);\n\nstruct WorkDoneProgressCreateParams {\n  /// The token to be used to report progress.\n  llvm::json::Value token = nullptr;\n};\nllvm::json::Value toJSON(const WorkDoneProgressCreateParams &P);\n\ntemplate <typename T> struct ProgressParams {\n  /// The progress token provided by the client or server.\n  llvm::json::Value token = nullptr;\n\n  /// The progress data.\n  T value;\n};\ntemplate <typename T> llvm::json::Value toJSON(const ProgressParams<T> &P) {\n  return llvm::json::Object{{\"token\", P.token}, {\"value\", P.value}};\n}\n/// To start progress reporting a $/progress notification with the following\n/// payload must be sent.\nstruct WorkDoneProgressBegin {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls if a cancel button should show to allow the user to cancel the\n  /// long-running operation. Clients that don't support cancellation are\n  /// allowed to ignore the setting.\n  bool cancellable = false;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  ///\n  /// Clangd implementation note: we only send nonzero percentages in\n  /// the WorkProgressReport. 'true' here means percentages will be used.\n  bool percentage = false;\n};\nllvm::json::Value toJSON(const WorkDoneProgressBegin &);\n\n/// Reporting progress is done using the following payload.\nstruct WorkDoneProgressReport {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls enablement state of a cancel button. This property is only valid\n  /// if a cancel button got requested in the `WorkDoneProgressStart` payload.\n  ///\n  /// Clients that don't support cancellation or don't support control\n  /// the button's enablement state are allowed to ignore the setting.\n  llvm::Optional<bool> cancellable;\n\n  /// Optional, more detailed associated progress message. Contains\n  /// complementary information to the `title`.\n  ///\n  /// Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n  /// If unset, the previous progress message (if any) is still valid.\n  llvm::Optional<std::string> message;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  llvm::Optional<double> percentage;\n};\nllvm::json::Value toJSON(const WorkDoneProgressReport &);\n//\n/// Signals the end of progress reporting.\nstruct WorkDoneProgressEnd {\n  /// Optional, a final message indicating to for example indicate the outcome\n  /// of the operation.\n  llvm::Optional<std::string> message;\n};\nllvm::json::Value toJSON(const WorkDoneProgressEnd &);\n\nenum class MessageType {\n  /// An error message.\n  Error = 1,\n  /// A warning message.\n  Warning = 2,\n  /// An information message.\n  Info = 3,\n  /// A log message.\n  Log = 4,\n};\nllvm::json::Value toJSON(const MessageType &);\n\n/// The show message notification is sent from a server to a client to ask the\n/// client to display a particular message in the user interface.\nstruct ShowMessageParams {\n  /// The message type.\n  MessageType type = MessageType::Info;\n  /// The actual message.\n  std::string message;\n};\nllvm::json::Value toJSON(const ShowMessageParams &);\n\nstruct DidOpenTextDocumentParams {\n  /// The document that was opened.\n  TextDocumentItem textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidOpenTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidCloseTextDocumentParams {\n  /// The document that was closed.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidCloseTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidSaveTextDocumentParams {\n  /// The document that was saved.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidSaveTextDocumentParams &,\n              llvm::json::Path);\n\nstruct TextDocumentContentChangeEvent {\n  /// The range of the document that changed.\n  llvm::Optional<Range> range;\n\n  /// The length of the range that got replaced.\n  llvm::Optional<int> rangeLength;\n\n  /// The new text of the range/document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentContentChangeEvent &,\n              llvm::json::Path);\n\nstruct DidChangeTextDocumentParams {\n  /// The document that did change. The version number points\n  /// to the version after all provided content changes have\n  /// been applied.\n  VersionedTextDocumentIdentifier textDocument;\n\n  /// The actual content changes.\n  std::vector<TextDocumentContentChangeEvent> contentChanges;\n\n  /// Forces diagnostics to be generated, or to not be generated, for this\n  /// version of the file. If not set, diagnostics are eventually consistent:\n  /// either they will be provided for this version or some subsequent one.\n  /// This is a clangd extension.\n  llvm::Optional<bool> wantDiagnostics;\n\n  /// Force a complete rebuild of the file, ignoring all cached state. Slow!\n  /// This is useful to defeat clangd's assumption that missing headers will\n  /// stay missing.\n  /// This is a clangd extension.\n  bool forceRebuild = false;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeTextDocumentParams &,\n              llvm::json::Path);\n\nenum class FileChangeType {\n  /// The file got created.\n  Created = 1,\n  /// The file got changed.\n  Changed = 2,\n  /// The file got deleted.\n  Deleted = 3\n};\nbool fromJSON(const llvm::json::Value &E, FileChangeType &Out,\n              llvm::json::Path);\n\nstruct FileEvent {\n  /// The file's URI.\n  URIForFile uri;\n  /// The change type.\n  FileChangeType type = FileChangeType::Created;\n};\nbool fromJSON(const llvm::json::Value &, FileEvent &, llvm::json::Path);\n\nstruct DidChangeWatchedFilesParams {\n  /// The actual file events.\n  std::vector<FileEvent> changes;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeWatchedFilesParams &,\n              llvm::json::Path);\n\nstruct DidChangeConfigurationParams {\n  ConfigurationSettings settings;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeConfigurationParams &,\n              llvm::json::Path);\n\n// Note: we do not parse FormattingOptions for *FormattingParams.\n// In general, we use a clang-format style detected from common mechanisms\n// (.clang-format files and the -fallback-style flag).\n// It would be possible to override these with FormatOptions, but:\n//  - the protocol makes FormatOptions mandatory, so many clients set them to\n//    useless values, and we can't tell when to respect them\n// - we also format in other places, where FormatOptions aren't available.\n\nstruct DocumentRangeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The range to format\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, DocumentRangeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentOnTypeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The character that has been typed.\n  std::string ch;\n};\nbool fromJSON(const llvm::json::Value &, DocumentOnTypeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentSymbolParams {\n  // The text document to find symbols in.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentSymbolParams &,\n              llvm::json::Path);\n\n/// Represents a related message and source code location for a diagnostic.\n/// This should be used to point to code locations that cause or related to a\n/// diagnostics, e.g when duplicating a symbol in a scope.\nstruct DiagnosticRelatedInformation {\n  /// The location of this related diagnostic information.\n  Location location;\n  /// The message of this related diagnostic information.\n  std::string message;\n};\nllvm::json::Value toJSON(const DiagnosticRelatedInformation &);\n\nstruct CodeAction;\nstruct Diagnostic {\n  /// The range at which the message applies.\n  Range range;\n\n  /// The diagnostic's severity. Can be omitted. If omitted it is up to the\n  /// client to interpret diagnostics as error, warning, info or hint.\n  int severity = 0;\n\n  /// The diagnostic's code. Can be omitted.\n  std::string code;\n\n  /// A human-readable string describing the source of this\n  /// diagnostic, e.g. 'typescript' or 'super lint'.\n  std::string source;\n\n  /// The diagnostic's message.\n  std::string message;\n\n  /// An array of related diagnostic information, e.g. when symbol-names within\n  /// a scope collide all definitions can be marked via this property.\n  llvm::Optional<std::vector<DiagnosticRelatedInformation>> relatedInformation;\n\n  /// The diagnostic's category. Can be omitted.\n  /// An LSP extension that's used to send the name of the category over to the\n  /// client. The category typically describes the compilation stage during\n  /// which the issue was produced, e.g. \"Semantic Issue\" or \"Parse Issue\".\n  llvm::Optional<std::string> category;\n\n  /// Clangd extension: code actions related to this diagnostic.\n  /// Only with capability textDocument.publishDiagnostics.codeActionsInline.\n  /// (These actions can also be obtained using textDocument/codeAction).\n  llvm::Optional<std::vector<CodeAction>> codeActions;\n};\nllvm::json::Value toJSON(const Diagnostic &);\n\n/// A LSP-specific comparator used to find diagnostic in a container like\n/// std:map.\n/// We only use the required fields of Diagnostic to do the comparison to avoid\n/// any regression issues from LSP clients (e.g. VScode), see\n/// https://git.io/vbr29\nstruct LSPDiagnosticCompare {\n  bool operator()(const Diagnostic &LHS, const Diagnostic &RHS) const {\n    return std::tie(LHS.range, LHS.message) < std::tie(RHS.range, RHS.message);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Diagnostic &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Diagnostic &);\n\nstruct PublishDiagnosticsParams {\n  /// The URI for which diagnostic information is reported.\n  URIForFile uri;\n  /// An array of diagnostic information items.\n  std::vector<Diagnostic> diagnostics;\n  /// The version number of the document the diagnostics are published for.\n  llvm::Optional<int64_t> version;\n};\nllvm::json::Value toJSON(const PublishDiagnosticsParams &);\n\nstruct CodeActionContext {\n  /// An array of diagnostics known on the client side overlapping the range\n  /// provided to the `textDocument/codeAction` request. They are provided so\n  /// that the server knows which errors are currently presented to the user for\n  /// the given range. There is no guarantee that these accurately reflect the\n  /// error state of the resource. The primary parameter to compute code actions\n  /// is the provided range.\n  std::vector<Diagnostic> diagnostics;\n\n  /// Requested kind of actions to return.\n  ///\n  /// Actions not of this kind are filtered out by the client before being\n  /// shown. So servers can omit computing them.\n  std::vector<std::string> only;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionContext &, llvm::json::Path);\n\nstruct CodeActionParams {\n  /// The document in which the command was invoked.\n  TextDocumentIdentifier textDocument;\n\n  /// The range for which the command was invoked.\n  Range range;\n\n  /// Context carrying additional information.\n  CodeActionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionParams &, llvm::json::Path);\n\nstruct WorkspaceEdit {\n  /// Holds changes to existing resources.\n  llvm::Optional<std::map<std::string, std::vector<TextEdit>>> changes;\n\n  /// Note: \"documentChanges\" is not currently used because currently there is\n  /// no support for versioned edits.\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const WorkspaceEdit &WE);\n\n/// Arguments for the 'applyTweak' command. The server sends these commands as a\n/// response to the textDocument/codeAction request. The client can later send a\n/// command back to the server if the user requests to execute a particular code\n/// tweak.\nstruct TweakArgs {\n  /// A file provided by the client on a textDocument/codeAction request.\n  URIForFile file;\n  /// A selection provided by the client on a textDocument/codeAction request.\n  Range selection;\n  /// ID of the tweak that should be executed. Corresponds to Tweak::id().\n  std::string tweakID;\n};\nbool fromJSON(const llvm::json::Value &, TweakArgs &, llvm::json::Path);\nllvm::json::Value toJSON(const TweakArgs &A);\n\nstruct ExecuteCommandParams {\n  /// The identifier of the actual command handler.\n  std::string command;\n\n  // This is `arguments?: []any` in LSP.\n  // All clangd's commands accept a single argument (or none => null).\n  llvm::json::Value argument = nullptr;\n};\nbool fromJSON(const llvm::json::Value &, ExecuteCommandParams &,\n              llvm::json::Path);\n\nstruct Command : public ExecuteCommandParams {\n  std::string title;\n};\nllvm::json::Value toJSON(const Command &C);\n\n/// A code action represents a change that can be performed in code, e.g. to fix\n/// a problem or to refactor code.\n///\n/// A CodeAction must set either `edit` and/or a `command`. If both are\n/// supplied, the `edit` is applied first, then the `command` is executed.\nstruct CodeAction {\n  /// A short, human-readable, title for this code action.\n  std::string title;\n\n  /// The kind of the code action.\n  /// Used to filter code actions.\n  llvm::Optional<std::string> kind;\n  const static llvm::StringLiteral QUICKFIX_KIND;\n  const static llvm::StringLiteral REFACTOR_KIND;\n  const static llvm::StringLiteral INFO_KIND;\n\n  /// The diagnostics that this code action resolves.\n  llvm::Optional<std::vector<Diagnostic>> diagnostics;\n\n  /// Marks this as a preferred action. Preferred actions are used by the\n  /// `auto fix` command and can be targeted by keybindings.\n  /// A quick fix should be marked preferred if it properly addresses the\n  /// underlying error. A refactoring should be marked preferred if it is the\n  /// most reasonable choice of actions to take.\n  bool isPreferred = false;\n\n  /// The workspace edit this code action performs.\n  llvm::Optional<WorkspaceEdit> edit;\n\n  /// A command this code action executes. If a code action provides an edit\n  /// and a command, first the edit is executed and then the command.\n  llvm::Optional<Command> command;\n};\nllvm::json::Value toJSON(const CodeAction &);\n\n/// Represents programming constructs like variables, classes, interfaces etc.\n/// that appear in a document. Document symbols can be hierarchical and they\n/// have two ranges: one that encloses its definition and one that points to its\n/// most interesting range, e.g. the range of an identifier.\nstruct DocumentSymbol {\n  /// The name of this symbol.\n  std::string name;\n\n  /// More detail for this symbol, e.g the signature of a function.\n  std::string detail;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// Indicates if this symbol is deprecated.\n  bool deprecated = false;\n\n  /// The range enclosing this symbol not including leading/trailing whitespace\n  /// but everything else like comments. This information is typically used to\n  /// determine if the clients cursor is inside the symbol to reveal in the\n  /// symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol is being\n  /// picked, e.g the name of a function. Must be contained by the `range`.\n  Range selectionRange;\n\n  /// Children of this symbol, e.g. properties of a class.\n  std::vector<DocumentSymbol> children;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &O, const DocumentSymbol &S);\nllvm::json::Value toJSON(const DocumentSymbol &S);\n\n/// Represents information about programming constructs like variables, classes,\n/// interfaces etc.\nstruct SymbolInformation {\n  /// The name of this symbol.\n  std::string name;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// The location of this symbol.\n  Location location;\n\n  /// The name of the symbol containing this symbol.\n  std::string containerName;\n\n  /// The score that clangd calculates to rank the returned symbols.\n  /// This excludes the fuzzy-matching score between `name` and the query.\n  /// (Specifically, the last ::-separated component).\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension, set only for workspace/symbol responses.\n  llvm::Optional<float> score;\n};\nllvm::json::Value toJSON(const SymbolInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolInformation &);\n\n/// Represents information about identifier.\n/// This is returned from textDocument/symbolInfo, which is a clangd extension.\nstruct SymbolDetails {\n  std::string name;\n\n  std::string containerName;\n\n  /// Unified Symbol Resolution identifier\n  /// This is an opaque string uniquely identifying a symbol.\n  /// Unlike SymbolID, it is variable-length and somewhat human-readable.\n  /// It is a common representation across several clang tools.\n  /// (See USRGeneration.h)\n  std::string USR;\n\n  SymbolID ID;\n};\nllvm::json::Value toJSON(const SymbolDetails &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolDetails &);\nbool operator==(const SymbolDetails &, const SymbolDetails &);\n\n/// The parameters of a Workspace Symbol Request.\nstruct WorkspaceSymbolParams {\n  /// A non-empty query string\n  std::string query;\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceSymbolParams &,\n              llvm::json::Path);\n\nstruct ApplyWorkspaceEditParams {\n  WorkspaceEdit edit;\n};\nllvm::json::Value toJSON(const ApplyWorkspaceEditParams &);\n\nstruct ApplyWorkspaceEditResponse {\n  bool applied = true;\n  llvm::Optional<std::string> failureReason;\n};\nbool fromJSON(const llvm::json::Value &, ApplyWorkspaceEditResponse &,\n              llvm::json::Path);\n\nstruct TextDocumentPositionParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position inside the text document.\n  Position position;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentPositionParams &,\n              llvm::json::Path);\n\nenum class CompletionTriggerKind {\n  /// Completion was triggered by typing an identifier (24x7 code\n  /// complete), manual invocation (e.g Ctrl+Space) or via API.\n  Invoked = 1,\n  /// Completion was triggered by a trigger character specified by\n  /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n  TriggerCharacter = 2,\n  /// Completion was re-triggered as the current completion list is incomplete.\n  TriggerTriggerForIncompleteCompletions = 3\n};\n\nstruct CompletionContext {\n  /// How the completion was triggered.\n  CompletionTriggerKind triggerKind = CompletionTriggerKind::Invoked;\n  /// The trigger character (a single character) that has trigger code complete.\n  /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`\n  std::string triggerCharacter;\n};\nbool fromJSON(const llvm::json::Value &, CompletionContext &, llvm::json::Path);\n\nstruct CompletionParams : TextDocumentPositionParams {\n  CompletionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CompletionParams &, llvm::json::Path);\n\nstruct MarkupContent {\n  MarkupKind kind = MarkupKind::PlainText;\n  std::string value;\n};\nllvm::json::Value toJSON(const MarkupContent &MC);\n\nstruct Hover {\n  /// The hover's content\n  MarkupContent contents;\n\n  /// An optional range is a range inside a text document\n  /// that is used to visualize a hover, e.g. by changing the background color.\n  llvm::Optional<Range> range;\n};\nllvm::json::Value toJSON(const Hover &H);\n\n/// Defines whether the insert text in a completion item should be interpreted\n/// as plain text or a snippet.\nenum class InsertTextFormat {\n  Missing = 0,\n  /// The primary text to be inserted is treated as a plain string.\n  PlainText = 1,\n  /// The primary text to be inserted is treated as a snippet.\n  ///\n  /// A snippet can define tab stops and placeholders with `$1`, `$2`\n  /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to the end\n  /// of the snippet. Placeholders with equal identifiers are linked, that is\n  /// typing in one will update others too.\n  ///\n  /// See also:\n  /// https//github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\n  Snippet = 2,\n};\n\nstruct CompletionItem {\n  /// The label of this completion item. By default also the text that is\n  /// inserted when selecting this completion.\n  std::string label;\n\n  /// The kind of this completion item. Based of the kind an icon is chosen by\n  /// the editor.\n  CompletionItemKind kind = CompletionItemKind::Missing;\n\n  /// A human-readable string with additional information about this item, like\n  /// type or symbol information.\n  std::string detail;\n\n  /// A human-readable string that represents a doc-comment.\n  llvm::Optional<MarkupContent> documentation;\n\n  /// A string that should be used when comparing this item with other items.\n  /// When `falsy` the label is used.\n  std::string sortText;\n\n  /// A string that should be used when filtering a set of completion items.\n  /// When `falsy` the label is used.\n  std::string filterText;\n\n  /// A string that should be inserted to a document when selecting this\n  /// completion. When `falsy` the label is used.\n  std::string insertText;\n\n  /// The format of the insert text. The format applies to both the `insertText`\n  /// property and the `newText` property of a provided `textEdit`.\n  InsertTextFormat insertTextFormat = InsertTextFormat::Missing;\n\n  /// An edit which is applied to a document when selecting this completion.\n  /// When an edit is provided `insertText` is ignored.\n  ///\n  /// Note: The range of the edit must be a single line range and it must\n  /// contain the position at which completion has been requested.\n  llvm::Optional<TextEdit> textEdit;\n\n  /// An optional array of additional text edits that are applied when selecting\n  /// this completion. Edits must not overlap with the main edit nor with\n  /// themselves.\n  std::vector<TextEdit> additionalTextEdits;\n\n  /// Indicates if this item is deprecated.\n  bool deprecated = false;\n\n  /// The score that clangd calculates to rank the returned completions.\n  /// This excludes the fuzzy-match between `filterText` and the partial word.\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension.\n  float score = 0.f;\n\n  // TODO: Add custom commitCharacters for some of the completion items. For\n  // example, it makes sense to use () only for the functions.\n  // TODO(krasimir): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a completion item\n  //              between a completion and a completion resolve request.\n};\nllvm::json::Value toJSON(const CompletionItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const CompletionItem &);\n\nbool operator<(const CompletionItem &, const CompletionItem &);\n\n/// Represents a collection of completion items to be presented in the editor.\nstruct CompletionList {\n  /// The list is not complete. Further typing should result in recomputing the\n  /// list.\n  bool isIncomplete = false;\n\n  /// The completion items.\n  std::vector<CompletionItem> items;\n};\nllvm::json::Value toJSON(const CompletionList &);\n\n/// A single parameter of a particular signature.\nstruct ParameterInformation {\n\n  /// The label of this parameter. Ignored when labelOffsets is set.\n  std::string labelString;\n\n  /// Inclusive start and exclusive end offsets withing the containing signature\n  /// label.\n  /// Offsets are computed by lspLength(), which counts UTF-16 code units by\n  /// default but that can be overriden, see its documentation for details.\n  llvm::Optional<std::pair<unsigned, unsigned>> labelOffsets;\n\n  /// The documentation of this parameter. Optional.\n  std::string documentation;\n};\nllvm::json::Value toJSON(const ParameterInformation &);\n\n/// Represents the signature of something callable.\nstruct SignatureInformation {\n\n  /// The label of this signature. Mandatory.\n  std::string label;\n\n  /// The documentation of this signature. Optional.\n  std::string documentation;\n\n  /// The parameters of this signature.\n  std::vector<ParameterInformation> parameters;\n};\nllvm::json::Value toJSON(const SignatureInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SignatureInformation &);\n\n/// Represents the signature of a callable.\nstruct SignatureHelp {\n\n  /// The resulting signatures.\n  std::vector<SignatureInformation> signatures;\n\n  /// The active signature.\n  int activeSignature = 0;\n\n  /// The active parameter of the active signature.\n  int activeParameter = 0;\n\n  /// Position of the start of the argument list, including opening paren. e.g.\n  /// foo(\"first arg\",   \"second arg\",\n  ///    ^-argListStart   ^-cursor\n  /// This is a clangd-specific extension, it is only available via C++ API and\n  /// not currently serialized for the LSP.\n  Position argListStart;\n};\nllvm::json::Value toJSON(const SignatureHelp &);\n\nstruct RenameParams {\n  /// The document that was opened.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The new name of the symbol.\n  std::string newName;\n};\nbool fromJSON(const llvm::json::Value &, RenameParams &, llvm::json::Path);\n\nenum class DocumentHighlightKind { Text = 1, Read = 2, Write = 3 };\n\n/// A document highlight is a range inside a text document which deserves\n/// special attention. Usually a document highlight is visualized by changing\n/// the background color of its range.\n\nstruct DocumentHighlight {\n  /// The range this highlight applies to.\n  Range range;\n\n  /// The highlight kind, default is DocumentHighlightKind.Text.\n  DocumentHighlightKind kind = DocumentHighlightKind::Text;\n\n  friend bool operator<(const DocumentHighlight &LHS,\n                        const DocumentHighlight &RHS) {\n    int LHSKind = static_cast<int>(LHS.kind);\n    int RHSKind = static_cast<int>(RHS.kind);\n    return std::tie(LHS.range, LHSKind) < std::tie(RHS.range, RHSKind);\n  }\n\n  friend bool operator==(const DocumentHighlight &LHS,\n                         const DocumentHighlight &RHS) {\n    return LHS.kind == RHS.kind && LHS.range == RHS.range;\n  }\n};\nllvm::json::Value toJSON(const DocumentHighlight &DH);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const DocumentHighlight &);\n\nenum class TypeHierarchyDirection { Children = 0, Parents = 1, Both = 2 };\nbool fromJSON(const llvm::json::Value &E, TypeHierarchyDirection &Out,\n              llvm::json::Path);\n\n/// The type hierarchy params is an extension of the\n/// `TextDocumentPositionsParams` with optional properties which can be used to\n/// eagerly resolve the item when requesting from the server.\nstruct TypeHierarchyParams : public TextDocumentPositionParams {\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve = 0;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction = TypeHierarchyDirection::Parents;\n};\nbool fromJSON(const llvm::json::Value &, TypeHierarchyParams &,\n              llvm::json::Path);\n\nstruct TypeHierarchyItem {\n  /// The human readable name of the hierarchy item.\n  std::string name;\n\n  /// Optional detail for the hierarchy item. It can be, for instance, the\n  /// signature of a function or method.\n  llvm::Optional<std::string> detail;\n\n  /// The kind of the hierarchy item. For instance, class or interface.\n  SymbolKind kind;\n\n  /// `true` if the hierarchy item is deprecated. Otherwise, `false`.\n  bool deprecated = false;\n\n  /// The URI of the text document where this type hierarchy item belongs to.\n  URIForFile uri;\n\n  /// The range enclosing this type hierarchy item not including\n  /// leading/trailing whitespace but everything else like comments. This\n  /// information is typically used to determine if the client's cursor is\n  /// inside the type hierarch item to reveal in the symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this type hierarchy\n  /// item is being picked, e.g. the name of a function. Must be contained by\n  /// the `range`.\n  Range selectionRange;\n\n  /// If this type hierarchy item is resolved, it contains the direct parents.\n  /// Could be empty if the item does not have direct parents. If not defined,\n  /// the parents have not been resolved yet.\n  llvm::Optional<std::vector<TypeHierarchyItem>> parents;\n\n  /// If this type hierarchy item is resolved, it contains the direct children\n  /// of the current item. Could be empty if the item does not have any\n  /// descendants. If not defined, the children have not been resolved.\n  llvm::Optional<std::vector<TypeHierarchyItem>> children;\n\n  /// An optional 'data' field, which can be used to identify a type hierarchy\n  /// item in a resolve request.\n  llvm::Optional<std::string> data;\n};\nllvm::json::Value toJSON(const TypeHierarchyItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TypeHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, TypeHierarchyItem &, llvm::json::Path);\n\n/// Parameters for the `typeHierarchy/resolve` request.\nstruct ResolveTypeHierarchyItemParams {\n  /// The item to resolve.\n  TypeHierarchyItem item;\n\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction;\n};\nbool fromJSON(const llvm::json::Value &, ResolveTypeHierarchyItemParams &,\n              llvm::json::Path);\n\nenum class SymbolTag { Deprecated = 1 };\nllvm::json::Value toJSON(SymbolTag);\n\n/// The parameter of a `textDocument/prepareCallHierarchy` request.\nstruct CallHierarchyPrepareParams : public TextDocumentPositionParams {};\n\n/// Represents programming constructs like functions or constructors\n/// in the context of call hierarchy.\nstruct CallHierarchyItem {\n  /// The name of this item.\n  std::string name;\n\n  /// The kind of this item.\n  SymbolKind kind;\n\n  /// Tags for this item.\n  std::vector<SymbolTag> tags;\n\n  /// More detaill for this item, e.g. the signature of a function.\n  std::string detail;\n\n  /// The resource identifier of this item.\n  URIForFile uri;\n\n  /// The range enclosing this symbol not including leading / trailing\n  /// whitespace but everything else, e.g. comments and code.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol\n  /// is being picked, e.g. the name of a function.\n  /// Must be contained by `Rng`.\n  Range selectionRange;\n\n  /// An optional 'data' field, which can be used to identify a call\n  /// hierarchy item in an incomingCalls or outgoingCalls request.\n  std::string data;\n};\nllvm::json::Value toJSON(const CallHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, CallHierarchyItem &, llvm::json::Path);\n\n/// The parameter of a `callHierarchy/incomingCalls` request.\nstruct CallHierarchyIncomingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyIncomingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an incoming call, e.g. a caller of a method or constructor.\nstruct CallHierarchyIncomingCall {\n  /// The item that makes the call.\n  CallHierarchyItem from;\n\n  /// The range at which the calls appear.\n  /// This is relative to the caller denoted by `From`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyIncomingCall &);\n\n/// The parameter of a `callHierarchy/outgoingCalls` request.\nstruct CallHierarchyOutgoingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyOutgoingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an outgoing call, e.g. calling a getter from a method or\n/// a method from a constructor etc.\nstruct CallHierarchyOutgoingCall {\n  /// The item that is called.\n  CallHierarchyItem to;\n\n  /// The range at which this item is called.\n  /// This is the range relative to the caller, and not `To`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyOutgoingCall &);\n\nstruct ReferenceContext {\n  /// Include the declaration of the current symbol.\n  bool includeDeclaration = false;\n};\n\nstruct ReferenceParams : public TextDocumentPositionParams {\n  ReferenceContext context;\n};\nbool fromJSON(const llvm::json::Value &, ReferenceParams &, llvm::json::Path);\n\n/// Clangd extension: indicates the current state of the file in clangd,\n/// sent from server via the `textDocument/clangd.fileStatus` notification.\nstruct FileStatus {\n  /// The text document's URI.\n  URIForFile uri;\n  /// The human-readable string presents the current state of the file, can be\n  /// shown in the UI (e.g. status bar).\n  std::string state;\n  // FIXME: add detail messages.\n};\nllvm::json::Value toJSON(const FileStatus &);\n\n/// Specifies a single semantic token in the document.\n/// This struct is not part of LSP, which just encodes lists of tokens as\n/// arrays of numbers directly.\nstruct SemanticToken {\n  /// token line number, relative to the previous token\n  unsigned deltaLine = 0;\n  /// token start character, relative to the previous token\n  /// (relative to 0 or the previous token's start if they are on the same line)\n  unsigned deltaStart = 0;\n  /// the length of the token. A token cannot be multiline\n  unsigned length = 0;\n  /// will be looked up in `SemanticTokensLegend.tokenTypes`\n  unsigned tokenType = 0;\n  /// each set bit will be looked up in `SemanticTokensLegend.tokenModifiers`\n  unsigned tokenModifiers = 0;\n};\nbool operator==(const SemanticToken &, const SemanticToken &);\n\n/// A versioned set of tokens.\nstruct SemanticTokens {\n  // An optional result id. If provided and clients support delta updating\n  // the client will include the result id in the next semantic token request.\n  // A server can then instead of computing all semantic tokens again simply\n  // send a delta.\n  std::string resultId;\n\n  /// The actual tokens.\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array.\n};\nllvm::json::Value toJSON(const SemanticTokens &);\n\n/// Body of textDocument/semanticTokens/full request.\nstruct SemanticTokensParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, SemanticTokensParams &,\n              llvm::json::Path);\n\n/// Body of textDocument/semanticTokens/full/delta request.\n/// Requests the changes in semantic tokens since a previous response.\nstruct SemanticTokensDeltaParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n  /// The previous result id.\n  std::string previousResultId;\n};\nbool fromJSON(const llvm::json::Value &Params, SemanticTokensDeltaParams &R,\n              llvm::json::Path);\n\n/// Describes a a replacement of a contiguous range of semanticTokens.\nstruct SemanticTokensEdit {\n  // LSP specifies `start` and `deleteCount` which are relative to the array\n  // encoding of the previous tokens.\n  // We use token counts instead, and translate when serializing this struct.\n  unsigned startToken = 0;\n  unsigned deleteTokens = 0;\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array\n};\nllvm::json::Value toJSON(const SemanticTokensEdit &);\n\n/// This models LSP SemanticTokensDelta | SemanticTokens, which is the result of\n/// textDocument/semanticTokens/full/delta.\nstruct SemanticTokensOrDelta {\n  std::string resultId;\n  /// Set if we computed edits relative to a previous set of tokens.\n  llvm::Optional<std::vector<SemanticTokensEdit>> edits;\n  /// Set if we computed a fresh set of tokens.\n  llvm::Optional<std::vector<SemanticToken>> tokens; // encoded as integer array\n};\nllvm::json::Value toJSON(const SemanticTokensOrDelta &);\n\nstruct SelectionRangeParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The positions inside the text document.\n  std::vector<Position> positions;\n};\nbool fromJSON(const llvm::json::Value &, SelectionRangeParams &,\n              llvm::json::Path);\n\nstruct SelectionRange {\n  /**\n   * The range of this selection range.\n   */\n  Range range;\n  /**\n   * The parent selection range containing this range. Therefore `parent.range`\n   * must contain `this.range`.\n   */\n  std::unique_ptr<SelectionRange> parent;\n};\nllvm::json::Value toJSON(const SelectionRange &);\n\n/// Parameters for the document link request.\nstruct DocumentLinkParams {\n  /// The document to provide document links for.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentLinkParams &,\n              llvm::json::Path);\n\n/// A range in a text document that links to an internal or external resource,\n/// like another text document or a web site.\nstruct DocumentLink {\n  /// The range this link applies to.\n  Range range;\n\n  /// The uri this link points to. If missing a resolve request is sent later.\n  URIForFile target;\n\n  // TODO(forster): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a document link\n  //              between a DocumentLinkRequest and a\n  //              DocumentLinkResolveRequest.\n\n  friend bool operator==(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return LHS.range == RHS.range && LHS.target == RHS.target;\n  }\n\n  friend bool operator!=(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return !(LHS == RHS);\n  }\n};\nllvm::json::Value toJSON(const DocumentLink &DocumentLink);\n\n// FIXME(kirillbobyrev): Add FoldingRangeClientCapabilities so we can support\n// per-line-folding editors.\nstruct FoldingRangeParams {\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, FoldingRangeParams &,\n              llvm::json::Path);\n\n/// Stores information about a region of code that can be folded.\nstruct FoldingRange {\n  unsigned startLine = 0;\n  unsigned startCharacter;\n  unsigned endLine = 0;\n  unsigned endCharacter;\n  llvm::Optional<std::string> kind;\n};\nllvm::json::Value toJSON(const FoldingRange &Range);\n\n/// Keys starting with an underscore(_) represent leaves, e.g. _total or _self\n/// for memory usage of whole subtree or only that specific node in bytes. All\n/// other keys represents children. An example:\n///   {\n///     \"_self\": 0,\n///     \"_total\": 8,\n///     \"child1\": {\n///       \"_self\": 4,\n///       \"_total\": 4,\n///     }\n///     \"child2\": {\n///       \"_self\": 2,\n///       \"_total\": 4,\n///       \"child_deep\": {\n///         \"_self\": 2,\n///         \"_total\": 2,\n///       }\n///     }\n///   }\nllvm::json::Value toJSON(const MemoryTree &MT);\n\n/// Payload for textDocument/ast request.\n/// This request is a clangd extension.\nstruct ASTParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position of the node to be dumped.\n  /// The highest-level node that entirely contains the range will be returned.\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, ASTParams &, llvm::json::Path);\n\n/// Simplified description of a clang AST node.\n/// This is clangd's internal representation of C++ code.\nstruct ASTNode {\n  /// The general kind of node, such as \"expression\"\n  /// Corresponds to the base AST node type such as Expr.\n  std::string role;\n  /// The specific kind of node this is, such as \"BinaryOperator\".\n  /// This is usually a concrete node class (with Expr etc suffix dropped).\n  /// When there's no hierarchy (e.g. TemplateName), the variant (NameKind).\n  std::string kind;\n  /// Brief additional information, such as \"||\" for the particular operator.\n  /// The information included depends on the node kind, and may be empty.\n  std::string detail;\n  /// A one-line dump of detailed information about the node.\n  /// This includes role/kind/description information, but is rather cryptic.\n  /// It is similar to the output from `clang -Xclang -ast-dump`.\n  /// May be empty for certain types of nodes.\n  std::string arcana;\n  /// The range of the original source file covered by this node.\n  /// May be missing for implicit nodes, or those created by macro expansion.\n  llvm::Optional<Range> range;\n  /// Nodes nested within this one, such as the operands of a BinaryOperator.\n  std::vector<ASTNode> children;\n};\nllvm::json::Value toJSON(const ASTNode &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const ASTNode &);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct format_provider<clang::clangd::Position> {\n  static void format(const clang::clangd::Position &Pos, raw_ostream &OS,\n                     StringRef Style) {\n    assert(Style.empty() && \"style modifiers for this type are not supported\");\n    OS << Pos;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "content": "//===--- URI.h - File URIs with schemes --------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// A URI describes the location of a source file.\n/// In the simplest case, this is a \"file\" URI that directly encodes the\n/// absolute path to a file. More abstract cases are possible: a shared index\n/// service might expose repo:// URIs that are relative to the source control\n/// root.\n///\n/// Clangd handles URIs of the form <scheme>:[//<authority>]<body>. It doesn't\n/// further split the authority or body into constituent parts (e.g. query\n/// strings is included in the body).\nclass URI {\npublic:\n  URI(llvm::StringRef Scheme, llvm::StringRef Authority, llvm::StringRef Body);\n\n  /// Returns decoded scheme e.g. \"https\"\n  llvm::StringRef scheme() const { return Scheme; }\n  /// Returns decoded authority e.g. \"reviews.lvm.org\"\n  llvm::StringRef authority() const { return Authority; }\n  /// Returns decoded body e.g. \"/D41946\"\n  llvm::StringRef body() const { return Body; }\n\n  /// Returns a string URI with all components percent-encoded.\n  std::string toString() const;\n\n  /// Creates a URI for a file in the given scheme. \\p Scheme must be\n  /// registered. The URI is percent-encoded.\n  static llvm::Expected<URI> create(llvm::StringRef AbsolutePath,\n                                    llvm::StringRef Scheme);\n\n  // Similar to above except this picks a registered scheme that works. If none\n  // works, this falls back to \"file\" scheme.\n  static URI create(llvm::StringRef AbsolutePath);\n\n  /// This creates a file:// URI for \\p AbsolutePath. The path must be absolute.\n  static URI createFile(llvm::StringRef AbsolutePath);\n\n  /// Parse a URI string \"<scheme>:[//<authority>/]<path>\". Percent-encoded\n  /// characters in the URI will be decoded.\n  static llvm::Expected<URI> parse(llvm::StringRef Uri);\n\n  /// Resolves the absolute path of \\p U. If there is no matching scheme, or the\n  /// URI is invalid in the scheme, this returns an error.\n  ///\n  /// \\p HintPath A related path, such as the current file or working directory,\n  /// which can help disambiguate when the same file exists in many workspaces.\n  static llvm::Expected<std::string> resolve(const URI &U,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Same as above, in addition it parses the \\p FileURI using URI::parse.\n  static llvm::Expected<std::string> resolve(llvm::StringRef FileURI,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Resolves \\p AbsPath into a canonical path of its URI, by converting\n  /// \\p AbsPath to URI and resolving the URI to get th canonical path.\n  /// This ensures that paths with the same URI are resolved into consistent\n  /// file path.\n  static llvm::Expected<std::string> resolvePath(llvm::StringRef AbsPath,\n                                                 llvm::StringRef HintPath = \"\");\n\n  /// Gets the preferred spelling of this file for #include, if there is one,\n  /// e.g. <system_header.h>, \"path/to/x.h\".\n  ///\n  /// This allows URI schemas to provide their customized include paths.\n  ///\n  /// Returns an empty string if normal include-shortening based on the absolute\n  /// path should be used.\n  /// Fails if the URI is not valid in the schema.\n  static llvm::Expected<std::string> includeSpelling(const URI &U);\n\n  friend bool operator==(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) ==\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\n  friend bool operator<(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) <\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\nprivate:\n  URI() = default;\n\n  std::string Scheme;\n  std::string Authority;\n  std::string Body;\n};\n\n/// URIScheme is an extension point for teaching clangd to recognize a custom\n/// URI scheme. This is expected to be implemented and exposed via the\n/// URISchemeRegistry.\nclass URIScheme {\npublic:\n  virtual ~URIScheme() = default;\n\n  /// Returns the absolute path of the file corresponding to the URI\n  /// authority+body in the file system. See URI::resolve for semantics of\n  /// \\p HintPath.\n  virtual llvm::Expected<std::string>\n  getAbsolutePath(llvm::StringRef Authority, llvm::StringRef Body,\n                  llvm::StringRef HintPath) const = 0;\n\n  virtual llvm::Expected<URI>\n  uriFromAbsolutePath(llvm::StringRef AbsolutePath) const = 0;\n\n  /// Returns the include path of the file (e.g. <path>, \"path\"), which can be\n  /// #included directly. See URI::includeSpelling for details.\n  virtual llvm::Expected<std::string> getIncludeSpelling(const URI &U) const {\n    return \"\"; // no customized include path for this scheme.\n  }\n};\n\n/// By default, a \"file\" scheme is supported where URI paths are always absolute\n/// in the file system.\ntypedef llvm::Registry<URIScheme> URISchemeRegistry;\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "content": "//===--- Ref.h ---------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <set>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\n/// Describes the kind of a cross-reference.\n///\n/// This is a bitfield which can be combined from different kinds.\nenum class RefKind : uint8_t {\n  Unknown = 0,\n  // Points to symbol declaration. Example:\n  //\n  // class Foo;\n  //       ^ Foo declaration\n  // Foo foo;\n  // ^ this does not reference Foo declaration\n  Declaration = 1 << 0,\n  // Points to symbol definition. Example:\n  //\n  // int foo();\n  //     ^ references foo declaration, but not foo definition\n  // int foo() { return 42; }\n  //     ^ references foo definition, but not declaration\n  // bool bar() { return true; }\n  //      ^ references both definition and declaration\n  Definition = 1 << 1,\n  // Points to symbol reference. Example:\n  //\n  // int Foo = 42;\n  // int Bar = Foo + 1;\n  //           ^ this is a reference to Foo\n  Reference = 1 << 2,\n  // The reference explicitly spells out declaration's name. Such references can\n  // not come from macro expansions or implicit AST nodes.\n  //\n  // class Foo { public: Foo() {} };\n  //       ^ references declaration, definition and explicitly spells out name\n  // #define MACRO Foo\n  //     v there is an implicit constructor call here which is not a spelled ref\n  // Foo foo;\n  // ^ this reference explicitly spells out Foo's name\n  // struct Bar {\n  //   MACRO Internal;\n  //   ^ this references Foo, but does not explicitly spell out its name\n  // };\n  Spelled = 1 << 3,\n  All = Declaration | Definition | Reference | Spelled,\n};\n\ninline RefKind operator|(RefKind L, RefKind R) {\n  return static_cast<RefKind>(static_cast<uint8_t>(L) |\n                              static_cast<uint8_t>(R));\n}\ninline RefKind &operator|=(RefKind &L, RefKind R) { return L = L | R; }\ninline RefKind operator&(RefKind A, RefKind B) {\n  return static_cast<RefKind>(static_cast<uint8_t>(A) &\n                              static_cast<uint8_t>(B));\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, RefKind);\n\n/// Represents a symbol occurrence in the source file.\n/// Despite the name, it could be a declaration/definition/reference.\n///\n/// WARNING: Location does not own the underlying data - Copies are shallow.\nstruct Ref {\n  /// The source location where the symbol is named.\n  SymbolLocation Location;\n  RefKind Kind = RefKind::Unknown;\n  /// The ID of the symbol whose definition contains this reference.\n  /// For example, for a reference inside a function body, this would\n  /// be that function. For top-level definitions this isNull().\n  SymbolID Container;\n};\n\ninline bool operator<(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) <\n         std::tie(R.Location, R.Kind, R.Container);\n}\ninline bool operator==(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) ==\n         std::tie(R.Location, R.Kind, R.Container);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Ref &);\n\n/// An efficient structure of storing large set of symbol references in memory.\n/// Filenames are deduplicated.\nclass RefSlab {\npublic:\n  // Refs are stored in order.\n  using value_type = std::pair<SymbolID, llvm::ArrayRef<Ref>>;\n  using const_iterator = std::vector<value_type>::const_iterator;\n  using iterator = const_iterator;\n\n  RefSlab() = default;\n  RefSlab(RefSlab &&Slab) = default;\n  RefSlab &operator=(RefSlab &&RHS) = default;\n\n  const_iterator begin() const { return Refs.begin(); }\n  const_iterator end() const { return Refs.end(); }\n  /// Gets the number of symbols.\n  size_t size() const { return Refs.size(); }\n  size_t numRefs() const { return NumRefs; }\n  bool empty() const { return Refs.empty(); }\n\n  size_t bytes() const {\n    return sizeof(*this) + Arena.getTotalMemory() +\n           sizeof(value_type) * Refs.capacity();\n  }\n\n  /// RefSlab::Builder is a mutable container that can 'freeze' to RefSlab.\n  class Builder {\n  public:\n    Builder() : UniqueStrings(Arena) {}\n    /// Adds a ref to the slab. Deep copy: Strings will be owned by the slab.\n    void insert(const SymbolID &ID, const Ref &S);\n    /// Consumes the builder to finalize the slab.\n    RefSlab build() &&;\n\n  private:\n    // A ref we're storing with its symbol to consume with build().\n    // All strings are interned, so DenseMapInfo can use pointer comparisons.\n    struct Entry {\n      SymbolID Symbol;\n      Ref Reference;\n    };\n    friend struct llvm::DenseMapInfo<Entry>;\n\n    llvm::BumpPtrAllocator Arena;\n    llvm::UniqueStringSaver UniqueStrings; // Contents on the arena.\n    llvm::DenseSet<Entry> Entries;\n  };\n\nprivate:\n  RefSlab(std::vector<value_type> Refs, llvm::BumpPtrAllocator Arena,\n          size_t NumRefs)\n      : Arena(std::move(Arena)), Refs(std::move(Refs)), NumRefs(NumRefs) {}\n\n  llvm::BumpPtrAllocator Arena;\n  std::vector<value_type> Refs;\n  /// Number of all references.\n  size_t NumRefs = 0;\n};\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct DenseMapInfo<clang::clangd::RefSlab::Builder::Entry> {\n  using Entry = clang::clangd::RefSlab::Builder::Entry;\n  static inline Entry getEmptyKey() {\n    static Entry E{clang::clangd::SymbolID(\"\"), {}};\n    return E;\n  }\n  static inline Entry getTombstoneKey() {\n    static Entry E{clang::clangd::SymbolID(\"TOMBSTONE\"), {}};\n    return E;\n  }\n  static unsigned getHashValue(const Entry &Val) {\n    return llvm::hash_combine(\n        Val.Symbol, reinterpret_cast<uintptr_t>(Val.Reference.Location.FileURI),\n        Val.Reference.Location.Start.rep(), Val.Reference.Location.End.rep());\n  }\n  static bool isEqual(const Entry &LHS, const Entry &RHS) {\n    return std::tie(LHS.Symbol, LHS.Reference.Location.FileURI,\n                    LHS.Reference.Kind) ==\n               std::tie(RHS.Symbol, RHS.Reference.Location.FileURI,\n                        RHS.Reference.Kind) &&\n           LHS.Reference.Location.Start == RHS.Reference.Location.Start &&\n           LHS.Reference.Location.End == RHS.Reference.Location.End;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "content": "//===--- SymbolID.h ----------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLID_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLID_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <array>\n#include <cstdint>\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\n// The class identifies a particular C++ symbol (class, function, method, etc).\n//\n// As USRs (Unified Symbol Resolution) could be large, especially for functions\n// with long type arguments, SymbolID is using truncated SHA1(USR) values to\n// guarantee the uniqueness of symbols while using a relatively small amount of\n// memory (vs storing USRs directly).\n//\n// SymbolID can be used as key in the symbol indexes to lookup the symbol.\nclass SymbolID {\npublic:\n  SymbolID() = default;\n  explicit SymbolID(llvm::StringRef USR);\n\n  bool operator==(const SymbolID &Sym) const {\n    return HashValue == Sym.HashValue;\n  }\n  bool operator!=(const SymbolID &Sym) const {\n    return !(*this == Sym);\n  }\n  bool operator<(const SymbolID &Sym) const {\n    return HashValue < Sym.HashValue;\n  }\n\n  // The stored hash is truncated to RawSize bytes.\n  // This trades off memory against the number of symbols we can handle.\n  constexpr static size_t RawSize = 8;\n  llvm::StringRef raw() const;\n  static SymbolID fromRaw(llvm::StringRef);\n\n  // Returns a hex encoded string.\n  std::string str() const;\n  static llvm::Expected<SymbolID> fromStr(llvm::StringRef);\n\n  bool isNull() const { return *this == SymbolID(); }\n  explicit operator bool() const { return !isNull(); }\n\nprivate:\n  std::array<uint8_t, RawSize> HashValue{};\n};\n\nllvm::hash_code hash_value(const SymbolID &ID);\n\n// Write SymbolID into the given stream. SymbolID is encoded as ID.str().\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const SymbolID &ID);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\n// Support SymbolIDs as DenseMap keys.\ntemplate <> struct DenseMapInfo<clang::clangd::SymbolID> {\n  static inline clang::clangd::SymbolID getEmptyKey() {\n    static clang::clangd::SymbolID EmptyKey(\"EMPTYKEY\");\n    return EmptyKey;\n  }\n  static inline clang::clangd::SymbolID getTombstoneKey() {\n    static clang::clangd::SymbolID TombstoneKey(\"TOMBSTONEKEY\");\n    return TombstoneKey;\n  }\n  static unsigned getHashValue(const clang::clangd::SymbolID &Sym) {\n    return hash_value(Sym);\n  }\n  static bool isEqual(const clang::clangd::SymbolID &LHS,\n                      const clang::clangd::SymbolID &RHS) {\n    return LHS == RHS;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLID_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "content": "//===--- SymbolLocation.h ----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\nstruct SymbolLocation {\n  // Specify a position (Line, Column) of symbol. Using Line/Column allows us to\n  // build LSP responses without reading the file content.\n  //\n  // clangd uses the following definitions, which differ slightly from LSP:\n  //  - Line is the number of newline characters (\\n) before the point.\n  //  - Column is (by default) the number of UTF-16 code between the last \\n\n  //    (or start of file) and the point.\n  //    If the `offsetEncoding` protocol extension is used to negotiate UTF-8,\n  //    then it is instead the number of *bytes* since the last \\n.\n  //\n  // Position is encoded into 32 bits to save space.\n  // If Line/Column overflow, the value will be their maximum value.\n  struct Position {\n    Position() : LineColumnPacked(0) {}\n    void setLine(uint32_t Line);\n    uint32_t line() const { return LineColumnPacked >> ColumnBits; }\n    void setColumn(uint32_t Column);\n    uint32_t column() const { return LineColumnPacked & MaxColumn; }\n    uint32_t rep() const { return LineColumnPacked; }\n\n    bool hasOverflow() const {\n      return line() == MaxLine || column() == MaxColumn;\n    }\n\n    static constexpr unsigned ColumnBits = 12;\n    static constexpr uint32_t MaxLine = (1 << (32 - ColumnBits)) - 1;\n    static constexpr uint32_t MaxColumn = (1 << ColumnBits) - 1;\n\n  private:\n    uint32_t LineColumnPacked; // Top 20 bit line, bottom 12 bits column.\n  };\n\n  /// The symbol range, using half-open range [Start, End).\n  Position Start;\n  Position End;\n\n  explicit operator bool() const { return !llvm::StringRef(FileURI).empty(); }\n\n  // The URI of the source file where a symbol occurs.\n  // The string must be null-terminated.\n  //\n  // We avoid using llvm::StringRef here to save memory.\n  // WARNING: unless you know what you are doing, it is recommended to use it\n  // via llvm::StringRef.\n  const char *FileURI = \"\";\n};\n\ninline bool operator==(const SymbolLocation::Position &L,\n                       const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) ==\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator<(const SymbolLocation::Position &L,\n                      const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) <\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator==(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  return !std::strcmp(L.FileURI, R.FileURI) &&\n         std::tie(L.Start, L.End) == std::tie(R.Start, R.End);\n}\ninline bool operator<(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  int Cmp = std::strcmp(L.FileURI, R.FileURI);\n  if (Cmp != 0)\n    return Cmp < 0;\n  return std::tie(L.Start, L.End) < std::tie(R.Start, R.End);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolLocation &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "content": "//===--- Threading.h - Abstractions for multithreading -----------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n\n#include \"support/Context.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <cassert>\n#include <condition_variable>\n#include <future>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A threadsafe flag that is initially clear.\nclass Notification {\npublic:\n  // Sets the flag. No-op if already set.\n  void notify();\n  // Blocks until flag is set.\n  void wait() const;\n\nprivate:\n  bool Notified = false;\n  mutable std::condition_variable CV;\n  mutable std::mutex Mu;\n};\n\n/// Limits the number of threads that can acquire the lock at the same time.\nclass Semaphore {\npublic:\n  Semaphore(std::size_t MaxLocks);\n\n  bool try_lock();\n  void lock();\n  void unlock();\n\nprivate:\n  std::mutex Mutex;\n  std::condition_variable SlotsChanged;\n  std::size_t FreeSlots;\n};\n\n/// A point in time we can wait for.\n/// Can be zero (don't wait) or infinity (wait forever).\n/// (Not time_point::max(), because many std::chrono implementations overflow).\nclass Deadline {\npublic:\n  Deadline(std::chrono::steady_clock::time_point Time)\n      : Type(Finite), Time(Time) {}\n  static Deadline zero() { return Deadline(Zero); }\n  static Deadline infinity() { return Deadline(Infinite); }\n\n  std::chrono::steady_clock::time_point time() const {\n    assert(Type == Finite);\n    return Time;\n  }\n  bool expired() const {\n    return (Type == Zero) ||\n           (Type == Finite && Time < std::chrono::steady_clock::now());\n  }\n  bool operator==(const Deadline &Other) const {\n    return (Type == Other.Type) && (Type != Finite || Time == Other.Time);\n  }\n\nprivate:\n  enum Type { Zero, Infinite, Finite };\n\n  Deadline(enum Type Type) : Type(Type) {}\n  enum Type Type;\n  std::chrono::steady_clock::time_point Time;\n};\n\n/// Makes a deadline from a timeout in seconds. None means wait forever.\nDeadline timeoutSeconds(llvm::Optional<double> Seconds);\n/// Wait once on CV for the specified duration.\nvoid wait(std::unique_lock<std::mutex> &Lock, std::condition_variable &CV,\n          Deadline D);\n/// Waits on a condition variable until F() is true or D expires.\ntemplate <typename Func>\nLLVM_NODISCARD bool wait(std::unique_lock<std::mutex> &Lock,\n                         std::condition_variable &CV, Deadline D, Func F) {\n  while (!F()) {\n    if (D.expired())\n      return false;\n    wait(Lock, CV, D);\n  }\n  return true;\n}\n\n/// Runs tasks on separate (detached) threads and wait for all tasks to finish.\n/// Objects that need to spawn threads can own an AsyncTaskRunner to ensure they\n/// all complete on destruction.\nclass AsyncTaskRunner {\npublic:\n  /// Destructor waits for all pending tasks to finish.\n  ~AsyncTaskRunner();\n\n  void wait() const { (void)wait(Deadline::infinity()); }\n  LLVM_NODISCARD bool wait(Deadline D) const;\n  // The name is used for tracing and debugging (e.g. to name a spawned thread).\n  void runAsync(const llvm::Twine &Name, llvm::unique_function<void()> Action);\n\nprivate:\n  mutable std::mutex Mutex;\n  mutable std::condition_variable TasksReachedZero;\n  std::size_t InFlightTasks = 0;\n};\n\n/// Runs \\p Action asynchronously with a new std::thread. The context will be\n/// propagated.\ntemplate <typename T>\nstd::future<T> runAsync(llvm::unique_function<T()> Action) {\n  return std::async(\n      std::launch::async,\n      [](llvm::unique_function<T()> &&Action, Context Ctx) {\n        WithContext WithCtx(std::move(Ctx));\n        return Action();\n      },\n      std::move(Action), Context::current().clone());\n}\n\n/// Memoize is a cache to store and reuse computation results based on a key.\n///\n///   Memoize<DenseMap<int, bool>> PrimeCache;\n///   for (int I : RepetitiveNumbers)\n///     if (PrimeCache.get(I, [&] { return expensiveIsPrime(I); }))\n///       llvm::errs() << \"Prime: \" << I << \"\\n\";\n///\n/// The computation will only be run once for each key.\n/// This class is threadsafe. Concurrent calls for the same key may run the\n/// computation multiple times, but each call will return the same result.\ntemplate <typename Container> class Memoize {\n  mutable Container Cache;\n  std::unique_ptr<std::mutex> Mu;\n\npublic:\n  Memoize() : Mu(std::make_unique<std::mutex>()) {}\n\n  template <typename T, typename Func>\n  typename Container::mapped_type get(T &&Key, Func Compute) const {\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto It = Cache.find(Key);\n      if (It != Cache.end())\n        return It->second;\n    }\n    // Don't hold the mutex while computing.\n    auto V = Compute();\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto R = Cache.try_emplace(std::forward<T>(Key), V);\n      // Insert into cache may fail if we raced with another thread.\n      if (!R.second)\n        return R.first->second; // Canonical value, from other thread.\n    }\n    return V;\n  }\n};\n\n/// Used to guard an operation that should run at most every N seconds.\n///\n/// Usage:\n///   mutable PeriodicThrottler ShouldLog(std::chrono::seconds(1));\n///   void calledFrequently() {\n///     if (ShouldLog())\n///       log(\"this is not spammy\");\n///   }\n///\n/// This class is threadsafe. If multiple threads are involved, then the guarded\n/// operation still needs to be threadsafe!\nclass PeriodicThrottler {\n  using Stopwatch = std::chrono::steady_clock;\n  using Rep = Stopwatch::duration::rep;\n\n  Rep Period;\n  std::atomic<Rep> Next;\n\npublic:\n  /// If Period is zero, the throttler will return true every time.\n  PeriodicThrottler(Stopwatch::duration Period, Stopwatch::duration Delay = {})\n      : Period(Period.count()),\n        Next((Stopwatch::now() + Delay).time_since_epoch().count()) {}\n\n  /// Returns whether the operation should run at this time.\n  /// operator() is safe to call concurrently.\n  bool operator()();\n};\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "content": "//===--- APValue.h - Union class for APFloat/APSInt/Complex -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the APValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_APVALUE_H\n#define LLVM_CLANG_AST_APVALUE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/APFixedPoint.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace clang {\nnamespace serialization {\ntemplate <typename T> class BasicReaderBase;\n} // end namespace serialization\n\n  class AddrLabelExpr;\n  class ASTContext;\n  class CharUnits;\n  class CXXRecordDecl;\n  class Decl;\n  class DiagnosticBuilder;\n  class Expr;\n  class FieldDecl;\n  struct PrintingPolicy;\n  class Type;\n  class ValueDecl;\n  class QualType;\n\n/// Symbolic representation of typeid(T) for some type T.\nclass TypeInfoLValue {\n  const Type *T;\n\npublic:\n  TypeInfoLValue() : T() {}\n  explicit TypeInfoLValue(const Type *T);\n\n  const Type *getType() const { return T; }\n  explicit operator bool() const { return T; }\n\n  void *getOpaqueValue() { return const_cast<Type*>(T); }\n  static TypeInfoLValue getFromOpaqueValue(void *Value) {\n    TypeInfoLValue V;\n    V.T = reinterpret_cast<const Type*>(Value);\n    return V;\n  }\n\n  void print(llvm::raw_ostream &Out, const PrintingPolicy &Policy) const;\n};\n\n/// Symbolic representation of a dynamic allocation.\nclass DynamicAllocLValue {\n  unsigned Index;\n\npublic:\n  DynamicAllocLValue() : Index(0) {}\n  explicit DynamicAllocLValue(unsigned Index) : Index(Index + 1) {}\n  unsigned getIndex() { return Index - 1; }\n\n  explicit operator bool() const { return Index != 0; }\n\n  void *getOpaqueValue() {\n    return reinterpret_cast<void *>(static_cast<uintptr_t>(Index)\n                                    << NumLowBitsAvailable);\n  }\n  static DynamicAllocLValue getFromOpaqueValue(void *Value) {\n    DynamicAllocLValue V;\n    V.Index = reinterpret_cast<uintptr_t>(Value) >> NumLowBitsAvailable;\n    return V;\n  }\n\n  static unsigned getMaxIndex() {\n    return (std::numeric_limits<unsigned>::max() >> NumLowBitsAvailable) - 1;\n  }\n\n  static constexpr int NumLowBitsAvailable = 3;\n};\n}\n\nnamespace llvm {\ntemplate<> struct PointerLikeTypeTraits<clang::TypeInfoLValue> {\n  static void *getAsVoidPointer(clang::TypeInfoLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::TypeInfoLValue getFromVoidPointer(void *P) {\n    return clang::TypeInfoLValue::getFromOpaqueValue(P);\n  }\n  // Validated by static_assert in APValue.cpp; hardcoded to avoid needing\n  // to include Type.h.\n  static constexpr int NumLowBitsAvailable = 3;\n};\n\ntemplate<> struct PointerLikeTypeTraits<clang::DynamicAllocLValue> {\n  static void *getAsVoidPointer(clang::DynamicAllocLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::DynamicAllocLValue getFromVoidPointer(void *P) {\n    return clang::DynamicAllocLValue::getFromOpaqueValue(P);\n  }\n  static constexpr int NumLowBitsAvailable =\n      clang::DynamicAllocLValue::NumLowBitsAvailable;\n};\n}\n\nnamespace clang {\n/// APValue - This class implements a discriminated union of [uninitialized]\n/// [APSInt] [APFloat], [Complex APSInt] [Complex APFloat], [Expr + Offset],\n/// [Vector: N * APValue], [Array: N * APValue]\nclass APValue {\n  typedef llvm::APFixedPoint APFixedPoint;\n  typedef llvm::APSInt APSInt;\n  typedef llvm::APFloat APFloat;\npublic:\n  enum ValueKind {\n    /// There is no such object (it's outside its lifetime).\n    None,\n    /// This object has an indeterminate value (C++ [basic.indet]).\n    Indeterminate,\n    Int,\n    Float,\n    FixedPoint,\n    ComplexInt,\n    ComplexFloat,\n    LValue,\n    Vector,\n    Array,\n    Struct,\n    Union,\n    MemberPointer,\n    AddrLabelDiff\n  };\n\n  class LValueBase {\n    typedef llvm::PointerUnion<const ValueDecl *, const Expr *, TypeInfoLValue,\n                               DynamicAllocLValue>\n        PtrTy;\n\n  public:\n    LValueBase() : Local{} {}\n    LValueBase(const ValueDecl *P, unsigned I = 0, unsigned V = 0);\n    LValueBase(const Expr *P, unsigned I = 0, unsigned V = 0);\n    static LValueBase getDynamicAlloc(DynamicAllocLValue LV, QualType Type);\n    static LValueBase getTypeInfo(TypeInfoLValue LV, QualType TypeInfo);\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    template <class T>\n    bool is() const { return Ptr.is<T>(); }\n\n    template <class T>\n    T get() const { return Ptr.get<T>(); }\n\n    template <class T>\n    T dyn_cast() const { return Ptr.dyn_cast<T>(); }\n\n    void *getOpaqueValue() const;\n\n    bool isNull() const;\n\n    explicit operator bool() const;\n\n    unsigned getCallIndex() const;\n    unsigned getVersion() const;\n    QualType getTypeInfoType() const;\n    QualType getDynamicAllocType() const;\n\n    QualType getType() const;\n\n    friend bool operator==(const LValueBase &LHS, const LValueBase &RHS);\n    friend bool operator!=(const LValueBase &LHS, const LValueBase &RHS) {\n      return !(LHS == RHS);\n    }\n    friend llvm::hash_code hash_value(const LValueBase &Base);\n    friend struct llvm::DenseMapInfo<LValueBase>;\n\n  private:\n    PtrTy Ptr;\n    struct LocalState {\n      unsigned CallIndex, Version;\n    };\n    union {\n      LocalState Local;\n      /// The type std::type_info, if this is a TypeInfoLValue.\n      void *TypeInfoType;\n      /// The QualType, if this is a DynamicAllocLValue.\n      void *DynamicAllocType;\n    };\n  };\n\n  /// A FieldDecl or CXXRecordDecl, along with a flag indicating whether we\n  /// mean a virtual or non-virtual base class subobject.\n  typedef llvm::PointerIntPair<const Decl *, 1, bool> BaseOrMemberType;\n\n  /// A non-discriminated union of a base, field, or array index.\n  class LValuePathEntry {\n    static_assert(sizeof(uintptr_t) <= sizeof(uint64_t),\n                  \"pointer doesn't fit in 64 bits?\");\n    uint64_t Value;\n\n  public:\n    LValuePathEntry() : Value() {}\n    LValuePathEntry(BaseOrMemberType BaseOrMember);\n    static LValuePathEntry ArrayIndex(uint64_t Index) {\n      LValuePathEntry Result;\n      Result.Value = Index;\n      return Result;\n    }\n\n    BaseOrMemberType getAsBaseOrMember() const {\n      return BaseOrMemberType::getFromOpaqueValue(\n          reinterpret_cast<void *>(Value));\n    }\n    uint64_t getAsArrayIndex() const { return Value; }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    friend bool operator==(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value == B.Value;\n    }\n    friend bool operator!=(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value != B.Value;\n    }\n    friend llvm::hash_code hash_value(LValuePathEntry A) {\n      return llvm::hash_value(A.Value);\n    }\n  };\n  class LValuePathSerializationHelper {\n    const void *ElemTy;\n\n  public:\n    ArrayRef<LValuePathEntry> Path;\n\n    LValuePathSerializationHelper(ArrayRef<LValuePathEntry>, QualType);\n    QualType getType();\n  };\n  struct NoLValuePath {};\n  struct UninitArray {};\n  struct UninitStruct {};\n\n  template <typename Impl> friend class clang::serialization::BasicReaderBase;\n  friend class ASTImporter;\n  friend class ASTNodeImporter;\n\nprivate:\n  ValueKind Kind;\n\n  struct ComplexAPSInt {\n    APSInt Real, Imag;\n    ComplexAPSInt() : Real(1), Imag(1) {}\n  };\n  struct ComplexAPFloat {\n    APFloat Real, Imag;\n    ComplexAPFloat() : Real(0.0), Imag(0.0) {}\n  };\n  struct LV;\n  struct Vec {\n    APValue *Elts;\n    unsigned NumElts;\n    Vec() : Elts(nullptr), NumElts(0) {}\n    ~Vec() { delete[] Elts; }\n  };\n  struct Arr {\n    APValue *Elts;\n    unsigned NumElts, ArrSize;\n    Arr(unsigned NumElts, unsigned ArrSize);\n    ~Arr();\n  };\n  struct StructData {\n    APValue *Elts;\n    unsigned NumBases;\n    unsigned NumFields;\n    StructData(unsigned NumBases, unsigned NumFields);\n    ~StructData();\n  };\n  struct UnionData {\n    const FieldDecl *Field;\n    APValue *Value;\n    UnionData();\n    ~UnionData();\n  };\n  struct AddrLabelDiffData {\n    const AddrLabelExpr* LHSExpr;\n    const AddrLabelExpr* RHSExpr;\n  };\n  struct MemberPointerData;\n\n  // We ensure elsewhere that Data is big enough for LV and MemberPointerData.\n  typedef llvm::AlignedCharArrayUnion<void *, APSInt, APFloat, ComplexAPSInt,\n                                      ComplexAPFloat, Vec, Arr, StructData,\n                                      UnionData, AddrLabelDiffData> DataType;\n  static const size_t DataSize = sizeof(DataType);\n\n  DataType Data;\n\npublic:\n  APValue() : Kind(None) {}\n  explicit APValue(APSInt I) : Kind(None) {\n    MakeInt(); setInt(std::move(I));\n  }\n  explicit APValue(APFloat F) : Kind(None) {\n    MakeFloat(); setFloat(std::move(F));\n  }\n  explicit APValue(APFixedPoint FX) : Kind(None) {\n    MakeFixedPoint(std::move(FX));\n  }\n  explicit APValue(const APValue *E, unsigned N) : Kind(None) {\n    MakeVector(); setVector(E, N);\n  }\n  APValue(APSInt R, APSInt I) : Kind(None) {\n    MakeComplexInt(); setComplexInt(std::move(R), std::move(I));\n  }\n  APValue(APFloat R, APFloat I) : Kind(None) {\n    MakeComplexFloat(); setComplexFloat(std::move(R), std::move(I));\n  }\n  APValue(const APValue &RHS);\n  APValue(APValue &&RHS);\n  APValue(LValueBase B, const CharUnits &O, NoLValuePath N,\n          bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, N, IsNullPtr);\n  }\n  APValue(LValueBase B, const CharUnits &O, ArrayRef<LValuePathEntry> Path,\n          bool OnePastTheEnd, bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, Path, OnePastTheEnd, IsNullPtr);\n  }\n  APValue(UninitArray, unsigned InitElts, unsigned Size) : Kind(None) {\n    MakeArray(InitElts, Size);\n  }\n  APValue(UninitStruct, unsigned B, unsigned M) : Kind(None) {\n    MakeStruct(B, M);\n  }\n  explicit APValue(const FieldDecl *D, const APValue &V = APValue())\n      : Kind(None) {\n    MakeUnion(); setUnion(D, V);\n  }\n  APValue(const ValueDecl *Member, bool IsDerivedMember,\n          ArrayRef<const CXXRecordDecl*> Path) : Kind(None) {\n    MakeMemberPointer(Member, IsDerivedMember, Path);\n  }\n  APValue(const AddrLabelExpr* LHSExpr, const AddrLabelExpr* RHSExpr)\n      : Kind(None) {\n    MakeAddrLabelDiff(); setAddrLabelDiff(LHSExpr, RHSExpr);\n  }\n  static APValue IndeterminateValue() {\n    APValue Result;\n    Result.Kind = Indeterminate;\n    return Result;\n  }\n\n  APValue &operator=(const APValue &RHS);\n  APValue &operator=(APValue &&RHS);\n\n  ~APValue() {\n    if (Kind != None && Kind != Indeterminate)\n      DestroyDataAndMakeUninit();\n  }\n\n  /// Returns whether the object performed allocations.\n  ///\n  /// If APValues are constructed via placement new, \\c needsCleanup()\n  /// indicates whether the destructor must be called in order to correctly\n  /// free all allocated memory.\n  bool needsCleanup() const;\n\n  /// Swaps the contents of this and the given APValue.\n  void swap(APValue &RHS);\n\n  /// profile this value. There is no guarantee that values of different\n  /// types will not produce the same profiled value, so the type should\n  /// typically also be profiled if it's not implied by the context.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  ValueKind getKind() const { return Kind; }\n\n  bool isAbsent() const { return Kind == None; }\n  bool isIndeterminate() const { return Kind == Indeterminate; }\n  bool hasValue() const { return Kind != None && Kind != Indeterminate; }\n\n  bool isInt() const { return Kind == Int; }\n  bool isFloat() const { return Kind == Float; }\n  bool isFixedPoint() const { return Kind == FixedPoint; }\n  bool isComplexInt() const { return Kind == ComplexInt; }\n  bool isComplexFloat() const { return Kind == ComplexFloat; }\n  bool isLValue() const { return Kind == LValue; }\n  bool isVector() const { return Kind == Vector; }\n  bool isArray() const { return Kind == Array; }\n  bool isStruct() const { return Kind == Struct; }\n  bool isUnion() const { return Kind == Union; }\n  bool isMemberPointer() const { return Kind == MemberPointer; }\n  bool isAddrLabelDiff() const { return Kind == AddrLabelDiff; }\n\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  void printPretty(raw_ostream &OS, const ASTContext &Ctx, QualType Ty) const;\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy, QualType Ty,\n                   const ASTContext *Ctx = nullptr) const;\n\n  std::string getAsString(const ASTContext &Ctx, QualType Ty) const;\n\n  APSInt &getInt() {\n    assert(isInt() && \"Invalid accessor\");\n    return *(APSInt *)(char *)&Data;\n  }\n  const APSInt &getInt() const {\n    return const_cast<APValue*>(this)->getInt();\n  }\n\n  /// Try to convert this value to an integral constant. This works if it's an\n  /// integer, null pointer, or offset from a null pointer. Returns true on\n  /// success.\n  bool toIntegralConstant(APSInt &Result, QualType SrcTy,\n                          const ASTContext &Ctx) const;\n\n  APFloat &getFloat() {\n    assert(isFloat() && \"Invalid accessor\");\n    return *(APFloat *)(char *)&Data;\n  }\n  const APFloat &getFloat() const {\n    return const_cast<APValue*>(this)->getFloat();\n  }\n\n  APFixedPoint &getFixedPoint() {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    return *(APFixedPoint *)(char *)&Data;\n  }\n  const APFixedPoint &getFixedPoint() const {\n    return const_cast<APValue *>(this)->getFixedPoint();\n  }\n\n  APSInt &getComplexIntReal() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Real;\n  }\n  const APSInt &getComplexIntReal() const {\n    return const_cast<APValue*>(this)->getComplexIntReal();\n  }\n\n  APSInt &getComplexIntImag() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Imag;\n  }\n  const APSInt &getComplexIntImag() const {\n    return const_cast<APValue*>(this)->getComplexIntImag();\n  }\n\n  APFloat &getComplexFloatReal() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Real;\n  }\n  const APFloat &getComplexFloatReal() const {\n    return const_cast<APValue*>(this)->getComplexFloatReal();\n  }\n\n  APFloat &getComplexFloatImag() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Imag;\n  }\n  const APFloat &getComplexFloatImag() const {\n    return const_cast<APValue*>(this)->getComplexFloatImag();\n  }\n\n  const LValueBase getLValueBase() const;\n  CharUnits &getLValueOffset();\n  const CharUnits &getLValueOffset() const {\n    return const_cast<APValue*>(this)->getLValueOffset();\n  }\n  bool isLValueOnePastTheEnd() const;\n  bool hasLValuePath() const;\n  ArrayRef<LValuePathEntry> getLValuePath() const;\n  unsigned getLValueCallIndex() const;\n  unsigned getLValueVersion() const;\n  bool isNullPointer() const;\n\n  APValue &getVectorElt(unsigned I) {\n    assert(isVector() && \"Invalid accessor\");\n    assert(I < getVectorLength() && \"Index out of range\");\n    return ((Vec *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getVectorElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getVectorElt(I);\n  }\n  unsigned getVectorLength() const {\n    assert(isVector() && \"Invalid accessor\");\n    return ((const Vec *)(const void *)&Data)->NumElts;\n  }\n\n  APValue &getArrayInitializedElt(unsigned I) {\n    assert(isArray() && \"Invalid accessor\");\n    assert(I < getArrayInitializedElts() && \"Index out of range\");\n    return ((Arr *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getArrayInitializedElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getArrayInitializedElt(I);\n  }\n  bool hasArrayFiller() const {\n    return getArrayInitializedElts() != getArraySize();\n  }\n  APValue &getArrayFiller() {\n    assert(isArray() && \"Invalid accessor\");\n    assert(hasArrayFiller() && \"No array filler\");\n    return ((Arr *)(char *)&Data)->Elts[getArrayInitializedElts()];\n  }\n  const APValue &getArrayFiller() const {\n    return const_cast<APValue*>(this)->getArrayFiller();\n  }\n  unsigned getArrayInitializedElts() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->NumElts;\n  }\n  unsigned getArraySize() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->ArrSize;\n  }\n\n  unsigned getStructNumBases() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumBases;\n  }\n  unsigned getStructNumFields() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumFields;\n  }\n  APValue &getStructBase(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumBases() && \"base class index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[i];\n  }\n  APValue &getStructField(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumFields() && \"field index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[getStructNumBases() + i];\n  }\n  const APValue &getStructBase(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructBase(i);\n  }\n  const APValue &getStructField(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructField(i);\n  }\n\n  const FieldDecl *getUnionField() const {\n    assert(isUnion() && \"Invalid accessor\");\n    return ((const UnionData *)(const char *)&Data)->Field;\n  }\n  APValue &getUnionValue() {\n    assert(isUnion() && \"Invalid accessor\");\n    return *((UnionData *)(char *)&Data)->Value;\n  }\n  const APValue &getUnionValue() const {\n    return const_cast<APValue*>(this)->getUnionValue();\n  }\n\n  const ValueDecl *getMemberPointerDecl() const;\n  bool isMemberPointerToDerivedMember() const;\n  ArrayRef<const CXXRecordDecl*> getMemberPointerPath() const;\n\n  const AddrLabelExpr* getAddrLabelDiffLHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->LHSExpr;\n  }\n  const AddrLabelExpr* getAddrLabelDiffRHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->RHSExpr;\n  }\n\n  void setInt(APSInt I) {\n    assert(isInt() && \"Invalid accessor\");\n    *(APSInt *)(char *)&Data = std::move(I);\n  }\n  void setFloat(APFloat F) {\n    assert(isFloat() && \"Invalid accessor\");\n    *(APFloat *)(char *)&Data = std::move(F);\n  }\n  void setFixedPoint(APFixedPoint FX) {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    *(APFixedPoint *)(char *)&Data = std::move(FX);\n  }\n  void setVector(const APValue *E, unsigned N) {\n    MutableArrayRef<APValue> InternalElts = setVectorUninit(N);\n    for (unsigned i = 0; i != N; ++i)\n      InternalElts[i] = E[i];\n  }\n  void setComplexInt(APSInt R, APSInt I) {\n    assert(R.getBitWidth() == I.getBitWidth() &&\n           \"Invalid complex int (type mismatch).\");\n    assert(isComplexInt() && \"Invalid accessor\");\n    ((ComplexAPSInt *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPSInt *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setComplexFloat(APFloat R, APFloat I) {\n    assert(&R.getSemantics() == &I.getSemantics() &&\n           \"Invalid complex float (type mismatch).\");\n    assert(isComplexFloat() && \"Invalid accessor\");\n    ((ComplexAPFloat *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPFloat *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setLValue(LValueBase B, const CharUnits &O, NoLValuePath,\n                 bool IsNullPtr);\n  void setLValue(LValueBase B, const CharUnits &O,\n                 ArrayRef<LValuePathEntry> Path, bool OnePastTheEnd,\n                 bool IsNullPtr);\n  void setUnion(const FieldDecl *Field, const APValue &Value);\n  void setAddrLabelDiff(const AddrLabelExpr* LHSExpr,\n                        const AddrLabelExpr* RHSExpr) {\n    ((AddrLabelDiffData *)(char *)&Data)->LHSExpr = LHSExpr;\n    ((AddrLabelDiffData *)(char *)&Data)->RHSExpr = RHSExpr;\n  }\n\nprivate:\n  void DestroyDataAndMakeUninit();\n  void MakeInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)&Data) APSInt(1);\n    Kind = Int;\n  }\n  void MakeFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFloat(0.0);\n    Kind = Float;\n  }\n  void MakeFixedPoint(APFixedPoint &&FX) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFixedPoint(std::move(FX));\n    Kind = FixedPoint;\n  }\n  void MakeVector() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) Vec();\n    Kind = Vector;\n  }\n  void MakeComplexInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPSInt();\n    Kind = ComplexInt;\n  }\n  void MakeComplexFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPFloat();\n    Kind = ComplexFloat;\n  }\n  void MakeLValue();\n  void MakeArray(unsigned InitElts, unsigned Size);\n  void MakeStruct(unsigned B, unsigned M) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) StructData(B, M);\n    Kind = Struct;\n  }\n  void MakeUnion() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) UnionData();\n    Kind = Union;\n  }\n  void MakeMemberPointer(const ValueDecl *Member, bool IsDerivedMember,\n                         ArrayRef<const CXXRecordDecl*> Path);\n  void MakeAddrLabelDiff() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) AddrLabelDiffData();\n    Kind = AddrLabelDiff;\n  }\n\nprivate:\n  /// The following functions are used as part of initialization, during\n  /// deserialization and importing. Reserve the space so that it can be\n  /// filled in by those steps.\n  MutableArrayRef<APValue> setVectorUninit(unsigned N) {\n    assert(isVector() && \"Invalid accessor\");\n    Vec *V = ((Vec *)(char *)&Data);\n    V->Elts = new APValue[N];\n    V->NumElts = N;\n    return {V->Elts, V->NumElts};\n  }\n  MutableArrayRef<LValuePathEntry>\n  setLValueUninit(LValueBase B, const CharUnits &O, unsigned Size,\n                  bool OnePastTheEnd, bool IsNullPtr);\n  MutableArrayRef<const CXXRecordDecl *>\n  setMemberPointerUninit(const ValueDecl *Member, bool IsDerivedMember,\n                         unsigned Size);\n};\n\n} // end namespace clang.\n\nnamespace llvm {\ntemplate<> struct DenseMapInfo<clang::APValue::LValueBase> {\n  static clang::APValue::LValueBase getEmptyKey();\n  static clang::APValue::LValueBase getTombstoneKey();\n  static unsigned getHashValue(const clang::APValue::LValueBase &Base);\n  static bool isEqual(const clang::APValue::LValueBase &LHS,\n                      const clang::APValue::LValueBase &RHS);\n};\n}\n\n#endif\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "content": "//===--- ASTTypeTraits.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Provides a dynamic type identifier and a dynamically typed node container\n//  that can be used to store an AST base node at runtime in the same storage in\n//  a type safe way.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTTYPETRAITS_H\n#define LLVM_CLANG_AST_ASTTYPETRAITS_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\n}\n\nnamespace clang {\n\nstruct PrintingPolicy;\n\n/// Defines how we descend a level in the AST when we pass\n/// through expressions.\nenum TraversalKind {\n  /// Will traverse all child nodes.\n  TK_AsIs,\n\n  /// Ignore AST nodes not written in the source\n  TK_IgnoreUnlessSpelledInSource\n};\n\n/// Kind identifier.\n///\n/// It can be constructed from any node kind and allows for runtime type\n/// hierarchy checks.\n/// Use getFromNodeKind<T>() to construct them.\nclass ASTNodeKind {\npublic:\n  /// Empty identifier. It matches nothing.\n  ASTNodeKind() : KindId(NKI_None) {}\n\n  /// Construct an identifier for T.\n  template <class T>\n  static ASTNodeKind getFromNodeKind() {\n    return ASTNodeKind(KindToKindId<T>::Id);\n  }\n\n  /// \\{\n  /// Construct an identifier for the dynamic type of the node\n  static ASTNodeKind getFromNode(const Decl &D);\n  static ASTNodeKind getFromNode(const Stmt &S);\n  static ASTNodeKind getFromNode(const Type &T);\n  static ASTNodeKind getFromNode(const OMPClause &C);\n  /// \\}\n\n  /// Returns \\c true if \\c this and \\c Other represent the same kind.\n  bool isSame(ASTNodeKind Other) const {\n    return KindId != NKI_None && KindId == Other.KindId;\n  }\n\n  /// Returns \\c true only for the default \\c ASTNodeKind()\n  bool isNone() const { return KindId == NKI_None; }\n\n  /// Returns \\c true if \\c this is a base kind of (or same as) \\c Other.\n  /// \\param Distance If non-null, used to return the distance between \\c this\n  /// and \\c Other in the class hierarchy.\n  bool isBaseOf(ASTNodeKind Other, unsigned *Distance = nullptr) const;\n\n  /// String representation of the kind.\n  StringRef asStringRef() const;\n\n  /// Strict weak ordering for ASTNodeKind.\n  bool operator<(const ASTNodeKind &Other) const {\n    return KindId < Other.KindId;\n  }\n\n  /// Return the most derived type between \\p Kind1 and \\p Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedType(ASTNodeKind Kind1, ASTNodeKind Kind2);\n\n  /// Return the most derived common ancestor between Kind1 and Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedCommonAncestor(ASTNodeKind Kind1,\n                                                  ASTNodeKind Kind2);\n\n  ASTNodeKind getCladeKind() const;\n\n  /// Hooks for using ASTNodeKind as a key in a DenseMap.\n  struct DenseMapInfo {\n    // ASTNodeKind() is a good empty key because it is represented as a 0.\n    static inline ASTNodeKind getEmptyKey() { return ASTNodeKind(); }\n    // NKI_NumberOfKinds is not a valid value, so it is good for a\n    // tombstone key.\n    static inline ASTNodeKind getTombstoneKey() {\n      return ASTNodeKind(NKI_NumberOfKinds);\n    }\n    static unsigned getHashValue(const ASTNodeKind &Val) { return Val.KindId; }\n    static bool isEqual(const ASTNodeKind &LHS, const ASTNodeKind &RHS) {\n      return LHS.KindId == RHS.KindId;\n    }\n  };\n\n  /// Check if the given ASTNodeKind identifies a type that offers pointer\n  /// identity. This is useful for the fast path in DynTypedNode.\n  bool hasPointerIdentity() const {\n    return KindId > NKI_LastKindWithoutPointerIdentity;\n  }\n\nprivate:\n  /// Kind ids.\n  ///\n  /// Includes all possible base and derived kinds.\n  enum NodeKindId {\n    NKI_None,\n    NKI_TemplateArgument,\n    NKI_TemplateArgumentLoc,\n    NKI_TemplateName,\n    NKI_NestedNameSpecifierLoc,\n    NKI_QualType,\n    NKI_TypeLoc,\n    NKI_LastKindWithoutPointerIdentity = NKI_TypeLoc,\n    NKI_CXXBaseSpecifier,\n    NKI_CXXCtorInitializer,\n    NKI_NestedNameSpecifier,\n    NKI_Decl,\n#define DECL(DERIVED, BASE) NKI_##DERIVED##Decl,\n#include \"clang/AST/DeclNodes.inc\"\n    NKI_Stmt,\n#define STMT(DERIVED, BASE) NKI_##DERIVED,\n#include \"clang/AST/StmtNodes.inc\"\n    NKI_Type,\n#define TYPE(DERIVED, BASE) NKI_##DERIVED##Type,\n#include \"clang/AST/TypeNodes.inc\"\n    NKI_OMPClause,\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) NKI_##Class,\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n    NKI_NumberOfKinds\n  };\n\n  /// Use getFromNodeKind<T>() to construct the kind.\n  ASTNodeKind(NodeKindId KindId) : KindId(KindId) {}\n\n  /// Returns \\c true if \\c Base is a base kind of (or same as) \\c\n  ///   Derived.\n  /// \\param Distance If non-null, used to return the distance between \\c Base\n  /// and \\c Derived in the class hierarchy.\n  static bool isBaseOf(NodeKindId Base, NodeKindId Derived, unsigned *Distance);\n\n  /// Helper meta-function to convert a kind T to its enum value.\n  ///\n  /// This struct is specialized below for all known kinds.\n  template <class T> struct KindToKindId {\n    static const NodeKindId Id = NKI_None;\n  };\n  template <class T>\n  struct KindToKindId<const T> : KindToKindId<T> {};\n\n  /// Per kind info.\n  struct KindInfo {\n    /// The id of the parent kind, or None if it has no parent.\n    NodeKindId ParentId;\n    /// Name of the kind.\n    const char *Name;\n  };\n  static const KindInfo AllKindInfo[NKI_NumberOfKinds];\n\n  NodeKindId KindId;\n};\n\n#define KIND_TO_KIND_ID(Class)                                                 \\\n  template <> struct ASTNodeKind::KindToKindId<Class> {                        \\\n    static const NodeKindId Id = NKI_##Class;                                  \\\n  };\nKIND_TO_KIND_ID(CXXCtorInitializer)\nKIND_TO_KIND_ID(TemplateArgument)\nKIND_TO_KIND_ID(TemplateArgumentLoc)\nKIND_TO_KIND_ID(TemplateName)\nKIND_TO_KIND_ID(NestedNameSpecifier)\nKIND_TO_KIND_ID(NestedNameSpecifierLoc)\nKIND_TO_KIND_ID(QualType)\nKIND_TO_KIND_ID(TypeLoc)\nKIND_TO_KIND_ID(Decl)\nKIND_TO_KIND_ID(Stmt)\nKIND_TO_KIND_ID(Type)\nKIND_TO_KIND_ID(OMPClause)\nKIND_TO_KIND_ID(CXXBaseSpecifier)\n#define DECL(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Decl)\n#include \"clang/AST/DeclNodes.inc\"\n#define STMT(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED)\n#include \"clang/AST/StmtNodes.inc\"\n#define TYPE(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Type)\n#include \"clang/AST/TypeNodes.inc\"\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) KIND_TO_KIND_ID(Class)\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n#undef KIND_TO_KIND_ID\n\ninline raw_ostream &operator<<(raw_ostream &OS, ASTNodeKind K) {\n  OS << K.asStringRef();\n  return OS;\n}\n\n/// A dynamically typed AST node container.\n///\n/// Stores an AST node in a type safe way. This allows writing code that\n/// works with different kinds of AST nodes, despite the fact that they don't\n/// have a common base class.\n///\n/// Use \\c create(Node) to create a \\c DynTypedNode from an AST node,\n/// and \\c get<T>() to retrieve the node as type T if the types match.\n///\n/// See \\c ASTNodeKind for which node base types are currently supported;\n/// You can create DynTypedNodes for all nodes in the inheritance hierarchy of\n/// the supported base types.\nclass DynTypedNode {\npublic:\n  /// Creates a \\c DynTypedNode from \\c Node.\n  template <typename T>\n  static DynTypedNode create(const T &Node) {\n    return BaseConverter<T>::create(Node);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Returns NULL if the stored node does not have a type that is\n  /// convertible to \\c T.\n  ///\n  /// For types that have identity via their pointer in the AST\n  /// (like \\c Stmt, \\c Decl, \\c Type and \\c NestedNameSpecifier) the returned\n  /// pointer points to the referenced AST node.\n  /// For other types (like \\c QualType) the value is stored directly\n  /// in the \\c DynTypedNode, and the returned pointer points at\n  /// the storage inside DynTypedNode. For those nodes, do not\n  /// use the pointer outside the scope of the DynTypedNode.\n  template <typename T> const T *get() const {\n    return BaseConverter<T>::get(NodeKind, &Storage);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Similar to \\c get(), but asserts that the type is what we are expecting.\n  template <typename T>\n  const T &getUnchecked() const {\n    return BaseConverter<T>::getUnchecked(NodeKind, &Storage);\n  }\n\n  ASTNodeKind getNodeKind() const { return NodeKind; }\n\n  /// Returns a pointer that identifies the stored AST node.\n  ///\n  /// Note that this is not supported by all AST nodes. For AST nodes\n  /// that don't have a pointer-defined identity inside the AST, this\n  /// method returns NULL.\n  const void *getMemoizationData() const {\n    return NodeKind.hasPointerIdentity()\n               ? *reinterpret_cast<void *const *>(&Storage)\n               : nullptr;\n  }\n\n  /// Prints the node to the given output stream.\n  void print(llvm::raw_ostream &OS, const PrintingPolicy &PP) const;\n\n  /// Dumps the node to the given output stream.\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  /// For nodes which represent textual entities in the source code,\n  /// return their SourceRange.  For all other nodes, return SourceRange().\n  SourceRange getSourceRange() const;\n\n  /// @{\n  /// Imposes an order on \\c DynTypedNode.\n  ///\n  /// Supports comparison of nodes that support memoization.\n  /// FIXME: Implement comparison for other node types (currently\n  /// only Stmt, Decl, Type and NestedNameSpecifier return memoization data).\n  bool operator<(const DynTypedNode &Other) const {\n    if (!NodeKind.isSame(Other.NodeKind))\n      return NodeKind < Other.NodeKind;\n\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>().getAsOpaquePtr() <\n             Other.getUnchecked<QualType>().getAsOpaquePtr();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(NodeKind)) {\n      auto TLA = getUnchecked<TypeLoc>();\n      auto TLB = Other.getUnchecked<TypeLoc>();\n      return std::make_pair(TLA.getType().getAsOpaquePtr(),\n                            TLA.getOpaqueData()) <\n             std::make_pair(TLB.getType().getAsOpaquePtr(),\n                            TLB.getOpaqueData());\n    }\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n            NodeKind)) {\n      auto NNSLA = getUnchecked<NestedNameSpecifierLoc>();\n      auto NNSLB = Other.getUnchecked<NestedNameSpecifierLoc>();\n      return std::make_pair(NNSLA.getNestedNameSpecifier(),\n                            NNSLA.getOpaqueData()) <\n             std::make_pair(NNSLB.getNestedNameSpecifier(),\n                            NNSLB.getOpaqueData());\n    }\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() < Other.getMemoizationData();\n  }\n  bool operator==(const DynTypedNode &Other) const {\n    // DynTypedNode::create() stores the exact kind of the node in NodeKind.\n    // If they contain the same node, their NodeKind must be the same.\n    if (!NodeKind.isSame(Other.NodeKind))\n      return false;\n\n    // FIXME: Implement for other types.\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>() == Other.getUnchecked<QualType>();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(NodeKind))\n      return getUnchecked<TypeLoc>() == Other.getUnchecked<TypeLoc>();\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(NodeKind))\n      return getUnchecked<NestedNameSpecifierLoc>() ==\n             Other.getUnchecked<NestedNameSpecifierLoc>();\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() == Other.getMemoizationData();\n  }\n  bool operator!=(const DynTypedNode &Other) const {\n    return !operator==(Other);\n  }\n  /// @}\n\n  /// Hooks for using DynTypedNode as a key in a DenseMap.\n  struct DenseMapInfo {\n    static inline DynTypedNode getEmptyKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      return Node;\n    }\n    static inline DynTypedNode getTombstoneKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return Node;\n    }\n    static unsigned getHashValue(const DynTypedNode &Val) {\n      // FIXME: Add hashing support for the remaining types.\n      if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(Val.NodeKind)) {\n        auto TL = Val.getUnchecked<TypeLoc>();\n        return llvm::hash_combine(TL.getType().getAsOpaquePtr(),\n                                  TL.getOpaqueData());\n      }\n\n      if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n              Val.NodeKind)) {\n        auto NNSL = Val.getUnchecked<NestedNameSpecifierLoc>();\n        return llvm::hash_combine(NNSL.getNestedNameSpecifier(),\n                                  NNSL.getOpaqueData());\n      }\n\n      assert(Val.getMemoizationData());\n      return llvm::hash_value(Val.getMemoizationData());\n    }\n    static bool isEqual(const DynTypedNode &LHS, const DynTypedNode &RHS) {\n      auto Empty = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      auto TombStone = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, Empty) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, Empty)) ||\n             (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, TombStone) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, TombStone)) ||\n             LHS == RHS;\n    }\n  };\n\nprivate:\n  /// Takes care of converting from and to \\c T.\n  template <typename T, typename EnablerT = void> struct BaseConverter;\n\n  /// Converter that uses dyn_cast<T> from a stored BaseT*.\n  template <typename T, typename BaseT> struct DynCastPtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind));\n      return *cast<T>(static_cast<const BaseT *>(\n          *reinterpret_cast<const void *const *>(Storage)));\n    }\n    static DynTypedNode create(const BaseT &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNode(Node);\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T* (by pointer).\n  template <typename T> struct PtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *static_cast<const T *>(\n          *reinterpret_cast<const void *const *>(Storage));\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T (by value).\n  template <typename T> struct ValueConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return reinterpret_cast<const T *>(Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *reinterpret_cast<const T *>(Storage);\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) T(Node);\n      return Result;\n    }\n  };\n\n  ASTNodeKind NodeKind;\n\n  /// Stores the data of the node.\n  ///\n  /// Note that we can store \\c Decls, \\c Stmts, \\c Types,\n  /// \\c NestedNameSpecifiers and \\c CXXCtorInitializer by pointer as they are\n  /// guaranteed to be unique pointers pointing to dedicated storage in the AST.\n  /// \\c QualTypes, \\c NestedNameSpecifierLocs, \\c TypeLocs,\n  /// \\c TemplateArguments and \\c TemplateArgumentLocs on the other hand do not\n  /// have storage or unique pointers and thus need to be stored by value.\n  llvm::AlignedCharArrayUnion<const void *, TemplateArgument,\n                              TemplateArgumentLoc, NestedNameSpecifierLoc,\n                              QualType, TypeLoc>\n      Storage;\n};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Decl, T>::value>>\n    : public DynCastPtrConverter<T, Decl> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Stmt, T>::value>>\n    : public DynCastPtrConverter<T, Stmt> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Type, T>::value>>\n    : public DynCastPtrConverter<T, Type> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<OMPClause, T>::value>>\n    : public DynCastPtrConverter<T, OMPClause> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    NestedNameSpecifier, void> : public PtrConverter<NestedNameSpecifier> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    CXXCtorInitializer, void> : public PtrConverter<CXXCtorInitializer> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TemplateArgument, void> : public ValueConverter<TemplateArgument> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<TemplateArgumentLoc, void>\n    : public ValueConverter<TemplateArgumentLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TemplateName, void> : public ValueConverter<TemplateName> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    NestedNameSpecifierLoc,\n    void> : public ValueConverter<NestedNameSpecifierLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<QualType,\n                                   void> : public ValueConverter<QualType> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TypeLoc, void> : public ValueConverter<TypeLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<CXXBaseSpecifier, void>\n    : public PtrConverter<CXXBaseSpecifier> {};\n\n// The only operation we allow on unsupported types is \\c get.\n// This allows to conveniently use \\c DynTypedNode when having an arbitrary\n// AST node that is not supported, but prevents misuse - a user cannot create\n// a DynTypedNode from arbitrary types.\ntemplate <typename T, typename EnablerT> struct DynTypedNode::BaseConverter {\n  static const T *get(ASTNodeKind NodeKind, const char Storage[]) {\n    return NULL;\n  }\n};\n\n} // end namespace clang\n\nnamespace llvm {\n\ntemplate <>\nstruct DenseMapInfo<clang::ASTNodeKind> : clang::ASTNodeKind::DenseMapInfo {};\n\ntemplate <>\nstruct DenseMapInfo<clang::DynTypedNode> : clang::DynTypedNode::DenseMapInfo {};\n\n}  // end namespace llvm\n\n#endif\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "content": "//===- PathDiagnostic.h - Path-Specific Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PathDiagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <deque>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass BinaryOperator;\nclass CallEnter;\nclass CallExitEnd;\nclass CallExpr;\nclass ConditionalOperator;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass MemberExpr;\nclass ProgramPoint;\nclass SourceManager;\n\nnamespace ento {\n\n//===----------------------------------------------------------------------===//\n// High-level interface for handlers of path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnostic;\n\n/// These options tweak the behavior of path diangostic consumers.\n/// Most of these options are currently supported by very few consumers.\nstruct PathDiagnosticConsumerOptions {\n  /// Run-line of the tool that produced the diagnostic.\n  /// It can be included with the diagnostic for debugging purposes.\n  std::string ToolInvocation;\n\n  /// Whether to include additional information about macro expansions\n  /// with the diagnostics, because otherwise they can be hard to obtain\n  /// without re-compiling the program under analysis.\n  bool ShouldDisplayMacroExpansions = false;\n\n  /// Whether to include LLVM statistics of the process in the diagnostic.\n  /// Useful for profiling the tool on large real-world codebases.\n  bool ShouldSerializeStats = false;\n\n  /// If the consumer intends to produce multiple output files, should it\n  /// use randomly generated file names for these files (with the tiny risk of\n  /// having random collisions) or deterministic human-readable file names\n  /// (with a larger risk of deterministic collisions or invalid characters\n  /// in the file name). We should not really give this choice to the users\n  /// because deterministic mode is always superior when done right, but\n  /// for some consumers this mode is experimental and needs to be\n  /// off by default.\n  bool ShouldWriteStableReportFilename = false;\n\n  /// Whether the consumer should treat consumed diagnostics as hard errors.\n  /// Useful for breaking your build when issues are found.\n  bool ShouldDisplayWarningsAsErrors = false;\n\n  /// Whether the consumer should attempt to rewrite the source file\n  /// with fix-it hints attached to the diagnostics it consumes.\n  bool ShouldApplyFixIts = false;\n\n  /// Whether the consumer should present the name of the entity that emitted\n  /// the diagnostic (eg., a checker) so that the user knew how to disable it.\n  bool ShouldDisplayDiagnosticName = false;\n};\n\nclass PathDiagnosticConsumer {\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for HTML, SARIF, and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() == Extensive; }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n};\n\n//===----------------------------------------------------------------------===//\n// Path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticRange : public SourceRange {\npublic:\n  bool isPoint = false;\n\n  PathDiagnosticRange(SourceRange R, bool isP = false)\n      : SourceRange(R), isPoint(isP) {}\n  PathDiagnosticRange() = default;\n};\n\nusing LocationOrAnalysisDeclContext =\n    llvm::PointerUnion<const LocationContext *, AnalysisDeclContext *>;\n\nclass PathDiagnosticLocation {\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n};\n\nclass PathDiagnosticLocationPair {\nprivate:\n  PathDiagnosticLocation Start, End;\n\npublic:\n  PathDiagnosticLocationPair(const PathDiagnosticLocation &start,\n                             const PathDiagnosticLocation &end)\n      : Start(start), End(end) {}\n\n  const PathDiagnosticLocation &getStart() const { return Start; }\n  const PathDiagnosticLocation &getEnd() const { return End; }\n\n  void setStart(const PathDiagnosticLocation &L) { Start = L; }\n  void setEnd(const PathDiagnosticLocation &L) { End = L; }\n\n  void flatten() {\n    Start.flatten();\n    End.flatten();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Start.Profile(ID);\n    End.Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Path \"pieces\" for path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticPiece: public llvm::FoldingSetNode {\npublic:\n  enum Kind { ControlFlow, Event, Macro, Call, Note, PopUp };\n  enum DisplayHint { Above, Below };\n\nprivate:\n  const std::string str;\n  const Kind kind;\n  const DisplayHint Hint;\n\n  /// In the containing bug report, this piece is the last piece from\n  /// the main source file.\n  bool LastInMainSourceFile = false;\n\n  /// A constant string that can be used to tag the PathDiagnosticPiece,\n  /// typically with the identification of the creator.  The actual pointer\n  /// value is meant to be an identifier; the string itself is useful for\n  /// debugging.\n  StringRef Tag;\n\n  std::vector<SourceRange> ranges;\n  std::vector<FixItHint> fixits;\n\nprotected:\n  PathDiagnosticPiece(StringRef s, Kind k, DisplayHint hint = Below);\n  PathDiagnosticPiece(Kind k, DisplayHint hint = Below);\n\npublic:\n  PathDiagnosticPiece() = delete;\n  PathDiagnosticPiece(const PathDiagnosticPiece &) = delete;\n  PathDiagnosticPiece &operator=(const PathDiagnosticPiece &) = delete;\n  virtual ~PathDiagnosticPiece();\n\n  StringRef getString() const { return str; }\n\n  /// Tag this PathDiagnosticPiece with the given C-string.\n  void setTag(const char *tag) { Tag = tag; }\n\n  /// Return the opaque tag (if any) on the PathDiagnosticPiece.\n  const void *getTag() const { return Tag.data(); }\n\n  /// Return the string representation of the tag.  This is useful\n  /// for debugging.\n  StringRef getTagStr() const { return Tag; }\n\n  /// getDisplayHint - Return a hint indicating where the diagnostic should\n  ///  be displayed by the PathDiagnosticConsumer.\n  DisplayHint getDisplayHint() const { return Hint; }\n\n  virtual PathDiagnosticLocation getLocation() const = 0;\n  virtual void flattenLocations() = 0;\n\n  Kind getKind() const { return kind; }\n\n  void addRange(SourceRange R) {\n    if (!R.isValid())\n      return;\n    ranges.push_back(R);\n  }\n\n  void addRange(SourceLocation B, SourceLocation E) {\n    if (!B.isValid() || !E.isValid())\n      return;\n    ranges.push_back(SourceRange(B,E));\n  }\n\n  void addFixit(FixItHint F) {\n    fixits.push_back(F);\n  }\n\n  /// Return the SourceRanges associated with this PathDiagnosticPiece.\n  ArrayRef<SourceRange> getRanges() const { return ranges; }\n\n  /// Return the fix-it hints associated with this PathDiagnosticPiece.\n  ArrayRef<FixItHint> getFixits() const { return fixits; }\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void setAsLastInMainSourceFile() {\n    LastInMainSourceFile = true;\n  }\n\n  bool isLastInMainSourceFile() const {\n    return LastInMainSourceFile;\n  }\n\n  virtual void dump() const = 0;\n};\n\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\nclass PathPieces : public std::list<PathDiagnosticPieceRef> {\n  void flattenTo(PathPieces &Primary, PathPieces &Current,\n                 bool ShouldFlattenMacros) const;\n\npublic:\n  PathPieces flatten(bool ShouldFlattenMacros) const {\n    PathPieces Result;\n    flattenTo(Result, Result, ShouldFlattenMacros);\n    return Result;\n  }\n\n  void dump() const;\n};\n\nclass PathDiagnosticSpotPiece : public PathDiagnosticPiece {\nprivate:\n  PathDiagnosticLocation Pos;\n\npublic:\n  PathDiagnosticSpotPiece(const PathDiagnosticLocation &pos,\n                          StringRef s,\n                          PathDiagnosticPiece::Kind k,\n                          bool addPosRange = true)\n      : PathDiagnosticPiece(s, k), Pos(pos) {\n    assert(Pos.isValid() && Pos.hasValidLocation() &&\n           \"PathDiagnosticSpotPiece's must have a valid location.\");\n    if (addPosRange && Pos.hasRange()) addRange(Pos.asRange());\n  }\n\n  PathDiagnosticLocation getLocation() const override { return Pos; }\n  void flattenLocations() override { Pos.flatten(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event || P->getKind() == Macro ||\n           P->getKind() == Note || P->getKind() == PopUp;\n  }\n};\n\nclass PathDiagnosticEventPiece : public PathDiagnosticSpotPiece {\n  Optional<bool> IsPrunable;\n\npublic:\n  PathDiagnosticEventPiece(const PathDiagnosticLocation &pos,\n                           StringRef s, bool addPosRange = true)\n      : PathDiagnosticSpotPiece(pos, s, Event, addPosRange) {}\n  ~PathDiagnosticEventPiece() override;\n\n  /// Mark the diagnostic piece as being potentially prunable.  This\n  /// flag may have been previously set, at which point it will not\n  /// be reset unless one specifies to do so.\n  void setPrunable(bool isPrunable, bool override = false) {\n    if (IsPrunable.hasValue() && !override)\n     return;\n    IsPrunable = isPrunable;\n  }\n\n  /// Return true if the diagnostic piece is prunable.\n  bool isPrunable() const {\n    return IsPrunable.hasValue() ? IsPrunable.getValue() : false;\n  }\n\n  void dump() const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event;\n  }\n};\n\nclass PathDiagnosticCallPiece : public PathDiagnosticPiece {\n  const Decl *Caller;\n  const Decl *Callee = nullptr;\n\n  // Flag signifying that this diagnostic has only call enter and no matching\n  // call exit.\n  bool NoExit;\n\n  // Flag signifying that the callee function is an Objective-C autosynthesized\n  // property getter or setter.\n  bool IsCalleeAnAutosynthesizedPropertyAccessor = false;\n\n  // The custom string, which should appear after the call Return Diagnostic.\n  // TODO: Should we allow multiple diagnostics?\n  std::string CallStackMessage;\n\n  PathDiagnosticCallPiece(const Decl *callerD,\n                          const PathDiagnosticLocation &callReturnPos)\n      : PathDiagnosticPiece(Call), Caller(callerD), NoExit(false),\n        callReturn(callReturnPos) {}\n  PathDiagnosticCallPiece(PathPieces &oldPath, const Decl *caller)\n      : PathDiagnosticPiece(Call), Caller(caller), NoExit(true),\n        path(oldPath) {}\n\npublic:\n  PathDiagnosticLocation callEnter;\n  PathDiagnosticLocation callEnterWithin;\n  PathDiagnosticLocation callReturn;\n  PathPieces path;\n\n  ~PathDiagnosticCallPiece() override;\n\n  const Decl *getCaller() const { return Caller; }\n\n  const Decl *getCallee() const { return Callee; }\n  void setCallee(const CallEnter &CE, const SourceManager &SM);\n\n  bool hasCallStackMessage() { return !CallStackMessage.empty(); }\n  void setCallStackMessage(StringRef st) { CallStackMessage = std::string(st); }\n\n  PathDiagnosticLocation getLocation() const override { return callEnter; }\n\n  std::shared_ptr<PathDiagnosticEventPiece> getCallEnterEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece>\n  getCallEnterWithinCallerEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece> getCallExitEvent() const;\n\n  void flattenLocations() override {\n    callEnter.flatten();\n    callReturn.flatten();\n    for (const auto &I : path)\n      I->flattenLocations();\n  }\n\n  static std::shared_ptr<PathDiagnosticCallPiece>\n  construct(const CallExitEnd &CE,\n            const SourceManager &SM);\n\n  static PathDiagnosticCallPiece *construct(PathPieces &pieces,\n                                            const Decl *caller);\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Call;\n  }\n};\n\nclass PathDiagnosticControlFlowPiece : public PathDiagnosticPiece {\n  std::vector<PathDiagnosticLocationPair> LPairs;\n\npublic:\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos,\n                                 StringRef s)\n      : PathDiagnosticPiece(s, ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos)\n      : PathDiagnosticPiece(ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  ~PathDiagnosticControlFlowPiece() override;\n\n  PathDiagnosticLocation getStartLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getStart();\n  }\n\n  PathDiagnosticLocation getEndLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getEnd();\n  }\n\n  void setStartLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setStart(L);\n  }\n\n  void setEndLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setEnd(L);\n  }\n\n  void push_back(const PathDiagnosticLocationPair &X) { LPairs.push_back(X); }\n\n  PathDiagnosticLocation getLocation() const override {\n    return getStartLocation();\n  }\n\n  using iterator = std::vector<PathDiagnosticLocationPair>::iterator;\n\n  iterator begin() { return LPairs.begin(); }\n  iterator end() { return LPairs.end(); }\n\n  void flattenLocations() override {\n    for (auto &I : *this)\n      I.flatten();\n  }\n\n  using const_iterator =\n      std::vector<PathDiagnosticLocationPair>::const_iterator;\n\n  const_iterator begin() const { return LPairs.begin(); }\n  const_iterator end() const { return LPairs.end(); }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == ControlFlow;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticMacroPiece : public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticMacroPiece(const PathDiagnosticLocation &pos)\n      : PathDiagnosticSpotPiece(pos, \"\", Macro) {}\n  ~PathDiagnosticMacroPiece() override;\n\n  PathPieces subPieces;\n\n  void flattenLocations() override {\n    PathDiagnosticSpotPiece::flattenLocations();\n    for (const auto &I : subPieces)\n      I->flattenLocations();\n  }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Macro;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticNotePiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticNotePiece(const PathDiagnosticLocation &Pos, StringRef S,\n                          bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, Note, AddPosRange) {}\n  ~PathDiagnosticNotePiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Note;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticPopUpPiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticPopUpPiece(const PathDiagnosticLocation &Pos, StringRef S,\n                           bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, PopUp, AddPosRange) {}\n  ~PathDiagnosticPopUpPiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == PopUp;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\n/// File IDs mapped to sets of line numbers.\nusing FilesToLineNumsMap = std::map<FileID, std::set<unsigned>>;\n\n/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive\n///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,\n///  each which represent the pieces of the path.\nclass PathDiagnostic : public llvm::FoldingSetNode {\n  std::string CheckerName;\n  const Decl *DeclWithIssue;\n  std::string BugType;\n  std::string VerboseDesc;\n  std::string ShortDesc;\n  std::string Category;\n  std::deque<std::string> OtherDesc;\n\n  /// Loc The location of the path diagnostic report.\n  PathDiagnosticLocation Loc;\n\n  PathPieces pathImpl;\n  SmallVector<PathPieces *, 3> pathStack;\n\n  /// Important bug uniqueing location.\n  /// The location info is useful to differentiate between bugs.\n  PathDiagnosticLocation UniqueingLoc;\n  const Decl *UniqueingDecl;\n\n  /// Lines executed in the path.\n  std::unique_ptr<FilesToLineNumsMap> ExecutedLines;\n\npublic:\n  PathDiagnostic() = delete;\n  PathDiagnostic(StringRef CheckerName, const Decl *DeclWithIssue,\n                 StringRef bugtype, StringRef verboseDesc, StringRef shortDesc,\n                 StringRef category, PathDiagnosticLocation LocationToUnique,\n                 const Decl *DeclToUnique,\n                 std::unique_ptr<FilesToLineNumsMap> ExecutedLines);\n  ~PathDiagnostic();\n\n  const PathPieces &path;\n\n  /// Return the path currently used by builders for constructing the\n  /// PathDiagnostic.\n  PathPieces &getActivePath() {\n    if (pathStack.empty())\n      return pathImpl;\n    return *pathStack.back();\n  }\n\n  /// Return a mutable version of 'path'.\n  PathPieces &getMutablePieces() {\n    return pathImpl;\n  }\n\n  /// Return the unrolled size of the path.\n  unsigned full_size();\n\n  void pushActivePath(PathPieces *p) { pathStack.push_back(p); }\n  void popActivePath() { if (!pathStack.empty()) pathStack.pop_back(); }\n\n  bool isWithinCall() const { return !pathStack.empty(); }\n\n  void setEndOfPath(PathDiagnosticPieceRef EndPiece) {\n    assert(!Loc.isValid() && \"End location already set!\");\n    Loc = EndPiece->getLocation();\n    assert(Loc.isValid() && \"Invalid location for end-of-path piece\");\n    getActivePath().push_back(std::move(EndPiece));\n  }\n\n  void appendToDesc(StringRef S) {\n    if (!ShortDesc.empty())\n      ShortDesc += S;\n    VerboseDesc += S;\n  }\n\n  StringRef getVerboseDescription() const { return VerboseDesc; }\n\n  StringRef getShortDescription() const {\n    return ShortDesc.empty() ? VerboseDesc : ShortDesc;\n  }\n\n  StringRef getCheckerName() const { return CheckerName; }\n  StringRef getBugType() const { return BugType; }\n  StringRef getCategory() const { return Category; }\n\n  using meta_iterator = std::deque<std::string>::const_iterator;\n\n  meta_iterator meta_begin() const { return OtherDesc.begin(); }\n  meta_iterator meta_end() const { return OtherDesc.end(); }\n  void addMeta(StringRef s) { OtherDesc.push_back(std::string(s)); }\n\n  const FilesToLineNumsMap &getExecutedLines() const {\n    return *ExecutedLines;\n  }\n\n  FilesToLineNumsMap &getExecutedLines() {\n    return *ExecutedLines;\n  }\n\n  /// Return the semantic context where an issue occurred.  If the\n  /// issue occurs along a path, this represents the \"central\" area\n  /// where the bug manifests.\n  const Decl *getDeclWithIssue() const { return DeclWithIssue; }\n\n  void setDeclWithIssue(const Decl *D) {\n    DeclWithIssue = D;\n  }\n\n  PathDiagnosticLocation getLocation() const {\n    return Loc;\n  }\n\n  void setLocation(PathDiagnosticLocation NewLoc) {\n    Loc = NewLoc;\n  }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLoc() const {\n    return UniqueingLoc;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const {\n    return UniqueingDecl;\n  }\n\n  void flattenLocations() {\n    Loc.flatten();\n    for (const auto &I : pathImpl)\n      I->flattenLocations();\n  }\n\n  /// Profiles the diagnostic, independent of the path it references.\n  ///\n  /// This can be used to merge diagnostics that refer to the same issue\n  /// along different paths.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  /// Profiles the diagnostic, including its path.\n  ///\n  /// Two diagnostics with the same issue along different paths will generate\n  /// different profiles.\n  void FullProfile(llvm::FoldingSetNodeID &ID) const;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "content": "//===- clang/Basic/DirectoryEntry.h - Directory references ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::DirectoryEntry and clang::DirectoryEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n#define LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n\nnamespace clang {\nnamespace FileMgr {\n\ntemplate <class RefTy> class MapEntryOptionalStorage;\n\n} // end namespace FileMgr\n\n/// Cached information about one directory (either on disk or in\n/// the virtual file system).\nclass DirectoryEntry {\n  friend class FileManager;\n\n  // FIXME: We should not be storing a directory entry name here.\n  StringRef Name; // Name of the directory.\n\npublic:\n  StringRef getName() const { return Name; }\n};\n\n/// A reference to a \\c DirectoryEntry  that includes the name of the directory\n/// as it was accessed by the FileManager's client.\nclass DirectoryEntryRef {\npublic:\n  const DirectoryEntry &getDirEntry() const { return *ME->getValue(); }\n\n  StringRef getName() const { return ME->getKey(); }\n\n  /// Hash code is based on the DirectoryEntry, not the specific named\n  /// reference.\n  friend llvm::hash_code hash_value(DirectoryEntryRef Ref) {\n    return llvm::hash_value(&Ref.getDirEntry());\n  }\n\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<DirectoryEntry &>>;\n\n  const MapEntry &getMapEntry() const { return *ME; }\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(DirectoryEntryRef RHS) const { return ME == RHS.ME; }\n\n  DirectoryEntryRef() = delete;\n  DirectoryEntryRef(const MapEntry &ME) : ME(&ME) {}\n\n  /// Allow DirectoryEntryRef to degrade into 'const DirectoryEntry*' to\n  /// facilitate incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getDirectoryEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::getName\n  /// has been deleted, delete this implicit conversion.\n  operator const DirectoryEntry *() const { return &getDirEntry(); }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<DirectoryEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  DirectoryEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<DirectoryEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  DirectoryEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  DirectoryEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(DirectoryEntryRef(dense_map_empty_tag())) ||\n           isSameRef(DirectoryEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nnamespace FileMgr {\n\n/// Customized storage for refs derived from map entires in FileManager, using\n/// the private optional_none_tag to keep it to the size of a single pointer.\ntemplate <class RefTy> class MapEntryOptionalStorage {\n  using optional_none_tag = typename RefTy::optional_none_tag;\n  RefTy MaybeRef;\n\npublic:\n  MapEntryOptionalStorage() : MaybeRef(optional_none_tag()) {}\n\n  template <class... ArgTypes>\n  explicit MapEntryOptionalStorage(llvm::optional_detail::in_place_t,\n                                   ArgTypes &&...Args)\n      : MaybeRef(std::forward<ArgTypes>(Args)...) {}\n\n  void reset() { MaybeRef = optional_none_tag(); }\n\n  bool hasValue() const { return MaybeRef.hasOptionalValue(); }\n\n  RefTy &getValue() LLVM_LVALUE_FUNCTION {\n    assert(hasValue());\n    return MaybeRef;\n  }\n  RefTy const &getValue() const LLVM_LVALUE_FUNCTION {\n    assert(hasValue());\n    return MaybeRef;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  RefTy &&getValue() && {\n    assert(hasValue());\n    return std::move(MaybeRef);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&...args) {\n    MaybeRef = RefTy(std::forward<Args>(args)...);\n  }\n\n  MapEntryOptionalStorage &operator=(RefTy Ref) {\n    MaybeRef = Ref;\n    return *this;\n  }\n};\n\n} // end namespace FileMgr\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<DirectoryEntryRef> to use DirectoryEntryRef and\n/// its optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::DirectoryEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::DirectoryEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::DirectoryEntryRef>) ==\n                  sizeof(clang::DirectoryEntryRef),\n              \"Optional<DirectoryEntryRef> must avoid size overhead\");\n\nstatic_assert(\n    std::is_trivially_copyable<Optional<clang::DirectoryEntryRef>>::value,\n    \"Optional<DirectoryEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for DirectoryEntryRef.\ntemplate <> struct DenseMapInfo<clang::DirectoryEntryRef> {\n  static inline clang::DirectoryEntryRef getEmptyKey() {\n    return clang::DirectoryEntryRef(\n        clang::DirectoryEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::DirectoryEntryRef getTombstoneKey() {\n    return clang::DirectoryEntryRef(\n        clang::DirectoryEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::DirectoryEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::DirectoryEntryRef LHS,\n                      clang::DirectoryEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<DirectoryEntryRef> that degrades to 'const\n/// DirectoryEntry*', facilitating incremental patches to propagate\n/// DirectoryEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<DirectoryEntryRef> to degrade to a 'const DirectoryEntry*'. The\n/// purpose is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<DirectoryEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getDirectoryEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::LastRef\n/// and DirectoryEntry::getName have been deleted, delete this class and\n/// replace instances with Optional<DirectoryEntryRef>.\nclass OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr\n    : public Optional<DirectoryEntryRef> {\npublic:\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr() = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(\n      OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &&) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(\n      const OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &&) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(const OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &) = default;\n\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(llvm::NoneType) {}\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(DirectoryEntryRef Ref)\n      : Optional<DirectoryEntryRef>(Ref) {}\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(Optional<DirectoryEntryRef> MaybeRef)\n      : Optional<DirectoryEntryRef>(MaybeRef) {}\n\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &operator=(llvm::NoneType) {\n    Optional<DirectoryEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &operator=(DirectoryEntryRef Ref) {\n    Optional<DirectoryEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(Optional<DirectoryEntryRef> MaybeRef) {\n    Optional<DirectoryEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const DirectoryEntry *' to allow  DirectoryEntry::LastRef and\n  /// DirectoryEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<DirectoryEntryRef>\n  operator const DirectoryEntry *() const {\n    return hasValue() ? &getValue().getDirEntry() : nullptr;\n  }\n};\n\nstatic_assert(std::is_trivially_copyable<\n                  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr>::value,\n              \"OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr should be \"\n              \"trivially copyable\");\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "content": "//===- clang/Basic/FileEntry.h - File references ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::FileEntry and clang::FileEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_FILEENTRY_H\n#define LLVM_CLANG_BASIC_FILEENTRY_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nnamespace vfs {\n\nclass File;\n\n} // namespace vfs\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntryRef;\n\n} // namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Forward declare a template specialization for OptionalStorage.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef, /*is_trivially_copyable*/ true>;\n\n} // namespace optional_detail\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntry;\n\n/// A reference to a \\c FileEntry that includes the name of the file as it was\n/// accessed by the FileManager's client.\nclass FileEntryRef {\npublic:\n  StringRef getName() const { return ME->first(); }\n  const FileEntry &getFileEntry() const {\n    return *ME->second->V.get<FileEntry *>();\n  }\n  DirectoryEntryRef getDir() const { return *ME->second->Dir; }\n\n  inline bool isValid() const;\n  inline off_t getSize() const;\n  inline unsigned getUID() const;\n  inline const llvm::sys::fs::UniqueID &getUniqueID() const;\n  inline time_t getModificationTime() const;\n  inline bool isNamedPipe() const;\n  inline void closeFile() const;\n\n  /// Check if the underlying FileEntry is the same, intentially ignoring\n  /// whether the file was referenced with the same spelling of the filename.\n  friend bool operator==(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return &LHS.getFileEntry() == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return LHS == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return &LHS.getFileEntry() == RHS;\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Hash code is based on the FileEntry, not the specific named reference,\n  /// just like operator==.\n  friend llvm::hash_code hash_value(FileEntryRef Ref) {\n    return llvm::hash_value(&Ref.getFileEntry());\n  }\n\n  struct MapValue;\n\n  /// Type used in the StringMap.\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<MapValue>>;\n\n  /// Type stored in the StringMap.\n  struct MapValue {\n    /// The pointer at another MapEntry is used when the FileManager should\n    /// silently forward from one name to another, which occurs in Redirecting\n    /// VFSs that use external names. In that case, the \\c FileEntryRef\n    /// returned by the \\c FileManager will have the external name, and not the\n    /// name that was used to lookup the file.\n    ///\n    /// The second type is really a `const MapEntry *`, but that confuses\n    /// gcc5.3.  Once that's no longer supported, change this back.\n    llvm::PointerUnion<FileEntry *, const void *> V;\n\n    /// Directory the file was found in. Set if and only if V is a FileEntry.\n    Optional<DirectoryEntryRef> Dir;\n\n    MapValue() = delete;\n    MapValue(FileEntry &FE, DirectoryEntryRef Dir) : V(&FE), Dir(Dir) {}\n    MapValue(MapEntry &ME) : V(&ME) {}\n  };\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(const FileEntryRef &RHS) const { return ME == RHS.ME; }\n\n  /// Allow FileEntryRef to degrade into 'const FileEntry*' to facilitate\n  /// incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getFileEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this implicit conversion.\n  operator const FileEntry *() const { return &getFileEntry(); }\n\n  FileEntryRef() = delete;\n  explicit FileEntryRef(const MapEntry &ME) : ME(&ME) {\n    assert(ME.second && \"Expected payload\");\n    assert(ME.second->V && \"Expected non-null\");\n    assert(ME.second->V.is<FileEntry *>() && \"Expected FileEntry\");\n  }\n\n  /// Expose the underlying MapEntry to simplify packing in a PointerIntPair or\n  /// PointerUnion and allow construction in Optional.\n  const clang::FileEntryRef::MapEntry &getMapEntry() const { return *ME; }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<FileEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  FileEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<FileEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  FileEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  FileEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(FileEntryRef(dense_map_empty_tag())) ||\n           isSameRef(FileEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nstatic_assert(sizeof(FileEntryRef) == sizeof(const FileEntry *),\n              \"FileEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<FileEntryRef>::value,\n              \"FileEntryRef must be trivially copyable\");\n\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<FileEntryRef> to use FileEntryRef and its\n/// optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::FileEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::FileEntryRef>) ==\n                  sizeof(clang::FileEntryRef),\n              \"Optional<FileEntryRef> must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<Optional<clang::FileEntryRef>>::value,\n              \"Optional<FileEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for FileEntryRef.\ntemplate <> struct DenseMapInfo<clang::FileEntryRef> {\n  static inline clang::FileEntryRef getEmptyKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::FileEntryRef getTombstoneKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::FileEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::FileEntryRef LHS, clang::FileEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<FileEntryRef> that degrades to 'const FileEntry*',\n/// facilitating incremental patches to propagate FileEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<FileEntryRef> to degrade to a 'const FileEntry*'. The purpose\n/// is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<FileEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getFileEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n/// FileEntry::getName have been deleted, delete this class and replace\n/// instances with Optional<FileEntryRef>.\nclass OptionalFileEntryRefDegradesToFileEntryPtr\n    : public Optional<FileEntryRef> {\npublic:\n  OptionalFileEntryRefDegradesToFileEntryPtr() = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n\n  OptionalFileEntryRefDegradesToFileEntryPtr(llvm::NoneType) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(FileEntryRef Ref)\n      : Optional<FileEntryRef>(Ref) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(Optional<FileEntryRef> MaybeRef)\n      : Optional<FileEntryRef>(MaybeRef) {}\n\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(llvm::NoneType) {\n    Optional<FileEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(FileEntryRef Ref) {\n    Optional<FileEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(Optional<FileEntryRef> MaybeRef) {\n    Optional<FileEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const FileEntry *' to allow  FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<FileEntryRef>\n  operator const FileEntry *() const {\n    return hasValue() ? &getValue().getFileEntry() : nullptr;\n  }\n};\n\nstatic_assert(\n    std::is_trivially_copyable<\n        OptionalFileEntryRefDegradesToFileEntryPtr>::value,\n    \"OptionalFileEntryRefDegradesToFileEntryPtr should be trivially copyable\");\n\n/// Cached information about one file (either on disk\n/// or in the virtual file system).\n///\n/// If the 'File' member is valid, then this FileEntry has an open file\n/// descriptor for the file.\nclass FileEntry {\n  friend class FileManager;\n\n  std::string RealPathName;   // Real path to the file; could be empty.\n  off_t Size = 0;             // File size in bytes.\n  time_t ModTime = 0;         // Modification time of file.\n  const DirectoryEntry *Dir = nullptr; // Directory file lives in.\n  llvm::sys::fs::UniqueID UniqueID;\n  unsigned UID = 0; // A unique (small) ID for the file.\n  bool IsNamedPipe = false;\n  bool IsValid = false; // Is this \\c FileEntry initialized and valid?\n\n  /// The open file, if it is owned by the \\p FileEntry.\n  mutable std::unique_ptr<llvm::vfs::File> File;\n\n  /// The file content, if it is owned by the \\p FileEntry.\n  std::unique_ptr<llvm::MemoryBuffer> Content;\n\n  // First access name for this FileEntry.\n  //\n  // This is Optional only to allow delayed construction (FileEntryRef has no\n  // default constructor). It should always have a value in practice.\n  //\n  // TODO: remove this once everyone that needs a name uses FileEntryRef.\n  Optional<FileEntryRef> LastRef;\n\npublic:\n  FileEntry();\n  ~FileEntry();\n\n  FileEntry(const FileEntry &) = delete;\n  FileEntry &operator=(const FileEntry &) = delete;\n\n  StringRef getName() const { return LastRef->getName(); }\n  FileEntryRef getLastRef() const { return *LastRef; }\n\n  StringRef tryGetRealPathName() const { return RealPathName; }\n  bool isValid() const { return IsValid; }\n  off_t getSize() const { return Size; }\n  unsigned getUID() const { return UID; }\n  const llvm::sys::fs::UniqueID &getUniqueID() const { return UniqueID; }\n  time_t getModificationTime() const { return ModTime; }\n\n  /// Return the directory the file lives in.\n  const DirectoryEntry *getDir() const { return Dir; }\n\n  bool operator<(const FileEntry &RHS) const { return UniqueID < RHS.UniqueID; }\n\n  /// Check whether the file is a named pipe (and thus can't be opened by\n  /// the native FileManager methods).\n  bool isNamedPipe() const { return IsNamedPipe; }\n\n  void closeFile() const;\n};\n\nbool FileEntryRef::isValid() const { return getFileEntry().isValid(); }\n\noff_t FileEntryRef::getSize() const { return getFileEntry().getSize(); }\n\nunsigned FileEntryRef::getUID() const { return getFileEntry().getUID(); }\n\nconst llvm::sys::fs::UniqueID &FileEntryRef::getUniqueID() const {\n  return getFileEntry().getUniqueID();\n}\n\ntime_t FileEntryRef::getModificationTime() const {\n  return getFileEntry().getModificationTime();\n}\n\nbool FileEntryRef::isNamedPipe() const { return getFileEntry().isNamedPipe(); }\n\nvoid FileEntryRef::closeFile() const { getFileEntry().closeFile(); }\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_FILEENTRY_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LLVM.h", "content": "//===--- LLVM.h - Import various common LLVM datatypes ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Forward-declares and imports various common LLVM datatypes that\n/// clang wants to use unqualified.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_LLVM_H\n#define LLVM_CLANG_BASIC_LLVM_H\n\n// Do not proliferate #includes here, require clients to #include their\n// dependencies.\n// Casting.h has complex templates that cannot be easily forward declared.\n#include \"llvm/Support/Casting.h\"\n// None.h includes an enumerator that is desired & cannot be forward declared\n// without a definition of NoneType.\n#include \"llvm/ADT/None.h\"\n\nnamespace llvm {\n  // ADT's.\n  class StringRef;\n  class Twine;\n  class VersionTuple;\n  template<typename T> class ArrayRef;\n  template<typename T> class MutableArrayRef;\n  template<typename T> class OwningArrayRef;\n  template<unsigned InternalLen> class SmallString;\n  template<typename T, unsigned N> class SmallVector;\n  template<typename T> class SmallVectorImpl;\n  template<typename T> class Optional;\n  template <class T> class Expected;\n\n  template<typename T>\n  struct SaveAndRestore;\n\n  // Reference counting.\n  template <typename T> class IntrusiveRefCntPtr;\n  template <typename T> struct IntrusiveRefCntPtrInfo;\n  template <class Derived> class RefCountedBase;\n\n  class raw_ostream;\n  class raw_pwrite_stream;\n  // TODO: DenseMap, ...\n}\n\n\nnamespace clang {\n  // Casting operators.\n  using llvm::isa;\n  using llvm::isa_and_nonnull;\n  using llvm::cast;\n  using llvm::dyn_cast;\n  using llvm::dyn_cast_or_null;\n  using llvm::cast_or_null;\n\n  // ADT's.\n  using llvm::ArrayRef;\n  using llvm::MutableArrayRef;\n  using llvm::None;\n  using llvm::Optional;\n  using llvm::OwningArrayRef;\n  using llvm::SaveAndRestore;\n  using llvm::SmallString;\n  using llvm::SmallVector;\n  using llvm::SmallVectorImpl;\n  using llvm::StringRef;\n  using llvm::Twine;\n  using llvm::VersionTuple;\n\n  // Error handling.\n  using llvm::Expected;\n\n  // Reference counting.\n  using llvm::IntrusiveRefCntPtr;\n  using llvm::IntrusiveRefCntPtrInfo;\n  using llvm::RefCountedBase;\n\n  using llvm::raw_ostream;\n  using llvm::raw_pwrite_stream;\n} // end namespace clang.\n\n#endif\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "content": "//===- Module.h - Describe a module -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Module class, which describes a module in the\n/// source code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_MODULE_H\n#define LLVM_CLANG_BASIC_MODULE_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/FileEntry.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <iterator>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass FileManager;\nclass LangOptions;\nclass TargetInfo;\n\n/// Describes the name of a module.\nusing ModuleId = SmallVector<std::pair<std::string, SourceLocation>, 2>;\n\n/// The signature of a module, which is a hash of the AST content.\nstruct ASTFileSignature : std::array<uint8_t, 20> {\n  using BaseT = std::array<uint8_t, 20>;\n\n  static constexpr size_t size = std::tuple_size<BaseT>::value;\n\n  ASTFileSignature(BaseT S = {{0}}) : BaseT(std::move(S)) {}\n\n  explicit operator bool() const { return *this != BaseT({{0}}); }\n\n  /// Returns the value truncated to the size of an uint64_t.\n  uint64_t truncatedValue() const {\n    uint64_t Value = 0;\n    static_assert(sizeof(*this) >= sizeof(uint64_t), \"No need to truncate.\");\n    for (unsigned I = 0; I < sizeof(uint64_t); ++I)\n      Value |= static_cast<uint64_t>((*this)[I]) << (I * 8);\n    return Value;\n  }\n\n  static ASTFileSignature create(StringRef Bytes) {\n    return create(Bytes.bytes_begin(), Bytes.bytes_end());\n  }\n\n  static ASTFileSignature createDISentinel() {\n    ASTFileSignature Sentinel;\n    Sentinel.fill(0xFF);\n    return Sentinel;\n  }\n\n  template <typename InputIt>\n  static ASTFileSignature create(InputIt First, InputIt Last) {\n    assert(std::distance(First, Last) == size &&\n           \"Wrong amount of bytes to create an ASTFileSignature\");\n\n    ASTFileSignature Signature;\n    std::copy(First, Last, Signature.begin());\n    return Signature;\n  }\n};\n\n/// Describes a module or submodule.\nclass Module {\npublic:\n  /// The name of this module.\n  std::string Name;\n\n  /// The location of the module definition.\n  SourceLocation DefinitionLoc;\n\n  enum ModuleKind {\n    /// This is a module that was defined by a module map and built out\n    /// of header files.\n    ModuleMapModule,\n\n    /// This is a C++ Modules TS module interface unit.\n    ModuleInterfaceUnit,\n\n    /// This is a fragment of the global module within some C++ module.\n    GlobalModuleFragment,\n\n    /// This is the private module fragment within some C++ module.\n    PrivateModuleFragment,\n  };\n\n  /// The kind of this module.\n  ModuleKind Kind = ModuleMapModule;\n\n  /// The parent of this module. This will be NULL for the top-level\n  /// module.\n  Module *Parent;\n\n  /// The build directory of this module. This is the directory in\n  /// which the module is notionally built, and relative to which its headers\n  /// are found.\n  const DirectoryEntry *Directory = nullptr;\n\n  /// The presumed file name for the module map defining this module.\n  /// Only non-empty when building from preprocessed source.\n  std::string PresumedModuleMapFile;\n\n  /// The umbrella header or directory.\n  llvm::PointerUnion<const FileEntry *, const DirectoryEntry *> Umbrella;\n\n  /// The module signature.\n  ASTFileSignature Signature;\n\n  /// The name of the umbrella entry, as written in the module map.\n  std::string UmbrellaAsWritten;\n\n  /// The module through which entities defined in this module will\n  /// eventually be exposed, for use in \"private\" modules.\n  std::string ExportAsModule;\n\n  /// Does this Module scope describe part of the purview of a named C++ module?\n  bool isModulePurview() const {\n    return Kind == ModuleInterfaceUnit || Kind == PrivateModuleFragment;\n  }\n\nprivate:\n  /// The submodules of this module, indexed by name.\n  std::vector<Module *> SubModules;\n\n  /// A mapping from the submodule name to the index into the\n  /// \\c SubModules vector at which that submodule resides.\n  llvm::StringMap<unsigned> SubModuleIndex;\n\n  /// The AST file if this is a top-level module which has a\n  /// corresponding serialized AST file, or null otherwise.\n  Optional<FileEntryRef> ASTFile;\n\n  /// The top-level headers associated with this module.\n  llvm::SmallSetVector<const FileEntry *, 2> TopHeaders;\n\n  /// top-level header filenames that aren't resolved to FileEntries yet.\n  std::vector<std::string> TopHeaderNames;\n\n  /// Cache of modules visible to lookup in this module.\n  mutable llvm::DenseSet<const Module*> VisibleModulesCache;\n\n  /// The ID used when referencing this module within a VisibleModuleSet.\n  unsigned VisibilityID;\n\npublic:\n  enum HeaderKind {\n    HK_Normal,\n    HK_Textual,\n    HK_Private,\n    HK_PrivateTextual,\n    HK_Excluded\n  };\n  static const int NumHeaderKinds = HK_Excluded + 1;\n\n  /// Information about a header directive as found in the module map\n  /// file.\n  struct Header {\n    std::string NameAsWritten;\n    const FileEntry *Entry;\n\n    explicit operator bool() { return Entry; }\n  };\n\n  /// Information about a directory name as found in the module map\n  /// file.\n  struct DirectoryName {\n    std::string NameAsWritten;\n    const DirectoryEntry *Entry;\n\n    explicit operator bool() { return Entry; }\n  };\n\n  /// The headers that are part of this module.\n  SmallVector<Header, 2> Headers[5];\n\n  /// Stored information about a header directive that was found in the\n  /// module map file but has not been resolved to a file.\n  struct UnresolvedHeaderDirective {\n    HeaderKind Kind = HK_Normal;\n    SourceLocation FileNameLoc;\n    std::string FileName;\n    bool IsUmbrella = false;\n    bool HasBuiltinHeader = false;\n    Optional<off_t> Size;\n    Optional<time_t> ModTime;\n  };\n\n  /// Headers that are mentioned in the module map file but that we have not\n  /// yet attempted to resolve to a file on the file system.\n  SmallVector<UnresolvedHeaderDirective, 1> UnresolvedHeaders;\n\n  /// Headers that are mentioned in the module map file but could not be\n  /// found on the file system.\n  SmallVector<UnresolvedHeaderDirective, 1> MissingHeaders;\n\n  /// An individual requirement: a feature name and a flag indicating\n  /// the required state of that feature.\n  using Requirement = std::pair<std::string, bool>;\n\n  /// The set of language features required to use this module.\n  ///\n  /// If any of these requirements are not available, the \\c IsAvailable bit\n  /// will be false to indicate that this (sub)module is not available.\n  SmallVector<Requirement, 2> Requirements;\n\n  /// A module with the same name that shadows this module.\n  Module *ShadowingModule = nullptr;\n\n  /// Whether this module has declared itself unimportable, either because\n  /// it's missing a requirement from \\p Requirements or because it's been\n  /// shadowed by another module.\n  unsigned IsUnimportable : 1;\n\n  /// Whether we tried and failed to load a module file for this module.\n  unsigned HasIncompatibleModuleFile : 1;\n\n  /// Whether this module is available in the current translation unit.\n  ///\n  /// If the module is missing headers or does not meet all requirements then\n  /// this bit will be 0.\n  unsigned IsAvailable : 1;\n\n  /// Whether this module was loaded from a module file.\n  unsigned IsFromModuleFile : 1;\n\n  /// Whether this is a framework module.\n  unsigned IsFramework : 1;\n\n  /// Whether this is an explicit submodule.\n  unsigned IsExplicit : 1;\n\n  /// Whether this is a \"system\" module (which assumes that all\n  /// headers in it are system headers).\n  unsigned IsSystem : 1;\n\n  /// Whether this is an 'extern \"C\"' module (which implicitly puts all\n  /// headers in it within an 'extern \"C\"' block, and allows the module to be\n  /// imported within such a block).\n  unsigned IsExternC : 1;\n\n  /// Whether this is an inferred submodule (module * { ... }).\n  unsigned IsInferred : 1;\n\n  /// Whether we should infer submodules for this module based on\n  /// the headers.\n  ///\n  /// Submodules can only be inferred for modules with an umbrella header.\n  unsigned InferSubmodules : 1;\n\n  /// Whether, when inferring submodules, the inferred submodules\n  /// should be explicit.\n  unsigned InferExplicitSubmodules : 1;\n\n  /// Whether, when inferring submodules, the inferr submodules should\n  /// export all modules they import (e.g., the equivalent of \"export *\").\n  unsigned InferExportWildcard : 1;\n\n  /// Whether the set of configuration macros is exhaustive.\n  ///\n  /// When the set of configuration macros is exhaustive, meaning\n  /// that no identifier not in this list should affect how the module is\n  /// built.\n  unsigned ConfigMacrosExhaustive : 1;\n\n  /// Whether files in this module can only include non-modular headers\n  /// and headers from used modules.\n  unsigned NoUndeclaredIncludes : 1;\n\n  /// Whether this module came from a \"private\" module map, found next\n  /// to a regular (public) module map.\n  unsigned ModuleMapIsPrivate : 1;\n\n  /// Describes the visibility of the various names within a\n  /// particular module.\n  enum NameVisibilityKind {\n    /// All of the names in this module are hidden.\n    Hidden,\n    /// All of the names in this module are visible.\n    AllVisible\n  };\n\n  /// The visibility of names within this particular module.\n  NameVisibilityKind NameVisibility;\n\n  /// The location of the inferred submodule.\n  SourceLocation InferredSubmoduleLoc;\n\n  /// The set of modules imported by this module, and on which this\n  /// module depends.\n  llvm::SmallSetVector<Module *, 2> Imports;\n\n  /// Describes an exported module.\n  ///\n  /// The pointer is the module being re-exported, while the bit will be true\n  /// to indicate that this is a wildcard export.\n  using ExportDecl = llvm::PointerIntPair<Module *, 1, bool>;\n\n  /// The set of export declarations.\n  SmallVector<ExportDecl, 2> Exports;\n\n  /// Describes an exported module that has not yet been resolved\n  /// (perhaps because the module it refers to has not yet been loaded).\n  struct UnresolvedExportDecl {\n    /// The location of the 'export' keyword in the module map file.\n    SourceLocation ExportLoc;\n\n    /// The name of the module.\n    ModuleId Id;\n\n    /// Whether this export declaration ends in a wildcard, indicating\n    /// that all of its submodules should be exported (rather than the named\n    /// module itself).\n    bool Wildcard;\n  };\n\n  /// The set of export declarations that have yet to be resolved.\n  SmallVector<UnresolvedExportDecl, 2> UnresolvedExports;\n\n  /// The directly used modules.\n  SmallVector<Module *, 2> DirectUses;\n\n  /// The set of use declarations that have yet to be resolved.\n  SmallVector<ModuleId, 2> UnresolvedDirectUses;\n\n  /// A library or framework to link against when an entity from this\n  /// module is used.\n  struct LinkLibrary {\n    LinkLibrary() = default;\n    LinkLibrary(const std::string &Library, bool IsFramework)\n        : Library(Library), IsFramework(IsFramework) {}\n\n    /// The library to link against.\n    ///\n    /// This will typically be a library or framework name, but can also\n    /// be an absolute path to the library or framework.\n    std::string Library;\n\n    /// Whether this is a framework rather than a library.\n    bool IsFramework = false;\n  };\n\n  /// The set of libraries or frameworks to link against when\n  /// an entity from this module is used.\n  llvm::SmallVector<LinkLibrary, 2> LinkLibraries;\n\n  /// Autolinking uses the framework name for linking purposes\n  /// when this is false and the export_as name otherwise.\n  bool UseExportAsModuleLinkName = false;\n\n  /// The set of \"configuration macros\", which are macros that\n  /// (intentionally) change how this module is built.\n  std::vector<std::string> ConfigMacros;\n\n  /// An unresolved conflict with another module.\n  struct UnresolvedConflict {\n    /// The (unresolved) module id.\n    ModuleId Id;\n\n    /// The message provided to the user when there is a conflict.\n    std::string Message;\n  };\n\n  /// The list of conflicts for which the module-id has not yet been\n  /// resolved.\n  std::vector<UnresolvedConflict> UnresolvedConflicts;\n\n  /// A conflict between two modules.\n  struct Conflict {\n    /// The module that this module conflicts with.\n    Module *Other;\n\n    /// The message provided to the user when there is a conflict.\n    std::string Message;\n  };\n\n  /// The list of conflicts.\n  std::vector<Conflict> Conflicts;\n\n  /// Construct a new module or submodule.\n  Module(StringRef Name, SourceLocation DefinitionLoc, Module *Parent,\n         bool IsFramework, bool IsExplicit, unsigned VisibilityID);\n\n  ~Module();\n\n  /// Determine whether this module has been declared unimportable.\n  bool isUnimportable() const { return IsUnimportable; }\n\n  /// Determine whether this module has been declared unimportable.\n  ///\n  /// \\param LangOpts The language options used for the current\n  /// translation unit.\n  ///\n  /// \\param Target The target options used for the current translation unit.\n  ///\n  /// \\param Req If this module is unimportable because of a missing\n  /// requirement, this parameter will be set to one of the requirements that\n  /// is not met for use of this module.\n  ///\n  /// \\param ShadowingModule If this module is unimportable because it is\n  /// shadowed, this parameter will be set to the shadowing module.\n  bool isUnimportable(const LangOptions &LangOpts, const TargetInfo &Target,\n                      Requirement &Req, Module *&ShadowingModule) const;\n\n  /// Determine whether this module is available for use within the\n  /// current translation unit.\n  bool isAvailable() const { return IsAvailable; }\n\n  /// Determine whether this module is available for use within the\n  /// current translation unit.\n  ///\n  /// \\param LangOpts The language options used for the current\n  /// translation unit.\n  ///\n  /// \\param Target The target options used for the current translation unit.\n  ///\n  /// \\param Req If this module is unavailable because of a missing requirement,\n  /// this parameter will be set to one of the requirements that is not met for\n  /// use of this module.\n  ///\n  /// \\param MissingHeader If this module is unavailable because of a missing\n  /// header, this parameter will be set to one of the missing headers.\n  ///\n  /// \\param ShadowingModule If this module is unavailable because it is\n  /// shadowed, this parameter will be set to the shadowing module.\n  bool isAvailable(const LangOptions &LangOpts,\n                   const TargetInfo &Target,\n                   Requirement &Req,\n                   UnresolvedHeaderDirective &MissingHeader,\n                   Module *&ShadowingModule) const;\n\n  /// Determine whether this module is a submodule.\n  bool isSubModule() const { return Parent != nullptr; }\n\n  /// Check if this module is a (possibly transitive) submodule of \\p Other.\n  ///\n  /// The 'A is a submodule of B' relation is a partial order based on the\n  /// the parent-child relationship between individual modules.\n  ///\n  /// Returns \\c false if \\p Other is \\c nullptr.\n  bool isSubModuleOf(const Module *Other) const;\n\n  /// Determine whether this module is a part of a framework,\n  /// either because it is a framework module or because it is a submodule\n  /// of a framework module.\n  bool isPartOfFramework() const {\n    for (const Module *Mod = this; Mod; Mod = Mod->Parent)\n      if (Mod->IsFramework)\n        return true;\n\n    return false;\n  }\n\n  /// Determine whether this module is a subframework of another\n  /// framework.\n  bool isSubFramework() const {\n    return IsFramework && Parent && Parent->isPartOfFramework();\n  }\n\n  /// Set the parent of this module. This should only be used if the parent\n  /// could not be set during module creation.\n  void setParent(Module *M) {\n    assert(!Parent);\n    Parent = M;\n    Parent->SubModuleIndex[Name] = Parent->SubModules.size();\n    Parent->SubModules.push_back(this);\n  }\n\n  /// Retrieve the full name of this module, including the path from\n  /// its top-level module.\n  /// \\param AllowStringLiterals If \\c true, components that might not be\n  ///        lexically valid as identifiers will be emitted as string literals.\n  std::string getFullModuleName(bool AllowStringLiterals = false) const;\n\n  /// Whether the full name of this module is equal to joining\n  /// \\p nameParts with \".\"s.\n  ///\n  /// This is more efficient than getFullModuleName().\n  bool fullModuleNameIs(ArrayRef<StringRef> nameParts) const;\n\n  /// Retrieve the top-level module for this (sub)module, which may\n  /// be this module.\n  Module *getTopLevelModule() {\n    return const_cast<Module *>(\n             const_cast<const Module *>(this)->getTopLevelModule());\n  }\n\n  /// Retrieve the top-level module for this (sub)module, which may\n  /// be this module.\n  const Module *getTopLevelModule() const;\n\n  /// Retrieve the name of the top-level module.\n  StringRef getTopLevelModuleName() const {\n    return getTopLevelModule()->Name;\n  }\n\n  /// The serialized AST file for this module, if one was created.\n  OptionalFileEntryRefDegradesToFileEntryPtr getASTFile() const {\n    return getTopLevelModule()->ASTFile;\n  }\n\n  /// Set the serialized AST file for the top-level module of this module.\n  void setASTFile(Optional<FileEntryRef> File) {\n    assert((!File || !getASTFile() || getASTFile() == File) &&\n           \"file path changed\");\n    getTopLevelModule()->ASTFile = File;\n  }\n\n  /// Retrieve the directory for which this module serves as the\n  /// umbrella.\n  DirectoryName getUmbrellaDir() const;\n\n  /// Retrieve the header that serves as the umbrella header for this\n  /// module.\n  Header getUmbrellaHeader() const {\n    if (auto *FE = Umbrella.dyn_cast<const FileEntry *>())\n      return Header{UmbrellaAsWritten, FE};\n    return Header{};\n  }\n\n  /// Determine whether this module has an umbrella directory that is\n  /// not based on an umbrella header.\n  bool hasUmbrellaDir() const {\n    return Umbrella && Umbrella.is<const DirectoryEntry *>();\n  }\n\n  /// Add a top-level header associated with this module.\n  void addTopHeader(const FileEntry *File);\n\n  /// Add a top-level header filename associated with this module.\n  void addTopHeaderFilename(StringRef Filename) {\n    TopHeaderNames.push_back(std::string(Filename));\n  }\n\n  /// The top-level headers associated with this module.\n  ArrayRef<const FileEntry *> getTopHeaders(FileManager &FileMgr);\n\n  /// Determine whether this module has declared its intention to\n  /// directly use another module.\n  bool directlyUses(const Module *Requested) const;\n\n  /// Add the given feature requirement to the list of features\n  /// required by this module.\n  ///\n  /// \\param Feature The feature that is required by this module (and\n  /// its submodules).\n  ///\n  /// \\param RequiredState The required state of this feature: \\c true\n  /// if it must be present, \\c false if it must be absent.\n  ///\n  /// \\param LangOpts The set of language options that will be used to\n  /// evaluate the availability of this feature.\n  ///\n  /// \\param Target The target options that will be used to evaluate the\n  /// availability of this feature.\n  void addRequirement(StringRef Feature, bool RequiredState,\n                      const LangOptions &LangOpts,\n                      const TargetInfo &Target);\n\n  /// Mark this module and all of its submodules as unavailable.\n  void markUnavailable(bool Unimportable);\n\n  /// Find the submodule with the given name.\n  ///\n  /// \\returns The submodule if found, or NULL otherwise.\n  Module *findSubmodule(StringRef Name) const;\n  Module *findOrInferSubmodule(StringRef Name);\n\n  /// Determine whether the specified module would be visible to\n  /// a lookup at the end of this module.\n  ///\n  /// FIXME: This may return incorrect results for (submodules of) the\n  /// module currently being built, if it's queried before we see all\n  /// of its imports.\n  bool isModuleVisible(const Module *M) const {\n    if (VisibleModulesCache.empty())\n      buildVisibleModulesCache();\n    return VisibleModulesCache.count(M);\n  }\n\n  unsigned getVisibilityID() const { return VisibilityID; }\n\n  using submodule_iterator = std::vector<Module *>::iterator;\n  using submodule_const_iterator = std::vector<Module *>::const_iterator;\n\n  submodule_iterator submodule_begin() { return SubModules.begin(); }\n  submodule_const_iterator submodule_begin() const {return SubModules.begin();}\n  submodule_iterator submodule_end()   { return SubModules.end(); }\n  submodule_const_iterator submodule_end() const { return SubModules.end(); }\n\n  llvm::iterator_range<submodule_iterator> submodules() {\n    return llvm::make_range(submodule_begin(), submodule_end());\n  }\n  llvm::iterator_range<submodule_const_iterator> submodules() const {\n    return llvm::make_range(submodule_begin(), submodule_end());\n  }\n\n  /// Appends this module's list of exported modules to \\p Exported.\n  ///\n  /// This provides a subset of immediately imported modules (the ones that are\n  /// directly exported), not the complete set of exported modules.\n  void getExportedModules(SmallVectorImpl<Module *> &Exported) const;\n\n  static StringRef getModuleInputBufferName() {\n    return \"<module-includes>\";\n  }\n\n  /// Print the module map for this module to the given stream.\n  void print(raw_ostream &OS, unsigned Indent = 0) const;\n\n  /// Dump the contents of this module to the given output stream.\n  void dump() const;\n\nprivate:\n  void buildVisibleModulesCache() const;\n};\n\n/// A set of visible modules.\nclass VisibleModuleSet {\npublic:\n  VisibleModuleSet() = default;\n  VisibleModuleSet(VisibleModuleSet &&O)\n      : ImportLocs(std::move(O.ImportLocs)), Generation(O.Generation ? 1 : 0) {\n    O.ImportLocs.clear();\n    ++O.Generation;\n  }\n\n  /// Move from another visible modules set. Guaranteed to leave the source\n  /// empty and bump the generation on both.\n  VisibleModuleSet &operator=(VisibleModuleSet &&O) {\n    ImportLocs = std::move(O.ImportLocs);\n    O.ImportLocs.clear();\n    ++O.Generation;\n    ++Generation;\n    return *this;\n  }\n\n  /// Get the current visibility generation. Incremented each time the\n  /// set of visible modules changes in any way.\n  unsigned getGeneration() const { return Generation; }\n\n  /// Determine whether a module is visible.\n  bool isVisible(const Module *M) const {\n    return getImportLoc(M).isValid();\n  }\n\n  /// Get the location at which the import of a module was triggered.\n  SourceLocation getImportLoc(const Module *M) const {\n    return M->getVisibilityID() < ImportLocs.size()\n               ? ImportLocs[M->getVisibilityID()]\n               : SourceLocation();\n  }\n\n  /// A callback to call when a module is made visible (directly or\n  /// indirectly) by a call to \\ref setVisible.\n  using VisibleCallback = llvm::function_ref<void(Module *M)>;\n\n  /// A callback to call when a module conflict is found. \\p Path\n  /// consists of a sequence of modules from the conflicting module to the one\n  /// made visible, where each was exported by the next.\n  using ConflictCallback =\n      llvm::function_ref<void(ArrayRef<Module *> Path, Module *Conflict,\n                         StringRef Message)>;\n\n  /// Make a specific module visible.\n  void setVisible(Module *M, SourceLocation Loc,\n                  VisibleCallback Vis = [](Module *) {},\n                  ConflictCallback Cb = [](ArrayRef<Module *>, Module *,\n                                           StringRef) {});\n\nprivate:\n  /// Import locations for each visible module. Indexed by the module's\n  /// VisibilityID.\n  std::vector<SourceLocation> ImportLocs;\n\n  /// Visibility generation, bumped every time the visibility state changes.\n  unsigned Generation = 0;\n};\n\n/// Abstracts clang modules and precompiled header files and holds\n/// everything needed to generate debug info for an imported module\n/// or PCH.\nclass ASTSourceDescriptor {\n  StringRef PCHModuleName;\n  StringRef Path;\n  StringRef ASTFile;\n  ASTFileSignature Signature;\n  Module *ClangModule = nullptr;\n\npublic:\n  ASTSourceDescriptor() = default;\n  ASTSourceDescriptor(StringRef Name, StringRef Path, StringRef ASTFile,\n                      ASTFileSignature Signature)\n      : PCHModuleName(std::move(Name)), Path(std::move(Path)),\n        ASTFile(std::move(ASTFile)), Signature(Signature) {}\n  ASTSourceDescriptor(Module &M);\n\n  std::string getModuleName() const;\n  StringRef getPath() const { return Path; }\n  StringRef getASTFile() const { return ASTFile; }\n  ASTFileSignature getSignature() const { return Signature; }\n  Module *getModuleOrNull() const { return ClangModule; }\n};\n\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_MODULE_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "content": "//===- SourceLocation.h - Compact identifier for Source Files ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::SourceLocation class and associated facilities.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SOURCELOCATION_H\n#define LLVM_CLANG_BASIC_SOURCELOCATION_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\ntemplate <typename T> struct DenseMapInfo;\n\nclass FoldingSetNodeID;\ntemplate <typename T> struct FoldingSetTrait;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass SourceManager;\n\n/// An opaque identifier used by SourceManager which refers to a\n/// source file (MemoryBuffer) along with its \\#include path and \\#line data.\n///\nclass FileID {\n  /// A mostly-opaque identifier, where 0 is \"invalid\", >0 is\n  /// this module, and <-1 is something loaded from another module.\n  int ID = 0;\n\npublic:\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\n  bool operator==(const FileID &RHS) const { return ID == RHS.ID; }\n  bool operator<(const FileID &RHS) const { return ID < RHS.ID; }\n  bool operator<=(const FileID &RHS) const { return ID <= RHS.ID; }\n  bool operator!=(const FileID &RHS) const { return !(*this == RHS); }\n  bool operator>(const FileID &RHS) const { return RHS < *this; }\n  bool operator>=(const FileID &RHS) const { return RHS <= *this; }\n\n  static FileID getSentinel() { return get(-1); }\n  unsigned getHashValue() const { return static_cast<unsigned>(ID); }\n\nprivate:\n  friend class ASTWriter;\n  friend class ASTReader;\n  friend class SourceManager;\n\n  static FileID get(int V) {\n    FileID F;\n    F.ID = V;\n    return F;\n  }\n\n  int getOpaqueValue() const { return ID; }\n};\n\n/// Encodes a location in the source. The SourceManager can decode this\n/// to get at the full include stack, line and column information.\n///\n/// Technically, a source location is simply an offset into the manager's view\n/// of the input source, which is all input buffers (including macro\n/// expansions) concatenated in an effectively arbitrary order. The manager\n/// actually maintains two blocks of input buffers. One, starting at offset\n/// 0 and growing upwards, contains all buffers from this module. The other,\n/// starting at the highest possible offset and growing downwards, contains\n/// buffers of loaded modules.\n///\n/// In addition, one bit of SourceLocation is used for quick access to the\n/// information whether the location is in a file or a macro expansion.\n///\n/// It is important that this type remains small. It is currently 32 bits wide.\nclass SourceLocation {\n  friend class ASTReader;\n  friend class ASTWriter;\n  friend class SourceManager;\n  friend struct llvm::FoldingSetTrait<SourceLocation>;\n\n  unsigned ID = 0;\n\n  enum : unsigned {\n    MacroIDBit = 1U << 31\n  };\n\npublic:\n  bool isFileID() const  { return (ID & MacroIDBit) == 0; }\n  bool isMacroID() const { return (ID & MacroIDBit) != 0; }\n\n  /// Return true if this is a valid SourceLocation object.\n  ///\n  /// Invalid SourceLocations are often used when events have no corresponding\n  /// location in the source (e.g. a diagnostic is required for a command line\n  /// option).\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\nprivate:\n  /// Return the offset into the manager's global input view.\n  unsigned getOffset() const {\n    return ID & ~MacroIDBit;\n  }\n\n  static SourceLocation getFileLoc(unsigned ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = ID;\n    return L;\n  }\n\n  static SourceLocation getMacroLoc(unsigned ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = MacroIDBit | ID;\n    return L;\n  }\n\npublic:\n  /// Return a source location with the specified offset from this\n  /// SourceLocation.\n  SourceLocation getLocWithOffset(int Offset) const {\n    assert(((getOffset()+Offset) & MacroIDBit) == 0 && \"offset overflow\");\n    SourceLocation L;\n    L.ID = ID+Offset;\n    return L;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) 32-bit integer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromRawEncoding, it\n  /// should not be inspected directly.\n  unsigned getRawEncoding() const { return ID; }\n\n  /// Turn a raw encoding of a SourceLocation object into\n  /// a real SourceLocation.\n  ///\n  /// \\see getRawEncoding.\n  static SourceLocation getFromRawEncoding(unsigned Encoding) {\n    SourceLocation X;\n    X.ID = Encoding;\n    return X;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) pointer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromPtrEncoding, it\n  /// should not be inspected directly.\n  void* getPtrEncoding() const {\n    // Double cast to avoid a warning \"cast to pointer from integer of different\n    // size\".\n    return (void*)(uintptr_t)getRawEncoding();\n  }\n\n  /// Turn a pointer encoding of a SourceLocation object back\n  /// into a real SourceLocation.\n  static SourceLocation getFromPtrEncoding(const void *Encoding) {\n    return getFromRawEncoding((unsigned)(uintptr_t)Encoding);\n  }\n\n  static bool isPairOfFileLocations(SourceLocation Start, SourceLocation End) {\n    return Start.isValid() && Start.isFileID() && End.isValid() &&\n           End.isFileID();\n  }\n\n  unsigned getHashValue() const;\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n};\n\ninline bool operator==(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() == RHS.getRawEncoding();\n}\n\ninline bool operator!=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return !(LHS == RHS);\n}\n\n// Ordering is meaningful only if LHS and RHS have the same FileID!\n// Otherwise use SourceManager::isBeforeInTranslationUnit().\ninline bool operator<(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() < RHS.getRawEncoding();\n}\ninline bool operator>(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() > RHS.getRawEncoding();\n}\ninline bool operator<=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() <= RHS.getRawEncoding();\n}\ninline bool operator>=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() >= RHS.getRawEncoding();\n}\n\n/// A trivial tuple used to represent a source range.\nclass SourceRange {\n  SourceLocation B;\n  SourceLocation E;\n\npublic:\n  SourceRange() = default;\n  SourceRange(SourceLocation loc) : B(loc), E(loc) {}\n  SourceRange(SourceLocation begin, SourceLocation end) : B(begin), E(end) {}\n\n  SourceLocation getBegin() const { return B; }\n  SourceLocation getEnd() const { return E; }\n\n  void setBegin(SourceLocation b) { B = b; }\n  void setEnd(SourceLocation e) { E = e; }\n\n  bool isValid() const { return B.isValid() && E.isValid(); }\n  bool isInvalid() const { return !isValid(); }\n\n  bool operator==(const SourceRange &X) const {\n    return B == X.B && E == X.E;\n  }\n\n  bool operator!=(const SourceRange &X) const {\n    return B != X.B || E != X.E;\n  }\n\n  // Returns true iff other is wholly contained within this range.\n  bool fullyContains(const SourceRange &other) const {\n    return B <= other.B && E >= other.E;\n  }\n\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n};\n\n/// Represents a character-granular source range.\n///\n/// The underlying SourceRange can either specify the starting/ending character\n/// of the range, or it can specify the start of the range and the start of the\n/// last token of the range (a \"token range\").  In the token range case, the\n/// size of the last token must be measured to determine the actual end of the\n/// range.\nclass CharSourceRange {\n  SourceRange Range;\n  bool IsTokenRange = false;\n\npublic:\n  CharSourceRange() = default;\n  CharSourceRange(SourceRange R, bool ITR) : Range(R), IsTokenRange(ITR) {}\n\n  static CharSourceRange getTokenRange(SourceRange R) {\n    return CharSourceRange(R, true);\n  }\n\n  static CharSourceRange getCharRange(SourceRange R) {\n    return CharSourceRange(R, false);\n  }\n\n  static CharSourceRange getTokenRange(SourceLocation B, SourceLocation E) {\n    return getTokenRange(SourceRange(B, E));\n  }\n\n  static CharSourceRange getCharRange(SourceLocation B, SourceLocation E) {\n    return getCharRange(SourceRange(B, E));\n  }\n\n  /// Return true if the end of this range specifies the start of\n  /// the last token.  Return false if the end of this range specifies the last\n  /// character in the range.\n  bool isTokenRange() const { return IsTokenRange; }\n  bool isCharRange() const { return !IsTokenRange; }\n\n  SourceLocation getBegin() const { return Range.getBegin(); }\n  SourceLocation getEnd() const { return Range.getEnd(); }\n  SourceRange getAsRange() const { return Range; }\n\n  void setBegin(SourceLocation b) { Range.setBegin(b); }\n  void setEnd(SourceLocation e) { Range.setEnd(e); }\n  void setTokenRange(bool TR) { IsTokenRange = TR; }\n\n  bool isValid() const { return Range.isValid(); }\n  bool isInvalid() const { return !isValid(); }\n};\n\n/// Represents an unpacked \"presumed\" location which can be presented\n/// to the user.\n///\n/// A 'presumed' location can be modified by \\#line and GNU line marker\n/// directives and is always the expansion point of a normal location.\n///\n/// You can get a PresumedLoc from a SourceLocation with SourceManager.\nclass PresumedLoc {\n  const char *Filename = nullptr;\n  FileID ID;\n  unsigned Line, Col;\n  SourceLocation IncludeLoc;\n\npublic:\n  PresumedLoc() = default;\n  PresumedLoc(const char *FN, FileID FID, unsigned Ln, unsigned Co,\n              SourceLocation IL)\n      : Filename(FN), ID(FID), Line(Ln), Col(Co), IncludeLoc(IL) {}\n\n  /// Return true if this object is invalid or uninitialized.\n  ///\n  /// This occurs when created with invalid source locations or when walking\n  /// off the top of a \\#include stack.\n  bool isInvalid() const { return Filename == nullptr; }\n  bool isValid() const { return Filename != nullptr; }\n\n  /// Return the presumed filename of this location.\n  ///\n  /// This can be affected by \\#line etc.\n  const char *getFilename() const {\n    assert(isValid());\n    return Filename;\n  }\n\n  FileID getFileID() const {\n    assert(isValid());\n    return ID;\n  }\n\n  /// Return the presumed line number of this location.\n  ///\n  /// This can be affected by \\#line etc.\n  unsigned getLine() const {\n    assert(isValid());\n    return Line;\n  }\n\n  /// Return the presumed column number of this location.\n  ///\n  /// This cannot be affected by \\#line, but is packaged here for convenience.\n  unsigned getColumn() const {\n    assert(isValid());\n    return Col;\n  }\n\n  /// Return the presumed include location of this location.\n  ///\n  /// This can be affected by GNU linemarker directives.\n  SourceLocation getIncludeLoc() const {\n    assert(isValid());\n    return IncludeLoc;\n  }\n};\n\nclass FileEntry;\n\n/// A SourceLocation and its associated SourceManager.\n///\n/// This is useful for argument passing to functions that expect both objects.\nclass FullSourceLoc : public SourceLocation {\n  const SourceManager *SrcMgr = nullptr;\n\npublic:\n  /// Creates a FullSourceLoc where isValid() returns \\c false.\n  FullSourceLoc() = default;\n\n  explicit FullSourceLoc(SourceLocation Loc, const SourceManager &SM)\n      : SourceLocation(Loc), SrcMgr(&SM) {}\n\n  bool hasManager() const {\n      bool hasSrcMgr =  SrcMgr != nullptr;\n      assert(hasSrcMgr == isValid() && \"FullSourceLoc has location but no manager\");\n      return hasSrcMgr;\n  }\n\n  /// \\pre This FullSourceLoc has an associated SourceManager.\n  const SourceManager &getManager() const {\n    assert(SrcMgr && \"SourceManager is NULL.\");\n    return *SrcMgr;\n  }\n\n  FileID getFileID() const;\n\n  FullSourceLoc getExpansionLoc() const;\n  FullSourceLoc getSpellingLoc() const;\n  FullSourceLoc getFileLoc() const;\n  PresumedLoc getPresumedLoc(bool UseLineDirectives = true) const;\n  bool isMacroArgExpansion(FullSourceLoc *StartLoc = nullptr) const;\n  FullSourceLoc getImmediateMacroCallerLoc() const;\n  std::pair<FullSourceLoc, StringRef> getModuleImportLoc() const;\n  unsigned getFileOffset() const;\n\n  unsigned getExpansionLineNumber(bool *Invalid = nullptr) const;\n  unsigned getExpansionColumnNumber(bool *Invalid = nullptr) const;\n\n  unsigned getSpellingLineNumber(bool *Invalid = nullptr) const;\n  unsigned getSpellingColumnNumber(bool *Invalid = nullptr) const;\n\n  const char *getCharacterData(bool *Invalid = nullptr) const;\n\n  unsigned getLineNumber(bool *Invalid = nullptr) const;\n  unsigned getColumnNumber(bool *Invalid = nullptr) const;\n\n  const FileEntry *getFileEntry() const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID.\n  StringRef getBufferData(bool *Invalid = nullptr) const;\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// The first element is the FileID, the second is the offset from the\n  /// start of the buffer of the location.\n  std::pair<FileID, unsigned> getDecomposedLoc() const;\n\n  bool isInSystemHeader() const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if this source location comes before 'Loc', false otherwise.\n  bool isBeforeInTranslationUnitThan(SourceLocation Loc) const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if this source location comes before 'Loc', false otherwise.\n  bool isBeforeInTranslationUnitThan(FullSourceLoc Loc) const {\n    assert(Loc.isValid());\n    assert(SrcMgr == Loc.SrcMgr && \"Loc comes from another SourceManager!\");\n    return isBeforeInTranslationUnitThan((SourceLocation)Loc);\n  }\n\n  /// Comparison function class, useful for sorting FullSourceLocs.\n  struct BeforeThanCompare {\n    bool operator()(const FullSourceLoc& lhs, const FullSourceLoc& rhs) const {\n      return lhs.isBeforeInTranslationUnitThan(rhs);\n    }\n  };\n\n  /// Prints information about this FullSourceLoc to stderr.\n  ///\n  /// This is useful for debugging.\n  void dump() const;\n\n  friend bool\n  operator==(const FullSourceLoc &LHS, const FullSourceLoc &RHS) {\n    return LHS.getRawEncoding() == RHS.getRawEncoding() &&\n          LHS.SrcMgr == RHS.SrcMgr;\n  }\n\n  friend bool\n  operator!=(const FullSourceLoc &LHS, const FullSourceLoc &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n  /// Define DenseMapInfo so that FileID's can be used as keys in DenseMap and\n  /// DenseSets.\n  template <>\n  struct DenseMapInfo<clang::FileID> {\n    static clang::FileID getEmptyKey() {\n      return {};\n    }\n\n    static clang::FileID getTombstoneKey() {\n      return clang::FileID::getSentinel();\n    }\n\n    static unsigned getHashValue(clang::FileID S) {\n      return S.getHashValue();\n    }\n\n    static bool isEqual(clang::FileID LHS, clang::FileID RHS) {\n      return LHS == RHS;\n    }\n  };\n\n  /// Define DenseMapInfo so that SourceLocation's can be used as keys in\n  /// DenseMap and DenseSet. This trait class is eqivalent to\n  /// DenseMapInfo<unsigned> which uses SourceLocation::ID is used as a key.\n  template <> struct DenseMapInfo<clang::SourceLocation> {\n    static clang::SourceLocation getEmptyKey() {\n      return clang::SourceLocation::getFromRawEncoding(~0U);\n    }\n\n    static clang::SourceLocation getTombstoneKey() {\n      return clang::SourceLocation::getFromRawEncoding(~0U - 1);\n    }\n\n    static unsigned getHashValue(clang::SourceLocation Loc) {\n      return Loc.getHashValue();\n    }\n\n    static bool isEqual(clang::SourceLocation LHS, clang::SourceLocation RHS) {\n      return LHS == RHS;\n    }\n  };\n\n  // Allow calling FoldingSetNodeID::Add with SourceLocation object as parameter\n  template <> struct FoldingSetTrait<clang::SourceLocation> {\n    static void Profile(const clang::SourceLocation &X, FoldingSetNodeID &ID);\n  };\n\n  // Teach SmallPtrSet how to handle SourceLocation.\n  template<>\n  struct PointerLikeTypeTraits<clang::SourceLocation> {\n    static constexpr int NumLowBitsAvailable = 0;\n\n    static void *getAsVoidPointer(clang::SourceLocation L) {\n      return L.getPtrEncoding();\n    }\n\n    static clang::SourceLocation getFromVoidPointer(void *P) {\n      return clang::SourceLocation::getFromRawEncoding((unsigned)(uintptr_t)P);\n    }\n  };\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_BASIC_SOURCELOCATION_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "content": "//===- SourceManager.h - Track and cache source files -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the SourceManager interface.\n///\n/// There are three different types of locations in a %file: a spelling\n/// location, an expansion location, and a presumed location.\n///\n/// Given an example of:\n/// \\code\n/// #define min(x, y) x < y ? x : y\n/// \\endcode\n///\n/// and then later on a use of min:\n/// \\code\n/// #line 17\n/// return min(a, b);\n/// \\endcode\n///\n/// The expansion location is the line in the source code where the macro\n/// was expanded (the return statement), the spelling location is the\n/// location in the source where the macro was originally defined,\n/// and the presumed location is where the line directive states that\n/// the line is 17, or any other line.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SOURCEMANAGER_H\n#define LLVM_CLANG_BASIC_SOURCEMANAGER_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileEntry.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstddef>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTReader;\nclass ASTWriter;\nclass FileManager;\nclass LineTableInfo;\nclass SourceManager;\n\n/// Public enums and private classes that are part of the\n/// SourceManager implementation.\nnamespace SrcMgr {\n\n/// Indicates whether a file or directory holds normal user code,\n/// system code, or system code which is implicitly 'extern \"C\"' in C++ mode.\n///\n/// Entire directories can be tagged with this (this is maintained by\n/// DirectoryLookup and friends) as can specific FileInfos when a \\#pragma\n/// system_header is seen or in various other cases.\n///\nenum CharacteristicKind {\n  C_User,\n  C_System,\n  C_ExternCSystem,\n  C_User_ModuleMap,\n  C_System_ModuleMap\n};\n\n/// Determine whether a file / directory characteristic is for system code.\ninline bool isSystem(CharacteristicKind CK) {\n  return CK != C_User && CK != C_User_ModuleMap;\n}\n\n/// Determine whether a file characteristic is for a module map.\ninline bool isModuleMap(CharacteristicKind CK) {\n  return CK == C_User_ModuleMap || CK == C_System_ModuleMap;\n}\n\n/// Mapping of line offsets into a source file. This does not own the storage\n/// for the line numbers.\nclass LineOffsetMapping {\npublic:\n  explicit operator bool() const { return Storage; }\n  unsigned size() const {\n    assert(Storage);\n    return Storage[0];\n  }\n  ArrayRef<unsigned> getLines() const {\n    assert(Storage);\n    return ArrayRef<unsigned>(Storage + 1, Storage + 1 + size());\n  }\n  const unsigned *begin() const { return getLines().begin(); }\n  const unsigned *end() const { return getLines().end(); }\n  const unsigned &operator[](int I) const { return getLines()[I]; }\n\n  static LineOffsetMapping get(llvm::MemoryBufferRef Buffer,\n                               llvm::BumpPtrAllocator &Alloc);\n\n  LineOffsetMapping() = default;\n  LineOffsetMapping(ArrayRef<unsigned> LineOffsets,\n                    llvm::BumpPtrAllocator &Alloc);\n\nprivate:\n  /// First element is the size, followed by elements at off-by-one indexes.\n  unsigned *Storage = nullptr;\n};\n\n/// One instance of this struct is kept for every file loaded or used.\n///\n/// This object owns the MemoryBuffer object.\nclass alignas(8) ContentCache {\n  /// The actual buffer containing the characters from the input\n  /// file.\n  mutable std::unique_ptr<llvm::MemoryBuffer> Buffer;\n\npublic:\n  /// Reference to the file entry representing this ContentCache.\n  ///\n  /// This reference does not own the FileEntry object.\n  ///\n  /// It is possible for this to be NULL if the ContentCache encapsulates\n  /// an imaginary text buffer.\n  ///\n  /// FIXME: Turn this into a FileEntryRef and remove Filename.\n  const FileEntry *OrigEntry;\n\n  /// References the file which the contents were actually loaded from.\n  ///\n  /// Can be different from 'Entry' if we overridden the contents of one file\n  /// with the contents of another file.\n  const FileEntry *ContentsEntry;\n\n  /// The filename that is used to access OrigEntry.\n  ///\n  /// FIXME: Remove this once OrigEntry is a FileEntryRef with a stable name.\n  StringRef Filename;\n\n  /// A bump pointer allocated array of offsets for each source line.\n  ///\n  /// This is lazily computed.  The lines are owned by the SourceManager\n  /// BumpPointerAllocator object.\n  mutable LineOffsetMapping SourceLineCache;\n\n  /// Indicates whether the buffer itself was provided to override\n  /// the actual file contents.\n  ///\n  /// When true, the original entry may be a virtual file that does not\n  /// exist.\n  unsigned BufferOverridden : 1;\n\n  /// True if this content cache was initially created for a source file\n  /// considered to be volatile (likely to change between stat and open).\n  unsigned IsFileVolatile : 1;\n\n  /// True if this file may be transient, that is, if it might not\n  /// exist at some later point in time when this content entry is used,\n  /// after serialization and deserialization.\n  unsigned IsTransient : 1;\n\n  mutable unsigned IsBufferInvalid : 1;\n\n  ContentCache(const FileEntry *Ent = nullptr) : ContentCache(Ent, Ent) {}\n\n  ContentCache(const FileEntry *Ent, const FileEntry *contentEnt)\n      : OrigEntry(Ent), ContentsEntry(contentEnt), BufferOverridden(false),\n        IsFileVolatile(false), IsTransient(false), IsBufferInvalid(false) {}\n\n  /// The copy ctor does not allow copies where source object has either\n  /// a non-NULL Buffer or SourceLineCache.  Ownership of allocated memory\n  /// is not transferred, so this is a logical error.\n  ContentCache(const ContentCache &RHS)\n      : BufferOverridden(false), IsFileVolatile(false), IsTransient(false),\n        IsBufferInvalid(false) {\n    OrigEntry = RHS.OrigEntry;\n    ContentsEntry = RHS.ContentsEntry;\n\n    assert(!RHS.Buffer && !RHS.SourceLineCache &&\n           \"Passed ContentCache object cannot own a buffer.\");\n  }\n\n  ContentCache &operator=(const ContentCache &RHS) = delete;\n\n  /// Returns the memory buffer for the associated content.\n  ///\n  /// \\param Diag Object through which diagnostics will be emitted if the\n  ///   buffer cannot be retrieved.\n  ///\n  /// \\param Loc If specified, is the location that invalid file diagnostics\n  ///   will be emitted at.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getBufferOrNone(DiagnosticsEngine &Diag, FileManager &FM,\n                  SourceLocation Loc = SourceLocation()) const;\n\n  /// Returns the size of the content encapsulated by this\n  /// ContentCache.\n  ///\n  /// This can be the size of the source file or the size of an\n  /// arbitrary scratch buffer.  If the ContentCache encapsulates a source\n  /// file this size is retrieved from the file's FileEntry.\n  unsigned getSize() const;\n\n  /// Returns the number of bytes actually mapped for this\n  /// ContentCache.\n  ///\n  /// This can be 0 if the MemBuffer was not actually expanded.\n  unsigned getSizeBytesMapped() const;\n\n  /// Returns the kind of memory used to back the memory buffer for\n  /// this content cache.  This is used for performance analysis.\n  llvm::MemoryBuffer::BufferKind getMemoryBufferKind() const;\n\n  /// Return the buffer, only if it has been loaded.\n  llvm::Optional<llvm::MemoryBufferRef> getBufferIfLoaded() const {\n    if (Buffer)\n      return Buffer->getMemBufferRef();\n    return None;\n  }\n\n  /// Return a StringRef to the source buffer data, only if it has already\n  /// been loaded.\n  llvm::Optional<StringRef> getBufferDataIfLoaded() const {\n    if (Buffer)\n      return Buffer->getBuffer();\n    return None;\n  }\n\n  /// Set the buffer.\n  void setBuffer(std::unique_ptr<llvm::MemoryBuffer> B) {\n    IsBufferInvalid = false;\n    Buffer = std::move(B);\n  }\n\n  /// Set the buffer to one that's not owned (or to nullptr).\n  ///\n  /// \\pre Buffer cannot already be set.\n  void setUnownedBuffer(llvm::Optional<llvm::MemoryBufferRef> B) {\n    assert(!Buffer && \"Expected to be called right after construction\");\n    if (B)\n      setBuffer(llvm::MemoryBuffer::getMemBuffer(*B));\n  }\n\n  // If BufStr has an invalid BOM, returns the BOM name; otherwise, returns\n  // nullptr\n  static const char *getInvalidBOM(StringRef BufStr);\n};\n\n// Assert that the \\c ContentCache objects will always be 8-byte aligned so\n// that we can pack 3 bits of integer into pointers to such objects.\nstatic_assert(alignof(ContentCache) >= 8,\n              \"ContentCache must be 8-byte aligned.\");\n\n/// Information about a FileID, basically just the logical file\n/// that it represents and include stack information.\n///\n/// Each FileInfo has include stack information, indicating where it came\n/// from. This information encodes the \\#include chain that a token was\n/// expanded from. The main include file has an invalid IncludeLoc.\n///\n/// FileInfo should not grow larger than ExpansionInfo. Doing so will\n/// cause memory to bloat in compilations with many unloaded macro\n/// expansions, since the two data structurs are stored in a union in\n/// SLocEntry. Extra fields should instead go in \"ContentCache *\", which\n/// stores file contents and other bits on the side.\n///\nclass FileInfo {\n  friend class clang::SourceManager;\n  friend class clang::ASTWriter;\n  friend class clang::ASTReader;\n\n  /// The location of the \\#include that brought in this file.\n  ///\n  /// This is an invalid SLOC for the main file (top of the \\#include chain).\n  SourceLocation IncludeLoc;\n\n  /// Number of FileIDs (files and macros) that were created during\n  /// preprocessing of this \\#include, including this SLocEntry.\n  ///\n  /// Zero means the preprocessor didn't provide such info for this SLocEntry.\n  unsigned NumCreatedFIDs : 31;\n\n  /// Whether this FileInfo has any \\#line directives.\n  unsigned HasLineDirectives : 1;\n\n  /// The content cache and the characteristic of the file.\n  llvm::PointerIntPair<const ContentCache *, 3, CharacteristicKind>\n      ContentAndKind;\n\npublic:\n  /// Return a FileInfo object.\n  static FileInfo get(SourceLocation IL, ContentCache &Con,\n                      CharacteristicKind FileCharacter, StringRef Filename) {\n    FileInfo X;\n    X.IncludeLoc = IL;\n    X.NumCreatedFIDs = 0;\n    X.HasLineDirectives = false;\n    X.ContentAndKind.setPointer(&Con);\n    X.ContentAndKind.setInt(FileCharacter);\n    Con.Filename = Filename;\n    return X;\n  }\n\n  SourceLocation getIncludeLoc() const {\n    return IncludeLoc;\n  }\n\n  const ContentCache &getContentCache() const {\n    return *ContentAndKind.getPointer();\n  }\n\n  /// Return whether this is a system header or not.\n  CharacteristicKind getFileCharacteristic() const {\n    return ContentAndKind.getInt();\n  }\n\n  /// Return true if this FileID has \\#line directives in it.\n  bool hasLineDirectives() const { return HasLineDirectives; }\n\n  /// Set the flag that indicates that this FileID has\n  /// line table entries associated with it.\n  void setHasLineDirectives() { HasLineDirectives = true; }\n\n  /// Returns the name of the file that was used when the file was loaded from\n  /// the underlying file system.\n  StringRef getName() const { return getContentCache().Filename; }\n};\n\n/// Each ExpansionInfo encodes the expansion location - where\n/// the token was ultimately expanded, and the SpellingLoc - where the actual\n/// character data for the token came from.\nclass ExpansionInfo {\n  // Really these are all SourceLocations.\n\n  /// Where the spelling for the token can be found.\n  SourceLocation SpellingLoc;\n\n  /// In a macro expansion, ExpansionLocStart and ExpansionLocEnd\n  /// indicate the start and end of the expansion. In object-like macros,\n  /// they will be the same. In a function-like macro expansion, the start\n  /// will be the identifier and the end will be the ')'. Finally, in\n  /// macro-argument instantiations, the end will be 'SourceLocation()', an\n  /// invalid location.\n  SourceLocation ExpansionLocStart, ExpansionLocEnd;\n\n  /// Whether the expansion range is a token range.\n  bool ExpansionIsTokenRange;\n\npublic:\n  SourceLocation getSpellingLoc() const {\n    return SpellingLoc.isInvalid() ? getExpansionLocStart() : SpellingLoc;\n  }\n\n  SourceLocation getExpansionLocStart() const {\n    return ExpansionLocStart;\n  }\n\n  SourceLocation getExpansionLocEnd() const {\n    return ExpansionLocEnd.isInvalid() ? getExpansionLocStart()\n                                       : ExpansionLocEnd;\n  }\n\n  bool isExpansionTokenRange() const { return ExpansionIsTokenRange; }\n\n  CharSourceRange getExpansionLocRange() const {\n    return CharSourceRange(\n        SourceRange(getExpansionLocStart(), getExpansionLocEnd()),\n        isExpansionTokenRange());\n  }\n\n  bool isMacroArgExpansion() const {\n    // Note that this needs to return false for default constructed objects.\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isInvalid();\n  }\n\n  bool isMacroBodyExpansion() const {\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isValid();\n  }\n\n  bool isFunctionMacroExpansion() const {\n    return getExpansionLocStart().isValid() &&\n           getExpansionLocStart() != getExpansionLocEnd();\n  }\n\n  /// Return a ExpansionInfo for an expansion.\n  ///\n  /// Start and End specify the expansion range (where the macro is\n  /// expanded), and SpellingLoc specifies the spelling location (where\n  /// the characters from the token come from). All three can refer to\n  /// normal File SLocs or expansion locations.\n  static ExpansionInfo create(SourceLocation SpellingLoc, SourceLocation Start,\n                              SourceLocation End,\n                              bool ExpansionIsTokenRange = true) {\n    ExpansionInfo X;\n    X.SpellingLoc = SpellingLoc;\n    X.ExpansionLocStart = Start;\n    X.ExpansionLocEnd = End;\n    X.ExpansionIsTokenRange = ExpansionIsTokenRange;\n    return X;\n  }\n\n  /// Return a special ExpansionInfo for the expansion of\n  /// a macro argument into a function-like macro's body.\n  ///\n  /// ExpansionLoc specifies the expansion location (where the macro is\n  /// expanded). This doesn't need to be a range because a macro is always\n  /// expanded at a macro parameter reference, and macro parameters are\n  /// always exactly one token. SpellingLoc specifies the spelling location\n  /// (where the characters from the token come from). ExpansionLoc and\n  /// SpellingLoc can both refer to normal File SLocs or expansion locations.\n  ///\n  /// Given the code:\n  /// \\code\n  ///   #define F(x) f(x)\n  ///   F(42);\n  /// \\endcode\n  ///\n  /// When expanding '\\c F(42)', the '\\c x' would call this with an\n  /// SpellingLoc pointing at '\\c 42' and an ExpansionLoc pointing at its\n  /// location in the definition of '\\c F'.\n  static ExpansionInfo createForMacroArg(SourceLocation SpellingLoc,\n                                         SourceLocation ExpansionLoc) {\n    // We store an intentionally invalid source location for the end of the\n    // expansion range to mark that this is a macro argument location rather\n    // than a normal one.\n    return create(SpellingLoc, ExpansionLoc, SourceLocation());\n  }\n\n  /// Return a special ExpansionInfo representing a token that ends\n  /// prematurely. This is used to model a '>>' token that has been split\n  /// into '>' tokens and similar cases. Unlike for the other forms of\n  /// expansion, the expansion range in this case is a character range, not\n  /// a token range.\n  static ExpansionInfo createForTokenSplit(SourceLocation SpellingLoc,\n                                           SourceLocation Start,\n                                           SourceLocation End) {\n    return create(SpellingLoc, Start, End, false);\n  }\n};\n\n// Assert that the \\c FileInfo objects are no bigger than \\c ExpansionInfo\n// objects. This controls the size of \\c SLocEntry, of which we have one for\n// each macro expansion. The number of (unloaded) macro expansions can be\n// very large. Any other fields needed in FileInfo should go in ContentCache.\nstatic_assert(sizeof(FileInfo) <= sizeof(ExpansionInfo),\n              \"FileInfo must be no larger than ExpansionInfo.\");\n\n/// This is a discriminated union of FileInfo and ExpansionInfo.\n///\n/// SourceManager keeps an array of these objects, and they are uniquely\n/// identified by the FileID datatype.\nclass SLocEntry {\n  unsigned Offset : 31;\n  unsigned IsExpansion : 1;\n  union {\n    FileInfo File;\n    ExpansionInfo Expansion;\n  };\n\npublic:\n  SLocEntry() : Offset(), IsExpansion(), File() {}\n\n  unsigned getOffset() const { return Offset; }\n\n  bool isExpansion() const { return IsExpansion; }\n  bool isFile() const { return !isExpansion(); }\n\n  const FileInfo &getFile() const {\n    assert(isFile() && \"Not a file SLocEntry!\");\n    return File;\n  }\n\n  const ExpansionInfo &getExpansion() const {\n    assert(isExpansion() && \"Not a macro expansion SLocEntry!\");\n    return Expansion;\n  }\n\n  static SLocEntry get(unsigned Offset, const FileInfo &FI) {\n    assert(!(Offset & (1u << 31)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = false;\n    E.File = FI;\n    return E;\n  }\n\n  static SLocEntry get(unsigned Offset, const ExpansionInfo &Expansion) {\n    assert(!(Offset & (1u << 31)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = true;\n    new (&E.Expansion) ExpansionInfo(Expansion);\n    return E;\n  }\n};\n\n} // namespace SrcMgr\n\n/// External source of source location entries.\nclass ExternalSLocEntrySource {\npublic:\n  virtual ~ExternalSLocEntrySource();\n\n  /// Read the source location entry with index ID, which will always be\n  /// less than -1.\n  ///\n  /// \\returns true if an error occurred that prevented the source-location\n  /// entry from being loaded.\n  virtual bool ReadSLocEntry(int ID) = 0;\n\n  /// Retrieve the module import location and name for the given ID, if\n  /// in fact it was loaded from a module (rather than, say, a precompiled\n  /// header).\n  virtual std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) = 0;\n};\n\n/// Holds the cache used by isBeforeInTranslationUnit.\n///\n/// The cache structure is complex enough to be worth breaking out of\n/// SourceManager.\nclass InBeforeInTUCacheEntry {\n  /// The FileID's of the cached query.\n  ///\n  /// If these match up with a subsequent query, the result can be reused.\n  FileID LQueryFID, RQueryFID;\n\n  /// True if LQueryFID was created before RQueryFID.\n  ///\n  /// This is used to compare macro expansion locations.\n  bool IsLQFIDBeforeRQFID;\n\n  /// The file found in common between the two \\#include traces, i.e.,\n  /// the nearest common ancestor of the \\#include tree.\n  FileID CommonFID;\n\n  /// The offset of the previous query in CommonFID.\n  ///\n  /// Usually, this represents the location of the \\#include for QueryFID, but\n  /// if LQueryFID is a parent of RQueryFID (or vice versa) then these can be a\n  /// random token in the parent.\n  unsigned LCommonOffset, RCommonOffset;\n\npublic:\n  /// Return true if the currently cached values match up with\n  /// the specified LHS/RHS query.\n  ///\n  /// If not, we can't use the cache.\n  bool isCacheValid(FileID LHS, FileID RHS) const {\n    return LQueryFID == LHS && RQueryFID == RHS;\n  }\n\n  /// If the cache is valid, compute the result given the\n  /// specified offsets in the LHS/RHS FileID's.\n  bool getCachedResult(unsigned LOffset, unsigned ROffset) const {\n    // If one of the query files is the common file, use the offset.  Otherwise,\n    // use the #include loc in the common file.\n    if (LQueryFID != CommonFID) LOffset = LCommonOffset;\n    if (RQueryFID != CommonFID) ROffset = RCommonOffset;\n\n    // It is common for multiple macro expansions to be \"included\" from the same\n    // location (expansion location), in which case use the order of the FileIDs\n    // to determine which came first. This will also take care the case where\n    // one of the locations points at the inclusion/expansion point of the other\n    // in which case its FileID will come before the other.\n    if (LOffset == ROffset)\n      return IsLQFIDBeforeRQFID;\n\n    return LOffset < ROffset;\n  }\n\n  /// Set up a new query.\n  void setQueryFIDs(FileID LHS, FileID RHS, bool isLFIDBeforeRFID) {\n    assert(LHS != RHS);\n    LQueryFID = LHS;\n    RQueryFID = RHS;\n    IsLQFIDBeforeRQFID = isLFIDBeforeRFID;\n  }\n\n  void clear() {\n    LQueryFID = RQueryFID = FileID();\n    IsLQFIDBeforeRQFID = false;\n  }\n\n  void setCommonLoc(FileID commonFID, unsigned lCommonOffset,\n                    unsigned rCommonOffset) {\n    CommonFID = commonFID;\n    LCommonOffset = lCommonOffset;\n    RCommonOffset = rCommonOffset;\n  }\n};\n\n/// The stack used when building modules on demand, which is used\n/// to provide a link between the source managers of the different compiler\n/// instances.\nusing ModuleBuildStack = ArrayRef<std::pair<std::string, FullSourceLoc>>;\n\n/// This class handles loading and caching of source files into memory.\n///\n/// This object owns the MemoryBuffer objects for all of the loaded\n/// files and assigns unique FileID's for each unique \\#include chain.\n///\n/// The SourceManager can be queried for information about SourceLocation\n/// objects, turning them into either spelling or expansion locations. Spelling\n/// locations represent where the bytes corresponding to a token came from and\n/// expansion locations represent where the location is in the user's view. In\n/// the case of a macro expansion, for example, the spelling location indicates\n/// where the expanded token came from and the expansion location specifies\n/// where it was expanded.\nclass SourceManager : public RefCountedBase<SourceManager> {\n  /// DiagnosticsEngine object.\n  DiagnosticsEngine &Diag;\n\n  FileManager &FileMgr;\n\n  mutable llvm::BumpPtrAllocator ContentCacheAlloc;\n\n  /// Memoized information about all of the files tracked by this\n  /// SourceManager.\n  ///\n  /// This map allows us to merge ContentCache entries based\n  /// on their FileEntry*.  All ContentCache objects will thus have unique,\n  /// non-null, FileEntry pointers.\n  llvm::DenseMap<const FileEntry*, SrcMgr::ContentCache*> FileInfos;\n\n  /// True if the ContentCache for files that are overridden by other\n  /// files, should report the original file name. Defaults to true.\n  bool OverridenFilesKeepOriginalName = true;\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them). Defaults to false.\n  bool UserFilesAreVolatile;\n\n  /// True if all files read during this compilation should be treated\n  /// as transient (may not be present in later compilations using a module\n  /// file created from this compilation). Defaults to false.\n  bool FilesAreTransient = false;\n\n  struct OverriddenFilesInfoTy {\n    /// Files that have been overridden with the contents from another\n    /// file.\n    llvm::DenseMap<const FileEntry *, const FileEntry *> OverriddenFiles;\n\n    /// Files that were overridden with a memory buffer.\n    llvm::DenseSet<const FileEntry *> OverriddenFilesWithBuffer;\n  };\n\n  /// Lazily create the object keeping overridden files info, since\n  /// it is uncommonly used.\n  std::unique_ptr<OverriddenFilesInfoTy> OverriddenFilesInfo;\n\n  OverriddenFilesInfoTy &getOverriddenFilesInfo() {\n    if (!OverriddenFilesInfo)\n      OverriddenFilesInfo.reset(new OverriddenFilesInfoTy);\n    return *OverriddenFilesInfo;\n  }\n\n  /// Information about various memory buffers that we have read in.\n  ///\n  /// All FileEntry* within the stored ContentCache objects are NULL,\n  /// as they do not refer to a file.\n  std::vector<SrcMgr::ContentCache*> MemBufferInfos;\n\n  /// The table of SLocEntries that are local to this module.\n  ///\n  /// Positive FileIDs are indexes into this table. Entry 0 indicates an invalid\n  /// expansion.\n  SmallVector<SrcMgr::SLocEntry, 0> LocalSLocEntryTable;\n\n  /// The table of SLocEntries that are loaded from other modules.\n  ///\n  /// Negative FileIDs are indexes into this table. To get from ID to an index,\n  /// use (-ID - 2).\n  SmallVector<SrcMgr::SLocEntry, 0> LoadedSLocEntryTable;\n\n  /// The starting offset of the next local SLocEntry.\n  ///\n  /// This is LocalSLocEntryTable.back().Offset + the size of that entry.\n  unsigned NextLocalOffset;\n\n  /// The starting offset of the latest batch of loaded SLocEntries.\n  ///\n  /// This is LoadedSLocEntryTable.back().Offset, except that that entry might\n  /// not have been loaded, so that value would be unknown.\n  unsigned CurrentLoadedOffset;\n\n  /// The highest possible offset is 2^31-1, so CurrentLoadedOffset\n  /// starts at 2^31.\n  static const unsigned MaxLoadedOffset = 1U << 31U;\n\n  /// A bitmap that indicates whether the entries of LoadedSLocEntryTable\n  /// have already been loaded from the external source.\n  ///\n  /// Same indexing as LoadedSLocEntryTable.\n  llvm::BitVector SLocEntryLoaded;\n\n  /// An external source for source location entries.\n  ExternalSLocEntrySource *ExternalSLocEntries = nullptr;\n\n  /// A one-entry cache to speed up getFileID.\n  ///\n  /// LastFileIDLookup records the last FileID looked up or created, because it\n  /// is very common to look up many tokens from the same file.\n  mutable FileID LastFileIDLookup;\n\n  /// Holds information for \\#line directives.\n  ///\n  /// This is referenced by indices from SLocEntryTable.\n  std::unique_ptr<LineTableInfo> LineTable;\n\n  /// These ivars serve as a cache used in the getLineNumber\n  /// method which is used to speedup getLineNumber calls to nearby locations.\n  mutable FileID LastLineNoFileIDQuery;\n  mutable const SrcMgr::ContentCache *LastLineNoContentCache;\n  mutable unsigned LastLineNoFilePos;\n  mutable unsigned LastLineNoResult;\n\n  /// The file ID for the main source file of the translation unit.\n  FileID MainFileID;\n\n  /// The file ID for the precompiled preamble there is one.\n  FileID PreambleFileID;\n\n  // Statistics for -print-stats.\n  mutable unsigned NumLinearScans = 0;\n  mutable unsigned NumBinaryProbes = 0;\n\n  /// Associates a FileID with its \"included/expanded in\" decomposed\n  /// location.\n  ///\n  /// Used to cache results from and speed-up \\c getDecomposedIncludedLoc\n  /// function.\n  mutable llvm::DenseMap<FileID, std::pair<FileID, unsigned>> IncludedLocMap;\n\n  /// The key value into the IsBeforeInTUCache table.\n  using IsBeforeInTUCacheKey = std::pair<FileID, FileID>;\n\n  /// The IsBeforeInTranslationUnitCache is a mapping from FileID pairs\n  /// to cache results.\n  using InBeforeInTUCache =\n      llvm::DenseMap<IsBeforeInTUCacheKey, InBeforeInTUCacheEntry>;\n\n  /// Cache results for the isBeforeInTranslationUnit method.\n  mutable InBeforeInTUCache IBTUCache;\n  mutable InBeforeInTUCacheEntry IBTUCacheOverflow;\n\n  /// Return the cache entry for comparing the given file IDs\n  /// for isBeforeInTranslationUnit.\n  InBeforeInTUCacheEntry &getInBeforeInTUCache(FileID LFID, FileID RFID) const;\n\n  // Cache for the \"fake\" buffer used for error-recovery purposes.\n  mutable std::unique_ptr<llvm::MemoryBuffer> FakeBufferForRecovery;\n\n  mutable std::unique_ptr<SrcMgr::ContentCache> FakeContentCacheForRecovery;\n\n  mutable std::unique_ptr<SrcMgr::SLocEntry> FakeSLocEntryForRecovery;\n\n  /// Lazily computed map of macro argument chunks to their expanded\n  /// source location.\n  using MacroArgsMap = std::map<unsigned, SourceLocation>;\n\n  mutable llvm::DenseMap<FileID, std::unique_ptr<MacroArgsMap>>\n      MacroArgsCacheMap;\n\n  /// The stack of modules being built, which is used to detect\n  /// cycles in the module dependency graph as modules are being built, as\n  /// well as to describe why we're rebuilding a particular module.\n  ///\n  /// There is no way to set this value from the command line. If we ever need\n  /// to do so (e.g., if on-demand module construction moves out-of-process),\n  /// we can add a cc1-level option to do so.\n  SmallVector<std::pair<std::string, FullSourceLoc>, 2> StoredModuleBuildStack;\n\npublic:\n  SourceManager(DiagnosticsEngine &Diag, FileManager &FileMgr,\n                bool UserFilesAreVolatile = false);\n  explicit SourceManager(const SourceManager &) = delete;\n  SourceManager &operator=(const SourceManager &) = delete;\n  ~SourceManager();\n\n  void clearIDTables();\n\n  /// Initialize this source manager suitably to replay the compilation\n  /// described by \\p Old. Requires that \\p Old outlive \\p *this.\n  void initializeForReplay(const SourceManager &Old);\n\n  DiagnosticsEngine &getDiagnostics() const { return Diag; }\n\n  FileManager &getFileManager() const { return FileMgr; }\n\n  /// Set true if the SourceManager should report the original file name\n  /// for contents of files that were overridden by other files. Defaults to\n  /// true.\n  void setOverridenFilesKeepOriginalName(bool value) {\n    OverridenFilesKeepOriginalName = value;\n  }\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them).\n  bool userFilesAreVolatile() const { return UserFilesAreVolatile; }\n\n  /// Retrieve the module build stack.\n  ModuleBuildStack getModuleBuildStack() const {\n    return StoredModuleBuildStack;\n  }\n\n  /// Set the module build stack.\n  void setModuleBuildStack(ModuleBuildStack stack) {\n    StoredModuleBuildStack.clear();\n    StoredModuleBuildStack.append(stack.begin(), stack.end());\n  }\n\n  /// Push an entry to the module build stack.\n  void pushModuleBuildStack(StringRef moduleName, FullSourceLoc importLoc) {\n    StoredModuleBuildStack.push_back(std::make_pair(moduleName.str(),importLoc));\n  }\n\n  //===--------------------------------------------------------------------===//\n  // MainFileID creation and querying methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the FileID of the main source file.\n  FileID getMainFileID() const { return MainFileID; }\n\n  /// Set the file ID for the main source file.\n  void setMainFileID(FileID FID) {\n    MainFileID = FID;\n  }\n\n  /// Returns true when the given FileEntry corresponds to the main file.\n  ///\n  /// The main file should be set prior to calling this function.\n  bool isMainFile(const FileEntry &SourceFile);\n\n  /// Set the file ID for the precompiled preamble.\n  void setPreambleFileID(FileID Preamble) {\n    assert(PreambleFileID.isInvalid() && \"PreambleFileID already set!\");\n    PreambleFileID = Preamble;\n  }\n\n  /// Get the file ID for the precompiled preamble if there is one.\n  FileID getPreambleFileID() const { return PreambleFileID; }\n\n  //===--------------------------------------------------------------------===//\n  // Methods to create new FileID's and macro expansions.\n  //===--------------------------------------------------------------------===//\n\n  /// Create a new FileID that represents the specified file\n  /// being \\#included from the specified IncludePosition.\n  ///\n  /// This translates NULL into standard input.\n  FileID createFileID(const FileEntry *SourceFile, SourceLocation IncludePos,\n                      SrcMgr::CharacteristicKind FileCharacter,\n                      int LoadedID = 0, unsigned LoadedOffset = 0);\n\n  FileID createFileID(FileEntryRef SourceFile, SourceLocation IncludePos,\n                      SrcMgr::CharacteristicKind FileCharacter,\n                      int LoadedID = 0, unsigned LoadedOffset = 0);\n\n  /// Create a new FileID that represents the specified memory buffer.\n  ///\n  /// This does no caching of the buffer and takes ownership of the\n  /// MemoryBuffer, so only pass a MemoryBuffer to this once.\n  FileID createFileID(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n                      SrcMgr::CharacteristicKind FileCharacter = SrcMgr::C_User,\n                      int LoadedID = 0, unsigned LoadedOffset = 0,\n                      SourceLocation IncludeLoc = SourceLocation());\n\n  /// Create a new FileID that represents the specified memory buffer.\n  ///\n  /// This does not take ownership of the MemoryBuffer. The memory buffer must\n  /// outlive the SourceManager.\n  FileID createFileID(const llvm::MemoryBufferRef &Buffer,\n                      SrcMgr::CharacteristicKind FileCharacter = SrcMgr::C_User,\n                      int LoadedID = 0, unsigned LoadedOffset = 0,\n                      SourceLocation IncludeLoc = SourceLocation());\n\n  /// Get the FileID for \\p SourceFile if it exists. Otherwise, create a\n  /// new FileID for the \\p SourceFile.\n  FileID getOrCreateFileID(const FileEntry *SourceFile,\n                           SrcMgr::CharacteristicKind FileCharacter);\n\n  /// Return a new SourceLocation that encodes the\n  /// fact that a token from SpellingLoc should actually be referenced from\n  /// ExpansionLoc, and that it represents the expansion of a macro argument\n  /// into the function-like macro body.\n  SourceLocation createMacroArgExpansionLoc(SourceLocation Loc,\n                                            SourceLocation ExpansionLoc,\n                                            unsigned TokLength);\n\n  /// Return a new SourceLocation that encodes the fact\n  /// that a token from SpellingLoc should actually be referenced from\n  /// ExpansionLoc.\n  SourceLocation createExpansionLoc(SourceLocation Loc,\n                                    SourceLocation ExpansionLocStart,\n                                    SourceLocation ExpansionLocEnd,\n                                    unsigned TokLength,\n                                    bool ExpansionIsTokenRange = true,\n                                    int LoadedID = 0,\n                                    unsigned LoadedOffset = 0);\n\n  /// Return a new SourceLocation that encodes that the token starting\n  /// at \\p TokenStart ends prematurely at \\p TokenEnd.\n  SourceLocation createTokenSplitLoc(SourceLocation SpellingLoc,\n                                     SourceLocation TokenStart,\n                                     SourceLocation TokenEnd);\n\n  /// Retrieve the memory buffer associated with the given file.\n  ///\n  /// Returns None if the buffer is not valid.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getMemoryBufferForFileOrNone(const FileEntry *File);\n\n  /// Retrieve the memory buffer associated with the given file.\n  ///\n  /// Returns a fake buffer if there isn't a real one.\n  llvm::MemoryBufferRef getMemoryBufferForFileOrFake(const FileEntry *File) {\n    if (auto B = getMemoryBufferForFileOrNone(File))\n      return *B;\n    return getFakeBufferForRecovery();\n  }\n\n  /// Override the contents of the given source file by providing an\n  /// already-allocated buffer.\n  ///\n  /// \\param SourceFile the source file whose contents will be overridden.\n  ///\n  /// \\param Buffer the memory buffer whose contents will be used as the\n  /// data in the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            const llvm::MemoryBufferRef &Buffer) {\n    overrideFileContents(SourceFile, llvm::MemoryBuffer::getMemBuffer(Buffer));\n  }\n\n  /// Override the contents of the given source file by providing an\n  /// already-allocated buffer.\n  ///\n  /// \\param SourceFile the source file whose contents will be overridden.\n  ///\n  /// \\param Buffer the memory buffer whose contents will be used as the\n  /// data in the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  void overrideFileContents(FileEntryRef SourceFile,\n                            std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    overrideFileContents(&SourceFile.getFileEntry(), std::move(Buffer));\n  }\n\n  /// Override the given source file with another one.\n  ///\n  /// \\param SourceFile the source file which will be overridden.\n  ///\n  /// \\param NewFile the file whose contents will be used as the\n  /// data instead of the contents of the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            const FileEntry *NewFile);\n\n  /// Returns true if the file contents have been overridden.\n  bool isFileOverridden(const FileEntry *File) const {\n    if (OverriddenFilesInfo) {\n      if (OverriddenFilesInfo->OverriddenFilesWithBuffer.count(File))\n        return true;\n      if (OverriddenFilesInfo->OverriddenFiles.find(File) !=\n          OverriddenFilesInfo->OverriddenFiles.end())\n        return true;\n    }\n    return false;\n  }\n\n  /// Bypass the overridden contents of a file.  This creates a new FileEntry\n  /// and initializes the content cache for it.  Returns None if there is no\n  /// such file in the filesystem.\n  ///\n  /// This should be called before parsing has begun.\n  Optional<FileEntryRef> bypassFileContentsOverride(FileEntryRef File);\n\n  /// Specify that a file is transient.\n  void setFileIsTransient(const FileEntry *SourceFile);\n\n  /// Specify that all files that are read during this compilation are\n  /// transient.\n  void setAllFilesAreTransient(bool Transient) {\n    FilesAreTransient = Transient;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // FileID manipulation methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the buffer for the specified FileID.\n  ///\n  /// If there is an error opening this buffer the first time, return None.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getBufferOrNone(FileID FID, SourceLocation Loc = SourceLocation()) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getContentCache().getBufferOrNone(\n          Diag, getFileManager(), Loc);\n    return None;\n  }\n\n  /// Return the buffer for the specified FileID.\n  ///\n  /// If there is an error opening this buffer the first time, this\n  /// manufactures a temporary buffer and returns it.\n  llvm::MemoryBufferRef\n  getBufferOrFake(FileID FID, SourceLocation Loc = SourceLocation()) const {\n    if (auto B = getBufferOrNone(FID, Loc))\n      return *B;\n    return getFakeBufferForRecovery();\n  }\n\n  /// Returns the FileEntry record for the provided FileID.\n  const FileEntry *getFileEntryForID(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getContentCache().OrigEntry;\n    return nullptr;\n  }\n\n  /// Returns the FileEntryRef for the provided FileID.\n  Optional<FileEntryRef> getFileEntryRefForID(FileID FID) const {\n    if (auto *Entry = getFileEntryForID(FID))\n      return Entry->getLastRef();\n    return None;\n  }\n\n  /// Returns the filename for the provided FileID, unless it's a built-in\n  /// buffer that's not represented by a filename.\n  ///\n  /// Returns None for non-files and built-in files.\n  Optional<StringRef> getNonBuiltinFilenameForID(FileID FID) const;\n\n  /// Returns the FileEntry record for the provided SLocEntry.\n  const FileEntry *getFileEntryForSLocEntry(const SrcMgr::SLocEntry &sloc) const\n  {\n    return sloc.getFile().getContentCache().OrigEntry;\n  }\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  /// \\param Invalid If non-NULL, will be set true if an error occurred.\n  StringRef getBufferData(FileID FID, bool *Invalid = nullptr) const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID, returning None if invalid.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  llvm::Optional<StringRef> getBufferDataOrNone(FileID FID) const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID, returning None if it's not yet loaded.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  llvm::Optional<StringRef> getBufferDataIfLoaded(FileID FID) const;\n\n  /// Get the number of FileIDs (files and macros) that were created\n  /// during preprocessing of \\p FID, including it.\n  unsigned getNumCreatedFIDsForFileID(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().NumCreatedFIDs;\n    return 0;\n  }\n\n  /// Set the number of FileIDs (files and macros) that were created\n  /// during preprocessing of \\p FID, including it.\n  void setNumCreatedFIDsForFileID(FileID FID, unsigned NumFIDs,\n                                  bool Force = false) const {\n    auto *Entry = getSLocEntryForFile(FID);\n    if (!Entry)\n      return;\n    assert((Force || Entry->getFile().NumCreatedFIDs == 0) && \"Already set!\");\n    const_cast<SrcMgr::FileInfo &>(Entry->getFile()).NumCreatedFIDs = NumFIDs;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // SourceLocation manipulation methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the FileID for a SourceLocation.\n  ///\n  /// This is a very hot method that is used for all SourceManager queries\n  /// that start with a SourceLocation object.  It is responsible for finding\n  /// the entry in SLocEntryTable which contains the specified location.\n  ///\n  FileID getFileID(SourceLocation SpellingLoc) const {\n    unsigned SLocOffset = SpellingLoc.getOffset();\n\n    // If our one-entry cache covers this offset, just return it.\n    if (isOffsetInFileID(LastFileIDLookup, SLocOffset))\n      return LastFileIDLookup;\n\n    return getFileIDSlow(SLocOffset);\n  }\n\n  /// Return the filename of the file containing a SourceLocation.\n  StringRef getFilename(SourceLocation SpellingLoc) const;\n\n  /// Return the source location corresponding to the first byte of\n  /// the specified file.\n  SourceLocation getLocForStartOfFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return SourceLocation::getFileLoc(Entry->getOffset());\n    return SourceLocation();\n  }\n\n  /// Return the source location corresponding to the last byte of the\n  /// specified file.\n  SourceLocation getLocForEndOfFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return SourceLocation::getFileLoc(Entry->getOffset() +\n                                        getFileIDSize(FID));\n    return SourceLocation();\n  }\n\n  /// Returns the include location if \\p FID is a \\#include'd file\n  /// otherwise it returns an invalid location.\n  SourceLocation getIncludeLoc(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getIncludeLoc();\n    return SourceLocation();\n  }\n\n  // Returns the import location if the given source location is\n  // located within a module, or an invalid location if the source location\n  // is within the current translation unit.\n  std::pair<SourceLocation, StringRef>\n  getModuleImportLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n\n    // Positive file IDs are in the current translation unit, and -1 is a\n    // placeholder.\n    if (FID.ID >= -1)\n      return std::make_pair(SourceLocation(), \"\");\n\n    return ExternalSLocEntries->getModuleImportLoc(FID.ID);\n  }\n\n  /// Given a SourceLocation object \\p Loc, return the expansion\n  /// location referenced by the ID.\n  SourceLocation getExpansionLoc(SourceLocation Loc) const {\n    // Handle the non-mapped case inline, defer to out of line code to handle\n    // expansions.\n    if (Loc.isFileID()) return Loc;\n    return getExpansionLocSlowCase(Loc);\n  }\n\n  /// Given \\p Loc, if it is a macro location return the expansion\n  /// location or the spelling location, depending on if it comes from a\n  /// macro argument or not.\n  SourceLocation getFileLoc(SourceLocation Loc) const {\n    if (Loc.isFileID()) return Loc;\n    return getFileLocSlowCase(Loc);\n  }\n\n  /// Return the start/end of the expansion information for an\n  /// expansion location.\n  ///\n  /// \\pre \\p Loc is required to be an expansion location.\n  CharSourceRange getImmediateExpansionRange(SourceLocation Loc) const;\n\n  /// Given a SourceLocation object, return the range of\n  /// tokens covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(SourceLocation Loc) const;\n\n  /// Given a SourceRange object, return the range of\n  /// tokens or characters covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(SourceRange Range) const {\n    SourceLocation Begin = getExpansionRange(Range.getBegin()).getBegin();\n    CharSourceRange End = getExpansionRange(Range.getEnd());\n    return CharSourceRange(SourceRange(Begin, End.getEnd()),\n                           End.isTokenRange());\n  }\n\n  /// Given a CharSourceRange object, return the range of\n  /// tokens or characters covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(CharSourceRange Range) const {\n    CharSourceRange Expansion = getExpansionRange(Range.getAsRange());\n    if (Expansion.getEnd() == Range.getEnd())\n      Expansion.setTokenRange(Range.isTokenRange());\n    return Expansion;\n  }\n\n  /// Given a SourceLocation object, return the spelling\n  /// location referenced by the ID.\n  ///\n  /// This is the place where the characters that make up the lexed token\n  /// can be found.\n  SourceLocation getSpellingLoc(SourceLocation Loc) const {\n    // Handle the non-mapped case inline, defer to out of line code to handle\n    // expansions.\n    if (Loc.isFileID()) return Loc;\n    return getSpellingLocSlowCase(Loc);\n  }\n\n  /// Given a SourceLocation object, return the spelling location\n  /// referenced by the ID.\n  ///\n  /// This is the first level down towards the place where the characters\n  /// that make up the lexed token can be found.  This should not generally\n  /// be used by clients.\n  SourceLocation getImmediateSpellingLoc(SourceLocation Loc) const;\n\n  /// Form a SourceLocation from a FileID and Offset pair.\n  SourceLocation getComposedLoc(FileID FID, unsigned Offset) const {\n    auto *Entry = getSLocEntryOrNull(FID);\n    if (!Entry)\n      return SourceLocation();\n\n    unsigned GlobalOffset = Entry->getOffset() + Offset;\n    return Entry->isFile() ? SourceLocation::getFileLoc(GlobalOffset)\n                           : SourceLocation::getMacroLoc(GlobalOffset);\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// The first element is the FileID, the second is the offset from the\n  /// start of the buffer of the location.\n  std::pair<FileID, unsigned> getDecomposedLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *Entry = getSLocEntryOrNull(FID);\n    if (!Entry)\n      return std::make_pair(FileID(), 0);\n    return std::make_pair(FID, Loc.getOffset() - Entry->getOffset());\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// If the location is an expansion record, walk through it until we find\n  /// the final location expanded.\n  std::pair<FileID, unsigned>\n  getDecomposedExpansionLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *E = getSLocEntryOrNull(FID);\n    if (!E)\n      return std::make_pair(FileID(), 0);\n\n    unsigned Offset = Loc.getOffset()-E->getOffset();\n    if (Loc.isFileID())\n      return std::make_pair(FID, Offset);\n\n    return getDecomposedExpansionLocSlowCase(E);\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// If the location is an expansion record, walk through it until we find\n  /// its spelling record.\n  std::pair<FileID, unsigned>\n  getDecomposedSpellingLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *E = getSLocEntryOrNull(FID);\n    if (!E)\n      return std::make_pair(FileID(), 0);\n\n    unsigned Offset = Loc.getOffset()-E->getOffset();\n    if (Loc.isFileID())\n      return std::make_pair(FID, Offset);\n    return getDecomposedSpellingLocSlowCase(E, Offset);\n  }\n\n  /// Returns the \"included/expanded in\" decomposed location of the given\n  /// FileID.\n  std::pair<FileID, unsigned> getDecomposedIncludedLoc(FileID FID) const;\n\n  /// Returns the offset from the start of the file that the\n  /// specified SourceLocation represents.\n  ///\n  /// This is not very meaningful for a macro ID.\n  unsigned getFileOffset(SourceLocation SpellingLoc) const {\n    return getDecomposedLoc(SpellingLoc).second;\n  }\n\n  /// Tests whether the given source location represents a macro\n  /// argument's expansion into the function-like macro definition.\n  ///\n  /// \\param StartLoc If non-null and function returns true, it is set to the\n  /// start location of the macro argument expansion.\n  ///\n  /// Such source locations only appear inside of the expansion\n  /// locations representing where a particular function-like macro was\n  /// expanded.\n  bool isMacroArgExpansion(SourceLocation Loc,\n                           SourceLocation *StartLoc = nullptr) const;\n\n  /// Tests whether the given source location represents the expansion of\n  /// a macro body.\n  ///\n  /// This is equivalent to testing whether the location is part of a macro\n  /// expansion but not the expansion of an argument to a function-like macro.\n  bool isMacroBodyExpansion(SourceLocation Loc) const;\n\n  /// Returns true if the given MacroID location points at the beginning\n  /// of the immediate macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to the\n  /// begin location of the immediate macro expansion.\n  bool isAtStartOfImmediateMacroExpansion(SourceLocation Loc,\n                                    SourceLocation *MacroBegin = nullptr) const;\n\n  /// Returns true if the given MacroID location points at the character\n  /// end of the immediate macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to the\n  /// character end location of the immediate macro expansion.\n  bool\n  isAtEndOfImmediateMacroExpansion(SourceLocation Loc,\n                                   SourceLocation *MacroEnd = nullptr) const;\n\n  /// Returns true if \\p Loc is inside the [\\p Start, +\\p Length)\n  /// chunk of the source location address space.\n  ///\n  /// If it's true and \\p RelativeOffset is non-null, it will be set to the\n  /// relative offset of \\p Loc inside the chunk.\n  bool isInSLocAddrSpace(SourceLocation Loc,\n                         SourceLocation Start, unsigned Length,\n                         unsigned *RelativeOffset = nullptr) const {\n    assert(((Start.getOffset() < NextLocalOffset &&\n               Start.getOffset()+Length <= NextLocalOffset) ||\n            (Start.getOffset() >= CurrentLoadedOffset &&\n                Start.getOffset()+Length < MaxLoadedOffset)) &&\n           \"Chunk is not valid SLoc address space\");\n    unsigned LocOffs = Loc.getOffset();\n    unsigned BeginOffs = Start.getOffset();\n    unsigned EndOffs = BeginOffs + Length;\n    if (LocOffs >= BeginOffs && LocOffs < EndOffs) {\n      if (RelativeOffset)\n        *RelativeOffset = LocOffs - BeginOffs;\n      return true;\n    }\n\n    return false;\n  }\n\n  /// Return true if both \\p LHS and \\p RHS are in the local source\n  /// location address space or the loaded one.\n  ///\n  /// If it's true and \\p RelativeOffset is non-null, it will be set to the\n  /// offset of \\p RHS relative to \\p LHS.\n  bool isInSameSLocAddrSpace(SourceLocation LHS, SourceLocation RHS,\n                             int *RelativeOffset) const {\n    unsigned LHSOffs = LHS.getOffset(), RHSOffs = RHS.getOffset();\n    bool LHSLoaded = LHSOffs >= CurrentLoadedOffset;\n    bool RHSLoaded = RHSOffs >= CurrentLoadedOffset;\n\n    if (LHSLoaded == RHSLoaded) {\n      if (RelativeOffset)\n        *RelativeOffset = RHSOffs - LHSOffs;\n      return true;\n    }\n\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Queries about the code at a SourceLocation.\n  //===--------------------------------------------------------------------===//\n\n  /// Return a pointer to the start of the specified location\n  /// in the appropriate spelling MemoryBuffer.\n  ///\n  /// \\param Invalid If non-NULL, will be set \\c true if an error occurs.\n  const char *getCharacterData(SourceLocation SL,\n                               bool *Invalid = nullptr) const;\n\n  /// Return the column # for the specified file position.\n  ///\n  /// This is significantly cheaper to compute than the line number.  This\n  /// returns zero if the column number isn't known.  This may only be called\n  /// on a file sloc, so you must choose a spelling or expansion location\n  /// before calling this method.\n  unsigned getColumnNumber(FileID FID, unsigned FilePos,\n                           bool *Invalid = nullptr) const;\n  unsigned getSpellingColumnNumber(SourceLocation Loc,\n                                   bool *Invalid = nullptr) const;\n  unsigned getExpansionColumnNumber(SourceLocation Loc,\n                                    bool *Invalid = nullptr) const;\n  unsigned getPresumedColumnNumber(SourceLocation Loc,\n                                   bool *Invalid = nullptr) const;\n\n  /// Given a SourceLocation, return the spelling line number\n  /// for the position indicated.\n  ///\n  /// This requires building and caching a table of line offsets for the\n  /// MemoryBuffer, so this is not cheap: use only when about to emit a\n  /// diagnostic.\n  unsigned getLineNumber(FileID FID, unsigned FilePos, bool *Invalid = nullptr) const;\n  unsigned getSpellingLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n  unsigned getExpansionLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n  unsigned getPresumedLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n\n  /// Return the filename or buffer identifier of the buffer the\n  /// location is in.\n  ///\n  /// Note that this name does not respect \\#line directives.  Use\n  /// getPresumedLoc for normal clients.\n  StringRef getBufferName(SourceLocation Loc, bool *Invalid = nullptr) const;\n\n  /// Return the file characteristic of the specified source\n  /// location, indicating whether this is a normal file, a system\n  /// header, or an \"implicit extern C\" system header.\n  ///\n  /// This state can be modified with flags on GNU linemarker directives like:\n  /// \\code\n  ///   # 4 \"foo.h\" 3\n  /// \\endcode\n  /// which changes all source locations in the current file after that to be\n  /// considered to be from a system header.\n  SrcMgr::CharacteristicKind getFileCharacteristic(SourceLocation Loc) const;\n\n  /// Returns the \"presumed\" location of a SourceLocation specifies.\n  ///\n  /// A \"presumed location\" can be modified by \\#line or GNU line marker\n  /// directives.  This provides a view on the data that a user should see\n  /// in diagnostics, for example.\n  ///\n  /// Note that a presumed location is always given as the expansion point of\n  /// an expansion location, not at the spelling location.\n  ///\n  /// \\returns The presumed location of the specified SourceLocation. If the\n  /// presumed location cannot be calculated (e.g., because \\p Loc is invalid\n  /// or the file containing \\p Loc has changed on disk), returns an invalid\n  /// presumed location.\n  PresumedLoc getPresumedLoc(SourceLocation Loc,\n                             bool UseLineDirectives = true) const;\n\n  /// Returns whether the PresumedLoc for a given SourceLocation is\n  /// in the main file.\n  ///\n  /// This computes the \"presumed\" location for a SourceLocation, then checks\n  /// whether it came from a file other than the main file. This is different\n  /// from isWrittenInMainFile() because it takes line marker directives into\n  /// account.\n  bool isInMainFile(SourceLocation Loc) const;\n\n  /// Returns true if the spelling locations for both SourceLocations\n  /// are part of the same file buffer.\n  ///\n  /// This check ignores line marker directives.\n  bool isWrittenInSameFile(SourceLocation Loc1, SourceLocation Loc2) const {\n    return getFileID(Loc1) == getFileID(Loc2);\n  }\n\n  /// Returns true if the spelling location for the given location\n  /// is in the main file buffer.\n  ///\n  /// This check ignores line marker directives.\n  bool isWrittenInMainFile(SourceLocation Loc) const {\n    return getFileID(Loc) == getMainFileID();\n  }\n\n  /// Returns whether \\p Loc is located in a <built-in> file.\n  bool isWrittenInBuiltinFile(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<built-in>\");\n  }\n\n  /// Returns whether \\p Loc is located in a <command line> file.\n  bool isWrittenInCommandLineFile(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<command line>\");\n  }\n\n  /// Returns whether \\p Loc is located in a <scratch space> file.\n  bool isWrittenInScratchSpace(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<scratch space>\");\n  }\n\n  /// Returns if a SourceLocation is in a system header.\n  bool isInSystemHeader(SourceLocation Loc) const {\n    return isSystem(getFileCharacteristic(Loc));\n  }\n\n  /// Returns if a SourceLocation is in an \"extern C\" system header.\n  bool isInExternCSystemHeader(SourceLocation Loc) const {\n    return getFileCharacteristic(Loc) == SrcMgr::C_ExternCSystem;\n  }\n\n  /// Returns whether \\p Loc is expanded from a macro in a system header.\n  bool isInSystemMacro(SourceLocation loc) const {\n    if (!loc.isMacroID())\n      return false;\n\n    // This happens when the macro is the result of a paste, in that case\n    // its spelling is the scratch memory, so we take the parent context.\n    // There can be several level of token pasting.\n    if (isWrittenInScratchSpace(getSpellingLoc(loc))) {\n      do {\n        loc = getImmediateMacroCallerLoc(loc);\n      } while (isWrittenInScratchSpace(getSpellingLoc(loc)));\n      return isInSystemMacro(loc);\n    }\n\n    return isInSystemHeader(getSpellingLoc(loc));\n  }\n\n  /// The size of the SLocEntry that \\p FID represents.\n  unsigned getFileIDSize(FileID FID) const;\n\n  /// Given a specific FileID, returns true if \\p Loc is inside that\n  /// FileID chunk and sets relative offset (offset of \\p Loc from beginning\n  /// of FileID) to \\p relativeOffset.\n  bool isInFileID(SourceLocation Loc, FileID FID,\n                  unsigned *RelativeOffset = nullptr) const {\n    unsigned Offs = Loc.getOffset();\n    if (isOffsetInFileID(FID, Offs)) {\n      if (RelativeOffset)\n        *RelativeOffset = Offs - getSLocEntry(FID).getOffset();\n      return true;\n    }\n\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Line Table Manipulation Routines\n  //===--------------------------------------------------------------------===//\n\n  /// Return the uniqued ID for the specified filename.\n  unsigned getLineTableFilenameID(StringRef Str);\n\n  /// Add a line note to the line table for the FileID and offset\n  /// specified by Loc.\n  ///\n  /// If FilenameID is -1, it is considered to be unspecified.\n  void AddLineNote(SourceLocation Loc, unsigned LineNo, int FilenameID,\n                   bool IsFileEntry, bool IsFileExit,\n                   SrcMgr::CharacteristicKind FileKind);\n\n  /// Determine if the source manager has a line table.\n  bool hasLineTable() const { return LineTable != nullptr; }\n\n  /// Retrieve the stored line table.\n  LineTableInfo &getLineTable();\n\n  //===--------------------------------------------------------------------===//\n  // Queries for performance analysis.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the total amount of physical memory allocated by the\n  /// ContentCache allocator.\n  size_t getContentCacheSize() const {\n    return ContentCacheAlloc.getTotalMemory();\n  }\n\n  struct MemoryBufferSizes {\n    const size_t malloc_bytes;\n    const size_t mmap_bytes;\n\n    MemoryBufferSizes(size_t malloc_bytes, size_t mmap_bytes)\n      : malloc_bytes(malloc_bytes), mmap_bytes(mmap_bytes) {}\n  };\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  MemoryBufferSizes getMemoryBufferSizes() const;\n\n  /// Return the amount of memory used for various side tables and\n  /// data structures in the SourceManager.\n  size_t getDataStructureSizes() const;\n\n  //===--------------------------------------------------------------------===//\n  // Other miscellaneous methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Get the source location for the given file:line:col triplet.\n  ///\n  /// If the source file is included multiple times, the source location will\n  /// be based upon the first inclusion.\n  SourceLocation translateFileLineCol(const FileEntry *SourceFile,\n                                      unsigned Line, unsigned Col) const;\n\n  /// Get the FileID for the given file.\n  ///\n  /// If the source file is included multiple times, the FileID will be the\n  /// first inclusion.\n  FileID translateFile(const FileEntry *SourceFile) const;\n  FileID translateFile(FileEntryRef SourceFile) const {\n    return translateFile(&SourceFile.getFileEntry());\n  }\n\n  /// Get the source location in \\p FID for the given line:col.\n  /// Returns null location if \\p FID is not a file SLocEntry.\n  SourceLocation translateLineCol(FileID FID,\n                                  unsigned Line, unsigned Col) const;\n\n  /// If \\p Loc points inside a function macro argument, the returned\n  /// location will be the macro location in which the argument was expanded.\n  /// If a macro argument is used multiple times, the expanded location will\n  /// be at the first expansion of the argument.\n  /// e.g.\n  ///   MY_MACRO(foo);\n  ///             ^\n  /// Passing a file location pointing at 'foo', will yield a macro location\n  /// where 'foo' was expanded into.\n  SourceLocation getMacroArgExpandedLocation(SourceLocation Loc) const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if LHS source location comes before RHS, false otherwise.\n  bool isBeforeInTranslationUnit(SourceLocation LHS, SourceLocation RHS) const;\n\n  /// Determines whether the two decomposed source location is in the\n  ///        same translation unit. As a byproduct, it also calculates the order\n  ///        of the source locations in case they are in the same TU.\n  ///\n  /// \\returns Pair of bools the first component is true if the two locations\n  ///          are in the same TU. The second bool is true if the first is true\n  ///          and \\p LOffs is before \\p ROffs.\n  std::pair<bool, bool>\n  isInTheSameTranslationUnit(std::pair<FileID, unsigned> &LOffs,\n                             std::pair<FileID, unsigned> &ROffs) const;\n\n  /// Determines the order of 2 source locations in the \"source location\n  /// address space\".\n  bool isBeforeInSLocAddrSpace(SourceLocation LHS, SourceLocation RHS) const {\n    return isBeforeInSLocAddrSpace(LHS, RHS.getOffset());\n  }\n\n  /// Determines the order of a source location and a source location\n  /// offset in the \"source location address space\".\n  ///\n  /// Note that we always consider source locations loaded from\n  bool isBeforeInSLocAddrSpace(SourceLocation LHS, unsigned RHS) const {\n    unsigned LHSOffset = LHS.getOffset();\n    bool LHSLoaded = LHSOffset >= CurrentLoadedOffset;\n    bool RHSLoaded = RHS >= CurrentLoadedOffset;\n    if (LHSLoaded == RHSLoaded)\n      return LHSOffset < RHS;\n\n    return LHSLoaded;\n  }\n\n  /// Return true if the Point is within Start and End.\n  bool isPointWithin(SourceLocation Location, SourceLocation Start,\n                     SourceLocation End) const {\n    return Location == Start || Location == End ||\n           (isBeforeInTranslationUnit(Start, Location) &&\n            isBeforeInTranslationUnit(Location, End));\n  }\n\n  // Iterators over FileInfos.\n  using fileinfo_iterator =\n      llvm::DenseMap<const FileEntry*, SrcMgr::ContentCache*>::const_iterator;\n\n  fileinfo_iterator fileinfo_begin() const { return FileInfos.begin(); }\n  fileinfo_iterator fileinfo_end() const { return FileInfos.end(); }\n  bool hasFileInfo(const FileEntry *File) const {\n    return FileInfos.find(File) != FileInfos.end();\n  }\n\n  /// Print statistics to stderr.\n  void PrintStats() const;\n\n  void dump() const;\n\n  /// Get the number of local SLocEntries we have.\n  unsigned local_sloc_entry_size() const { return LocalSLocEntryTable.size(); }\n\n  /// Get a local SLocEntry. This is exposed for indexing.\n  const SrcMgr::SLocEntry &getLocalSLocEntry(unsigned Index) const {\n    assert(Index < LocalSLocEntryTable.size() && \"Invalid index\");\n    return LocalSLocEntryTable[Index];\n  }\n\n  /// Get the number of loaded SLocEntries we have.\n  unsigned loaded_sloc_entry_size() const { return LoadedSLocEntryTable.size();}\n\n  /// Get a loaded SLocEntry. This is exposed for indexing.\n  const SrcMgr::SLocEntry &getLoadedSLocEntry(unsigned Index,\n                                              bool *Invalid = nullptr) const {\n    assert(Index < LoadedSLocEntryTable.size() && \"Invalid index\");\n    if (SLocEntryLoaded[Index])\n      return LoadedSLocEntryTable[Index];\n    return loadSLocEntry(Index, Invalid);\n  }\n\n  const SrcMgr::SLocEntry &getSLocEntry(FileID FID,\n                                        bool *Invalid = nullptr) const {\n    if (FID.ID == 0 || FID.ID == -1) {\n      if (Invalid) *Invalid = true;\n      return LocalSLocEntryTable[0];\n    }\n    return getSLocEntryByID(FID.ID, Invalid);\n  }\n\n  unsigned getNextLocalOffset() const { return NextLocalOffset; }\n\n  void setExternalSLocEntrySource(ExternalSLocEntrySource *Source) {\n    assert(LoadedSLocEntryTable.empty() &&\n           \"Invalidating existing loaded entries\");\n    ExternalSLocEntries = Source;\n  }\n\n  /// Allocate a number of loaded SLocEntries, which will be actually\n  /// loaded on demand from the external source.\n  ///\n  /// NumSLocEntries will be allocated, which occupy a total of TotalSize space\n  /// in the global source view. The lowest ID and the base offset of the\n  /// entries will be returned.\n  std::pair<int, unsigned>\n  AllocateLoadedSLocEntries(unsigned NumSLocEntries, unsigned TotalSize);\n\n  /// Returns true if \\p Loc came from a PCH/Module.\n  bool isLoadedSourceLocation(SourceLocation Loc) const {\n    return Loc.getOffset() >= CurrentLoadedOffset;\n  }\n\n  /// Returns true if \\p Loc did not come from a PCH/Module.\n  bool isLocalSourceLocation(SourceLocation Loc) const {\n    return Loc.getOffset() < NextLocalOffset;\n  }\n\n  /// Returns true if \\p FID came from a PCH/Module.\n  bool isLoadedFileID(FileID FID) const {\n    assert(FID.ID != -1 && \"Using FileID sentinel value\");\n    return FID.ID < 0;\n  }\n\n  /// Returns true if \\p FID did not come from a PCH/Module.\n  bool isLocalFileID(FileID FID) const {\n    return !isLoadedFileID(FID);\n  }\n\n  /// Gets the location of the immediate macro caller, one level up the stack\n  /// toward the initial macro typed into the source.\n  SourceLocation getImmediateMacroCallerLoc(SourceLocation Loc) const {\n    if (!Loc.isMacroID()) return Loc;\n\n    // When we have the location of (part of) an expanded parameter, its\n    // spelling location points to the argument as expanded in the macro call,\n    // and therefore is used to locate the macro caller.\n    if (isMacroArgExpansion(Loc))\n      return getImmediateSpellingLoc(Loc);\n\n    // Otherwise, the caller of the macro is located where this macro is\n    // expanded (while the spelling is part of the macro definition).\n    return getImmediateExpansionRange(Loc).getBegin();\n  }\n\n  /// \\return Location of the top-level macro caller.\n  SourceLocation getTopMacroCallerLoc(SourceLocation Loc) const;\n\nprivate:\n  friend class ASTReader;\n  friend class ASTWriter;\n\n  llvm::MemoryBufferRef getFakeBufferForRecovery() const;\n  SrcMgr::ContentCache &getFakeContentCacheForRecovery() const;\n\n  const SrcMgr::SLocEntry &loadSLocEntry(unsigned Index, bool *Invalid) const;\n\n  const SrcMgr::SLocEntry *getSLocEntryOrNull(FileID FID) const {\n    bool Invalid = false;\n    const SrcMgr::SLocEntry &Entry = getSLocEntry(FID, &Invalid);\n    return Invalid ? nullptr : &Entry;\n  }\n\n  const SrcMgr::SLocEntry *getSLocEntryForFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryOrNull(FID))\n      if (Entry->isFile())\n        return Entry;\n    return nullptr;\n  }\n\n  /// Get the entry with the given unwrapped FileID.\n  /// Invalid will not be modified for Local IDs.\n  const SrcMgr::SLocEntry &getSLocEntryByID(int ID,\n                                            bool *Invalid = nullptr) const {\n    assert(ID != -1 && \"Using FileID sentinel value\");\n    if (ID < 0)\n      return getLoadedSLocEntryByID(ID, Invalid);\n    return getLocalSLocEntry(static_cast<unsigned>(ID));\n  }\n\n  const SrcMgr::SLocEntry &\n  getLoadedSLocEntryByID(int ID, bool *Invalid = nullptr) const {\n    return getLoadedSLocEntry(static_cast<unsigned>(-ID - 2), Invalid);\n  }\n\n  /// Implements the common elements of storing an expansion info struct into\n  /// the SLocEntry table and producing a source location that refers to it.\n  SourceLocation createExpansionLocImpl(const SrcMgr::ExpansionInfo &Expansion,\n                                        unsigned TokLength,\n                                        int LoadedID = 0,\n                                        unsigned LoadedOffset = 0);\n\n  /// Return true if the specified FileID contains the\n  /// specified SourceLocation offset.  This is a very hot method.\n  inline bool isOffsetInFileID(FileID FID, unsigned SLocOffset) const {\n    const SrcMgr::SLocEntry &Entry = getSLocEntry(FID);\n    // If the entry is after the offset, it can't contain it.\n    if (SLocOffset < Entry.getOffset()) return false;\n\n    // If this is the very last entry then it does.\n    if (FID.ID == -2)\n      return true;\n\n    // If it is the last local entry, then it does if the location is local.\n    if (FID.ID+1 == static_cast<int>(LocalSLocEntryTable.size()))\n      return SLocOffset < NextLocalOffset;\n\n    // Otherwise, the entry after it has to not include it. This works for both\n    // local and loaded entries.\n    return SLocOffset < getSLocEntryByID(FID.ID+1).getOffset();\n  }\n\n  /// Returns the previous in-order FileID or an invalid FileID if there\n  /// is no previous one.\n  FileID getPreviousFileID(FileID FID) const;\n\n  /// Returns the next in-order FileID or an invalid FileID if there is\n  /// no next one.\n  FileID getNextFileID(FileID FID) const;\n\n  /// Create a new fileID for the specified ContentCache and\n  /// include position.\n  ///\n  /// This works regardless of whether the ContentCache corresponds to a\n  /// file or some other input source.\n  FileID createFileIDImpl(SrcMgr::ContentCache &File, StringRef Filename,\n                          SourceLocation IncludePos,\n                          SrcMgr::CharacteristicKind DirCharacter, int LoadedID,\n                          unsigned LoadedOffset);\n\n  SrcMgr::ContentCache &getOrCreateContentCache(FileEntryRef SourceFile,\n                                                bool isSystemFile = false);\n\n  /// Create a new ContentCache for the specified  memory buffer.\n  SrcMgr::ContentCache &\n  createMemBufferContentCache(std::unique_ptr<llvm::MemoryBuffer> Buf);\n\n  FileID getFileIDSlow(unsigned SLocOffset) const;\n  FileID getFileIDLocal(unsigned SLocOffset) const;\n  FileID getFileIDLoaded(unsigned SLocOffset) const;\n\n  SourceLocation getExpansionLocSlowCase(SourceLocation Loc) const;\n  SourceLocation getSpellingLocSlowCase(SourceLocation Loc) const;\n  SourceLocation getFileLocSlowCase(SourceLocation Loc) const;\n\n  std::pair<FileID, unsigned>\n  getDecomposedExpansionLocSlowCase(const SrcMgr::SLocEntry *E) const;\n  std::pair<FileID, unsigned>\n  getDecomposedSpellingLocSlowCase(const SrcMgr::SLocEntry *E,\n                                   unsigned Offset) const;\n  void computeMacroArgsCache(MacroArgsMap &MacroArgsCache, FileID FID) const;\n  void associateFileChunkWithMacroArgExp(MacroArgsMap &MacroArgsCache,\n                                         FileID FID,\n                                         SourceLocation SpellLoc,\n                                         SourceLocation ExpansionLoc,\n                                         unsigned ExpansionLength) const;\n};\n\n/// Comparison function object.\ntemplate<typename T>\nclass BeforeThanCompare;\n\n/// Compare two source locations.\ntemplate<>\nclass BeforeThanCompare<SourceLocation> {\n  SourceManager &SM;\n\npublic:\n  explicit BeforeThanCompare(SourceManager &SM) : SM(SM) {}\n\n  bool operator()(SourceLocation LHS, SourceLocation RHS) const {\n    return SM.isBeforeInTranslationUnit(LHS, RHS);\n  }\n};\n\n/// Compare two non-overlapping source ranges.\ntemplate<>\nclass BeforeThanCompare<SourceRange> {\n  SourceManager &SM;\n\npublic:\n  explicit BeforeThanCompare(SourceManager &SM) : SM(SM) {}\n\n  bool operator()(SourceRange LHS, SourceRange RHS) const {\n    return SM.isBeforeInTranslationUnit(LHS.getBegin(), RHS.getBegin());\n  }\n};\n\n/// SourceManager and necessary depdencies (e.g. VFS, FileManager) for a single\n/// in-memorty file.\nclass SourceManagerForFile {\npublic:\n  /// Creates SourceManager and necessary depdencies (e.g. VFS, FileManager).\n  /// The main file in the SourceManager will be \\p FileName with \\p Content.\n  SourceManagerForFile(StringRef FileName, StringRef Content);\n\n  SourceManager &get() {\n    assert(SourceMgr);\n    return *SourceMgr;\n  }\n\nprivate:\n  // The order of these fields are important - they should be in the same order\n  // as they are created in `createSourceManagerForFile` so that they can be\n  // deleted in the reverse order as they are created.\n  std::unique_ptr<FileManager> FileMgr;\n  std::unique_ptr<DiagnosticsEngine> Diagnostics;\n  std::unique_ptr<SourceManager> SourceMgr;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_SOURCEMANAGER_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Specifiers.h", "content": "//===--- Specifiers.h - Declaration and Type Specifiers ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines various enumerations that describe declaration and\n/// type specifiers.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SPECIFIERS_H\n#define LLVM_CLANG_BASIC_SPECIFIERS_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n\nnamespace clang {\n\n  /// Define the meaning of possible values of the kind in ExplicitSpecifier.\n  enum class ExplicitSpecKind : unsigned {\n    ResolvedFalse,\n    ResolvedTrue,\n    Unresolved,\n  };\n\n  /// Define the kind of constexpr specifier.\n  enum class ConstexprSpecKind { Unspecified, Constexpr, Consteval, Constinit };\n\n  /// Specifies the width of a type, e.g., short, long, or long long.\n  enum class TypeSpecifierWidth { Unspecified, Short, Long, LongLong };\n\n  /// Specifies the signedness of a type, e.g., signed or unsigned.\n  enum class TypeSpecifierSign { Unspecified, Signed, Unsigned };\n\n  enum class TypeSpecifiersPipe { Unspecified, Pipe };\n\n  /// Specifies the kind of type.\n  enum TypeSpecifierType {\n    TST_unspecified,\n    TST_void,\n    TST_char,\n    TST_wchar,        // C++ wchar_t\n    TST_char8,        // C++20 char8_t (proposed)\n    TST_char16,       // C++11 char16_t\n    TST_char32,       // C++11 char32_t\n    TST_int,\n    TST_int128,\n    TST_extint,       // Extended Int types.\n    TST_half,         // OpenCL half, ARM NEON __fp16\n    TST_Float16,      // C11 extension ISO/IEC TS 18661-3\n    TST_Accum,        // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n    TST_Fract,\n    TST_BFloat16,\n    TST_float,\n    TST_double,\n    TST_float128,\n    TST_bool,         // _Bool\n    TST_decimal32,    // _Decimal32\n    TST_decimal64,    // _Decimal64\n    TST_decimal128,   // _Decimal128\n    TST_enum,\n    TST_union,\n    TST_struct,\n    TST_class,        // C++ class type\n    TST_interface,    // C++ (Microsoft-specific) __interface type\n    TST_typename,     // Typedef, C++ class-name or enum name, etc.\n    TST_typeofType,\n    TST_typeofExpr,\n    TST_decltype,         // C++11 decltype\n    TST_underlyingType,   // __underlying_type for C++11\n    TST_auto,             // C++11 auto\n    TST_decltype_auto,    // C++1y decltype(auto)\n    TST_auto_type,        // __auto_type extension\n    TST_unknown_anytype,  // __unknown_anytype extension\n    TST_atomic,           // C11 _Atomic\n#define GENERIC_IMAGE_TYPE(ImgType, Id) TST_##ImgType##_t, // OpenCL image types\n#include \"clang/Basic/OpenCLImageTypes.def\"\n    TST_error // erroneous type\n  };\n\n  /// Structure that packs information about the type specifiers that\n  /// were written in a particular type specifier sequence.\n  struct WrittenBuiltinSpecs {\n    static_assert(TST_error < 1 << 6, \"Type bitfield not wide enough for TST\");\n    /*DeclSpec::TST*/ unsigned Type  : 6;\n    /*DeclSpec::TSS*/ unsigned Sign  : 2;\n    /*TypeSpecifierWidth*/ unsigned Width : 2;\n    unsigned ModeAttr : 1;\n  };\n\n  /// A C++ access specifier (public, private, protected), plus the\n  /// special value \"none\" which means different things in different contexts.\n  enum AccessSpecifier {\n    AS_public,\n    AS_protected,\n    AS_private,\n    AS_none\n  };\n\n  /// The categorization of expression values, currently following the\n  /// C++11 scheme.\n  enum ExprValueKind {\n    /// An r-value expression (a pr-value in the C++11 taxonomy)\n    /// produces a temporary value.\n    VK_RValue,\n\n    /// An l-value expression is a reference to an object with\n    /// independent storage.\n    VK_LValue,\n\n    /// An x-value expression is a reference to an object with\n    /// independent storage but which can be \"moved\", i.e.\n    /// efficiently cannibalized for its resources.\n    VK_XValue\n  };\n\n  /// A further classification of the kind of object referenced by an\n  /// l-value or x-value.\n  enum ExprObjectKind {\n    /// An ordinary object is located at an address in memory.\n    OK_Ordinary,\n\n    /// A bitfield object is a bitfield on a C or C++ record.\n    OK_BitField,\n\n    /// A vector component is an element or range of elements on a vector.\n    OK_VectorComponent,\n\n    /// An Objective-C property is a logical field of an Objective-C\n    /// object which is read and written via Objective-C method calls.\n    OK_ObjCProperty,\n\n    /// An Objective-C array/dictionary subscripting which reads an\n    /// object or writes at the subscripted array/dictionary element via\n    /// Objective-C method calls.\n    OK_ObjCSubscript,\n\n    /// A matrix component is a single element of a matrix.\n    OK_MatrixComponent\n  };\n\n  /// The reason why a DeclRefExpr does not constitute an odr-use.\n  enum NonOdrUseReason {\n    /// This is an odr-use.\n    NOUR_None = 0,\n    /// This name appears in an unevaluated operand.\n    NOUR_Unevaluated,\n    /// This name appears as a potential result of an lvalue-to-rvalue\n    /// conversion that is a constant expression.\n    NOUR_Constant,\n    /// This name appears as a potential result of a discarded value\n    /// expression.\n    NOUR_Discarded,\n  };\n\n  /// Describes the kind of template specialization that a\n  /// particular template specialization declaration represents.\n  enum TemplateSpecializationKind {\n    /// This template specialization was formed from a template-id but\n    /// has not yet been declared, defined, or instantiated.\n    TSK_Undeclared = 0,\n    /// This template specialization was implicitly instantiated from a\n    /// template. (C++ [temp.inst]).\n    TSK_ImplicitInstantiation,\n    /// This template specialization was declared or defined by an\n    /// explicit specialization (C++ [temp.expl.spec]) or partial\n    /// specialization (C++ [temp.class.spec]).\n    TSK_ExplicitSpecialization,\n    /// This template specialization was instantiated from a template\n    /// due to an explicit instantiation declaration request\n    /// (C++11 [temp.explicit]).\n    TSK_ExplicitInstantiationDeclaration,\n    /// This template specialization was instantiated from a template\n    /// due to an explicit instantiation definition request\n    /// (C++ [temp.explicit]).\n    TSK_ExplicitInstantiationDefinition\n  };\n\n  /// Determine whether this template specialization kind refers\n  /// to an instantiation of an entity (as opposed to a non-template or\n  /// an explicit specialization).\n  inline bool isTemplateInstantiation(TemplateSpecializationKind Kind) {\n    return Kind != TSK_Undeclared && Kind != TSK_ExplicitSpecialization;\n  }\n\n  /// True if this template specialization kind is an explicit\n  /// specialization, explicit instantiation declaration, or explicit\n  /// instantiation definition.\n  inline bool isTemplateExplicitInstantiationOrSpecialization(\n      TemplateSpecializationKind Kind) {\n    switch (Kind) {\n    case TSK_ExplicitSpecialization:\n    case TSK_ExplicitInstantiationDeclaration:\n    case TSK_ExplicitInstantiationDefinition:\n      return true;\n\n    case TSK_Undeclared:\n    case TSK_ImplicitInstantiation:\n      return false;\n    }\n    llvm_unreachable(\"bad template specialization kind\");\n  }\n\n  /// Thread storage-class-specifier.\n  enum ThreadStorageClassSpecifier {\n    TSCS_unspecified,\n    /// GNU __thread.\n    TSCS___thread,\n    /// C++11 thread_local. Implies 'static' at block scope, but not at\n    /// class scope.\n    TSCS_thread_local,\n    /// C11 _Thread_local. Must be combined with either 'static' or 'extern'\n    /// if used at block scope.\n    TSCS__Thread_local\n  };\n\n  /// Storage classes.\n  enum StorageClass {\n    // These are legal on both functions and variables.\n    SC_None,\n    SC_Extern,\n    SC_Static,\n    SC_PrivateExtern,\n\n    // These are only legal on variables.\n    SC_Auto,\n    SC_Register\n  };\n\n  /// Checks whether the given storage class is legal for functions.\n  inline bool isLegalForFunction(StorageClass SC) {\n    return SC <= SC_PrivateExtern;\n  }\n\n  /// Checks whether the given storage class is legal for variables.\n  inline bool isLegalForVariable(StorageClass SC) {\n    return true;\n  }\n\n  /// In-class initialization styles for non-static data members.\n  enum InClassInitStyle {\n    ICIS_NoInit,   ///< No in-class initializer.\n    ICIS_CopyInit, ///< Copy initialization.\n    ICIS_ListInit  ///< Direct list-initialization.\n  };\n\n  /// CallingConv - Specifies the calling convention that a function uses.\n  enum CallingConv {\n    CC_C,           // __attribute__((cdecl))\n    CC_X86StdCall,  // __attribute__((stdcall))\n    CC_X86FastCall, // __attribute__((fastcall))\n    CC_X86ThisCall, // __attribute__((thiscall))\n    CC_X86VectorCall, // __attribute__((vectorcall))\n    CC_X86Pascal,   // __attribute__((pascal))\n    CC_Win64,       // __attribute__((ms_abi))\n    CC_X86_64SysV,  // __attribute__((sysv_abi))\n    CC_X86RegCall, // __attribute__((regcall))\n    CC_AAPCS,       // __attribute__((pcs(\"aapcs\")))\n    CC_AAPCS_VFP,   // __attribute__((pcs(\"aapcs-vfp\")))\n    CC_IntelOclBicc, // __attribute__((intel_ocl_bicc))\n    CC_SpirFunction, // default for OpenCL functions on SPIR target\n    CC_OpenCLKernel, // inferred for OpenCL kernels\n    CC_Swift,        // __attribute__((swiftcall))\n    CC_PreserveMost, // __attribute__((preserve_most))\n    CC_PreserveAll,  // __attribute__((preserve_all))\n    CC_AArch64VectorCall, // __attribute__((aarch64_vector_pcs))\n  };\n\n  /// Checks whether the given calling convention supports variadic\n  /// calls. Unprototyped calls also use the variadic call rules.\n  inline bool supportsVariadicCall(CallingConv CC) {\n    switch (CC) {\n    case CC_X86StdCall:\n    case CC_X86FastCall:\n    case CC_X86ThisCall:\n    case CC_X86RegCall:\n    case CC_X86Pascal:\n    case CC_X86VectorCall:\n    case CC_SpirFunction:\n    case CC_OpenCLKernel:\n    case CC_Swift:\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /// The storage duration for an object (per C++ [basic.stc]).\n  enum StorageDuration {\n    SD_FullExpression, ///< Full-expression storage duration (for temporaries).\n    SD_Automatic,      ///< Automatic storage duration (most local variables).\n    SD_Thread,         ///< Thread storage duration.\n    SD_Static,         ///< Static storage duration.\n    SD_Dynamic         ///< Dynamic storage duration.\n  };\n\n  /// Describes the nullability of a particular type.\n  enum class NullabilityKind : uint8_t {\n    /// Values of this type can never be null.\n    NonNull = 0,\n    /// Values of this type can be null.\n    Nullable,\n    /// Whether values of this type can be null is (explicitly)\n    /// unspecified. This captures a (fairly rare) case where we\n    /// can't conclude anything about the nullability of the type even\n    /// though it has been considered.\n    Unspecified,\n    // Generally behaves like Nullable, except when used in a block parameter\n    // that was imported into a swift async method. There, swift will assume\n    // that the parameter can get null even if no error occured. _Nullable\n    // parameters are assumed to only get null on error.\n    NullableResult,\n  };\n\n  /// Return true if \\p L has a weaker nullability annotation than \\p R. The\n  /// ordering is: Unspecified < Nullable < NonNull.\n  inline bool hasWeakerNullability(NullabilityKind L, NullabilityKind R) {\n    return uint8_t(L) > uint8_t(R);\n  }\n\n  /// Retrieve the spelling of the given nullability kind.\n  llvm::StringRef getNullabilitySpelling(NullabilityKind kind,\n                                         bool isContextSensitive = false);\n\n  /// Kinds of parameter ABI.\n  enum class ParameterABI {\n    /// This parameter uses ordinary ABI rules for its type.\n    Ordinary,\n\n    /// This parameter (which must have pointer type) is a Swift\n    /// indirect result parameter.\n    SwiftIndirectResult,\n\n    /// This parameter (which must have pointer-to-pointer type) uses\n    /// the special Swift error-result ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftErrorResult,\n\n    /// This parameter (which must have pointer type) uses the special\n    /// Swift context-pointer ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftContext\n  };\n\n  /// Assigned inheritance model for a class in the MS C++ ABI. Must match order\n  /// of spellings in MSInheritanceAttr.\n  enum class MSInheritanceModel {\n    Single = 0,\n    Multiple = 1,\n    Virtual = 2,\n    Unspecified = 3,\n  };\n\n  llvm::StringRef getParameterABISpelling(ParameterABI kind);\n\n  inline llvm::StringRef getAccessSpelling(AccessSpecifier AS) {\n    switch (AS) {\n    case AccessSpecifier::AS_public:\n      return \"public\";\n    case AccessSpecifier::AS_protected:\n      return \"protected\";\n    case AccessSpecifier::AS_private:\n      return \"private\";\n    case AccessSpecifier::AS_none:\n      return {};\n    }\n    llvm_unreachable(\"Unknown AccessSpecifier\");\n  }\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_SPECIFIERS_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "content": "\n//===--- CommandLineSourceLoc.h - Parsing for source locations-*- C++ -*---===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Command line parsing for source locations.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMMANDLINESOURCELOC_H\n#define LLVM_CLANG_FRONTEND_COMMANDLINESOURCELOC_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace clang {\n\n/// A source location that has been parsed on the command line.\nstruct ParsedSourceLocation {\n  std::string FileName;\n  unsigned Line;\n  unsigned Column;\n\npublic:\n  /// Construct a parsed source location from a string; the Filename is empty on\n  /// error.\n  static ParsedSourceLocation FromString(StringRef Str) {\n    ParsedSourceLocation PSL;\n    std::pair<StringRef, StringRef> ColSplit = Str.rsplit(':');\n    std::pair<StringRef, StringRef> LineSplit =\n      ColSplit.first.rsplit(':');\n\n    // If both tail splits were valid integers, return success.\n    if (!ColSplit.second.getAsInteger(10, PSL.Column) &&\n        !LineSplit.second.getAsInteger(10, PSL.Line)) {\n      PSL.FileName = std::string(LineSplit.first);\n\n      // On the command-line, stdin may be specified via \"-\". Inside the\n      // compiler, stdin is called \"<stdin>\".\n      if (PSL.FileName == \"-\")\n        PSL.FileName = \"<stdin>\";\n    }\n\n    return PSL;\n  }\n\n  /// Serialize ParsedSourceLocation back to a string.\n  std::string ToString() const {\n    return (llvm::Twine(FileName == \"<stdin>\" ? \"-\" : FileName) + \":\" +\n            Twine(Line) + \":\" + Twine(Column))\n        .str();\n  }\n};\n\n/// A source range that has been parsed on the command line.\nstruct ParsedSourceRange {\n  std::string FileName;\n  /// The starting location of the range. The first element is the line and\n  /// the second element is the column.\n  std::pair<unsigned, unsigned> Begin;\n  /// The ending location of the range. The first element is the line and the\n  /// second element is the column.\n  std::pair<unsigned, unsigned> End;\n\n  /// Returns a parsed source range from a string or None if the string is\n  /// invalid.\n  ///\n  /// These source string has the following format:\n  ///\n  /// file:start_line:start_column[-end_line:end_column]\n  ///\n  /// If the end line and column are omitted, the starting line and columns\n  /// are used as the end values.\n  static Optional<ParsedSourceRange> fromString(StringRef Str) {\n    std::pair<StringRef, StringRef> RangeSplit = Str.rsplit('-');\n    unsigned EndLine, EndColumn;\n    bool HasEndLoc = false;\n    if (!RangeSplit.second.empty()) {\n      std::pair<StringRef, StringRef> Split = RangeSplit.second.rsplit(':');\n      if (Split.first.getAsInteger(10, EndLine) ||\n          Split.second.getAsInteger(10, EndColumn)) {\n        // The string does not end in end_line:end_column, so the '-'\n        // probably belongs to the filename which menas the whole\n        // string should be parsed.\n        RangeSplit.first = Str;\n      } else\n        HasEndLoc = true;\n    }\n    auto Begin = ParsedSourceLocation::FromString(RangeSplit.first);\n    if (Begin.FileName.empty())\n      return None;\n    if (!HasEndLoc) {\n      EndLine = Begin.Line;\n      EndColumn = Begin.Column;\n    }\n    return ParsedSourceRange{std::move(Begin.FileName),\n                             {Begin.Line, Begin.Column},\n                             {EndLine, EndColumn}};\n  }\n};\n}\n\nnamespace llvm {\n  namespace cl {\n    /// Command-line option parser that parses source locations.\n    ///\n    /// Source locations are of the form filename:line:column.\n    template<>\n    class parser<clang::ParsedSourceLocation> final\n      : public basic_parser<clang::ParsedSourceLocation> {\n    public:\n      inline bool parse(Option &O, StringRef ArgName, StringRef ArgValue,\n                 clang::ParsedSourceLocation &Val);\n    };\n\n    bool\n    parser<clang::ParsedSourceLocation>::\n    parse(Option &O, StringRef ArgName, StringRef ArgValue,\n          clang::ParsedSourceLocation &Val) {\n      using namespace clang;\n\n      Val = ParsedSourceLocation::FromString(ArgValue);\n      if (Val.FileName.empty()) {\n        errs() << \"error: \"\n               << \"source location must be of the form filename:line:column\\n\";\n        return true;\n      }\n\n      return false;\n    }\n  }\n}\n\n#endif\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "content": "//===-- FrontendAction.h - Generic Frontend Action Interface ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::FrontendAction interface and various convenience\n/// abstract classes (clang::ASTFrontendAction, clang::PluginASTAction,\n/// clang::PreprocessorFrontendAction, and clang::WrapperFrontendAction)\n/// derived from it.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_FRONTENDACTION_H\n#define LLVM_CLANG_FRONTEND_FRONTENDACTION_H\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Frontend/ASTUnit.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nclass ASTMergeAction;\nclass CompilerInstance;\n\n/// Abstract base class for actions which can be performed by the frontend.\nclass FrontendAction {\n  FrontendInputFile CurrentInput;\n  std::unique_ptr<ASTUnit> CurrentASTUnit;\n  CompilerInstance *Instance;\n  friend class ASTMergeAction;\n  friend class WrapperFrontendAction;\n\nprivate:\n  std::unique_ptr<ASTConsumer> CreateWrappedASTConsumer(CompilerInstance &CI,\n                                                        StringRef InFile);\n\nprotected:\n  /// @name Implementation Action Interface\n  /// @{\n\n  /// Prepare to execute the action on the given CompilerInstance.\n  ///\n  /// This is called before executing the action on any inputs, and can modify\n  /// the configuration as needed (including adjusting the input list).\n  virtual bool PrepareToExecuteAction(CompilerInstance &CI) { return true; }\n\n  /// Create the AST consumer object for this action, if supported.\n  ///\n  /// This routine is called as part of BeginSourceFile(), which will\n  /// fail if the AST consumer cannot be created. This will not be called if the\n  /// action has indicated that it only uses the preprocessor.\n  ///\n  /// \\param CI - The current compiler instance, provided as a convenience, see\n  /// getCompilerInstance().\n  ///\n  /// \\param InFile - The current input file, provided as a convenience, see\n  /// getCurrentFile().\n  ///\n  /// \\return The new AST consumer, or null on failure.\n  virtual std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                         StringRef InFile) = 0;\n\n  /// Callback before starting processing a single input, giving the\n  /// opportunity to modify the CompilerInvocation or do some other action\n  /// before BeginSourceFileAction is called.\n  ///\n  /// \\return True on success; on failure BeginSourceFileAction(),\n  /// ExecuteAction() and EndSourceFileAction() will not be called.\n  virtual bool BeginInvocation(CompilerInstance &CI) { return true; }\n\n  /// Callback at the start of processing a single input.\n  ///\n  /// \\return True on success; on failure ExecutionAction() and\n  /// EndSourceFileAction() will not be called.\n  virtual bool BeginSourceFileAction(CompilerInstance &CI) {\n    return true;\n  }\n\n  /// Callback to run the program action, using the initialized\n  /// compiler instance.\n  ///\n  /// This is guaranteed to only be called between BeginSourceFileAction()\n  /// and EndSourceFileAction().\n  virtual void ExecuteAction() = 0;\n\n  /// Callback at the end of processing a single input.\n  ///\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual void EndSourceFileAction() {}\n\n  /// Callback at the end of processing a single input, to determine\n  /// if the output files should be erased or not.\n  ///\n  /// By default it returns true if a compiler error occurred.\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual bool shouldEraseOutputFiles();\n\n  /// @}\n\npublic:\n  FrontendAction();\n  virtual ~FrontendAction();\n\n  /// @name Compiler Instance Access\n  /// @{\n\n  CompilerInstance &getCompilerInstance() const {\n    assert(Instance && \"Compiler instance not registered!\");\n    return *Instance;\n  }\n\n  void setCompilerInstance(CompilerInstance *Value) { Instance = Value; }\n\n  /// @}\n  /// @name Current File Information\n  /// @{\n\n  bool isCurrentFileAST() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return (bool)CurrentASTUnit;\n  }\n\n  const FrontendInputFile &getCurrentInput() const {\n    return CurrentInput;\n  }\n\n  StringRef getCurrentFile() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getFile();\n  }\n\n  StringRef getCurrentFileOrBufferName() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.isFile()\n               ? CurrentInput.getFile()\n               : CurrentInput.getBuffer().getBufferIdentifier();\n  }\n\n  InputKind getCurrentFileKind() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getKind();\n  }\n\n  ASTUnit &getCurrentASTUnit() const {\n    assert(CurrentASTUnit && \"No current AST unit!\");\n    return *CurrentASTUnit;\n  }\n\n  Module *getCurrentModule() const;\n\n  std::unique_ptr<ASTUnit> takeCurrentASTUnit() {\n    return std::move(CurrentASTUnit);\n  }\n\n  void setCurrentInput(const FrontendInputFile &CurrentInput,\n                       std::unique_ptr<ASTUnit> AST = nullptr);\n\n  /// @}\n  /// @name Supported Modes\n  /// @{\n\n  /// Is this action invoked on a model file?\n  ///\n  /// Model files are incomplete translation units that relies on type\n  /// information from another translation unit. Check ParseModelFileAction for\n  /// details.\n  virtual bool isModelParsingAction() const { return false; }\n\n  /// Does this action only use the preprocessor?\n  ///\n  /// If so no AST context will be created and this action will be invalid\n  /// with AST file inputs.\n  virtual bool usesPreprocessorOnly() const = 0;\n\n  /// For AST-based actions, the kind of translation unit we're handling.\n  virtual TranslationUnitKind getTranslationUnitKind() { return TU_Complete; }\n\n  /// Does this action support use with PCH?\n  virtual bool hasPCHSupport() const { return true; }\n\n  /// Does this action support use with AST files?\n  virtual bool hasASTFileSupport() const { return true; }\n\n  /// Does this action support use with IR files?\n  virtual bool hasIRSupport() const { return false; }\n\n  /// Does this action support use with code completion?\n  virtual bool hasCodeCompletionSupport() const { return false; }\n\n  /// @}\n  /// @name Public Action Interface\n  /// @{\n\n  /// Prepare the action to execute on the given compiler instance.\n  bool PrepareToExecute(CompilerInstance &CI) {\n    return PrepareToExecuteAction(CI);\n  }\n\n  /// Prepare the action for processing the input file \\p Input.\n  ///\n  /// This is run after the options and frontend have been initialized,\n  /// but prior to executing any per-file processing.\n  ///\n  /// \\param CI - The compiler instance this action is being run from. The\n  /// action may store and use this object up until the matching EndSourceFile\n  /// action.\n  ///\n  /// \\param Input - The input filename and kind. Some input kinds are handled\n  /// specially, for example AST inputs, since the AST file itself contains\n  /// several objects which would normally be owned by the\n  /// CompilerInstance. When processing AST input files, these objects should\n  /// generally not be initialized in the CompilerInstance -- they will\n  /// automatically be shared with the AST file in between\n  /// BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\return True on success; on failure the compilation of this file should\n  /// be aborted and neither Execute() nor EndSourceFile() should be called.\n  bool BeginSourceFile(CompilerInstance &CI, const FrontendInputFile &Input);\n\n  /// Set the source manager's main input file, and run the action.\n  llvm::Error Execute();\n\n  /// Perform any per-file post processing, deallocate per-file\n  /// objects, and run statistics and output file cleanup code.\n  void EndSourceFile();\n\n  /// @}\n};\n\n/// Abstract base class to use for AST consumer-based frontend actions.\nclass ASTFrontendAction : public FrontendAction {\nprotected:\n  /// Implement the ExecuteAction interface by running Sema on\n  /// the already-initialized AST consumer.\n  ///\n  /// This will also take care of instantiating a code completion consumer if\n  /// the user requested it and the action supports it.\n  void ExecuteAction() override;\n\npublic:\n  ASTFrontendAction() {}\n  bool usesPreprocessorOnly() const override { return false; }\n};\n\nclass PluginASTAction : public ASTFrontendAction {\n  virtual void anchor();\npublic:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override = 0;\n\n  /// Parse the given plugin command line arguments.\n  ///\n  /// \\param CI - The compiler instance, for use in reporting diagnostics.\n  /// \\return True if the parsing succeeded; otherwise the plugin will be\n  /// destroyed and no action run. The plugin is responsible for using the\n  /// CompilerInstance's Diagnostic object to report errors.\n  virtual bool ParseArgs(const CompilerInstance &CI,\n                         const std::vector<std::string> &arg) = 0;\n\n  enum ActionType {\n    Cmdline,             ///< Action is determined by the cc1 command-line\n    ReplaceAction,       ///< Replace the main action\n    AddBeforeMainAction, ///< Execute the action before the main action\n    AddAfterMainAction   ///< Execute the action after the main action\n  };\n  /// Get the action type for this plugin\n  ///\n  /// \\return The action type. If the type is Cmdline then by default the\n  /// plugin does nothing and what it does is determined by the cc1\n  /// command-line.\n  virtual ActionType getActionType() { return Cmdline; }\n};\n\n/// Abstract base class to use for preprocessor-based frontend actions.\nclass PreprocessorFrontendAction : public FrontendAction {\nprotected:\n  /// Provide a default implementation which returns aborts;\n  /// this method should never be called by FrontendAction clients.\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\n/// A frontend action which simply wraps some other runtime-specified\n/// frontend action.\n///\n/// Deriving from this class allows an action to inject custom logic around\n/// some existing action's behavior. It implements every virtual method in\n/// the FrontendAction interface by forwarding to the wrapped action.\nclass WrapperFrontendAction : public FrontendAction {\n  std::unique_ptr<FrontendAction> WrappedAction;\n\nprotected:\n  bool PrepareToExecuteAction(CompilerInstance &CI) override;\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n  bool BeginInvocation(CompilerInstance &CI) override;\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n  void ExecuteAction() override;\n  void EndSourceFileAction() override;\n  bool shouldEraseOutputFiles() override;\n\npublic:\n  /// Construct a WrapperFrontendAction from an existing action, taking\n  /// ownership of it.\n  WrapperFrontendAction(std::unique_ptr<FrontendAction> WrappedAction);\n\n  bool usesPreprocessorOnly() const override;\n  TranslationUnitKind getTranslationUnitKind() override;\n  bool hasPCHSupport() const override;\n  bool hasASTFileSupport() const override;\n  bool hasIRSupport() const override;\n  bool hasCodeCompletionSupport() const override;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "content": "//===- FrontendOptions.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n#define LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Frontend/CommandLineSourceLoc.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\n} // namespace llvm\n\nnamespace clang {\n\nnamespace frontend {\n\nenum ActionKind {\n  /// Parse ASTs and list Decl nodes.\n  ASTDeclList,\n\n  /// Parse ASTs and dump them.\n  ASTDump,\n\n  /// Parse ASTs and print them.\n  ASTPrint,\n\n  /// Parse ASTs and view them in Graphviz.\n  ASTView,\n\n  /// Dump the compiler configuration.\n  DumpCompilerOptions,\n\n  /// Dump out raw tokens.\n  DumpRawTokens,\n\n  /// Dump out preprocessed tokens.\n  DumpTokens,\n\n  /// Emit a .s file.\n  EmitAssembly,\n\n  /// Emit a .bc file.\n  EmitBC,\n\n  /// Translate input source into HTML.\n  EmitHTML,\n\n  /// Emit a .ll file.\n  EmitLLVM,\n\n  /// Generate LLVM IR, but do not emit anything.\n  EmitLLVMOnly,\n\n  /// Generate machine code, but don't emit anything.\n  EmitCodeGenOnly,\n\n  /// Emit a .o file.\n  EmitObj,\n\n  /// Parse and apply any fixits to the source.\n  FixIt,\n\n  /// Generate pre-compiled module from a module map.\n  GenerateModule,\n\n  /// Generate pre-compiled module from a C++ module interface file.\n  GenerateModuleInterface,\n\n  /// Generate pre-compiled module from a set of header files.\n  GenerateHeaderModule,\n\n  /// Generate pre-compiled header.\n  GeneratePCH,\n\n  /// Generate Interface Stub Files.\n  GenerateInterfaceStubs,\n\n  /// Only execute frontend initialization.\n  InitOnly,\n\n  /// Dump information about a module file.\n  ModuleFileInfo,\n\n  /// Load and verify that a PCH file is usable.\n  VerifyPCH,\n\n  /// Parse and perform semantic analysis.\n  ParseSyntaxOnly,\n\n  /// Run a plugin action, \\see ActionName.\n  PluginAction,\n\n  /// Print the \"preamble\" of the input file\n  PrintPreamble,\n\n  /// -E mode.\n  PrintPreprocessedInput,\n\n  /// Expand macros but not \\#includes.\n  RewriteMacros,\n\n  /// ObjC->C Rewriter.\n  RewriteObjC,\n\n  /// Rewriter playground\n  RewriteTest,\n\n  /// Run one or more source code analyses.\n  RunAnalysis,\n\n  /// Dump template instantiations\n  TemplightDump,\n\n  /// Run migrator.\n  MigrateSource,\n\n  /// Just lex, no output.\n  RunPreprocessorOnly,\n\n  /// Print the output of the dependency directives source minimizer.\n  PrintDependencyDirectivesSourceMinimizerOutput\n};\n\n} // namespace frontend\n\n/// The kind of a file that we've been handed as an input.\nclass InputKind {\nprivate:\n  Language Lang;\n  unsigned Fmt : 3;\n  unsigned Preprocessed : 1;\n\npublic:\n  /// The input file format.\n  enum Format {\n    Source,\n    ModuleMap,\n    Precompiled\n  };\n\n  constexpr InputKind(Language L = Language::Unknown, Format F = Source,\n                      bool PP = false)\n      : Lang(L), Fmt(F), Preprocessed(PP) {}\n\n  Language getLanguage() const { return static_cast<Language>(Lang); }\n  Format getFormat() const { return static_cast<Format>(Fmt); }\n  bool isPreprocessed() const { return Preprocessed; }\n\n  /// Is the input kind fully-unknown?\n  bool isUnknown() const { return Lang == Language::Unknown && Fmt == Source; }\n\n  /// Is the language of the input some dialect of Objective-C?\n  bool isObjectiveC() const {\n    return Lang == Language::ObjC || Lang == Language::ObjCXX;\n  }\n\n  InputKind getPreprocessed() const {\n    return InputKind(getLanguage(), getFormat(), true);\n  }\n\n  InputKind withFormat(Format F) const {\n    return InputKind(getLanguage(), F, isPreprocessed());\n  }\n};\n\n/// An input file for the front end.\nclass FrontendInputFile {\n  /// The file name, or \"-\" to read from standard input.\n  std::string File;\n\n  /// The input, if it comes from a buffer rather than a file. This object\n  /// does not own the buffer, and the caller is responsible for ensuring\n  /// that it outlives any users.\n  llvm::Optional<llvm::MemoryBufferRef> Buffer;\n\n  /// The kind of input, e.g., C source, AST file, LLVM IR.\n  InputKind Kind;\n\n  /// Whether we're dealing with a 'system' input (vs. a 'user' input).\n  bool IsSystem = false;\n\npublic:\n  FrontendInputFile() = default;\n  FrontendInputFile(StringRef File, InputKind Kind, bool IsSystem = false)\n      : File(File.str()), Kind(Kind), IsSystem(IsSystem) {}\n  FrontendInputFile(llvm::MemoryBufferRef Buffer, InputKind Kind,\n                    bool IsSystem = false)\n      : Buffer(Buffer), Kind(Kind), IsSystem(IsSystem) {}\n\n  InputKind getKind() const { return Kind; }\n  bool isSystem() const { return IsSystem; }\n\n  bool isEmpty() const { return File.empty() && Buffer == None; }\n  bool isFile() const { return !isBuffer(); }\n  bool isBuffer() const { return Buffer != None; }\n  bool isPreprocessed() const { return Kind.isPreprocessed(); }\n\n  StringRef getFile() const {\n    assert(isFile());\n    return File;\n  }\n\n  llvm::MemoryBufferRef getBuffer() const {\n    assert(isBuffer());\n    return *Buffer;\n  }\n};\n\n/// FrontendOptions - Options for controlling the behavior of the frontend.\nclass FrontendOptions {\npublic:\n  /// Disable memory freeing on exit.\n  unsigned DisableFree : 1;\n\n  /// When generating PCH files, instruct the AST writer to create relocatable\n  /// PCH files.\n  unsigned RelocatablePCH : 1;\n\n  /// Show the -help text.\n  unsigned ShowHelp : 1;\n\n  /// Show frontend performance metrics and statistics.\n  unsigned ShowStats : 1;\n\n  /// print the supported cpus for the current target\n  unsigned PrintSupportedCPUs : 1;\n\n  /// Output time trace profile.\n  unsigned TimeTrace : 1;\n\n  /// Show the -version text.\n  unsigned ShowVersion : 1;\n\n  /// Apply fixes even if there are unfixable errors.\n  unsigned FixWhatYouCan : 1;\n\n  /// Apply fixes only for warnings.\n  unsigned FixOnlyWarnings : 1;\n\n  /// Apply fixes and recompile.\n  unsigned FixAndRecompile : 1;\n\n  /// Apply fixes to temporary files.\n  unsigned FixToTemporaries : 1;\n\n  /// Emit ARC errors even if the migrator can fix them.\n  unsigned ARCMTMigrateEmitARCErrors : 1;\n\n  /// Skip over function bodies to speed up parsing in cases you do not need\n  /// them (e.g. with code completion).\n  unsigned SkipFunctionBodies : 1;\n\n  /// Whether we can use the global module index if available.\n  unsigned UseGlobalModuleIndex : 1;\n\n  /// Whether we can generate the global module index if needed.\n  unsigned GenerateGlobalModuleIndex : 1;\n\n  /// Whether we include declaration dumps in AST dumps.\n  unsigned ASTDumpDecls : 1;\n\n  /// Whether we deserialize all decls when forming AST dumps.\n  unsigned ASTDumpAll : 1;\n\n  /// Whether we include lookup table dumps in AST dumps.\n  unsigned ASTDumpLookups : 1;\n\n  /// Whether we include declaration type dumps in AST dumps.\n  unsigned ASTDumpDeclTypes : 1;\n\n  /// Whether we are performing an implicit module build.\n  unsigned BuildingImplicitModule : 1;\n\n  /// Whether we should embed all used files into the PCM file.\n  unsigned ModulesEmbedAllFiles : 1;\n\n  /// Whether timestamps should be written to the produced PCH file.\n  unsigned IncludeTimestamps : 1;\n\n  /// Should a temporary file be used during compilation.\n  unsigned UseTemporary : 1;\n\n  /// When using -emit-module, treat the modulemap as a system module.\n  unsigned IsSystemModule : 1;\n\n  /// Output (and read) PCM files regardless of compiler errors.\n  unsigned AllowPCMWithCompilerErrors : 1;\n\n  CodeCompleteOptions CodeCompleteOpts;\n\n  /// Specifies the output format of the AST.\n  ASTDumpOutputFormat ASTDumpFormat = ADOF_Default;\n\n  enum {\n    ARCMT_None,\n    ARCMT_Check,\n    ARCMT_Modify,\n    ARCMT_Migrate\n  } ARCMTAction = ARCMT_None;\n\n  enum {\n    ObjCMT_None = 0,\n\n    /// Enable migration to modern ObjC literals.\n    ObjCMT_Literals = 0x1,\n\n    /// Enable migration to modern ObjC subscripting.\n    ObjCMT_Subscripting = 0x2,\n\n    /// Enable migration to modern ObjC readonly property.\n    ObjCMT_ReadonlyProperty = 0x4,\n\n    /// Enable migration to modern ObjC readwrite property.\n    ObjCMT_ReadwriteProperty = 0x8,\n\n    /// Enable migration to modern ObjC property.\n    ObjCMT_Property = (ObjCMT_ReadonlyProperty | ObjCMT_ReadwriteProperty),\n\n    /// Enable annotation of ObjCMethods of all kinds.\n    ObjCMT_Annotation = 0x10,\n\n    /// Enable migration of ObjC methods to 'instancetype'.\n    ObjCMT_Instancetype = 0x20,\n\n    /// Enable migration to NS_ENUM/NS_OPTIONS macros.\n    ObjCMT_NsMacros = 0x40,\n\n    /// Enable migration to add conforming protocols.\n    ObjCMT_ProtocolConformance = 0x80,\n\n    /// prefer 'atomic' property over 'nonatomic'.\n    ObjCMT_AtomicProperty = 0x100,\n\n    /// annotate property with NS_RETURNS_INNER_POINTER\n    ObjCMT_ReturnsInnerPointerProperty = 0x200,\n\n    /// use NS_NONATOMIC_IOSONLY for property 'atomic' attribute\n    ObjCMT_NsAtomicIOSOnlyProperty = 0x400,\n\n    /// Enable inferring NS_DESIGNATED_INITIALIZER for ObjC methods.\n    ObjCMT_DesignatedInitializer = 0x800,\n\n    /// Enable converting setter/getter expressions to property-dot syntx.\n    ObjCMT_PropertyDotSyntax = 0x1000,\n\n    ObjCMT_MigrateDecls = (ObjCMT_ReadonlyProperty | ObjCMT_ReadwriteProperty |\n                           ObjCMT_Annotation | ObjCMT_Instancetype |\n                           ObjCMT_NsMacros | ObjCMT_ProtocolConformance |\n                           ObjCMT_NsAtomicIOSOnlyProperty |\n                           ObjCMT_DesignatedInitializer),\n    ObjCMT_MigrateAll = (ObjCMT_Literals | ObjCMT_Subscripting |\n                         ObjCMT_MigrateDecls | ObjCMT_PropertyDotSyntax)\n  };\n  unsigned ObjCMTAction = ObjCMT_None;\n  std::string ObjCMTWhiteListPath;\n\n  std::string MTMigrateDir;\n  std::string ARCMTMigrateReportOut;\n\n  /// The input kind, either specified via -x argument or deduced from the input\n  /// file name.\n  InputKind DashX;\n\n  /// The input files and their types.\n  SmallVector<FrontendInputFile, 0> Inputs;\n\n  /// When the input is a module map, the original module map file from which\n  /// that map was inferred, if any (for umbrella modules).\n  std::string OriginalModuleMap;\n\n  /// The output file, if any.\n  std::string OutputFile;\n\n  /// If given, the new suffix for fix-it rewritten files.\n  std::string FixItSuffix;\n\n  /// If given, filter dumped AST Decl nodes by this substring.\n  std::string ASTDumpFilter;\n\n  /// If given, enable code completion at the provided location.\n  ParsedSourceLocation CodeCompletionAt;\n\n  /// The frontend action to perform.\n  frontend::ActionKind ProgramAction = frontend::ParseSyntaxOnly;\n\n  /// The name of the action to run when using a plugin action.\n  std::string ActionName;\n\n  /// Args to pass to the plugins\n  std::unordered_map<std::string,std::vector<std::string>> PluginArgs;\n\n  /// The list of plugin actions to run in addition to the normal action.\n  std::vector<std::string> AddPluginActions;\n\n  /// The list of plugins to load.\n  std::vector<std::string> Plugins;\n\n  /// The list of module file extensions.\n  std::vector<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// The list of module map files to load before processing the input.\n  std::vector<std::string> ModuleMapFiles;\n\n  /// The list of additional prebuilt module files to load before\n  /// processing the input.\n  std::vector<std::string> ModuleFiles;\n\n  /// The list of files to embed into the compiled module file.\n  std::vector<std::string> ModulesEmbedFiles;\n\n  /// The list of AST files to merge.\n  std::vector<std::string> ASTMergeFiles;\n\n  /// A list of arguments to forward to LLVM's option processing; this\n  /// should only be used for debugging and experimental features.\n  std::vector<std::string> LLVMArgs;\n\n  /// File name of the file that will provide record layouts\n  /// (in the format produced by -fdump-record-layouts).\n  std::string OverrideRecordLayoutsFile;\n\n  /// Auxiliary triple for CUDA/HIP compilation.\n  std::string AuxTriple;\n\n  /// Auxiliary target CPU for CUDA/HIP compilation.\n  Optional<std::string> AuxTargetCPU;\n\n  /// Auxiliary target features for CUDA/HIP compilation.\n  Optional<std::vector<std::string>> AuxTargetFeatures;\n\n  /// Filename to write statistics to.\n  std::string StatsFile;\n\n  /// Minimum time granularity (in microseconds) traced by time profiler.\n  unsigned TimeTraceGranularity;\n\npublic:\n  FrontendOptions()\n      : DisableFree(false), RelocatablePCH(false), ShowHelp(false),\n        ShowStats(false), TimeTrace(false), ShowVersion(false),\n        FixWhatYouCan(false), FixOnlyWarnings(false), FixAndRecompile(false),\n        FixToTemporaries(false), ARCMTMigrateEmitARCErrors(false),\n        SkipFunctionBodies(false), UseGlobalModuleIndex(true),\n        GenerateGlobalModuleIndex(true), ASTDumpDecls(false),\n        ASTDumpLookups(false), BuildingImplicitModule(false),\n        ModulesEmbedAllFiles(false), IncludeTimestamps(true),\n        UseTemporary(true), AllowPCMWithCompilerErrors(false),\n        TimeTraceGranularity(500) {}\n\n  /// getInputKindForExtension - Return the appropriate input kind for a file\n  /// extension. For example, \"c\" would return Language::C.\n  ///\n  /// \\return The input kind for the extension, or Language::Unknown if the\n  /// extension is not recognized.\n  static InputKind getInputKindForExtension(StringRef Extension);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/Utils.h", "content": "//===- Utils.h - Misc utilities for the front-end ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This header contains miscellaneous utilities for various front-end actions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_UTILS_H\n#define LLVM_CLANG_FRONTEND_UTILS_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Driver/OptionUtils.h\"\n#include \"clang/Frontend/DependencyOutputOptions.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Option/OptSpecifier.h\"\n#include \"llvm/Support/FileCollector.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass Triple;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTReader;\nclass CompilerInstance;\nclass CompilerInvocation;\nclass DiagnosticsEngine;\nclass ExternalSemaSource;\nclass FrontendOptions;\nclass HeaderSearch;\nclass HeaderSearchOptions;\nclass LangOptions;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nclass PreprocessorOutputOptions;\n\n/// Apply the header search options to get given HeaderSearch object.\nvoid ApplyHeaderSearchOptions(HeaderSearch &HS,\n                              const HeaderSearchOptions &HSOpts,\n                              const LangOptions &Lang,\n                              const llvm::Triple &triple);\n\n/// InitializePreprocessor - Initialize the preprocessor getting it and the\n/// environment ready to process a single file.\nvoid InitializePreprocessor(Preprocessor &PP, const PreprocessorOptions &PPOpts,\n                            const PCHContainerReader &PCHContainerRdr,\n                            const FrontendOptions &FEOpts);\n\n/// DoPrintPreprocessedInput - Implement -E mode.\nvoid DoPrintPreprocessedInput(Preprocessor &PP, raw_ostream *OS,\n                              const PreprocessorOutputOptions &Opts);\n\n/// An interface for collecting the dependencies of a compilation. Users should\n/// use \\c attachToPreprocessor and \\c attachToASTReader to get all of the\n/// dependencies.\n/// FIXME: Migrate DependencyGraphGen to use this interface.\nclass DependencyCollector {\npublic:\n  virtual ~DependencyCollector();\n\n  virtual void attachToPreprocessor(Preprocessor &PP);\n  virtual void attachToASTReader(ASTReader &R);\n  ArrayRef<std::string> getDependencies() const { return Dependencies; }\n\n  /// Called when a new file is seen. Return true if \\p Filename should be added\n  /// to the list of dependencies.\n  ///\n  /// The default implementation ignores <built-in> and system files.\n  virtual bool sawDependency(StringRef Filename, bool FromModule,\n                             bool IsSystem, bool IsModuleFile, bool IsMissing);\n\n  /// Called when the end of the main file is reached.\n  virtual void finishedMainFile(DiagnosticsEngine &Diags) {}\n\n  /// Return true if system files should be passed to sawDependency().\n  virtual bool needSystemDependencies() { return false; }\n\n  /// Add a dependency \\p Filename if it has not been seen before and\n  /// sawDependency() returns true.\n  virtual void maybeAddDependency(StringRef Filename, bool FromModule,\n                                  bool IsSystem, bool IsModuleFile,\n                                  bool IsMissing);\n\nprotected:\n  /// Return true if the filename was added to the list of dependencies, false\n  /// otherwise.\n  bool addDependency(StringRef Filename);\n\nprivate:\n  llvm::StringSet<> Seen;\n  std::vector<std::string> Dependencies;\n};\n\n/// Builds a dependency file when attached to a Preprocessor (for includes) and\n/// ASTReader (for module imports), and writes it out at the end of processing\n/// a source file.  Users should attach to the ast reader whenever a module is\n/// loaded.\nclass DependencyFileGenerator : public DependencyCollector {\npublic:\n  DependencyFileGenerator(const DependencyOutputOptions &Opts);\n\n  void attachToPreprocessor(Preprocessor &PP) override;\n\n  void finishedMainFile(DiagnosticsEngine &Diags) override;\n\n  bool needSystemDependencies() final override { return IncludeSystemHeaders; }\n\n  bool sawDependency(StringRef Filename, bool FromModule, bool IsSystem,\n                     bool IsModuleFile, bool IsMissing) final override;\n\nprotected:\n  void outputDependencyFile(llvm::raw_ostream &OS);\n\nprivate:\n  void outputDependencyFile(DiagnosticsEngine &Diags);\n\n  std::string OutputFile;\n  std::vector<std::string> Targets;\n  bool IncludeSystemHeaders;\n  bool PhonyTarget;\n  bool AddMissingHeaderDeps;\n  bool SeenMissingHeader;\n  bool IncludeModuleFiles;\n  DependencyOutputFormat OutputFormat;\n  unsigned InputFileIndex;\n};\n\n/// Collects the dependencies for imported modules into a directory.  Users\n/// should attach to the AST reader whenever a module is loaded.\nclass ModuleDependencyCollector : public DependencyCollector {\n  std::string DestDir;\n  bool HasErrors = false;\n  llvm::StringSet<> Seen;\n  llvm::vfs::YAMLVFSWriter VFSWriter;\n  llvm::FileCollector::PathCanonicalizer Canonicalizer;\n\n  std::error_code copyToRoot(StringRef Src, StringRef Dst = {});\n\npublic:\n  ModuleDependencyCollector(std::string DestDir)\n      : DestDir(std::move(DestDir)) {}\n  ~ModuleDependencyCollector() override { writeFileMap(); }\n\n  StringRef getDest() { return DestDir; }\n  virtual bool insertSeen(StringRef Filename) { return Seen.insert(Filename).second; }\n  virtual void addFile(StringRef Filename, StringRef FileDst = {});\n\n  virtual void addFileMapping(StringRef VPath, StringRef RPath) {\n    VFSWriter.addFileMapping(VPath, RPath);\n  }\n\n  void attachToPreprocessor(Preprocessor &PP) override;\n  void attachToASTReader(ASTReader &R) override;\n\n  virtual void writeFileMap();\n  virtual bool hasErrors() { return HasErrors; }\n};\n\n/// AttachDependencyGraphGen - Create a dependency graph generator, and attach\n/// it to the given preprocessor.\nvoid AttachDependencyGraphGen(Preprocessor &PP, StringRef OutputFile,\n                              StringRef SysRoot);\n\n/// AttachHeaderIncludeGen - Create a header include list generator, and attach\n/// it to the given preprocessor.\n///\n/// \\param DepOpts - Options controlling the output.\n/// \\param ShowAllHeaders - If true, show all header information instead of just\n/// headers following the predefines buffer. This is useful for making sure\n/// includes mentioned on the command line are also reported, but differs from\n/// the default behavior used by -H.\n/// \\param OutputPath - If non-empty, a path to write the header include\n/// information to, instead of writing to stderr.\n/// \\param ShowDepth - Whether to indent to show the nesting of the includes.\n/// \\param MSStyle - Whether to print in cl.exe /showIncludes style.\nvoid AttachHeaderIncludeGen(Preprocessor &PP,\n                            const DependencyOutputOptions &DepOpts,\n                            bool ShowAllHeaders = false,\n                            StringRef OutputPath = {},\n                            bool ShowDepth = true, bool MSStyle = false);\n\n/// The ChainedIncludesSource class converts headers to chained PCHs in\n/// memory, mainly for testing.\nIntrusiveRefCntPtr<ExternalSemaSource>\ncreateChainedIncludesSource(CompilerInstance &CI,\n                            IntrusiveRefCntPtr<ExternalSemaSource> &Reader);\n\n/// createInvocationFromCommandLine - Construct a compiler invocation object for\n/// a command line argument vector.\n///\n/// \\param ShouldRecoverOnErrors - whether we should attempt to return a\n/// non-null (and possibly incorrect) CompilerInvocation if any errors were\n/// encountered. When this flag is false, always return null on errors.\n///\n/// \\param CC1Args - if non-null, will be populated with the args to cc1\n/// expanded from \\p Args. May be set even if nullptr is returned.\n///\n/// \\return A CompilerInvocation, or nullptr if none was built for the given\n/// argument vector.\nstd::unique_ptr<CompilerInvocation> createInvocationFromCommandLine(\n    ArrayRef<const char *> Args,\n    IntrusiveRefCntPtr<DiagnosticsEngine> Diags =\n        IntrusiveRefCntPtr<DiagnosticsEngine>(),\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr,\n    bool ShouldRecoverOnErrors = false,\n    std::vector<std::string> *CC1Args = nullptr);\n\n// Frontend timing utils\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_UTILS_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Index/IndexSymbol.h", "content": "//===- IndexSymbol.h - Types and functions for indexing symbols -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_INDEX_INDEXSYMBOL_H\n#define LLVM_CLANG_INDEX_INDEXSYMBOL_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nnamespace clang {\n  class Decl;\n  class LangOptions;\n\nnamespace index {\n\nenum class SymbolKind : uint8_t {\n  Unknown,\n\n  Module,\n  Namespace,\n  NamespaceAlias,\n  Macro,\n\n  Enum,\n  Struct,\n  Class,\n  Protocol,\n  Extension,\n  Union,\n  TypeAlias,\n\n  Function,\n  Variable,\n  Field,\n  EnumConstant,\n\n  InstanceMethod,\n  ClassMethod,\n  StaticMethod,\n  InstanceProperty,\n  ClassProperty,\n  StaticProperty,\n\n  Constructor,\n  Destructor,\n  ConversionFunction,\n\n  Parameter,\n  Using,\n  TemplateTypeParm,\n  TemplateTemplateParm,\n  NonTypeTemplateParm,\n};\n\nenum class SymbolLanguage : uint8_t {\n  C,\n  ObjC,\n  CXX,\n  Swift,\n};\n\n/// Language specific sub-kinds.\nenum class SymbolSubKind : uint8_t {\n  None,\n  CXXCopyConstructor,\n  CXXMoveConstructor,\n  AccessorGetter,\n  AccessorSetter,\n  UsingTypename,\n  UsingValue,\n};\n\ntypedef uint16_t SymbolPropertySet;\n/// Set of properties that provide additional info about a symbol.\nenum class SymbolProperty : SymbolPropertySet {\n  Generic                       = 1 << 0,\n  TemplatePartialSpecialization = 1 << 1,\n  TemplateSpecialization        = 1 << 2,\n  UnitTest                      = 1 << 3,\n  IBAnnotated                   = 1 << 4,\n  IBOutletCollection            = 1 << 5,\n  GKInspectable                 = 1 << 6,\n  Local                         = 1 << 7,\n  /// Symbol is part of a protocol interface.\n  ProtocolInterface             = 1 << 8,\n};\nstatic const unsigned SymbolPropertyBitNum = 9;\n\n/// Set of roles that are attributed to symbol occurrences.\n///\n/// Low 9 bits of clang-c/include/Index.h CXSymbolRole mirrors this enum.\nenum class SymbolRole : uint32_t {\n  Declaration = 1 << 0,\n  Definition = 1 << 1,\n  Reference = 1 << 2,\n  Read = 1 << 3,\n  Write = 1 << 4,\n  Call = 1 << 5,\n  Dynamic = 1 << 6,\n  AddressOf = 1 << 7,\n  Implicit = 1 << 8,\n  // FIXME: this is not mirrored in CXSymbolRole.\n  // Note that macro occurrences aren't currently supported in libclang.\n  Undefinition = 1 << 9, // macro #undef\n\n  // Relation roles.\n  RelationChildOf = 1 << 10,\n  RelationBaseOf = 1 << 11,\n  RelationOverrideOf = 1 << 12,\n  RelationReceivedBy = 1 << 13,\n  RelationCalledBy = 1 << 14,\n  RelationExtendedBy = 1 << 15,\n  RelationAccessorOf = 1 << 16,\n  RelationContainedBy = 1 << 17,\n  RelationIBTypeOf = 1 << 18,\n  RelationSpecializationOf = 1 << 19,\n\n  // Symbol only references the name of the object as written. For example, a\n  // constructor references the class declaration using that role.\n  NameReference = 1 << 20,\n};\nstatic const unsigned SymbolRoleBitNum = 21;\ntypedef unsigned SymbolRoleSet;\n\n/// Represents a relation to another symbol for a symbol occurrence.\nstruct SymbolRelation {\n  SymbolRoleSet Roles;\n  const Decl *RelatedSymbol;\n\n  SymbolRelation(SymbolRoleSet Roles, const Decl *Sym)\n    : Roles(Roles), RelatedSymbol(Sym) {}\n};\n\nstruct SymbolInfo {\n  SymbolKind Kind;\n  SymbolSubKind SubKind;\n  SymbolLanguage Lang;\n  SymbolPropertySet Properties;\n};\n\nSymbolInfo getSymbolInfo(const Decl *D);\n\nSymbolInfo getSymbolInfoForMacro(const MacroInfo &MI);\n\nbool isFunctionLocalSymbol(const Decl *D);\n\nvoid applyForEachSymbolRole(SymbolRoleSet Roles,\n                            llvm::function_ref<void(SymbolRole)> Fn);\nbool applyForEachSymbolRoleInterruptible(SymbolRoleSet Roles,\n                            llvm::function_ref<bool(SymbolRole)> Fn);\nvoid printSymbolRoles(SymbolRoleSet Roles, raw_ostream &OS);\n\n/// \\returns true if no name was printed, false otherwise.\nbool printSymbolName(const Decl *D, const LangOptions &LO, raw_ostream &OS);\n\nStringRef getSymbolKindString(SymbolKind K);\nStringRef getSymbolSubKindString(SymbolSubKind K);\nStringRef getSymbolLanguageString(SymbolLanguage K);\n\nvoid applyForEachSymbolProperty(SymbolPropertySet Props,\n                            llvm::function_ref<void(SymbolProperty)> Fn);\nvoid printSymbolProperties(SymbolPropertySet Props, raw_ostream &OS);\n\n} // namespace index\n} // namespace clang\n\n#endif\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "content": "//===- MacroInfo.h - Information about #defined identifiers -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::MacroInfo and clang::MacroDirective classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MACROINFO_H\n#define LLVM_CLANG_LEX_MACROINFO_H\n\n#include \"clang/Lex/Token.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace clang {\n\nclass DefMacroDirective;\nclass IdentifierInfo;\nclass Module;\nclass Preprocessor;\nclass SourceManager;\n\n/// Encapsulates the data about a macro definition (e.g. its tokens).\n///\n/// There's an instance of this class for every #define.\nclass MacroInfo {\n  //===--------------------------------------------------------------------===//\n  // State set when the macro is defined.\n\n  /// The location the macro is defined.\n  SourceLocation Location;\n\n  /// The location of the last token in the macro.\n  SourceLocation EndLocation;\n\n  /// The list of arguments for a function-like macro.\n  ///\n  /// ParameterList points to the first of NumParameters pointers.\n  ///\n  /// This can be empty, for, e.g. \"#define X()\".  In a C99-style variadic\n  /// macro, this includes the \\c __VA_ARGS__ identifier on the list.\n  IdentifierInfo **ParameterList = nullptr;\n\n  /// \\see ParameterList\n  unsigned NumParameters = 0;\n\n  /// This is the list of tokens that the macro is defined to.\n  SmallVector<Token, 8> ReplacementTokens;\n\n  /// Length in characters of the macro definition.\n  mutable unsigned DefinitionLength;\n  mutable bool IsDefinitionLengthCached : 1;\n\n  /// True if this macro is function-like, false if it is object-like.\n  bool IsFunctionLike : 1;\n\n  /// True if this macro is of the form \"#define X(...)\" or\n  /// \"#define X(Y,Z,...)\".\n  ///\n  /// The __VA_ARGS__ token should be replaced with the contents of \"...\" in an\n  /// invocation.\n  bool IsC99Varargs : 1;\n\n  /// True if this macro is of the form \"#define X(a...)\".\n  ///\n  /// The \"a\" identifier in the replacement list will be replaced with all\n  /// arguments of the macro starting with the specified one.\n  bool IsGNUVarargs : 1;\n\n  /// True if this macro requires processing before expansion.\n  ///\n  /// This is the case for builtin macros such as __LINE__, so long as they have\n  /// not been redefined, but not for regular predefined macros from the\n  /// \"<built-in>\" memory buffer (see Preprocessing::getPredefinesFileID).\n  bool IsBuiltinMacro : 1;\n\n  /// Whether this macro contains the sequence \", ## __VA_ARGS__\"\n  bool HasCommaPasting : 1;\n\n  //===--------------------------------------------------------------------===//\n  // State that changes as the macro is used.\n\n  /// True if we have started an expansion of this macro already.\n  ///\n  /// This disables recursive expansion, which would be quite bad for things\n  /// like \\#define A A.\n  bool IsDisabled : 1;\n\n  /// True if this macro is either defined in the main file and has\n  /// been used, or if it is not defined in the main file.\n  ///\n  /// This is used to emit -Wunused-macros diagnostics.\n  bool IsUsed : 1;\n\n  /// True if this macro can be redefined without emitting a warning.\n  bool IsAllowRedefinitionsWithoutWarning : 1;\n\n  /// Must warn if the macro is unused at the end of translation unit.\n  bool IsWarnIfUnused : 1;\n\n  /// Whether this macro was used as header guard.\n  bool UsedForHeaderGuard : 1;\n\n  // Only the Preprocessor gets to create and destroy these.\n  MacroInfo(SourceLocation DefLoc);\n  ~MacroInfo() = default;\n\npublic:\n  /// Return the location that the macro was defined at.\n  SourceLocation getDefinitionLoc() const { return Location; }\n\n  /// Set the location of the last token in the macro.\n  void setDefinitionEndLoc(SourceLocation EndLoc) { EndLocation = EndLoc; }\n\n  /// Return the location of the last token in the macro.\n  SourceLocation getDefinitionEndLoc() const { return EndLocation; }\n\n  /// Get length in characters of the macro definition.\n  unsigned getDefinitionLength(const SourceManager &SM) const {\n    if (IsDefinitionLengthCached)\n      return DefinitionLength;\n    return getDefinitionLengthSlow(SM);\n  }\n\n  /// Return true if the specified macro definition is equal to\n  /// this macro in spelling, arguments, and whitespace.\n  ///\n  /// \\param Syntactically if true, the macro definitions can be identical even\n  /// if they use different identifiers for the function macro parameters.\n  /// Otherwise the comparison is lexical and this implements the rules in\n  /// C99 6.10.3.\n  bool isIdenticalTo(const MacroInfo &Other, Preprocessor &PP,\n                     bool Syntactically) const;\n\n  /// Set or clear the isBuiltinMacro flag.\n  void setIsBuiltinMacro(bool Val = true) { IsBuiltinMacro = Val; }\n\n  /// Set the value of the IsUsed flag.\n  void setIsUsed(bool Val) { IsUsed = Val; }\n\n  /// Set the value of the IsAllowRedefinitionsWithoutWarning flag.\n  void setIsAllowRedefinitionsWithoutWarning(bool Val) {\n    IsAllowRedefinitionsWithoutWarning = Val;\n  }\n\n  /// Set the value of the IsWarnIfUnused flag.\n  void setIsWarnIfUnused(bool val) { IsWarnIfUnused = val; }\n\n  /// Set the specified list of identifiers as the parameter list for\n  /// this macro.\n  void setParameterList(ArrayRef<IdentifierInfo *> List,\n                       llvm::BumpPtrAllocator &PPAllocator) {\n    assert(ParameterList == nullptr && NumParameters == 0 &&\n           \"Parameter list already set!\");\n    if (List.empty())\n      return;\n\n    NumParameters = List.size();\n    ParameterList = PPAllocator.Allocate<IdentifierInfo *>(List.size());\n    std::copy(List.begin(), List.end(), ParameterList);\n  }\n\n  /// Parameters - The list of parameters for a function-like macro.  This can\n  /// be empty, for, e.g. \"#define X()\".\n  using param_iterator = IdentifierInfo *const *;\n  bool param_empty() const { return NumParameters == 0; }\n  param_iterator param_begin() const { return ParameterList; }\n  param_iterator param_end() const { return ParameterList + NumParameters; }\n  unsigned getNumParams() const { return NumParameters; }\n  ArrayRef<const IdentifierInfo *> params() const {\n    return ArrayRef<const IdentifierInfo *>(ParameterList, NumParameters);\n  }\n\n  /// Return the parameter number of the specified identifier,\n  /// or -1 if the identifier is not a formal parameter identifier.\n  int getParameterNum(const IdentifierInfo *Arg) const {\n    for (param_iterator I = param_begin(), E = param_end(); I != E; ++I)\n      if (*I == Arg)\n        return I - param_begin();\n    return -1;\n  }\n\n  /// Function/Object-likeness.  Keep track of whether this macro has formal\n  /// parameters.\n  void setIsFunctionLike() { IsFunctionLike = true; }\n  bool isFunctionLike() const { return IsFunctionLike; }\n  bool isObjectLike() const { return !IsFunctionLike; }\n\n  /// Varargs querying methods.  This can only be set for function-like macros.\n  void setIsC99Varargs() { IsC99Varargs = true; }\n  void setIsGNUVarargs() { IsGNUVarargs = true; }\n  bool isC99Varargs() const { return IsC99Varargs; }\n  bool isGNUVarargs() const { return IsGNUVarargs; }\n  bool isVariadic() const { return IsC99Varargs | IsGNUVarargs; }\n\n  /// Return true if this macro requires processing before expansion.\n  ///\n  /// This is true only for builtin macro, such as \\__LINE__, whose values\n  /// are not given by fixed textual expansions.  Regular predefined macros\n  /// from the \"<built-in>\" buffer are not reported as builtins by this\n  /// function.\n  bool isBuiltinMacro() const { return IsBuiltinMacro; }\n\n  bool hasCommaPasting() const { return HasCommaPasting; }\n  void setHasCommaPasting() { HasCommaPasting = true; }\n\n  /// Return false if this macro is defined in the main file and has\n  /// not yet been used.\n  bool isUsed() const { return IsUsed; }\n\n  /// Return true if this macro can be redefined without warning.\n  bool isAllowRedefinitionsWithoutWarning() const {\n    return IsAllowRedefinitionsWithoutWarning;\n  }\n\n  /// Return true if we should emit a warning if the macro is unused.\n  bool isWarnIfUnused() const { return IsWarnIfUnused; }\n\n  /// Return the number of tokens that this macro expands to.\n  unsigned getNumTokens() const { return ReplacementTokens.size(); }\n\n  const Token &getReplacementToken(unsigned Tok) const {\n    assert(Tok < ReplacementTokens.size() && \"Invalid token #\");\n    return ReplacementTokens[Tok];\n  }\n\n  using tokens_iterator = SmallVectorImpl<Token>::const_iterator;\n\n  tokens_iterator tokens_begin() const { return ReplacementTokens.begin(); }\n  tokens_iterator tokens_end() const { return ReplacementTokens.end(); }\n  bool tokens_empty() const { return ReplacementTokens.empty(); }\n  ArrayRef<Token> tokens() const { return ReplacementTokens; }\n\n  /// Add the specified token to the replacement text for the macro.\n  void AddTokenToBody(const Token &Tok) {\n    assert(\n        !IsDefinitionLengthCached &&\n        \"Changing replacement tokens after definition length got calculated\");\n    ReplacementTokens.push_back(Tok);\n  }\n\n  /// Return true if this macro is enabled.\n  ///\n  /// In other words, that we are not currently in an expansion of this macro.\n  bool isEnabled() const { return !IsDisabled; }\n\n  void EnableMacro() {\n    assert(IsDisabled && \"Cannot enable an already-enabled macro!\");\n    IsDisabled = false;\n  }\n\n  void DisableMacro() {\n    assert(!IsDisabled && \"Cannot disable an already-disabled macro!\");\n    IsDisabled = true;\n  }\n\n  /// Determine whether this macro was used for a header guard.\n  bool isUsedForHeaderGuard() const { return UsedForHeaderGuard; }\n\n  void setUsedForHeaderGuard(bool Val) { UsedForHeaderGuard = Val; }\n\n  void dump() const;\n\nprivate:\n  friend class Preprocessor;\n\n  unsigned getDefinitionLengthSlow(const SourceManager &SM) const;\n};\n\n/// Encapsulates changes to the \"macros namespace\" (the location where\n/// the macro name became active, the location where it was undefined, etc.).\n///\n/// MacroDirectives, associated with an identifier, are used to model the macro\n/// history. Usually a macro definition (MacroInfo) is where a macro name\n/// becomes active (MacroDirective) but #pragma push_macro / pop_macro can\n/// create additional DefMacroDirectives for the same MacroInfo.\nclass MacroDirective {\npublic:\n  enum Kind {\n    MD_Define,\n    MD_Undefine,\n    MD_Visibility\n  };\n\nprotected:\n  /// Previous macro directive for the same identifier, or nullptr.\n  MacroDirective *Previous = nullptr;\n\n  SourceLocation Loc;\n\n  /// MacroDirective kind.\n  unsigned MDKind : 2;\n\n  /// True if the macro directive was loaded from a PCH file.\n  unsigned IsFromPCH : 1;\n\n  // Used by VisibilityMacroDirective ----------------------------------------//\n\n  /// Whether the macro has public visibility (when described in a\n  /// module).\n  unsigned IsPublic : 1;\n\n  MacroDirective(Kind K, SourceLocation Loc)\n      : Loc(Loc), MDKind(K), IsFromPCH(false), IsPublic(true) {}\n\npublic:\n  Kind getKind() const { return Kind(MDKind); }\n\n  SourceLocation getLocation() const { return Loc; }\n\n  /// Set previous definition of the macro with the same name.\n  void setPrevious(MacroDirective *Prev) { Previous = Prev; }\n\n  /// Get previous definition of the macro with the same name.\n  const MacroDirective *getPrevious() const { return Previous; }\n\n  /// Get previous definition of the macro with the same name.\n  MacroDirective *getPrevious() { return Previous; }\n\n  /// Return true if the macro directive was loaded from a PCH file.\n  bool isFromPCH() const { return IsFromPCH; }\n\n  void setIsFromPCH() { IsFromPCH = true; }\n\n  class DefInfo {\n    DefMacroDirective *DefDirective = nullptr;\n    SourceLocation UndefLoc;\n    bool IsPublic = true;\n\n  public:\n    DefInfo() = default;\n    DefInfo(DefMacroDirective *DefDirective, SourceLocation UndefLoc,\n            bool isPublic)\n        : DefDirective(DefDirective), UndefLoc(UndefLoc), IsPublic(isPublic) {}\n\n    const DefMacroDirective *getDirective() const { return DefDirective; }\n    DefMacroDirective *getDirective() { return DefDirective; }\n\n    inline SourceLocation getLocation() const;\n    inline MacroInfo *getMacroInfo();\n\n    const MacroInfo *getMacroInfo() const {\n      return const_cast<DefInfo *>(this)->getMacroInfo();\n    }\n\n    SourceLocation getUndefLocation() const { return UndefLoc; }\n    bool isUndefined() const { return UndefLoc.isValid(); }\n\n    bool isPublic() const { return IsPublic; }\n\n    bool isValid() const { return DefDirective != nullptr; }\n    bool isInvalid() const { return !isValid(); }\n\n    explicit operator bool() const { return isValid(); }\n\n    inline DefInfo getPreviousDefinition();\n\n    const DefInfo getPreviousDefinition() const {\n      return const_cast<DefInfo *>(this)->getPreviousDefinition();\n    }\n  };\n\n  /// Traverses the macro directives history and returns the next\n  /// macro definition directive along with info about its undefined location\n  /// (if there is one) and if it is public or private.\n  DefInfo getDefinition();\n  const DefInfo getDefinition() const {\n    return const_cast<MacroDirective *>(this)->getDefinition();\n  }\n\n  bool isDefined() const {\n    if (const DefInfo Def = getDefinition())\n      return !Def.isUndefined();\n    return false;\n  }\n\n  const MacroInfo *getMacroInfo() const {\n    return getDefinition().getMacroInfo();\n  }\n  MacroInfo *getMacroInfo() { return getDefinition().getMacroInfo(); }\n\n  /// Find macro definition active in the specified source location. If\n  /// this macro was not defined there, return NULL.\n  const DefInfo findDirectiveAtLoc(SourceLocation L,\n                                   const SourceManager &SM) const;\n\n  void dump() const;\n\n  static bool classof(const MacroDirective *) { return true; }\n};\n\n/// A directive for a defined macro or a macro imported from a module.\nclass DefMacroDirective : public MacroDirective {\n  MacroInfo *Info;\n\npublic:\n  DefMacroDirective(MacroInfo *MI, SourceLocation Loc)\n      : MacroDirective(MD_Define, Loc), Info(MI) {\n    assert(MI && \"MacroInfo is null\");\n  }\n  explicit DefMacroDirective(MacroInfo *MI)\n      : DefMacroDirective(MI, MI->getDefinitionLoc()) {}\n\n  /// The data for the macro definition.\n  const MacroInfo *getInfo() const { return Info; }\n  MacroInfo *getInfo() { return Info; }\n\n  static bool classof(const MacroDirective *MD) {\n    return MD->getKind() == MD_Define;\n  }\n\n  static bool classof(const DefMacroDirective *) { return true; }\n};\n\n/// A directive for an undefined macro.\nclass UndefMacroDirective : public MacroDirective {\npublic:\n  explicit UndefMacroDirective(SourceLocation UndefLoc)\n      : MacroDirective(MD_Undefine, UndefLoc) {\n    assert(UndefLoc.isValid() && \"Invalid UndefLoc!\");\n  }\n\n  static bool classof(const MacroDirective *MD) {\n    return MD->getKind() == MD_Undefine;\n  }\n\n  static bool classof(const UndefMacroDirective *) { return true; }\n};\n\n/// A directive for setting the module visibility of a macro.\nclass VisibilityMacroDirective : public MacroDirective {\npublic:\n  explicit VisibilityMacroDirective(SourceLocation Loc, bool Public)\n      : MacroDirective(MD_Visibility, Loc) {\n    IsPublic = Public;\n  }\n\n  /// Determine whether this macro is part of the public API of its\n  /// module.\n  bool isPublic() const { return IsPublic; }\n\n  static bool classof(const MacroDirective *MD) {\n    return MD->getKind() == MD_Visibility;\n  }\n\n  static bool classof(const VisibilityMacroDirective *) { return true; }\n};\n\ninline SourceLocation MacroDirective::DefInfo::getLocation() const {\n  if (isInvalid())\n    return {};\n  return DefDirective->getLocation();\n}\n\ninline MacroInfo *MacroDirective::DefInfo::getMacroInfo() {\n  if (isInvalid())\n    return nullptr;\n  return DefDirective->getInfo();\n}\n\ninline MacroDirective::DefInfo\nMacroDirective::DefInfo::getPreviousDefinition() {\n  if (isInvalid() || DefDirective->getPrevious() == nullptr)\n    return {};\n  return DefDirective->getPrevious()->getDefinition();\n}\n\n/// Represents a macro directive exported by a module.\n///\n/// There's an instance of this class for every macro #define or #undef that is\n/// the final directive for a macro name within a module. These entities also\n/// represent the macro override graph.\n///\n/// These are stored in a FoldingSet in the preprocessor.\nclass ModuleMacro : public llvm::FoldingSetNode {\n  friend class Preprocessor;\n\n  /// The name defined by the macro.\n  IdentifierInfo *II;\n\n  /// The body of the #define, or nullptr if this is a #undef.\n  MacroInfo *Macro;\n\n  /// The module that exports this macro.\n  Module *OwningModule;\n\n  /// The number of module macros that override this one.\n  unsigned NumOverriddenBy = 0;\n\n  /// The number of modules whose macros are directly overridden by this one.\n  unsigned NumOverrides;\n\n  ModuleMacro(Module *OwningModule, IdentifierInfo *II, MacroInfo *Macro,\n              ArrayRef<ModuleMacro *> Overrides)\n      : II(II), Macro(Macro), OwningModule(OwningModule),\n        NumOverrides(Overrides.size()) {\n    std::copy(Overrides.begin(), Overrides.end(),\n              reinterpret_cast<ModuleMacro **>(this + 1));\n  }\n\npublic:\n  static ModuleMacro *create(Preprocessor &PP, Module *OwningModule,\n                             IdentifierInfo *II, MacroInfo *Macro,\n                             ArrayRef<ModuleMacro *> Overrides);\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    return Profile(ID, OwningModule, II);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Module *OwningModule,\n                      IdentifierInfo *II) {\n    ID.AddPointer(OwningModule);\n    ID.AddPointer(II);\n  }\n\n  /// Get the name of the macro.\n  IdentifierInfo *getName() const { return II; }\n\n  /// Get the ID of the module that exports this macro.\n  Module *getOwningModule() const { return OwningModule; }\n\n  /// Get definition for this exported #define, or nullptr if this\n  /// represents a #undef.\n  MacroInfo *getMacroInfo() const { return Macro; }\n\n  /// Iterators over the overridden module IDs.\n  /// \\{\n  using overrides_iterator = ModuleMacro *const *;\n\n  overrides_iterator overrides_begin() const {\n    return reinterpret_cast<overrides_iterator>(this + 1);\n  }\n\n  overrides_iterator overrides_end() const {\n    return overrides_begin() + NumOverrides;\n  }\n\n  ArrayRef<ModuleMacro *> overrides() const {\n    return llvm::makeArrayRef(overrides_begin(), overrides_end());\n  }\n  /// \\}\n\n  /// Get the number of macros that override this one.\n  unsigned getNumOverridingMacros() const { return NumOverriddenBy; }\n};\n\n/// A description of the current definition of a macro.\n///\n/// The definition of a macro comprises a set of (at least one) defining\n/// entities, which are either local MacroDirectives or imported ModuleMacros.\nclass MacroDefinition {\n  llvm::PointerIntPair<DefMacroDirective *, 1, bool> LatestLocalAndAmbiguous;\n  ArrayRef<ModuleMacro *> ModuleMacros;\n\npublic:\n  MacroDefinition() = default;\n  MacroDefinition(DefMacroDirective *MD, ArrayRef<ModuleMacro *> MMs,\n                  bool IsAmbiguous)\n      : LatestLocalAndAmbiguous(MD, IsAmbiguous), ModuleMacros(MMs) {}\n\n  /// Determine whether there is a definition of this macro.\n  explicit operator bool() const {\n    return getLocalDirective() || !ModuleMacros.empty();\n  }\n\n  /// Get the MacroInfo that should be used for this definition.\n  MacroInfo *getMacroInfo() const {\n    if (!ModuleMacros.empty())\n      return ModuleMacros.back()->getMacroInfo();\n    if (auto *MD = getLocalDirective())\n      return MD->getMacroInfo();\n    return nullptr;\n  }\n\n  /// \\c true if the definition is ambiguous, \\c false otherwise.\n  bool isAmbiguous() const { return LatestLocalAndAmbiguous.getInt(); }\n\n  /// Get the latest non-imported, non-\\#undef'd macro definition\n  /// for this macro.\n  DefMacroDirective *getLocalDirective() const {\n    return LatestLocalAndAmbiguous.getPointer();\n  }\n\n  /// Get the active module macros for this macro.\n  ArrayRef<ModuleMacro *> getModuleMacros() const { return ModuleMacros; }\n\n  template <typename Fn> void forAllDefinitions(Fn F) const {\n    if (auto *MD = getLocalDirective())\n      F(MD->getMacroInfo());\n    for (auto *MM : getModuleMacros())\n      F(MM->getMacroInfo());\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MACROINFO_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PPCallbacks.h", "content": "//===--- PPCallbacks.h - Callbacks for Preprocessor actions -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the PPCallbacks interface.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PPCALLBACKS_H\n#define LLVM_CLANG_LEX_PPCALLBACKS_H\n\n#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/Pragma.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace clang {\n  class Token;\n  class IdentifierInfo;\n  class MacroDefinition;\n  class MacroDirective;\n  class MacroArgs;\n\n/// This interface provides a way to observe the actions of the\n/// preprocessor as it does its thing.\n///\n/// Clients can define their hooks here to implement preprocessor level tools.\nclass PPCallbacks {\npublic:\n  virtual ~PPCallbacks();\n\n  enum FileChangeReason {\n    EnterFile, ExitFile, SystemHeaderPragma, RenameFile\n  };\n\n  /// Callback invoked whenever a source file is entered or exited.\n  ///\n  /// \\param Loc Indicates the new location.\n  /// \\param PrevFID the file that was exited if \\p Reason is ExitFile.\n  virtual void FileChanged(SourceLocation Loc, FileChangeReason Reason,\n                           SrcMgr::CharacteristicKind FileType,\n                           FileID PrevFID = FileID()) {\n  }\n\n  /// Callback invoked whenever a source file is skipped as the result\n  /// of header guard optimization.\n  ///\n  /// \\param SkippedFile The file that is skipped instead of entering \\#include\n  ///\n  /// \\param FilenameTok The file name token in \\#include \"FileName\" directive\n  /// or macro expanded file name token from \\#include MACRO(PARAMS) directive.\n  /// Note that FilenameTok contains corresponding quotes/angles symbols.\n  virtual void FileSkipped(const FileEntryRef &SkippedFile,\n                           const Token &FilenameTok,\n                           SrcMgr::CharacteristicKind FileType) {}\n\n  /// Callback invoked whenever an inclusion directive results in a\n  /// file-not-found error.\n  ///\n  /// \\param FileName The name of the file being included, as written in the\n  /// source code.\n  ///\n  /// \\param RecoveryPath If this client indicates that it can recover from\n  /// this missing file, the client should set this as an additional header\n  /// search patch.\n  ///\n  /// \\returns true to indicate that the preprocessor should attempt to recover\n  /// by adding \\p RecoveryPath as a header search path.\n  virtual bool FileNotFound(StringRef FileName,\n                            SmallVectorImpl<char> &RecoveryPath) {\n    return false;\n  }\n\n  /// Callback invoked whenever an inclusion directive of\n  /// any kind (\\c \\#include, \\c \\#import, etc.) has been processed, regardless\n  /// of whether the inclusion will actually result in an inclusion.\n  ///\n  /// \\param HashLoc The location of the '#' that starts the inclusion\n  /// directive.\n  ///\n  /// \\param IncludeTok The token that indicates the kind of inclusion\n  /// directive, e.g., 'include' or 'import'.\n  ///\n  /// \\param FileName The name of the file being included, as written in the\n  /// source code.\n  ///\n  /// \\param IsAngled Whether the file name was enclosed in angle brackets;\n  /// otherwise, it was enclosed in quotes.\n  ///\n  /// \\param FilenameRange The character range of the quotes or angle brackets\n  /// for the written file name.\n  ///\n  /// \\param File The actual file that may be included by this inclusion\n  /// directive.\n  ///\n  /// \\param SearchPath Contains the search path which was used to find the file\n  /// in the file system. If the file was found via an absolute include path,\n  /// SearchPath will be empty. For framework includes, the SearchPath and\n  /// RelativePath will be split up. For example, if an include of \"Some/Some.h\"\n  /// is found via the framework path\n  /// \"path/to/Frameworks/Some.framework/Headers/Some.h\", SearchPath will be\n  /// \"path/to/Frameworks/Some.framework/Headers\" and RelativePath will be\n  /// \"Some.h\".\n  ///\n  /// \\param RelativePath The path relative to SearchPath, at which the include\n  /// file was found. This is equal to FileName except for framework includes.\n  ///\n  /// \\param Imported The module, whenever an inclusion directive was\n  /// automatically turned into a module import or null otherwise.\n  ///\n  /// \\param FileType The characteristic kind, indicates whether a file or\n  /// directory holds normal user code, system code, or system code which is\n  /// implicitly 'extern \"C\"' in C++ mode.\n  ///\n  virtual void InclusionDirective(SourceLocation HashLoc,\n                                  const Token &IncludeTok,\n                                  StringRef FileName,\n                                  bool IsAngled,\n                                  CharSourceRange FilenameRange,\n                                  const FileEntry *File,\n                                  StringRef SearchPath,\n                                  StringRef RelativePath,\n                                  const Module *Imported,\n                                  SrcMgr::CharacteristicKind FileType) {\n  }\n\n  /// Callback invoked whenever a submodule was entered.\n  ///\n  /// \\param M The submodule we have entered.\n  ///\n  /// \\param ImportLoc The location of import directive token.\n  ///\n  /// \\param ForPragma If entering from pragma directive.\n  ///\n  virtual void EnteredSubmodule(Module *M, SourceLocation ImportLoc,\n                                bool ForPragma) { }\n\n  /// Callback invoked whenever a submodule was left.\n  ///\n  /// \\param M The submodule we have left.\n  ///\n  /// \\param ImportLoc The location of import directive token.\n  ///\n  /// \\param ForPragma If entering from pragma directive.\n  ///\n  virtual void LeftSubmodule(Module *M, SourceLocation ImportLoc,\n                             bool ForPragma) { }\n\n  /// Callback invoked whenever there was an explicit module-import\n  /// syntax.\n  ///\n  /// \\param ImportLoc The location of import directive token.\n  ///\n  /// \\param Path The identifiers (and their locations) of the module\n  /// \"path\", e.g., \"std.vector\" would be split into \"std\" and \"vector\".\n  ///\n  /// \\param Imported The imported module; can be null if importing failed.\n  ///\n  virtual void moduleImport(SourceLocation ImportLoc,\n                            ModuleIdPath Path,\n                            const Module *Imported) {\n  }\n\n  /// Callback invoked when the end of the main file is reached.\n  ///\n  /// No subsequent callbacks will be made.\n  virtual void EndOfMainFile() {\n  }\n\n  /// Callback invoked when a \\#ident or \\#sccs directive is read.\n  /// \\param Loc The location of the directive.\n  /// \\param str The text of the directive.\n  ///\n  virtual void Ident(SourceLocation Loc, StringRef str) {\n  }\n\n  /// Callback invoked when start reading any pragma directive.\n  virtual void PragmaDirective(SourceLocation Loc,\n                               PragmaIntroducerKind Introducer) {\n  }\n\n  /// Callback invoked when a \\#pragma comment directive is read.\n  virtual void PragmaComment(SourceLocation Loc, const IdentifierInfo *Kind,\n                             StringRef Str) {\n  }\n\n  /// Callback invoked when a \\#pragma detect_mismatch directive is\n  /// read.\n  virtual void PragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                                    StringRef Value) {\n  }\n\n  /// Callback invoked when a \\#pragma clang __debug directive is read.\n  /// \\param Loc The location of the debug directive.\n  /// \\param DebugType The identifier following __debug.\n  virtual void PragmaDebug(SourceLocation Loc, StringRef DebugType) {\n  }\n\n  /// Determines the kind of \\#pragma invoking a call to PragmaMessage.\n  enum PragmaMessageKind {\n    /// \\#pragma message has been invoked.\n    PMK_Message,\n\n    /// \\#pragma GCC warning has been invoked.\n    PMK_Warning,\n\n    /// \\#pragma GCC error has been invoked.\n    PMK_Error\n  };\n\n  /// Callback invoked when a \\#pragma message directive is read.\n  /// \\param Loc The location of the message directive.\n  /// \\param Namespace The namespace of the message directive.\n  /// \\param Kind The type of the message directive.\n  /// \\param Str The text of the message directive.\n  virtual void PragmaMessage(SourceLocation Loc, StringRef Namespace,\n                             PragmaMessageKind Kind, StringRef Str) {\n  }\n\n  /// Callback invoked when a \\#pragma gcc diagnostic push directive\n  /// is read.\n  virtual void PragmaDiagnosticPush(SourceLocation Loc,\n                                    StringRef Namespace) {\n  }\n\n  /// Callback invoked when a \\#pragma gcc diagnostic pop directive\n  /// is read.\n  virtual void PragmaDiagnosticPop(SourceLocation Loc,\n                                   StringRef Namespace) {\n  }\n\n  /// Callback invoked when a \\#pragma gcc diagnostic directive is read.\n  virtual void PragmaDiagnostic(SourceLocation Loc, StringRef Namespace,\n                                diag::Severity mapping, StringRef Str) {}\n\n  /// Called when an OpenCL extension is either disabled or\n  /// enabled with a pragma.\n  virtual void PragmaOpenCLExtension(SourceLocation NameLoc,\n                                     const IdentifierInfo *Name,\n                                     SourceLocation StateLoc, unsigned State) {\n  }\n\n  /// Callback invoked when a \\#pragma warning directive is read.\n  virtual void PragmaWarning(SourceLocation Loc, StringRef WarningSpec,\n                             ArrayRef<int> Ids) {\n  }\n\n  /// Callback invoked when a \\#pragma warning(push) directive is read.\n  virtual void PragmaWarningPush(SourceLocation Loc, int Level) {\n  }\n\n  /// Callback invoked when a \\#pragma warning(pop) directive is read.\n  virtual void PragmaWarningPop(SourceLocation Loc) {\n  }\n\n  /// Callback invoked when a \\#pragma execution_character_set(push) directive\n  /// is read.\n  virtual void PragmaExecCharsetPush(SourceLocation Loc, StringRef Str) {}\n\n  /// Callback invoked when a \\#pragma execution_character_set(pop) directive\n  /// is read.\n  virtual void PragmaExecCharsetPop(SourceLocation Loc) {}\n\n  /// Callback invoked when a \\#pragma clang assume_nonnull begin directive\n  /// is read.\n  virtual void PragmaAssumeNonNullBegin(SourceLocation Loc) {}\n\n  /// Callback invoked when a \\#pragma clang assume_nonnull end directive\n  /// is read.\n  virtual void PragmaAssumeNonNullEnd(SourceLocation Loc) {}\n\n  /// Called by Preprocessor::HandleMacroExpandedIdentifier when a\n  /// macro invocation is found.\n  virtual void MacroExpands(const Token &MacroNameTok,\n                            const MacroDefinition &MD, SourceRange Range,\n                            const MacroArgs *Args) {}\n\n  /// Hook called whenever a macro definition is seen.\n  virtual void MacroDefined(const Token &MacroNameTok,\n                            const MacroDirective *MD) {\n  }\n\n  /// Hook called whenever a macro \\#undef is seen.\n  /// \\param MacroNameTok The active Token\n  /// \\param MD A MacroDefinition for the named macro.\n  /// \\param Undef New MacroDirective if the macro was defined, null otherwise.\n  ///\n  /// MD is released immediately following this callback.\n  virtual void MacroUndefined(const Token &MacroNameTok,\n                              const MacroDefinition &MD,\n                              const MacroDirective *Undef) {\n  }\n\n  /// Hook called whenever the 'defined' operator is seen.\n  /// \\param MD The MacroDirective if the name was a macro, null otherwise.\n  virtual void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n                       SourceRange Range) {\n  }\n\n  /// Hook called when a '__has_include' or '__has_include_next' directive is\n  /// read.\n  virtual void HasInclude(SourceLocation Loc, StringRef FileName, bool IsAngled,\n                          Optional<FileEntryRef> File,\n                          SrcMgr::CharacteristicKind FileType);\n\n  /// Hook called when a source range is skipped.\n  /// \\param Range The SourceRange that was skipped. The range begins at the\n  /// \\#if/\\#else directive and ends after the \\#endif/\\#else directive.\n  /// \\param EndifLoc The end location of the 'endif' token, which may precede\n  /// the range skipped by the directive (e.g excluding comments after an\n  /// 'endif').\n  virtual void SourceRangeSkipped(SourceRange Range, SourceLocation EndifLoc) {\n  }\n\n  enum ConditionValueKind {\n    CVK_NotEvaluated, CVK_False, CVK_True\n  };\n\n  /// Hook called whenever an \\#if is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param ConditionRange The SourceRange of the expression being tested.\n  /// \\param ConditionValue The evaluated value of the condition.\n  ///\n  // FIXME: better to pass in a list (or tree!) of Tokens.\n  virtual void If(SourceLocation Loc, SourceRange ConditionRange,\n                  ConditionValueKind ConditionValue) {\n  }\n\n  /// Hook called whenever an \\#elif is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param ConditionRange The SourceRange of the expression being tested.\n  /// \\param ConditionValue The evaluated value of the condition.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  // FIXME: better to pass in a list (or tree!) of Tokens.\n  virtual void Elif(SourceLocation Loc, SourceRange ConditionRange,\n                    ConditionValueKind ConditionValue, SourceLocation IfLoc) {\n  }\n\n  /// Hook called whenever an \\#ifdef is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param MacroNameTok Information on the token being tested.\n  /// \\param MD The MacroDefinition if the name was a macro, null otherwise.\n  virtual void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n                     const MacroDefinition &MD) {\n  }\n\n  /// Hook called whenever an \\#ifndef is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param MacroNameTok Information on the token being tested.\n  /// \\param MD The MacroDefiniton if the name was a macro, null otherwise.\n  virtual void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n                      const MacroDefinition &MD) {\n  }\n\n  /// Hook called whenever an \\#else is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  virtual void Else(SourceLocation Loc, SourceLocation IfLoc) {\n  }\n\n  /// Hook called whenever an \\#endif is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  virtual void Endif(SourceLocation Loc, SourceLocation IfLoc) {\n  }\n};\n\n/// Simple wrapper class for chaining callbacks.\nclass PPChainedCallbacks : public PPCallbacks {\n  std::unique_ptr<PPCallbacks> First, Second;\n\npublic:\n  PPChainedCallbacks(std::unique_ptr<PPCallbacks> _First,\n                     std::unique_ptr<PPCallbacks> _Second)\n    : First(std::move(_First)), Second(std::move(_Second)) {}\n\n  ~PPChainedCallbacks() override;\n\n  void FileChanged(SourceLocation Loc, FileChangeReason Reason,\n                   SrcMgr::CharacteristicKind FileType,\n                   FileID PrevFID) override {\n    First->FileChanged(Loc, Reason, FileType, PrevFID);\n    Second->FileChanged(Loc, Reason, FileType, PrevFID);\n  }\n\n  void FileSkipped(const FileEntryRef &SkippedFile, const Token &FilenameTok,\n                   SrcMgr::CharacteristicKind FileType) override {\n    First->FileSkipped(SkippedFile, FilenameTok, FileType);\n    Second->FileSkipped(SkippedFile, FilenameTok, FileType);\n  }\n\n  bool FileNotFound(StringRef FileName,\n                    SmallVectorImpl<char> &RecoveryPath) override {\n    return First->FileNotFound(FileName, RecoveryPath) ||\n           Second->FileNotFound(FileName, RecoveryPath);\n  }\n\n  void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,\n                          StringRef FileName, bool IsAngled,\n                          CharSourceRange FilenameRange, const FileEntry *File,\n                          StringRef SearchPath, StringRef RelativePath,\n                          const Module *Imported,\n                          SrcMgr::CharacteristicKind FileType) override {\n    First->InclusionDirective(HashLoc, IncludeTok, FileName, IsAngled,\n                              FilenameRange, File, SearchPath, RelativePath,\n                              Imported, FileType);\n    Second->InclusionDirective(HashLoc, IncludeTok, FileName, IsAngled,\n                               FilenameRange, File, SearchPath, RelativePath,\n                               Imported, FileType);\n  }\n\n  void EnteredSubmodule(Module *M, SourceLocation ImportLoc,\n                        bool ForPragma) override {\n    First->EnteredSubmodule(M, ImportLoc, ForPragma);\n    Second->EnteredSubmodule(M, ImportLoc, ForPragma);\n  }\n\n  void LeftSubmodule(Module *M, SourceLocation ImportLoc,\n                     bool ForPragma) override {\n    First->LeftSubmodule(M, ImportLoc, ForPragma);\n    Second->LeftSubmodule(M, ImportLoc, ForPragma);\n  }\n\n  void moduleImport(SourceLocation ImportLoc, ModuleIdPath Path,\n                    const Module *Imported) override {\n    First->moduleImport(ImportLoc, Path, Imported);\n    Second->moduleImport(ImportLoc, Path, Imported);\n  }\n\n  void EndOfMainFile() override {\n    First->EndOfMainFile();\n    Second->EndOfMainFile();\n  }\n\n  void Ident(SourceLocation Loc, StringRef str) override {\n    First->Ident(Loc, str);\n    Second->Ident(Loc, str);\n  }\n\n  void PragmaDirective(SourceLocation Loc,\n                       PragmaIntroducerKind Introducer) override {\n    First->PragmaDirective(Loc, Introducer);\n    Second->PragmaDirective(Loc, Introducer);\n  }\n\n  void PragmaComment(SourceLocation Loc, const IdentifierInfo *Kind,\n                     StringRef Str) override {\n    First->PragmaComment(Loc, Kind, Str);\n    Second->PragmaComment(Loc, Kind, Str);\n  }\n\n  void PragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                            StringRef Value) override {\n    First->PragmaDetectMismatch(Loc, Name, Value);\n    Second->PragmaDetectMismatch(Loc, Name, Value);\n  }\n\n  void PragmaDebug(SourceLocation Loc, StringRef DebugType) override {\n    First->PragmaDebug(Loc, DebugType);\n    Second->PragmaDebug(Loc, DebugType);\n  }\n\n  void PragmaMessage(SourceLocation Loc, StringRef Namespace,\n                     PragmaMessageKind Kind, StringRef Str) override {\n    First->PragmaMessage(Loc, Namespace, Kind, Str);\n    Second->PragmaMessage(Loc, Namespace, Kind, Str);\n  }\n\n  void PragmaDiagnosticPush(SourceLocation Loc, StringRef Namespace) override {\n    First->PragmaDiagnosticPush(Loc, Namespace);\n    Second->PragmaDiagnosticPush(Loc, Namespace);\n  }\n\n  void PragmaDiagnosticPop(SourceLocation Loc, StringRef Namespace) override {\n    First->PragmaDiagnosticPop(Loc, Namespace);\n    Second->PragmaDiagnosticPop(Loc, Namespace);\n  }\n\n  void PragmaDiagnostic(SourceLocation Loc, StringRef Namespace,\n                        diag::Severity mapping, StringRef Str) override {\n    First->PragmaDiagnostic(Loc, Namespace, mapping, Str);\n    Second->PragmaDiagnostic(Loc, Namespace, mapping, Str);\n  }\n\n  void HasInclude(SourceLocation Loc, StringRef FileName, bool IsAngled,\n                  Optional<FileEntryRef> File,\n                  SrcMgr::CharacteristicKind FileType) override;\n\n  void PragmaOpenCLExtension(SourceLocation NameLoc, const IdentifierInfo *Name,\n                             SourceLocation StateLoc, unsigned State) override {\n    First->PragmaOpenCLExtension(NameLoc, Name, StateLoc, State);\n    Second->PragmaOpenCLExtension(NameLoc, Name, StateLoc, State);\n  }\n\n  void PragmaWarning(SourceLocation Loc, StringRef WarningSpec,\n                     ArrayRef<int> Ids) override {\n    First->PragmaWarning(Loc, WarningSpec, Ids);\n    Second->PragmaWarning(Loc, WarningSpec, Ids);\n  }\n\n  void PragmaWarningPush(SourceLocation Loc, int Level) override {\n    First->PragmaWarningPush(Loc, Level);\n    Second->PragmaWarningPush(Loc, Level);\n  }\n\n  void PragmaWarningPop(SourceLocation Loc) override {\n    First->PragmaWarningPop(Loc);\n    Second->PragmaWarningPop(Loc);\n  }\n\n  void PragmaExecCharsetPush(SourceLocation Loc, StringRef Str) override {\n    First->PragmaExecCharsetPush(Loc, Str);\n    Second->PragmaExecCharsetPush(Loc, Str);\n  }\n\n  void PragmaExecCharsetPop(SourceLocation Loc) override {\n    First->PragmaExecCharsetPop(Loc);\n    Second->PragmaExecCharsetPop(Loc);\n  }\n\n  void PragmaAssumeNonNullBegin(SourceLocation Loc) override {\n    First->PragmaAssumeNonNullBegin(Loc);\n    Second->PragmaAssumeNonNullBegin(Loc);\n  }\n\n  void PragmaAssumeNonNullEnd(SourceLocation Loc) override {\n    First->PragmaAssumeNonNullEnd(Loc);\n    Second->PragmaAssumeNonNullEnd(Loc);\n  }\n\n  void MacroExpands(const Token &MacroNameTok, const MacroDefinition &MD,\n                    SourceRange Range, const MacroArgs *Args) override {\n    First->MacroExpands(MacroNameTok, MD, Range, Args);\n    Second->MacroExpands(MacroNameTok, MD, Range, Args);\n  }\n\n  void MacroDefined(const Token &MacroNameTok,\n                    const MacroDirective *MD) override {\n    First->MacroDefined(MacroNameTok, MD);\n    Second->MacroDefined(MacroNameTok, MD);\n  }\n\n  void MacroUndefined(const Token &MacroNameTok,\n                      const MacroDefinition &MD,\n                      const MacroDirective *Undef) override {\n    First->MacroUndefined(MacroNameTok, MD, Undef);\n    Second->MacroUndefined(MacroNameTok, MD, Undef);\n  }\n\n  void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n               SourceRange Range) override {\n    First->Defined(MacroNameTok, MD, Range);\n    Second->Defined(MacroNameTok, MD, Range);\n  }\n\n  void SourceRangeSkipped(SourceRange Range, SourceLocation EndifLoc) override {\n    First->SourceRangeSkipped(Range, EndifLoc);\n    Second->SourceRangeSkipped(Range, EndifLoc);\n  }\n\n  /// Hook called whenever an \\#if is seen.\n  void If(SourceLocation Loc, SourceRange ConditionRange,\n          ConditionValueKind ConditionValue) override {\n    First->If(Loc, ConditionRange, ConditionValue);\n    Second->If(Loc, ConditionRange, ConditionValue);\n  }\n\n  /// Hook called whenever an \\#elif is seen.\n  void Elif(SourceLocation Loc, SourceRange ConditionRange,\n            ConditionValueKind ConditionValue, SourceLocation IfLoc) override {\n    First->Elif(Loc, ConditionRange, ConditionValue, IfLoc);\n    Second->Elif(Loc, ConditionRange, ConditionValue, IfLoc);\n  }\n\n  /// Hook called whenever an \\#ifdef is seen.\n  void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n             const MacroDefinition &MD) override {\n    First->Ifdef(Loc, MacroNameTok, MD);\n    Second->Ifdef(Loc, MacroNameTok, MD);\n  }\n\n  /// Hook called whenever an \\#ifndef is seen.\n  void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n              const MacroDefinition &MD) override {\n    First->Ifndef(Loc, MacroNameTok, MD);\n    Second->Ifndef(Loc, MacroNameTok, MD);\n  }\n\n  /// Hook called whenever an \\#else is seen.\n  void Else(SourceLocation Loc, SourceLocation IfLoc) override {\n    First->Else(Loc, IfLoc);\n    Second->Else(Loc, IfLoc);\n  }\n\n  /// Hook called whenever an \\#endif is seen.\n  void Endif(SourceLocation Loc, SourceLocation IfLoc) override {\n    First->Endif(Loc, IfLoc);\n    Second->Endif(Loc, IfLoc);\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "content": "//===- Pragma.h - Pragma registration and handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PragmaHandler and PragmaTable interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PRAGMA_H\n#define LLVM_CLANG_LEX_PRAGMA_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <string>\n\nnamespace clang {\n\nclass PragmaNamespace;\nclass Preprocessor;\nclass Token;\n\n  /**\n   * Describes how the pragma was introduced, e.g., with \\#pragma,\n   * _Pragma, or __pragma.\n   */\n  enum PragmaIntroducerKind {\n    /**\n     * The pragma was introduced via \\#pragma.\n     */\n    PIK_HashPragma,\n\n    /**\n     * The pragma was introduced via the C99 _Pragma(string-literal).\n     */\n    PIK__Pragma,\n\n    /**\n     * The pragma was introduced via the Microsoft\n     * __pragma(token-string).\n     */\n    PIK___pragma\n  };\n\n  /// Describes how and where the pragma was introduced.\n  struct PragmaIntroducer {\n    PragmaIntroducerKind Kind;\n    SourceLocation Loc;\n  };\n\n/// PragmaHandler - Instances of this interface defined to handle the various\n/// pragmas that the language front-end uses.  Each handler optionally has a\n/// name (e.g. \"pack\") and the HandlePragma method is invoked when a pragma with\n/// that identifier is found.  If a handler does not match any of the declared\n/// pragmas the handler with a null identifier is invoked, if it exists.\n///\n/// Note that the PragmaNamespace class can be used to subdivide pragmas, e.g.\n/// we treat \"\\#pragma STDC\" and \"\\#pragma GCC\" as namespaces that contain other\n/// pragmas.\nclass PragmaHandler {\n  std::string Name;\n\npublic:\n  PragmaHandler() = default;\n  explicit PragmaHandler(StringRef name) : Name(name) {}\n  virtual ~PragmaHandler();\n\n  StringRef getName() const { return Name; }\n  virtual void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                            Token &FirstToken) = 0;\n\n  /// getIfNamespace - If this is a namespace, return it.  This is equivalent to\n  /// using a dynamic_cast, but doesn't require RTTI.\n  virtual PragmaNamespace *getIfNamespace() { return nullptr; }\n};\n\n/// EmptyPragmaHandler - A pragma handler which takes no action, which can be\n/// used to ignore particular pragmas.\nclass EmptyPragmaHandler : public PragmaHandler {\npublic:\n  explicit EmptyPragmaHandler(StringRef Name = StringRef());\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &FirstToken) override;\n};\n\n/// PragmaNamespace - This PragmaHandler subdivides the namespace of pragmas,\n/// allowing hierarchical pragmas to be defined.  Common examples of namespaces\n/// are \"\\#pragma GCC\", \"\\#pragma STDC\", and \"\\#pragma omp\", but any namespaces\n/// may be (potentially recursively) defined.\nclass PragmaNamespace : public PragmaHandler {\n  /// Handlers - This is a map of the handlers in this namespace with their name\n  /// as key.\n  llvm::StringMap<std::unique_ptr<PragmaHandler>> Handlers;\n\npublic:\n  explicit PragmaNamespace(StringRef Name) : PragmaHandler(Name) {}\n\n  /// FindHandler - Check to see if there is already a handler for the\n  /// specified name.  If not, return the handler for the null name if it\n  /// exists, otherwise return null.  If IgnoreNull is true (the default) then\n  /// the null handler isn't returned on failure to match.\n  PragmaHandler *FindHandler(StringRef Name,\n                             bool IgnoreNull = true) const;\n\n  /// AddPragma - Add a pragma to this namespace.\n  void AddPragma(PragmaHandler *Handler);\n\n  /// RemovePragmaHandler - Remove the given handler from the\n  /// namespace.\n  void RemovePragmaHandler(PragmaHandler *Handler);\n\n  bool IsEmpty() const { return Handlers.empty(); }\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &Tok) override;\n\n  PragmaNamespace *getIfNamespace() override { return this; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PRAGMA_H\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "content": "//===- PreprocessingRecord.h - Record of Preprocessing ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PreprocessingRecord class, which maintains a record\n//  of what occurred during preprocessing.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n#define LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass PreprocessingRecord;\n\n} // namespace clang\n\n/// Allocates memory within a Clang preprocessing record.\nvoid *operator new(size_t bytes, clang::PreprocessingRecord &PR,\n                   unsigned alignment = 8) noexcept;\n\n/// Frees memory allocated in a Clang preprocessing record.\nvoid operator delete(void *ptr, clang::PreprocessingRecord &PR,\n                     unsigned) noexcept;\n\nnamespace clang {\n\nclass FileEntry;\nclass IdentifierInfo;\nclass MacroInfo;\nclass SourceManager;\nclass Token;\n\n  /// Base class that describes a preprocessed entity, which may be a\n  /// preprocessor directive or macro expansion.\n  class PreprocessedEntity {\n  public:\n    /// The kind of preprocessed entity an object describes.\n    enum EntityKind {\n      /// Indicates a problem trying to load the preprocessed entity.\n      InvalidKind,\n\n      /// A macro expansion.\n      MacroExpansionKind,\n\n      /// \\defgroup Preprocessing directives\n      /// @{\n\n      /// A macro definition.\n      MacroDefinitionKind,\n\n      /// An inclusion directive, such as \\c \\#include, \\c\n      /// \\#import, or \\c \\#include_next.\n      InclusionDirectiveKind,\n\n      /// @}\n\n      FirstPreprocessingDirective = MacroDefinitionKind,\n      LastPreprocessingDirective = InclusionDirectiveKind\n    };\n\n  private:\n    /// The kind of preprocessed entity that this object describes.\n    EntityKind Kind;\n\n    /// The source range that covers this preprocessed entity.\n    SourceRange Range;\n\n  protected:\n    friend class PreprocessingRecord;\n\n    PreprocessedEntity(EntityKind Kind, SourceRange Range)\n        : Kind(Kind), Range(Range) {}\n\n  public:\n    /// Retrieve the kind of preprocessed entity stored in this object.\n    EntityKind getKind() const { return Kind; }\n\n    /// Retrieve the source range that covers this entire preprocessed\n    /// entity.\n    SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n    /// Returns true if there was a problem loading the preprocessed\n    /// entity.\n    bool isInvalid() const { return Kind == InvalidKind; }\n\n    // Only allow allocation of preprocessed entities using the allocator\n    // in PreprocessingRecord or by doing a placement new.\n    void *operator new(size_t bytes, PreprocessingRecord &PR,\n                       unsigned alignment = 8) noexcept {\n      return ::operator new(bytes, PR, alignment);\n    }\n\n    void *operator new(size_t bytes, void *mem) noexcept { return mem; }\n\n    void operator delete(void *ptr, PreprocessingRecord &PR,\n                         unsigned alignment) noexcept {\n      return ::operator delete(ptr, PR, alignment);\n    }\n\n    void operator delete(void *, std::size_t) noexcept {}\n    void operator delete(void *, void *) noexcept {}\n\n  private:\n    // Make vanilla 'new' and 'delete' illegal for preprocessed entities.\n    void *operator new(size_t bytes) noexcept;\n    void operator delete(void *data) noexcept;\n  };\n\n  /// Records the presence of a preprocessor directive.\n  class PreprocessingDirective : public PreprocessedEntity {\n  public:\n    PreprocessingDirective(EntityKind Kind, SourceRange Range)\n        : PreprocessedEntity(Kind, Range) {}\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PD) {\n      return PD->getKind() >= FirstPreprocessingDirective &&\n             PD->getKind() <= LastPreprocessingDirective;\n    }\n  };\n\n  /// Record the location of a macro definition.\n  class MacroDefinitionRecord : public PreprocessingDirective {\n    /// The name of the macro being defined.\n    const IdentifierInfo *Name;\n\n  public:\n    explicit MacroDefinitionRecord(const IdentifierInfo *Name,\n                                   SourceRange Range)\n        : PreprocessingDirective(MacroDefinitionKind, Range), Name(Name) {}\n\n    /// Retrieve the name of the macro being defined.\n    const IdentifierInfo *getName() const { return Name; }\n\n    /// Retrieve the location of the macro name in the definition.\n    SourceLocation getLocation() const { return getSourceRange().getBegin(); }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == MacroDefinitionKind;\n    }\n  };\n\n  /// Records the location of a macro expansion.\n  class MacroExpansion : public PreprocessedEntity {\n    /// The definition of this macro or the name of the macro if it is\n    /// a builtin macro.\n    llvm::PointerUnion<IdentifierInfo *, MacroDefinitionRecord *> NameOrDef;\n\n  public:\n    MacroExpansion(IdentifierInfo *BuiltinName, SourceRange Range)\n        : PreprocessedEntity(MacroExpansionKind, Range),\n          NameOrDef(BuiltinName) {}\n\n    MacroExpansion(MacroDefinitionRecord *Definition, SourceRange Range)\n        : PreprocessedEntity(MacroExpansionKind, Range), NameOrDef(Definition) {\n    }\n\n    /// True if it is a builtin macro.\n    bool isBuiltinMacro() const { return NameOrDef.is<IdentifierInfo *>(); }\n\n    /// The name of the macro being expanded.\n    const IdentifierInfo *getName() const {\n      if (MacroDefinitionRecord *Def = getDefinition())\n        return Def->getName();\n      return NameOrDef.get<IdentifierInfo *>();\n    }\n\n    /// The definition of the macro being expanded. May return null if\n    /// this is a builtin macro.\n    MacroDefinitionRecord *getDefinition() const {\n      return NameOrDef.dyn_cast<MacroDefinitionRecord *>();\n    }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == MacroExpansionKind;\n    }\n  };\n\n  /// Record the location of an inclusion directive, such as an\n  /// \\c \\#include or \\c \\#import statement.\n  class InclusionDirective : public PreprocessingDirective {\n  public:\n    /// The kind of inclusion directives known to the\n    /// preprocessor.\n    enum InclusionKind {\n      /// An \\c \\#include directive.\n      Include,\n\n      /// An Objective-C \\c \\#import directive.\n      Import,\n\n      /// A GNU \\c \\#include_next directive.\n      IncludeNext,\n\n      /// A Clang \\c \\#__include_macros directive.\n      IncludeMacros\n    };\n\n  private:\n    /// The name of the file that was included, as written in\n    /// the source.\n    StringRef FileName;\n\n    /// Whether the file name was in quotation marks; otherwise, it was\n    /// in angle brackets.\n    unsigned InQuotes : 1;\n\n    /// The kind of inclusion directive we have.\n    ///\n    /// This is a value of type InclusionKind.\n    unsigned Kind : 2;\n\n    /// Whether the inclusion directive was automatically turned into\n    /// a module import.\n    unsigned ImportedModule : 1;\n\n    /// The file that was included.\n    const FileEntry *File;\n\n  public:\n    InclusionDirective(PreprocessingRecord &PPRec,\n                       InclusionKind Kind, StringRef FileName,\n                       bool InQuotes, bool ImportedModule,\n                       const FileEntry *File, SourceRange Range);\n\n    /// Determine what kind of inclusion directive this is.\n    InclusionKind getKind() const { return static_cast<InclusionKind>(Kind); }\n\n    /// Retrieve the included file name as it was written in the source.\n    StringRef getFileName() const { return FileName; }\n\n    /// Determine whether the included file name was written in quotes;\n    /// otherwise, it was written in angle brackets.\n    bool wasInQuotes() const { return InQuotes; }\n\n    /// Determine whether the inclusion directive was automatically\n    /// turned into a module import.\n    bool importedModule() const { return ImportedModule; }\n\n    /// Retrieve the file entry for the actual file that was included\n    /// by this directive.\n    const FileEntry *getFile() const { return File; }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == InclusionDirectiveKind;\n    }\n  };\n\n  /// An abstract class that should be subclassed by any external source\n  /// of preprocessing record entries.\n  class ExternalPreprocessingRecordSource {\n  public:\n    virtual ~ExternalPreprocessingRecordSource();\n\n    /// Read a preallocated preprocessed entity from the external source.\n    ///\n    /// \\returns null if an error occurred that prevented the preprocessed\n    /// entity from being loaded.\n    virtual PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) = 0;\n\n    /// Returns a pair of [Begin, End) indices of preallocated\n    /// preprocessed entities that \\p Range encompasses.\n    virtual std::pair<unsigned, unsigned>\n        findPreprocessedEntitiesInRange(SourceRange Range) = 0;\n\n    /// Optionally returns true or false if the preallocated preprocessed\n    /// entity with index \\p Index came from file \\p FID.\n    virtual Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                                        FileID FID) {\n      return None;\n    }\n\n    /// Read a preallocated skipped range from the external source.\n    virtual SourceRange ReadSkippedRange(unsigned Index) = 0;\n  };\n\n  /// A record of the steps taken while preprocessing a source file,\n  /// including the various preprocessing directives processed, macros\n  /// expanded, etc.\n  class PreprocessingRecord : public PPCallbacks {\n    SourceManager &SourceMgr;\n\n    /// Allocator used to store preprocessing objects.\n    llvm::BumpPtrAllocator BumpAlloc;\n\n    /// The set of preprocessed entities in this record, in order they\n    /// were seen.\n    std::vector<PreprocessedEntity *> PreprocessedEntities;\n\n    /// The set of preprocessed entities in this record that have been\n    /// loaded from external sources.\n    ///\n    /// The entries in this vector are loaded lazily from the external source,\n    /// and are referenced by the iterator using negative indices.\n    std::vector<PreprocessedEntity *> LoadedPreprocessedEntities;\n\n    /// The set of ranges that were skipped by the preprocessor,\n    std::vector<SourceRange> SkippedRanges;\n\n    bool SkippedRangesAllLoaded = true;\n\n    /// Global (loaded or local) ID for a preprocessed entity.\n    /// Negative values are used to indicate preprocessed entities\n    /// loaded from the external source while non-negative values are used to\n    /// indicate preprocessed entities introduced by the current preprocessor.\n    /// Value -1 corresponds to element 0 in the loaded entities vector,\n    /// value -2 corresponds to element 1 in the loaded entities vector, etc.\n    /// Value 0 is an invalid value, the index to local entities is 1-based,\n    /// value 1 corresponds to element 0 in the local entities vector,\n    /// value 2 corresponds to element 1 in the local entities vector, etc.\n    class PPEntityID {\n      friend class PreprocessingRecord;\n\n      int ID = 0;\n\n      explicit PPEntityID(int ID) : ID(ID) {}\n\n    public:\n      PPEntityID() = default;\n    };\n\n    static PPEntityID getPPEntityID(unsigned Index, bool isLoaded) {\n      return isLoaded ? PPEntityID(-int(Index)-1) : PPEntityID(Index+1);\n    }\n\n    /// Mapping from MacroInfo structures to their definitions.\n    llvm::DenseMap<const MacroInfo *, MacroDefinitionRecord *> MacroDefinitions;\n\n    /// External source of preprocessed entities.\n    ExternalPreprocessingRecordSource *ExternalSource = nullptr;\n\n    /// Retrieve the preprocessed entity at the given ID.\n    PreprocessedEntity *getPreprocessedEntity(PPEntityID PPID);\n\n    /// Retrieve the loaded preprocessed entity at the given index.\n    PreprocessedEntity *getLoadedPreprocessedEntity(unsigned Index);\n\n    /// Determine the number of preprocessed entities that were\n    /// loaded (or can be loaded) from an external source.\n    unsigned getNumLoadedPreprocessedEntities() const {\n      return LoadedPreprocessedEntities.size();\n    }\n\n    /// Returns a pair of [Begin, End) indices of local preprocessed\n    /// entities that \\p Range encompasses.\n    std::pair<unsigned, unsigned>\n      findLocalPreprocessedEntitiesInRange(SourceRange Range) const;\n    unsigned findBeginLocalPreprocessedEntity(SourceLocation Loc) const;\n    unsigned findEndLocalPreprocessedEntity(SourceLocation Loc) const;\n\n    /// Allocate space for a new set of loaded preprocessed entities.\n    ///\n    /// \\returns The index into the set of loaded preprocessed entities, which\n    /// corresponds to the first newly-allocated entity.\n    unsigned allocateLoadedEntities(unsigned NumEntities);\n\n    /// Allocate space for a new set of loaded preprocessed skipped\n    /// ranges.\n    ///\n    /// \\returns The index into the set of loaded preprocessed ranges, which\n    /// corresponds to the first newly-allocated range.\n    unsigned allocateSkippedRanges(unsigned NumRanges);\n\n    /// Ensures that all external skipped ranges have been loaded.\n    void ensureSkippedRangesLoaded();\n\n    /// Register a new macro definition.\n    void RegisterMacroDefinition(MacroInfo *Macro, MacroDefinitionRecord *Def);\n\n  public:\n    /// Construct a new preprocessing record.\n    explicit PreprocessingRecord(SourceManager &SM);\n\n    /// Allocate memory in the preprocessing record.\n    void *Allocate(unsigned Size, unsigned Align = 8) {\n      return BumpAlloc.Allocate(Size, Align);\n    }\n\n    /// Deallocate memory in the preprocessing record.\n    void Deallocate(void *Ptr) {}\n\n    size_t getTotalMemory() const;\n\n    SourceManager &getSourceManager() const { return SourceMgr; }\n\n    /// Iteration over the preprocessed entities.\n    ///\n    /// In a complete iteration, the iterator walks the range [-M, N),\n    /// where negative values are used to indicate preprocessed entities\n    /// loaded from the external source while non-negative values are used to\n    /// indicate preprocessed entities introduced by the current preprocessor.\n    /// However, to provide iteration in source order (for, e.g., chained\n    /// precompiled headers), dereferencing the iterator flips the negative\n    /// values (corresponding to loaded entities), so that position -M\n    /// corresponds to element 0 in the loaded entities vector, position -M+1\n    /// corresponds to element 1 in the loaded entities vector, etc. This\n    /// gives us a reasonably efficient, source-order walk.\n    ///\n    /// We define this as a wrapping iterator around an int. The\n    /// iterator_adaptor_base class forwards the iterator methods to basic\n    /// integer arithmetic.\n    class iterator : public llvm::iterator_adaptor_base<\n                         iterator, int, std::random_access_iterator_tag,\n                         PreprocessedEntity *, int, PreprocessedEntity *,\n                         PreprocessedEntity *> {\n      friend class PreprocessingRecord;\n\n      PreprocessingRecord *Self;\n\n      iterator(PreprocessingRecord *Self, int Position)\n          : iterator::iterator_adaptor_base(Position), Self(Self) {}\n\n    public:\n      iterator() : iterator(nullptr, 0) {}\n\n      PreprocessedEntity *operator*() const {\n        bool isLoaded = this->I < 0;\n        unsigned Index = isLoaded ?\n            Self->LoadedPreprocessedEntities.size() + this->I : this->I;\n        PPEntityID ID = Self->getPPEntityID(Index, isLoaded);\n        return Self->getPreprocessedEntity(ID);\n      }\n      PreprocessedEntity *operator->() const { return **this; }\n    };\n\n    /// Begin iterator for all preprocessed entities.\n    iterator begin() {\n      return iterator(this, -(int)LoadedPreprocessedEntities.size());\n    }\n\n    /// End iterator for all preprocessed entities.\n    iterator end() {\n      return iterator(this, PreprocessedEntities.size());\n    }\n\n    /// Begin iterator for local, non-loaded, preprocessed entities.\n    iterator local_begin() {\n      return iterator(this, 0);\n    }\n\n    /// End iterator for local, non-loaded, preprocessed entities.\n    iterator local_end() {\n      return iterator(this, PreprocessedEntities.size());\n    }\n\n    /// iterator range for the given range of loaded\n    /// preprocessed entities.\n    llvm::iterator_range<iterator> getIteratorsForLoadedRange(unsigned start,\n                                                              unsigned count) {\n      unsigned end = start + count;\n      assert(end <= LoadedPreprocessedEntities.size());\n      return llvm::make_range(\n          iterator(this, int(start) - LoadedPreprocessedEntities.size()),\n          iterator(this, int(end) - LoadedPreprocessedEntities.size()));\n    }\n\n    /// Returns a range of preprocessed entities that source range \\p R\n    /// encompasses.\n    ///\n    /// \\param R the range to look for preprocessed entities.\n    llvm::iterator_range<iterator>\n    getPreprocessedEntitiesInRange(SourceRange R);\n\n    /// Returns true if the preprocessed entity that \\p PPEI iterator\n    /// points to is coming from the file \\p FID.\n    ///\n    /// Can be used to avoid implicit deserializations of preallocated\n    /// preprocessed entities if we only care about entities of a specific file\n    /// and not from files \\#included in the range given at\n    /// \\see getPreprocessedEntitiesInRange.\n    bool isEntityInFileID(iterator PPEI, FileID FID);\n\n    /// Add a new preprocessed entity to this record.\n    PPEntityID addPreprocessedEntity(PreprocessedEntity *Entity);\n\n    /// Set the external source for preprocessed entities.\n    void SetExternalSource(ExternalPreprocessingRecordSource &Source);\n\n    /// Retrieve the external source for preprocessed entities.\n    ExternalPreprocessingRecordSource *getExternalSource() const {\n      return ExternalSource;\n    }\n\n    /// Retrieve the macro definition that corresponds to the given\n    /// \\c MacroInfo.\n    MacroDefinitionRecord *findMacroDefinition(const MacroInfo *MI);\n\n    /// Retrieve all ranges that got skipped while preprocessing.\n    const std::vector<SourceRange> &getSkippedRanges() {\n      ensureSkippedRangesLoaded();\n      return SkippedRanges;\n    }\n\n  private:\n    friend class ASTReader;\n    friend class ASTWriter;\n\n    void MacroExpands(const Token &Id, const MacroDefinition &MD,\n                      SourceRange Range, const MacroArgs *Args) override;\n    void MacroDefined(const Token &Id, const MacroDirective *MD) override;\n    void MacroUndefined(const Token &Id, const MacroDefinition &MD,\n                        const MacroDirective *Undef) override;\n    void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,\n                            StringRef FileName, bool IsAngled,\n                            CharSourceRange FilenameRange,\n                            const FileEntry *File, StringRef SearchPath,\n                            StringRef RelativePath, const Module *Imported,\n                            SrcMgr::CharacteristicKind FileType) override;\n    void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n               const MacroDefinition &MD) override;\n    void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n                const MacroDefinition &MD) override;\n\n    /// Hook called whenever the 'defined' operator is seen.\n    void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n                 SourceRange Range) override;\n\n    void SourceRangeSkipped(SourceRange Range,\n                            SourceLocation EndifLoc) override;\n\n    void addMacroExpansion(const Token &Id, const MacroInfo *MI,\n                           SourceRange Range);\n\n    /// Cached result of the last \\see getPreprocessedEntitiesInRange\n    /// query.\n    struct {\n      SourceRange Range;\n      std::pair<int, int> Result;\n    } CachedRangeQuery;\n\n    std::pair<int, int> getPreprocessedEntitiesInRangeSlow(SourceRange R);\n  };\n\n} // namespace clang\n\ninline void *operator new(size_t bytes, clang::PreprocessingRecord &PR,\n                          unsigned alignment) noexcept {\n  return PR.Allocate(bytes, alignment);\n}\n\ninline void operator delete(void *ptr, clang::PreprocessingRecord &PR,\n                            unsigned) noexcept {\n  PR.Deallocate(ptr);\n}\n\n#endif // LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "content": "//===- Preprocessor.h - C Language Family Preprocessor ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Preprocessor interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOR_H\n#define LLVM_CLANG_LEX_PREPROCESSOR_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Lex/TokenLexer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Registry.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate<unsigned InternalLen> class SmallString;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass CodeCompletionHandler;\nclass CommentHandler;\nclass DirectoryEntry;\nclass DirectoryLookup;\nclass EmptylineHandler;\nclass ExternalPreprocessorSource;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass MacroArgs;\nclass PragmaHandler;\nclass PragmaNamespace;\nclass PreprocessingRecord;\nclass PreprocessorLexer;\nclass PreprocessorOptions;\nclass ScratchBuffer;\nclass TargetInfo;\n\nnamespace Builtin {\nclass Context;\n}\n\n/// Stores token information for comparing actual tokens with\n/// predefined values.  Only handles simple tokens and identifiers.\nclass TokenValue {\n  tok::TokenKind Kind;\n  IdentifierInfo *II;\n\npublic:\n  TokenValue(tok::TokenKind Kind) : Kind(Kind), II(nullptr) {\n    assert(Kind != tok::raw_identifier && \"Raw identifiers are not supported.\");\n    assert(Kind != tok::identifier &&\n           \"Identifiers should be created by TokenValue(IdentifierInfo *)\");\n    assert(!tok::isLiteral(Kind) && \"Literals are not supported.\");\n    assert(!tok::isAnnotation(Kind) && \"Annotations are not supported.\");\n  }\n\n  TokenValue(IdentifierInfo *II) : Kind(tok::identifier), II(II) {}\n\n  bool operator==(const Token &Tok) const {\n    return Tok.getKind() == Kind &&\n        (!II || II == Tok.getIdentifierInfo());\n  }\n};\n\n/// Context in which macro name is used.\nenum MacroUse {\n  // other than #define or #undef\n  MU_Other  = 0,\n\n  // macro name specified in #define\n  MU_Define = 1,\n\n  // macro name specified in #undef\n  MU_Undef  = 2\n};\n\n/// Engages in a tight little dance with the lexer to efficiently\n/// preprocess tokens.\n///\n/// Lexers know only about tokens within a single source file, and don't\n/// know anything about preprocessor-level issues like the \\#include stack,\n/// token expansion, etc.\nclass Preprocessor {\n  friend class VAOptDefinitionContext;\n  friend class VariadicMacroScopeGuard;\n\n  llvm::unique_function<void(const clang::Token &)> OnToken;\n  std::shared_ptr<PreprocessorOptions> PPOpts;\n  DiagnosticsEngine        *Diags;\n  LangOptions       &LangOpts;\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  FileManager       &FileMgr;\n  SourceManager     &SourceMgr;\n  std::unique_ptr<ScratchBuffer> ScratchBuf;\n  HeaderSearch      &HeaderInfo;\n  ModuleLoader      &TheModuleLoader;\n\n  /// External source of macros.\n  ExternalPreprocessorSource *ExternalSource;\n\n  /// A BumpPtrAllocator object used to quickly allocate and release\n  /// objects internal to the Preprocessor.\n  llvm::BumpPtrAllocator BP;\n\n  /// Identifiers for builtin macros and other builtins.\n  IdentifierInfo *Ident__LINE__, *Ident__FILE__;   // __LINE__, __FILE__\n  IdentifierInfo *Ident__DATE__, *Ident__TIME__;   // __DATE__, __TIME__\n  IdentifierInfo *Ident__INCLUDE_LEVEL__;          // __INCLUDE_LEVEL__\n  IdentifierInfo *Ident__BASE_FILE__;              // __BASE_FILE__\n  IdentifierInfo *Ident__FILE_NAME__;              // __FILE_NAME__\n  IdentifierInfo *Ident__TIMESTAMP__;              // __TIMESTAMP__\n  IdentifierInfo *Ident__COUNTER__;                // __COUNTER__\n  IdentifierInfo *Ident_Pragma, *Ident__pragma;    // _Pragma, __pragma\n  IdentifierInfo *Ident__identifier;               // __identifier\n  IdentifierInfo *Ident__VA_ARGS__;                // __VA_ARGS__\n  IdentifierInfo *Ident__VA_OPT__;                 // __VA_OPT__\n  IdentifierInfo *Ident__has_feature;              // __has_feature\n  IdentifierInfo *Ident__has_extension;            // __has_extension\n  IdentifierInfo *Ident__has_builtin;              // __has_builtin\n  IdentifierInfo *Ident__has_attribute;            // __has_attribute\n  IdentifierInfo *Ident__has_include;              // __has_include\n  IdentifierInfo *Ident__has_include_next;         // __has_include_next\n  IdentifierInfo *Ident__has_warning;              // __has_warning\n  IdentifierInfo *Ident__is_identifier;            // __is_identifier\n  IdentifierInfo *Ident__building_module;          // __building_module\n  IdentifierInfo *Ident__MODULE__;                 // __MODULE__\n  IdentifierInfo *Ident__has_cpp_attribute;        // __has_cpp_attribute\n  IdentifierInfo *Ident__has_c_attribute;          // __has_c_attribute\n  IdentifierInfo *Ident__has_declspec;             // __has_declspec_attribute\n  IdentifierInfo *Ident__is_target_arch;           // __is_target_arch\n  IdentifierInfo *Ident__is_target_vendor;         // __is_target_vendor\n  IdentifierInfo *Ident__is_target_os;             // __is_target_os\n  IdentifierInfo *Ident__is_target_environment;    // __is_target_environment\n\n  // Weak, only valid (and set) while InMacroArgs is true.\n  Token* ArgMacro;\n\n  SourceLocation DATELoc, TIMELoc;\n\n  // Next __COUNTER__ value, starts at 0.\n  unsigned CounterValue = 0;\n\n  enum {\n    /// Maximum depth of \\#includes.\n    MaxAllowedIncludeStackDepth = 200\n  };\n\n  // State that is set before the preprocessor begins.\n  bool KeepComments : 1;\n  bool KeepMacroComments : 1;\n  bool SuppressIncludeNotFoundError : 1;\n\n  // State that changes while the preprocessor runs:\n  bool InMacroArgs : 1;            // True if parsing fn macro invocation args.\n\n  /// Whether the preprocessor owns the header search object.\n  bool OwnsHeaderSearch : 1;\n\n  /// True if macro expansion is disabled.\n  bool DisableMacroExpansion : 1;\n\n  /// Temporarily disables DisableMacroExpansion (i.e. enables expansion)\n  /// when parsing preprocessor directives.\n  bool MacroExpansionInDirectivesOverride : 1;\n\n  class ResetMacroExpansionHelper;\n\n  /// Whether we have already loaded macros from the external source.\n  mutable bool ReadMacrosFromExternalSource : 1;\n\n  /// True if pragmas are enabled.\n  bool PragmasEnabled : 1;\n\n  /// True if the current build action is a preprocessing action.\n  bool PreprocessedOutput : 1;\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool ParsingIfOrElifDirective;\n\n  /// True if we are pre-expanding macro arguments.\n  bool InMacroArgPreExpansion;\n\n  /// Mapping/lookup information for all identifiers in\n  /// the program, including program keywords.\n  mutable IdentifierTable Identifiers;\n\n  /// This table contains all the selectors in the program.\n  ///\n  /// Unlike IdentifierTable above, this table *isn't* populated by the\n  /// preprocessor. It is declared/expanded here because its role/lifetime is\n  /// conceptually similar to the IdentifierTable. In addition, the current\n  /// control flow (in clang::ParseAST()), make it convenient to put here.\n  ///\n  /// FIXME: Make sure the lifetime of Identifiers/Selectors *isn't* tied to\n  /// the lifetime of the preprocessor.\n  SelectorTable Selectors;\n\n  /// Information about builtins.\n  std::unique_ptr<Builtin::Context> BuiltinInfo;\n\n  /// Tracks all of the pragmas that the client registered\n  /// with this preprocessor.\n  std::unique_ptr<PragmaNamespace> PragmaHandlers;\n\n  /// Pragma handlers of the original source is stored here during the\n  /// parsing of a model file.\n  std::unique_ptr<PragmaNamespace> PragmaHandlersBackup;\n\n  /// Tracks all of the comment handlers that the client registered\n  /// with this preprocessor.\n  std::vector<CommentHandler *> CommentHandlers;\n\n  /// Empty line handler.\n  EmptylineHandler *Emptyline = nullptr;\n\n  /// True if we want to ignore EOF token and continue later on (thus\n  /// avoid tearing the Lexer and etc. down).\n  bool IncrementalProcessing = false;\n\n  /// The kind of translation unit we are processing.\n  TranslationUnitKind TUKind;\n\n  /// The code-completion handler.\n  CodeCompletionHandler *CodeComplete = nullptr;\n\n  /// The file that we're performing code-completion for, if any.\n  const FileEntry *CodeCompletionFile = nullptr;\n\n  /// The offset in file for the code-completion point.\n  unsigned CodeCompletionOffset = 0;\n\n  /// The location for the code-completion point. This gets instantiated\n  /// when the CodeCompletionFile gets \\#include'ed for preprocessing.\n  SourceLocation CodeCompletionLoc;\n\n  /// The start location for the file of the code-completion point.\n  ///\n  /// This gets instantiated when the CodeCompletionFile gets \\#include'ed\n  /// for preprocessing.\n  SourceLocation CodeCompletionFileLoc;\n\n  /// The source location of the \\c import contextual keyword we just\n  /// lexed, if any.\n  SourceLocation ModuleImportLoc;\n\n  /// The module import path that we're currently processing.\n  SmallVector<std::pair<IdentifierInfo *, SourceLocation>, 2> ModuleImportPath;\n\n  /// Whether the last token we lexed was an '@'.\n  bool LastTokenWasAt = false;\n\n  /// A position within a C++20 import-seq.\n  class ImportSeq {\n  public:\n    enum State : int {\n      // Positive values represent a number of unclosed brackets.\n      AtTopLevel = 0,\n      AfterTopLevelTokenSeq = -1,\n      AfterExport = -2,\n      AfterImportSeq = -3,\n    };\n\n    ImportSeq(State S) : S(S) {}\n\n    /// Saw any kind of open bracket.\n    void handleOpenBracket() {\n      S = static_cast<State>(std::max<int>(S, 0) + 1);\n    }\n    /// Saw any kind of close bracket other than '}'.\n    void handleCloseBracket() {\n      S = static_cast<State>(std::max<int>(S, 1) - 1);\n    }\n    /// Saw a close brace.\n    void handleCloseBrace() {\n      handleCloseBracket();\n      if (S == AtTopLevel && !AfterHeaderName)\n        S = AfterTopLevelTokenSeq;\n    }\n    /// Saw a semicolon.\n    void handleSemi() {\n      if (atTopLevel()) {\n        S = AfterTopLevelTokenSeq;\n        AfterHeaderName = false;\n      }\n    }\n\n    /// Saw an 'export' identifier.\n    void handleExport() {\n      if (S == AfterTopLevelTokenSeq)\n        S = AfterExport;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n    /// Saw an 'import' identifier.\n    void handleImport() {\n      if (S == AfterTopLevelTokenSeq || S == AfterExport)\n        S = AfterImportSeq;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    /// Saw a 'header-name' token; do not recognize any more 'import' tokens\n    /// until we reach a top-level semicolon.\n    void handleHeaderName() {\n      if (S == AfterImportSeq)\n        AfterHeaderName = true;\n      handleMisc();\n    }\n\n    /// Saw any other token.\n    void handleMisc() {\n      if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    bool atTopLevel() { return S <= 0; }\n    bool afterImportSeq() { return S == AfterImportSeq; }\n\n  private:\n    State S;\n    /// Whether we're in the pp-import-suffix following the header-name in a\n    /// pp-import. If so, a close-brace is not sufficient to end the\n    /// top-level-token-seq of an import-seq.\n    bool AfterHeaderName = false;\n  };\n\n  /// Our current position within a C++20 import-seq.\n  ImportSeq ImportSeqState = ImportSeq::AfterTopLevelTokenSeq;\n\n  /// Whether the module import expects an identifier next. Otherwise,\n  /// it expects a '.' or ';'.\n  bool ModuleImportExpectsIdentifier = false;\n\n  /// The identifier and source location of the currently-active\n  /// \\#pragma clang arc_cf_code_audited begin.\n  std::pair<IdentifierInfo *, SourceLocation> PragmaARCCFCodeAuditedInfo;\n\n  /// The source location of the currently-active\n  /// \\#pragma clang assume_nonnull begin.\n  SourceLocation PragmaAssumeNonNullLoc;\n\n  /// True if we hit the code-completion point.\n  bool CodeCompletionReached = false;\n\n  /// The code completion token containing the information\n  /// on the stem that is to be code completed.\n  IdentifierInfo *CodeCompletionII = nullptr;\n\n  /// Range for the code completion token.\n  SourceRange CodeCompletionTokenRange;\n\n  /// The directory that the main file should be considered to occupy,\n  /// if it does not correspond to a real file (as happens when building a\n  /// module).\n  const DirectoryEntry *MainFileDir = nullptr;\n\n  /// The number of bytes that we will initially skip when entering the\n  /// main file, along with a flag that indicates whether skipping this number\n  /// of bytes will place the lexer at the start of a line.\n  ///\n  /// This is used when loading a precompiled preamble.\n  std::pair<int, bool> SkipMainFilePreamble;\n\n  /// Whether we hit an error due to reaching max allowed include depth. Allows\n  /// to avoid hitting the same error over and over again.\n  bool HasReachedMaxIncludeDepth = false;\n\n  /// The number of currently-active calls to Lex.\n  ///\n  /// Lex is reentrant, and asking for an (end-of-phase-4) token can often\n  /// require asking for multiple additional tokens. This counter makes it\n  /// possible for Lex to detect whether it's producing a token for the end\n  /// of phase 4 of translation or for some other situation.\n  unsigned LexLevel = 0;\n\n  /// The number of (LexLevel 0) preprocessor tokens.\n  unsigned TokenCount = 0;\n\n  /// Preprocess every token regardless of LexLevel.\n  bool PreprocessToken = false;\n\n  /// The maximum number of (LexLevel 0) tokens before issuing a -Wmax-tokens\n  /// warning, or zero for unlimited.\n  unsigned MaxTokens = 0;\n  SourceLocation MaxTokensOverrideLoc;\n\npublic:\n  struct PreambleSkipInfo {\n    SourceLocation HashTokenLoc;\n    SourceLocation IfTokenLoc;\n    bool FoundNonSkipPortion;\n    bool FoundElse;\n    SourceLocation ElseLoc;\n\n    PreambleSkipInfo(SourceLocation HashTokenLoc, SourceLocation IfTokenLoc,\n                     bool FoundNonSkipPortion, bool FoundElse,\n                     SourceLocation ElseLoc)\n        : HashTokenLoc(HashTokenLoc), IfTokenLoc(IfTokenLoc),\n          FoundNonSkipPortion(FoundNonSkipPortion), FoundElse(FoundElse),\n          ElseLoc(ElseLoc) {}\n  };\n\nprivate:\n  friend class ASTReader;\n  friend class MacroArgs;\n\n  class PreambleConditionalStackStore {\n    enum State {\n      Off = 0,\n      Recording = 1,\n      Replaying = 2,\n    };\n\n  public:\n    PreambleConditionalStackStore() = default;\n\n    void startRecording() { ConditionalStackState = Recording; }\n    void startReplaying() { ConditionalStackState = Replaying; }\n    bool isRecording() const { return ConditionalStackState == Recording; }\n    bool isReplaying() const { return ConditionalStackState == Replaying; }\n\n    ArrayRef<PPConditionalInfo> getStack() const {\n      return ConditionalStack;\n    }\n\n    void doneReplaying() {\n      ConditionalStack.clear();\n      ConditionalStackState = Off;\n    }\n\n    void setStack(ArrayRef<PPConditionalInfo> s) {\n      if (!isRecording() && !isReplaying())\n        return;\n      ConditionalStack.clear();\n      ConditionalStack.append(s.begin(), s.end());\n    }\n\n    bool hasRecordedPreamble() const { return !ConditionalStack.empty(); }\n\n    bool reachedEOFWhileSkipping() const { return SkipInfo.hasValue(); }\n\n    void clearSkipInfo() { SkipInfo.reset(); }\n\n    llvm::Optional<PreambleSkipInfo> SkipInfo;\n\n  private:\n    SmallVector<PPConditionalInfo, 4> ConditionalStack;\n    State ConditionalStackState = Off;\n  } PreambleConditionalStack;\n\n  /// The current top of the stack that we're lexing from if\n  /// not expanding a macro and we are lexing directly from source code.\n  ///\n  /// Only one of CurLexer, or CurTokenLexer will be non-null.\n  std::unique_ptr<Lexer> CurLexer;\n\n  /// The current top of the stack what we're lexing from\n  /// if not expanding a macro.\n  ///\n  /// This is an alias for CurLexer.\n  PreprocessorLexer *CurPPLexer = nullptr;\n\n  /// Used to find the current FileEntry, if CurLexer is non-null\n  /// and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *CurDirLookup = nullptr;\n\n  /// The current macro we are expanding, if we are expanding a macro.\n  ///\n  /// One of CurLexer and CurTokenLexer must be null.\n  std::unique_ptr<TokenLexer> CurTokenLexer;\n\n  /// The kind of lexer we're currently working with.\n  enum CurLexerKind {\n    CLK_Lexer,\n    CLK_TokenLexer,\n    CLK_CachingLexer,\n    CLK_LexAfterModuleImport\n  } CurLexerKind = CLK_Lexer;\n\n  /// If the current lexer is for a submodule that is being built, this\n  /// is that submodule.\n  Module *CurLexerSubmodule = nullptr;\n\n  /// Keeps track of the stack of files currently\n  /// \\#included, and macros currently being expanded from, not counting\n  /// CurLexer/CurTokenLexer.\n  struct IncludeStackInfo {\n    enum CurLexerKind           CurLexerKind;\n    Module                     *TheSubmodule;\n    std::unique_ptr<Lexer>      TheLexer;\n    PreprocessorLexer          *ThePPLexer;\n    std::unique_ptr<TokenLexer> TheTokenLexer;\n    const DirectoryLookup      *TheDirLookup;\n\n    // The following constructors are completely useless copies of the default\n    // versions, only needed to pacify MSVC.\n    IncludeStackInfo(enum CurLexerKind CurLexerKind, Module *TheSubmodule,\n                     std::unique_ptr<Lexer> &&TheLexer,\n                     PreprocessorLexer *ThePPLexer,\n                     std::unique_ptr<TokenLexer> &&TheTokenLexer,\n                     const DirectoryLookup *TheDirLookup)\n        : CurLexerKind(std::move(CurLexerKind)),\n          TheSubmodule(std::move(TheSubmodule)), TheLexer(std::move(TheLexer)),\n          ThePPLexer(std::move(ThePPLexer)),\n          TheTokenLexer(std::move(TheTokenLexer)),\n          TheDirLookup(std::move(TheDirLookup)) {}\n  };\n  std::vector<IncludeStackInfo> IncludeMacroStack;\n\n  /// Actions invoked when some preprocessor activity is\n  /// encountered (e.g. a file is \\#included, etc).\n  std::unique_ptr<PPCallbacks> Callbacks;\n\n  struct MacroExpandsInfo {\n    Token Tok;\n    MacroDefinition MD;\n    SourceRange Range;\n\n    MacroExpandsInfo(Token Tok, MacroDefinition MD, SourceRange Range)\n        : Tok(Tok), MD(MD), Range(Range) {}\n  };\n  SmallVector<MacroExpandsInfo, 2> DelayedMacroExpandsCallbacks;\n\n  /// Information about a name that has been used to define a module macro.\n  struct ModuleMacroInfo {\n    /// The most recent macro directive for this identifier.\n    MacroDirective *MD;\n\n    /// The active module macros for this identifier.\n    llvm::TinyPtrVector<ModuleMacro *> ActiveModuleMacros;\n\n    /// The generation number at which we last updated ActiveModuleMacros.\n    /// \\see Preprocessor::VisibleModules.\n    unsigned ActiveModuleMacrosGeneration = 0;\n\n    /// Whether this macro name is ambiguous.\n    bool IsAmbiguous = false;\n\n    /// The module macros that are overridden by this macro.\n    llvm::TinyPtrVector<ModuleMacro *> OverriddenMacros;\n\n    ModuleMacroInfo(MacroDirective *MD) : MD(MD) {}\n  };\n\n  /// The state of a macro for an identifier.\n  class MacroState {\n    mutable llvm::PointerUnion<MacroDirective *, ModuleMacroInfo *> State;\n\n    ModuleMacroInfo *getModuleInfo(Preprocessor &PP,\n                                   const IdentifierInfo *II) const {\n      if (II->isOutOfDate())\n        PP.updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n      // FIXME: Find a spare bit on IdentifierInfo and store a\n      //        HasModuleMacros flag.\n      if (!II->hasMacroDefinition() ||\n          (!PP.getLangOpts().Modules &&\n           !PP.getLangOpts().ModulesLocalVisibility) ||\n          !PP.CurSubmoduleState->VisibleModules.getGeneration())\n        return nullptr;\n\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n\n      if (PP.CurSubmoduleState->VisibleModules.getGeneration() !=\n          Info->ActiveModuleMacrosGeneration)\n        PP.updateModuleMacroInfo(II, *Info);\n      return Info;\n    }\n\n  public:\n    MacroState() : MacroState(nullptr) {}\n    MacroState(MacroDirective *MD) : State(MD) {}\n\n    MacroState(MacroState &&O) noexcept : State(O.State) {\n      O.State = (MacroDirective *)nullptr;\n    }\n\n    MacroState &operator=(MacroState &&O) noexcept {\n      auto S = O.State;\n      O.State = (MacroDirective *)nullptr;\n      State = S;\n      return *this;\n    }\n\n    ~MacroState() {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->~ModuleMacroInfo();\n    }\n\n    MacroDirective *getLatest() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->MD;\n      return State.get<MacroDirective*>();\n    }\n\n    void setLatest(MacroDirective *MD) {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->MD = MD;\n      else\n        State = MD;\n    }\n\n    bool isAmbiguous(Preprocessor &PP, const IdentifierInfo *II) const {\n      auto *Info = getModuleInfo(PP, II);\n      return Info ? Info->IsAmbiguous : false;\n    }\n\n    ArrayRef<ModuleMacro *>\n    getActiveModuleMacros(Preprocessor &PP, const IdentifierInfo *II) const {\n      if (auto *Info = getModuleInfo(PP, II))\n        return Info->ActiveModuleMacros;\n      return None;\n    }\n\n    MacroDirective::DefInfo findDirectiveAtLoc(SourceLocation Loc,\n                                               SourceManager &SourceMgr) const {\n      // FIXME: Incorporate module macros into the result of this.\n      if (auto *Latest = getLatest())\n        return Latest->findDirectiveAtLoc(Loc, SourceMgr);\n      return {};\n    }\n\n    void overrideActiveModuleMacros(Preprocessor &PP, IdentifierInfo *II) {\n      if (auto *Info = getModuleInfo(PP, II)) {\n        Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                      Info->ActiveModuleMacros.begin(),\n                                      Info->ActiveModuleMacros.end());\n        Info->ActiveModuleMacros.clear();\n        Info->IsAmbiguous = false;\n      }\n    }\n\n    ArrayRef<ModuleMacro*> getOverriddenMacros() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->OverriddenMacros;\n      return None;\n    }\n\n    void setOverriddenMacros(Preprocessor &PP,\n                             ArrayRef<ModuleMacro *> Overrides) {\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        if (Overrides.empty())\n          return;\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n      Info->OverriddenMacros.clear();\n      Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                    Overrides.begin(), Overrides.end());\n      Info->ActiveModuleMacrosGeneration = 0;\n    }\n  };\n\n  /// For each IdentifierInfo that was associated with a macro, we\n  /// keep a mapping to the history of all macro definitions and #undefs in\n  /// the reverse order (the latest one is in the head of the list).\n  ///\n  /// This mapping lives within the \\p CurSubmoduleState.\n  using MacroMap = llvm::DenseMap<const IdentifierInfo *, MacroState>;\n\n  struct SubmoduleState;\n\n  /// Information about a submodule that we're currently building.\n  struct BuildingSubmoduleInfo {\n    /// The module that we are building.\n    Module *M;\n\n    /// The location at which the module was included.\n    SourceLocation ImportLoc;\n\n    /// Whether we entered this submodule via a pragma.\n    bool IsPragma;\n\n    /// The previous SubmoduleState.\n    SubmoduleState *OuterSubmoduleState;\n\n    /// The number of pending module macro names when we started building this.\n    unsigned OuterPendingModuleMacroNames;\n\n    BuildingSubmoduleInfo(Module *M, SourceLocation ImportLoc, bool IsPragma,\n                          SubmoduleState *OuterSubmoduleState,\n                          unsigned OuterPendingModuleMacroNames)\n        : M(M), ImportLoc(ImportLoc), IsPragma(IsPragma),\n          OuterSubmoduleState(OuterSubmoduleState),\n          OuterPendingModuleMacroNames(OuterPendingModuleMacroNames) {}\n  };\n  SmallVector<BuildingSubmoduleInfo, 8> BuildingSubmoduleStack;\n\n  /// Information about a submodule's preprocessor state.\n  struct SubmoduleState {\n    /// The macros for the submodule.\n    MacroMap Macros;\n\n    /// The set of modules that are visible within the submodule.\n    VisibleModuleSet VisibleModules;\n\n    // FIXME: CounterValue?\n    // FIXME: PragmaPushMacroInfo?\n  };\n  std::map<Module *, SubmoduleState> Submodules;\n\n  /// The preprocessor state for preprocessing outside of any submodule.\n  SubmoduleState NullSubmoduleState;\n\n  /// The current submodule state. Will be \\p NullSubmoduleState if we're not\n  /// in a submodule.\n  SubmoduleState *CurSubmoduleState;\n\n  /// The set of known macros exported from modules.\n  llvm::FoldingSet<ModuleMacro> ModuleMacros;\n\n  /// The names of potential module macros that we've not yet processed.\n  llvm::SmallVector<const IdentifierInfo *, 32> PendingModuleMacroNames;\n\n  /// The list of module macros, for each identifier, that are not overridden by\n  /// any other module macro.\n  llvm::DenseMap<const IdentifierInfo *, llvm::TinyPtrVector<ModuleMacro *>>\n      LeafModuleMacros;\n\n  /// Macros that we want to warn because they are not used at the end\n  /// of the translation unit.\n  ///\n  /// We store just their SourceLocations instead of\n  /// something like MacroInfo*. The benefit of this is that when we are\n  /// deserializing from PCH, we don't need to deserialize identifier & macros\n  /// just so that we can report that they are unused, we just warn using\n  /// the SourceLocations of this set (that will be filled by the ASTReader).\n  /// We are using SmallPtrSet instead of a vector for faster removal.\n  using WarnUnusedMacroLocsTy = llvm::SmallPtrSet<SourceLocation, 32>;\n  WarnUnusedMacroLocsTy WarnUnusedMacroLocs;\n\n  /// A \"freelist\" of MacroArg objects that can be\n  /// reused for quick allocation.\n  MacroArgs *MacroArgCache = nullptr;\n\n  /// For each IdentifierInfo used in a \\#pragma push_macro directive,\n  /// we keep a MacroInfo stack used to restore the previous macro value.\n  llvm::DenseMap<IdentifierInfo *, std::vector<MacroInfo *>>\n      PragmaPushMacroInfo;\n\n  // Various statistics we track for performance analysis.\n  unsigned NumDirectives = 0;\n  unsigned NumDefined = 0;\n  unsigned NumUndefined = 0;\n  unsigned NumPragma = 0;\n  unsigned NumIf = 0;\n  unsigned NumElse = 0;\n  unsigned NumEndif = 0;\n  unsigned NumEnteredSourceFiles = 0;\n  unsigned MaxIncludeStackDepth = 0;\n  unsigned NumMacroExpanded = 0;\n  unsigned NumFnMacroExpanded = 0;\n  unsigned NumBuiltinMacroExpanded = 0;\n  unsigned NumFastMacroExpanded = 0;\n  unsigned NumTokenPaste = 0;\n  unsigned NumFastTokenPaste = 0;\n  unsigned NumSkipped = 0;\n\n  /// The predefined macros that preprocessor should use from the\n  /// command line etc.\n  std::string Predefines;\n\n  /// The file ID for the preprocessor predefines.\n  FileID PredefinesFileID;\n\n  /// The file ID for the PCH through header.\n  FileID PCHThroughHeaderFileID;\n\n  /// Whether tokens are being skipped until a #pragma hdrstop is seen.\n  bool SkippingUntilPragmaHdrStop = false;\n\n  /// Whether tokens are being skipped until the through header is seen.\n  bool SkippingUntilPCHThroughHeader = false;\n\n  /// \\{\n  /// Cache of macro expanders to reduce malloc traffic.\n  enum { TokenLexerCacheSize = 8 };\n  unsigned NumCachedTokenLexers;\n  std::unique_ptr<TokenLexer> TokenLexerCache[TokenLexerCacheSize];\n  /// \\}\n\n  /// Keeps macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  SmallVector<Token, 16> MacroExpandedTokens;\n  std::vector<std::pair<TokenLexer *, size_t>> MacroExpandingLexersStack;\n\n  /// A record of the macro definitions and expansions that\n  /// occurred during preprocessing.\n  ///\n  /// This is an optional side structure that can be enabled with\n  /// \\c createPreprocessingRecord() prior to preprocessing.\n  PreprocessingRecord *Record = nullptr;\n\n  /// Cached tokens state.\n  using CachedTokensTy = SmallVector<Token, 1>;\n\n  /// Cached tokens are stored here when we do backtracking or\n  /// lookahead. They are \"lexed\" by the CachingLex() method.\n  CachedTokensTy CachedTokens;\n\n  /// The position of the cached token that CachingLex() should\n  /// \"lex\" next.\n  ///\n  /// If it points beyond the CachedTokens vector, it means that a normal\n  /// Lex() should be invoked.\n  CachedTokensTy::size_type CachedLexPos = 0;\n\n  /// Stack of backtrack positions, allowing nested backtracks.\n  ///\n  /// The EnableBacktrackAtThisPos() method pushes a position to\n  /// indicate where CachedLexPos should be set when the BackTrack() method is\n  /// invoked (at which point the last position is popped).\n  std::vector<CachedTokensTy::size_type> BacktrackPositions;\n\n  struct MacroInfoChain {\n    MacroInfo MI;\n    MacroInfoChain *Next;\n  };\n\n  /// MacroInfos are managed as a chain for easy disposal.  This is the head\n  /// of that list.\n  MacroInfoChain *MIChainHead = nullptr;\n\n  void updateOutOfDateIdentifier(IdentifierInfo &II) const;\n\npublic:\n  Preprocessor(std::shared_ptr<PreprocessorOptions> PPOpts,\n               DiagnosticsEngine &diags, LangOptions &opts, SourceManager &SM,\n               HeaderSearch &Headers, ModuleLoader &TheModuleLoader,\n               IdentifierInfoLookup *IILookup = nullptr,\n               bool OwnsHeaderSearch = false,\n               TranslationUnitKind TUKind = TU_Complete);\n\n  ~Preprocessor();\n\n  /// Initialize the preprocessor using information about the target.\n  ///\n  /// \\param Target is owned by the caller and must remain valid for the\n  /// lifetime of the preprocessor.\n  /// \\param AuxTarget is owned by the caller and must remain valid for\n  /// the lifetime of the preprocessor.\n  void Initialize(const TargetInfo &Target,\n                  const TargetInfo *AuxTarget = nullptr);\n\n  /// Initialize the preprocessor to parse a model file\n  ///\n  /// To parse model files the preprocessor of the original source is reused to\n  /// preserver the identifier table. However to avoid some duplicate\n  /// information in the preprocessor some cleanup is needed before it is used\n  /// to parse model files. This method does that cleanup.\n  void InitializeForModelFile();\n\n  /// Cleanup after model file parsing\n  void FinalizeForModelFile();\n\n  /// Retrieve the preprocessor options used to initialize this\n  /// preprocessor.\n  PreprocessorOptions &getPreprocessorOpts() const { return *PPOpts; }\n\n  DiagnosticsEngine &getDiagnostics() const { return *Diags; }\n  void setDiagnostics(DiagnosticsEngine &D) { Diags = &D; }\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n  FileManager &getFileManager() const { return FileMgr; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  HeaderSearch &getHeaderSearchInfo() const { return HeaderInfo; }\n\n  IdentifierTable &getIdentifierTable() { return Identifiers; }\n  const IdentifierTable &getIdentifierTable() const { return Identifiers; }\n  SelectorTable &getSelectorTable() { return Selectors; }\n  Builtin::Context &getBuiltinInfo() { return *BuiltinInfo; }\n  llvm::BumpPtrAllocator &getPreprocessorAllocator() { return BP; }\n\n  void setExternalSource(ExternalPreprocessorSource *Source) {\n    ExternalSource = Source;\n  }\n\n  ExternalPreprocessorSource *getExternalSource() const {\n    return ExternalSource;\n  }\n\n  /// Retrieve the module loader associated with this preprocessor.\n  ModuleLoader &getModuleLoader() const { return TheModuleLoader; }\n\n  bool hadModuleLoaderFatalFailure() const {\n    return TheModuleLoader.HadFatalFailure;\n  }\n\n  /// Retrieve the number of Directives that have been processed by the\n  /// Preprocessor.\n  unsigned getNumDirectives() const {\n    return NumDirectives;\n  }\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool isParsingIfOrElifDirective() const {\n    return ParsingIfOrElifDirective;\n  }\n\n  /// Control whether the preprocessor retains comments in output.\n  void SetCommentRetentionState(bool KeepComments, bool KeepMacroComments) {\n    this->KeepComments = KeepComments | KeepMacroComments;\n    this->KeepMacroComments = KeepMacroComments;\n  }\n\n  bool getCommentRetentionState() const { return KeepComments; }\n\n  void setPragmasEnabled(bool Enabled) { PragmasEnabled = Enabled; }\n  bool getPragmasEnabled() const { return PragmasEnabled; }\n\n  void SetSuppressIncludeNotFoundError(bool Suppress) {\n    SuppressIncludeNotFoundError = Suppress;\n  }\n\n  bool GetSuppressIncludeNotFoundError() {\n    return SuppressIncludeNotFoundError;\n  }\n\n  /// Sets whether the preprocessor is responsible for producing output or if\n  /// it is producing tokens to be consumed by Parse and Sema.\n  void setPreprocessedOutput(bool IsPreprocessedOutput) {\n    PreprocessedOutput = IsPreprocessedOutput;\n  }\n\n  /// Returns true if the preprocessor is responsible for generating output,\n  /// false if it is producing tokens to be consumed by Parse and Sema.\n  bool isPreprocessedOutput() const { return PreprocessedOutput; }\n\n  /// Return true if we are lexing directly from the specified lexer.\n  bool isCurrentLexer(const PreprocessorLexer *L) const {\n    return CurPPLexer == L;\n  }\n\n  /// Return the current lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentLexer() const { return CurPPLexer; }\n\n  /// Return the current file lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentFileLexer() const;\n\n  /// Return the submodule owning the file being lexed. This may not be\n  /// the current module if we have changed modules since entering the file.\n  Module *getCurrentLexerSubmodule() const { return CurLexerSubmodule; }\n\n  /// Returns the FileID for the preprocessor predefines.\n  FileID getPredefinesFileID() const { return PredefinesFileID; }\n\n  /// \\{\n  /// Accessors for preprocessor callbacks.\n  ///\n  /// Note that this class takes ownership of any PPCallbacks object given to\n  /// it.\n  PPCallbacks *getPPCallbacks() const { return Callbacks.get(); }\n  void addPPCallbacks(std::unique_ptr<PPCallbacks> C) {\n    if (Callbacks)\n      C = std::make_unique<PPChainedCallbacks>(std::move(C),\n                                                std::move(Callbacks));\n    Callbacks = std::move(C);\n  }\n  /// \\}\n\n  /// Get the number of tokens processed so far.\n  unsigned getTokenCount() const { return TokenCount; }\n\n  /// Get the max number of tokens before issuing a -Wmax-tokens warning.\n  unsigned getMaxTokens() const { return MaxTokens; }\n\n  void overrideMaxTokens(unsigned Value, SourceLocation Loc) {\n    MaxTokens = Value;\n    MaxTokensOverrideLoc = Loc;\n  };\n\n  SourceLocation getMaxTokensOverrideLoc() const { return MaxTokensOverrideLoc; }\n\n  /// Register a function that would be called on each token in the final\n  /// expanded token stream.\n  /// This also reports annotation tokens produced by the parser.\n  void setTokenWatcher(llvm::unique_function<void(const clang::Token &)> F) {\n    OnToken = std::move(F);\n  }\n\n  void setPreprocessToken(bool Preprocess) { PreprocessToken = Preprocess; }\n\n  bool isMacroDefined(StringRef Id) {\n    return isMacroDefined(&Identifiers.get(Id));\n  }\n  bool isMacroDefined(const IdentifierInfo *II) {\n    return II->hasMacroDefinition() &&\n           (!getLangOpts().Modules || (bool)getMacroDefinition(II));\n  }\n\n  /// Determine whether II is defined as a macro within the module M,\n  /// if that is a module that we've already preprocessed. Does not check for\n  /// macros imported into M.\n  bool isMacroDefinedInLocalModule(const IdentifierInfo *II, Module *M) {\n    if (!II->hasMacroDefinition())\n      return false;\n    auto I = Submodules.find(M);\n    if (I == Submodules.end())\n      return false;\n    auto J = I->second.Macros.find(II);\n    if (J == I->second.Macros.end())\n      return false;\n    auto *MD = J->second.getLatest();\n    return MD && MD->isDefined();\n  }\n\n  MacroDefinition getMacroDefinition(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    auto *MD = S.getLatest();\n    while (MD && isa<VisibilityMacroDirective>(MD))\n      MD = MD->getPrevious();\n    return MacroDefinition(dyn_cast_or_null<DefMacroDirective>(MD),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  MacroDefinition getMacroDefinitionAtLoc(const IdentifierInfo *II,\n                                          SourceLocation Loc) {\n    if (!II->hadMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    MacroDirective::DefInfo DI;\n    if (auto *MD = S.getLatest())\n      DI = MD->findDirectiveAtLoc(Loc, getSourceManager());\n    // FIXME: Compute the set of active module macros at the specified location.\n    return MacroDefinition(DI.getDirective(),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  /// Given an identifier, return its latest non-imported MacroDirective\n  /// if it is \\#define'd and not \\#undef'd, or null if it isn't \\#define'd.\n  MacroDirective *getLocalMacroDirective(const IdentifierInfo *II) const {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n\n    auto *MD = getLocalMacroDirectiveHistory(II);\n    if (!MD || MD->getDefinition().isUndefined())\n      return nullptr;\n\n    return MD;\n  }\n\n  const MacroInfo *getMacroInfo(const IdentifierInfo *II) const {\n    return const_cast<Preprocessor*>(this)->getMacroInfo(II);\n  }\n\n  MacroInfo *getMacroInfo(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n    if (auto MD = getMacroDefinition(II))\n      return MD.getMacroInfo();\n    return nullptr;\n  }\n\n  /// Given an identifier, return the latest non-imported macro\n  /// directive for that identifier.\n  ///\n  /// One can iterate over all previous macro directives from the most recent\n  /// one.\n  MacroDirective *getLocalMacroDirectiveHistory(const IdentifierInfo *II) const;\n\n  /// Add a directive to the macro directive history for this identifier.\n  void appendMacroDirective(IdentifierInfo *II, MacroDirective *MD);\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II, MacroInfo *MI,\n                                             SourceLocation Loc) {\n    DefMacroDirective *MD = AllocateDefMacroDirective(MI, Loc);\n    appendMacroDirective(II, MD);\n    return MD;\n  }\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II,\n                                             MacroInfo *MI) {\n    return appendDefMacroDirective(II, MI, MI->getDefinitionLoc());\n  }\n\n  /// Set a MacroDirective that was loaded from a PCH file.\n  void setLoadedMacroDirective(IdentifierInfo *II, MacroDirective *ED,\n                               MacroDirective *MD);\n\n  /// Register an exported macro for a module and identifier.\n  ModuleMacro *addModuleMacro(Module *Mod, IdentifierInfo *II, MacroInfo *Macro,\n                              ArrayRef<ModuleMacro *> Overrides, bool &IsNew);\n  ModuleMacro *getModuleMacro(Module *Mod, IdentifierInfo *II);\n\n  /// Get the list of leaf (non-overridden) module macros for a name.\n  ArrayRef<ModuleMacro*> getLeafModuleMacros(const IdentifierInfo *II) const {\n    if (II->isOutOfDate())\n      updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n    auto I = LeafModuleMacros.find(II);\n    if (I != LeafModuleMacros.end())\n      return I->second;\n    return None;\n  }\n\n  /// \\{\n  /// Iterators for the macro history table. Currently defined macros have\n  /// IdentifierInfo::hasMacroDefinition() set and an empty\n  /// MacroInfo::getUndefLoc() at the head of the list.\n  using macro_iterator = MacroMap::const_iterator;\n\n  macro_iterator macro_begin(bool IncludeExternalMacros = true) const;\n  macro_iterator macro_end(bool IncludeExternalMacros = true) const;\n\n  llvm::iterator_range<macro_iterator>\n  macros(bool IncludeExternalMacros = true) const {\n    macro_iterator begin = macro_begin(IncludeExternalMacros);\n    macro_iterator end = macro_end(IncludeExternalMacros);\n    return llvm::make_range(begin, end);\n  }\n\n  /// \\}\n\n  /// Return the name of the macro defined before \\p Loc that has\n  /// spelling \\p Tokens.  If there are multiple macros with same spelling,\n  /// return the last one defined.\n  StringRef getLastMacroWithSpelling(SourceLocation Loc,\n                                     ArrayRef<TokenValue> Tokens) const;\n\n  const std::string &getPredefines() const { return Predefines; }\n\n  /// Set the predefines for this Preprocessor.\n  ///\n  /// These predefines are automatically injected when parsing the main file.\n  void setPredefines(const char *P) { Predefines = P; }\n  void setPredefines(StringRef P) { Predefines = std::string(P); }\n\n  /// Return information about the specified preprocessor\n  /// identifier token.\n  IdentifierInfo *getIdentifierInfo(StringRef Name) const {\n    return &Identifiers.get(Name);\n  }\n\n  /// Add the specified pragma handler to this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it is a token required to exist on the\n  /// pragma line before the pragma string starts, e.g. \"STDC\" or \"GCC\".\n  void AddPragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void AddPragmaHandler(PragmaHandler *Handler) {\n    AddPragmaHandler(StringRef(), Handler);\n  }\n\n  /// Remove the specific pragma handler from this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it should be the namespace that\n  /// \\p Handler was added to. It is an error to remove a handler that\n  /// has not been registered.\n  void RemovePragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void RemovePragmaHandler(PragmaHandler *Handler) {\n    RemovePragmaHandler(StringRef(), Handler);\n  }\n\n  /// Install empty handlers for all pragmas (making them ignored).\n  void IgnorePragmas();\n\n  /// Set empty line handler.\n  void setEmptylineHandler(EmptylineHandler *Handler) { Emptyline = Handler; }\n\n  EmptylineHandler *getEmptylineHandler() const { return Emptyline; }\n\n  /// Add the specified comment handler to the preprocessor.\n  void addCommentHandler(CommentHandler *Handler);\n\n  /// Remove the specified comment handler.\n  ///\n  /// It is an error to remove a handler that has not been registered.\n  void removeCommentHandler(CommentHandler *Handler);\n\n  /// Set the code completion handler to the given object.\n  void setCodeCompletionHandler(CodeCompletionHandler &Handler) {\n    CodeComplete = &Handler;\n  }\n\n  /// Retrieve the current code-completion handler.\n  CodeCompletionHandler *getCodeCompletionHandler() const {\n    return CodeComplete;\n  }\n\n  /// Clear out the code completion handler.\n  void clearCodeCompletionHandler() {\n    CodeComplete = nullptr;\n  }\n\n  /// Hook used by the lexer to invoke the \"included file\" code\n  /// completion point.\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n\n  /// Hook used by the lexer to invoke the \"natural language\" code\n  /// completion point.\n  void CodeCompleteNaturalLanguage();\n\n  /// Set the code completion token for filtering purposes.\n  void setCodeCompletionIdentifierInfo(IdentifierInfo *Filter) {\n    CodeCompletionII = Filter;\n  }\n\n  /// Set the code completion token range for detecting replacement range later\n  /// on.\n  void setCodeCompletionTokenRange(const SourceLocation Start,\n                                   const SourceLocation End) {\n    CodeCompletionTokenRange = {Start, End};\n  }\n  SourceRange getCodeCompletionTokenRange() const {\n    return CodeCompletionTokenRange;\n  }\n\n  /// Get the code completion token for filtering purposes.\n  StringRef getCodeCompletionFilter() {\n    if (CodeCompletionII)\n      return CodeCompletionII->getName();\n    return {};\n  }\n\n  /// Retrieve the preprocessing record, or NULL if there is no\n  /// preprocessing record.\n  PreprocessingRecord *getPreprocessingRecord() const { return Record; }\n\n  /// Create a new preprocessing record, which will keep track of\n  /// all macro expansions, macro definitions, etc.\n  void createPreprocessingRecord();\n\n  /// Returns true if the FileEntry is the PCH through header.\n  bool isPCHThroughHeader(const FileEntry *FE);\n\n  /// True if creating a PCH with a through header.\n  bool creatingPCHWithThroughHeader();\n\n  /// True if using a PCH with a through header.\n  bool usingPCHWithThroughHeader();\n\n  /// True if creating a PCH with a #pragma hdrstop.\n  bool creatingPCHWithPragmaHdrStop();\n\n  /// True if using a PCH with a #pragma hdrstop.\n  bool usingPCHWithPragmaHdrStop();\n\n  /// Skip tokens until after the #include of the through header or\n  /// until after a #pragma hdrstop.\n  void SkipTokensWhileUsingPCH();\n\n  /// Process directives while skipping until the through header or\n  /// #pragma hdrstop is found.\n  void HandleSkippedDirectiveWhileUsingPCH(Token &Result,\n                                           SourceLocation HashLoc);\n\n  /// Enter the specified FileID as the main source file,\n  /// which implicitly adds the builtin defines etc.\n  void EnterMainSourceFile();\n\n  /// Inform the preprocessor callbacks that processing is complete.\n  void EndSourceFile();\n\n  /// Add a source file to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  ///\n  /// Emits a diagnostic, doesn't enter the file, and returns true on error.\n  bool EnterSourceFile(FileID FID, const DirectoryLookup *Dir,\n                       SourceLocation Loc);\n\n  /// Add a Macro to the top of the include stack and start lexing\n  /// tokens from it instead of the current buffer.\n  ///\n  /// \\param Args specifies the tokens input to a function-like macro.\n  /// \\param ILEnd specifies the location of the ')' for a function-like macro\n  /// or the identifier for an object-like macro.\n  void EnterMacro(Token &Tok, SourceLocation ILEnd, MacroInfo *Macro,\n                  MacroArgs *Args);\n\nprivate:\n  /// Add a \"macro\" context to the top of the include stack,\n  /// which will cause the lexer to start returning the specified tokens.\n  ///\n  /// If \\p DisableMacroExpansion is true, tokens lexed from the token stream\n  /// will not be subject to further macro expansion. Otherwise, these tokens\n  /// will be re-macro-expanded when/if expansion is enabled.\n  ///\n  /// If \\p OwnsTokens is false, this method assumes that the specified stream\n  /// of tokens has a permanent owner somewhere, so they do not need to be\n  /// copied. If it is true, it assumes the array of tokens is allocated with\n  /// \\c new[] and the Preprocessor will delete[] it.\n  ///\n  /// If \\p IsReinject the resulting tokens will have Token::IsReinjected flag\n  /// set, see the flag documentation for details.\n  void EnterTokenStream(const Token *Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool OwnsTokens,\n                        bool IsReinject);\n\npublic:\n  void EnterTokenStream(std::unique_ptr<Token[]> Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool IsReinject) {\n    EnterTokenStream(Toks.release(), NumToks, DisableMacroExpansion, true,\n                     IsReinject);\n  }\n\n  void EnterTokenStream(ArrayRef<Token> Toks, bool DisableMacroExpansion,\n                        bool IsReinject) {\n    EnterTokenStream(Toks.data(), Toks.size(), DisableMacroExpansion, false,\n                     IsReinject);\n  }\n\n  /// Pop the current lexer/macro exp off the top of the lexer stack.\n  ///\n  /// This should only be used in situations where the current state of the\n  /// top-of-stack lexer is known.\n  void RemoveTopOfLexerStack();\n\n  /// From the point that this method is called, and until\n  /// CommitBacktrackedTokens() or Backtrack() is called, the Preprocessor\n  /// keeps track of the lexed tokens so that a subsequent Backtrack() call will\n  /// make the Preprocessor re-lex the same tokens.\n  ///\n  /// Nested backtracks are allowed, meaning that EnableBacktrackAtThisPos can\n  /// be called multiple times and CommitBacktrackedTokens/Backtrack calls will\n  /// be combined with the EnableBacktrackAtThisPos calls in reverse order.\n  ///\n  /// NOTE: *DO NOT* forget to call either CommitBacktrackedTokens or Backtrack\n  /// at some point after EnableBacktrackAtThisPos. If you don't, caching of\n  /// tokens will continue indefinitely.\n  ///\n  void EnableBacktrackAtThisPos();\n\n  /// Disable the last EnableBacktrackAtThisPos call.\n  void CommitBacktrackedTokens();\n\n  /// Make Preprocessor re-lex the tokens that were lexed since\n  /// EnableBacktrackAtThisPos() was previously called.\n  void Backtrack();\n\n  /// True if EnableBacktrackAtThisPos() was called and\n  /// caching of tokens is on.\n  bool isBacktrackEnabled() const { return !BacktrackPositions.empty(); }\n\n  /// Lex the next token for this preprocessor.\n  void Lex(Token &Result);\n\n  /// Lex a token, forming a header-name token if possible.\n  bool LexHeaderName(Token &Result, bool AllowMacroExpansion = true);\n\n  bool LexAfterModuleImport(Token &Result);\n  void CollectPpImportSuffix(SmallVectorImpl<Token> &Toks);\n\n  void makeModuleVisible(Module *M, SourceLocation Loc);\n\n  SourceLocation getModuleImportLoc(Module *M) const {\n    return CurSubmoduleState->VisibleModules.getImportLoc(M);\n  }\n\n  /// Lex a string literal, which may be the concatenation of multiple\n  /// string literals and may even come from macro expansion.\n  /// \\returns true on success, false if a error diagnostic has been generated.\n  bool LexStringLiteral(Token &Result, std::string &String,\n                        const char *DiagnosticTag, bool AllowMacroExpansion) {\n    if (AllowMacroExpansion)\n      Lex(Result);\n    else\n      LexUnexpandedToken(Result);\n    return FinishLexStringLiteral(Result, String, DiagnosticTag,\n                                  AllowMacroExpansion);\n  }\n\n  /// Complete the lexing of a string literal where the first token has\n  /// already been lexed (see LexStringLiteral).\n  bool FinishLexStringLiteral(Token &Result, std::string &String,\n                              const char *DiagnosticTag,\n                              bool AllowMacroExpansion);\n\n  /// Lex a token.  If it's a comment, keep lexing until we get\n  /// something not a comment.\n  ///\n  /// This is useful in -E -C mode where comments would foul up preprocessor\n  /// directive handling.\n  void LexNonComment(Token &Result) {\n    do\n      Lex(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Just like Lex, but disables macro expansion of identifier tokens.\n  void LexUnexpandedToken(Token &Result) {\n    // Disable macro expansion.\n    bool OldVal = DisableMacroExpansion;\n    DisableMacroExpansion = true;\n    // Lex the token.\n    Lex(Result);\n\n    // Reenable it.\n    DisableMacroExpansion = OldVal;\n  }\n\n  /// Like LexNonComment, but this disables macro expansion of\n  /// identifier tokens.\n  void LexUnexpandedNonComment(Token &Result) {\n    do\n      LexUnexpandedToken(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Parses a simple integer literal to get its numeric value.  Floating\n  /// point literals and user defined literals are rejected.  Used primarily to\n  /// handle pragmas that accept integer arguments.\n  bool parseSimpleIntegerLiteral(Token &Tok, uint64_t &Value);\n\n  /// Disables macro expansion everywhere except for preprocessor directives.\n  void SetMacroExpansionOnlyInDirectives() {\n    DisableMacroExpansion = true;\n    MacroExpansionInDirectivesOverride = true;\n  }\n\n  /// Peeks ahead N tokens and returns that token without consuming any\n  /// tokens.\n  ///\n  /// LookAhead(0) returns the next token that would be returned by Lex(),\n  /// LookAhead(1) returns the token after it, etc.  This returns normal\n  /// tokens after phase 5.  As such, it is equivalent to using\n  /// 'Lex', not 'LexUnexpandedToken'.\n  const Token &LookAhead(unsigned N) {\n    assert(LexLevel == 0 && \"cannot use lookahead while lexing\");\n    if (CachedLexPos + N < CachedTokens.size())\n      return CachedTokens[CachedLexPos+N];\n    else\n      return PeekAhead(N+1);\n  }\n\n  /// When backtracking is enabled and tokens are cached,\n  /// this allows to revert a specific number of tokens.\n  ///\n  /// Note that the number of tokens being reverted should be up to the last\n  /// backtrack position, not more.\n  void RevertCachedTokens(unsigned N) {\n    assert(isBacktrackEnabled() &&\n           \"Should only be called when tokens are cached for backtracking\");\n    assert(signed(CachedLexPos) - signed(N) >= signed(BacktrackPositions.back())\n         && \"Should revert tokens up to the last backtrack position, not more\");\n    assert(signed(CachedLexPos) - signed(N) >= 0 &&\n           \"Corrupted backtrack positions ?\");\n    CachedLexPos -= N;\n  }\n\n  /// Enters a token in the token stream to be lexed next.\n  ///\n  /// If BackTrack() is called afterwards, the token will remain at the\n  /// insertion point.\n  /// If \\p IsReinject is true, resulting token will have Token::IsReinjected\n  /// flag set. See the flag documentation for details.\n  void EnterToken(const Token &Tok, bool IsReinject) {\n    if (LexLevel) {\n      // It's not correct in general to enter caching lex mode while in the\n      // middle of a nested lexing action.\n      auto TokCopy = std::make_unique<Token[]>(1);\n      TokCopy[0] = Tok;\n      EnterTokenStream(std::move(TokCopy), 1, true, IsReinject);\n    } else {\n      EnterCachingLexMode();\n      assert(IsReinject && \"new tokens in the middle of cached stream\");\n      CachedTokens.insert(CachedTokens.begin()+CachedLexPos, Tok);\n    }\n  }\n\n  /// We notify the Preprocessor that if it is caching tokens (because\n  /// backtrack is enabled) it should replace the most recent cached tokens\n  /// with the given annotation token. This function has no effect if\n  /// backtracking is not enabled.\n  ///\n  /// Note that the use of this function is just for optimization, so that the\n  /// cached tokens doesn't get re-parsed and re-resolved after a backtrack is\n  /// invoked.\n  void AnnotateCachedTokens(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      AnnotatePreviousCachedTokens(Tok);\n  }\n\n  /// Get the location of the last cached token, suitable for setting the end\n  /// location of an annotation token.\n  SourceLocation getLastCachedTokenLocation() const {\n    assert(CachedLexPos != 0);\n    return CachedTokens[CachedLexPos-1].getLastLoc();\n  }\n\n  /// Whether \\p Tok is the most recent token (`CachedLexPos - 1`) in\n  /// CachedTokens.\n  bool IsPreviousCachedToken(const Token &Tok) const;\n\n  /// Replace token in `CachedLexPos - 1` in CachedTokens by the tokens\n  /// in \\p NewToks.\n  ///\n  /// Useful when a token needs to be split in smaller ones and CachedTokens\n  /// most recent token must to be updated to reflect that.\n  void ReplacePreviousCachedToken(ArrayRef<Token> NewToks);\n\n  /// Replace the last token with an annotation token.\n  ///\n  /// Like AnnotateCachedTokens(), this routine replaces an\n  /// already-parsed (and resolved) token with an annotation\n  /// token. However, this routine only replaces the last token with\n  /// the annotation token; it does not affect any other cached\n  /// tokens. This function has no effect if backtracking is not\n  /// enabled.\n  void ReplaceLastTokenWithAnnotation(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Enter an annotation token into the token stream.\n  void EnterAnnotationToken(SourceRange Range, tok::TokenKind Kind,\n                            void *AnnotationVal);\n\n  /// Determine whether it's possible for a future call to Lex to produce an\n  /// annotation token created by a previous call to EnterAnnotationToken.\n  bool mightHavePendingAnnotationTokens() {\n    return CurLexerKind != CLK_Lexer;\n  }\n\n  /// Update the current token to represent the provided\n  /// identifier, in order to cache an action performed by typo correction.\n  void TypoCorrectToken(const Token &Tok) {\n    assert(Tok.getIdentifierInfo() && \"Expected identifier token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Recompute the current lexer kind based on the CurLexer/\n  /// CurTokenLexer pointers.\n  void recomputeCurLexerKind();\n\n  /// Returns true if incremental processing is enabled\n  bool isIncrementalProcessingEnabled() const { return IncrementalProcessing; }\n\n  /// Enables the incremental processing\n  void enableIncrementalProcessing(bool value = true) {\n    IncrementalProcessing = value;\n  }\n\n  /// Specify the point at which code-completion will be performed.\n  ///\n  /// \\param File the file in which code completion should occur. If\n  /// this file is included multiple times, code-completion will\n  /// perform completion the first time it is included. If NULL, this\n  /// function clears out the code-completion point.\n  ///\n  /// \\param Line the line at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\param Column the column at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SetCodeCompletionPoint(const FileEntry *File,\n                              unsigned Line, unsigned Column);\n\n  /// Determine if we are performing code completion.\n  bool isCodeCompletionEnabled() const { return CodeCompletionFile != nullptr; }\n\n  /// Returns the location of the code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionLoc() const { return CodeCompletionLoc; }\n\n  /// Returns the start location of the file of code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionFileLoc() const {\n    return CodeCompletionFileLoc;\n  }\n\n  /// Returns true if code-completion is enabled and we have hit the\n  /// code-completion point.\n  bool isCodeCompletionReached() const { return CodeCompletionReached; }\n\n  /// Note that we hit the code-completion point.\n  void setCodeCompletionReached() {\n    assert(isCodeCompletionEnabled() && \"Code-completion not enabled!\");\n    CodeCompletionReached = true;\n    // Silence any diagnostics that occur after we hit the code-completion.\n    getDiagnostics().setSuppressAllDiagnostics(true);\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  std::pair<IdentifierInfo *, SourceLocation>\n  getPragmaARCCFCodeAuditedInfo() const {\n    return PragmaARCCFCodeAuditedInfo;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.  An invalid location ends the pragma.\n  void setPragmaARCCFCodeAuditedInfo(IdentifierInfo *Ident,\n                                     SourceLocation Loc) {\n    PragmaARCCFCodeAuditedInfo = {Ident, Loc};\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  SourceLocation getPragmaAssumeNonNullLoc() const {\n    return PragmaAssumeNonNullLoc;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.  An invalid location ends the pragma.\n  void setPragmaAssumeNonNullLoc(SourceLocation Loc) {\n    PragmaAssumeNonNullLoc = Loc;\n  }\n\n  /// Set the directory in which the main file should be considered\n  /// to have been found, if it is not a real file.\n  void setMainFileDir(const DirectoryEntry *Dir) {\n    MainFileDir = Dir;\n  }\n\n  /// Instruct the preprocessor to skip part of the main source file.\n  ///\n  /// \\param Bytes The number of bytes in the preamble to skip.\n  ///\n  /// \\param StartOfLine Whether skipping these bytes puts the lexer at the\n  /// start of a line.\n  void setSkipMainFilePreamble(unsigned Bytes, bool StartOfLine) {\n    SkipMainFilePreamble.first = Bytes;\n    SkipMainFilePreamble.second = StartOfLine;\n  }\n\n  /// Forwarding function for diagnostics.  This emits a diagnostic at\n  /// the specified Token's location, translating the token's start\n  /// position in the current buffer into a SourcePosition object for rendering.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const {\n    return Diags->Report(Loc, DiagID);\n  }\n\n  DiagnosticBuilder Diag(const Token &Tok, unsigned DiagID) const {\n    return Diags->Report(Tok.getLocation(), DiagID);\n  }\n\n  /// Return the 'spelling' of the token at the given\n  /// location; does not go up to the spelling location or down to the\n  /// expansion location.\n  ///\n  /// \\param buffer A buffer which will be used only if the token requires\n  ///   \"cleaning\", e.g. if it contains trigraphs or escaped newlines\n  /// \\param invalid If non-null, will be set \\c true if an error occurs.\n  StringRef getSpelling(SourceLocation loc,\n                        SmallVectorImpl<char> &buffer,\n                        bool *invalid = nullptr) const {\n    return Lexer::getSpelling(loc, buffer, SourceMgr, LangOpts, invalid);\n  }\n\n  /// Return the 'spelling' of the Tok token.\n  ///\n  /// The spelling of a token is the characters used to represent the token in\n  /// the source file after trigraph expansion and escaped-newline folding.  In\n  /// particular, this wants to get the true, uncanonicalized, spelling of\n  /// things like digraphs, UCNs, etc.\n  ///\n  /// \\param Invalid If non-null, will be set \\c true if an error occurs.\n  std::string getSpelling(const Token &Tok, bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a preallocated buffer, instead\n  /// of as an std::string.\n  ///\n  /// The caller is required to allocate enough space for the token, which is\n  /// guaranteed to be at least Tok.getLength() bytes long. The length of the\n  /// actual result is returned.\n  ///\n  /// Note that this method may do two possible things: it may either fill in\n  /// the buffer specified with characters, or it may *change the input pointer*\n  /// to point to a constant buffer with the data already in it (avoiding a\n  /// copy).  The caller is not allowed to modify the returned buffer pointer\n  /// if an internal buffer is returned.\n  unsigned getSpelling(const Token &Tok, const char *&Buffer,\n                       bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, Buffer, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a SmallVector.\n  ///\n  /// Note that the returned StringRef may not point to the\n  /// supplied buffer if a copy can be avoided.\n  StringRef getSpelling(const Token &Tok,\n                        SmallVectorImpl<char> &Buffer,\n                        bool *Invalid = nullptr) const;\n\n  /// Relex the token at the specified location.\n  /// \\returns true if there was a failure, false on success.\n  bool getRawToken(SourceLocation Loc, Token &Result,\n                   bool IgnoreWhiteSpace = false) {\n    return Lexer::getRawToken(Loc, Result, SourceMgr, LangOpts, IgnoreWhiteSpace);\n  }\n\n  /// Given a Token \\p Tok that is a numeric constant with length 1,\n  /// return the character.\n  char\n  getSpellingOfSingleCharacterNumericConstant(const Token &Tok,\n                                              bool *Invalid = nullptr) const {\n    assert(Tok.is(tok::numeric_constant) &&\n           Tok.getLength() == 1 && \"Called on unsupported token\");\n    assert(!Tok.needsCleaning() && \"Token can't need cleaning with length 1\");\n\n    // If the token is carrying a literal data pointer, just use it.\n    if (const char *D = Tok.getLiteralData())\n      return *D;\n\n    // Otherwise, fall back on getCharacterData, which is slower, but always\n    // works.\n    return *SourceMgr.getCharacterData(Tok.getLocation(), Invalid);\n  }\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the\n  /// macro responsible for its immediate expansion. It looks through any\n  /// intervening macro argument expansions to compute this. It returns a\n  /// StringRef that refers to the SourceManager-owned buffer of the source\n  /// where that macro name is spelled. Thus, the result shouldn't out-live\n  /// the SourceManager.\n  StringRef getImmediateMacroName(SourceLocation Loc) {\n    return Lexer::getImmediateMacroName(Loc, SourceMgr, getLangOpts());\n  }\n\n  /// Plop the specified string into a scratch buffer and set the\n  /// specified token's location and length to it.\n  ///\n  /// If specified, the source location provides a location of the expansion\n  /// point of the token.\n  void CreateString(StringRef Str, Token &Tok,\n                    SourceLocation ExpansionLocStart = SourceLocation(),\n                    SourceLocation ExpansionLocEnd = SourceLocation());\n\n  /// Split the first Length characters out of the token starting at TokLoc\n  /// and return a location pointing to the split token. Re-lexing from the\n  /// split token will return the split token rather than the original.\n  SourceLocation SplitToken(SourceLocation TokLoc, unsigned Length);\n\n  /// Computes the source location just past the end of the\n  /// token at this source location.\n  ///\n  /// This routine can be used to produce a source location that\n  /// points just past the end of the token referenced by \\p Loc, and\n  /// is generally used when a diagnostic needs to point just after a\n  /// token where it expected something different that it received. If\n  /// the returned source location would not be meaningful (e.g., if\n  /// it points into a macro), this routine returns an invalid\n  /// source location.\n  ///\n  /// \\param Offset an offset from the end of the token, where the source\n  /// location should refer to. The default offset (0) produces a source\n  /// location pointing just past the end of the token; an offset of 1 produces\n  /// a source location pointing to the last character in the token, etc.\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0) {\n    return Lexer::getLocForEndOfToken(Loc, Offset, SourceMgr, LangOpts);\n  }\n\n  /// Returns true if the given MacroID location points at the first\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to\n  /// begin location of the macro.\n  bool isAtStartOfMacroExpansion(SourceLocation loc,\n                                 SourceLocation *MacroBegin = nullptr) const {\n    return Lexer::isAtStartOfMacroExpansion(loc, SourceMgr, LangOpts,\n                                            MacroBegin);\n  }\n\n  /// Returns true if the given MacroID location points at the last\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to\n  /// end location of the macro.\n  bool isAtEndOfMacroExpansion(SourceLocation loc,\n                               SourceLocation *MacroEnd = nullptr) const {\n    return Lexer::isAtEndOfMacroExpansion(loc, SourceMgr, LangOpts, MacroEnd);\n  }\n\n  /// Print the token to stderr, used for debugging.\n  void DumpToken(const Token &Tok, bool DumpFlags = false) const;\n  void DumpLocation(SourceLocation Loc) const;\n  void DumpMacro(const MacroInfo &MI) const;\n  void dumpMacroInfo(const IdentifierInfo *II);\n\n  /// Given a location that specifies the start of a\n  /// token, return a new location that specifies a character within the token.\n  SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,\n                                         unsigned Char) const {\n    return Lexer::AdvanceToTokenCharacter(TokStart, Char, SourceMgr, LangOpts);\n  }\n\n  /// Increment the counters for the number of token paste operations\n  /// performed.\n  ///\n  /// If fast was specified, this is a 'fast paste' case we handled.\n  void IncrementPasteCounter(bool isFast) {\n    if (isFast)\n      ++NumFastTokenPaste;\n    else\n      ++NumTokenPaste;\n  }\n\n  void PrintStats();\n\n  size_t getTotalMemory() const;\n\n  /// When the macro expander pastes together a comment (/##/) in Microsoft\n  /// mode, this method handles updating the current state, returning the\n  /// token on the next source line.\n  void HandleMicrosoftCommentPaste(Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  // Preprocessor callback methods.  These are invoked by a lexer as various\n  // directives and events are found.\n\n  /// Given a tok::raw_identifier token, look up the\n  /// identifier information for the token and install it into the token,\n  /// updating the token kind accordingly.\n  IdentifierInfo *LookUpIdentifierInfo(Token &Identifier) const;\n\nprivate:\n  llvm::DenseMap<IdentifierInfo*,unsigned> PoisonReasons;\n\npublic:\n  /// Specifies the reason for poisoning an identifier.\n  ///\n  /// If that identifier is accessed while poisoned, then this reason will be\n  /// used instead of the default \"poisoned\" diagnostic.\n  void SetPoisonReason(IdentifierInfo *II, unsigned DiagID);\n\n  /// Display reason for poisoned identifier.\n  void HandlePoisonedIdentifier(Token & Identifier);\n\n  void MaybeHandlePoisonedIdentifier(Token & Identifier) {\n    if(IdentifierInfo * II = Identifier.getIdentifierInfo()) {\n      if(II->isPoisoned()) {\n        HandlePoisonedIdentifier(Identifier);\n      }\n    }\n  }\n\nprivate:\n  /// Identifiers used for SEH handling in Borland. These are only\n  /// allowed in particular circumstances\n  // __except block\n  IdentifierInfo *Ident__exception_code,\n                 *Ident___exception_code,\n                 *Ident_GetExceptionCode;\n  // __except filter expression\n  IdentifierInfo *Ident__exception_info,\n                 *Ident___exception_info,\n                 *Ident_GetExceptionInfo;\n  // __finally\n  IdentifierInfo *Ident__abnormal_termination,\n                 *Ident___abnormal_termination,\n                 *Ident_AbnormalTermination;\n\n  const char *getCurLexerEndPos();\n  void diagnoseMissingHeaderInUmbrellaDir(const Module &Mod);\n\npublic:\n  void PoisonSEHIdentifiers(bool Poison = true); // Borland\n\n  /// Callback invoked when the lexer reads an identifier and has\n  /// filled in the tokens IdentifierInfo member.\n  ///\n  /// This callback potentially macro expands it or turns it into a named\n  /// token (like 'for').\n  ///\n  /// \\returns true if we actually computed a token, false if we need to\n  /// lex again.\n  bool HandleIdentifier(Token &Identifier);\n\n  /// Callback invoked when the lexer hits the end of the current file.\n  ///\n  /// This either returns the EOF token and returns true, or\n  /// pops a level off the include stack and returns false, at which point the\n  /// client should call lex again.\n  bool HandleEndOfFile(Token &Result, bool isEndOfMacro = false);\n\n  /// Callback invoked when the current TokenLexer hits the end of its\n  /// token stream.\n  bool HandleEndOfTokenLexer(Token &Result);\n\n  /// Callback invoked when the lexer sees a # token at the start of a\n  /// line.\n  ///\n  /// This consumes the directive, modifies the lexer/preprocessor state, and\n  /// advances the lexer(s) so that the next token read is the correct one.\n  void HandleDirective(Token &Result);\n\n  /// Ensure that the next token is a tok::eod token.\n  ///\n  /// If not, emit a diagnostic and consume up until the eod.\n  /// If \\p EnableMacros is true, then we consider macros that expand to zero\n  /// tokens as being ok.\n  ///\n  /// \\return The location of the end of the directive (the terminating\n  /// newline).\n  SourceLocation CheckEndOfDirective(const char *DirType,\n                                     bool EnableMacros = false);\n\n  /// Read and discard all tokens remaining on the current line until\n  /// the tok::eod token is found. Returns the range of the skipped tokens.\n  SourceRange DiscardUntilEndOfDirective();\n\n  /// Returns true if the preprocessor has seen a use of\n  /// __DATE__ or __TIME__ in the file so far.\n  bool SawDateOrTime() const {\n    return DATELoc != SourceLocation() || TIMELoc != SourceLocation();\n  }\n  unsigned getCounterValue() const { return CounterValue; }\n  void setCounterValue(unsigned V) { CounterValue = V; }\n\n  /// Retrieves the module that we're currently building, if any.\n  Module *getCurrentModule();\n\n  /// Allocate a new MacroInfo object with the provided SourceLocation.\n  MacroInfo *AllocateMacroInfo(SourceLocation L);\n\n  /// Turn the specified lexer token into a fully checked and spelled\n  /// filename, e.g. as an operand of \\#include.\n  ///\n  /// The caller is expected to provide a buffer that is large enough to hold\n  /// the spelling of the filename, but is also expected to handle the case\n  /// when this method decides to use a different buffer.\n  ///\n  /// \\returns true if the input filename was in <>'s or false if it was\n  /// in \"\"'s.\n  bool GetIncludeFilenameSpelling(SourceLocation Loc,StringRef &Buffer);\n\n  /// Given a \"foo\" or \\<foo> reference, look up the indicated file.\n  ///\n  /// Returns None on failure.  \\p isAngled indicates whether the file\n  /// reference is for system \\#include's or not (i.e. using <> instead of \"\").\n  Optional<FileEntryRef>\n  LookupFile(SourceLocation FilenameLoc, StringRef Filename, bool isAngled,\n             const DirectoryLookup *FromDir, const FileEntry *FromFile,\n             const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,\n             SmallVectorImpl<char> *RelativePath,\n             ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,\n             bool *IsFrameworkFound, bool SkipCache = false);\n\n  /// Get the DirectoryLookup structure used to find the current\n  /// FileEntry, if CurLexer is non-null and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *GetCurDirLookup() { return CurDirLookup; }\n\n  /// Return true if we're in the top-level file, not in a \\#include.\n  bool isInPrimaryFile() const;\n\n  /// Lex an on-off-switch (C99 6.10.6p2) and verify that it is\n  /// followed by EOD.  Return true if the token is not a valid on-off-switch.\n  bool LexOnOffSwitch(tok::OnOffSwitch &Result);\n\n  bool CheckMacroName(Token &MacroNameTok, MacroUse isDefineUndef,\n                      bool *ShadowFlag = nullptr);\n\n  void EnterSubmodule(Module *M, SourceLocation ImportLoc, bool ForPragma);\n  Module *LeaveSubmodule(bool ForPragma);\n\nprivate:\n  friend void TokenLexer::ExpandFunctionArguments();\n\n  void PushIncludeMacroStack() {\n    assert(CurLexerKind != CLK_CachingLexer && \"cannot push a caching lexer\");\n    IncludeMacroStack.emplace_back(CurLexerKind, CurLexerSubmodule,\n                                   std::move(CurLexer), CurPPLexer,\n                                   std::move(CurTokenLexer), CurDirLookup);\n    CurPPLexer = nullptr;\n  }\n\n  void PopIncludeMacroStack() {\n    CurLexer = std::move(IncludeMacroStack.back().TheLexer);\n    CurPPLexer = IncludeMacroStack.back().ThePPLexer;\n    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);\n    CurDirLookup  = IncludeMacroStack.back().TheDirLookup;\n    CurLexerSubmodule = IncludeMacroStack.back().TheSubmodule;\n    CurLexerKind = IncludeMacroStack.back().CurLexerKind;\n    IncludeMacroStack.pop_back();\n  }\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n\n  /// Determine whether we need to create module macros for #defines in the\n  /// current context.\n  bool needModuleMacros() const;\n\n  /// Update the set of active module macros and ambiguity flag for a module\n  /// macro name.\n  void updateModuleMacroInfo(const IdentifierInfo *II, ModuleMacroInfo &Info);\n\n  DefMacroDirective *AllocateDefMacroDirective(MacroInfo *MI,\n                                               SourceLocation Loc);\n  UndefMacroDirective *AllocateUndefMacroDirective(SourceLocation UndefLoc);\n  VisibilityMacroDirective *AllocateVisibilityMacroDirective(SourceLocation Loc,\n                                                             bool isPublic);\n\n  /// Lex and validate a macro name, which occurs after a\n  /// \\#define or \\#undef.\n  ///\n  /// \\param MacroNameTok Token that represents the name defined or undefined.\n  /// \\param IsDefineUndef Kind if preprocessor directive.\n  /// \\param ShadowFlag Points to flag that is set if macro name shadows\n  ///                   a keyword.\n  ///\n  /// This emits a diagnostic, sets the token kind to eod,\n  /// and discards the rest of the macro line if the macro name is invalid.\n  void ReadMacroName(Token &MacroNameTok, MacroUse IsDefineUndef = MU_Other,\n                     bool *ShadowFlag = nullptr);\n\n  /// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the\n  /// entire line) of the macro's tokens and adds them to MacroInfo, and while\n  /// doing so performs certain validity checks including (but not limited to):\n  ///   - # (stringization) is followed by a macro parameter\n  /// \\param MacroNameTok - Token that represents the macro name\n  /// \\param ImmediatelyAfterHeaderGuard - Macro follows an #ifdef header guard\n  ///\n  ///  Either returns a pointer to a MacroInfo object OR emits a diagnostic and\n  ///  returns a nullptr if an invalid sequence of tokens is encountered.\n  MacroInfo *ReadOptionalMacroParameterListAndBody(\n      const Token &MacroNameTok, bool ImmediatelyAfterHeaderGuard);\n\n  /// The ( starting an argument list of a macro definition has just been read.\n  /// Lex the rest of the parameters and the closing ), updating \\p MI with\n  /// what we learn and saving in \\p LastTok the last token read.\n  /// Return true if an error occurs parsing the arg list.\n  bool ReadMacroParameterList(MacroInfo *MI, Token& LastTok);\n\n  /// We just read a \\#if or related directive and decided that the\n  /// subsequent tokens are in the \\#if'd out portion of the\n  /// file.  Lex the rest of the file, until we see an \\#endif.  If \\p\n  /// FoundNonSkipPortion is true, then we have already emitted code for part of\n  /// this \\#if directive, so \\#else/\\#elif blocks should never be entered. If\n  /// \\p FoundElse is false, then \\#else directives are ok, if not, then we have\n  /// already seen one so a \\#else directive is a duplicate.  When this returns,\n  /// the caller can lex the first valid token.\n  void SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,\n                                    SourceLocation IfTokenLoc,\n                                    bool FoundNonSkipPortion, bool FoundElse,\n                                    SourceLocation ElseLoc = SourceLocation());\n\n  /// Information about the result for evaluating an expression for a\n  /// preprocessor directive.\n  struct DirectiveEvalResult {\n    /// Whether the expression was evaluated as true or not.\n    bool Conditional;\n\n    /// True if the expression contained identifiers that were undefined.\n    bool IncludedUndefinedIds;\n\n    /// The source range for the expression.\n    SourceRange ExprRange;\n  };\n\n  /// Evaluate an integer constant expression that may occur after a\n  /// \\#if or \\#elif directive and return a \\p DirectiveEvalResult object.\n  ///\n  /// If the expression is equivalent to \"!defined(X)\" return X in IfNDefMacro.\n  DirectiveEvalResult EvaluateDirectiveExpression(IdentifierInfo *&IfNDefMacro);\n\n  /// Install the standard preprocessor pragmas:\n  /// \\#pragma GCC poison/system_header/dependency and \\#pragma once.\n  void RegisterBuiltinPragmas();\n\n  /// Register builtin macros such as __LINE__ with the identifier table.\n  void RegisterBuiltinMacros();\n\n  /// If an identifier token is read that is to be expanded as a macro, handle\n  /// it and return the next token as 'Tok'.  If we lexed a token, return true;\n  /// otherwise the caller should lex again.\n  bool HandleMacroExpandedIdentifier(Token &Identifier, const MacroDefinition &MD);\n\n  /// Cache macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  Token *cacheMacroExpandedTokens(TokenLexer *tokLexer,\n                                  ArrayRef<Token> tokens);\n\n  void removeCachedMacroExpandedTokensOfLastLexer();\n\n  /// Determine whether the next preprocessor token to be\n  /// lexed is a '('.  If so, consume the token and return true, if not, this\n  /// method should have no observable side-effect on the lexed tokens.\n  bool isNextPPTokenLParen();\n\n  /// After reading \"MACRO(\", this method is invoked to read all of the formal\n  /// arguments specified for the macro invocation.  Returns null on error.\n  MacroArgs *ReadMacroCallArgumentList(Token &MacroName, MacroInfo *MI,\n                                       SourceLocation &MacroEnd);\n\n  /// If an identifier token is read that is to be expanded\n  /// as a builtin macro, handle it and return the next token as 'Tok'.\n  void ExpandBuiltinMacro(Token &Tok);\n\n  /// Read a \\c _Pragma directive, slice it up, process it, then\n  /// return the first token after the directive.\n  /// This assumes that the \\c _Pragma token has just been read into \\p Tok.\n  void Handle_Pragma(Token &Tok);\n\n  /// Like Handle_Pragma except the pragma text is not enclosed within\n  /// a string literal.\n  void HandleMicrosoft__pragma(Token &Tok);\n\n  /// Add a lexer to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  void EnterSourceFileWithLexer(Lexer *TheLexer, const DirectoryLookup *Dir);\n\n  /// Set the FileID for the preprocessor predefines.\n  void setPredefinesFileID(FileID FID) {\n    assert(PredefinesFileID.isInvalid() && \"PredefinesFileID already set!\");\n    PredefinesFileID = FID;\n  }\n\n  /// Set the FileID for the PCH through header.\n  void setPCHThroughHeaderFileID(FileID FID);\n\n  /// Returns true if we are lexing from a file and not a\n  /// pragma or a macro.\n  static bool IsFileLexer(const Lexer* L, const PreprocessorLexer* P) {\n    return L ? !L->isPragmaLexer() : P != nullptr;\n  }\n\n  static bool IsFileLexer(const IncludeStackInfo& I) {\n    return IsFileLexer(I.TheLexer.get(), I.ThePPLexer);\n  }\n\n  bool IsFileLexer() const {\n    return IsFileLexer(CurLexer.get(), CurPPLexer);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Caching stuff.\n  void CachingLex(Token &Result);\n\n  bool InCachingLexMode() const {\n    // If the Lexer pointers are 0 and IncludeMacroStack is empty, it means\n    // that we are past EOF, not that we are in CachingLex mode.\n    return !CurPPLexer && !CurTokenLexer && !IncludeMacroStack.empty();\n  }\n\n  void EnterCachingLexMode();\n  void EnterCachingLexModeUnchecked();\n\n  void ExitCachingLexMode() {\n    if (InCachingLexMode())\n      RemoveTopOfLexerStack();\n  }\n\n  const Token &PeekAhead(unsigned N);\n  void AnnotatePreviousCachedTokens(const Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  /// Handle*Directive - implement the various preprocessor directives.  These\n  /// should side-effect the current preprocessor object so that the next call\n  /// to Lex() will return the appropriate token next.\n  void HandleLineDirective();\n  void HandleDigitDirective(Token &Tok);\n  void HandleUserDiagnosticDirective(Token &Tok, bool isWarning);\n  void HandleIdentSCCSDirective(Token &Tok);\n  void HandleMacroPublicDirective(Token &Tok);\n  void HandleMacroPrivateDirective();\n\n  /// An additional notification that can be produced by a header inclusion or\n  /// import to tell the parser what happened.\n  struct ImportAction {\n    enum ActionKind {\n      None,\n      ModuleBegin,\n      ModuleImport,\n      SkippedModuleImport,\n      Failure,\n    } Kind;\n    Module *ModuleForHeader = nullptr;\n\n    ImportAction(ActionKind AK, Module *Mod = nullptr)\n        : Kind(AK), ModuleForHeader(Mod) {\n      assert((AK == None || Mod || AK == Failure) &&\n             \"no module for module action\");\n    }\n  };\n\n  Optional<FileEntryRef> LookupHeaderIncludeOrImport(\n      const DirectoryLookup *&CurDir, StringRef &Filename,\n      SourceLocation FilenameLoc, CharSourceRange FilenameRange,\n      const Token &FilenameTok, bool &IsFrameworkFound, bool IsImportDecl,\n      bool &IsMapped, const DirectoryLookup *LookupFrom,\n      const FileEntry *LookupFromFile, StringRef &LookupFilename,\n      SmallVectorImpl<char> &RelativePath, SmallVectorImpl<char> &SearchPath,\n      ModuleMap::KnownHeader &SuggestedModule, bool isAngled);\n\n  // File inclusion.\n  void HandleIncludeDirective(SourceLocation HashLoc, Token &Tok,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  ImportAction\n  HandleHeaderIncludeOrImport(SourceLocation HashLoc, Token &IncludeTok,\n                              Token &FilenameTok, SourceLocation EndLoc,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  void HandleIncludeNextDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleIncludeMacrosDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleImportDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleMicrosoftImportDirective(Token &Tok);\n\npublic:\n  /// Check that the given module is available, producing a diagnostic if not.\n  /// \\return \\c true if the check failed (because the module is not available).\n  ///         \\c false if the module appears to be usable.\n  static bool checkModuleIsAvailable(const LangOptions &LangOpts,\n                                     const TargetInfo &TargetInfo,\n                                     DiagnosticsEngine &Diags, Module *M);\n\n  // Module inclusion testing.\n  /// Find the module that owns the source or header file that\n  /// \\p Loc points to. If the location is in a file that was included\n  /// into a module, or is outside any module, returns nullptr.\n  Module *getModuleForLocation(SourceLocation Loc);\n\n  /// We want to produce a diagnostic at location IncLoc concerning an\n  /// unreachable effect at location MLoc (eg, where a desired entity was\n  /// declared or defined). Determine whether the right way to make MLoc\n  /// reachable is by #include, and if so, what header should be included.\n  ///\n  /// This is not necessarily fast, and might load unexpected module maps, so\n  /// should only be called by code that intends to produce an error.\n  ///\n  /// \\param IncLoc The location at which the missing effect was detected.\n  /// \\param MLoc A location within an unimported module at which the desired\n  ///        effect occurred.\n  /// \\return A file that can be #included to provide the desired effect. Null\n  ///         if no such file could be determined or if a #include is not\n  ///         appropriate (eg, if a module should be imported instead).\n  const FileEntry *getHeaderToIncludeForDiagnostics(SourceLocation IncLoc,\n                                                    SourceLocation MLoc);\n\n  bool isRecordingPreamble() const {\n    return PreambleConditionalStack.isRecording();\n  }\n\n  bool hasRecordedPreamble() const {\n    return PreambleConditionalStack.hasRecordedPreamble();\n  }\n\n  ArrayRef<PPConditionalInfo> getPreambleConditionalStack() const {\n      return PreambleConditionalStack.getStack();\n  }\n\n  void setRecordedPreambleConditionalStack(ArrayRef<PPConditionalInfo> s) {\n    PreambleConditionalStack.setStack(s);\n  }\n\n  void setReplayablePreambleConditionalStack(ArrayRef<PPConditionalInfo> s,\n                                             llvm::Optional<PreambleSkipInfo> SkipInfo) {\n    PreambleConditionalStack.startReplaying();\n    PreambleConditionalStack.setStack(s);\n    PreambleConditionalStack.SkipInfo = SkipInfo;\n  }\n\n  llvm::Optional<PreambleSkipInfo> getPreambleSkipInfo() const {\n    return PreambleConditionalStack.SkipInfo;\n  }\n\nprivate:\n  /// After processing predefined file, initialize the conditional stack from\n  /// the preamble.\n  void replayPreambleConditionalStack();\n\n  // Macro handling.\n  void HandleDefineDirective(Token &Tok, bool ImmediatelyAfterHeaderGuard);\n  void HandleUndefDirective();\n\n  // Conditional Inclusion.\n  void HandleIfdefDirective(Token &Result, const Token &HashToken,\n                            bool isIfndef, bool ReadAnyTokensBeforeDirective);\n  void HandleIfDirective(Token &IfToken, const Token &HashToken,\n                         bool ReadAnyTokensBeforeDirective);\n  void HandleEndifDirective(Token &EndifToken);\n  void HandleElseDirective(Token &Result, const Token &HashToken);\n  void HandleElifDirective(Token &ElifToken, const Token &HashToken);\n\n  // Pragmas.\n  void HandlePragmaDirective(PragmaIntroducer Introducer);\n\npublic:\n  void HandlePragmaOnce(Token &OnceTok);\n  void HandlePragmaMark();\n  void HandlePragmaPoison();\n  void HandlePragmaSystemHeader(Token &SysHeaderTok);\n  void HandlePragmaDependency(Token &DependencyTok);\n  void HandlePragmaPushMacro(Token &Tok);\n  void HandlePragmaPopMacro(Token &Tok);\n  void HandlePragmaIncludeAlias(Token &Tok);\n  void HandlePragmaModuleBuild(Token &Tok);\n  void HandlePragmaHdrstop(Token &Tok);\n  IdentifierInfo *ParsePragmaPushOrPopMacro(Token &Tok);\n\n  // Return true and store the first token only if any CommentHandler\n  // has inserted some tokens and getCommentRetentionState() is false.\n  bool HandleComment(Token &result, SourceRange Comment);\n\n  /// A macro is used, update information about macros that need unused\n  /// warnings.\n  void markMacroAsUsed(MacroInfo *MI);\n\nprivate:\n  Optional<unsigned>\n  getSkippedRangeForExcludedConditionalBlock(SourceLocation HashLoc);\n\n  /// Contains the currently active skipped range mappings for skipping excluded\n  /// conditional directives.\n  ExcludedPreprocessorDirectiveSkipMapping\n      *ExcludedConditionalDirectiveSkipMappings;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for each of the comments encountered in the source file.\nclass CommentHandler {\npublic:\n  virtual ~CommentHandler();\n\n  // The handler shall return true if it has pushed any tokens\n  // to be read using e.g. EnterToken or EnterTokenStream.\n  virtual bool HandleComment(Preprocessor &PP, SourceRange Comment) = 0;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for empty lines encountered in the source file.\nclass EmptylineHandler {\npublic:\n  virtual ~EmptylineHandler();\n\n  // The handler handles empty lines.\n  virtual void HandleEmptyline(SourceRange Range) = 0;\n};\n\n/// Registry of pragma handlers added by plugins\nusing PragmaHandlerRegistry = llvm::Registry<PragmaHandler>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOR_H\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Token.h", "content": "//===--- Token.h - Token interface ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Token interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_TOKEN_H\n#define LLVM_CLANG_LEX_TOKEN_H\n\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass IdentifierInfo;\n\n/// Token - This structure provides full information about a lexed token.\n/// It is not intended to be space efficient, it is intended to return as much\n/// information as possible about each returned token.  This is expected to be\n/// compressed into a smaller form if memory footprint is important.\n///\n/// The parser can create a special \"annotation token\" representing a stream of\n/// tokens that were parsed and semantically resolved, e.g.: \"foo::MyClass<int>\"\n/// can be represented by a single typename annotation token that carries\n/// information about the SourceRange of the tokens and the type object.\nclass Token {\n  /// The location of the token. This is actually a SourceLocation.\n  unsigned Loc;\n\n  // Conceptually these next two fields could be in a union.  However, this\n  // causes gcc 4.2 to pessimize LexTokenInternal, a very performance critical\n  // routine. Keeping as separate members with casts until a more beautiful fix\n  // presents itself.\n\n  /// UintData - This holds either the length of the token text, when\n  /// a normal token, or the end of the SourceRange when an annotation\n  /// token.\n  unsigned UintData;\n\n  /// PtrData - This is a union of four different pointer types, which depends\n  /// on what type of token this is:\n  ///  Identifiers, keywords, etc:\n  ///    This is an IdentifierInfo*, which contains the uniqued identifier\n  ///    spelling.\n  ///  Literals:  isLiteral() returns true.\n  ///    This is a pointer to the start of the token in a text buffer, which\n  ///    may be dirty (have trigraphs / escaped newlines).\n  ///  Annotations (resolved type names, C++ scopes, etc): isAnnotation().\n  ///    This is a pointer to sema-specific data for the annotation token.\n  ///  Eof:\n  //     This is a pointer to a Decl.\n  ///  Other:\n  ///    This is null.\n  void *PtrData;\n\n  /// Kind - The actual flavor of token this is.\n  tok::TokenKind Kind;\n\n  /// Flags - Bits we track about this token, members of the TokenFlags enum.\n  unsigned short Flags;\n\npublic:\n  // Various flags set per token:\n  enum TokenFlags {\n    StartOfLine = 0x01,   // At start of line or only after whitespace\n                          // (considering the line after macro expansion).\n    LeadingSpace = 0x02,  // Whitespace exists before this token (considering\n                          // whitespace after macro expansion).\n    DisableExpand = 0x04, // This identifier may never be macro expanded.\n    NeedsCleaning = 0x08, // Contained an escaped newline or trigraph.\n    LeadingEmptyMacro = 0x10, // Empty macro exists before this token.\n    HasUDSuffix = 0x20,  // This string or character literal has a ud-suffix.\n    HasUCN = 0x40,       // This identifier contains a UCN.\n    IgnoredComma = 0x80, // This comma is not a macro argument separator (MS).\n    StringifiedInMacro = 0x100, // This string or character literal is formed by\n                                // macro stringizing or charizing operator.\n    CommaAfterElided = 0x200, // The comma following this token was elided (MS).\n    IsEditorPlaceholder = 0x400, // This identifier is a placeholder.\n    IsReinjected = 0x800, // A phase 4 token that was produced before and\n                          // re-added, e.g. via EnterTokenStream. Annotation\n                          // tokens are *not* reinjected.\n  };\n\n  tok::TokenKind getKind() const { return Kind; }\n  void setKind(tok::TokenKind K) { Kind = K; }\n\n  /// is/isNot - Predicates to check if this token is a specific kind, as in\n  /// \"if (Tok.is(tok::l_brace)) {...}\".\n  bool is(tok::TokenKind K) const { return Kind == K; }\n  bool isNot(tok::TokenKind K) const { return Kind != K; }\n  bool isOneOf(tok::TokenKind K1, tok::TokenKind K2) const {\n    return is(K1) || is(K2);\n  }\n  template <typename... Ts>\n  bool isOneOf(tok::TokenKind K1, tok::TokenKind K2, Ts... Ks) const {\n    return is(K1) || isOneOf(K2, Ks...);\n  }\n\n  /// Return true if this is a raw identifier (when lexing\n  /// in raw mode) or a non-keyword identifier (when lexing in non-raw mode).\n  bool isAnyIdentifier() const {\n    return tok::isAnyIdentifier(getKind());\n  }\n\n  /// Return true if this is a \"literal\", like a numeric\n  /// constant, string, etc.\n  bool isLiteral() const {\n    return tok::isLiteral(getKind());\n  }\n\n  /// Return true if this is any of tok::annot_* kind tokens.\n  bool isAnnotation() const {\n    return tok::isAnnotation(getKind());\n  }\n\n  /// Return a source location identifier for the specified\n  /// offset in the current file.\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromRawEncoding(Loc);\n  }\n  unsigned getLength() const {\n    assert(!isAnnotation() && \"Annotation tokens have no length field\");\n    return UintData;\n  }\n\n  void setLocation(SourceLocation L) { Loc = L.getRawEncoding(); }\n  void setLength(unsigned Len) {\n    assert(!isAnnotation() && \"Annotation tokens have no length field\");\n    UintData = Len;\n  }\n\n  SourceLocation getAnnotationEndLoc() const {\n    assert(isAnnotation() && \"Used AnnotEndLocID on non-annotation token\");\n    return SourceLocation::getFromRawEncoding(UintData ? UintData : Loc);\n  }\n  void setAnnotationEndLoc(SourceLocation L) {\n    assert(isAnnotation() && \"Used AnnotEndLocID on non-annotation token\");\n    UintData = L.getRawEncoding();\n  }\n\n  SourceLocation getLastLoc() const {\n    return isAnnotation() ? getAnnotationEndLoc() : getLocation();\n  }\n\n  SourceLocation getEndLoc() const {\n    return isAnnotation() ? getAnnotationEndLoc()\n                          : getLocation().getLocWithOffset(getLength());\n  }\n\n  /// SourceRange of the group of tokens that this annotation token\n  /// represents.\n  SourceRange getAnnotationRange() const {\n    return SourceRange(getLocation(), getAnnotationEndLoc());\n  }\n  void setAnnotationRange(SourceRange R) {\n    setLocation(R.getBegin());\n    setAnnotationEndLoc(R.getEnd());\n  }\n\n  const char *getName() const { return tok::getTokenName(Kind); }\n\n  /// Reset all flags to cleared.\n  void startToken() {\n    Kind = tok::unknown;\n    Flags = 0;\n    PtrData = nullptr;\n    UintData = 0;\n    Loc = SourceLocation().getRawEncoding();\n  }\n\n  IdentifierInfo *getIdentifierInfo() const {\n    assert(isNot(tok::raw_identifier) &&\n           \"getIdentifierInfo() on a tok::raw_identifier token!\");\n    assert(!isAnnotation() &&\n           \"getIdentifierInfo() on an annotation token!\");\n    if (isLiteral()) return nullptr;\n    if (is(tok::eof)) return nullptr;\n    return (IdentifierInfo*) PtrData;\n  }\n  void setIdentifierInfo(IdentifierInfo *II) {\n    PtrData = (void*) II;\n  }\n\n  const void *getEofData() const {\n    assert(is(tok::eof));\n    return reinterpret_cast<const void *>(PtrData);\n  }\n  void setEofData(const void *D) {\n    assert(is(tok::eof));\n    assert(!PtrData);\n    PtrData = const_cast<void *>(D);\n  }\n\n  /// getRawIdentifier - For a raw identifier token (i.e., an identifier\n  /// lexed in raw mode), returns a reference to the text substring in the\n  /// buffer if known.\n  StringRef getRawIdentifier() const {\n    assert(is(tok::raw_identifier));\n    return StringRef(reinterpret_cast<const char *>(PtrData), getLength());\n  }\n  void setRawIdentifierData(const char *Ptr) {\n    assert(is(tok::raw_identifier));\n    PtrData = const_cast<char*>(Ptr);\n  }\n\n  /// getLiteralData - For a literal token (numeric constant, string, etc), this\n  /// returns a pointer to the start of it in the text buffer if known, null\n  /// otherwise.\n  const char *getLiteralData() const {\n    assert(isLiteral() && \"Cannot get literal data of non-literal\");\n    return reinterpret_cast<const char*>(PtrData);\n  }\n  void setLiteralData(const char *Ptr) {\n    assert(isLiteral() && \"Cannot set literal data of non-literal\");\n    PtrData = const_cast<char*>(Ptr);\n  }\n\n  void *getAnnotationValue() const {\n    assert(isAnnotation() && \"Used AnnotVal on non-annotation token\");\n    return PtrData;\n  }\n  void setAnnotationValue(void *val) {\n    assert(isAnnotation() && \"Used AnnotVal on non-annotation token\");\n    PtrData = val;\n  }\n\n  /// Set the specified flag.\n  void setFlag(TokenFlags Flag) {\n    Flags |= Flag;\n  }\n\n  /// Get the specified flag.\n  bool getFlag(TokenFlags Flag) const {\n    return (Flags & Flag) != 0;\n  }\n\n  /// Unset the specified flag.\n  void clearFlag(TokenFlags Flag) {\n    Flags &= ~Flag;\n  }\n\n  /// Return the internal represtation of the flags.\n  ///\n  /// This is only intended for low-level operations such as writing tokens to\n  /// disk.\n  unsigned getFlags() const {\n    return Flags;\n  }\n\n  /// Set a flag to either true or false.\n  void setFlagValue(TokenFlags Flag, bool Val) {\n    if (Val)\n      setFlag(Flag);\n    else\n      clearFlag(Flag);\n  }\n\n  /// isAtStartOfLine - Return true if this token is at the start of a line.\n  ///\n  bool isAtStartOfLine() const { return getFlag(StartOfLine); }\n\n  /// Return true if this token has whitespace before it.\n  ///\n  bool hasLeadingSpace() const { return getFlag(LeadingSpace); }\n\n  /// Return true if this identifier token should never\n  /// be expanded in the future, due to C99 6.10.3.4p2.\n  bool isExpandDisabled() const { return getFlag(DisableExpand); }\n\n  /// Return true if we have an ObjC keyword identifier.\n  bool isObjCAtKeyword(tok::ObjCKeywordKind objcKey) const;\n\n  /// Return the ObjC keyword kind.\n  tok::ObjCKeywordKind getObjCKeywordID() const;\n\n  /// Return true if this token has trigraphs or escaped newlines in it.\n  bool needsCleaning() const { return getFlag(NeedsCleaning); }\n\n  /// Return true if this token has an empty macro before it.\n  ///\n  bool hasLeadingEmptyMacro() const { return getFlag(LeadingEmptyMacro); }\n\n  /// Return true if this token is a string or character literal which\n  /// has a ud-suffix.\n  bool hasUDSuffix() const { return getFlag(HasUDSuffix); }\n\n  /// Returns true if this token contains a universal character name.\n  bool hasUCN() const { return getFlag(HasUCN); }\n\n  /// Returns true if this token is formed by macro by stringizing or charizing\n  /// operator.\n  bool stringifiedInMacro() const { return getFlag(StringifiedInMacro); }\n\n  /// Returns true if the comma after this token was elided.\n  bool commaAfterElided() const { return getFlag(CommaAfterElided); }\n\n  /// Returns true if this token is an editor placeholder.\n  ///\n  /// Editor placeholders are produced by the code-completion engine and are\n  /// represented as characters between '<#' and '#>' in the source code. The\n  /// lexer uses identifier tokens to represent placeholders.\n  bool isEditorPlaceholder() const { return getFlag(IsEditorPlaceholder); }\n};\n\n/// Information about the conditional stack (\\#if directives)\n/// currently active.\nstruct PPConditionalInfo {\n  /// Location where the conditional started.\n  SourceLocation IfLoc;\n\n  /// True if this was contained in a skipping directive, e.g.,\n  /// in a \"\\#if 0\" block.\n  bool WasSkipping;\n\n  /// True if we have emitted tokens already, and now we're in\n  /// an \\#else block or something.  Only useful in Skipping blocks.\n  bool FoundNonSkip;\n\n  /// True if we've seen a \\#else in this block.  If so,\n  /// \\#elif/\\#else directives are not allowed.\n  bool FoundElse;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_LEX_TOKEN_H\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "content": "//===- CodeCompleteConsumer.h - Code Completion Interface -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CodeCompleteConsumer class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n#define LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass DeclContext;\nclass FunctionDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamedDecl;\nclass NestedNameSpecifier;\nclass Preprocessor;\nclass RawComment;\nclass Sema;\nclass UsingShadowDecl;\n\n/// Default priority values for code-completion results based\n/// on their kind.\nenum {\n  /// Priority for the next initialization in a constructor initializer\n  /// list.\n  CCP_NextInitializer = 7,\n\n  /// Priority for an enumeration constant inside a switch whose\n  /// condition is of the enumeration type.\n  CCP_EnumInCase = 7,\n\n  /// Priority for a send-to-super completion.\n  CCP_SuperCompletion = 20,\n\n  /// Priority for a declaration that is in the local scope.\n  CCP_LocalDeclaration = 34,\n\n  /// Priority for a member declaration found from the current\n  /// method or member function.\n  CCP_MemberDeclaration = 35,\n\n  /// Priority for a language keyword (that isn't any of the other\n  /// categories).\n  CCP_Keyword = 40,\n\n  /// Priority for a code pattern.\n  CCP_CodePattern = 40,\n\n  /// Priority for a non-type declaration.\n  CCP_Declaration = 50,\n\n  /// Priority for a type.\n  CCP_Type = CCP_Declaration,\n\n  /// Priority for a constant value (e.g., enumerator).\n  CCP_Constant = 65,\n\n  /// Priority for a preprocessor macro.\n  CCP_Macro = 70,\n\n  /// Priority for a nested-name-specifier.\n  CCP_NestedNameSpecifier = 75,\n\n  /// Priority for a result that isn't likely to be what the user wants,\n  /// but is included for completeness.\n  CCP_Unlikely = 80,\n\n  /// Priority for the Objective-C \"_cmd\" implicit parameter.\n  CCP_ObjC_cmd = CCP_Unlikely\n};\n\n/// Priority value deltas that are added to code-completion results\n/// based on the context of the result.\nenum {\n  /// The result is in a base class.\n  CCD_InBaseClass = 2,\n\n  /// The result is a C++ non-static member function whose qualifiers\n  /// exactly match the object type on which the member function can be called.\n  CCD_ObjectQualifierMatch = -1,\n\n  /// The selector of the given message exactly matches the selector\n  /// of the current method, which might imply that some kind of delegation\n  /// is occurring.\n  CCD_SelectorMatch = -3,\n\n  /// Adjustment to the \"bool\" type in Objective-C, where the typedef\n  /// \"BOOL\" is preferred.\n  CCD_bool_in_ObjC = 1,\n\n  /// Adjustment for KVC code pattern priorities when it doesn't look\n  /// like the\n  CCD_ProbablyNotObjCCollection = 15,\n\n  /// An Objective-C method being used as a property.\n  CCD_MethodAsProperty = 2,\n\n  /// An Objective-C block property completed as a setter with a\n  /// block placeholder.\n  CCD_BlockPropertySetter = 3\n};\n\n/// Priority value factors by which we will divide or multiply the\n/// priority of a code-completion result.\nenum {\n  /// Divide by this factor when a code-completion result's type exactly\n  /// matches the type we expect.\n  CCF_ExactTypeMatch = 4,\n\n  /// Divide by this factor when a code-completion result's type is\n  /// similar to the type we expect (e.g., both arithmetic types, both\n  /// Objective-C object pointer types).\n  CCF_SimilarTypeMatch = 2\n};\n\n/// A simplified classification of types used when determining\n/// \"similar\" types for code completion.\nenum SimplifiedTypeClass {\n  STC_Arithmetic,\n  STC_Array,\n  STC_Block,\n  STC_Function,\n  STC_ObjectiveC,\n  STC_Other,\n  STC_Pointer,\n  STC_Record,\n  STC_Void\n};\n\n/// Determine the simplified type class of the given canonical type.\nSimplifiedTypeClass getSimplifiedTypeClass(CanQualType T);\n\n/// Determine the type that this declaration will have if it is used\n/// as a type or in an expression.\nQualType getDeclUsageType(ASTContext &C, const NamedDecl *ND);\n\n/// Determine the priority to be given to a macro code completion result\n/// with the given name.\n///\n/// \\param MacroName The name of the macro.\n///\n/// \\param LangOpts Options describing the current language dialect.\n///\n/// \\param PreferredTypeIsPointer Whether the preferred type for the context\n/// of this macro is a pointer type.\nunsigned getMacroUsagePriority(StringRef MacroName,\n                               const LangOptions &LangOpts,\n                               bool PreferredTypeIsPointer = false);\n\n/// Determine the libclang cursor kind associated with the given\n/// declaration.\nCXCursorKind getCursorKindForDecl(const Decl *D);\n\n/// The context in which code completion occurred, so that the\n/// code-completion consumer can process the results accordingly.\nclass CodeCompletionContext {\npublic:\n  enum Kind {\n    /// An unspecified code-completion context.\n    CCC_Other,\n\n    /// An unspecified code-completion context where we should also add\n    /// macro completions.\n    CCC_OtherWithMacros,\n\n    /// Code completion occurred within a \"top-level\" completion context,\n    /// e.g., at namespace or global scope.\n    CCC_TopLevel,\n\n    /// Code completion occurred within an Objective-C interface,\n    /// protocol, or category interface.\n    CCC_ObjCInterface,\n\n    /// Code completion occurred within an Objective-C implementation\n    /// or category implementation.\n    CCC_ObjCImplementation,\n\n    /// Code completion occurred within the instance variable list of\n    /// an Objective-C interface, implementation, or category implementation.\n    CCC_ObjCIvarList,\n\n    /// Code completion occurred within a class, struct, or union.\n    CCC_ClassStructUnion,\n\n    /// Code completion occurred where a statement (or declaration) is\n    /// expected in a function, method, or block.\n    CCC_Statement,\n\n    /// Code completion occurred where an expression is expected.\n    CCC_Expression,\n\n    /// Code completion occurred where an Objective-C message receiver\n    /// is expected.\n    CCC_ObjCMessageReceiver,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the dot operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_DotMemberAccess,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the arrow operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ArrowMemberAccess,\n\n    /// Code completion occurred on the right-hand side of an Objective-C\n    /// property access expression.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ObjCPropertyAccess,\n\n    /// Code completion occurred after the \"enum\" keyword, to indicate\n    /// an enumeration name.\n    CCC_EnumTag,\n\n    /// Code completion occurred after the \"union\" keyword, to indicate\n    /// a union name.\n    CCC_UnionTag,\n\n    /// Code completion occurred after the \"struct\" or \"class\" keyword,\n    /// to indicate a struct or class name.\n    CCC_ClassOrStructTag,\n\n    /// Code completion occurred where a protocol name is expected.\n    CCC_ObjCProtocolName,\n\n    /// Code completion occurred where a namespace or namespace alias\n    /// is expected.\n    CCC_Namespace,\n\n    /// Code completion occurred where a type name is expected.\n    CCC_Type,\n\n    /// Code completion occurred where a new name is expected.\n    CCC_NewName,\n\n    /// Code completion occurred where both a new name and an existing symbol is\n    /// permissible.\n    CCC_SymbolOrNewName,\n\n    /// Code completion occurred where an existing name(such as type, function\n    /// or variable) is expected.\n    CCC_Symbol,\n\n    /// Code completion occurred where an macro is being defined.\n    CCC_MacroName,\n\n    /// Code completion occurred where a macro name is expected\n    /// (without any arguments, in the case of a function-like macro).\n    CCC_MacroNameUse,\n\n    /// Code completion occurred within a preprocessor expression.\n    CCC_PreprocessorExpression,\n\n    /// Code completion occurred where a preprocessor directive is\n    /// expected.\n    CCC_PreprocessorDirective,\n\n    /// Code completion occurred in a context where natural language is\n    /// expected, e.g., a comment or string literal.\n    ///\n    /// This context usually implies that no completions should be added,\n    /// unless they come from an appropriate natural-language dictionary.\n    CCC_NaturalLanguage,\n\n    /// Code completion for a selector, as in an \\@selector expression.\n    CCC_SelectorName,\n\n    /// Code completion within a type-qualifier list.\n    CCC_TypeQualifiers,\n\n    /// Code completion in a parenthesized expression, which means that\n    /// we may also have types here in C and Objective-C (as well as in C++).\n    CCC_ParenthesizedExpression,\n\n    /// Code completion where an Objective-C instance message is\n    /// expected.\n    CCC_ObjCInstanceMessage,\n\n    /// Code completion where an Objective-C class message is expected.\n    CCC_ObjCClassMessage,\n\n    /// Code completion where the name of an Objective-C class is\n    /// expected.\n    CCC_ObjCInterfaceName,\n\n    /// Code completion where an Objective-C category name is expected.\n    CCC_ObjCCategoryName,\n\n    /// Code completion inside the filename part of a #include directive.\n    CCC_IncludedFile,\n\n    /// An unknown context, in which we are recovering from a parsing\n    /// error and don't know which completions we should give.\n    CCC_Recovery\n  };\n\n  using VisitedContextSet = llvm::SmallPtrSet<DeclContext *, 8>;\n\nprivate:\n  Kind CCKind;\n\n  /// Indicates whether we are completing a name of a using declaration, e.g.\n  ///     using ^;\n  ///     using a::^;\n  bool IsUsingDeclaration;\n\n  /// The type that would prefer to see at this point (e.g., the type\n  /// of an initializer or function parameter).\n  QualType PreferredType;\n\n  /// The type of the base object in a member access expression.\n  QualType BaseType;\n\n  /// The identifiers for Objective-C selector parts.\n  ArrayRef<IdentifierInfo *> SelIdents;\n\n  /// The scope specifier that comes before the completion token e.g.\n  /// \"a::b::\"\n  llvm::Optional<CXXScopeSpec> ScopeSpecifier;\n\n  /// A set of declaration contexts visited by Sema when doing lookup for\n  /// code completion.\n  VisitedContextSet VisitedContexts;\n\npublic:\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(None) {}\n\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind, QualType T,\n                        ArrayRef<IdentifierInfo *> SelIdents = None)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(SelIdents) {\n    if (CCKind == CCC_DotMemberAccess || CCKind == CCC_ArrowMemberAccess ||\n        CCKind == CCC_ObjCPropertyAccess || CCKind == CCC_ObjCClassMessage ||\n        CCKind == CCC_ObjCInstanceMessage)\n      BaseType = T;\n    else\n      PreferredType = T;\n  }\n\n  bool isUsingDeclaration() const { return IsUsingDeclaration; }\n  void setIsUsingDeclaration(bool V) { IsUsingDeclaration = V; }\n\n  /// Retrieve the kind of code-completion context.\n  Kind getKind() const { return CCKind; }\n\n  /// Retrieve the type that this expression would prefer to have, e.g.,\n  /// if the expression is a variable initializer or a function argument, the\n  /// type of the corresponding variable or function parameter.\n  QualType getPreferredType() const { return PreferredType; }\n  void setPreferredType(QualType T) { PreferredType = T; }\n\n  /// Retrieve the type of the base object in a member-access\n  /// expression.\n  QualType getBaseType() const { return BaseType; }\n\n  /// Retrieve the Objective-C selector identifiers.\n  ArrayRef<IdentifierInfo *> getSelIdents() const { return SelIdents; }\n\n  /// Determines whether we want C++ constructors as results within this\n  /// context.\n  bool wantConstructorResults() const;\n\n  /// Sets the scope specifier that comes before the completion token.\n  /// This is expected to be set in code completions on qualfied specifiers\n  /// (e.g. \"a::b::\").\n  void setCXXScopeSpecifier(CXXScopeSpec SS) {\n    this->ScopeSpecifier = std::move(SS);\n  }\n\n  /// Adds a visited context.\n  void addVisitedContext(DeclContext *Ctx) {\n    VisitedContexts.insert(Ctx);\n  }\n\n  /// Retrieves all visited contexts.\n  const VisitedContextSet &getVisitedContexts() const {\n    return VisitedContexts;\n  }\n\n  llvm::Optional<const CXXScopeSpec *> getCXXScopeSpecifier() {\n    if (ScopeSpecifier)\n      return ScopeSpecifier.getPointer();\n    return llvm::None;\n  }\n};\n\n/// Get string representation of \\p Kind, useful for for debugging.\nllvm::StringRef getCompletionKindString(CodeCompletionContext::Kind Kind);\n\n/// A \"string\" used to describe how code completion can\n/// be performed for an entity.\n///\n/// A code completion string typically shows how a particular entity can be\n/// used. For example, the code completion string for a function would show\n/// the syntax to call it, including the parentheses, placeholders for the\n/// arguments, etc.\nclass CodeCompletionString {\npublic:\n  /// The different kinds of \"chunks\" that can occur within a code\n  /// completion string.\n  enum ChunkKind {\n    /// The piece of text that the user is expected to type to\n    /// match the code-completion string, typically a keyword or the name of a\n    /// declarator or macro.\n    CK_TypedText,\n\n    /// A piece of text that should be placed in the buffer, e.g.,\n    /// parentheses or a comma in a function call.\n    CK_Text,\n\n    /// A code completion string that is entirely optional. For example,\n    /// an optional code completion string that describes the default arguments\n    /// in a function call.\n    CK_Optional,\n\n    /// A string that acts as a placeholder for, e.g., a function\n    /// call argument.\n    CK_Placeholder,\n\n    /// A piece of text that describes something about the result but\n    /// should not be inserted into the buffer.\n    CK_Informative,\n    /// A piece of text that describes the type of an entity or, for\n    /// functions and methods, the return type.\n    CK_ResultType,\n\n    /// A piece of text that describes the parameter that corresponds\n    /// to the code-completion location within a function call, message send,\n    /// macro invocation, etc.\n    CK_CurrentParameter,\n\n    /// A left parenthesis ('(').\n    CK_LeftParen,\n\n    /// A right parenthesis (')').\n    CK_RightParen,\n\n    /// A left bracket ('[').\n    CK_LeftBracket,\n\n    /// A right bracket (']').\n    CK_RightBracket,\n\n    /// A left brace ('{').\n    CK_LeftBrace,\n\n    /// A right brace ('}').\n    CK_RightBrace,\n\n    /// A left angle bracket ('<').\n    CK_LeftAngle,\n\n    /// A right angle bracket ('>').\n    CK_RightAngle,\n\n    /// A comma separator (',').\n    CK_Comma,\n\n    /// A colon (':').\n    CK_Colon,\n\n    /// A semicolon (';').\n    CK_SemiColon,\n\n    /// An '=' sign.\n    CK_Equal,\n\n    /// Horizontal whitespace (' ').\n    CK_HorizontalSpace,\n\n    /// Vertical whitespace ('\\\\n' or '\\\\r\\\\n', depending on the\n    /// platform).\n    CK_VerticalSpace\n  };\n\n  /// One piece of the code completion string.\n  struct Chunk {\n    /// The kind of data stored in this piece of the code completion\n    /// string.\n    ChunkKind Kind = CK_Text;\n\n    union {\n      /// The text string associated with a CK_Text, CK_Placeholder,\n      /// CK_Informative, or CK_Comma chunk.\n      /// The string is owned by the chunk and will be deallocated\n      /// (with delete[]) when the chunk is destroyed.\n      const char *Text;\n\n      /// The code completion string associated with a CK_Optional chunk.\n      /// The optional code completion string is owned by the chunk, and will\n      /// be deallocated (with delete) when the chunk is destroyed.\n      CodeCompletionString *Optional;\n    };\n\n    Chunk() : Text(nullptr) {}\n\n    explicit Chunk(ChunkKind Kind, const char *Text = \"\");\n\n    /// Create a new text chunk.\n    static Chunk CreateText(const char *Text);\n\n    /// Create a new optional chunk.\n    static Chunk CreateOptional(CodeCompletionString *Optional);\n\n    /// Create a new placeholder chunk.\n    static Chunk CreatePlaceholder(const char *Placeholder);\n\n    /// Create a new informative chunk.\n    static Chunk CreateInformative(const char *Informative);\n\n    /// Create a new result type chunk.\n    static Chunk CreateResultType(const char *ResultType);\n\n    /// Create a new current-parameter chunk.\n    static Chunk CreateCurrentParameter(const char *CurrentParameter);\n  };\n\nprivate:\n  friend class CodeCompletionBuilder;\n  friend class CodeCompletionResult;\n\n  /// The number of chunks stored in this string.\n  unsigned NumChunks : 16;\n\n  /// The number of annotations for this code-completion result.\n  unsigned NumAnnotations : 16;\n\n  /// The priority of this code-completion string.\n  unsigned Priority : 16;\n\n  /// The availability of this code-completion result.\n  unsigned Availability : 2;\n\n  /// The name of the parent context.\n  StringRef ParentName;\n\n  /// A brief documentation comment attached to the declaration of\n  /// entity being completed by this result.\n  const char *BriefComment;\n\n  CodeCompletionString(const Chunk *Chunks, unsigned NumChunks,\n                       unsigned Priority, CXAvailabilityKind Availability,\n                       const char **Annotations, unsigned NumAnnotations,\n                       StringRef ParentName,\n                       const char *BriefComment);\n  ~CodeCompletionString() = default;\n\npublic:\n  CodeCompletionString(const CodeCompletionString &) = delete;\n  CodeCompletionString &operator=(const CodeCompletionString &) = delete;\n\n  using iterator = const Chunk *;\n\n  iterator begin() const { return reinterpret_cast<const Chunk *>(this + 1); }\n  iterator end() const { return begin() + NumChunks; }\n  bool empty() const { return NumChunks == 0; }\n  unsigned size() const { return NumChunks; }\n\n  const Chunk &operator[](unsigned I) const {\n    assert(I < size() && \"Chunk index out-of-range\");\n    return begin()[I];\n  }\n\n  /// Returns the text in the TypedText chunk.\n  const char *getTypedText() const;\n\n  /// Retrieve the priority of this code completion result.\n  unsigned getPriority() const { return Priority; }\n\n  /// Retrieve the availability of this code completion result.\n  unsigned getAvailability() const { return Availability; }\n\n  /// Retrieve the number of annotations for this code completion result.\n  unsigned getAnnotationCount() const;\n\n  /// Retrieve the annotation string specified by \\c AnnotationNr.\n  const char *getAnnotation(unsigned AnnotationNr) const;\n\n  /// Retrieve the name of the parent context.\n  StringRef getParentContextName() const {\n    return ParentName;\n  }\n\n  const char *getBriefComment() const {\n    return BriefComment;\n  }\n\n  /// Retrieve a string representation of the code completion string,\n  /// which is mainly useful for debugging.\n  std::string getAsString() const;\n};\n\n/// An allocator used specifically for the purpose of code completion.\nclass CodeCompletionAllocator : public llvm::BumpPtrAllocator {\npublic:\n  /// Copy the given string into this allocator.\n  const char *CopyString(const Twine &String);\n};\n\n/// Allocator for a cached set of global code completions.\nclass GlobalCodeCompletionAllocator : public CodeCompletionAllocator {};\n\nclass CodeCompletionTUInfo {\n  llvm::DenseMap<const DeclContext *, StringRef> ParentNames;\n  std::shared_ptr<GlobalCodeCompletionAllocator> AllocatorRef;\n\npublic:\n  explicit CodeCompletionTUInfo(\n      std::shared_ptr<GlobalCodeCompletionAllocator> Allocator)\n      : AllocatorRef(std::move(Allocator)) {}\n\n  std::shared_ptr<GlobalCodeCompletionAllocator> getAllocatorRef() const {\n    return AllocatorRef;\n  }\n\n  CodeCompletionAllocator &getAllocator() const {\n    assert(AllocatorRef);\n    return *AllocatorRef;\n  }\n\n  StringRef getParentName(const DeclContext *DC);\n};\n\n} // namespace clang\n\nnamespace clang {\n\n/// A builder class used to construct new code-completion strings.\nclass CodeCompletionBuilder {\npublic:\n  using Chunk = CodeCompletionString::Chunk;\n\nprivate:\n  CodeCompletionAllocator &Allocator;\n  CodeCompletionTUInfo &CCTUInfo;\n  unsigned Priority = 0;\n  CXAvailabilityKind Availability = CXAvailability_Available;\n  StringRef ParentName;\n  const char *BriefComment = nullptr;\n\n  /// The chunks stored in this string.\n  SmallVector<Chunk, 4> Chunks;\n\n  SmallVector<const char *, 2> Annotations;\n\npublic:\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo) {}\n\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo,\n                        unsigned Priority, CXAvailabilityKind Availability)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo), Priority(Priority),\n        Availability(Availability) {}\n\n  /// Retrieve the allocator into which the code completion\n  /// strings should be allocated.\n  CodeCompletionAllocator &getAllocator() const { return Allocator; }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() const { return CCTUInfo; }\n\n  /// Take the resulting completion string.\n  ///\n  /// This operation can only be performed once.\n  CodeCompletionString *TakeString();\n\n  /// Add a new typed-text chunk.\n  void AddTypedTextChunk(const char *Text);\n\n  /// Add a new text chunk.\n  void AddTextChunk(const char *Text);\n\n  /// Add a new optional chunk.\n  void AddOptionalChunk(CodeCompletionString *Optional);\n\n  /// Add a new placeholder chunk.\n  void AddPlaceholderChunk(const char *Placeholder);\n\n  /// Add a new informative chunk.\n  void AddInformativeChunk(const char *Text);\n\n  /// Add a new result-type chunk.\n  void AddResultTypeChunk(const char *ResultType);\n\n  /// Add a new current-parameter chunk.\n  void AddCurrentParameterChunk(const char *CurrentParameter);\n\n  /// Add a new chunk.\n  void AddChunk(CodeCompletionString::ChunkKind CK, const char *Text = \"\");\n\n  void AddAnnotation(const char *A) { Annotations.push_back(A); }\n\n  /// Add the parent context information to this code completion.\n  void addParentContext(const DeclContext *DC);\n\n  const char *getBriefComment() const { return BriefComment; }\n  void addBriefComment(StringRef Comment);\n\n  StringRef getParentName() const { return ParentName; }\n};\n\n/// Captures a result of code completion.\nclass CodeCompletionResult {\npublic:\n  /// Describes the kind of result generated.\n  enum ResultKind {\n    /// Refers to a declaration.\n    RK_Declaration = 0,\n\n    /// Refers to a keyword or symbol.\n    RK_Keyword,\n\n    /// Refers to a macro.\n    RK_Macro,\n\n    /// Refers to a precomputed pattern.\n    RK_Pattern\n  };\n\n  /// When Kind == RK_Declaration or RK_Pattern, the declaration we are\n  /// referring to. In the latter case, the declaration might be NULL.\n  const NamedDecl *Declaration = nullptr;\n\n  union {\n    /// When Kind == RK_Keyword, the string representing the keyword\n    /// or symbol's spelling.\n    const char *Keyword;\n\n    /// When Kind == RK_Pattern, the code-completion string that\n    /// describes the completion text to insert.\n    CodeCompletionString *Pattern;\n\n    /// When Kind == RK_Macro, the identifier that refers to a macro.\n    const IdentifierInfo *Macro;\n  };\n\n  /// The priority of this particular code-completion result.\n  unsigned Priority;\n\n  /// Specifies which parameter (of a function, Objective-C method,\n  /// macro, etc.) we should start with when formatting the result.\n  unsigned StartParameter = 0;\n\n  /// The kind of result stored here.\n  ResultKind Kind;\n\n  /// The cursor kind that describes this result.\n  CXCursorKind CursorKind;\n\n  /// The availability of this result.\n  CXAvailabilityKind Availability = CXAvailability_Available;\n\n  /// Fix-its that *must* be applied before inserting the text for the\n  /// corresponding completion.\n  ///\n  /// By default, CodeCompletionBuilder only returns completions with empty\n  /// fix-its. Extra completions with non-empty fix-its should be explicitly\n  /// requested by setting CompletionOptions::IncludeFixIts.\n  ///\n  /// For the clients to be able to compute position of the cursor after\n  /// applying fix-its, the following conditions are guaranteed to hold for\n  /// RemoveRange of the stored fix-its:\n  ///  - Ranges in the fix-its are guaranteed to never contain the completion\n  ///  point (or identifier under completion point, if any) inside them, except\n  ///  at the start or at the end of the range.\n  ///  - If a fix-it range starts or ends with completion point (or starts or\n  ///  ends after the identifier under completion point), it will contain at\n  ///  least one character. It allows to unambiguously recompute completion\n  ///  point after applying the fix-it.\n  ///\n  /// The intuition is that provided fix-its change code around the identifier\n  /// we complete, but are not allowed to touch the identifier itself or the\n  /// completion point. One example of completions with corrections are the ones\n  /// replacing '.' with '->' and vice versa:\n  ///\n  /// std::unique_ptr<std::vector<int>> vec_ptr;\n  /// In 'vec_ptr.^', one of the completions is 'push_back', it requires\n  /// replacing '.' with '->'.\n  /// In 'vec_ptr->^', one of the completions is 'release', it requires\n  /// replacing '->' with '.'.\n  std::vector<FixItHint> FixIts;\n\n  /// Whether this result is hidden by another name.\n  bool Hidden : 1;\n\n  /// Whether this is a class member from base class.\n  bool InBaseClass : 1;\n\n  /// Whether this result was found via lookup into a base class.\n  bool QualifierIsInformative : 1;\n\n  /// Whether this declaration is the beginning of a\n  /// nested-name-specifier and, therefore, should be followed by '::'.\n  bool StartsNestedNameSpecifier : 1;\n\n  /// Whether all parameters (of a function, Objective-C\n  /// method, etc.) should be considered \"informative\".\n  bool AllParametersAreInformative : 1;\n\n  /// Whether we're completing a declaration of the given entity,\n  /// rather than a use of that entity.\n  bool DeclaringEntity : 1;\n\n  /// If the result should have a nested-name-specifier, this is it.\n  /// When \\c QualifierIsInformative, the nested-name-specifier is\n  /// informative rather than required.\n  NestedNameSpecifier *Qualifier = nullptr;\n\n  /// If this Decl was unshadowed by using declaration, this can store a\n  /// pointer to the UsingShadowDecl which was used in the unshadowing process.\n  /// This information can be used to uprank CodeCompletionResults / which have\n  /// corresponding `using decl::qualified::name;` nearby.\n  const UsingShadowDecl *ShadowDecl = nullptr;\n\n  /// If the result is RK_Macro, this can store the information about the macro\n  /// definition. This should be set in most cases but can be missing when\n  /// the macro has been undefined.\n  const MacroInfo *MacroDefInfo = nullptr;\n\n  /// Build a result that refers to a declaration.\n  CodeCompletionResult(const NamedDecl *Declaration, unsigned Priority,\n                       NestedNameSpecifier *Qualifier = nullptr,\n                       bool QualifierIsInformative = false,\n                       bool Accessible = true,\n                       std::vector<FixItHint> FixIts = std::vector<FixItHint>())\n      : Declaration(Declaration), Priority(Priority), Kind(RK_Declaration),\n        FixIts(std::move(FixIts)), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(QualifierIsInformative),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), Qualifier(Qualifier) {\n    // FIXME: Add assert to check FixIts range requirements.\n    computeCursorKindAndAvailability(Accessible);\n  }\n\n  /// Build a result that refers to a keyword or symbol.\n  CodeCompletionResult(const char *Keyword, unsigned Priority = CCP_Keyword)\n      : Keyword(Keyword), Priority(Priority), Kind(RK_Keyword),\n        CursorKind(CXCursor_NotImplemented), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false) {}\n\n  /// Build a result that refers to a macro.\n  CodeCompletionResult(const IdentifierInfo *Macro,\n                       const MacroInfo *MI = nullptr,\n                       unsigned Priority = CCP_Macro)\n      : Macro(Macro), Priority(Priority), Kind(RK_Macro),\n        CursorKind(CXCursor_MacroDefinition), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false),\n        MacroDefInfo(MI) {}\n\n  /// Build a result that refers to a pattern.\n  CodeCompletionResult(\n      CodeCompletionString *Pattern, unsigned Priority = CCP_CodePattern,\n      CXCursorKind CursorKind = CXCursor_NotImplemented,\n      CXAvailabilityKind Availability = CXAvailability_Available,\n      const NamedDecl *D = nullptr)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        CursorKind(CursorKind), Availability(Availability), Hidden(false),\n        InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {}\n\n  /// Build a result that refers to a pattern with an associated\n  /// declaration.\n  CodeCompletionResult(CodeCompletionString *Pattern, const NamedDecl *D,\n                       unsigned Priority)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        Hidden(false), InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {\n    computeCursorKindAndAvailability();\n  }\n\n  /// Retrieve the declaration stored in this result. This might be nullptr if\n  /// Kind is RK_Pattern.\n  const NamedDecl *getDeclaration() const {\n    assert(((Kind == RK_Declaration) || (Kind == RK_Pattern)) &&\n           \"Not a declaration or pattern result\");\n    return Declaration;\n  }\n\n  /// Retrieve the keyword stored in this result.\n  const char *getKeyword() const {\n    assert(Kind == RK_Keyword && \"Not a keyword result\");\n    return Keyword;\n  }\n\n  /// Create a new code-completion string that describes how to insert\n  /// this result into a program.\n  ///\n  /// \\param S The semantic analysis that created the result.\n  ///\n  /// \\param Allocator The allocator that will be used to allocate the\n  /// string itself.\n  CodeCompletionString *CreateCodeCompletionString(Sema &S,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  CodeCompletionString *CreateCodeCompletionString(ASTContext &Ctx,\n                                                   Preprocessor &PP,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  /// Creates a new code-completion string for the macro result. Similar to the\n  /// above overloads, except this only requires preprocessor information.\n  /// The result kind must be `RK_Macro`.\n  CodeCompletionString *\n  CreateCodeCompletionStringForMacro(Preprocessor &PP,\n                                     CodeCompletionAllocator &Allocator,\n                                     CodeCompletionTUInfo &CCTUInfo);\n\n  CodeCompletionString *createCodeCompletionStringForDecl(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  CodeCompletionString *createCodeCompletionStringForOverride(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  /// Retrieve the name that should be used to order a result.\n  ///\n  /// If the name needs to be constructed as a string, that string will be\n  /// saved into Saved and the returned StringRef will refer to it.\n  StringRef getOrderedName(std::string &Saved) const;\n\nprivate:\n  void computeCursorKindAndAvailability(bool Accessible = true);\n};\n\nbool operator<(const CodeCompletionResult &X, const CodeCompletionResult &Y);\n\ninline bool operator>(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return Y < X;\n}\n\ninline bool operator<=(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return !(Y < X);\n}\n\ninline bool operator>=(const CodeCompletionResult &X,\n                       const CodeCompletionResult &Y) {\n  return !(X < Y);\n}\n\n/// Abstract interface for a consumer of code-completion\n/// information.\nclass CodeCompleteConsumer {\nprotected:\n  const CodeCompleteOptions CodeCompleteOpts;\n\npublic:\n  class OverloadCandidate {\n  public:\n    /// Describes the type of overload candidate.\n    enum CandidateKind {\n      /// The candidate is a function declaration.\n      CK_Function,\n\n      /// The candidate is a function template.\n      CK_FunctionTemplate,\n\n      /// The \"candidate\" is actually a variable, expression, or block\n      /// for which we only have a function prototype.\n      CK_FunctionType\n    };\n\n  private:\n    /// The kind of overload candidate.\n    CandidateKind Kind;\n\n    union {\n      /// The function overload candidate, available when\n      /// Kind == CK_Function.\n      FunctionDecl *Function;\n\n      /// The function template overload candidate, available when\n      /// Kind == CK_FunctionTemplate.\n      FunctionTemplateDecl *FunctionTemplate;\n\n      /// The function type that describes the entity being called,\n      /// when Kind == CK_FunctionType.\n      const FunctionType *Type;\n    };\n\n  public:\n    OverloadCandidate(FunctionDecl *Function)\n        : Kind(CK_Function), Function(Function) {}\n\n    OverloadCandidate(FunctionTemplateDecl *FunctionTemplateDecl)\n        : Kind(CK_FunctionTemplate), FunctionTemplate(FunctionTemplateDecl) {}\n\n    OverloadCandidate(const FunctionType *Type)\n        : Kind(CK_FunctionType), Type(Type) {}\n\n    /// Determine the kind of overload candidate.\n    CandidateKind getKind() const { return Kind; }\n\n    /// Retrieve the function overload candidate or the templated\n    /// function declaration for a function template.\n    FunctionDecl *getFunction() const;\n\n    /// Retrieve the function template overload candidate.\n    FunctionTemplateDecl *getFunctionTemplate() const {\n      assert(getKind() == CK_FunctionTemplate && \"Not a function template\");\n      return FunctionTemplate;\n    }\n\n    /// Retrieve the function type of the entity, regardless of how the\n    /// function is stored.\n    const FunctionType *getFunctionType() const;\n\n    /// Create a new code-completion string that describes the function\n    /// signature of this overload candidate.\n    CodeCompletionString *CreateSignatureString(unsigned CurrentArg,\n                                                Sema &S,\n                                      CodeCompletionAllocator &Allocator,\n                                      CodeCompletionTUInfo &CCTUInfo,\n                                      bool IncludeBriefComments) const;\n  };\n\n  CodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts)\n      : CodeCompleteOpts(CodeCompleteOpts) {}\n\n  /// Whether the code-completion consumer wants to see macros.\n  bool includeMacros() const {\n    return CodeCompleteOpts.IncludeMacros;\n  }\n\n  /// Whether the code-completion consumer wants to see code patterns.\n  bool includeCodePatterns() const {\n    return CodeCompleteOpts.IncludeCodePatterns;\n  }\n\n  /// Whether to include global (top-level) declaration results.\n  bool includeGlobals() const { return CodeCompleteOpts.IncludeGlobals; }\n\n  /// Whether to include declarations in namespace contexts (including\n  /// the global namespace). If this is false, `includeGlobals()` will be\n  /// ignored.\n  bool includeNamespaceLevelDecls() const {\n    return CodeCompleteOpts.IncludeNamespaceLevelDecls;\n  }\n\n  /// Whether to include brief documentation comments within the set of\n  /// code completions returned.\n  bool includeBriefComments() const {\n    return CodeCompleteOpts.IncludeBriefComments;\n  }\n\n  /// Whether to include completion items with small fix-its, e.g. change\n  /// '.' to '->' on member access, etc.\n  bool includeFixIts() const { return CodeCompleteOpts.IncludeFixIts; }\n\n  /// Hint whether to load data from the external AST in order to provide\n  /// full results. If false, declarations from the preamble may be omitted.\n  bool loadExternal() const {\n    return CodeCompleteOpts.LoadExternal;\n  }\n\n  /// Deregisters and destroys this code-completion consumer.\n  virtual ~CodeCompleteConsumer();\n\n  /// \\name Code-completion filtering\n  /// Check if the result should be filtered out.\n  virtual bool isResultFilteredOut(StringRef Filter,\n                                   CodeCompletionResult Results) {\n    return false;\n  }\n\n  /// \\name Code-completion callbacks\n  //@{\n  /// Process the finalized code-completion results.\n  virtual void ProcessCodeCompleteResults(Sema &S,\n                                          CodeCompletionContext Context,\n                                          CodeCompletionResult *Results,\n                                          unsigned NumResults) {}\n\n  /// \\param S the semantic-analyzer object for which code-completion is being\n  /// done.\n  ///\n  /// \\param CurrentArg the index of the current argument.\n  ///\n  /// \\param Candidates an array of overload candidates.\n  ///\n  /// \\param NumCandidates the number of overload candidates\n  ///\n  /// \\param OpenParLoc location of the opening parenthesis of the argument\n  ///        list.\n  virtual void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                         OverloadCandidate *Candidates,\n                                         unsigned NumCandidates,\n                                         SourceLocation OpenParLoc) {}\n  //@}\n\n  /// Retrieve the allocator that will be used to allocate\n  /// code completion strings.\n  virtual CodeCompletionAllocator &getAllocator() = 0;\n\n  virtual CodeCompletionTUInfo &getCodeCompletionTUInfo() = 0;\n};\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Declaration.\nconst RawComment *getCompletionComment(const ASTContext &Ctx,\n                                       const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Pattern.\nconst RawComment *getPatternCompletionComment(const ASTContext &Ctx,\n                                              const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for OverloadCandidate.\nconst RawComment *\ngetParameterComment(const ASTContext &Ctx,\n                    const CodeCompleteConsumer::OverloadCandidate &Result,\n                    unsigned ArgIndex);\n\n/// A simple code-completion consumer that prints the results it\n/// receives in a simple format.\nclass PrintingCodeCompleteConsumer : public CodeCompleteConsumer {\n  /// The raw output stream.\n  raw_ostream &OS;\n\n  CodeCompletionTUInfo CCTUInfo;\n\npublic:\n  /// Create a new printing code-completion consumer that prints its\n  /// results to the given raw output stream.\n  PrintingCodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts,\n                               raw_ostream &OS)\n      : CodeCompleteConsumer(CodeCompleteOpts), OS(OS),\n        CCTUInfo(std::make_shared<GlobalCodeCompletionAllocator>()) {}\n\n  /// Prints the finalized code-completion results.\n  void ProcessCodeCompleteResults(Sema &S, CodeCompletionContext Context,\n                                  CodeCompletionResult *Results,\n                                  unsigned NumResults) override;\n\n  void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                 OverloadCandidate *Candidates,\n                                 unsigned NumCandidates,\n                                 SourceLocation OpenParLoc) override;\n\n  bool isResultFilteredOut(StringRef Filter, CodeCompletionResult Results) override;\n\n  CodeCompletionAllocator &getAllocator() override {\n    return CCTUInfo.getAllocator();\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() override { return CCTUInfo; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h", "content": "//===---- CodeCompleteOptions.h - Code Completion Options -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETEOPTIONS_H\n#define LLVM_CLANG_SEMA_CODECOMPLETEOPTIONS_H\n\nnamespace clang {\n\n/// Options controlling the behavior of code completion.\nclass CodeCompleteOptions {\npublic:\n  /// Show macros in code completion results.\n  unsigned IncludeMacros : 1;\n\n  /// Show code patterns in code completion results.\n  unsigned IncludeCodePatterns : 1;\n\n  /// Show top-level decls in code completion results.\n  unsigned IncludeGlobals : 1;\n\n  /// Show decls in namespace (including the global namespace) in code\n  /// completion results. If this is 0, `IncludeGlobals` will be ignored.\n  ///\n  /// Currently, this only works when completing qualified IDs (i.e.\n  /// `Sema::CodeCompleteQualifiedId`).\n  /// FIXME: consider supporting more completion cases with this option.\n  unsigned IncludeNamespaceLevelDecls : 1;\n\n  /// Show brief documentation comments in code completion results.\n  unsigned IncludeBriefComments : 1;\n\n  /// Hint whether to load data from the external AST to provide full results.\n  /// If false, namespace-level declarations and macros from the preamble may be\n  /// omitted.\n  unsigned LoadExternal : 1;\n\n  /// Include results after corrections (small fix-its), e.g. change '.' to '->'\n  /// on member access, etc.\n  unsigned IncludeFixIts : 1;\n\n  CodeCompleteOptions()\n      : IncludeMacros(0), IncludeCodePatterns(0), IncludeGlobals(1),\n        IncludeNamespaceLevelDecls(1), IncludeBriefComments(0),\n        LoadExternal(1), IncludeFixIts(0) {}\n};\n\n} // namespace clang\n\n#endif\n\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "content": "//===--- DeclSpec.h - Parsed declaration specifiers -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file defines the classes used to store parsed information about\n/// declaration-specifiers and declarators.\n///\n/// \\verbatim\n///   static const int volatile x, *y, *(*(*z)[10])(const void *x);\n///   ------------------------- -  --  ---------------------------\n///     declaration-specifiers  \\  |   /\n///                            declarators\n/// \\endverbatim\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_DECLSPEC_H\n#define LLVM_CLANG_SEMA_DECLSPEC_H\n\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/ParsedAttr.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n\nnamespace clang {\n  class ASTContext;\n  class CXXRecordDecl;\n  class TypeLoc;\n  class LangOptions;\n  class IdentifierInfo;\n  class NamespaceAliasDecl;\n  class NamespaceDecl;\n  class ObjCDeclSpec;\n  class Sema;\n  class Declarator;\n  struct TemplateIdAnnotation;\n\n/// Represents a C++ nested-name-specifier or a global scope specifier.\n///\n/// These can be in 3 states:\n///   1) Not present, identified by isEmpty()\n///   2) Present, identified by isNotEmpty()\n///      2.a) Valid, identified by isValid()\n///      2.b) Invalid, identified by isInvalid().\n///\n/// isSet() is deprecated because it mostly corresponded to \"valid\" but was\n/// often used as if it meant \"present\".\n///\n/// The actual scope is described by getScopeRep().\nclass CXXScopeSpec {\n  SourceRange Range;\n  NestedNameSpecifierLocBuilder Builder;\n\npublic:\n  SourceRange getRange() const { return Range; }\n  void setRange(SourceRange R) { Range = R; }\n  void setBeginLoc(SourceLocation Loc) { Range.setBegin(Loc); }\n  void setEndLoc(SourceLocation Loc) { Range.setEnd(Loc); }\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n\n  /// Retrieve the representation of the nested-name-specifier.\n  NestedNameSpecifier *getScopeRep() const {\n    return Builder.getRepresentation();\n  }\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'type::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param TemplateKWLoc The location of the 'template' keyword, if present.\n  ///\n  /// \\param TL The TypeLoc that describes the type preceding the '::'.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, SourceLocation TemplateKWLoc, TypeLoc TL,\n              SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'identifier::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Identifier The identifier.\n  ///\n  /// \\param IdentifierLoc The location of the identifier.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, IdentifierInfo *Identifier,\n              SourceLocation IdentifierLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Namespace The namespace.\n  ///\n  /// \\param NamespaceLoc The location of the namespace name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceDecl *Namespace,\n              SourceLocation NamespaceLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace-alias::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Alias The namespace alias.\n  ///\n  /// \\param AliasLoc The location of the namespace alias\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceAliasDecl *Alias,\n              SourceLocation AliasLoc, SourceLocation ColonColonLoc);\n\n  /// Turn this (empty) nested-name-specifier into the global\n  /// nested-name-specifier '::'.\n  void MakeGlobal(ASTContext &Context, SourceLocation ColonColonLoc);\n\n  /// Turns this (empty) nested-name-specifier into '__super'\n  /// nested-name-specifier.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param RD The declaration of the class in which nested-name-specifier\n  /// appeared.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void MakeSuper(ASTContext &Context, CXXRecordDecl *RD,\n                 SourceLocation SuperLoc, SourceLocation ColonColonLoc);\n\n  /// Make a new nested-name-specifier from incomplete source-location\n  /// information.\n  ///\n  /// FIXME: This routine should be used very, very rarely, in cases where we\n  /// need to synthesize a nested-name-specifier. Most code should instead use\n  /// \\c Adopt() with a proper \\c NestedNameSpecifierLoc.\n  void MakeTrivial(ASTContext &Context, NestedNameSpecifier *Qualifier,\n                   SourceRange R);\n\n  /// Adopt an existing nested-name-specifier (with source-range\n  /// information).\n  void Adopt(NestedNameSpecifierLoc Other);\n\n  /// Retrieve a nested-name-specifier with location information, copied\n  /// into the given AST context.\n  ///\n  /// \\param Context The context into which this nested-name-specifier will be\n  /// copied.\n  NestedNameSpecifierLoc getWithLocInContext(ASTContext &Context) const;\n\n  /// Retrieve the location of the name in the last qualifier\n  /// in this nested name specifier.\n  ///\n  /// For example, the location of \\c bar\n  /// in\n  /// \\verbatim\n  ///   \\::foo::bar<0>::\n  ///           ^~~\n  /// \\endverbatim\n  SourceLocation getLastQualifierNameLoc() const;\n\n  /// No scope specifier.\n  bool isEmpty() const { return Range.isInvalid() && getScopeRep() == nullptr; }\n  /// A scope specifier is present, but may be valid or invalid.\n  bool isNotEmpty() const { return !isEmpty(); }\n\n  /// An error occurred during parsing of the scope specifier.\n  bool isInvalid() const { return Range.isValid() && getScopeRep() == nullptr; }\n  /// A scope specifier is present, and it refers to a real scope.\n  bool isValid() const { return getScopeRep() != nullptr; }\n\n  /// Indicate that this nested-name-specifier is invalid.\n  void SetInvalid(SourceRange R) {\n    assert(R.isValid() && \"Must have a valid source range\");\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(R.getBegin());\n    Range.setEnd(R.getEnd());\n    Builder.Clear();\n  }\n\n  /// Deprecated.  Some call sites intend isNotEmpty() while others intend\n  /// isValid().\n  bool isSet() const { return getScopeRep() != nullptr; }\n\n  void clear() {\n    Range = SourceRange();\n    Builder.Clear();\n  }\n\n  /// Retrieve the data associated with the source-location information.\n  char *location_data() const { return Builder.getBuffer().first; }\n\n  /// Retrieve the size of the data associated with source-location\n  /// information.\n  unsigned location_size() const { return Builder.getBuffer().second; }\n};\n\n/// Captures information about \"declaration specifiers\".\n///\n/// \"Declaration specifiers\" encompasses storage-class-specifiers,\n/// type-specifiers, type-qualifiers, and function-specifiers.\nclass DeclSpec {\npublic:\n  /// storage-class-specifier\n  /// \\note The order of these enumerators is important for diagnostics.\n  enum SCS {\n    SCS_unspecified = 0,\n    SCS_typedef,\n    SCS_extern,\n    SCS_static,\n    SCS_auto,\n    SCS_register,\n    SCS_private_extern,\n    SCS_mutable\n  };\n\n  // Import thread storage class specifier enumeration and constants.\n  // These can be combined with SCS_extern and SCS_static.\n  typedef ThreadStorageClassSpecifier TSCS;\n  static const TSCS TSCS_unspecified = clang::TSCS_unspecified;\n  static const TSCS TSCS___thread = clang::TSCS___thread;\n  static const TSCS TSCS_thread_local = clang::TSCS_thread_local;\n  static const TSCS TSCS__Thread_local = clang::TSCS__Thread_local;\n\n  enum TSC {\n    TSC_unspecified,\n    TSC_imaginary,\n    TSC_complex\n  };\n\n  // Import type specifier type enumeration and constants.\n  typedef TypeSpecifierType TST;\n  static const TST TST_unspecified = clang::TST_unspecified;\n  static const TST TST_void = clang::TST_void;\n  static const TST TST_char = clang::TST_char;\n  static const TST TST_wchar = clang::TST_wchar;\n  static const TST TST_char8 = clang::TST_char8;\n  static const TST TST_char16 = clang::TST_char16;\n  static const TST TST_char32 = clang::TST_char32;\n  static const TST TST_int = clang::TST_int;\n  static const TST TST_int128 = clang::TST_int128;\n  static const TST TST_extint = clang::TST_extint;\n  static const TST TST_half = clang::TST_half;\n  static const TST TST_BFloat16 = clang::TST_BFloat16;\n  static const TST TST_float = clang::TST_float;\n  static const TST TST_double = clang::TST_double;\n  static const TST TST_float16 = clang::TST_Float16;\n  static const TST TST_accum = clang::TST_Accum;\n  static const TST TST_fract = clang::TST_Fract;\n  static const TST TST_float128 = clang::TST_float128;\n  static const TST TST_bool = clang::TST_bool;\n  static const TST TST_decimal32 = clang::TST_decimal32;\n  static const TST TST_decimal64 = clang::TST_decimal64;\n  static const TST TST_decimal128 = clang::TST_decimal128;\n  static const TST TST_enum = clang::TST_enum;\n  static const TST TST_union = clang::TST_union;\n  static const TST TST_struct = clang::TST_struct;\n  static const TST TST_interface = clang::TST_interface;\n  static const TST TST_class = clang::TST_class;\n  static const TST TST_typename = clang::TST_typename;\n  static const TST TST_typeofType = clang::TST_typeofType;\n  static const TST TST_typeofExpr = clang::TST_typeofExpr;\n  static const TST TST_decltype = clang::TST_decltype;\n  static const TST TST_decltype_auto = clang::TST_decltype_auto;\n  static const TST TST_underlyingType = clang::TST_underlyingType;\n  static const TST TST_auto = clang::TST_auto;\n  static const TST TST_auto_type = clang::TST_auto_type;\n  static const TST TST_unknown_anytype = clang::TST_unknown_anytype;\n  static const TST TST_atomic = clang::TST_atomic;\n#define GENERIC_IMAGE_TYPE(ImgType, Id) \\\n  static const TST TST_##ImgType##_t = clang::TST_##ImgType##_t;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  static const TST TST_error = clang::TST_error;\n\n  // type-qualifiers\n  enum TQ {   // NOTE: These flags must be kept in sync with Qualifiers::TQ.\n    TQ_unspecified = 0,\n    TQ_const       = 1,\n    TQ_restrict    = 2,\n    TQ_volatile    = 4,\n    TQ_unaligned   = 8,\n    // This has no corresponding Qualifiers::TQ value, because it's not treated\n    // as a qualifier in our type system.\n    TQ_atomic      = 16\n  };\n\n  /// ParsedSpecifiers - Flags to query which specifiers were applied.  This is\n  /// returned by getParsedSpecifiers.\n  enum ParsedSpecifiers {\n    PQ_None                  = 0,\n    PQ_StorageClassSpecifier = 1,\n    PQ_TypeSpecifier         = 2,\n    PQ_TypeQualifier         = 4,\n    PQ_FunctionSpecifier     = 8\n    // FIXME: Attributes should be included here.\n  };\n\nprivate:\n  // storage-class-specifier\n  /*SCS*/unsigned StorageClassSpec : 3;\n  /*TSCS*/unsigned ThreadStorageClassSpec : 2;\n  unsigned SCS_extern_in_linkage_spec : 1;\n\n  // type-specifier\n  /*TypeSpecifierWidth*/ unsigned TypeSpecWidth : 2;\n  /*TSC*/unsigned TypeSpecComplex : 2;\n  /*TSS*/unsigned TypeSpecSign : 2;\n  /*TST*/unsigned TypeSpecType : 6;\n  unsigned TypeAltiVecVector : 1;\n  unsigned TypeAltiVecPixel : 1;\n  unsigned TypeAltiVecBool : 1;\n  unsigned TypeSpecOwned : 1;\n  unsigned TypeSpecPipe : 1;\n  unsigned TypeSpecSat : 1;\n  unsigned ConstrainedAuto : 1;\n\n  // type-qualifiers\n  unsigned TypeQualifiers : 5;  // Bitwise OR of TQ.\n\n  // function-specifier\n  unsigned FS_inline_specified : 1;\n  unsigned FS_forceinline_specified: 1;\n  unsigned FS_virtual_specified : 1;\n  unsigned FS_noreturn_specified : 1;\n\n  // friend-specifier\n  unsigned Friend_specified : 1;\n\n  // constexpr-specifier\n  unsigned ConstexprSpecifier : 2;\n\n  union {\n    UnionParsedType TypeRep;\n    Decl *DeclRep;\n    Expr *ExprRep;\n    TemplateIdAnnotation *TemplateIdRep;\n  };\n\n  /// ExplicitSpecifier - Store information about explicit spicifer.\n  ExplicitSpecifier FS_explicit_specifier;\n\n  // attributes.\n  ParsedAttributes Attrs;\n\n  // Scope specifier for the type spec, if applicable.\n  CXXScopeSpec TypeScope;\n\n  // SourceLocation info.  These are null if the item wasn't specified or if\n  // the setting was synthesized.\n  SourceRange Range;\n\n  SourceLocation StorageClassSpecLoc, ThreadStorageClassSpecLoc;\n  SourceRange TSWRange;\n  SourceLocation TSCLoc, TSSLoc, TSTLoc, AltiVecLoc, TSSatLoc;\n  /// TSTNameLoc - If TypeSpecType is any of class, enum, struct, union,\n  /// typename, then this is the location of the named type (if present);\n  /// otherwise, it is the same as TSTLoc. Hence, the pair TSTLoc and\n  /// TSTNameLoc provides source range info for tag types.\n  SourceLocation TSTNameLoc;\n  SourceRange TypeofParensRange;\n  SourceLocation TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc,\n      TQ_unalignedLoc;\n  SourceLocation FS_inlineLoc, FS_virtualLoc, FS_explicitLoc, FS_noreturnLoc;\n  SourceLocation FS_explicitCloseParenLoc;\n  SourceLocation FS_forceinlineLoc;\n  SourceLocation FriendLoc, ModulePrivateLoc, ConstexprLoc;\n  SourceLocation TQ_pipeLoc;\n\n  WrittenBuiltinSpecs writtenBS;\n  void SaveWrittenBuiltinSpecs();\n\n  ObjCDeclSpec *ObjCQualifiers;\n\n  static bool isTypeRep(TST T) {\n    return (T == TST_typename || T == TST_typeofType ||\n            T == TST_underlyingType || T == TST_atomic);\n  }\n  static bool isExprRep(TST T) {\n    return (T == TST_typeofExpr || T == TST_decltype || T == TST_extint);\n  }\n  static bool isTemplateIdRep(TST T) {\n    return (T == TST_auto || T == TST_decltype_auto);\n  }\n\n  DeclSpec(const DeclSpec &) = delete;\n  void operator=(const DeclSpec &) = delete;\npublic:\n  static bool isDeclRep(TST T) {\n    return (T == TST_enum || T == TST_struct ||\n            T == TST_interface || T == TST_union ||\n            T == TST_class);\n  }\n\n  DeclSpec(AttributeFactory &attrFactory)\n      : StorageClassSpec(SCS_unspecified),\n        ThreadStorageClassSpec(TSCS_unspecified),\n        SCS_extern_in_linkage_spec(false),\n        TypeSpecWidth(static_cast<unsigned>(TypeSpecifierWidth::Unspecified)),\n        TypeSpecComplex(TSC_unspecified),\n        TypeSpecSign(static_cast<unsigned>(TypeSpecifierSign::Unspecified)),\n        TypeSpecType(TST_unspecified), TypeAltiVecVector(false),\n        TypeAltiVecPixel(false), TypeAltiVecBool(false), TypeSpecOwned(false),\n        TypeSpecPipe(false), TypeSpecSat(false), ConstrainedAuto(false),\n        TypeQualifiers(TQ_unspecified), FS_inline_specified(false),\n        FS_forceinline_specified(false), FS_virtual_specified(false),\n        FS_noreturn_specified(false), Friend_specified(false),\n        ConstexprSpecifier(\n            static_cast<unsigned>(ConstexprSpecKind::Unspecified)),\n        FS_explicit_specifier(), Attrs(attrFactory), writtenBS(),\n        ObjCQualifiers(nullptr) {}\n\n  // storage-class-specifier\n  SCS getStorageClassSpec() const { return (SCS)StorageClassSpec; }\n  TSCS getThreadStorageClassSpec() const {\n    return (TSCS)ThreadStorageClassSpec;\n  }\n  bool isExternInLinkageSpec() const { return SCS_extern_in_linkage_spec; }\n  void setExternInLinkageSpec(bool Value) {\n    SCS_extern_in_linkage_spec = Value;\n  }\n\n  SourceLocation getStorageClassSpecLoc() const { return StorageClassSpecLoc; }\n  SourceLocation getThreadStorageClassSpecLoc() const {\n    return ThreadStorageClassSpecLoc;\n  }\n\n  void ClearStorageClassSpecs() {\n    StorageClassSpec           = DeclSpec::SCS_unspecified;\n    ThreadStorageClassSpec     = DeclSpec::TSCS_unspecified;\n    SCS_extern_in_linkage_spec = false;\n    StorageClassSpecLoc        = SourceLocation();\n    ThreadStorageClassSpecLoc  = SourceLocation();\n  }\n\n  void ClearTypeSpecType() {\n    TypeSpecType = DeclSpec::TST_unspecified;\n    TypeSpecOwned = false;\n    TSTLoc = SourceLocation();\n  }\n\n  // type-specifier\n  TypeSpecifierWidth getTypeSpecWidth() const {\n    return static_cast<TypeSpecifierWidth>(TypeSpecWidth);\n  }\n  TSC getTypeSpecComplex() const { return (TSC)TypeSpecComplex; }\n  TypeSpecifierSign getTypeSpecSign() const {\n    return static_cast<TypeSpecifierSign>(TypeSpecSign);\n  }\n  TST getTypeSpecType() const { return (TST)TypeSpecType; }\n  bool isTypeAltiVecVector() const { return TypeAltiVecVector; }\n  bool isTypeAltiVecPixel() const { return TypeAltiVecPixel; }\n  bool isTypeAltiVecBool() const { return TypeAltiVecBool; }\n  bool isTypeSpecOwned() const { return TypeSpecOwned; }\n  bool isTypeRep() const { return isTypeRep((TST) TypeSpecType); }\n  bool isTypeSpecPipe() const { return TypeSpecPipe; }\n  bool isTypeSpecSat() const { return TypeSpecSat; }\n  bool isConstrainedAuto() const { return ConstrainedAuto; }\n\n  ParsedType getRepAsType() const {\n    assert(isTypeRep((TST) TypeSpecType) && \"DeclSpec does not store a type\");\n    return TypeRep;\n  }\n  Decl *getRepAsDecl() const {\n    assert(isDeclRep((TST) TypeSpecType) && \"DeclSpec does not store a decl\");\n    return DeclRep;\n  }\n  Expr *getRepAsExpr() const {\n    assert(isExprRep((TST) TypeSpecType) && \"DeclSpec does not store an expr\");\n    return ExprRep;\n  }\n  TemplateIdAnnotation *getRepAsTemplateId() const {\n    assert(isTemplateIdRep((TST) TypeSpecType) &&\n           \"DeclSpec does not store a template id\");\n    return TemplateIdRep;\n  }\n  CXXScopeSpec &getTypeSpecScope() { return TypeScope; }\n  const CXXScopeSpec &getTypeSpecScope() const { return TypeScope; }\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceLocation getTypeSpecWidthLoc() const { return TSWRange.getBegin(); }\n  SourceRange getTypeSpecWidthRange() const { return TSWRange; }\n  SourceLocation getTypeSpecComplexLoc() const { return TSCLoc; }\n  SourceLocation getTypeSpecSignLoc() const { return TSSLoc; }\n  SourceLocation getTypeSpecTypeLoc() const { return TSTLoc; }\n  SourceLocation getAltiVecLoc() const { return AltiVecLoc; }\n  SourceLocation getTypeSpecSatLoc() const { return TSSatLoc; }\n\n  SourceLocation getTypeSpecTypeNameLoc() const {\n    assert(isDeclRep((TST) TypeSpecType) || TypeSpecType == TST_typename);\n    return TSTNameLoc;\n  }\n\n  SourceRange getTypeofParensRange() const { return TypeofParensRange; }\n  void setTypeofParensRange(SourceRange range) { TypeofParensRange = range; }\n\n  bool hasAutoTypeSpec() const {\n    return (TypeSpecType == TST_auto || TypeSpecType == TST_auto_type ||\n            TypeSpecType == TST_decltype_auto);\n  }\n\n  bool hasTagDefinition() const;\n\n  /// Turn a type-specifier-type into a string like \"_Bool\" or \"union\".\n  static const char *getSpecifierName(DeclSpec::TST T,\n                                      const PrintingPolicy &Policy);\n  static const char *getSpecifierName(DeclSpec::TQ Q);\n  static const char *getSpecifierName(TypeSpecifierSign S);\n  static const char *getSpecifierName(DeclSpec::TSC C);\n  static const char *getSpecifierName(TypeSpecifierWidth W);\n  static const char *getSpecifierName(DeclSpec::SCS S);\n  static const char *getSpecifierName(DeclSpec::TSCS S);\n  static const char *getSpecifierName(ConstexprSpecKind C);\n\n  // type-qualifiers\n\n  /// getTypeQualifiers - Return a set of TQs.\n  unsigned getTypeQualifiers() const { return TypeQualifiers; }\n  SourceLocation getConstSpecLoc() const { return TQ_constLoc; }\n  SourceLocation getRestrictSpecLoc() const { return TQ_restrictLoc; }\n  SourceLocation getVolatileSpecLoc() const { return TQ_volatileLoc; }\n  SourceLocation getAtomicSpecLoc() const { return TQ_atomicLoc; }\n  SourceLocation getUnalignedSpecLoc() const { return TQ_unalignedLoc; }\n  SourceLocation getPipeLoc() const { return TQ_pipeLoc; }\n\n  /// Clear out all of the type qualifiers.\n  void ClearTypeQualifiers() {\n    TypeQualifiers = 0;\n    TQ_constLoc = SourceLocation();\n    TQ_restrictLoc = SourceLocation();\n    TQ_volatileLoc = SourceLocation();\n    TQ_atomicLoc = SourceLocation();\n    TQ_unalignedLoc = SourceLocation();\n    TQ_pipeLoc = SourceLocation();\n  }\n\n  // function-specifier\n  bool isInlineSpecified() const {\n    return FS_inline_specified | FS_forceinline_specified;\n  }\n  SourceLocation getInlineSpecLoc() const {\n    return FS_inline_specified ? FS_inlineLoc : FS_forceinlineLoc;\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() const {\n    return FS_explicit_specifier;\n  }\n\n  bool isVirtualSpecified() const { return FS_virtual_specified; }\n  SourceLocation getVirtualSpecLoc() const { return FS_virtualLoc; }\n\n  bool hasExplicitSpecifier() const {\n    return FS_explicit_specifier.isSpecified();\n  }\n  SourceLocation getExplicitSpecLoc() const { return FS_explicitLoc; }\n  SourceRange getExplicitSpecRange() const {\n    return FS_explicit_specifier.getExpr()\n               ? SourceRange(FS_explicitLoc, FS_explicitCloseParenLoc)\n               : SourceRange(FS_explicitLoc);\n  }\n\n  bool isNoreturnSpecified() const { return FS_noreturn_specified; }\n  SourceLocation getNoreturnSpecLoc() const { return FS_noreturnLoc; }\n\n  void ClearFunctionSpecs() {\n    FS_inline_specified = false;\n    FS_inlineLoc = SourceLocation();\n    FS_forceinline_specified = false;\n    FS_forceinlineLoc = SourceLocation();\n    FS_virtual_specified = false;\n    FS_virtualLoc = SourceLocation();\n    FS_explicit_specifier = ExplicitSpecifier();\n    FS_explicitLoc = SourceLocation();\n    FS_explicitCloseParenLoc = SourceLocation();\n    FS_noreturn_specified = false;\n    FS_noreturnLoc = SourceLocation();\n  }\n\n  /// This method calls the passed in handler on each CVRU qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachCVRUQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// This method calls the passed in handler on each qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// Return true if any type-specifier has been found.\n  bool hasTypeSpecifier() const {\n    return getTypeSpecType() != DeclSpec::TST_unspecified ||\n           getTypeSpecWidth() != TypeSpecifierWidth::Unspecified ||\n           getTypeSpecComplex() != DeclSpec::TSC_unspecified ||\n           getTypeSpecSign() != TypeSpecifierSign::Unspecified;\n  }\n\n  /// Return a bitmask of which flavors of specifiers this\n  /// DeclSpec includes.\n  unsigned getParsedSpecifiers() const;\n\n  /// isEmpty - Return true if this declaration specifier is completely empty:\n  /// no tokens were parsed in the production of it.\n  bool isEmpty() const {\n    return getParsedSpecifiers() == DeclSpec::PQ_None;\n  }\n\n  void SetRangeStart(SourceLocation Loc) { Range.setBegin(Loc); }\n  void SetRangeEnd(SourceLocation Loc) { Range.setEnd(Loc); }\n\n  /// These methods set the specified attribute of the DeclSpec and\n  /// return false if there was no error.  If an error occurs (for\n  /// example, if we tried to set \"auto\" on a spec with \"extern\"\n  /// already set), they return true and set PrevSpec and DiagID\n  /// such that\n  ///   Diag(Loc, DiagID) << PrevSpec;\n  /// will yield a useful result.\n  ///\n  /// TODO: use a more general approach that still allows these\n  /// diagnostics to be ignored when desired.\n  bool SetStorageClassSpec(Sema &S, SCS SC, SourceLocation Loc,\n                           const char *&PrevSpec, unsigned &DiagID,\n                           const PrintingPolicy &Policy);\n  bool SetStorageClassSpecThread(TSCS TSC, SourceLocation Loc,\n                                 const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecWidth(TypeSpecifierWidth W, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID,\n                        const PrintingPolicy &Policy);\n  bool SetTypeSpecComplex(TSC C, SourceLocation Loc, const char *&PrevSpec,\n                          unsigned &DiagID);\n  bool SetTypeSpecSign(TypeSpecifierSign S, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TypeResult Rep,\n                       const PrintingPolicy &Policy) {\n    if (Rep.isInvalid())\n      return SetTypeSpecError();\n    return SetTypeSpecType(T, Loc, PrevSpec, DiagID, Rep.get(), Policy);\n  }\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TemplateIdAnnotation *Rep,\n                       const PrintingPolicy &Policy);\n\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Expr *Rep,\n                       const PrintingPolicy &policy);\n  bool SetTypeAltiVecVector(bool isAltiVecVector, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecPixel(bool isAltiVecPixel, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecBool(bool isAltiVecBool, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypePipe(bool isPipe, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetExtIntType(SourceLocation KWLoc, Expr *BitWidth,\n                     const char *&PrevSpec, unsigned &DiagID,\n                     const PrintingPolicy &Policy);\n  bool SetTypeSpecSat(SourceLocation Loc, const char *&PrevSpec,\n                      unsigned &DiagID);\n  bool SetTypeSpecError();\n  void UpdateDeclRep(Decl *Rep) {\n    assert(isDeclRep((TST) TypeSpecType));\n    DeclRep = Rep;\n  }\n  void UpdateTypeRep(ParsedType Rep) {\n    assert(isTypeRep((TST) TypeSpecType));\n    TypeRep = Rep;\n  }\n  void UpdateExprRep(Expr *Rep) {\n    assert(isExprRep((TST) TypeSpecType));\n    ExprRep = Rep;\n  }\n\n  bool SetTypeQual(TQ T, SourceLocation Loc);\n\n  bool SetTypeQual(TQ T, SourceLocation Loc, const char *&PrevSpec,\n                   unsigned &DiagID, const LangOptions &Lang);\n\n  bool setFunctionSpecInline(SourceLocation Loc, const char *&PrevSpec,\n                             unsigned &DiagID);\n  bool setFunctionSpecForceInline(SourceLocation Loc, const char *&PrevSpec,\n                                  unsigned &DiagID);\n  bool setFunctionSpecVirtual(SourceLocation Loc, const char *&PrevSpec,\n                              unsigned &DiagID);\n  bool setFunctionSpecExplicit(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID, ExplicitSpecifier ExplicitSpec,\n                               SourceLocation CloseParenLoc);\n  bool setFunctionSpecNoreturn(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID);\n\n  bool SetFriendSpec(SourceLocation Loc, const char *&PrevSpec,\n                     unsigned &DiagID);\n  bool setModulePrivateSpec(SourceLocation Loc, const char *&PrevSpec,\n                            unsigned &DiagID);\n  bool SetConstexprSpec(ConstexprSpecKind ConstexprKind, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID);\n\n  bool isFriendSpecified() const { return Friend_specified; }\n  SourceLocation getFriendSpecLoc() const { return FriendLoc; }\n\n  bool isModulePrivateSpecified() const { return ModulePrivateLoc.isValid(); }\n  SourceLocation getModulePrivateSpecLoc() const { return ModulePrivateLoc; }\n\n  ConstexprSpecKind getConstexprSpecifier() const {\n    return ConstexprSpecKind(ConstexprSpecifier);\n  }\n\n  SourceLocation getConstexprSpecLoc() const { return ConstexprLoc; }\n  bool hasConstexprSpecifier() const {\n    return getConstexprSpecifier() != ConstexprSpecKind::Unspecified;\n  }\n\n  void ClearConstexprSpec() {\n    ConstexprSpecifier = static_cast<unsigned>(ConstexprSpecKind::Unspecified);\n    ConstexprLoc = SourceLocation();\n  }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// Concatenates two attribute lists.\n  ///\n  /// The GCC attribute syntax allows for the following:\n  ///\n  /// \\code\n  /// short __attribute__(( unused, deprecated ))\n  /// int __attribute__(( may_alias, aligned(16) )) var;\n  /// \\endcode\n  ///\n  /// This declares 4 attributes using 2 lists. The following syntax is\n  /// also allowed and equivalent to the previous declaration.\n  ///\n  /// \\code\n  /// short __attribute__((unused)) __attribute__((deprecated))\n  /// int __attribute__((may_alias)) __attribute__((aligned(16))) var;\n  /// \\endcode\n  ///\n  void addAttributes(ParsedAttributesView &AL) {\n    Attrs.addAll(AL.begin(), AL.end());\n  }\n\n  bool hasAttributes() const { return !Attrs.empty(); }\n\n  ParsedAttributes &getAttributes() { return Attrs; }\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n\n  void takeAttributesFrom(ParsedAttributes &attrs) {\n    Attrs.takeAllFrom(attrs);\n  }\n\n  /// Finish - This does final analysis of the declspec, issuing diagnostics for\n  /// things like \"_Imaginary\" (lacking an FP type).  After calling this method,\n  /// DeclSpec is guaranteed self-consistent, even if an error occurred.\n  void Finish(Sema &S, const PrintingPolicy &Policy);\n\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return writtenBS;\n  }\n\n  ObjCDeclSpec *getObjCQualifiers() const { return ObjCQualifiers; }\n  void setObjCQualifiers(ObjCDeclSpec *quals) { ObjCQualifiers = quals; }\n\n  /// Checks if this DeclSpec can stand alone, without a Declarator.\n  ///\n  /// Only tag declspecs can stand alone.\n  bool isMissingDeclaratorOk();\n};\n\n/// Captures information about \"declaration specifiers\" specific to\n/// Objective-C.\nclass ObjCDeclSpec {\npublic:\n  /// ObjCDeclQualifier - Qualifier used on types in method\n  /// declarations.  Not all combinations are sensible.  Parameters\n  /// can be one of { in, out, inout } with one of { bycopy, byref }.\n  /// Returns can either be { oneway } or not.\n  ///\n  /// This should be kept in sync with Decl::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    DQ_None = 0x0,\n    DQ_In = 0x1,\n    DQ_Inout = 0x2,\n    DQ_Out = 0x4,\n    DQ_Bycopy = 0x8,\n    DQ_Byref = 0x10,\n    DQ_Oneway = 0x20,\n    DQ_CSNullability = 0x40\n  };\n\n  ObjCDeclSpec()\n      : objcDeclQualifier(DQ_None),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr), Nullability(0),\n        GetterName(nullptr), SetterName(nullptr) {}\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    return (ObjCDeclQualifier)objcDeclQualifier;\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier DQVal) {\n    objcDeclQualifier = (ObjCDeclQualifier) (objcDeclQualifier | DQVal);\n  }\n  void clearObjCDeclQualifier(ObjCDeclQualifier DQVal) {\n    objcDeclQualifier = (ObjCDeclQualifier) (objcDeclQualifier & ~DQVal);\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes =\n        (ObjCPropertyAttribute::Kind)(PropertyAttributes | PRVal);\n  }\n\n  NullabilityKind getNullability() const {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Objective-C declspec doesn't have nullability\");\n    return static_cast<NullabilityKind>(Nullability);\n  }\n\n  SourceLocation getNullabilityLoc() const {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Objective-C declspec doesn't have nullability\");\n    return NullabilityLoc;\n  }\n\n  void setNullability(SourceLocation loc, NullabilityKind kind) {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Set the nullability declspec or property attribute first\");\n    Nullability = static_cast<unsigned>(kind);\n    NullabilityLoc = loc;\n  }\n\n  const IdentifierInfo *getGetterName() const { return GetterName; }\n  IdentifierInfo *getGetterName() { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n  void setGetterName(IdentifierInfo *name, SourceLocation loc) {\n    GetterName = name;\n    GetterNameLoc = loc;\n  }\n\n  const IdentifierInfo *getSetterName() const { return SetterName; }\n  IdentifierInfo *getSetterName() { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n  void setSetterName(IdentifierInfo *name, SourceLocation loc) {\n    SetterName = name;\n    SetterNameLoc = loc;\n  }\n\nprivate:\n  // FIXME: These two are unrelated and mutually exclusive. So perhaps\n  // we can put them in a union to reflect their mutual exclusivity\n  // (space saving is negligible).\n  unsigned objcDeclQualifier : 7;\n\n  // NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttribute::Kind\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n\n  unsigned Nullability : 2;\n\n  SourceLocation NullabilityLoc;\n\n  IdentifierInfo *GetterName;    // getter name or NULL if no getter\n  IdentifierInfo *SetterName;    // setter name or NULL if no setter\n  SourceLocation GetterNameLoc; // location of the getter attribute's value\n  SourceLocation SetterNameLoc; // location of the setter attribute's value\n\n};\n\n/// Describes the kind of unqualified-id parsed.\nenum class UnqualifiedIdKind {\n  /// An identifier.\n  IK_Identifier,\n  /// An overloaded operator name, e.g., operator+.\n  IK_OperatorFunctionId,\n  /// A conversion function name, e.g., operator int.\n  IK_ConversionFunctionId,\n  /// A user-defined literal name, e.g., operator \"\" _i.\n  IK_LiteralOperatorId,\n  /// A constructor name.\n  IK_ConstructorName,\n  /// A constructor named via a template-id.\n  IK_ConstructorTemplateId,\n  /// A destructor name.\n  IK_DestructorName,\n  /// A template-id, e.g., f<int>.\n  IK_TemplateId,\n  /// An implicit 'self' parameter\n  IK_ImplicitSelfParam,\n  /// A deduction-guide name (a template-name)\n  IK_DeductionGuideName\n};\n\n/// Represents a C++ unqualified-id that has been parsed.\nclass UnqualifiedId {\nprivate:\n  UnqualifiedId(const UnqualifiedId &Other) = delete;\n  const UnqualifiedId &operator=(const UnqualifiedId &) = delete;\n\npublic:\n  /// Describes the kind of unqualified-id parsed.\n  UnqualifiedIdKind Kind;\n\n  struct OFI {\n    /// The kind of overloaded operator.\n    OverloadedOperatorKind Operator;\n\n    /// The source locations of the individual tokens that name\n    /// the operator, e.g., the \"new\", \"[\", and \"]\" tokens in\n    /// operator new [].\n    ///\n    /// Different operators have different numbers of tokens in their name,\n    /// up to three. Any remaining source locations in this array will be\n    /// set to an invalid value for operators with fewer than three tokens.\n    SourceLocation SymbolLocations[3];\n  };\n\n  /// Anonymous union that holds extra data associated with the\n  /// parsed unqualified-id.\n  union {\n    /// When Kind == IK_Identifier, the parsed identifier, or when\n    /// Kind == IK_UserLiteralId, the identifier suffix.\n    IdentifierInfo *Identifier;\n\n    /// When Kind == IK_OperatorFunctionId, the overloaded operator\n    /// that we parsed.\n    struct OFI OperatorFunctionId;\n\n    /// When Kind == IK_ConversionFunctionId, the type that the\n    /// conversion function names.\n    UnionParsedType ConversionFunctionId;\n\n    /// When Kind == IK_ConstructorName, the class-name of the type\n    /// whose constructor is being referenced.\n    UnionParsedType ConstructorName;\n\n    /// When Kind == IK_DestructorName, the type referred to by the\n    /// class-name.\n    UnionParsedType DestructorName;\n\n    /// When Kind == IK_DeductionGuideName, the parsed template-name.\n    UnionParsedTemplateTy TemplateName;\n\n    /// When Kind == IK_TemplateId or IK_ConstructorTemplateId,\n    /// the template-id annotation that contains the template name and\n    /// template arguments.\n    TemplateIdAnnotation *TemplateId;\n  };\n\n  /// The location of the first token that describes this unqualified-id,\n  /// which will be the location of the identifier, \"operator\" keyword,\n  /// tilde (for a destructor), or the template name of a template-id.\n  SourceLocation StartLocation;\n\n  /// The location of the last token that describes this unqualified-id.\n  SourceLocation EndLocation;\n\n  UnqualifiedId()\n      : Kind(UnqualifiedIdKind::IK_Identifier), Identifier(nullptr) {}\n\n  /// Clear out this unqualified-id, setting it to default (invalid)\n  /// state.\n  void clear() {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = nullptr;\n    StartLocation = SourceLocation();\n    EndLocation = SourceLocation();\n  }\n\n  /// Determine whether this unqualified-id refers to a valid name.\n  bool isValid() const { return StartLocation.isValid(); }\n\n  /// Determine whether this unqualified-id refers to an invalid name.\n  bool isInvalid() const { return !isValid(); }\n\n  /// Determine what kind of name we have.\n  UnqualifiedIdKind getKind() const { return Kind; }\n\n  /// Specify that this unqualified-id was parsed as an identifier.\n  ///\n  /// \\param Id the parsed identifier.\n  /// \\param IdLoc the location of the parsed identifier.\n  void setIdentifier(const IdentifierInfo *Id, SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as an\n  /// operator-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Op the overloaded operator.\n  ///\n  /// \\param SymbolLocations the locations of the individual operator symbols\n  /// in the operator.\n  void setOperatorFunctionId(SourceLocation OperatorLoc,\n                             OverloadedOperatorKind Op,\n                             SourceLocation SymbolLocations[3]);\n\n  /// Specify that this unqualified-id was parsed as a\n  /// conversion-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Ty the type to which this conversion function is converting.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConversionFunctionId(SourceLocation OperatorLoc,\n                               ParsedType Ty,\n                               SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConversionFunctionId;\n    StartLocation = OperatorLoc;\n    EndLocation = EndLoc;\n    ConversionFunctionId = Ty;\n  }\n\n  /// Specific that this unqualified-id was parsed as a\n  /// literal-operator-id.\n  ///\n  /// \\param Id the parsed identifier.\n  ///\n  /// \\param OpLoc the location of the 'operator' keyword.\n  ///\n  /// \\param IdLoc the location of the identifier.\n  void setLiteralOperatorId(const IdentifierInfo *Id, SourceLocation OpLoc,\n                              SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_LiteralOperatorId;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = OpLoc;\n    EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as a constructor name.\n  ///\n  /// \\param ClassType the class type referred to by the constructor name.\n  ///\n  /// \\param ClassNameLoc the location of the class name.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConstructorName(ParsedType ClassType,\n                          SourceLocation ClassNameLoc,\n                          SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConstructorName;\n    StartLocation = ClassNameLoc;\n    EndLocation = EndLoc;\n    ConstructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a\n  /// template-id that names a constructor.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setConstructorTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a destructor name.\n  ///\n  /// \\param TildeLoc the location of the '~' that introduces the destructor\n  /// name.\n  ///\n  /// \\param ClassType the name of the class referred to by the destructor name.\n  void setDestructorName(SourceLocation TildeLoc,\n                         ParsedType ClassType,\n                         SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_DestructorName;\n    StartLocation = TildeLoc;\n    EndLocation = EndLoc;\n    DestructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a template-id.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a template-name for\n  /// a deduction-guide.\n  ///\n  /// \\param Template The parsed template-name.\n  /// \\param TemplateLoc The location of the parsed template-name.\n  void setDeductionGuideName(ParsedTemplateTy Template,\n                             SourceLocation TemplateLoc) {\n    Kind = UnqualifiedIdKind::IK_DeductionGuideName;\n    TemplateName = Template;\n    StartLocation = EndLocation = TemplateLoc;\n  }\n\n  /// Specify that this unqualified-id is an implicit 'self'\n  /// parameter.\n  ///\n  /// \\param Id the identifier.\n  void setImplicitSelfParam(const IdentifierInfo *Id) {\n    Kind = UnqualifiedIdKind::IK_ImplicitSelfParam;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = SourceLocation();\n  }\n\n  /// Return the source range that covers this unqualified-id.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(StartLocation, EndLocation);\n  }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLocation; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return EndLocation; }\n};\n\n/// A set of tokens that has been cached for later parsing.\ntypedef SmallVector<Token, 4> CachedTokens;\n\n/// One instance of this struct is used for each type in a\n/// declarator that is parsed.\n///\n/// This is intended to be a small value object.\nstruct DeclaratorChunk {\n  DeclaratorChunk() {};\n\n  enum {\n    Pointer, Reference, Array, Function, BlockPointer, MemberPointer, Paren, Pipe\n  } Kind;\n\n  /// Loc - The place where this type was defined.\n  SourceLocation Loc;\n  /// EndLoc - If valid, the place where this chunck ends.\n  SourceLocation EndLoc;\n\n  SourceRange getSourceRange() const {\n    if (EndLoc.isInvalid())\n      return SourceRange(Loc, Loc);\n    return SourceRange(Loc, EndLoc);\n  }\n\n  ParsedAttributesView AttrList;\n\n  struct PointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/unaligned/atomic.\n    unsigned TypeQuals : 5;\n\n    /// The location of the const-qualifier, if any.\n    SourceLocation ConstQualLoc;\n\n    /// The location of the volatile-qualifier, if any.\n    SourceLocation VolatileQualLoc;\n\n    /// The location of the restrict-qualifier, if any.\n    SourceLocation RestrictQualLoc;\n\n    /// The location of the _Atomic-qualifier, if any.\n    SourceLocation AtomicQualLoc;\n\n    /// The location of the __unaligned-qualifier, if any.\n    SourceLocation UnalignedQualLoc;\n\n    void destroy() {\n    }\n  };\n\n  struct ReferenceTypeInfo {\n    /// The type qualifier: restrict. [GNU] C++ extension\n    bool HasRestrict : 1;\n    /// True if this is an lvalue reference, false if it's an rvalue reference.\n    bool LValueRef : 1;\n    void destroy() {\n    }\n  };\n\n  struct ArrayTypeInfo {\n    /// The type qualifiers for the array:\n    /// const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    /// True if this dimension included the 'static' keyword.\n    unsigned hasStatic : 1;\n\n    /// True if this dimension was [*].  In this case, NumElts is null.\n    unsigned isStar : 1;\n\n    /// This is the size of the array, or null if [] or [*] was specified.\n    /// Since the parser is multi-purpose, and we don't want to impose a root\n    /// expression class on all clients, NumElts is untyped.\n    Expr *NumElts;\n\n    void destroy() {}\n  };\n\n  /// ParamInfo - An array of paraminfo objects is allocated whenever a function\n  /// declarator is parsed.  There are two interesting styles of parameters\n  /// here:\n  /// K&R-style identifier lists and parameter type lists.  K&R-style identifier\n  /// lists will have information about the identifier, but no type information.\n  /// Parameter type lists will have type info (if the actions module provides\n  /// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.\n  struct ParamInfo {\n    IdentifierInfo *Ident;\n    SourceLocation IdentLoc;\n    Decl *Param;\n\n    /// DefaultArgTokens - When the parameter's default argument\n    /// cannot be parsed immediately (because it occurs within the\n    /// declaration of a member function), it will be stored here as a\n    /// sequence of tokens to be parsed once the class definition is\n    /// complete. Non-NULL indicates that there is a default argument.\n    std::unique_ptr<CachedTokens> DefaultArgTokens;\n\n    ParamInfo() = default;\n    ParamInfo(IdentifierInfo *ident, SourceLocation iloc,\n              Decl *param,\n              std::unique_ptr<CachedTokens> DefArgTokens = nullptr)\n      : Ident(ident), IdentLoc(iloc), Param(param),\n        DefaultArgTokens(std::move(DefArgTokens)) {}\n  };\n\n  struct TypeAndRange {\n    ParsedType Ty;\n    SourceRange Range;\n  };\n\n  struct FunctionTypeInfo {\n    /// hasPrototype - This is true if the function had at least one typed\n    /// parameter.  If the function is () or (a,b,c), then it has no prototype,\n    /// and is treated as a K&R-style function.\n    unsigned hasPrototype : 1;\n\n    /// isVariadic - If this function has a prototype, and if that\n    /// proto ends with ',...)', this is true. When true, EllipsisLoc\n    /// contains the location of the ellipsis.\n    unsigned isVariadic : 1;\n\n    /// Can this declaration be a constructor-style initializer?\n    unsigned isAmbiguous : 1;\n\n    /// Whether the ref-qualifier (if any) is an lvalue reference.\n    /// Otherwise, it's an rvalue reference.\n    unsigned RefQualifierIsLValueRef : 1;\n\n    /// ExceptionSpecType - An ExceptionSpecificationType value.\n    unsigned ExceptionSpecType : 4;\n\n    /// DeleteParams - If this is true, we need to delete[] Params.\n    unsigned DeleteParams : 1;\n\n    /// HasTrailingReturnType - If this is true, a trailing return type was\n    /// specified.\n    unsigned HasTrailingReturnType : 1;\n\n    /// The location of the left parenthesis in the source.\n    SourceLocation LParenLoc;\n\n    /// When isVariadic is true, the location of the ellipsis in the source.\n    SourceLocation EllipsisLoc;\n\n    /// The location of the right parenthesis in the source.\n    SourceLocation RParenLoc;\n\n    /// NumParams - This is the number of formal parameters specified by the\n    /// declarator.\n    unsigned NumParams;\n\n    /// NumExceptionsOrDecls - This is the number of types in the\n    /// dynamic-exception-decl, if the function has one. In C, this is the\n    /// number of declarations in the function prototype.\n    unsigned NumExceptionsOrDecls;\n\n    /// The location of the ref-qualifier, if any.\n    ///\n    /// If this is an invalid location, there is no ref-qualifier.\n    SourceLocation RefQualifierLoc;\n\n    /// The location of the 'mutable' qualifer in a lambda-declarator, if\n    /// any.\n    SourceLocation MutableLoc;\n\n    /// The beginning location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocBeg;\n\n    /// The end location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocEnd;\n\n    /// Params - This is a pointer to a new[]'d array of ParamInfo objects that\n    /// describe the parameters specified by this function declarator.  null if\n    /// there are no parameters specified.\n    ParamInfo *Params;\n\n    /// DeclSpec for the function with the qualifier related info.\n    DeclSpec *MethodQualifiers;\n\n    /// AtttibuteFactory for the MethodQualifiers.\n    AttributeFactory *QualAttrFactory;\n\n    union {\n      /// Pointer to a new[]'d array of TypeAndRange objects that\n      /// contain the types in the function's dynamic exception specification\n      /// and their locations, if there is one.\n      TypeAndRange *Exceptions;\n\n      /// Pointer to the expression in the noexcept-specifier of this\n      /// function, if it has one.\n      Expr *NoexceptExpr;\n\n      /// Pointer to the cached tokens for an exception-specification\n      /// that has not yet been parsed.\n      CachedTokens *ExceptionSpecTokens;\n\n      /// Pointer to a new[]'d array of declarations that need to be available\n      /// for lookup inside the function body, if one exists. Does not exist in\n      /// C++.\n      NamedDecl **DeclsInPrototype;\n    };\n\n    /// If HasTrailingReturnType is true, this is the trailing return\n    /// type specified.\n    UnionParsedType TrailingReturnType;\n\n    /// If HasTrailingReturnType is true, this is the location of the trailing\n    /// return type.\n    SourceLocation TrailingReturnTypeLoc;\n\n    /// Reset the parameter list to having zero parameters.\n    ///\n    /// This is used in various places for error recovery.\n    void freeParams() {\n      for (unsigned I = 0; I < NumParams; ++I)\n        Params[I].DefaultArgTokens.reset();\n      if (DeleteParams) {\n        delete[] Params;\n        DeleteParams = false;\n      }\n      NumParams = 0;\n    }\n\n    void destroy() {\n      freeParams();\n      delete QualAttrFactory;\n      delete MethodQualifiers;\n      switch (getExceptionSpecType()) {\n      default:\n        break;\n      case EST_Dynamic:\n        delete[] Exceptions;\n        break;\n      case EST_Unparsed:\n        delete ExceptionSpecTokens;\n        break;\n      case EST_None:\n        if (NumExceptionsOrDecls != 0)\n          delete[] DeclsInPrototype;\n        break;\n      }\n    }\n\n    DeclSpec &getOrCreateMethodQualifiers() {\n      if (!MethodQualifiers) {\n        QualAttrFactory = new AttributeFactory();\n        MethodQualifiers = new DeclSpec(*QualAttrFactory);\n      }\n      return *MethodQualifiers;\n    }\n\n    /// isKNRPrototype - Return true if this is a K&R style identifier list,\n    /// like \"void foo(a,b,c)\".  In a function definition, this will be followed\n    /// by the parameter type definitions.\n    bool isKNRPrototype() const { return !hasPrototype && NumParams != 0; }\n\n    SourceLocation getLParenLoc() const { return LParenLoc; }\n\n    SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n    SourceLocation getRParenLoc() const { return RParenLoc; }\n\n    SourceLocation getExceptionSpecLocBeg() const {\n      return ExceptionSpecLocBeg;\n    }\n\n    SourceLocation getExceptionSpecLocEnd() const {\n      return ExceptionSpecLocEnd;\n    }\n\n    SourceRange getExceptionSpecRange() const {\n      return SourceRange(getExceptionSpecLocBeg(), getExceptionSpecLocEnd());\n    }\n\n    /// Retrieve the location of the ref-qualifier, if any.\n    SourceLocation getRefQualifierLoc() const { return RefQualifierLoc; }\n\n    /// Retrieve the location of the 'const' qualifier.\n    SourceLocation getConstQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getConstSpecLoc();\n    }\n\n    /// Retrieve the location of the 'volatile' qualifier.\n    SourceLocation getVolatileQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getVolatileSpecLoc();\n    }\n\n    /// Retrieve the location of the 'restrict' qualifier.\n    SourceLocation getRestrictQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getRestrictSpecLoc();\n    }\n\n    /// Retrieve the location of the 'mutable' qualifier, if any.\n    SourceLocation getMutableLoc() const { return MutableLoc; }\n\n    /// Determine whether this function declaration contains a\n    /// ref-qualifier.\n    bool hasRefQualifier() const { return getRefQualifierLoc().isValid(); }\n\n    /// Determine whether this lambda-declarator contains a 'mutable'\n    /// qualifier.\n    bool hasMutableQualifier() const { return getMutableLoc().isValid(); }\n\n    /// Determine whether this method has qualifiers.\n    bool hasMethodTypeQualifiers() const {\n      return MethodQualifiers && (MethodQualifiers->getTypeQualifiers() ||\n                                  MethodQualifiers->getAttributes().size());\n    }\n\n    /// Get the type of exception specification this function has.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      return static_cast<ExceptionSpecificationType>(ExceptionSpecType);\n    }\n\n    /// Get the number of dynamic exception specifications.\n    unsigned getNumExceptions() const {\n      assert(ExceptionSpecType != EST_None);\n      return NumExceptionsOrDecls;\n    }\n\n    /// Get the non-parameter decls defined within this function\n    /// prototype. Typically these are tag declarations.\n    ArrayRef<NamedDecl *> getDeclsInPrototype() const {\n      assert(ExceptionSpecType == EST_None);\n      return llvm::makeArrayRef(DeclsInPrototype, NumExceptionsOrDecls);\n    }\n\n    /// Determine whether this function declarator had a\n    /// trailing-return-type.\n    bool hasTrailingReturnType() const { return HasTrailingReturnType; }\n\n    /// Get the trailing-return-type for this function declarator.\n    ParsedType getTrailingReturnType() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnType;\n    }\n\n    /// Get the trailing-return-type location for this function declarator.\n    SourceLocation getTrailingReturnTypeLoc() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnTypeLoc;\n    }\n  };\n\n  struct BlockPointerTypeInfo {\n    /// For now, sema will catch these as invalid.\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    void destroy() {\n    }\n  };\n\n  struct MemberPointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n    /// Location of the '*' token.\n    SourceLocation StarLoc;\n    // CXXScopeSpec has a constructor, so it can't be a direct member.\n    // So we need some pointer-aligned storage and a bit of trickery.\n    alignas(CXXScopeSpec) char ScopeMem[sizeof(CXXScopeSpec)];\n    CXXScopeSpec &Scope() {\n      return *reinterpret_cast<CXXScopeSpec *>(ScopeMem);\n    }\n    const CXXScopeSpec &Scope() const {\n      return *reinterpret_cast<const CXXScopeSpec *>(ScopeMem);\n    }\n    void destroy() {\n      Scope().~CXXScopeSpec();\n    }\n  };\n\n  struct PipeTypeInfo {\n    /// The access writes.\n    unsigned AccessWrites : 3;\n\n    void destroy() {}\n  };\n\n  union {\n    PointerTypeInfo       Ptr;\n    ReferenceTypeInfo     Ref;\n    ArrayTypeInfo         Arr;\n    FunctionTypeInfo      Fun;\n    BlockPointerTypeInfo  Cls;\n    MemberPointerTypeInfo Mem;\n    PipeTypeInfo          PipeInfo;\n  };\n\n  void destroy() {\n    switch (Kind) {\n    case DeclaratorChunk::Function:      return Fun.destroy();\n    case DeclaratorChunk::Pointer:       return Ptr.destroy();\n    case DeclaratorChunk::BlockPointer:  return Cls.destroy();\n    case DeclaratorChunk::Reference:     return Ref.destroy();\n    case DeclaratorChunk::Array:         return Arr.destroy();\n    case DeclaratorChunk::MemberPointer: return Mem.destroy();\n    case DeclaratorChunk::Paren:         return;\n    case DeclaratorChunk::Pipe:          return PipeInfo.destroy();\n    }\n  }\n\n  /// If there are attributes applied to this declaratorchunk, return\n  /// them.\n  const ParsedAttributesView &getAttrs() const { return AttrList; }\n  ParsedAttributesView &getAttrs() { return AttrList; }\n\n  /// Return a DeclaratorChunk for a pointer.\n  static DeclaratorChunk getPointer(unsigned TypeQuals, SourceLocation Loc,\n                                    SourceLocation ConstQualLoc,\n                                    SourceLocation VolatileQualLoc,\n                                    SourceLocation RestrictQualLoc,\n                                    SourceLocation AtomicQualLoc,\n                                    SourceLocation UnalignedQualLoc) {\n    DeclaratorChunk I;\n    I.Kind                = Pointer;\n    I.Loc                 = Loc;\n    new (&I.Ptr) PointerTypeInfo;\n    I.Ptr.TypeQuals       = TypeQuals;\n    I.Ptr.ConstQualLoc    = ConstQualLoc;\n    I.Ptr.VolatileQualLoc = VolatileQualLoc;\n    I.Ptr.RestrictQualLoc = RestrictQualLoc;\n    I.Ptr.AtomicQualLoc   = AtomicQualLoc;\n    I.Ptr.UnalignedQualLoc = UnalignedQualLoc;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a reference.\n  static DeclaratorChunk getReference(unsigned TypeQuals, SourceLocation Loc,\n                                      bool lvalue) {\n    DeclaratorChunk I;\n    I.Kind            = Reference;\n    I.Loc             = Loc;\n    I.Ref.HasRestrict = (TypeQuals & DeclSpec::TQ_restrict) != 0;\n    I.Ref.LValueRef   = lvalue;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for an array.\n  static DeclaratorChunk getArray(unsigned TypeQuals,\n                                  bool isStatic, bool isStar, Expr *NumElts,\n                                  SourceLocation LBLoc, SourceLocation RBLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Array;\n    I.Loc           = LBLoc;\n    I.EndLoc        = RBLoc;\n    I.Arr.TypeQuals = TypeQuals;\n    I.Arr.hasStatic = isStatic;\n    I.Arr.isStar    = isStar;\n    I.Arr.NumElts   = NumElts;\n    return I;\n  }\n\n  /// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.\n  /// \"TheDeclarator\" is the declarator that this will be added to.\n  static DeclaratorChunk getFunction(bool HasProto,\n                                     bool IsAmbiguous,\n                                     SourceLocation LParenLoc,\n                                     ParamInfo *Params, unsigned NumParams,\n                                     SourceLocation EllipsisLoc,\n                                     SourceLocation RParenLoc,\n                                     bool RefQualifierIsLvalueRef,\n                                     SourceLocation RefQualifierLoc,\n                                     SourceLocation MutableLoc,\n                                     ExceptionSpecificationType ESpecType,\n                                     SourceRange ESpecRange,\n                                     ParsedType *Exceptions,\n                                     SourceRange *ExceptionRanges,\n                                     unsigned NumExceptions,\n                                     Expr *NoexceptExpr,\n                                     CachedTokens *ExceptionSpecTokens,\n                                     ArrayRef<NamedDecl *> DeclsInPrototype,\n                                     SourceLocation LocalRangeBegin,\n                                     SourceLocation LocalRangeEnd,\n                                     Declarator &TheDeclarator,\n                                     TypeResult TrailingReturnType =\n                                                    TypeResult(),\n                                     SourceLocation TrailingReturnTypeLoc =\n                                                    SourceLocation(),\n                                     DeclSpec *MethodQualifiers = nullptr);\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getBlockPointer(unsigned TypeQuals,\n                                         SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = BlockPointer;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getPipe(unsigned TypeQuals,\n                                 SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = Pipe;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  static DeclaratorChunk getMemberPointer(const CXXScopeSpec &SS,\n                                          unsigned TypeQuals,\n                                          SourceLocation StarLoc,\n                                          SourceLocation EndLoc) {\n    DeclaratorChunk I;\n    I.Kind          = MemberPointer;\n    I.Loc           = SS.getBeginLoc();\n    I.EndLoc = EndLoc;\n    new (&I.Mem) MemberPointerTypeInfo;\n    I.Mem.StarLoc = StarLoc;\n    I.Mem.TypeQuals = TypeQuals;\n    new (I.Mem.ScopeMem) CXXScopeSpec(SS);\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a paren.\n  static DeclaratorChunk getParen(SourceLocation LParenLoc,\n                                  SourceLocation RParenLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Paren;\n    I.Loc           = LParenLoc;\n    I.EndLoc        = RParenLoc;\n    return I;\n  }\n\n  bool isParen() const {\n    return Kind == Paren;\n  }\n};\n\n/// A parsed C++17 decomposition declarator of the form\n///   '[' identifier-list ']'\nclass DecompositionDeclarator {\npublic:\n  struct Binding {\n    IdentifierInfo *Name;\n    SourceLocation NameLoc;\n  };\n\nprivate:\n  /// The locations of the '[' and ']' tokens.\n  SourceLocation LSquareLoc, RSquareLoc;\n\n  /// The bindings.\n  Binding *Bindings;\n  unsigned NumBindings : 31;\n  unsigned DeleteBindings : 1;\n\n  friend class Declarator;\n\npublic:\n  DecompositionDeclarator()\n      : Bindings(nullptr), NumBindings(0), DeleteBindings(false) {}\n  DecompositionDeclarator(const DecompositionDeclarator &G) = delete;\n  DecompositionDeclarator &operator=(const DecompositionDeclarator &G) = delete;\n  ~DecompositionDeclarator() {\n    if (DeleteBindings)\n      delete[] Bindings;\n  }\n\n  void clear() {\n    LSquareLoc = RSquareLoc = SourceLocation();\n    if (DeleteBindings)\n      delete[] Bindings;\n    Bindings = nullptr;\n    NumBindings = 0;\n    DeleteBindings = false;\n  }\n\n  ArrayRef<Binding> bindings() const {\n    return llvm::makeArrayRef(Bindings, NumBindings);\n  }\n\n  bool isSet() const { return LSquareLoc.isValid(); }\n\n  SourceLocation getLSquareLoc() const { return LSquareLoc; }\n  SourceLocation getRSquareLoc() const { return RSquareLoc; }\n  SourceRange getSourceRange() const {\n    return SourceRange(LSquareLoc, RSquareLoc);\n  }\n};\n\n/// Described the kind of function definition (if any) provided for\n/// a function.\nenum class FunctionDefinitionKind {\n  Declaration,\n  Definition,\n  Defaulted,\n  Deleted\n};\n\nenum class DeclaratorContext {\n  File,                // File scope declaration.\n  Prototype,           // Within a function prototype.\n  ObjCResult,          // An ObjC method result type.\n  ObjCParameter,       // An ObjC method parameter type.\n  KNRTypeList,         // K&R type definition list for formals.\n  TypeName,            // Abstract declarator for types.\n  FunctionalCast,      // Type in a C++ functional cast expression.\n  Member,              // Struct/Union field.\n  Block,               // Declaration within a block in a function.\n  ForInit,             // Declaration within first part of a for loop.\n  SelectionInit,       // Declaration within optional init stmt of if/switch.\n  Condition,           // Condition declaration in a C++ if/switch/while/for.\n  TemplateParam,       // Within a template parameter list.\n  CXXNew,              // C++ new-expression.\n  CXXCatch,            // C++ catch exception-declaration\n  ObjCCatch,           // Objective-C catch exception-declaration\n  BlockLiteral,        // Block literal declarator.\n  LambdaExpr,          // Lambda-expression declarator.\n  LambdaExprParameter, // Lambda-expression parameter declarator.\n  ConversionId,        // C++ conversion-type-id.\n  TrailingReturn,      // C++11 trailing-type-specifier.\n  TrailingReturnVar,   // C++11 trailing-type-specifier for variable.\n  TemplateArg,         // Any template argument (in template argument list).\n  TemplateTypeArg,     // Template type argument (in default argument).\n  AliasDecl,           // C++11 alias-declaration.\n  AliasTemplate,       // C++11 alias-declaration template.\n  RequiresExpr         // C++2a requires-expression.\n};\n\n/// Information about one declarator, including the parsed type\n/// information and the identifier.\n///\n/// When the declarator is fully formed, this is turned into the appropriate\n/// Decl object.\n///\n/// Declarators come in two types: normal declarators and abstract declarators.\n/// Abstract declarators are used when parsing types, and don't have an\n/// identifier.  Normal declarators do have ID's.\n///\n/// Instances of this class should be a transient object that lives on the\n/// stack, not objects that are allocated in large quantities on the heap.\nclass Declarator {\n\nprivate:\n  const DeclSpec &DS;\n  CXXScopeSpec SS;\n  UnqualifiedId Name;\n  SourceRange Range;\n\n  /// Where we are parsing this declarator.\n  DeclaratorContext Context;\n\n  /// The C++17 structured binding, if any. This is an alternative to a Name.\n  DecompositionDeclarator BindingGroup;\n\n  /// DeclTypeInfo - This holds each type that the declarator includes as it is\n  /// parsed.  This is pushed from the identifier out, which means that element\n  /// #0 will be the most closely bound to the identifier, and\n  /// DeclTypeInfo.back() will be the least closely bound.\n  SmallVector<DeclaratorChunk, 8> DeclTypeInfo;\n\n  /// InvalidType - Set by Sema::GetTypeForDeclarator().\n  unsigned InvalidType : 1;\n\n  /// GroupingParens - Set by Parser::ParseParenDeclarator().\n  unsigned GroupingParens : 1;\n\n  /// FunctionDefinition - Is this Declarator for a function or member\n  /// definition and, if so, what kind?\n  ///\n  /// Actually a FunctionDefinitionKind.\n  unsigned FunctionDefinition : 2;\n\n  /// Is this Declarator a redeclaration?\n  unsigned Redeclaration : 1;\n\n  /// true if the declaration is preceded by \\c __extension__.\n  unsigned Extension : 1;\n\n  /// Indicates whether this is an Objective-C instance variable.\n  unsigned ObjCIvar : 1;\n\n  /// Indicates whether this is an Objective-C 'weak' property.\n  unsigned ObjCWeakProperty : 1;\n\n  /// Indicates whether the InlineParams / InlineBindings storage has been used.\n  unsigned InlineStorageUsed : 1;\n\n  /// Indicates whether this declarator has an initializer.\n  unsigned HasInitializer : 1;\n\n  /// Attrs - Attributes.\n  ParsedAttributes Attrs;\n\n  /// The asm label, if specified.\n  Expr *AsmLabel;\n\n  /// \\brief The constraint-expression specified by the trailing\n  /// requires-clause, or null if no such clause was specified.\n  Expr *TrailingRequiresClause;\n\n  /// If this declarator declares a template, its template parameter lists.\n  ArrayRef<TemplateParameterList *> TemplateParameterLists;\n\n  /// If the declarator declares an abbreviated function template, the innermost\n  /// template parameter list containing the invented and explicit template\n  /// parameters (if any).\n  TemplateParameterList *InventedTemplateParameterList;\n\n#ifndef _MSC_VER\n  union {\n#endif\n    /// InlineParams - This is a local array used for the first function decl\n    /// chunk to avoid going to the heap for the common case when we have one\n    /// function chunk in the declarator.\n    DeclaratorChunk::ParamInfo InlineParams[16];\n    DecompositionDeclarator::Binding InlineBindings[16];\n#ifndef _MSC_VER\n  };\n#endif\n\n  /// If this is the second or subsequent declarator in this declaration,\n  /// the location of the comma before this declarator.\n  SourceLocation CommaLoc;\n\n  /// If provided, the source location of the ellipsis used to describe\n  /// this declarator as a parameter pack.\n  SourceLocation EllipsisLoc;\n\n  friend struct DeclaratorChunk;\n\npublic:\n  Declarator(const DeclSpec &ds, DeclaratorContext C)\n      : DS(ds), Range(ds.getSourceRange()), Context(C),\n        InvalidType(DS.getTypeSpecType() == DeclSpec::TST_error),\n        GroupingParens(false), FunctionDefinition(static_cast<unsigned>(\n                                   FunctionDefinitionKind::Declaration)),\n        Redeclaration(false), Extension(false), ObjCIvar(false),\n        ObjCWeakProperty(false), InlineStorageUsed(false),\n        HasInitializer(false), Attrs(ds.getAttributePool().getFactory()),\n        AsmLabel(nullptr), TrailingRequiresClause(nullptr),\n        InventedTemplateParameterList(nullptr) {}\n\n  ~Declarator() {\n    clear();\n  }\n  /// getDeclSpec - Return the declaration-specifier that this declarator was\n  /// declared with.\n  const DeclSpec &getDeclSpec() const { return DS; }\n\n  /// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This\n  /// should be used with extreme care: declspecs can often be shared between\n  /// multiple declarators, so mutating the DeclSpec affects all of the\n  /// Declarators.  This should only be done when the declspec is known to not\n  /// be shared or when in error recovery etc.\n  DeclSpec &getMutableDeclSpec() { return const_cast<DeclSpec &>(DS); }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// getCXXScopeSpec - Return the C++ scope specifier (global scope or\n  /// nested-name-specifier) that is part of the declarator-id.\n  const CXXScopeSpec &getCXXScopeSpec() const { return SS; }\n  CXXScopeSpec &getCXXScopeSpec() { return SS; }\n\n  /// Retrieve the name specified by this declarator.\n  UnqualifiedId &getName() { return Name; }\n\n  const DecompositionDeclarator &getDecompositionDeclarator() const {\n    return BindingGroup;\n  }\n\n  DeclaratorContext getContext() const { return Context; }\n\n  bool isPrototypeContext() const {\n    return (Context == DeclaratorContext::Prototype ||\n            Context == DeclaratorContext::ObjCParameter ||\n            Context == DeclaratorContext::ObjCResult ||\n            Context == DeclaratorContext::LambdaExprParameter);\n  }\n\n  /// Get the source range that spans this declarator.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  void SetSourceRange(SourceRange R) { Range = R; }\n  /// SetRangeBegin - Set the start of the source range to Loc, unless it's\n  /// invalid.\n  void SetRangeBegin(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setBegin(Loc);\n  }\n  /// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.\n  void SetRangeEnd(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setEnd(Loc);\n  }\n  /// ExtendWithDeclSpec - Extend the declarator source range to include the\n  /// given declspec, unless its location is invalid. Adopts the range start if\n  /// the current range start is invalid.\n  void ExtendWithDeclSpec(const DeclSpec &DS) {\n    SourceRange SR = DS.getSourceRange();\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(SR.getBegin());\n    if (!SR.getEnd().isInvalid())\n      Range.setEnd(SR.getEnd());\n  }\n\n  /// Reset the contents of this Declarator.\n  void clear() {\n    SS.clear();\n    Name.clear();\n    Range = DS.getSourceRange();\n    BindingGroup.clear();\n\n    for (unsigned i = 0, e = DeclTypeInfo.size(); i != e; ++i)\n      DeclTypeInfo[i].destroy();\n    DeclTypeInfo.clear();\n    Attrs.clear();\n    AsmLabel = nullptr;\n    InlineStorageUsed = false;\n    HasInitializer = false;\n    ObjCIvar = false;\n    ObjCWeakProperty = false;\n    CommaLoc = SourceLocation();\n    EllipsisLoc = SourceLocation();\n  }\n\n  /// mayOmitIdentifier - Return true if the identifier is either optional or\n  /// not allowed.  This is true for typenames, prototypes, and template\n  /// parameter lists.\n  bool mayOmitIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return false;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayHaveIdentifier - Return true if the identifier is either optional or\n  /// required.  This is true for normal declarators and prototypes, but not\n  /// typenames.\n  bool mayHaveIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if the context permits a C++17 decomposition declarator.\n  bool mayHaveDecompositionDeclarator() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n      // FIXME: It's not clear that the proposal meant to allow file-scope\n      // structured bindings, but it does.\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return true;\n\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::RequiresExpr:\n      // Maybe one day...\n      return false;\n\n    // These contexts don't allow any kind of non-abstract declarator.\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayBeFollowedByCXXDirectInit - Return true if the declarator can be\n  /// followed by a C++ direct initializer, e.g. \"int x(1);\".\n  bool mayBeFollowedByCXXDirectInit() const {\n    if (hasGroupingParens()) return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_extern &&\n        Context != DeclaratorContext::File)\n      return false;\n\n    // Special names can't have direct initializers.\n    if (Name.getKind() != UnqualifiedIdKind::IK_Identifier)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::TrailingReturnVar:\n      return true;\n\n    case DeclaratorContext::Condition:\n      // This may not be followed by a direct initializer, but it can't be a\n      // function declaration either, and we'd prefer to perform a tentative\n      // parse in order to produce the right diagnostic.\n      return true;\n\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast: // FIXME\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// isPastIdentifier - Return true if we have parsed beyond the point where\n  /// the name would appear. (This may happen even if we haven't actually parsed\n  /// a name, perhaps because this context doesn't require one.)\n  bool isPastIdentifier() const { return Name.isValid(); }\n\n  /// hasName - Whether this declarator has a name, which might be an\n  /// identifier (accessible via getIdentifier()) or some kind of\n  /// special C++ name (constructor, destructor, etc.), or a structured\n  /// binding (which is not exactly a name, but occupies the same position).\n  bool hasName() const {\n    return Name.getKind() != UnqualifiedIdKind::IK_Identifier ||\n           Name.Identifier || isDecompositionDeclarator();\n  }\n\n  /// Return whether this declarator is a decomposition declarator.\n  bool isDecompositionDeclarator() const {\n    return BindingGroup.isSet();\n  }\n\n  IdentifierInfo *getIdentifier() const {\n    if (Name.getKind() == UnqualifiedIdKind::IK_Identifier)\n      return Name.Identifier;\n\n    return nullptr;\n  }\n  SourceLocation getIdentifierLoc() const { return Name.StartLocation; }\n\n  /// Set the name of this declarator to be the given identifier.\n  void SetIdentifier(IdentifierInfo *Id, SourceLocation IdLoc) {\n    Name.setIdentifier(Id, IdLoc);\n  }\n\n  /// Set the decomposition bindings for this declarator.\n  void\n  setDecompositionBindings(SourceLocation LSquareLoc,\n                           ArrayRef<DecompositionDeclarator::Binding> Bindings,\n                           SourceLocation RSquareLoc);\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  /// This function takes attrs by R-Value reference because it takes ownership\n  /// of those attributes from the parameter.\n  void AddTypeInfo(const DeclaratorChunk &TI, ParsedAttributes &&attrs,\n                   SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n    DeclTypeInfo.back().getAttrs().addAll(attrs.begin(), attrs.end());\n    getAttributePool().takeAllFrom(attrs.getPool());\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  void AddTypeInfo(const DeclaratorChunk &TI, SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// Add a new innermost chunk to this declarator.\n  void AddInnermostTypeInfo(const DeclaratorChunk &TI) {\n    DeclTypeInfo.insert(DeclTypeInfo.begin(), TI);\n  }\n\n  /// Return the number of types applied to this declarator.\n  unsigned getNumTypeObjects() const { return DeclTypeInfo.size(); }\n\n  /// Return the specified TypeInfo from this declarator.  TypeInfo #0 is\n  /// closest to the identifier.\n  const DeclaratorChunk &getTypeObject(unsigned i) const {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n  DeclaratorChunk &getTypeObject(unsigned i) {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n\n  typedef SmallVectorImpl<DeclaratorChunk>::const_iterator type_object_iterator;\n  typedef llvm::iterator_range<type_object_iterator> type_object_range;\n\n  /// Returns the range of type objects, from the identifier outwards.\n  type_object_range type_objects() const {\n    return type_object_range(DeclTypeInfo.begin(), DeclTypeInfo.end());\n  }\n\n  void DropFirstTypeObject() {\n    assert(!DeclTypeInfo.empty() && \"No type chunks to drop.\");\n    DeclTypeInfo.front().destroy();\n    DeclTypeInfo.erase(DeclTypeInfo.begin());\n  }\n\n  /// Return the innermost (closest to the declarator) chunk of this\n  /// declarator that is not a parens chunk, or null if there are no\n  /// non-parens chunks.\n  const DeclaratorChunk *getInnermostNonParenChunk() const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      if (!DeclTypeInfo[i].isParen())\n        return &DeclTypeInfo[i];\n    }\n    return nullptr;\n  }\n\n  /// Return the outermost (furthest from the declarator) chunk of\n  /// this declarator that is not a parens chunk, or null if there are\n  /// no non-parens chunks.\n  const DeclaratorChunk *getOutermostNonParenChunk() const {\n    for (unsigned i = DeclTypeInfo.size(), i_end = 0; i != i_end; --i) {\n      if (!DeclTypeInfo[i-1].isParen())\n        return &DeclTypeInfo[i-1];\n    }\n    return nullptr;\n  }\n\n  /// isArrayOfUnknownBound - This method returns true if the declarator\n  /// is a declarator for an array of unknown bound (looking through\n  /// parentheses).\n  bool isArrayOfUnknownBound() const {\n    const DeclaratorChunk *chunk = getInnermostNonParenChunk();\n    return (chunk && chunk->Kind == DeclaratorChunk::Array &&\n            !chunk->Arr.NumElts);\n  }\n\n  /// isFunctionDeclarator - This method returns true if the declarator\n  /// is a function declarator (looking through parentheses).\n  /// If true is returned, then the reference type parameter idx is\n  /// assigned with the index of the declaration chunk.\n  bool isFunctionDeclarator(unsigned& idx) const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      switch (DeclTypeInfo[i].Kind) {\n      case DeclaratorChunk::Function:\n        idx = i;\n        return true;\n      case DeclaratorChunk::Paren:\n        continue;\n      case DeclaratorChunk::Pointer:\n      case DeclaratorChunk::Reference:\n      case DeclaratorChunk::Array:\n      case DeclaratorChunk::BlockPointer:\n      case DeclaratorChunk::MemberPointer:\n      case DeclaratorChunk::Pipe:\n        return false;\n      }\n      llvm_unreachable(\"Invalid type chunk\");\n    }\n    return false;\n  }\n\n  /// isFunctionDeclarator - Once this declarator is fully parsed and formed,\n  /// this method returns true if the identifier is a function declarator\n  /// (looking through parentheses).\n  bool isFunctionDeclarator() const {\n    unsigned index;\n    return isFunctionDeclarator(index);\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() {\n    assert(isFunctionDeclarator() && \"Not a function declarator!\");\n    unsigned index = 0;\n    isFunctionDeclarator(index);\n    return DeclTypeInfo[index].Fun;\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  const DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() const {\n    return const_cast<Declarator*>(this)->getFunctionTypeInfo();\n  }\n\n  /// Determine whether the declaration that will be produced from\n  /// this declaration will be a function.\n  ///\n  /// A declaration can declare a function even if the declarator itself\n  /// isn't a function declarator, if the type specifier refers to a function\n  /// type. This routine checks for both cases.\n  bool isDeclarationOfFunction() const;\n\n  /// Return true if this declaration appears in a context where a\n  /// function declarator would be a function declaration.\n  bool isFunctionDeclarationContext() const {\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n      return true;\n\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Determine whether this declaration appears in a context where an\n  /// expression could appear.\n  bool isExpressionContext() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n\n    // FIXME: sizeof(...) permits an expression.\n    case DeclaratorContext::TypeName:\n\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::TemplateArg:\n      return true;\n    }\n\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if a function declarator at this position would be a\n  /// function declaration.\n  bool isFunctionDeclaratorAFunctionDeclaration() const {\n    if (!isFunctionDeclarationContext())\n      return false;\n\n    for (unsigned I = 0, N = getNumTypeObjects(); I != N; ++I)\n      if (getTypeObject(I).Kind != DeclaratorChunk::Paren)\n        return false;\n\n    return true;\n  }\n\n  /// Determine whether a trailing return type was written (at any\n  /// level) within this declarator.\n  bool hasTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return true;\n    return false;\n  }\n  /// Get the trailing return type appearing (at any level) within this\n  /// declarator.\n  ParsedType getTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return Chunk.Fun.getTrailingReturnType();\n    return ParsedType();\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  void setTrailingRequiresClause(Expr *TRC) {\n    TrailingRequiresClause = TRC;\n\n    SetRangeEnd(TRC->getEndLoc());\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  Expr *getTrailingRequiresClause() {\n    return TrailingRequiresClause;\n  }\n\n  /// \\brief Determine whether a trailing requires clause was written in this\n  /// declarator.\n  bool hasTrailingRequiresClause() const {\n    return TrailingRequiresClause != nullptr;\n  }\n\n  /// Sets the template parameter lists that preceded the declarator.\n  void setTemplateParameterLists(ArrayRef<TemplateParameterList *> TPLs) {\n    TemplateParameterLists = TPLs;\n  }\n\n  /// The template parameter lists that preceded the declarator.\n  ArrayRef<TemplateParameterList *> getTemplateParameterLists() const {\n    return TemplateParameterLists;\n  }\n\n  /// Sets the template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters.\n  void setInventedTemplateParameterList(TemplateParameterList *Invented) {\n    InventedTemplateParameterList = Invented;\n  }\n\n  /// The template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters, if there were any such parameters.\n  TemplateParameterList * getInventedTemplateParameterList() const {\n    return InventedTemplateParameterList;\n  }\n\n  /// takeAttributes - Takes attributes from the given parsed-attributes\n  /// set and add them to this declarator.\n  ///\n  /// These examples both add 3 attributes to \"var\":\n  ///  short int var __attribute__((aligned(16),common,deprecated));\n  ///  short int x, __attribute__((aligned(16)) var\n  ///                                 __attribute__((common,deprecated));\n  ///\n  /// Also extends the range of the declarator.\n  void takeAttributes(ParsedAttributes &attrs, SourceLocation lastLoc) {\n    Attrs.takeAllFrom(attrs);\n\n    if (!lastLoc.isInvalid())\n      SetRangeEnd(lastLoc);\n  }\n\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n  ParsedAttributes &getAttributes() { return Attrs; }\n\n  /// hasAttributes - do we contain any attributes?\n  bool hasAttributes() const {\n    if (!getAttributes().empty() || getDeclSpec().hasAttributes())\n      return true;\n    for (unsigned i = 0, e = getNumTypeObjects(); i != e; ++i)\n      if (!getTypeObject(i).getAttrs().empty())\n        return true;\n    return false;\n  }\n\n  /// Return a source range list of C++11 attributes associated\n  /// with the declarator.\n  void getCXX11AttributeRanges(SmallVectorImpl<SourceRange> &Ranges) {\n    for (const ParsedAttr &AL : Attrs)\n      if (AL.isCXX11Attribute())\n        Ranges.push_back(AL.getRange());\n  }\n\n  void setAsmLabel(Expr *E) { AsmLabel = E; }\n  Expr *getAsmLabel() const { return AsmLabel; }\n\n  void setExtension(bool Val = true) { Extension = Val; }\n  bool getExtension() const { return Extension; }\n\n  void setObjCIvar(bool Val = true) { ObjCIvar = Val; }\n  bool isObjCIvar() const { return ObjCIvar; }\n\n  void setObjCWeakProperty(bool Val = true) { ObjCWeakProperty = Val; }\n  bool isObjCWeakProperty() const { return ObjCWeakProperty; }\n\n  void setInvalidType(bool Val = true) { InvalidType = Val; }\n  bool isInvalidType() const {\n    return InvalidType || DS.getTypeSpecType() == DeclSpec::TST_error;\n  }\n\n  void setGroupingParens(bool flag) { GroupingParens = flag; }\n  bool hasGroupingParens() const { return GroupingParens; }\n\n  bool isFirstDeclarator() const { return !CommaLoc.isValid(); }\n  SourceLocation getCommaLoc() const { return CommaLoc; }\n  void setCommaLoc(SourceLocation CL) { CommaLoc = CL; }\n\n  bool hasEllipsis() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  void setEllipsisLoc(SourceLocation EL) { EllipsisLoc = EL; }\n\n  void setFunctionDefinitionKind(FunctionDefinitionKind Val) {\n    FunctionDefinition = static_cast<unsigned>(Val);\n  }\n\n  bool isFunctionDefinition() const {\n    return getFunctionDefinitionKind() != FunctionDefinitionKind::Declaration;\n  }\n\n  FunctionDefinitionKind getFunctionDefinitionKind() const {\n    return (FunctionDefinitionKind)FunctionDefinition;\n  }\n\n  void setHasInitializer(bool Val = true) { HasInitializer = Val; }\n  bool hasInitializer() const { return HasInitializer; }\n\n  /// Returns true if this declares a real member and not a friend.\n  bool isFirstDeclarationOfMember() {\n    return getContext() == DeclaratorContext::Member &&\n           !getDeclSpec().isFriendSpecified();\n  }\n\n  /// Returns true if this declares a static member.  This cannot be called on a\n  /// declarator outside of a MemberContext because we won't know until\n  /// redeclaration time if the decl is static.\n  bool isStaticMember();\n\n  /// Returns true if this declares a constructor or a destructor.\n  bool isCtorOrDtor();\n\n  void setRedeclaration(bool Val) { Redeclaration = Val; }\n  bool isRedeclaration() const { return Redeclaration; }\n};\n\n/// This little struct is used to capture information about\n/// structure field declarators, which is basically just a bitfield size.\nstruct FieldDeclarator {\n  Declarator D;\n  Expr *BitfieldSize;\n  explicit FieldDeclarator(const DeclSpec &DS)\n      : D(DS, DeclaratorContext::Member), BitfieldSize(nullptr) {}\n};\n\n/// Represents a C++11 virt-specifier-seq.\nclass VirtSpecifiers {\npublic:\n  enum Specifier {\n    VS_None = 0,\n    VS_Override = 1,\n    VS_Final = 2,\n    VS_Sealed = 4,\n    // Represents the __final keyword, which is legal for gcc in pre-C++11 mode.\n    VS_GNU_Final = 8\n  };\n\n  VirtSpecifiers() : Specifiers(0), LastSpecifier(VS_None) { }\n\n  bool SetSpecifier(Specifier VS, SourceLocation Loc,\n                    const char *&PrevSpec);\n\n  bool isUnset() const { return Specifiers == 0; }\n\n  bool isOverrideSpecified() const { return Specifiers & VS_Override; }\n  SourceLocation getOverrideLoc() const { return VS_overrideLoc; }\n\n  bool isFinalSpecified() const { return Specifiers & (VS_Final | VS_Sealed | VS_GNU_Final); }\n  bool isFinalSpelledSealed() const { return Specifiers & VS_Sealed; }\n  SourceLocation getFinalLoc() const { return VS_finalLoc; }\n\n  void clear() { Specifiers = 0; }\n\n  static const char *getSpecifierName(Specifier VS);\n\n  SourceLocation getFirstLocation() const { return FirstLocation; }\n  SourceLocation getLastLocation() const { return LastLocation; }\n  Specifier getLastSpecifier() const { return LastSpecifier; }\n\nprivate:\n  unsigned Specifiers;\n  Specifier LastSpecifier;\n\n  SourceLocation VS_overrideLoc, VS_finalLoc;\n  SourceLocation FirstLocation;\n  SourceLocation LastLocation;\n};\n\nenum class LambdaCaptureInitKind {\n  NoInit,     //!< [a]\n  CopyInit,   //!< [a = b], [a = {b}]\n  DirectInit, //!< [a(b)]\n  ListInit    //!< [a{b}]\n};\n\n/// Represents a complete lambda introducer.\nstruct LambdaIntroducer {\n  /// An individual capture in a lambda introducer.\n  struct LambdaCapture {\n    LambdaCaptureKind Kind;\n    SourceLocation Loc;\n    IdentifierInfo *Id;\n    SourceLocation EllipsisLoc;\n    LambdaCaptureInitKind InitKind;\n    ExprResult Init;\n    ParsedType InitCaptureType;\n    SourceRange ExplicitRange;\n\n    LambdaCapture(LambdaCaptureKind Kind, SourceLocation Loc,\n                  IdentifierInfo *Id, SourceLocation EllipsisLoc,\n                  LambdaCaptureInitKind InitKind, ExprResult Init,\n                  ParsedType InitCaptureType,\n                  SourceRange ExplicitRange)\n        : Kind(Kind), Loc(Loc), Id(Id), EllipsisLoc(EllipsisLoc),\n          InitKind(InitKind), Init(Init), InitCaptureType(InitCaptureType),\n          ExplicitRange(ExplicitRange) {}\n  };\n\n  SourceRange Range;\n  SourceLocation DefaultLoc;\n  LambdaCaptureDefault Default;\n  SmallVector<LambdaCapture, 4> Captures;\n\n  LambdaIntroducer()\n    : Default(LCD_None) {}\n\n  /// Append a capture in a lambda introducer.\n  void addCapture(LambdaCaptureKind Kind,\n                  SourceLocation Loc,\n                  IdentifierInfo* Id,\n                  SourceLocation EllipsisLoc,\n                  LambdaCaptureInitKind InitKind,\n                  ExprResult Init,\n                  ParsedType InitCaptureType,\n                  SourceRange ExplicitRange) {\n    Captures.push_back(LambdaCapture(Kind, Loc, Id, EllipsisLoc, InitKind, Init,\n                                     InitCaptureType, ExplicitRange));\n  }\n};\n\nstruct InventedTemplateParameterInfo {\n  /// The number of parameters in the template parameter list that were\n  /// explicitly specified by the user, as opposed to being invented by use\n  /// of an auto parameter.\n  unsigned NumExplicitTemplateParams = 0;\n\n  /// If this is a generic lambda or abbreviated function template, use this\n  /// as the depth of each 'auto' parameter, during initial AST construction.\n  unsigned AutoTemplateParameterDepth = 0;\n\n  /// Store the list of the template parameters for a generic lambda or an\n  /// abbreviated function template.\n  /// If this is a generic lambda or abbreviated function template, this holds\n  /// the explicit template parameters followed by the auto parameters\n  /// converted into TemplateTypeParmDecls.\n  /// It can be used to construct the generic lambda or abbreviated template's\n  /// template parameter list during initial AST construction.\n  SmallVector<NamedDecl*, 4> TemplateParams;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_SEMA_DECLSPEC_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "content": "//======- ParsedAttr.h - Parsed attribute sets ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ParsedAttr class, which is used to collect\n// parsed attributes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n#define LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n\n#include \"clang/Basic/AttrSubjectMatchRules.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Registry.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass Expr;\nclass IdentifierInfo;\nclass LangOptions;\nclass ParsedAttr;\nclass Sema;\nclass TargetInfo;\n\nstruct ParsedAttrInfo {\n  /// Corresponds to the Kind enum.\n  unsigned AttrKind : 16;\n  /// The number of required arguments of this attribute.\n  unsigned NumArgs : 4;\n  /// The number of optional arguments of this attributes.\n  unsigned OptArgs : 4;\n  /// True if the parsing does not match the semantic content.\n  unsigned HasCustomParsing : 1;\n  /// True if this attribute is only available for certain targets.\n  unsigned IsTargetSpecific : 1;\n  /// True if this attribute applies to types.\n  unsigned IsType : 1;\n  /// True if this attribute applies to statements.\n  unsigned IsStmt : 1;\n  /// True if this attribute has any spellings that are known to gcc.\n  unsigned IsKnownToGCC : 1;\n  /// True if this attribute is supported by #pragma clang attribute.\n  unsigned IsSupportedByPragmaAttribute : 1;\n  /// The syntaxes supported by this attribute and how they're spelled.\n  struct Spelling {\n    AttributeCommonInfo::Syntax Syntax;\n    const char *NormalizedFullName;\n  };\n  ArrayRef<Spelling> Spellings;\n\n  ParsedAttrInfo(AttributeCommonInfo::Kind AttrKind =\n                     AttributeCommonInfo::NoSemaHandlerAttribute)\n      : AttrKind(AttrKind), NumArgs(0), OptArgs(0), HasCustomParsing(0),\n        IsTargetSpecific(0), IsType(0), IsStmt(0), IsKnownToGCC(0),\n        IsSupportedByPragmaAttribute(0) {}\n\n  virtual ~ParsedAttrInfo() = default;\n\n  /// Check if this attribute appertains to D, and issue a diagnostic if not.\n  virtual bool diagAppertainsToDecl(Sema &S, const ParsedAttr &Attr,\n                                    const Decl *D) const {\n    return true;\n  }\n  /// Check if this attribute is allowed by the language we are compiling, and\n  /// issue a diagnostic if not.\n  virtual bool diagLangOpts(Sema &S, const ParsedAttr &Attr) const {\n    return true;\n  }\n  /// Check if this attribute is allowed when compiling for the given target.\n  virtual bool existsInTarget(const TargetInfo &Target) const {\n    return true;\n  }\n  /// Convert the spelling index of Attr to a semantic spelling enum value.\n  virtual unsigned\n  spellingIndexToSemanticSpelling(const ParsedAttr &Attr) const {\n    return UINT_MAX;\n  }\n  /// Populate Rules with the match rules of this attribute.\n  virtual void getPragmaAttributeMatchRules(\n      llvm::SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>> &Rules,\n      const LangOptions &LangOpts) const {\n  }\n  enum AttrHandling {\n    NotHandled,\n    AttributeApplied,\n    AttributeNotApplied\n  };\n  /// If this ParsedAttrInfo knows how to handle this ParsedAttr applied to this\n  /// Decl then do so and return either AttributeApplied if it was applied or\n  /// AttributeNotApplied if it wasn't. Otherwise return NotHandled.\n  virtual AttrHandling handleDeclAttribute(Sema &S, Decl *D,\n                                           const ParsedAttr &Attr) const {\n    return NotHandled;\n  }\n\n  static const ParsedAttrInfo &get(const AttributeCommonInfo &A);\n};\n\ntypedef llvm::Registry<ParsedAttrInfo> ParsedAttrInfoRegistry;\n\n/// Represents information about a change in availability for\n/// an entity, which is part of the encoding of the 'availability'\n/// attribute.\nstruct AvailabilityChange {\n  /// The location of the keyword indicating the kind of change.\n  SourceLocation KeywordLoc;\n\n  /// The version number at which the change occurred.\n  VersionTuple Version;\n\n  /// The source range covering the version number.\n  SourceRange VersionRange;\n\n  /// Determine whether this availability change is valid.\n  bool isValid() const { return !Version.empty(); }\n};\n\nnamespace detail {\nenum AvailabilitySlot {\n  IntroducedSlot, DeprecatedSlot, ObsoletedSlot, NumAvailabilitySlots\n};\n\n/// Describes the trailing object for Availability attribute in ParsedAttr.\nstruct AvailabilityData {\n  AvailabilityChange Changes[NumAvailabilitySlots];\n  SourceLocation StrictLoc;\n  const Expr *Replacement;\n\n  AvailabilityData(const AvailabilityChange &Introduced,\n                   const AvailabilityChange &Deprecated,\n                   const AvailabilityChange &Obsoleted,\n                   SourceLocation Strict, const Expr *ReplaceExpr)\n    : StrictLoc(Strict), Replacement(ReplaceExpr) {\n    Changes[IntroducedSlot] = Introduced;\n    Changes[DeprecatedSlot] = Deprecated;\n    Changes[ObsoletedSlot] = Obsoleted;\n  }\n};\n\nstruct TypeTagForDatatypeData {\n  ParsedType MatchingCType;\n  unsigned LayoutCompatible : 1;\n  unsigned MustBeNull : 1;\n};\nstruct PropertyData {\n  IdentifierInfo *GetterId, *SetterId;\n\n  PropertyData(IdentifierInfo *getterId, IdentifierInfo *setterId)\n      : GetterId(getterId), SetterId(setterId) {}\n};\n\n} // namespace\n\n/// Wraps an identifier and optional source location for the identifier.\nstruct IdentifierLoc {\n  SourceLocation Loc;\n  IdentifierInfo *Ident;\n\n  static IdentifierLoc *create(ASTContext &Ctx, SourceLocation Loc,\n                               IdentifierInfo *Ident);\n};\n\n/// A union of the various pointer types that can be passed to an\n/// ParsedAttr as an argument.\nusing ArgsUnion = llvm::PointerUnion<Expr *, IdentifierLoc *>;\nusing ArgsVector = llvm::SmallVector<ArgsUnion, 12U>;\n\n/// ParsedAttr - Represents a syntactic attribute.\n///\n/// For a GNU attribute, there are four forms of this construct:\n///\n/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.\n/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.\n/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.\n/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.\n///\nclass ParsedAttr final\n    : public AttributeCommonInfo,\n      private llvm::TrailingObjects<\n          ParsedAttr, ArgsUnion, detail::AvailabilityData,\n          detail::TypeTagForDatatypeData, ParsedType, detail::PropertyData> {\n  friend TrailingObjects;\n\n  size_t numTrailingObjects(OverloadToken<ArgsUnion>) const { return NumArgs; }\n  size_t numTrailingObjects(OverloadToken<detail::AvailabilityData>) const {\n    return IsAvailability;\n  }\n  size_t\n      numTrailingObjects(OverloadToken<detail::TypeTagForDatatypeData>) const {\n    return IsTypeTagForDatatype;\n  }\n  size_t numTrailingObjects(OverloadToken<ParsedType>) const {\n    return HasParsedType;\n  }\n  size_t numTrailingObjects(OverloadToken<detail::PropertyData>) const {\n    return IsProperty;\n  }\n\nprivate:\n  IdentifierInfo *MacroII = nullptr;\n  SourceLocation MacroExpansionLoc;\n  SourceLocation EllipsisLoc;\n\n  /// The number of expression arguments this attribute has.\n  /// The expressions themselves are stored after the object.\n  unsigned NumArgs : 16;\n\n  /// True if already diagnosed as invalid.\n  mutable unsigned Invalid : 1;\n\n  /// True if this attribute was used as a type attribute.\n  mutable unsigned UsedAsTypeAttr : 1;\n\n  /// True if this has the extra information associated with an\n  /// availability attribute.\n  unsigned IsAvailability : 1;\n\n  /// True if this has extra information associated with a\n  /// type_tag_for_datatype attribute.\n  unsigned IsTypeTagForDatatype : 1;\n\n  /// True if this has extra information associated with a\n  /// Microsoft __delcspec(property) attribute.\n  unsigned IsProperty : 1;\n\n  /// True if this has a ParsedType\n  unsigned HasParsedType : 1;\n\n  /// True if the processing cache is valid.\n  mutable unsigned HasProcessingCache : 1;\n\n  /// A cached value.\n  mutable unsigned ProcessingCache : 8;\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  mutable unsigned IsPragmaClangAttribute : 1;\n\n  /// The location of the 'unavailable' keyword in an\n  /// availability attribute.\n  SourceLocation UnavailableLoc;\n\n  const Expr *MessageExpr;\n\n  const ParsedAttrInfo &Info;\n\n  ArgsUnion *getArgsBuffer() { return getTrailingObjects<ArgsUnion>(); }\n  ArgsUnion const *getArgsBuffer() const {\n    return getTrailingObjects<ArgsUnion>();\n  }\n\n  detail::AvailabilityData *getAvailabilityData() {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n  const detail::AvailabilityData *getAvailabilityData() const {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n\nprivate:\n  friend class AttributeFactory;\n  friend class AttributePool;\n\n  /// Constructor for attributes with expression arguments.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ArgsUnion *args, unsigned numArgs, Syntax syntaxUsed,\n             SourceLocation ellipsisLoc)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        EllipsisLoc(ellipsisLoc), NumArgs(numArgs), Invalid(false),\n        UsedAsTypeAttr(false), IsAvailability(false),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        Info(ParsedAttrInfo::get(*this)) {\n    if (numArgs)\n      memcpy(getArgsBuffer(), args, numArgs * sizeof(ArgsUnion));\n  }\n\n  /// Constructor for availability attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm, const AvailabilityChange &introduced,\n             const AvailabilityChange &deprecated,\n             const AvailabilityChange &obsoleted, SourceLocation unavailable,\n             const Expr *messageExpr, Syntax syntaxUsed, SourceLocation strict,\n             const Expr *replacementExpr)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false), IsAvailability(true),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        UnavailableLoc(unavailable), MessageExpr(messageExpr),\n        Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(Parm);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    new (getAvailabilityData()) detail::AvailabilityData(\n        introduced, deprecated, obsoleted, strict, replacementExpr);\n  }\n\n  /// Constructor for objc_bridge_related attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm1, IdentifierLoc *Parm2, IdentifierLoc *Parm3,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(3), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion *Args = getArgsBuffer();\n    Args[0] = Parm1;\n    Args[1] = Parm2;\n    Args[2] = Parm3;\n  }\n\n  /// Constructor for type_tag_for_datatype attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *ArgKind, ParsedType matchingCType,\n             bool layoutCompatible, bool mustBeNull, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(true), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(ArgKind);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    detail::TypeTagForDatatypeData &ExtraData = getTypeTagForDatatypeDataSlot();\n    new (&ExtraData.MatchingCType) ParsedType(matchingCType);\n    ExtraData.LayoutCompatible = layoutCompatible;\n    ExtraData.MustBeNull = mustBeNull;\n  }\n\n  /// Constructor for attributes with a single type argument.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ParsedType typeArg, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(true), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getTypeBuffer()) ParsedType(typeArg);\n  }\n\n  /// Constructor for microsoft __declspec(property) attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierInfo *getterId, IdentifierInfo *setterId,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(true),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getPropertyDataBuffer()) detail::PropertyData(getterId, setterId);\n  }\n\n  /// Type tag information is stored immediately following the arguments, if\n  /// any, at the end of the object.  They are mutually exclusive with\n  /// availability slots.\n  detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n  const detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() const {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n\n  /// The type buffer immediately follows the object and are mutually exclusive\n  /// with arguments.\n  ParsedType &getTypeBuffer() { return *getTrailingObjects<ParsedType>(); }\n  const ParsedType &getTypeBuffer() const {\n    return *getTrailingObjects<ParsedType>();\n  }\n\n  /// The property data immediately follows the object is is mutually exclusive\n  /// with arguments.\n  detail::PropertyData &getPropertyDataBuffer() {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n  const detail::PropertyData &getPropertyDataBuffer() const {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n\n  size_t allocated_size() const;\n\npublic:\n  ParsedAttr(const ParsedAttr &) = delete;\n  ParsedAttr(ParsedAttr &&) = delete;\n  ParsedAttr &operator=(const ParsedAttr &) = delete;\n  ParsedAttr &operator=(ParsedAttr &&) = delete;\n  ~ParsedAttr() = delete;\n\n  void operator delete(void *) = delete;\n\n  bool hasParsedType() const { return HasParsedType; }\n\n  /// Is this the Microsoft __declspec(property) attribute?\n  bool isDeclspecPropertyAttribute() const  {\n    return IsProperty;\n  }\n\n  bool isInvalid() const { return Invalid; }\n  void setInvalid(bool b = true) const { Invalid = b; }\n\n  bool hasProcessingCache() const { return HasProcessingCache; }\n\n  unsigned getProcessingCache() const {\n    assert(hasProcessingCache());\n    return ProcessingCache;\n  }\n\n  void setProcessingCache(unsigned value) const {\n    ProcessingCache = value;\n    HasProcessingCache = true;\n  }\n\n  bool isUsedAsTypeAttr() const { return UsedAsTypeAttr; }\n  void setUsedAsTypeAttr(bool Used = true) { UsedAsTypeAttr = Used; }\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  bool isPragmaClangAttribute() const { return IsPragmaClangAttribute; }\n\n  void setIsPragmaClangAttribute() { IsPragmaClangAttribute = true; }\n\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// getNumArgs - Return the number of actual arguments to this attribute.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// getArg - Return the specified argument.\n  ArgsUnion getArg(unsigned Arg) const {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgsBuffer()[Arg];\n  }\n\n  bool isArgExpr(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<Expr*>();\n  }\n\n  Expr *getArgAsExpr(unsigned Arg) const {\n    return getArg(Arg).get<Expr*>();\n  }\n\n  bool isArgIdent(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<IdentifierLoc*>();\n  }\n\n  IdentifierLoc *getArgAsIdent(unsigned Arg) const {\n    return getArg(Arg).get<IdentifierLoc*>();\n  }\n\n  const AvailabilityChange &getAvailabilityIntroduced() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::IntroducedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityDeprecated() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::DeprecatedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityObsoleted() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::ObsoletedSlot];\n  }\n\n  SourceLocation getStrictLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->StrictLoc;\n  }\n\n  SourceLocation getUnavailableLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return UnavailableLoc;\n  }\n\n  const Expr * getMessageExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return MessageExpr;\n  }\n\n  const Expr *getReplacementExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Replacement;\n  }\n\n  const ParsedType &getMatchingCType() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MatchingCType;\n  }\n\n  bool getLayoutCompatible() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().LayoutCompatible;\n  }\n\n  bool getMustBeNull() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MustBeNull;\n  }\n\n  const ParsedType &getTypeArg() const {\n    assert(HasParsedType && \"Not a type attribute\");\n    return getTypeBuffer();\n  }\n\n  IdentifierInfo *getPropertyDataGetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().GetterId;\n  }\n\n  IdentifierInfo *getPropertyDataSetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().SetterId;\n  }\n\n  /// Set the macro identifier info object that this parsed attribute was\n  /// declared in if it was declared in a macro. Also set the expansion location\n  /// of the macro.\n  void setMacroIdentifier(IdentifierInfo *MacroName, SourceLocation Loc) {\n    MacroII = MacroName;\n    MacroExpansionLoc = Loc;\n  }\n\n  /// Returns true if this attribute was declared in a macro.\n  bool hasMacroIdentifier() const { return MacroII != nullptr; }\n\n  /// Return the macro identifier if this attribute was declared in a macro.\n  /// nullptr is returned if it was not declared in a macro.\n  IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n\n  SourceLocation getMacroExpansionLoc() const {\n    assert(hasMacroIdentifier() && \"Can only get the macro expansion location \"\n                                   \"if this attribute has a macro identifier.\");\n    return MacroExpansionLoc;\n  }\n\n  /// Check if the attribute has exactly as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkExactlyNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at least as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtLeastNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at most as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtMostNumArgs(class Sema &S, unsigned Num) const;\n\n  bool isTargetSpecificAttr() const;\n  bool isTypeAttr() const;\n  bool isStmtAttr() const;\n\n  bool hasCustomParsing() const;\n  unsigned getMinArgs() const;\n  unsigned getMaxArgs() const;\n  bool hasVariadicArg() const;\n  bool diagnoseAppertainsTo(class Sema &S, const Decl *D) const;\n  bool appliesToDecl(const Decl *D, attr::SubjectMatchRule MatchRule) const;\n  void getMatchRules(const LangOptions &LangOpts,\n                     SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>>\n                         &MatchRules) const;\n  bool diagnoseLangOpts(class Sema &S) const;\n  bool existsInTarget(const TargetInfo &Target) const;\n  bool isKnownToGCC() const;\n  bool isSupportedByPragmaAttribute() const;\n\n  /// If the parsed attribute has a semantic equivalent, and it would\n  /// have a semantic Spelling enumeration (due to having semantically-distinct\n  /// spelling variations), return the value of that semantic spelling. If the\n  /// parsed attribute does not have a semantic equivalent, or would not have\n  /// a Spelling enumeration, the value UINT_MAX is returned.\n  unsigned getSemanticSpelling() const;\n\n  /// If this is an OpenCL addr space attribute returns its representation\n  /// in LangAS, otherwise returns default addr space.\n  LangAS asOpenCLLangAS() const {\n    switch (getParsedKind()) {\n    case ParsedAttr::AT_OpenCLConstantAddressSpace:\n      return LangAS::opencl_constant;\n    case ParsedAttr::AT_OpenCLGlobalAddressSpace:\n      return LangAS::opencl_global;\n    case ParsedAttr::AT_OpenCLGlobalDeviceAddressSpace:\n      return LangAS::opencl_global_device;\n    case ParsedAttr::AT_OpenCLGlobalHostAddressSpace:\n      return LangAS::opencl_global_host;\n    case ParsedAttr::AT_OpenCLLocalAddressSpace:\n      return LangAS::opencl_local;\n    case ParsedAttr::AT_OpenCLPrivateAddressSpace:\n      return LangAS::opencl_private;\n    case ParsedAttr::AT_OpenCLGenericAddressSpace:\n      return LangAS::opencl_generic;\n    default:\n      return LangAS::Default;\n    }\n  }\n\n  AttributeCommonInfo::Kind getKind() const {\n    return AttributeCommonInfo::Kind(Info.AttrKind);\n  }\n  const ParsedAttrInfo &getInfo() const { return Info; }\n};\n\nclass AttributePool;\n/// A factory, from which one makes pools, from which one creates\n/// individual attributes which are deallocated with the pool.\n///\n/// Note that it's tolerably cheap to create and destroy one of\n/// these as long as you don't actually allocate anything in it.\nclass AttributeFactory {\npublic:\n  enum {\n    AvailabilityAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 1, 0, 0, 0),\n    TypeTagForDatatypeAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 0, 1, 0, 0),\n    PropertyAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 0, 1),\n  };\n\nprivate:\n  enum {\n    /// The number of free lists we want to be sure to support\n    /// inline.  This is just enough that availability attributes\n    /// don't surpass it.  It's actually very unlikely we'll see an\n    /// attribute that needs more than that; on x86-64 you'd need 10\n    /// expression arguments, and on i386 you'd need 19.\n    InlineFreeListsCapacity =\n        1 + (AvailabilityAllocSize - sizeof(ParsedAttr)) / sizeof(void *)\n  };\n\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Free lists.  The index is determined by the following formula:\n  ///   (size - sizeof(ParsedAttr)) / sizeof(void*)\n  SmallVector<SmallVector<ParsedAttr *, 8>, InlineFreeListsCapacity> FreeLists;\n\n  // The following are the private interface used by AttributePool.\n  friend class AttributePool;\n\n  /// Allocate an attribute of the given size.\n  void *allocate(size_t size);\n\n  void deallocate(ParsedAttr *AL);\n\n  /// Reclaim all the attributes in the given pool chain, which is\n  /// non-empty.  Note that the current implementation is safe\n  /// against reclaiming things which were not actually allocated\n  /// with the allocator, although of course it's important to make\n  /// sure that their allocator lives at least as long as this one.\n  void reclaimPool(AttributePool &head);\n\npublic:\n  AttributeFactory();\n  ~AttributeFactory();\n};\n\nclass AttributePool {\n  friend class AttributeFactory;\n  friend class ParsedAttributes;\n  AttributeFactory &Factory;\n  llvm::TinyPtrVector<ParsedAttr *> Attrs;\n\n  void *allocate(size_t size) {\n    return Factory.allocate(size);\n  }\n\n  ParsedAttr *add(ParsedAttr *attr) {\n    Attrs.push_back(attr);\n    return attr;\n  }\n\n  void remove(ParsedAttr *attr) {\n    assert(llvm::is_contained(Attrs, attr) &&\n           \"Can't take attribute from a pool that doesn't own it!\");\n    Attrs.erase(llvm::find(Attrs, attr));\n  }\n\n  void takePool(AttributePool &pool);\n\npublic:\n  /// Create a new pool for a factory.\n  AttributePool(AttributeFactory &factory) : Factory(factory) {}\n\n  AttributePool(const AttributePool &) = delete;\n\n  ~AttributePool() { Factory.reclaimPool(*this); }\n\n  /// Move the given pool's allocations to this pool.\n  AttributePool(AttributePool &&pool) = default;\n\n  AttributeFactory &getFactory() const { return Factory; }\n\n  void clear() {\n    Factory.reclaimPool(*this);\n    Attrs.clear();\n  }\n\n  /// Take the given pool's allocations and add them to this pool.\n  void takeAllFrom(AttributePool &pool) {\n    takePool(pool);\n    pool.Attrs.clear();\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    size_t temp =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0, 0);\n    (void)temp;\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0,\n                                                           0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       args, numArgs, syntax, ellipsisLoc));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    void *memory = allocate(AttributeFactory::AvailabilityAllocSize);\n    return add(new (memory) ParsedAttr(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(3, 0, 0, 0, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       Param1, Param2, Param3, syntax));\n  }\n\n  ParsedAttr *\n  createTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(AttributeFactory::TypeTagForDatatypeAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       argumentKind, matchingCType,\n                                       layoutCompatible, mustBeNull, syntax));\n  }\n\n  ParsedAttr *createTypeAttribute(IdentifierInfo *attrName,\n                                  SourceRange attrRange,\n                                  IdentifierInfo *scopeName,\n                                  SourceLocation scopeLoc, ParsedType typeArg,\n                                  ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 1, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       typeArg, syntaxUsed));\n  }\n\n  ParsedAttr *\n  createPropertyAttribute(IdentifierInfo *attrName, SourceRange attrRange,\n                          IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                          IdentifierInfo *getterId, IdentifierInfo *setterId,\n                          ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(AttributeFactory::PropertyAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       getterId, setterId, syntaxUsed));\n  }\n};\n\nclass ParsedAttributesView {\n  using VecTy = llvm::TinyPtrVector<ParsedAttr *>;\n  using SizeType = decltype(std::declval<VecTy>().size());\n\npublic:\n  bool empty() const { return AttrList.empty(); }\n  SizeType size() const { return AttrList.size(); }\n  ParsedAttr &operator[](SizeType pos) { return *AttrList[pos]; }\n  const ParsedAttr &operator[](SizeType pos) const { return *AttrList[pos]; }\n\n  void addAtEnd(ParsedAttr *newAttr) {\n    assert(newAttr);\n    AttrList.push_back(newAttr);\n  }\n\n  void remove(ParsedAttr *ToBeRemoved) {\n    assert(is_contained(AttrList, ToBeRemoved) &&\n           \"Cannot remove attribute that isn't in the list\");\n    AttrList.erase(llvm::find(AttrList, ToBeRemoved));\n  }\n\n  void clearListOnly() { AttrList.clear(); }\n\n  struct iterator : llvm::iterator_adaptor_base<iterator, VecTy::iterator,\n                                                std::random_access_iterator_tag,\n                                                ParsedAttr> {\n    iterator() : iterator_adaptor_base(nullptr) {}\n    iterator(VecTy::iterator I) : iterator_adaptor_base(I) {}\n    reference operator*() { return **I; }\n    friend class ParsedAttributesView;\n  };\n  struct const_iterator\n      : llvm::iterator_adaptor_base<const_iterator, VecTy::const_iterator,\n                                    std::random_access_iterator_tag,\n                                    ParsedAttr> {\n    const_iterator() : iterator_adaptor_base(nullptr) {}\n    const_iterator(VecTy::const_iterator I) : iterator_adaptor_base(I) {}\n\n    reference operator*() const { return **I; }\n    friend class ParsedAttributesView;\n  };\n\n  void addAll(iterator B, iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAll(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAllAtEnd(iterator B, iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  void addAllAtEnd(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  iterator begin() { return iterator(AttrList.begin()); }\n  const_iterator begin() const { return const_iterator(AttrList.begin()); }\n  iterator end() { return iterator(AttrList.end()); }\n  const_iterator end() const { return const_iterator(AttrList.end()); }\n\n  ParsedAttr &front() {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  const ParsedAttr &front() const {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  ParsedAttr &back() {\n    assert(!empty());\n    return *AttrList.back();\n  }\n  const ParsedAttr &back() const {\n    assert(!empty());\n    return *AttrList.back();\n  }\n\n  bool hasAttribute(ParsedAttr::Kind K) const {\n    return llvm::any_of(AttrList, [K](const ParsedAttr *AL) {\n      return AL->getParsedKind() == K;\n    });\n  }\n\nprivate:\n  VecTy AttrList;\n};\n\n/// ParsedAttributes - A collection of parsed attributes.  Currently\n/// we don't differentiate between the various attribute syntaxes,\n/// which is basically silly.\n///\n/// Right now this is a very lightweight container, but the expectation\n/// is that this will become significantly more serious.\nclass ParsedAttributes : public ParsedAttributesView {\npublic:\n  ParsedAttributes(AttributeFactory &factory) : pool(factory) {}\n  ParsedAttributes(const ParsedAttributes &) = delete;\n\n  AttributePool &getPool() const { return pool; }\n\n  void takeAllFrom(ParsedAttributes &attrs) {\n    addAll(attrs.begin(), attrs.end());\n    attrs.clearListOnly();\n    pool.takeAllFrom(attrs.pool);\n  }\n\n  void takeOneFrom(ParsedAttributes &Attrs, ParsedAttr *PA) {\n    Attrs.getPool().remove(PA);\n    Attrs.remove(PA);\n    getPool().add(PA);\n    addAtEnd(PA);\n  }\n\n  void clear() {\n    clearListOnly();\n    pool.clear();\n  }\n\n  /// Add attribute with expression arguments.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   args, numArgs, syntax, ellipsisLoc);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add availability attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    ParsedAttr *attr = pool.create(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add objc_bridge_related attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   Param1, Param2, Param3, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add type_tag_for_datatype attribute.\n  ParsedAttr *\n  addNewTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.createTypeTagForDatatype(\n        attrName, attrRange, scopeName, scopeLoc, argumentKind, matchingCType,\n        layoutCompatible, mustBeNull, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add an attribute with a single type argument.\n  ParsedAttr *addNewTypeAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                             ParsedType typeArg,\n                             ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr = pool.createTypeAttribute(attrName, attrRange, scopeName,\n                                                scopeLoc, typeArg, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add microsoft __delspec(property) attribute.\n  ParsedAttr *\n  addNewPropertyAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierInfo *getterId, IdentifierInfo *setterId,\n                     ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr =\n        pool.createPropertyAttribute(attrName, attrRange, scopeName, scopeLoc,\n                                     getterId, setterId, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\nprivate:\n  mutable AttributePool pool;\n};\n\n/// These constants match the enumerated choices of\n/// err_attribute_argument_n_type and err_attribute_argument_type.\nenum AttributeArgumentNType {\n  AANT_ArgumentIntOrBool,\n  AANT_ArgumentIntegerConstant,\n  AANT_ArgumentString,\n  AANT_ArgumentIdentifier,\n  AANT_ArgumentConstantExpr,\n};\n\n/// These constants match the enumerated choices of\n/// warn_attribute_wrong_decl_type and err_attribute_wrong_decl_type.\nenum AttributeDeclKind {\n  ExpectedFunction,\n  ExpectedUnion,\n  ExpectedVariableOrFunction,\n  ExpectedFunctionOrMethod,\n  ExpectedFunctionMethodOrBlock,\n  ExpectedFunctionMethodOrParameter,\n  ExpectedVariable,\n  ExpectedVariableOrField,\n  ExpectedVariableFieldOrTag,\n  ExpectedTypeOrNamespace,\n  ExpectedFunctionVariableOrClass,\n  ExpectedKernelFunction,\n  ExpectedFunctionWithProtoType,\n};\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr &At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr *At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n/// AttributeCommonInfo has a non-explicit constructor which takes an\n/// SourceRange as its only argument, this constructor has many uses so making\n/// it explicit is hard. This constructor causes ambiguity with\n/// DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB, SourceRange R).\n/// We use SFINAE to disable any conversion and remove any ambiguity.\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI &CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI* CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "content": "//===- ASTBitCodes.h - Enum values for the PCH bitcode format ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header defines Bitcode enum values for Clang serialized AST files.\n//\n// The enum values defined in this file should be considered permanent.  If\n// new features are added, they should have values added at the end of the\n// respective lists.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n#define LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Bitstream/BitCodes.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace clang {\nnamespace serialization {\n\n/// AST file major version number supported by this version of\n/// Clang.\n///\n/// Whenever the AST file format changes in a way that makes it\n/// incompatible with previous versions (such that a reader\n/// designed for the previous version could not support reading\n/// the new version), this number should be increased.\n///\n/// Version 4 of AST files also requires that the version control branch and\n/// revision match exactly, since there is no backward compatibility of\n/// AST files at this time.\nconst unsigned VERSION_MAJOR = 13;\n\n/// AST file minor version number supported by this version of\n/// Clang.\n///\n/// Whenever the AST format changes in a way that is still\n/// compatible with previous versions (such that a reader designed\n/// for the previous version could still support reading the new\n/// version by ignoring new kinds of subblocks), this number\n/// should be increased.\nconst unsigned VERSION_MINOR = 0;\n\n/// An ID number that refers to an identifier in an AST file.\n///\n/// The ID numbers of identifiers are consecutive (in order of discovery)\n/// and start at 1. 0 is reserved for NULL.\nusing IdentifierID = uint32_t;\n\n/// An ID number that refers to a declaration in an AST file.\n///\n/// The ID numbers of declarations are consecutive (in order of\n/// discovery), with values below NUM_PREDEF_DECL_IDS being reserved.\n/// At the start of a chain of precompiled headers, declaration ID 1 is\n/// used for the translation unit declaration.\nusing DeclID = uint32_t;\n\n// FIXME: Turn these into classes so we can have some type safety when\n// we go from local ID to global and vice-versa.\nusing LocalDeclID = DeclID;\nusing GlobalDeclID = DeclID;\n\n/// An ID number that refers to a type in an AST file.\n///\n/// The ID of a type is partitioned into two parts: the lower\n/// three bits are used to store the const/volatile/restrict\n/// qualifiers (as with QualType) and the upper bits provide a\n/// type index. The type index values are partitioned into two\n/// sets. The values below NUM_PREDEF_TYPE_IDs are predefined type\n/// IDs (based on the PREDEF_TYPE_*_ID constants), with 0 as a\n/// placeholder for \"no type\". Values from NUM_PREDEF_TYPE_IDs are\n/// other types that have serialized representations.\nusing TypeID = uint32_t;\n\n/// A type index; the type ID with the qualifier bits removed.\nclass TypeIdx {\n  uint32_t Idx = 0;\n\npublic:\n  TypeIdx() = default;\n  explicit TypeIdx(uint32_t index) : Idx(index) {}\n\n  uint32_t getIndex() const { return Idx; }\n\n  TypeID asTypeID(unsigned FastQuals) const {\n    if (Idx == uint32_t(-1))\n      return TypeID(-1);\n\n    return (Idx << Qualifiers::FastWidth) | FastQuals;\n  }\n\n  static TypeIdx fromTypeID(TypeID ID) {\n    if (ID == TypeID(-1))\n      return TypeIdx(-1);\n\n    return TypeIdx(ID >> Qualifiers::FastWidth);\n  }\n};\n\n/// A structure for putting \"fast\"-unqualified QualTypes into a\n/// DenseMap.  This uses the standard pointer hash function.\nstruct UnsafeQualTypeDenseMapInfo {\n  static bool isEqual(QualType A, QualType B) { return A == B; }\n\n  static QualType getEmptyKey() {\n    return QualType::getFromOpaquePtr((void *)1);\n  }\n\n  static QualType getTombstoneKey() {\n    return QualType::getFromOpaquePtr((void *)2);\n  }\n\n  static unsigned getHashValue(QualType T) {\n    assert(!T.getLocalFastQualifiers() &&\n           \"hash invalid for types with fast quals\");\n    uintptr_t v = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n    return (unsigned(v) >> 4) ^ (unsigned(v) >> 9);\n  }\n};\n\n/// An ID number that refers to an identifier in an AST file.\nusing IdentID = uint32_t;\n\n/// The number of predefined identifier IDs.\nconst unsigned int NUM_PREDEF_IDENT_IDS = 1;\n\n/// An ID number that refers to a macro in an AST file.\nusing MacroID = uint32_t;\n\n/// A global ID number that refers to a macro in an AST file.\nusing GlobalMacroID = uint32_t;\n\n/// A local to a module ID number that refers to a macro in an\n/// AST file.\nusing LocalMacroID = uint32_t;\n\n/// The number of predefined macro IDs.\nconst unsigned int NUM_PREDEF_MACRO_IDS = 1;\n\n/// An ID number that refers to an ObjC selector in an AST file.\nusing SelectorID = uint32_t;\n\n/// The number of predefined selector IDs.\nconst unsigned int NUM_PREDEF_SELECTOR_IDS = 1;\n\n/// An ID number that refers to a set of CXXBaseSpecifiers in an\n/// AST file.\nusing CXXBaseSpecifiersID = uint32_t;\n\n/// An ID number that refers to a list of CXXCtorInitializers in an\n/// AST file.\nusing CXXCtorInitializersID = uint32_t;\n\n/// An ID number that refers to an entity in the detailed\n/// preprocessing record.\nusing PreprocessedEntityID = uint32_t;\n\n/// An ID number that refers to a submodule in a module file.\nusing SubmoduleID = uint32_t;\n\n/// The number of predefined submodule IDs.\nconst unsigned int NUM_PREDEF_SUBMODULE_IDS = 1;\n\n/// Source range/offset of a preprocessed entity.\nstruct PPEntityOffset {\n  /// Raw source location of beginning of range.\n  unsigned Begin;\n\n  /// Raw source location of end of range.\n  unsigned End;\n\n  /// Offset in the AST file relative to ModuleFile::MacroOffsetsBase.\n  uint32_t BitOffset;\n\n  PPEntityOffset(SourceRange R, uint32_t BitOffset)\n      : Begin(R.getBegin().getRawEncoding()), End(R.getEnd().getRawEncoding()),\n        BitOffset(BitOffset) {}\n\n  SourceLocation getBegin() const {\n    return SourceLocation::getFromRawEncoding(Begin);\n  }\n\n  SourceLocation getEnd() const {\n    return SourceLocation::getFromRawEncoding(End);\n  }\n};\n\n/// Source range of a skipped preprocessor region\nstruct PPSkippedRange {\n  /// Raw source location of beginning of range.\n  unsigned Begin;\n  /// Raw source location of end of range.\n  unsigned End;\n\n  PPSkippedRange(SourceRange R)\n      : Begin(R.getBegin().getRawEncoding()), End(R.getEnd().getRawEncoding()) {\n  }\n\n  SourceLocation getBegin() const {\n    return SourceLocation::getFromRawEncoding(Begin);\n  }\n  SourceLocation getEnd() const {\n    return SourceLocation::getFromRawEncoding(End);\n  }\n};\n\n/// Offset in the AST file. Use splitted 64-bit integer into low/high\n/// parts to keep structure alignment 32-bit (it is important because\n/// blobs in bitstream are 32-bit aligned). This structure is serialized\n/// \"as is\" to the AST file.\nstruct UnderalignedInt64 {\n  uint32_t BitOffsetLow = 0;\n  uint32_t BitOffsetHigh = 0;\n\n  UnderalignedInt64() = default;\n  UnderalignedInt64(uint64_t BitOffset) { setBitOffset(BitOffset); }\n\n  void setBitOffset(uint64_t Offset) {\n    BitOffsetLow = Offset;\n    BitOffsetHigh = Offset >> 32;\n  }\n\n  uint64_t getBitOffset() const {\n    return BitOffsetLow | (uint64_t(BitOffsetHigh) << 32);\n  }\n};\n\n/// Source location and bit offset of a declaration.\nstruct DeclOffset {\n  /// Raw source location.\n  unsigned Loc = 0;\n\n  /// Offset relative to the start of the DECLTYPES_BLOCK block. Keep\n  /// structure alignment 32-bit and avoid padding gap because undefined\n  /// value in the padding affects AST hash.\n  UnderalignedInt64 BitOffset;\n\n  DeclOffset() = default;\n  DeclOffset(SourceLocation Loc, uint64_t BitOffset,\n             uint64_t DeclTypesBlockStartOffset) {\n    setLocation(Loc);\n    setBitOffset(BitOffset, DeclTypesBlockStartOffset);\n  }\n\n  void setLocation(SourceLocation L) { Loc = L.getRawEncoding(); }\n\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromRawEncoding(Loc);\n  }\n\n  void setBitOffset(uint64_t Offset, const uint64_t DeclTypesBlockStartOffset) {\n    BitOffset.setBitOffset(Offset - DeclTypesBlockStartOffset);\n  }\n\n  uint64_t getBitOffset(const uint64_t DeclTypesBlockStartOffset) const {\n    return BitOffset.getBitOffset() + DeclTypesBlockStartOffset;\n  }\n};\n\n/// The number of predefined preprocessed entity IDs.\nconst unsigned int NUM_PREDEF_PP_ENTITY_IDS = 1;\n\n/// Describes the various kinds of blocks that occur within\n/// an AST file.\nenum BlockIDs {\n  /// The AST block, which acts as a container around the\n  /// full AST block.\n  AST_BLOCK_ID = llvm::bitc::FIRST_APPLICATION_BLOCKID,\n\n  /// The block containing information about the source\n  /// manager.\n  SOURCE_MANAGER_BLOCK_ID,\n\n  /// The block containing information about the\n  /// preprocessor.\n  PREPROCESSOR_BLOCK_ID,\n\n  /// The block containing the definitions of all of the\n  /// types and decls used within the AST file.\n  DECLTYPES_BLOCK_ID,\n\n  /// The block containing the detailed preprocessing record.\n  PREPROCESSOR_DETAIL_BLOCK_ID,\n\n  /// The block containing the submodule structure.\n  SUBMODULE_BLOCK_ID,\n\n  /// The block containing comments.\n  COMMENTS_BLOCK_ID,\n\n  /// The control block, which contains all of the\n  /// information that needs to be validated prior to committing\n  /// to loading the AST file.\n  CONTROL_BLOCK_ID,\n\n  /// The block of input files, which were used as inputs\n  /// to create this AST file.\n  ///\n  /// This block is part of the control block.\n  INPUT_FILES_BLOCK_ID,\n\n  /// The block of configuration options, used to check that\n  /// a module is being used in a configuration compatible with the\n  /// configuration in which it was built.\n  ///\n  /// This block is part of the control block.\n  OPTIONS_BLOCK_ID,\n\n  /// A block containing a module file extension.\n  EXTENSION_BLOCK_ID,\n\n  /// A block with unhashed content.\n  ///\n  /// These records should not change the \\a ASTFileSignature.  See \\a\n  /// UnhashedControlBlockRecordTypes for the list of records.\n  UNHASHED_CONTROL_BLOCK_ID,\n};\n\n/// Record types that occur within the control block.\nenum ControlRecordTypes {\n  /// AST file metadata, including the AST file version number\n  /// and information about the compiler used to build this AST file.\n  METADATA = 1,\n\n  /// Record code for the list of other AST files imported by\n  /// this AST file.\n  IMPORTS,\n\n  /// Record code for the original file that was used to\n  /// generate the AST file, including both its file ID and its\n  /// name.\n  ORIGINAL_FILE,\n\n  /// The directory that the PCH was originally created in.\n  ORIGINAL_PCH_DIR,\n\n  /// Record code for file ID of the file or buffer that was used to\n  /// generate the AST file.\n  ORIGINAL_FILE_ID,\n\n  /// Offsets into the input-files block where input files\n  /// reside.\n  INPUT_FILE_OFFSETS,\n\n  /// Record code for the module name.\n  MODULE_NAME,\n\n  /// Record code for the module map file that was used to build this\n  /// AST file.\n  MODULE_MAP_FILE,\n\n  /// Record code for the module build directory.\n  MODULE_DIRECTORY,\n};\n\n/// Record types that occur within the options block inside\n/// the control block.\nenum OptionsRecordTypes {\n  /// Record code for the language options table.\n  ///\n  /// The record with this code contains the contents of the\n  /// LangOptions structure. We serialize the entire contents of\n  /// the structure, and let the reader decide which options are\n  /// actually important to check.\n  LANGUAGE_OPTIONS = 1,\n\n  /// Record code for the target options table.\n  TARGET_OPTIONS,\n\n  /// Record code for the filesystem options table.\n  FILE_SYSTEM_OPTIONS,\n\n  /// Record code for the headers search options table.\n  HEADER_SEARCH_OPTIONS,\n\n  /// Record code for the preprocessor options table.\n  PREPROCESSOR_OPTIONS,\n};\n\n/// Record codes for the unhashed control block.\nenum UnhashedControlBlockRecordTypes {\n  /// Record code for the signature that identifiers this AST file.\n  SIGNATURE = 1,\n\n  /// Record code for the content hash of the AST block.\n  AST_BLOCK_HASH,\n\n  /// Record code for the diagnostic options table.\n  DIAGNOSTIC_OPTIONS,\n\n  /// Record code for \\#pragma diagnostic mappings.\n  DIAG_PRAGMA_MAPPINGS,\n};\n\n/// Record code for extension blocks.\nenum ExtensionBlockRecordTypes {\n  /// Metadata describing this particular extension.\n  EXTENSION_METADATA = 1,\n\n  /// The first record ID allocated to the extensions themselves.\n  FIRST_EXTENSION_RECORD_ID = 4\n};\n\n/// Record types that occur within the input-files block\n/// inside the control block.\nenum InputFileRecordTypes {\n  /// An input file.\n  INPUT_FILE = 1,\n\n  /// The input file content hash\n  INPUT_FILE_HASH\n};\n\n/// Record types that occur within the AST block itself.\nenum ASTRecordTypes {\n  /// Record code for the offsets of each type.\n  ///\n  /// The TYPE_OFFSET constant describes the record that occurs\n  /// within the AST block. The record itself is an array of offsets that\n  /// point into the declarations and types block (identified by\n  /// DECLTYPES_BLOCK_ID). The index into the array is based on the ID\n  /// of a type. For a given type ID @c T, the lower three bits of\n  /// @c T are its qualifiers (const, volatile, restrict), as in\n  /// the QualType class. The upper bits, after being shifted and\n  /// subtracting NUM_PREDEF_TYPE_IDS, are used to index into the\n  /// TYPE_OFFSET block to determine the offset of that type's\n  /// corresponding record within the DECLTYPES_BLOCK_ID block.\n  TYPE_OFFSET = 1,\n\n  /// Record code for the offsets of each decl.\n  ///\n  /// The DECL_OFFSET constant describes the record that occurs\n  /// within the block identified by DECL_OFFSETS_BLOCK_ID within\n  /// the AST block. The record itself is an array of offsets that\n  /// point into the declarations and types block (identified by\n  /// DECLTYPES_BLOCK_ID). The declaration ID is an index into this\n  /// record, after subtracting one to account for the use of\n  /// declaration ID 0 for a NULL declaration pointer. Index 0 is\n  /// reserved for the translation unit declaration.\n  DECL_OFFSET = 2,\n\n  /// Record code for the table of offsets of each\n  /// identifier ID.\n  ///\n  /// The offset table contains offsets into the blob stored in\n  /// the IDENTIFIER_TABLE record. Each offset points to the\n  /// NULL-terminated string that corresponds to that identifier.\n  IDENTIFIER_OFFSET = 3,\n\n  /// This is so that older clang versions, before the introduction\n  /// of the control block, can read and reject the newer PCH format.\n  /// *DON'T CHANGE THIS NUMBER*.\n  METADATA_OLD_FORMAT = 4,\n\n  /// Record code for the identifier table.\n  ///\n  /// The identifier table is a simple blob that contains\n  /// NULL-terminated strings for all of the identifiers\n  /// referenced by the AST file. The IDENTIFIER_OFFSET table\n  /// contains the mapping from identifier IDs to the characters\n  /// in this blob. Note that the starting offsets of all of the\n  /// identifiers are odd, so that, when the identifier offset\n  /// table is loaded in, we can use the low bit to distinguish\n  /// between offsets (for unresolved identifier IDs) and\n  /// IdentifierInfo pointers (for already-resolved identifier\n  /// IDs).\n  IDENTIFIER_TABLE = 5,\n\n  /// Record code for the array of eagerly deserialized decls.\n  ///\n  /// The AST file contains a list of all of the declarations that should be\n  /// eagerly deserialized present within the parsed headers, stored as an\n  /// array of declaration IDs. These declarations will be\n  /// reported to the AST consumer after the AST file has been\n  /// read, since their presence can affect the semantics of the\n  /// program (e.g., for code generation).\n  EAGERLY_DESERIALIZED_DECLS = 6,\n\n  /// Record code for the set of non-builtin, special\n  /// types.\n  ///\n  /// This record contains the type IDs for the various type nodes\n  /// that are constructed during semantic analysis (e.g.,\n  /// __builtin_va_list). The SPECIAL_TYPE_* constants provide\n  /// offsets into this record.\n  SPECIAL_TYPES = 7,\n\n  /// Record code for the extra statistics we gather while\n  /// generating an AST file.\n  STATISTICS = 8,\n\n  /// Record code for the array of tentative definitions.\n  TENTATIVE_DEFINITIONS = 9,\n\n  // ID 10 used to be for a list of extern \"C\" declarations.\n\n  /// Record code for the table of offsets into the\n  /// Objective-C method pool.\n  SELECTOR_OFFSETS = 11,\n\n  /// Record code for the Objective-C method pool,\n  METHOD_POOL = 12,\n\n  /// The value of the next __COUNTER__ to dispense.\n  /// [PP_COUNTER_VALUE, Val]\n  PP_COUNTER_VALUE = 13,\n\n  /// Record code for the table of offsets into the block\n  /// of source-location information.\n  SOURCE_LOCATION_OFFSETS = 14,\n\n  /// Record code for the set of source location entries\n  /// that need to be preloaded by the AST reader.\n  ///\n  /// This set contains the source location entry for the\n  /// predefines buffer and for any file entries that need to be\n  /// preloaded.\n  SOURCE_LOCATION_PRELOADS = 15,\n\n  /// Record code for the set of ext_vector type names.\n  EXT_VECTOR_DECLS = 16,\n\n  /// Record code for the array of unused file scoped decls.\n  UNUSED_FILESCOPED_DECLS = 17,\n\n  /// Record code for the table of offsets to entries in the\n  /// preprocessing record.\n  PPD_ENTITIES_OFFSETS = 18,\n\n  /// Record code for the array of VTable uses.\n  VTABLE_USES = 19,\n\n  // ID 20 used to be for a list of dynamic classes.\n\n  /// Record code for referenced selector pool.\n  REFERENCED_SELECTOR_POOL = 21,\n\n  /// Record code for an update to the TU's lexically contained\n  /// declarations.\n  TU_UPDATE_LEXICAL = 22,\n\n  // ID 23 used to be for a list of local redeclarations.\n\n  /// Record code for declarations that Sema keeps references of.\n  SEMA_DECL_REFS = 24,\n\n  /// Record code for weak undeclared identifiers.\n  WEAK_UNDECLARED_IDENTIFIERS = 25,\n\n  /// Record code for pending implicit instantiations.\n  PENDING_IMPLICIT_INSTANTIATIONS = 26,\n\n  // ID 27 used to be for a list of replacement decls.\n\n  /// Record code for an update to a decl context's lookup table.\n  ///\n  /// In practice, this should only be used for the TU and namespaces.\n  UPDATE_VISIBLE = 28,\n\n  /// Record for offsets of DECL_UPDATES records for declarations\n  /// that were modified after being deserialized and need updates.\n  DECL_UPDATE_OFFSETS = 29,\n\n  // ID 30 used to be a decl update record. These are now in the DECLTYPES\n  // block.\n\n  // ID 31 used to be a list of offsets to DECL_CXX_BASE_SPECIFIERS records.\n\n  // ID 32 used to be the code for \\#pragma diagnostic mappings.\n\n  /// Record code for special CUDA declarations.\n  CUDA_SPECIAL_DECL_REFS = 33,\n\n  /// Record code for header search information.\n  HEADER_SEARCH_TABLE = 34,\n\n  /// Record code for floating point \\#pragma options.\n  FP_PRAGMA_OPTIONS = 35,\n\n  /// Record code for enabled OpenCL extensions.\n  OPENCL_EXTENSIONS = 36,\n\n  /// The list of delegating constructor declarations.\n  DELEGATING_CTORS = 37,\n\n  /// Record code for the set of known namespaces, which are used\n  /// for typo correction.\n  KNOWN_NAMESPACES = 38,\n\n  /// Record code for the remapping information used to relate\n  /// loaded modules to the various offsets and IDs(e.g., source location\n  /// offests, declaration and type IDs) that are used in that module to\n  /// refer to other modules.\n  MODULE_OFFSET_MAP = 39,\n\n  /// Record code for the source manager line table information,\n  /// which stores information about \\#line directives.\n  SOURCE_MANAGER_LINE_TABLE = 40,\n\n  /// Record code for map of Objective-C class definition IDs to the\n  /// ObjC categories in a module that are attached to that class.\n  OBJC_CATEGORIES_MAP = 41,\n\n  /// Record code for a file sorted array of DeclIDs in a module.\n  FILE_SORTED_DECLS = 42,\n\n  /// Record code for an array of all of the (sub)modules that were\n  /// imported by the AST file.\n  IMPORTED_MODULES = 43,\n\n  // ID 44 used to be a table of merged canonical declarations.\n  // ID 45 used to be a list of declaration IDs of local redeclarations.\n\n  /// Record code for the array of Objective-C categories (including\n  /// extensions).\n  ///\n  /// This array can only be interpreted properly using the Objective-C\n  /// categories map.\n  OBJC_CATEGORIES = 46,\n\n  /// Record code for the table of offsets of each macro ID.\n  ///\n  /// The offset table contains offsets into the blob stored in\n  /// the preprocessor block. Each offset points to the corresponding\n  /// macro definition.\n  MACRO_OFFSET = 47,\n\n  /// A list of \"interesting\" identifiers. Only used in C++ (where we\n  /// don't normally do lookups into the serialized identifier table). These\n  /// are eagerly deserialized.\n  INTERESTING_IDENTIFIERS = 48,\n\n  /// Record code for undefined but used functions and variables that\n  /// need a definition in this TU.\n  UNDEFINED_BUT_USED = 49,\n\n  /// Record code for late parsed template functions.\n  LATE_PARSED_TEMPLATE = 50,\n\n  /// Record code for \\#pragma optimize options.\n  OPTIMIZE_PRAGMA_OPTIONS = 51,\n\n  /// Record code for potentially unused local typedef names.\n  UNUSED_LOCAL_TYPEDEF_NAME_CANDIDATES = 52,\n\n  // ID 53 used to be a table of constructor initializer records.\n\n  /// Delete expressions that will be analyzed later.\n  DELETE_EXPRS_TO_ANALYZE = 54,\n\n  /// Record code for \\#pragma ms_struct options.\n  MSSTRUCT_PRAGMA_OPTIONS = 55,\n\n  /// Record code for \\#pragma ms_struct options.\n  POINTERS_TO_MEMBERS_PRAGMA_OPTIONS = 56,\n\n  /// Number of unmatched #pragma clang cuda_force_host_device begin\n  /// directives we've seen.\n  CUDA_PRAGMA_FORCE_HOST_DEVICE_DEPTH = 57,\n\n  /// Record code for types associated with OpenCL extensions.\n  OPENCL_EXTENSION_TYPES = 58,\n\n  /// Record code for declarations associated with OpenCL extensions.\n  OPENCL_EXTENSION_DECLS = 59,\n\n  MODULAR_CODEGEN_DECLS = 60,\n\n  /// Record code for \\#pragma align/pack options.\n  ALIGN_PACK_PRAGMA_OPTIONS = 61,\n\n  /// The stack of open #ifs/#ifdefs recorded in a preamble.\n  PP_CONDITIONAL_STACK = 62,\n\n  /// A table of skipped ranges within the preprocessing record.\n  PPD_SKIPPED_RANGES = 63,\n\n  /// Record code for the Decls to be checked for deferred diags.\n  DECLS_TO_CHECK_FOR_DEFERRED_DIAGS = 64,\n\n  /// Record code for \\#pragma float_control options.\n  FLOAT_CONTROL_PRAGMA_OPTIONS = 65,\n};\n\n/// Record types used within a source manager block.\nenum SourceManagerRecordTypes {\n  /// Describes a source location entry (SLocEntry) for a\n  /// file.\n  SM_SLOC_FILE_ENTRY = 1,\n\n  /// Describes a source location entry (SLocEntry) for a\n  /// buffer.\n  SM_SLOC_BUFFER_ENTRY = 2,\n\n  /// Describes a blob that contains the data for a buffer\n  /// entry. This kind of record always directly follows a\n  /// SM_SLOC_BUFFER_ENTRY record or a SM_SLOC_FILE_ENTRY with an\n  /// overridden buffer.\n  SM_SLOC_BUFFER_BLOB = 3,\n\n  /// Describes a zlib-compressed blob that contains the data for\n  /// a buffer entry.\n  SM_SLOC_BUFFER_BLOB_COMPRESSED = 4,\n\n  /// Describes a source location entry (SLocEntry) for a\n  /// macro expansion.\n  SM_SLOC_EXPANSION_ENTRY = 5\n};\n\n/// Record types used within a preprocessor block.\nenum PreprocessorRecordTypes {\n  // The macros in the PP section are a PP_MACRO_* instance followed by a\n  // list of PP_TOKEN instances for each token in the definition.\n\n  /// An object-like macro definition.\n  /// [PP_MACRO_OBJECT_LIKE, IdentInfoID, SLoc, IsUsed]\n  PP_MACRO_OBJECT_LIKE = 1,\n\n  /// A function-like macro definition.\n  /// [PP_MACRO_FUNCTION_LIKE, \\<ObjectLikeStuff>, IsC99Varargs,\n  /// IsGNUVarars, NumArgs, ArgIdentInfoID* ]\n  PP_MACRO_FUNCTION_LIKE = 2,\n\n  /// Describes one token.\n  /// [PP_TOKEN, SLoc, Length, IdentInfoID, Kind, Flags]\n  PP_TOKEN = 3,\n\n  /// The macro directives history for a particular identifier.\n  PP_MACRO_DIRECTIVE_HISTORY = 4,\n\n  /// A macro directive exported by a module.\n  /// [PP_MODULE_MACRO, SubmoduleID, MacroID, (Overridden SubmoduleID)*]\n  PP_MODULE_MACRO = 5,\n};\n\n/// Record types used within a preprocessor detail block.\nenum PreprocessorDetailRecordTypes {\n  /// Describes a macro expansion within the preprocessing record.\n  PPD_MACRO_EXPANSION = 0,\n\n  /// Describes a macro definition within the preprocessing record.\n  PPD_MACRO_DEFINITION = 1,\n\n  /// Describes an inclusion directive within the preprocessing\n  /// record.\n  PPD_INCLUSION_DIRECTIVE = 2\n};\n\n/// Record types used within a submodule description block.\nenum SubmoduleRecordTypes {\n  /// Metadata for submodules as a whole.\n  SUBMODULE_METADATA = 0,\n\n  /// Defines the major attributes of a submodule, including its\n  /// name and parent.\n  SUBMODULE_DEFINITION = 1,\n\n  /// Specifies the umbrella header used to create this module,\n  /// if any.\n  SUBMODULE_UMBRELLA_HEADER = 2,\n\n  /// Specifies a header that falls into this (sub)module.\n  SUBMODULE_HEADER = 3,\n\n  /// Specifies a top-level header that falls into this (sub)module.\n  SUBMODULE_TOPHEADER = 4,\n\n  /// Specifies an umbrella directory.\n  SUBMODULE_UMBRELLA_DIR = 5,\n\n  /// Specifies the submodules that are imported by this\n  /// submodule.\n  SUBMODULE_IMPORTS = 6,\n\n  /// Specifies the submodules that are re-exported from this\n  /// submodule.\n  SUBMODULE_EXPORTS = 7,\n\n  /// Specifies a required feature.\n  SUBMODULE_REQUIRES = 8,\n\n  /// Specifies a header that has been explicitly excluded\n  /// from this submodule.\n  SUBMODULE_EXCLUDED_HEADER = 9,\n\n  /// Specifies a library or framework to link against.\n  SUBMODULE_LINK_LIBRARY = 10,\n\n  /// Specifies a configuration macro for this module.\n  SUBMODULE_CONFIG_MACRO = 11,\n\n  /// Specifies a conflict with another module.\n  SUBMODULE_CONFLICT = 12,\n\n  /// Specifies a header that is private to this submodule.\n  SUBMODULE_PRIVATE_HEADER = 13,\n\n  /// Specifies a header that is part of the module but must be\n  /// textually included.\n  SUBMODULE_TEXTUAL_HEADER = 14,\n\n  /// Specifies a header that is private to this submodule but\n  /// must be textually included.\n  SUBMODULE_PRIVATE_TEXTUAL_HEADER = 15,\n\n  /// Specifies some declarations with initializers that must be\n  /// emitted to initialize the module.\n  SUBMODULE_INITIALIZERS = 16,\n\n  /// Specifies the name of the module that will eventually\n  /// re-export the entities in this module.\n  SUBMODULE_EXPORT_AS = 17,\n};\n\n/// Record types used within a comments block.\nenum CommentRecordTypes { COMMENTS_RAW_COMMENT = 0 };\n\n/// \\defgroup ASTAST AST file AST constants\n///\n/// The constants in this group describe various components of the\n/// abstract syntax tree within an AST file.\n///\n/// @{\n\n/// Predefined type IDs.\n///\n/// These type IDs correspond to predefined types in the AST\n/// context, such as built-in types (int) and special place-holder\n/// types (the \\<overload> and \\<dependent> type markers). Such\n/// types are never actually serialized, since they will be built\n/// by the AST context when it is created.\nenum PredefinedTypeIDs {\n  /// The NULL type.\n  PREDEF_TYPE_NULL_ID = 0,\n\n  /// The void type.\n  PREDEF_TYPE_VOID_ID = 1,\n\n  /// The 'bool' or '_Bool' type.\n  PREDEF_TYPE_BOOL_ID = 2,\n\n  /// The 'char' type, when it is unsigned.\n  PREDEF_TYPE_CHAR_U_ID = 3,\n\n  /// The 'unsigned char' type.\n  PREDEF_TYPE_UCHAR_ID = 4,\n\n  /// The 'unsigned short' type.\n  PREDEF_TYPE_USHORT_ID = 5,\n\n  /// The 'unsigned int' type.\n  PREDEF_TYPE_UINT_ID = 6,\n\n  /// The 'unsigned long' type.\n  PREDEF_TYPE_ULONG_ID = 7,\n\n  /// The 'unsigned long long' type.\n  PREDEF_TYPE_ULONGLONG_ID = 8,\n\n  /// The 'char' type, when it is signed.\n  PREDEF_TYPE_CHAR_S_ID = 9,\n\n  /// The 'signed char' type.\n  PREDEF_TYPE_SCHAR_ID = 10,\n\n  /// The C++ 'wchar_t' type.\n  PREDEF_TYPE_WCHAR_ID = 11,\n\n  /// The (signed) 'short' type.\n  PREDEF_TYPE_SHORT_ID = 12,\n\n  /// The (signed) 'int' type.\n  PREDEF_TYPE_INT_ID = 13,\n\n  /// The (signed) 'long' type.\n  PREDEF_TYPE_LONG_ID = 14,\n\n  /// The (signed) 'long long' type.\n  PREDEF_TYPE_LONGLONG_ID = 15,\n\n  /// The 'float' type.\n  PREDEF_TYPE_FLOAT_ID = 16,\n\n  /// The 'double' type.\n  PREDEF_TYPE_DOUBLE_ID = 17,\n\n  /// The 'long double' type.\n  PREDEF_TYPE_LONGDOUBLE_ID = 18,\n\n  /// The placeholder type for overloaded function sets.\n  PREDEF_TYPE_OVERLOAD_ID = 19,\n\n  /// The placeholder type for dependent types.\n  PREDEF_TYPE_DEPENDENT_ID = 20,\n\n  /// The '__uint128_t' type.\n  PREDEF_TYPE_UINT128_ID = 21,\n\n  /// The '__int128_t' type.\n  PREDEF_TYPE_INT128_ID = 22,\n\n  /// The type of 'nullptr'.\n  PREDEF_TYPE_NULLPTR_ID = 23,\n\n  /// The C++ 'char16_t' type.\n  PREDEF_TYPE_CHAR16_ID = 24,\n\n  /// The C++ 'char32_t' type.\n  PREDEF_TYPE_CHAR32_ID = 25,\n\n  /// The ObjC 'id' type.\n  PREDEF_TYPE_OBJC_ID = 26,\n\n  /// The ObjC 'Class' type.\n  PREDEF_TYPE_OBJC_CLASS = 27,\n\n  /// The ObjC 'SEL' type.\n  PREDEF_TYPE_OBJC_SEL = 28,\n\n  /// The 'unknown any' placeholder type.\n  PREDEF_TYPE_UNKNOWN_ANY = 29,\n\n  /// The placeholder type for bound member functions.\n  PREDEF_TYPE_BOUND_MEMBER = 30,\n\n  /// The \"auto\" deduction type.\n  PREDEF_TYPE_AUTO_DEDUCT = 31,\n\n  /// The \"auto &&\" deduction type.\n  PREDEF_TYPE_AUTO_RREF_DEDUCT = 32,\n\n  /// The OpenCL 'half' / ARM NEON __fp16 type.\n  PREDEF_TYPE_HALF_ID = 33,\n\n  /// ARC's unbridged-cast placeholder type.\n  PREDEF_TYPE_ARC_UNBRIDGED_CAST = 34,\n\n  /// The pseudo-object placeholder type.\n  PREDEF_TYPE_PSEUDO_OBJECT = 35,\n\n  /// The placeholder type for builtin functions.\n  PREDEF_TYPE_BUILTIN_FN = 36,\n\n  /// OpenCL event type.\n  PREDEF_TYPE_EVENT_ID = 37,\n\n  /// OpenCL clk event type.\n  PREDEF_TYPE_CLK_EVENT_ID = 38,\n\n  /// OpenCL sampler type.\n  PREDEF_TYPE_SAMPLER_ID = 39,\n\n  /// OpenCL queue type.\n  PREDEF_TYPE_QUEUE_ID = 40,\n\n  /// OpenCL reserve_id type.\n  PREDEF_TYPE_RESERVE_ID_ID = 41,\n\n  /// The placeholder type for OpenMP array section.\n  PREDEF_TYPE_OMP_ARRAY_SECTION = 42,\n\n  /// The '__float128' type\n  PREDEF_TYPE_FLOAT128_ID = 43,\n\n  /// The '_Float16' type\n  PREDEF_TYPE_FLOAT16_ID = 44,\n\n  /// The C++ 'char8_t' type.\n  PREDEF_TYPE_CHAR8_ID = 45,\n\n  /// \\brief The 'short _Accum' type\n  PREDEF_TYPE_SHORT_ACCUM_ID = 46,\n\n  /// \\brief The '_Accum' type\n  PREDEF_TYPE_ACCUM_ID = 47,\n\n  /// \\brief The 'long _Accum' type\n  PREDEF_TYPE_LONG_ACCUM_ID = 48,\n\n  /// \\brief The 'unsigned short _Accum' type\n  PREDEF_TYPE_USHORT_ACCUM_ID = 49,\n\n  /// \\brief The 'unsigned _Accum' type\n  PREDEF_TYPE_UACCUM_ID = 50,\n\n  /// \\brief The 'unsigned long _Accum' type\n  PREDEF_TYPE_ULONG_ACCUM_ID = 51,\n\n  /// \\brief The 'short _Fract' type\n  PREDEF_TYPE_SHORT_FRACT_ID = 52,\n\n  /// \\brief The '_Fract' type\n  PREDEF_TYPE_FRACT_ID = 53,\n\n  /// \\brief The 'long _Fract' type\n  PREDEF_TYPE_LONG_FRACT_ID = 54,\n\n  /// \\brief The 'unsigned short _Fract' type\n  PREDEF_TYPE_USHORT_FRACT_ID = 55,\n\n  /// \\brief The 'unsigned _Fract' type\n  PREDEF_TYPE_UFRACT_ID = 56,\n\n  /// \\brief The 'unsigned long _Fract' type\n  PREDEF_TYPE_ULONG_FRACT_ID = 57,\n\n  /// \\brief The '_Sat short _Accum' type\n  PREDEF_TYPE_SAT_SHORT_ACCUM_ID = 58,\n\n  /// \\brief The '_Sat _Accum' type\n  PREDEF_TYPE_SAT_ACCUM_ID = 59,\n\n  /// \\brief The '_Sat long _Accum' type\n  PREDEF_TYPE_SAT_LONG_ACCUM_ID = 60,\n\n  /// \\brief The '_Sat unsigned short _Accum' type\n  PREDEF_TYPE_SAT_USHORT_ACCUM_ID = 61,\n\n  /// \\brief The '_Sat unsigned _Accum' type\n  PREDEF_TYPE_SAT_UACCUM_ID = 62,\n\n  /// \\brief The '_Sat unsigned long _Accum' type\n  PREDEF_TYPE_SAT_ULONG_ACCUM_ID = 63,\n\n  /// \\brief The '_Sat short _Fract' type\n  PREDEF_TYPE_SAT_SHORT_FRACT_ID = 64,\n\n  /// \\brief The '_Sat _Fract' type\n  PREDEF_TYPE_SAT_FRACT_ID = 65,\n\n  /// \\brief The '_Sat long _Fract' type\n  PREDEF_TYPE_SAT_LONG_FRACT_ID = 66,\n\n  /// \\brief The '_Sat unsigned short _Fract' type\n  PREDEF_TYPE_SAT_USHORT_FRACT_ID = 67,\n\n  /// \\brief The '_Sat unsigned _Fract' type\n  PREDEF_TYPE_SAT_UFRACT_ID = 68,\n\n  /// \\brief The '_Sat unsigned long _Fract' type\n  PREDEF_TYPE_SAT_ULONG_FRACT_ID = 69,\n\n  /// The placeholder type for OpenMP array shaping operation.\n  PREDEF_TYPE_OMP_ARRAY_SHAPING = 70,\n\n  /// The placeholder type for OpenMP iterator expression.\n  PREDEF_TYPE_OMP_ITERATOR = 71,\n\n  /// A placeholder type for incomplete matrix index operations.\n  PREDEF_TYPE_INCOMPLETE_MATRIX_IDX = 72,\n\n  /// \\brief The '__bf16' type\n  PREDEF_TYPE_BFLOAT16_ID = 73,\n\n/// OpenCL image types with auto numeration\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \\\n  PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/OpenCLImageTypes.def\"\n/// \\brief OpenCL extension types with auto numeration\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n// \\brief SVE types with auto numeration\n#define SVE_TYPE(Name, Id, SingletonId) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n// \\brief  PowerPC MMA types with auto numeration\n#define PPC_VECTOR_TYPE(Name, Id, Size) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/PPCTypes.def\"\n// \\brief RISC-V V types with auto numeration\n#define RVV_TYPE(Name, Id, SingletonId) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/RISCVVTypes.def\"\n};\n\n/// The number of predefined type IDs that are reserved for\n/// the PREDEF_TYPE_* constants.\n///\n/// Type IDs for non-predefined types will start at\n/// NUM_PREDEF_TYPE_IDs.\nconst unsigned NUM_PREDEF_TYPE_IDS = 300;\n\n/// Record codes for each kind of type.\n///\n/// These constants describe the type records that can occur within a\n/// block identified by DECLTYPES_BLOCK_ID in the AST file. Each\n/// constant describes a record for a specific type class in the\n/// AST. Note that DeclCode values share this code space.\nenum TypeCode {\n#define TYPE_BIT_CODE(CLASS_ID, CODE_ID, CODE_VALUE)                           \\\n  TYPE_##CODE_ID = CODE_VALUE,\n#include \"clang/Serialization/TypeBitCodes.def\"\n\n  /// An ExtQualType record.\n  TYPE_EXT_QUAL = 1\n};\n\n/// The type IDs for special types constructed by semantic\n/// analysis.\n///\n/// The constants in this enumeration are indices into the\n/// SPECIAL_TYPES record.\nenum SpecialTypeIDs {\n  /// CFConstantString type\n  SPECIAL_TYPE_CF_CONSTANT_STRING = 0,\n\n  /// C FILE typedef type\n  SPECIAL_TYPE_FILE = 1,\n\n  /// C jmp_buf typedef type\n  SPECIAL_TYPE_JMP_BUF = 2,\n\n  /// C sigjmp_buf typedef type\n  SPECIAL_TYPE_SIGJMP_BUF = 3,\n\n  /// Objective-C \"id\" redefinition type\n  SPECIAL_TYPE_OBJC_ID_REDEFINITION = 4,\n\n  /// Objective-C \"Class\" redefinition type\n  SPECIAL_TYPE_OBJC_CLASS_REDEFINITION = 5,\n\n  /// Objective-C \"SEL\" redefinition type\n  SPECIAL_TYPE_OBJC_SEL_REDEFINITION = 6,\n\n  /// C ucontext_t typedef type\n  SPECIAL_TYPE_UCONTEXT_T = 7\n};\n\n/// The number of special type IDs.\nconst unsigned NumSpecialTypeIDs = 8;\n\n/// Predefined declaration IDs.\n///\n/// These declaration IDs correspond to predefined declarations in the AST\n/// context, such as the NULL declaration ID. Such declarations are never\n/// actually serialized, since they will be built by the AST context when\n/// it is created.\nenum PredefinedDeclIDs {\n  /// The NULL declaration.\n  PREDEF_DECL_NULL_ID = 0,\n\n  /// The translation unit.\n  PREDEF_DECL_TRANSLATION_UNIT_ID = 1,\n\n  /// The Objective-C 'id' type.\n  PREDEF_DECL_OBJC_ID_ID = 2,\n\n  /// The Objective-C 'SEL' type.\n  PREDEF_DECL_OBJC_SEL_ID = 3,\n\n  /// The Objective-C 'Class' type.\n  PREDEF_DECL_OBJC_CLASS_ID = 4,\n\n  /// The Objective-C 'Protocol' type.\n  PREDEF_DECL_OBJC_PROTOCOL_ID = 5,\n\n  /// The signed 128-bit integer type.\n  PREDEF_DECL_INT_128_ID = 6,\n\n  /// The unsigned 128-bit integer type.\n  PREDEF_DECL_UNSIGNED_INT_128_ID = 7,\n\n  /// The internal 'instancetype' typedef.\n  PREDEF_DECL_OBJC_INSTANCETYPE_ID = 8,\n\n  /// The internal '__builtin_va_list' typedef.\n  PREDEF_DECL_BUILTIN_VA_LIST_ID = 9,\n\n  /// The internal '__va_list_tag' struct, if any.\n  PREDEF_DECL_VA_LIST_TAG = 10,\n\n  /// The internal '__builtin_ms_va_list' typedef.\n  PREDEF_DECL_BUILTIN_MS_VA_LIST_ID = 11,\n\n  /// The predeclared '_GUID' struct.\n  PREDEF_DECL_BUILTIN_MS_GUID_ID = 12,\n\n  /// The extern \"C\" context.\n  PREDEF_DECL_EXTERN_C_CONTEXT_ID = 13,\n\n  /// The internal '__make_integer_seq' template.\n  PREDEF_DECL_MAKE_INTEGER_SEQ_ID = 14,\n\n  /// The internal '__NSConstantString' typedef.\n  PREDEF_DECL_CF_CONSTANT_STRING_ID = 15,\n\n  /// The internal '__NSConstantString' tag type.\n  PREDEF_DECL_CF_CONSTANT_STRING_TAG_ID = 16,\n\n  /// The internal '__type_pack_element' template.\n  PREDEF_DECL_TYPE_PACK_ELEMENT_ID = 17,\n};\n\n/// The number of declaration IDs that are predefined.\n///\n/// For more information about predefined declarations, see the\n/// \\c PredefinedDeclIDs type and the PREDEF_DECL_*_ID constants.\nconst unsigned int NUM_PREDEF_DECL_IDS = 18;\n\n/// Record of updates for a declaration that was modified after\n/// being deserialized. This can occur within DECLTYPES_BLOCK_ID.\nconst unsigned int DECL_UPDATES = 49;\n\n/// Record code for a list of local redeclarations of a declaration.\n/// This can occur within DECLTYPES_BLOCK_ID.\nconst unsigned int LOCAL_REDECLARATIONS = 50;\n\n/// Record codes for each kind of declaration.\n///\n/// These constants describe the declaration records that can occur within\n/// a declarations block (identified by DECLTYPES_BLOCK_ID). Each\n/// constant describes a record for a specific declaration class\n/// in the AST. Note that TypeCode values share this code space.\nenum DeclCode {\n  /// A TypedefDecl record.\n  DECL_TYPEDEF = 51,\n  /// A TypeAliasDecl record.\n\n  DECL_TYPEALIAS,\n\n  /// An EnumDecl record.\n  DECL_ENUM,\n\n  /// A RecordDecl record.\n  DECL_RECORD,\n\n  /// An EnumConstantDecl record.\n  DECL_ENUM_CONSTANT,\n\n  /// A FunctionDecl record.\n  DECL_FUNCTION,\n\n  /// A ObjCMethodDecl record.\n  DECL_OBJC_METHOD,\n\n  /// A ObjCInterfaceDecl record.\n  DECL_OBJC_INTERFACE,\n\n  /// A ObjCProtocolDecl record.\n  DECL_OBJC_PROTOCOL,\n\n  /// A ObjCIvarDecl record.\n  DECL_OBJC_IVAR,\n\n  /// A ObjCAtDefsFieldDecl record.\n  DECL_OBJC_AT_DEFS_FIELD,\n\n  /// A ObjCCategoryDecl record.\n  DECL_OBJC_CATEGORY,\n\n  /// A ObjCCategoryImplDecl record.\n  DECL_OBJC_CATEGORY_IMPL,\n\n  /// A ObjCImplementationDecl record.\n  DECL_OBJC_IMPLEMENTATION,\n\n  /// A ObjCCompatibleAliasDecl record.\n  DECL_OBJC_COMPATIBLE_ALIAS,\n\n  /// A ObjCPropertyDecl record.\n  DECL_OBJC_PROPERTY,\n\n  /// A ObjCPropertyImplDecl record.\n  DECL_OBJC_PROPERTY_IMPL,\n\n  /// A FieldDecl record.\n  DECL_FIELD,\n\n  /// A MSPropertyDecl record.\n  DECL_MS_PROPERTY,\n\n  /// A MSGuidDecl record.\n  DECL_MS_GUID,\n\n  /// A TemplateParamObjectDecl record.\n  DECL_TEMPLATE_PARAM_OBJECT,\n\n  /// A VarDecl record.\n  DECL_VAR,\n\n  /// An ImplicitParamDecl record.\n  DECL_IMPLICIT_PARAM,\n\n  /// A ParmVarDecl record.\n  DECL_PARM_VAR,\n\n  /// A DecompositionDecl record.\n  DECL_DECOMPOSITION,\n\n  /// A BindingDecl record.\n  DECL_BINDING,\n\n  /// A FileScopeAsmDecl record.\n  DECL_FILE_SCOPE_ASM,\n\n  /// A BlockDecl record.\n  DECL_BLOCK,\n\n  /// A CapturedDecl record.\n  DECL_CAPTURED,\n\n  /// A record that stores the set of declarations that are\n  /// lexically stored within a given DeclContext.\n  ///\n  /// The record itself is a blob that is an array of declaration IDs,\n  /// in the order in which those declarations were added to the\n  /// declaration context. This data is used when iterating over\n  /// the contents of a DeclContext, e.g., via\n  /// DeclContext::decls_begin() and DeclContext::decls_end().\n  DECL_CONTEXT_LEXICAL,\n\n  /// A record that stores the set of declarations that are\n  /// visible from a given DeclContext.\n  ///\n  /// The record itself stores a set of mappings, each of which\n  /// associates a declaration name with one or more declaration\n  /// IDs. This data is used when performing qualified name lookup\n  /// into a DeclContext via DeclContext::lookup.\n  DECL_CONTEXT_VISIBLE,\n\n  /// A LabelDecl record.\n  DECL_LABEL,\n\n  /// A NamespaceDecl record.\n  DECL_NAMESPACE,\n\n  /// A NamespaceAliasDecl record.\n  DECL_NAMESPACE_ALIAS,\n\n  /// A UsingDecl record.\n  DECL_USING,\n\n  /// A UsingPackDecl record.\n  DECL_USING_PACK,\n\n  /// A UsingShadowDecl record.\n  DECL_USING_SHADOW,\n\n  /// A ConstructorUsingShadowDecl record.\n  DECL_CONSTRUCTOR_USING_SHADOW,\n\n  /// A UsingDirecitveDecl record.\n  DECL_USING_DIRECTIVE,\n\n  /// An UnresolvedUsingValueDecl record.\n  DECL_UNRESOLVED_USING_VALUE,\n\n  /// An UnresolvedUsingTypenameDecl record.\n  DECL_UNRESOLVED_USING_TYPENAME,\n\n  /// A LinkageSpecDecl record.\n  DECL_LINKAGE_SPEC,\n\n  /// An ExportDecl record.\n  DECL_EXPORT,\n\n  /// A CXXRecordDecl record.\n  DECL_CXX_RECORD,\n\n  /// A CXXDeductionGuideDecl record.\n  DECL_CXX_DEDUCTION_GUIDE,\n\n  /// A CXXMethodDecl record.\n  DECL_CXX_METHOD,\n\n  /// A CXXConstructorDecl record.\n  DECL_CXX_CONSTRUCTOR,\n\n  /// A CXXDestructorDecl record.\n  DECL_CXX_DESTRUCTOR,\n\n  /// A CXXConversionDecl record.\n  DECL_CXX_CONVERSION,\n\n  /// An AccessSpecDecl record.\n  DECL_ACCESS_SPEC,\n\n  /// A FriendDecl record.\n  DECL_FRIEND,\n\n  /// A FriendTemplateDecl record.\n  DECL_FRIEND_TEMPLATE,\n\n  /// A ClassTemplateDecl record.\n  DECL_CLASS_TEMPLATE,\n\n  /// A ClassTemplateSpecializationDecl record.\n  DECL_CLASS_TEMPLATE_SPECIALIZATION,\n\n  /// A ClassTemplatePartialSpecializationDecl record.\n  DECL_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION,\n\n  /// A VarTemplateDecl record.\n  DECL_VAR_TEMPLATE,\n\n  /// A VarTemplateSpecializationDecl record.\n  DECL_VAR_TEMPLATE_SPECIALIZATION,\n\n  /// A VarTemplatePartialSpecializationDecl record.\n  DECL_VAR_TEMPLATE_PARTIAL_SPECIALIZATION,\n\n  /// A FunctionTemplateDecl record.\n  DECL_FUNCTION_TEMPLATE,\n\n  /// A TemplateTypeParmDecl record.\n  DECL_TEMPLATE_TYPE_PARM,\n\n  /// A NonTypeTemplateParmDecl record.\n  DECL_NON_TYPE_TEMPLATE_PARM,\n\n  /// A TemplateTemplateParmDecl record.\n  DECL_TEMPLATE_TEMPLATE_PARM,\n\n  /// A TypeAliasTemplateDecl record.\n  DECL_TYPE_ALIAS_TEMPLATE,\n\n  /// \\brief A ConceptDecl record.\n  DECL_CONCEPT,\n\n  /// \\brief A StaticAssertDecl record.\n  DECL_STATIC_ASSERT,\n\n  /// A record containing CXXBaseSpecifiers.\n  DECL_CXX_BASE_SPECIFIERS,\n\n  /// A record containing CXXCtorInitializers.\n  DECL_CXX_CTOR_INITIALIZERS,\n\n  /// A IndirectFieldDecl record.\n  DECL_INDIRECTFIELD,\n\n  /// A NonTypeTemplateParmDecl record that stores an expanded\n  /// non-type template parameter pack.\n  DECL_EXPANDED_NON_TYPE_TEMPLATE_PARM_PACK,\n\n  /// A TemplateTemplateParmDecl record that stores an expanded\n  /// template template parameter pack.\n  DECL_EXPANDED_TEMPLATE_TEMPLATE_PARM_PACK,\n\n  /// A ClassScopeFunctionSpecializationDecl record a class scope\n  /// function specialization. (Microsoft extension).\n  DECL_CLASS_SCOPE_FUNCTION_SPECIALIZATION,\n\n  /// An ImportDecl recording a module import.\n  DECL_IMPORT,\n\n  /// An OMPThreadPrivateDecl record.\n  DECL_OMP_THREADPRIVATE,\n\n  /// An OMPRequiresDecl record.\n  DECL_OMP_REQUIRES,\n\n  /// An OMPAllocateDcl record.\n  DECL_OMP_ALLOCATE,\n\n  /// An EmptyDecl record.\n  DECL_EMPTY,\n\n  /// An LifetimeExtendedTemporaryDecl record.\n  DECL_LIFETIME_EXTENDED_TEMPORARY,\n\n  /// A RequiresExprBodyDecl record.\n  DECL_REQUIRES_EXPR_BODY,\n\n  /// An ObjCTypeParamDecl record.\n  DECL_OBJC_TYPE_PARAM,\n\n  /// An OMPCapturedExprDecl record.\n  DECL_OMP_CAPTUREDEXPR,\n\n  /// A PragmaCommentDecl record.\n  DECL_PRAGMA_COMMENT,\n\n  /// A PragmaDetectMismatchDecl record.\n  DECL_PRAGMA_DETECT_MISMATCH,\n\n  /// An OMPDeclareMapperDecl record.\n  DECL_OMP_DECLARE_MAPPER,\n\n  /// An OMPDeclareReductionDecl record.\n  DECL_OMP_DECLARE_REDUCTION,\n\n  DECL_LAST = DECL_OMP_DECLARE_REDUCTION\n};\n\n/// Record codes for each kind of statement or expression.\n///\n/// These constants describe the records that describe statements\n/// or expressions. These records  occur within type and declarations\n/// block, so they begin with record values of 128.  Each constant\n/// describes a record for a specific statement or expression class in the\n/// AST.\nenum StmtCode {\n  /// A marker record that indicates that we are at the end\n  /// of an expression.\n  STMT_STOP = DECL_LAST + 1,\n\n  /// A NULL expression.\n  STMT_NULL_PTR,\n\n  /// A reference to a previously [de]serialized Stmt record.\n  STMT_REF_PTR,\n\n  /// A NullStmt record.\n  STMT_NULL,\n\n  /// A CompoundStmt record.\n  STMT_COMPOUND,\n\n  /// A CaseStmt record.\n  STMT_CASE,\n\n  /// A DefaultStmt record.\n  STMT_DEFAULT,\n\n  /// A LabelStmt record.\n  STMT_LABEL,\n\n  /// An AttributedStmt record.\n  STMT_ATTRIBUTED,\n\n  /// An IfStmt record.\n  STMT_IF,\n\n  /// A SwitchStmt record.\n  STMT_SWITCH,\n\n  /// A WhileStmt record.\n  STMT_WHILE,\n\n  /// A DoStmt record.\n  STMT_DO,\n\n  /// A ForStmt record.\n  STMT_FOR,\n\n  /// A GotoStmt record.\n  STMT_GOTO,\n\n  /// An IndirectGotoStmt record.\n  STMT_INDIRECT_GOTO,\n\n  /// A ContinueStmt record.\n  STMT_CONTINUE,\n\n  /// A BreakStmt record.\n  STMT_BREAK,\n\n  /// A ReturnStmt record.\n  STMT_RETURN,\n\n  /// A DeclStmt record.\n  STMT_DECL,\n\n  /// A CapturedStmt record.\n  STMT_CAPTURED,\n\n  /// A GCC-style AsmStmt record.\n  STMT_GCCASM,\n\n  /// A MS-style AsmStmt record.\n  STMT_MSASM,\n\n  /// A constant expression context.\n  EXPR_CONSTANT,\n\n  /// A PredefinedExpr record.\n  EXPR_PREDEFINED,\n\n  /// A DeclRefExpr record.\n  EXPR_DECL_REF,\n\n  /// An IntegerLiteral record.\n  EXPR_INTEGER_LITERAL,\n\n  /// A FloatingLiteral record.\n  EXPR_FLOATING_LITERAL,\n\n  /// An ImaginaryLiteral record.\n  EXPR_IMAGINARY_LITERAL,\n\n  /// A StringLiteral record.\n  EXPR_STRING_LITERAL,\n\n  /// A CharacterLiteral record.\n  EXPR_CHARACTER_LITERAL,\n\n  /// A ParenExpr record.\n  EXPR_PAREN,\n\n  /// A ParenListExpr record.\n  EXPR_PAREN_LIST,\n\n  /// A UnaryOperator record.\n  EXPR_UNARY_OPERATOR,\n\n  /// An OffsetOfExpr record.\n  EXPR_OFFSETOF,\n\n  /// A SizefAlignOfExpr record.\n  EXPR_SIZEOF_ALIGN_OF,\n\n  /// An ArraySubscriptExpr record.\n  EXPR_ARRAY_SUBSCRIPT,\n\n  /// An MatrixSubscriptExpr record.\n  EXPR_MATRIX_SUBSCRIPT,\n\n  /// A CallExpr record.\n  EXPR_CALL,\n\n  /// A MemberExpr record.\n  EXPR_MEMBER,\n\n  /// A BinaryOperator record.\n  EXPR_BINARY_OPERATOR,\n\n  /// A CompoundAssignOperator record.\n  EXPR_COMPOUND_ASSIGN_OPERATOR,\n\n  /// A ConditionOperator record.\n  EXPR_CONDITIONAL_OPERATOR,\n\n  /// An ImplicitCastExpr record.\n  EXPR_IMPLICIT_CAST,\n\n  /// A CStyleCastExpr record.\n  EXPR_CSTYLE_CAST,\n\n  /// A CompoundLiteralExpr record.\n  EXPR_COMPOUND_LITERAL,\n\n  /// An ExtVectorElementExpr record.\n  EXPR_EXT_VECTOR_ELEMENT,\n\n  /// An InitListExpr record.\n  EXPR_INIT_LIST,\n\n  /// A DesignatedInitExpr record.\n  EXPR_DESIGNATED_INIT,\n\n  /// A DesignatedInitUpdateExpr record.\n  EXPR_DESIGNATED_INIT_UPDATE,\n\n  /// An NoInitExpr record.\n  EXPR_NO_INIT,\n\n  /// An ArrayInitLoopExpr record.\n  EXPR_ARRAY_INIT_LOOP,\n\n  /// An ArrayInitIndexExpr record.\n  EXPR_ARRAY_INIT_INDEX,\n\n  /// An ImplicitValueInitExpr record.\n  EXPR_IMPLICIT_VALUE_INIT,\n\n  /// A VAArgExpr record.\n  EXPR_VA_ARG,\n\n  /// An AddrLabelExpr record.\n  EXPR_ADDR_LABEL,\n\n  /// A StmtExpr record.\n  EXPR_STMT,\n\n  /// A ChooseExpr record.\n  EXPR_CHOOSE,\n\n  /// A GNUNullExpr record.\n  EXPR_GNU_NULL,\n\n  /// A SourceLocExpr record.\n  EXPR_SOURCE_LOC,\n\n  /// A ShuffleVectorExpr record.\n  EXPR_SHUFFLE_VECTOR,\n\n  /// A ConvertVectorExpr record.\n  EXPR_CONVERT_VECTOR,\n\n  /// BlockExpr\n  EXPR_BLOCK,\n\n  /// A GenericSelectionExpr record.\n  EXPR_GENERIC_SELECTION,\n\n  /// A PseudoObjectExpr record.\n  EXPR_PSEUDO_OBJECT,\n\n  /// An AtomicExpr record.\n  EXPR_ATOMIC,\n\n  /// A RecoveryExpr record.\n  EXPR_RECOVERY,\n\n  // Objective-C\n\n  /// An ObjCStringLiteral record.\n  EXPR_OBJC_STRING_LITERAL,\n\n  EXPR_OBJC_BOXED_EXPRESSION,\n  EXPR_OBJC_ARRAY_LITERAL,\n  EXPR_OBJC_DICTIONARY_LITERAL,\n\n  /// An ObjCEncodeExpr record.\n  EXPR_OBJC_ENCODE,\n\n  /// An ObjCSelectorExpr record.\n  EXPR_OBJC_SELECTOR_EXPR,\n\n  /// An ObjCProtocolExpr record.\n  EXPR_OBJC_PROTOCOL_EXPR,\n\n  /// An ObjCIvarRefExpr record.\n  EXPR_OBJC_IVAR_REF_EXPR,\n\n  /// An ObjCPropertyRefExpr record.\n  EXPR_OBJC_PROPERTY_REF_EXPR,\n\n  /// An ObjCSubscriptRefExpr record.\n  EXPR_OBJC_SUBSCRIPT_REF_EXPR,\n\n  /// UNUSED\n  EXPR_OBJC_KVC_REF_EXPR,\n\n  /// An ObjCMessageExpr record.\n  EXPR_OBJC_MESSAGE_EXPR,\n\n  /// An ObjCIsa Expr record.\n  EXPR_OBJC_ISA,\n\n  /// An ObjCIndirectCopyRestoreExpr record.\n  EXPR_OBJC_INDIRECT_COPY_RESTORE,\n\n  /// An ObjCForCollectionStmt record.\n  STMT_OBJC_FOR_COLLECTION,\n\n  /// An ObjCAtCatchStmt record.\n  STMT_OBJC_CATCH,\n\n  /// An ObjCAtFinallyStmt record.\n  STMT_OBJC_FINALLY,\n\n  /// An ObjCAtTryStmt record.\n  STMT_OBJC_AT_TRY,\n\n  /// An ObjCAtSynchronizedStmt record.\n  STMT_OBJC_AT_SYNCHRONIZED,\n\n  /// An ObjCAtThrowStmt record.\n  STMT_OBJC_AT_THROW,\n\n  /// An ObjCAutoreleasePoolStmt record.\n  STMT_OBJC_AUTORELEASE_POOL,\n\n  /// An ObjCBoolLiteralExpr record.\n  EXPR_OBJC_BOOL_LITERAL,\n\n  /// An ObjCAvailabilityCheckExpr record.\n  EXPR_OBJC_AVAILABILITY_CHECK,\n\n  // C++\n\n  /// A CXXCatchStmt record.\n  STMT_CXX_CATCH,\n\n  /// A CXXTryStmt record.\n  STMT_CXX_TRY,\n  /// A CXXForRangeStmt record.\n\n  STMT_CXX_FOR_RANGE,\n\n  /// A CXXOperatorCallExpr record.\n  EXPR_CXX_OPERATOR_CALL,\n\n  /// A CXXMemberCallExpr record.\n  EXPR_CXX_MEMBER_CALL,\n\n  /// A CXXRewrittenBinaryOperator record.\n  EXPR_CXX_REWRITTEN_BINARY_OPERATOR,\n\n  /// A CXXConstructExpr record.\n  EXPR_CXX_CONSTRUCT,\n\n  /// A CXXInheritedCtorInitExpr record.\n  EXPR_CXX_INHERITED_CTOR_INIT,\n\n  /// A CXXTemporaryObjectExpr record.\n  EXPR_CXX_TEMPORARY_OBJECT,\n\n  /// A CXXStaticCastExpr record.\n  EXPR_CXX_STATIC_CAST,\n\n  /// A CXXDynamicCastExpr record.\n  EXPR_CXX_DYNAMIC_CAST,\n\n  /// A CXXReinterpretCastExpr record.\n  EXPR_CXX_REINTERPRET_CAST,\n\n  /// A CXXConstCastExpr record.\n  EXPR_CXX_CONST_CAST,\n\n  /// A CXXAddrspaceCastExpr record.\n  EXPR_CXX_ADDRSPACE_CAST,\n\n  /// A CXXFunctionalCastExpr record.\n  EXPR_CXX_FUNCTIONAL_CAST,\n\n  /// A BuiltinBitCastExpr record.\n  EXPR_BUILTIN_BIT_CAST,\n\n  /// A UserDefinedLiteral record.\n  EXPR_USER_DEFINED_LITERAL,\n\n  /// A CXXStdInitializerListExpr record.\n  EXPR_CXX_STD_INITIALIZER_LIST,\n\n  /// A CXXBoolLiteralExpr record.\n  EXPR_CXX_BOOL_LITERAL,\n\n  EXPR_CXX_NULL_PTR_LITERAL, // CXXNullPtrLiteralExpr\n  EXPR_CXX_TYPEID_EXPR,      // CXXTypeidExpr (of expr).\n  EXPR_CXX_TYPEID_TYPE,      // CXXTypeidExpr (of type).\n  EXPR_CXX_THIS,             // CXXThisExpr\n  EXPR_CXX_THROW,            // CXXThrowExpr\n  EXPR_CXX_DEFAULT_ARG,      // CXXDefaultArgExpr\n  EXPR_CXX_DEFAULT_INIT,     // CXXDefaultInitExpr\n  EXPR_CXX_BIND_TEMPORARY,   // CXXBindTemporaryExpr\n\n  EXPR_CXX_SCALAR_VALUE_INIT, // CXXScalarValueInitExpr\n  EXPR_CXX_NEW,               // CXXNewExpr\n  EXPR_CXX_DELETE,            // CXXDeleteExpr\n  EXPR_CXX_PSEUDO_DESTRUCTOR, // CXXPseudoDestructorExpr\n\n  EXPR_EXPR_WITH_CLEANUPS, // ExprWithCleanups\n\n  EXPR_CXX_DEPENDENT_SCOPE_MEMBER,   // CXXDependentScopeMemberExpr\n  EXPR_CXX_DEPENDENT_SCOPE_DECL_REF, // DependentScopeDeclRefExpr\n  EXPR_CXX_UNRESOLVED_CONSTRUCT,     // CXXUnresolvedConstructExpr\n  EXPR_CXX_UNRESOLVED_MEMBER,        // UnresolvedMemberExpr\n  EXPR_CXX_UNRESOLVED_LOOKUP,        // UnresolvedLookupExpr\n\n  EXPR_CXX_EXPRESSION_TRAIT, // ExpressionTraitExpr\n  EXPR_CXX_NOEXCEPT,         // CXXNoexceptExpr\n\n  EXPR_OPAQUE_VALUE,                // OpaqueValueExpr\n  EXPR_BINARY_CONDITIONAL_OPERATOR, // BinaryConditionalOperator\n  EXPR_TYPE_TRAIT,                  // TypeTraitExpr\n  EXPR_ARRAY_TYPE_TRAIT,            // ArrayTypeTraitIntExpr\n\n  EXPR_PACK_EXPANSION,                    // PackExpansionExpr\n  EXPR_SIZEOF_PACK,                       // SizeOfPackExpr\n  EXPR_SUBST_NON_TYPE_TEMPLATE_PARM,      // SubstNonTypeTemplateParmExpr\n  EXPR_SUBST_NON_TYPE_TEMPLATE_PARM_PACK, // SubstNonTypeTemplateParmPackExpr\n  EXPR_FUNCTION_PARM_PACK,                // FunctionParmPackExpr\n  EXPR_MATERIALIZE_TEMPORARY,             // MaterializeTemporaryExpr\n  EXPR_CXX_FOLD,                          // CXXFoldExpr\n  EXPR_CONCEPT_SPECIALIZATION,            // ConceptSpecializationExpr\n  EXPR_REQUIRES,                          // RequiresExpr\n\n  // CUDA\n  EXPR_CUDA_KERNEL_CALL, // CUDAKernelCallExpr\n\n  // OpenCL\n  EXPR_ASTYPE, // AsTypeExpr\n\n  // Microsoft\n  EXPR_CXX_PROPERTY_REF_EXPR,       // MSPropertyRefExpr\n  EXPR_CXX_PROPERTY_SUBSCRIPT_EXPR, // MSPropertySubscriptExpr\n  EXPR_CXX_UUIDOF_EXPR,             // CXXUuidofExpr (of expr).\n  EXPR_CXX_UUIDOF_TYPE,             // CXXUuidofExpr (of type).\n  STMT_SEH_LEAVE,                   // SEHLeaveStmt\n  STMT_SEH_EXCEPT,                  // SEHExceptStmt\n  STMT_SEH_FINALLY,                 // SEHFinallyStmt\n  STMT_SEH_TRY,                     // SEHTryStmt\n\n  // OpenMP directives\n  STMT_OMP_CANONICAL_LOOP,\n  STMT_OMP_PARALLEL_DIRECTIVE,\n  STMT_OMP_SIMD_DIRECTIVE,\n  STMT_OMP_TILE_DIRECTIVE,\n  STMT_OMP_FOR_DIRECTIVE,\n  STMT_OMP_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_SECTIONS_DIRECTIVE,\n  STMT_OMP_SECTION_DIRECTIVE,\n  STMT_OMP_SINGLE_DIRECTIVE,\n  STMT_OMP_MASTER_DIRECTIVE,\n  STMT_OMP_CRITICAL_DIRECTIVE,\n  STMT_OMP_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_DIRECTIVE,\n  STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE,\n  STMT_OMP_TASK_DIRECTIVE,\n  STMT_OMP_TASKYIELD_DIRECTIVE,\n  STMT_OMP_BARRIER_DIRECTIVE,\n  STMT_OMP_TASKWAIT_DIRECTIVE,\n  STMT_OMP_FLUSH_DIRECTIVE,\n  STMT_OMP_DEPOBJ_DIRECTIVE,\n  STMT_OMP_SCAN_DIRECTIVE,\n  STMT_OMP_ORDERED_DIRECTIVE,\n  STMT_OMP_ATOMIC_DIRECTIVE,\n  STMT_OMP_TARGET_DIRECTIVE,\n  STMT_OMP_TARGET_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_ENTER_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_EXIT_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TEAMS_DIRECTIVE,\n  STMT_OMP_TASKGROUP_DIRECTIVE,\n  STMT_OMP_CANCELLATION_POINT_DIRECTIVE,\n  STMT_OMP_CANCEL_DIRECTIVE,\n  STMT_OMP_TASKLOOP_DIRECTIVE,\n  STMT_OMP_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_MASTER_TASKLOOP_DIRECTIVE,\n  STMT_OMP_MASTER_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_TASKLOOP_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TARGET_UPDATE_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,\n  EXPR_OMP_ARRAY_SECTION,\n  EXPR_OMP_ARRAY_SHAPING,\n  EXPR_OMP_ITERATOR,\n\n  // ARC\n  EXPR_OBJC_BRIDGED_CAST, // ObjCBridgedCastExpr\n\n  STMT_MS_DEPENDENT_EXISTS, // MSDependentExistsStmt\n  EXPR_LAMBDA,              // LambdaExpr\n  STMT_COROUTINE_BODY,\n  STMT_CORETURN,\n  EXPR_COAWAIT,\n  EXPR_COYIELD,\n  EXPR_DEPENDENT_COAWAIT,\n\n  // FixedPointLiteral\n  EXPR_FIXEDPOINT_LITERAL,\n};\n\n/// The kinds of designators that can occur in a\n/// DesignatedInitExpr.\nenum DesignatorTypes {\n  /// Field designator where only the field name is known.\n  DESIG_FIELD_NAME = 0,\n\n  /// Field designator where the field has been resolved to\n  /// a declaration.\n  DESIG_FIELD_DECL = 1,\n\n  /// Array designator.\n  DESIG_ARRAY = 2,\n\n  /// GNU array range designator.\n  DESIG_ARRAY_RANGE = 3\n};\n\n/// The different kinds of data that can occur in a\n/// CtorInitializer.\nenum CtorInitializerType {\n  CTOR_INITIALIZER_BASE,\n  CTOR_INITIALIZER_DELEGATING,\n  CTOR_INITIALIZER_MEMBER,\n  CTOR_INITIALIZER_INDIRECT_MEMBER\n};\n\n/// Kinds of cleanup objects owned by ExprWithCleanups.\nenum CleanupObjectKind { COK_Block, COK_CompoundLiteral };\n\n/// Describes the redeclarations of a declaration.\nstruct LocalRedeclarationsInfo {\n  // The ID of the first declaration\n  DeclID FirstID;\n\n  // Offset into the array of redeclaration chains.\n  unsigned Offset;\n\n  friend bool operator<(const LocalRedeclarationsInfo &X,\n                        const LocalRedeclarationsInfo &Y) {\n    return X.FirstID < Y.FirstID;\n  }\n\n  friend bool operator>(const LocalRedeclarationsInfo &X,\n                        const LocalRedeclarationsInfo &Y) {\n    return X.FirstID > Y.FirstID;\n  }\n\n  friend bool operator<=(const LocalRedeclarationsInfo &X,\n                         const LocalRedeclarationsInfo &Y) {\n    return X.FirstID <= Y.FirstID;\n  }\n\n  friend bool operator>=(const LocalRedeclarationsInfo &X,\n                         const LocalRedeclarationsInfo &Y) {\n    return X.FirstID >= Y.FirstID;\n  }\n};\n\n/// Describes the categories of an Objective-C class.\nstruct ObjCCategoriesInfo {\n  // The ID of the definition\n  DeclID DefinitionID;\n\n  // Offset into the array of category lists.\n  unsigned Offset;\n\n  friend bool operator<(const ObjCCategoriesInfo &X,\n                        const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID < Y.DefinitionID;\n  }\n\n  friend bool operator>(const ObjCCategoriesInfo &X,\n                        const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID > Y.DefinitionID;\n  }\n\n  friend bool operator<=(const ObjCCategoriesInfo &X,\n                         const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID <= Y.DefinitionID;\n  }\n\n  friend bool operator>=(const ObjCCategoriesInfo &X,\n                         const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID >= Y.DefinitionID;\n  }\n};\n\n/// A key used when looking up entities by \\ref DeclarationName.\n///\n/// Different \\ref DeclarationNames are mapped to different keys, but the\n/// same key can occasionally represent multiple names (for names that\n/// contain types, in particular).\nclass DeclarationNameKey {\n  using NameKind = unsigned;\n\n  NameKind Kind = 0;\n  uint64_t Data = 0;\n\npublic:\n  DeclarationNameKey() = default;\n  DeclarationNameKey(DeclarationName Name);\n  DeclarationNameKey(NameKind Kind, uint64_t Data) : Kind(Kind), Data(Data) {}\n\n  NameKind getKind() const { return Kind; }\n\n  IdentifierInfo *getIdentifier() const {\n    assert(Kind == DeclarationName::Identifier ||\n           Kind == DeclarationName::CXXLiteralOperatorName ||\n           Kind == DeclarationName::CXXDeductionGuideName);\n    return (IdentifierInfo *)Data;\n  }\n\n  Selector getSelector() const {\n    assert(Kind == DeclarationName::ObjCZeroArgSelector ||\n           Kind == DeclarationName::ObjCOneArgSelector ||\n           Kind == DeclarationName::ObjCMultiArgSelector);\n    return Selector(Data);\n  }\n\n  OverloadedOperatorKind getOperatorKind() const {\n    assert(Kind == DeclarationName::CXXOperatorName);\n    return (OverloadedOperatorKind)Data;\n  }\n\n  /// Compute a fingerprint of this key for use in on-disk hash table.\n  unsigned getHash() const;\n\n  friend bool operator==(const DeclarationNameKey &A,\n                         const DeclarationNameKey &B) {\n    return A.Kind == B.Kind && A.Data == B.Data;\n  }\n};\n\n/// @}\n\n} // namespace serialization\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <> struct DenseMapInfo<clang::serialization::DeclarationNameKey> {\n  static clang::serialization::DeclarationNameKey getEmptyKey() {\n    return clang::serialization::DeclarationNameKey(-1, 1);\n  }\n\n  static clang::serialization::DeclarationNameKey getTombstoneKey() {\n    return clang::serialization::DeclarationNameKey(-1, 2);\n  }\n\n  static unsigned\n  getHashValue(const clang::serialization::DeclarationNameKey &Key) {\n    return Key.getHash();\n  }\n\n  static bool isEqual(const clang::serialization::DeclarationNameKey &L,\n                      const clang::serialization::DeclarationNameKey &R) {\n    return L == R;\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "content": "//===- Tree.h - structure of the syntax tree ------------------*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Defines the basic structure of the syntax tree. There are two kinds of nodes:\n//   - leaf nodes correspond to a token in the expanded token stream,\n//   - tree nodes correspond to language grammar constructs.\n//\n// The tree is initially built from an AST. Each node of a newly built tree\n// covers a continous subrange of expanded tokens (i.e. tokens after\n// preprocessing), the specific tokens coverered are stored in the leaf nodes of\n// a tree. A post-order traversal of a tree will visit leaf nodes in an order\n// corresponding the original order of expanded tokens.\n//\n// This is still work in progress and highly experimental, we leave room for\n// ourselves to completely change the design and/or implementation.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n#define LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\nnamespace syntax {\n\n/// A memory arena for syntax trees. Also tracks the underlying token buffers,\n/// source manager, etc.\nclass Arena {\npublic:\n  Arena(SourceManager &SourceMgr, const LangOptions &LangOpts,\n        const TokenBuffer &Tokens);\n\n  const SourceManager &getSourceManager() const { return SourceMgr; }\n  const LangOptions &getLangOptions() const { return LangOpts; }\n\n  const TokenBuffer &getTokenBuffer() const;\n  llvm::BumpPtrAllocator &getAllocator() { return Allocator; }\n\nprivate:\n  /// Add \\p Buffer to the underlying source manager, tokenize it and store the\n  /// resulting tokens. Used exclusively in `FactoryImpl` to materialize tokens\n  /// that were not written in user code.\n  std::pair<FileID, ArrayRef<Token>>\n  lexBuffer(std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  friend class FactoryImpl;\n\nprivate:\n  SourceManager &SourceMgr;\n  const LangOptions &LangOpts;\n  const TokenBuffer &Tokens;\n  /// IDs and storage for additional tokenized files.\n  llvm::DenseMap<FileID, std::vector<Token>> ExtraTokens;\n  /// Keeps all the allocated nodes and their intermediate data structures.\n  llvm::BumpPtrAllocator Allocator;\n};\n\nclass Tree;\nclass TreeBuilder;\nclass FactoryImpl;\nclass MutationsImpl;\n\nenum class NodeKind : uint16_t;\nenum class NodeRole : uint8_t;\n\n/// A node in a syntax tree. Each node is either a Leaf (representing tokens) or\n/// a Tree (representing language constructrs).\nclass Node {\nprotected:\n  /// Newly created nodes are detached from a tree, parent and sibling links are\n  /// set when the node is added as a child to another one.\n  Node(NodeKind Kind);\n  /// Nodes are allocated on Arenas; the destructor is never called.\n  ~Node() = default;\n\npublic:\n  /// Nodes cannot simply be copied without violating tree invariants.\n  Node(const Node &) = delete;\n  Node &operator=(const Node &) = delete;\n  /// Idiomatically, nodes are allocated on an Arena and never moved.\n  Node(Node &&) = delete;\n  Node &operator=(Node &&) = delete;\n\n  NodeKind getKind() const { return static_cast<NodeKind>(Kind); }\n  NodeRole getRole() const { return static_cast<NodeRole>(Role); }\n\n  /// Whether the node is detached from a tree, i.e. does not have a parent.\n  bool isDetached() const;\n  /// Whether the node was created from the AST backed by the source code\n  /// rather than added later through mutation APIs or created with factory\n  /// functions.\n  /// When this flag is true, all subtrees are also original.\n  /// This flag is set to false on any modifications to the node or any of its\n  /// subtrees, even if this simply involves swapping existing subtrees.\n  bool isOriginal() const { return Original; }\n  /// If this function return false, the tree cannot be modified because there\n  /// is no reasonable way to produce the corresponding textual replacements.\n  /// This can happen when the node crosses macro expansion boundaries.\n  ///\n  /// Note that even if the node is not modifiable, its child nodes can be\n  /// modifiable.\n  bool canModify() const { return CanModify; }\n\n  const Tree *getParent() const { return Parent; }\n  Tree *getParent() { return Parent; }\n\n  const Node *getNextSibling() const { return NextSibling; }\n  Node *getNextSibling() { return NextSibling; }\n  const Node *getPreviousSibling() const { return PreviousSibling; }\n  Node *getPreviousSibling() { return PreviousSibling; }\n\n  /// Dumps the structure of a subtree. For debugging and testing purposes.\n  std::string dump(const SourceManager &SM) const;\n  /// Dumps the tokens forming this subtree.\n  std::string dumpTokens(const SourceManager &SM) const;\n\n  /// Asserts invariants on this node of the tree and its immediate children.\n  /// Will not recurse into the subtree. No-op if NDEBUG is set.\n  void assertInvariants() const;\n  /// Runs checkInvariants on all nodes in the subtree. No-op if NDEBUG is set.\n  void assertInvariantsRecursive() const;\n\nprivate:\n  // Tree is allowed to change the Parent link and Role.\n  friend class Tree;\n  // TreeBuilder is allowed to set the Original and CanModify flags.\n  friend class TreeBuilder;\n  // MutationsImpl sets roles and CanModify flag.\n  friend class MutationsImpl;\n  // FactoryImpl sets CanModify flag.\n  friend class FactoryImpl;\n\n  void setRole(NodeRole NR);\n\n  Tree *Parent;\n  Node *NextSibling;\n  Node *PreviousSibling;\n  unsigned Kind : 16;\n  unsigned Role : 8;\n  unsigned Original : 1;\n  unsigned CanModify : 1;\n};\n\n/// A leaf node points to a single token inside the expanded token stream.\nclass Leaf final : public Node {\npublic:\n  Leaf(const Token *T);\n  static bool classof(const Node *N);\n\n  const Token *getToken() const { return Tok; }\n\nprivate:\n  const Token *Tok;\n};\n\n/// A node that has children and represents a syntactic language construct.\nclass Tree : public Node {\n  /// Iterator over children (common base for const/non-const).\n  /// Not invalidated by tree mutations (holds a stable node pointer).\n  template <typename DerivedT, typename NodeT>\n  class ChildIteratorBase\n      : public llvm::iterator_facade_base<DerivedT, std::forward_iterator_tag,\n                                          NodeT> {\n  protected:\n    NodeT *N = nullptr;\n    using Base = ChildIteratorBase;\n\n  public:\n    ChildIteratorBase() = default;\n    explicit ChildIteratorBase(NodeT *N) : N(N) {}\n\n    bool operator==(const DerivedT &O) const { return O.N == N; }\n    NodeT &operator*() const { return *N; }\n    DerivedT &operator++() {\n      N = N->getNextSibling();\n      return *static_cast<DerivedT *>(this);\n    }\n\n    /// Truthy if valid (not past-the-end).\n    /// This allows: if (auto It = find_if(N.children(), ...) )\n    explicit operator bool() const { return N != nullptr; }\n    /// The element, or nullptr if past-the-end.\n    NodeT *asPointer() const { return N; }\n  };\n\npublic:\n  static bool classof(const Node *N);\n\n  Node *getFirstChild() { return FirstChild; }\n  const Node *getFirstChild() const { return FirstChild; }\n  Node *getLastChild() { return LastChild; }\n  const Node *getLastChild() const { return LastChild; }\n\n  const Leaf *findFirstLeaf() const;\n  Leaf *findFirstLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findFirstLeaf());\n  }\n\n  const Leaf *findLastLeaf() const;\n  Leaf *findLastLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findLastLeaf());\n  }\n\n  /// child_iterator is not invalidated by mutations.\n  struct ChildIterator : ChildIteratorBase<ChildIterator, Node> {\n    using Base::ChildIteratorBase;\n  };\n  struct ConstChildIterator\n      : ChildIteratorBase<ConstChildIterator, const Node> {\n    using Base::ChildIteratorBase;\n    ConstChildIterator() = default;\n    ConstChildIterator(const ChildIterator &I) : Base(I.asPointer()) {}\n  };\n\n  llvm::iterator_range<ChildIterator> getChildren() {\n    return {ChildIterator(getFirstChild()), ChildIterator()};\n  }\n  llvm::iterator_range<ConstChildIterator> getChildren() const {\n    return {ConstChildIterator(getFirstChild()), ConstChildIterator()};\n  }\n\n  /// Find the first node with a corresponding role.\n  const Node *findChild(NodeRole R) const;\n  Node *findChild(NodeRole R) {\n    return const_cast<Node *>(const_cast<const Tree *>(this)->findChild(R));\n  }\n\nprotected:\n  using Node::Node;\n\nprivate:\n  /// Append \\p Child to the list of children and sets the parent pointer.\n  /// A very low-level operation that does not check any invariants, only used\n  /// by TreeBuilder and FactoryImpl.\n  /// EXPECTS: Role != Detached.\n  void appendChildLowLevel(Node *Child, NodeRole Role);\n  /// Similar but prepends.\n  void prependChildLowLevel(Node *Child, NodeRole Role);\n\n  /// Like the previous overloads, but does not set role for \\p Child.\n  /// EXPECTS: Child->Role != Detached\n  void appendChildLowLevel(Node *Child);\n  void prependChildLowLevel(Node *Child);\n  friend class TreeBuilder;\n  friend class FactoryImpl;\n\n  /// Replace a range of children [Begin, End) with a list of\n  /// new nodes starting at \\p New.\n  /// Only used by MutationsImpl to implement higher-level mutation operations.\n  /// (!) \\p New can be null to model removal of the child range.\n  /// (!) \\p End can be null to model one past the end.\n  /// (!) \\p Begin can be null to model an append.\n  void replaceChildRangeLowLevel(Node *Begin, Node *End, Node *New);\n  friend class MutationsImpl;\n\n  Node *FirstChild = nullptr;\n  Node *LastChild = nullptr;\n};\n\n// Provide missing non_const == const overload.\n// iterator_facade_base requires == to be a member, but implicit conversions\n// don't work on the LHS of a member operator.\ninline bool operator==(const Tree::ConstChildIterator &A,\n                       const Tree::ConstChildIterator &B) {\n  return A.operator==(B);\n}\n\n/// A list of Elements separated or terminated by a fixed token.\n///\n/// This type models the following grammar construct:\n/// delimited-list(element, delimiter, termination, canBeEmpty)\nclass List : public Tree {\npublic:\n  template <typename Element> struct ElementAndDelimiter {\n    Element *element;\n    Leaf *delimiter;\n  };\n\n  enum class TerminationKind {\n    Terminated,\n    MaybeTerminated,\n    Separated,\n  };\n\n  using Tree::Tree;\n  static bool classof(const Node *N);\n  /// Returns the elements and corresponding delimiters. Missing elements\n  /// and delimiters are represented as null pointers.\n  ///\n  /// For example, in a separated list:\n  /// \"a, b, c\"  <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (\"c\" , null)]\n  /// \"a,  , c\"  <=> [(\"a\" , \",\"), (null, \",\" ), (\"c\" , null)]\n  /// \"a, b  c\"  <=> [(\"a\" , \",\"), (\"b\" , null), (\"c\" , null)]\n  /// \"a, b,\"    <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (null, null)]\n  ///\n  /// In a terminated or maybe-terminated list:\n  /// \"a; b; c;\" <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , \";\" )]\n  /// \"a;  ; c;\" <=> [(\"a\" , \";\"), (null, \";\" ), (\"c\" , \";\" )]\n  /// \"a; b  c;\" <=> [(\"a\" , \";\"), (\"b\" , null), (\"c\" , \";\" )]\n  /// \"a; b; c\"  <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , null)]\n  std::vector<ElementAndDelimiter<Node>> getElementsAsNodesAndDelimiters();\n\n  /// Returns the elements of the list. Missing elements are represented\n  /// as null pointers in the same way as in the return value of\n  /// `getElementsAsNodesAndDelimiters()`.\n  std::vector<Node *> getElementsAsNodes();\n\n  // These can't be implemented with the information we have!\n\n  /// Returns the appropriate delimiter for this list.\n  ///\n  /// Useful for discovering the correct delimiter to use when adding\n  /// elements to empty or one-element lists.\n  clang::tok::TokenKind getDelimiterTokenKind() const;\n\n  TerminationKind getTerminationKind() const;\n\n  /// Whether this list can be empty in syntactically and semantically correct\n  /// code.\n  ///\n  /// This list may be empty when the source code has errors even if\n  /// canBeEmpty() returns false.\n  bool canBeEmpty() const;\n};\n\n} // namespace syntax\n} // namespace clang\n\n#endif\n"}, "67": {"id": 67, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "content": "//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the fixed point number interface.\n/// This is a class for abstracting various operations performed on fixed point\n/// types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFIXEDPOINT_H\n#define LLVM_ADT_APFIXEDPOINT_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nclass APFloat;\nstruct fltSemantics;\n\n/// The fixed point semantics work similarly to fltSemantics. The width\n/// specifies the whole bit width of the underlying scaled integer (with padding\n/// if any). The scale represents the number of fractional bits in this type.\n/// When HasUnsignedPadding is true and this type is unsigned, the first bit\n/// in the value this represents is treated as padding.\nclass FixedPointSemantics {\npublic:\n  FixedPointSemantics(unsigned Width, unsigned Scale, bool IsSigned,\n                      bool IsSaturated, bool HasUnsignedPadding)\n      : Width(Width), Scale(Scale), IsSigned(IsSigned),\n        IsSaturated(IsSaturated), HasUnsignedPadding(HasUnsignedPadding) {\n    assert(Width >= Scale && \"Not enough room for the scale\");\n    assert(!(IsSigned && HasUnsignedPadding) &&\n           \"Cannot have unsigned padding on a signed type.\");\n  }\n\n  unsigned getWidth() const { return Width; }\n  unsigned getScale() const { return Scale; }\n  bool isSigned() const { return IsSigned; }\n  bool isSaturated() const { return IsSaturated; }\n  bool hasUnsignedPadding() const { return HasUnsignedPadding; }\n\n  void setSaturated(bool Saturated) { IsSaturated = Saturated; }\n\n  /// Return the number of integral bits represented by these semantics. These\n  /// are separate from the fractional bits and do not include the sign or\n  /// padding bit.\n  unsigned getIntegralBits() const {\n    if (IsSigned || (!IsSigned && HasUnsignedPadding))\n      return Width - Scale - 1;\n    else\n      return Width - Scale;\n  }\n\n  /// Return the FixedPointSemantics that allows for calculating the full\n  /// precision semantic that can precisely represent the precision and ranges\n  /// of both input values. This does not compute the resulting semantics for a\n  /// given binary operation.\n  FixedPointSemantics\n  getCommonSemantics(const FixedPointSemantics &Other) const;\n\n  /// Returns true if this fixed-point semantic with its value bits interpreted\n  /// as an integer can fit in the given floating point semantic without\n  /// overflowing to infinity.\n  /// For example, a signed 8-bit fixed-point semantic has a maximum and\n  /// minimum integer representation of 127 and -128, respectively. If both of\n  /// these values can be represented (possibly inexactly) in the floating\n  /// point semantic without overflowing, this returns true.\n  bool fitsInFloatSemantics(const fltSemantics &FloatSema) const;\n\n  /// Return the FixedPointSemantics for an integer type.\n  static FixedPointSemantics GetIntegerSemantics(unsigned Width,\n                                                 bool IsSigned) {\n    return FixedPointSemantics(Width, /*Scale=*/0, IsSigned,\n                               /*IsSaturated=*/false,\n                               /*HasUnsignedPadding=*/false);\n  }\n\nprivate:\n  unsigned Width          : 16;\n  unsigned Scale          : 13;\n  unsigned IsSigned       : 1;\n  unsigned IsSaturated    : 1;\n  unsigned HasUnsignedPadding : 1;\n};\n\n/// The APFixedPoint class works similarly to APInt/APSInt in that it is a\n/// functional replacement for a scaled integer. It is meant to replicate the\n/// fixed point types proposed in ISO/IEC JTC1 SC22 WG14 N1169. The class carries\n/// info about the fixed point type's width, sign, scale, and saturation, and\n/// provides different operations that would normally be performed on fixed point\n/// types.\nclass APFixedPoint {\npublic:\n  APFixedPoint(const APInt &Val, const FixedPointSemantics &Sema)\n      : Val(Val, !Sema.isSigned()), Sema(Sema) {\n    assert(Val.getBitWidth() == Sema.getWidth() &&\n           \"The value should have a bit width that matches the Sema width\");\n  }\n\n  APFixedPoint(uint64_t Val, const FixedPointSemantics &Sema)\n      : APFixedPoint(APInt(Sema.getWidth(), Val, Sema.isSigned()), Sema) {}\n\n  // Zero initialization.\n  APFixedPoint(const FixedPointSemantics &Sema) : APFixedPoint(0, Sema) {}\n\n  APSInt getValue() const { return APSInt(Val, !Sema.isSigned()); }\n  inline unsigned getWidth() const { return Sema.getWidth(); }\n  inline unsigned getScale() const { return Sema.getScale(); }\n  inline bool isSaturated() const { return Sema.isSaturated(); }\n  inline bool isSigned() const { return Sema.isSigned(); }\n  inline bool hasPadding() const { return Sema.hasUnsignedPadding(); }\n  FixedPointSemantics getSemantics() const { return Sema; }\n\n  bool getBoolValue() const { return Val.getBoolValue(); }\n\n  // Convert this number to match the semantics provided. If the overflow\n  // parameter is provided, set this value to true or false to indicate if this\n  // operation results in an overflow.\n  APFixedPoint convert(const FixedPointSemantics &DstSema,\n                       bool *Overflow = nullptr) const;\n\n  // Perform binary operations on a fixed point type. The resulting fixed point\n  // value will be in the common, full precision semantics that can represent\n  // the precision and ranges of both input values. See convert() for an\n  // explanation of the Overflow parameter.\n  APFixedPoint add(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint sub(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint mul(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint div(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n\n  // Perform shift operations on a fixed point type. Unlike the other binary\n  // operations, the resulting fixed point value will be in the original\n  // semantic.\n  APFixedPoint shl(unsigned Amt, bool *Overflow = nullptr) const;\n  APFixedPoint shr(unsigned Amt, bool *Overflow = nullptr) const {\n    // Right shift cannot overflow.\n    if (Overflow)\n      *Overflow = false;\n    return APFixedPoint(Val >> Amt, Sema);\n  }\n\n  /// Perform a unary negation (-X) on this fixed point type, taking into\n  /// account saturation if applicable.\n  APFixedPoint negate(bool *Overflow = nullptr) const;\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. (-2.5k -> -2)\n  APSInt getIntPart() const {\n    if (Val < 0 && Val != -Val) // Cover the case when we have the min val\n      return -(-Val >> getScale());\n    else\n      return Val >> getScale();\n  }\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. The value is stored into an APSInt with the provided width and sign.\n  /// If the overflow parameter is provided, and the integral value is not able\n  /// to be fully stored in the provided width and sign, the overflow parameter\n  /// is set to true.\n  APSInt convertToInt(unsigned DstWidth, bool DstSign,\n                      bool *Overflow = nullptr) const;\n\n  /// Convert this fixed point number to a floating point value with the\n  /// provided semantics.\n  APFloat convertToFloat(const fltSemantics &FloatSema) const;\n\n  void toString(SmallVectorImpl<char> &Str) const;\n  std::string toString() const {\n    SmallString<40> S;\n    toString(S);\n    return std::string(S.str());\n  }\n\n  // If LHS > RHS, return 1. If LHS == RHS, return 0. If LHS < RHS, return -1.\n  int compare(const APFixedPoint &Other) const;\n  bool operator==(const APFixedPoint &Other) const {\n    return compare(Other) == 0;\n  }\n  bool operator!=(const APFixedPoint &Other) const {\n    return compare(Other) != 0;\n  }\n  bool operator>(const APFixedPoint &Other) const { return compare(Other) > 0; }\n  bool operator<(const APFixedPoint &Other) const { return compare(Other) < 0; }\n  bool operator>=(const APFixedPoint &Other) const {\n    return compare(Other) >= 0;\n  }\n  bool operator<=(const APFixedPoint &Other) const {\n    return compare(Other) <= 0;\n  }\n\n  static APFixedPoint getMax(const FixedPointSemantics &Sema);\n  static APFixedPoint getMin(const FixedPointSemantics &Sema);\n\n  /// Given a floating point semantic, return the next floating point semantic\n  /// with a larger exponent and larger or equal mantissa.\n  static const fltSemantics *promoteFloatSemantics(const fltSemantics *S);\n\n  /// Create an APFixedPoint with a value equal to that of the provided integer,\n  /// and in the same semantics as the provided target semantics. If the value\n  /// is not able to fit in the specified fixed point semantics, and the\n  /// overflow parameter is provided, it is set to true.\n  static APFixedPoint getFromIntValue(const APSInt &Value,\n                                      const FixedPointSemantics &DstFXSema,\n                                      bool *Overflow = nullptr);\n\n  /// Create an APFixedPoint with a value equal to that of the provided\n  /// floating point value, in the provided target semantics. If the value is\n  /// not able to fit in the specified fixed point semantics and the overflow\n  /// parameter is specified, it is set to true.\n  /// For NaN, the Overflow flag is always set. For +inf and -inf, if the\n  /// semantic is saturating, the value saturates. Otherwise, the Overflow flag\n  /// is set.\n  static APFixedPoint getFromFloatValue(const APFloat &Value,\n                                        const FixedPointSemantics &DstFXSema,\n                                        bool *Overflow = nullptr);\n\nprivate:\n  APSInt Val;\n  FixedPointSemantics Sema;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APFixedPoint &FX) {\n  OS << FX.toString();\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "content": "//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief\n/// This file declares a class to represent arbitrary precision floating point\n/// values and provide a variety of arithmetic operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFLOAT_H\n#define LLVM_ADT_APFLOAT_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <memory>\n\n#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \\\n  do {                                                                         \\\n    if (usesLayout<IEEEFloat>(getSemantics()))                                 \\\n      return U.IEEE.METHOD_CALL;                                               \\\n    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \\\n      return U.Double.METHOD_CALL;                                             \\\n    llvm_unreachable(\"Unexpected semantics\");                                  \\\n  } while (false)\n\nnamespace llvm {\n\nstruct fltSemantics;\nclass APSInt;\nclass StringRef;\nclass APFloat;\nclass raw_ostream;\n\ntemplate <typename T> class Expected;\ntemplate <typename T> class SmallVectorImpl;\n\n/// Enum that represents what fraction of the LSB truncated bits of an fp number\n/// represent.\n///\n/// This essentially combines the roles of guard and sticky bits.\nenum lostFraction { // Example of truncated bits:\n  lfExactlyZero,    // 000000\n  lfLessThanHalf,   // 0xxxxx  x's not all zero\n  lfExactlyHalf,    // 100000\n  lfMoreThanHalf    // 1xxxxx  x's not all zero\n};\n\n/// A self-contained host- and target-independent arbitrary-precision\n/// floating-point software implementation.\n///\n/// APFloat uses bignum integer arithmetic as provided by static functions in\n/// the APInt class.  The library will work with bignum integers whose parts are\n/// any unsigned type at least 16 bits wide, but 64 bits is recommended.\n///\n/// Written for clarity rather than speed, in particular with a view to use in\n/// the front-end of a cross compiler so that target arithmetic can be correctly\n/// performed on the host.  Performance should nonetheless be reasonable,\n/// particularly for its intended use.  It may be useful as a base\n/// implementation for a run-time library during development of a faster\n/// target-specific one.\n///\n/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n/// implemented operations.  Currently implemented operations are add, subtract,\n/// multiply, divide, fused-multiply-add, conversion-to-float,\n/// conversion-to-integer and conversion-from-integer.  New rounding modes\n/// (e.g. away from zero) can be added with three or four lines of code.\n///\n/// Four formats are built-in: IEEE single precision, double precision,\n/// quadruple precision, and x87 80-bit extended double (when operating with\n/// full extended precision).  Adding a new format that obeys IEEE semantics\n/// only requires adding two lines of code: a declaration and definition of the\n/// format.\n///\n/// All operations return the status of that operation as an exception bit-mask,\n/// so multiple operations can be done consecutively with their results or-ed\n/// together.  The returned status can be useful for compiler diagnostics; e.g.,\n/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n/// and compiler optimizers can determine what exceptions would be raised by\n/// folding operations and optimize, or perhaps not optimize, accordingly.\n///\n/// At present, underflow tininess is detected after rounding; it should be\n/// straight forward to add support for the before-rounding case too.\n///\n/// The library reads hexadecimal floating point numbers as per C99, and\n/// correctly rounds if necessary according to the specified rounding mode.\n/// Syntax is required to have been validated by the caller.  It also converts\n/// floating point numbers to hexadecimal text as per the C99 %a and %A\n/// conversions.  The output precision (or alternatively the natural minimal\n/// precision) can be specified; if the requested precision is less than the\n/// natural precision the output is correctly rounded for the specified rounding\n/// mode.\n///\n/// It also reads decimal floating point numbers and correctly rounds according\n/// to the specified rounding mode.\n///\n/// Conversion to decimal text is not currently implemented.\n///\n/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n/// signed exponent, and the significand as an array of integer parts.  After\n/// normalization of a number of precision P the exponent is within the range of\n/// the format, and if the number is not denormal the P-th bit of the\n/// significand is set as an explicit integer bit.  For denormals the most\n/// significant bit is shifted right so that the exponent is maintained at the\n/// format's minimum, so that the smallest denormal has just the least\n/// significant bit of the significand set.  The sign of zeroes and infinities\n/// is significant; the exponent and significand of such numbers is not stored,\n/// but has a known implicit (deterministic) value: 0 for the significands, 0\n/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and\n/// significand are deterministic, although not really meaningful, and preserved\n/// in non-conversion operations.  The exponent is implicitly all 1 bits.\n///\n/// APFloat does not provide any exception handling beyond default exception\n/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n/// by encoding Signaling NaNs with the first bit of its trailing significand as\n/// 0.\n///\n/// TODO\n/// ====\n///\n/// Some features that may or may not be worth adding:\n///\n/// Binary to decimal conversion (hard).\n///\n/// Optional ability to detect underflow tininess before rounding.\n///\n/// New formats: x87 in single and double precision mode (IEEE apart from\n/// extended exponent range) (hard).\n///\n/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.\n///\n\n// This is the common type definitions shared by APFloat and its internal\n// implementation classes. This struct should not define any non-static data\n// members.\nstruct APFloatBase {\n  typedef APInt::WordType integerPart;\n  static constexpr unsigned integerPartWidth = APInt::APINT_BITS_PER_WORD;\n\n  /// A signed type to represent a floating point numbers unbiased exponent.\n  typedef int32_t ExponentType;\n\n  /// \\name Floating Point Semantics.\n  /// @{\n  enum Semantics {\n    S_IEEEhalf,\n    S_BFloat,\n    S_IEEEsingle,\n    S_IEEEdouble,\n    S_x87DoubleExtended,\n    S_IEEEquad,\n    S_PPCDoubleDouble\n  };\n\n  static const llvm::fltSemantics &EnumToSemantics(Semantics S);\n  static Semantics SemanticsToEnum(const llvm::fltSemantics &Sem);\n\n  static const fltSemantics &IEEEhalf() LLVM_READNONE;\n  static const fltSemantics &BFloat() LLVM_READNONE;\n  static const fltSemantics &IEEEsingle() LLVM_READNONE;\n  static const fltSemantics &IEEEdouble() LLVM_READNONE;\n  static const fltSemantics &IEEEquad() LLVM_READNONE;\n  static const fltSemantics &PPCDoubleDouble() LLVM_READNONE;\n  static const fltSemantics &x87DoubleExtended() LLVM_READNONE;\n\n  /// A Pseudo fltsemantic used to construct APFloats that cannot conflict with\n  /// anything real.\n  static const fltSemantics &Bogus() LLVM_READNONE;\n\n  /// @}\n\n  /// IEEE-754R 5.11: Floating Point Comparison Relations.\n  enum cmpResult {\n    cmpLessThan,\n    cmpEqual,\n    cmpGreaterThan,\n    cmpUnordered\n  };\n\n  /// IEEE-754R 4.3: Rounding-direction attributes.\n  using roundingMode = llvm::RoundingMode;\n\n  static constexpr roundingMode rmNearestTiesToEven =\n                                                RoundingMode::NearestTiesToEven;\n  static constexpr roundingMode rmTowardPositive = RoundingMode::TowardPositive;\n  static constexpr roundingMode rmTowardNegative = RoundingMode::TowardNegative;\n  static constexpr roundingMode rmTowardZero     = RoundingMode::TowardZero;\n  static constexpr roundingMode rmNearestTiesToAway =\n                                                RoundingMode::NearestTiesToAway;\n\n  /// IEEE-754R 7: Default exception handling.\n  ///\n  /// opUnderflow or opOverflow are always returned or-ed with opInexact.\n  ///\n  /// APFloat models this behavior specified by IEEE-754:\n  ///   \"For operations producing results in floating-point format, the default\n  ///    result of an operation that signals the invalid operation exception\n  ///    shall be a quiet NaN.\"\n  enum opStatus {\n    opOK = 0x00,\n    opInvalidOp = 0x01,\n    opDivByZero = 0x02,\n    opOverflow = 0x04,\n    opUnderflow = 0x08,\n    opInexact = 0x10\n  };\n\n  /// Category of internally-represented number.\n  enum fltCategory {\n    fcInfinity,\n    fcNaN,\n    fcNormal,\n    fcZero\n  };\n\n  /// Convenience enum used to construct an uninitialized APFloat.\n  enum uninitializedTag {\n    uninitialized\n  };\n\n  /// Enumeration of \\c ilogb error results.\n  enum IlogbErrorKinds {\n    IEK_Zero = INT_MIN + 1,\n    IEK_NaN = INT_MIN,\n    IEK_Inf = INT_MAX\n  };\n\n  static unsigned int semanticsPrecision(const fltSemantics &);\n  static ExponentType semanticsMinExponent(const fltSemantics &);\n  static ExponentType semanticsMaxExponent(const fltSemantics &);\n  static unsigned int semanticsSizeInBits(const fltSemantics &);\n\n  /// Returns the size of the floating point number (in bits) in the given\n  /// semantics.\n  static unsigned getSizeInBits(const fltSemantics &Sem);\n};\n\nnamespace detail {\n\nclass IEEEFloat final : public APFloatBase {\npublic:\n  /// \\name Constructors\n  /// @{\n\n  IEEEFloat(const fltSemantics &); // Default construct to +0.0\n  IEEEFloat(const fltSemantics &, integerPart);\n  IEEEFloat(const fltSemantics &, uninitializedTag);\n  IEEEFloat(const fltSemantics &, const APInt &);\n  explicit IEEEFloat(double d);\n  explicit IEEEFloat(float f);\n  IEEEFloat(const IEEEFloat &);\n  IEEEFloat(IEEEFloat &&);\n  ~IEEEFloat();\n\n  /// @}\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return partCount() > 1; }\n\n  /// \\name Convenience \"constructors\"\n  /// @{\n\n  /// @}\n\n  /// \\name Arithmetic\n  /// @{\n\n  opStatus add(const IEEEFloat &, roundingMode);\n  opStatus subtract(const IEEEFloat &, roundingMode);\n  opStatus multiply(const IEEEFloat &, roundingMode);\n  opStatus divide(const IEEEFloat &, roundingMode);\n  /// IEEE remainder.\n  opStatus remainder(const IEEEFloat &);\n  /// C fmod, or llvm frem.\n  opStatus mod(const IEEEFloat &);\n  opStatus fusedMultiplyAdd(const IEEEFloat &, const IEEEFloat &, roundingMode);\n  opStatus roundToIntegral(roundingMode);\n  /// IEEE-754R 5.3.1: nextUp/nextDown.\n  opStatus next(bool nextDown);\n\n  /// @}\n\n  /// \\name Sign operations.\n  /// @{\n\n  void changeSign();\n\n  /// @}\n\n  /// \\name Conversions\n  /// @{\n\n  opStatus convert(const fltSemantics &, roundingMode, bool *);\n  opStatus convertToInteger(MutableArrayRef<integerPart>, unsigned int, bool,\n                            roundingMode, bool *) const;\n  opStatus convertFromAPInt(const APInt &, bool, roundingMode);\n  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const;\n  double convertToDouble() const;\n  float convertToFloat() const;\n\n  /// @}\n\n  /// The definition of equality is not straightforward for floating point, so\n  /// we won't use operator==.  Use one of the following, or write whatever it\n  /// is you really mean.\n  bool operator==(const IEEEFloat &) const = delete;\n\n  /// IEEE comparison with another floating point number (NaNs compare\n  /// unordered, 0==-0).\n  cmpResult compare(const IEEEFloat &) const;\n\n  /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n  bool bitwiseIsEqual(const IEEEFloat &) const;\n\n  /// Write out a hexadecimal representation of the floating point value to DST,\n  /// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.\n  /// Return the number of characters written, excluding the terminating NUL.\n  unsigned int convertToHexString(char *dst, unsigned int hexDigits,\n                                  bool upperCase, roundingMode) const;\n\n  /// \\name IEEE-754R 5.7.2 General operations.\n  /// @{\n\n  /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n  /// negative.\n  ///\n  /// This applies to zeros and NaNs as well.\n  bool isNegative() const { return sign; }\n\n  /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n  ///\n  /// This implies that the current value of the float is not zero, subnormal,\n  /// infinite, or NaN following the definition of normality from IEEE-754R.\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n\n  /// Returns true if and only if the current value is zero, subnormal, or\n  /// normal.\n  ///\n  /// This means that the value is not infinite or NaN.\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  /// Returns true if and only if the float is plus or minus zero.\n  bool isZero() const { return category == fcZero; }\n\n  /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n  /// denormal.\n  bool isDenormal() const;\n\n  /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n  bool isInfinity() const { return category == fcInfinity; }\n\n  /// Returns true if and only if the float is a quiet or signaling NaN.\n  bool isNaN() const { return category == fcNaN; }\n\n  /// Returns true if and only if the float is a signaling NaN.\n  bool isSignaling() const;\n\n  /// @}\n\n  /// \\name Simple Queries\n  /// @{\n\n  fltCategory getCategory() const { return category; }\n  const fltSemantics &getSemantics() const { return *semantics; }\n  bool isNonZero() const { return category != fcZero; }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n\n  /// Returns true if and only if the number has the smallest possible non-zero\n  /// magnitude in the current semantics.\n  bool isSmallest() const;\n\n  /// Returns true if and only if the number has the largest possible finite\n  /// magnitude in the current semantics.\n  bool isLargest() const;\n\n  /// Returns true if and only if the number is an exact integer.\n  bool isInteger() const;\n\n  /// @}\n\n  IEEEFloat &operator=(const IEEEFloat &);\n  IEEEFloat &operator=(IEEEFloat &&);\n\n  /// Overload to compute a hash code for an APFloat value.\n  ///\n  /// Note that the use of hash codes for floating point values is in general\n  /// frought with peril. Equality is hard to define for these values. For\n  /// example, should negative and positive zero hash to different codes? Are\n  /// they equal or not? This hash value implementation specifically\n  /// emphasizes producing different codes for different inputs in order to\n  /// be used in canonicalization and memoization. As such, equality is\n  /// bitwiseIsEqual, and 0 != -0.\n  friend hash_code hash_value(const IEEEFloat &Arg);\n\n  /// Converts this value into a decimal string.\n  ///\n  /// \\param FormatPrecision The maximum number of digits of\n  ///   precision to output.  If there are fewer digits available,\n  ///   zero padding will not be used unless the value is\n  ///   integral and small enough to be expressed in\n  ///   FormatPrecision digits.  0 means to use the natural\n  ///   precision of the number.\n  /// \\param FormatMaxPadding The maximum number of zeros to\n  ///   consider inserting before falling back to scientific\n  ///   notation.  0 means to always use scientific notation.\n  ///\n  /// \\param TruncateZero Indicate whether to remove the trailing zero in\n  ///   fraction part or not. Also setting this parameter to false forcing\n  ///   producing of output more similar to default printf behavior.\n  ///   Specifically the lower e is used as exponent delimiter and exponent\n  ///   always contains no less than two digits.\n  ///\n  /// Number       Precision    MaxPadding      Result\n  /// ------       ---------    ----------      ------\n  /// 1.01E+4              5             2       10100\n  /// 1.01E+4              4             2       1.01E+4\n  /// 1.01E+4              5             1       1.01E+4\n  /// 1.01E-2              5             2       0.0101\n  /// 1.01E-2              4             2       0.0101\n  /// 1.01E-2              4             1       1.01E-2\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const;\n\n  /// If this value has an exact multiplicative inverse, store it in inv and\n  /// return true.\n  bool getExactInverse(APFloat *inv) const;\n\n  /// Returns the exponent of the internal representation of the APFloat.\n  ///\n  /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).\n  /// For special APFloat values, this returns special error codes:\n  ///\n  ///   NaN -> \\c IEK_NaN\n  ///   0   -> \\c IEK_Zero\n  ///   Inf -> \\c IEK_Inf\n  ///\n  friend int ilogb(const IEEEFloat &Arg);\n\n  /// Returns: X * 2^Exp for integral exponents.\n  friend IEEEFloat scalbn(IEEEFloat X, int Exp, roundingMode);\n\n  friend IEEEFloat frexp(const IEEEFloat &X, int &Exp, roundingMode);\n\n  /// \\name Special value setters.\n  /// @{\n\n  void makeLargest(bool Neg = false);\n  void makeSmallest(bool Neg = false);\n  void makeNaN(bool SNaN = false, bool Neg = false,\n               const APInt *fill = nullptr);\n  void makeInf(bool Neg = false);\n  void makeZero(bool Neg = false);\n  void makeQuiet();\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  void makeSmallestNormalized(bool Negative = false);\n\n  /// @}\n\n  cmpResult compareAbsoluteValue(const IEEEFloat &) const;\n\nprivate:\n  /// \\name Simple Queries\n  /// @{\n\n  integerPart *significandParts();\n  const integerPart *significandParts() const;\n  unsigned int partCount() const;\n\n  /// @}\n\n  /// \\name Significand operations.\n  /// @{\n\n  integerPart addSignificand(const IEEEFloat &);\n  integerPart subtractSignificand(const IEEEFloat &, integerPart);\n  lostFraction addOrSubtractSignificand(const IEEEFloat &, bool subtract);\n  lostFraction multiplySignificand(const IEEEFloat &, IEEEFloat);\n  lostFraction multiplySignificand(const IEEEFloat&);\n  lostFraction divideSignificand(const IEEEFloat &);\n  void incrementSignificand();\n  void initialize(const fltSemantics *);\n  void shiftSignificandLeft(unsigned int);\n  lostFraction shiftSignificandRight(unsigned int);\n  unsigned int significandLSB() const;\n  unsigned int significandMSB() const;\n  void zeroSignificand();\n  /// Return true if the significand excluding the integral bit is all ones.\n  bool isSignificandAllOnes() const;\n  /// Return true if the significand excluding the integral bit is all zeros.\n  bool isSignificandAllZeros() const;\n\n  /// @}\n\n  /// \\name Arithmetic on special values.\n  /// @{\n\n  opStatus addOrSubtractSpecials(const IEEEFloat &, bool subtract);\n  opStatus divideSpecials(const IEEEFloat &);\n  opStatus multiplySpecials(const IEEEFloat &);\n  opStatus modSpecials(const IEEEFloat &);\n  opStatus remainderSpecials(const IEEEFloat&);\n\n  /// @}\n\n  /// \\name Miscellany\n  /// @{\n\n  bool convertFromStringSpecials(StringRef str);\n  opStatus normalize(roundingMode, lostFraction);\n  opStatus addOrSubtract(const IEEEFloat &, roundingMode, bool subtract);\n  opStatus handleOverflow(roundingMode);\n  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;\n  opStatus convertToSignExtendedInteger(MutableArrayRef<integerPart>,\n                                        unsigned int, bool, roundingMode,\n                                        bool *) const;\n  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,\n                                    roundingMode);\n  Expected<opStatus> convertFromHexadecimalString(StringRef, roundingMode);\n  Expected<opStatus> convertFromDecimalString(StringRef, roundingMode);\n  char *convertNormalToHexString(char *, unsigned int, bool,\n                                 roundingMode) const;\n  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,\n                                        roundingMode);\n  ExponentType exponentNaN() const;\n  ExponentType exponentInf() const;\n  ExponentType exponentZero() const;\n\n  /// @}\n\n  APInt convertHalfAPFloatToAPInt() const;\n  APInt convertBFloatAPFloatToAPInt() const;\n  APInt convertFloatAPFloatToAPInt() const;\n  APInt convertDoubleAPFloatToAPInt() const;\n  APInt convertQuadrupleAPFloatToAPInt() const;\n  APInt convertF80LongDoubleAPFloatToAPInt() const;\n  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;\n  void initFromAPInt(const fltSemantics *Sem, const APInt &api);\n  void initFromHalfAPInt(const APInt &api);\n  void initFromBFloatAPInt(const APInt &api);\n  void initFromFloatAPInt(const APInt &api);\n  void initFromDoubleAPInt(const APInt &api);\n  void initFromQuadrupleAPInt(const APInt &api);\n  void initFromF80LongDoubleAPInt(const APInt &api);\n  void initFromPPCDoubleDoubleAPInt(const APInt &api);\n\n  void assign(const IEEEFloat &);\n  void copySignificand(const IEEEFloat &);\n  void freeSignificand();\n\n  /// Note: this must be the first data member.\n  /// The semantics that this value obeys.\n  const fltSemantics *semantics;\n\n  /// A binary fraction with an explicit integer bit.\n  ///\n  /// The significand must be at least one bit wider than the target precision.\n  union Significand {\n    integerPart part;\n    integerPart *parts;\n  } significand;\n\n  /// The signed unbiased exponent of the value.\n  ExponentType exponent;\n\n  /// What kind of floating point number this is.\n  ///\n  /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.\n  /// Using the extra bit keeps it from failing under VisualStudio.\n  fltCategory category : 3;\n\n  /// Sign bit of the number.\n  unsigned int sign : 1;\n};\n\nhash_code hash_value(const IEEEFloat &Arg);\nint ilogb(const IEEEFloat &Arg);\nIEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode);\nIEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM);\n\n// This mode implements more precise float in terms of two APFloats.\n// The interface and layout is designed for arbitrary underlying semantics,\n// though currently only PPCDoubleDouble semantics are supported, whose\n// corresponding underlying semantics are IEEEdouble.\nclass DoubleAPFloat final : public APFloatBase {\n  // Note: this must be the first data member.\n  const fltSemantics *Semantics;\n  std::unique_ptr<APFloat[]> Floats;\n\n  opStatus addImpl(const APFloat &a, const APFloat &aa, const APFloat &c,\n                   const APFloat &cc, roundingMode RM);\n\n  opStatus addWithSpecial(const DoubleAPFloat &LHS, const DoubleAPFloat &RHS,\n                          DoubleAPFloat &Out, roundingMode RM);\n\npublic:\n  DoubleAPFloat(const fltSemantics &S);\n  DoubleAPFloat(const fltSemantics &S, uninitializedTag);\n  DoubleAPFloat(const fltSemantics &S, integerPart);\n  DoubleAPFloat(const fltSemantics &S, const APInt &I);\n  DoubleAPFloat(const fltSemantics &S, APFloat &&First, APFloat &&Second);\n  DoubleAPFloat(const DoubleAPFloat &RHS);\n  DoubleAPFloat(DoubleAPFloat &&RHS);\n\n  DoubleAPFloat &operator=(const DoubleAPFloat &RHS);\n\n  DoubleAPFloat &operator=(DoubleAPFloat &&RHS) {\n    if (this != &RHS) {\n      this->~DoubleAPFloat();\n      new (this) DoubleAPFloat(std::move(RHS));\n    }\n    return *this;\n  }\n\n  bool needsCleanup() const { return Floats != nullptr; }\n\n  APFloat &getFirst() { return Floats[0]; }\n  const APFloat &getFirst() const { return Floats[0]; }\n  APFloat &getSecond() { return Floats[1]; }\n  const APFloat &getSecond() const { return Floats[1]; }\n\n  opStatus add(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus subtract(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus multiply(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus divide(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus remainder(const DoubleAPFloat &RHS);\n  opStatus mod(const DoubleAPFloat &RHS);\n  opStatus fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,\n                            const DoubleAPFloat &Addend, roundingMode RM);\n  opStatus roundToIntegral(roundingMode RM);\n  void changeSign();\n  cmpResult compareAbsoluteValue(const DoubleAPFloat &RHS) const;\n\n  fltCategory getCategory() const;\n  bool isNegative() const;\n\n  void makeInf(bool Neg);\n  void makeZero(bool Neg);\n  void makeLargest(bool Neg);\n  void makeSmallest(bool Neg);\n  void makeSmallestNormalized(bool Neg);\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill);\n\n  cmpResult compare(const DoubleAPFloat &RHS) const;\n  bool bitwiseIsEqual(const DoubleAPFloat &RHS) const;\n  APInt bitcastToAPInt() const;\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  opStatus next(bool nextDown);\n\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned, roundingMode RM);\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const;\n\n  bool isDenormal() const;\n  bool isSmallest() const;\n  bool isLargest() const;\n  bool isInteger() const;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,\n                unsigned FormatMaxPadding, bool TruncateZero = true) const;\n\n  bool getExactInverse(APFloat *inv) const;\n\n  friend DoubleAPFloat scalbn(const DoubleAPFloat &X, int Exp, roundingMode);\n  friend DoubleAPFloat frexp(const DoubleAPFloat &X, int &Exp, roundingMode);\n  friend hash_code hash_value(const DoubleAPFloat &Arg);\n};\n\nhash_code hash_value(const DoubleAPFloat &Arg);\n\n} // End detail namespace\n\n// This is a interface class that is currently forwarding functionalities from\n// detail::IEEEFloat.\nclass APFloat : public APFloatBase {\n  typedef detail::IEEEFloat IEEEFloat;\n  typedef detail::DoubleAPFloat DoubleAPFloat;\n\n  static_assert(std::is_standard_layout<IEEEFloat>::value, \"\");\n\n  union Storage {\n    const fltSemantics *semantics;\n    IEEEFloat IEEE;\n    DoubleAPFloat Double;\n\n    explicit Storage(IEEEFloat F, const fltSemantics &S);\n    explicit Storage(DoubleAPFloat F, const fltSemantics &S)\n        : Double(std::move(F)) {\n      assert(&S == &PPCDoubleDouble());\n    }\n\n    template <typename... ArgTypes>\n    Storage(const fltSemantics &Semantics, ArgTypes &&... Args) {\n      if (usesLayout<IEEEFloat>(Semantics)) {\n        new (&IEEE) IEEEFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(Semantics)) {\n        new (&Double) DoubleAPFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    ~Storage() {\n      if (usesLayout<IEEEFloat>(*semantics)) {\n        IEEE.~IEEEFloat();\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*semantics)) {\n        Double.~DoubleAPFloat();\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(RHS.IEEE);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(RHS.Double);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(std::move(RHS.IEEE));\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(std::move(RHS.Double));\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage &operator=(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = RHS.IEEE;\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = RHS.Double;\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(RHS);\n      }\n      return *this;\n    }\n\n    Storage &operator=(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = std::move(RHS.IEEE);\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = std::move(RHS.Double);\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(std::move(RHS));\n      }\n      return *this;\n    }\n  } U;\n\n  template <typename T> static bool usesLayout(const fltSemantics &Semantics) {\n    static_assert(std::is_same<T, IEEEFloat>::value ||\n                  std::is_same<T, DoubleAPFloat>::value, \"\");\n    if (std::is_same<T, DoubleAPFloat>::value) {\n      return &Semantics == &PPCDoubleDouble();\n    }\n    return &Semantics != &PPCDoubleDouble();\n  }\n\n  IEEEFloat &getIEEE() {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  const IEEEFloat &getIEEE() const {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  void makeZero(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeZero(Neg)); }\n\n  void makeInf(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeInf(Neg)); }\n\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeNaN(SNaN, Neg, fill));\n  }\n\n  void makeLargest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeLargest(Neg));\n  }\n\n  void makeSmallest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallest(Neg));\n  }\n\n  void makeSmallestNormalized(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallestNormalized(Neg));\n  }\n\n  // FIXME: This is due to clang 3.3 (or older version) always checks for the\n  // default constructor in an array aggregate initialization, even if no\n  // elements in the array is default initialized.\n  APFloat() : U(IEEEdouble()) {\n    llvm_unreachable(\"This is a workaround for old clang.\");\n  }\n\n  explicit APFloat(IEEEFloat F, const fltSemantics &S) : U(std::move(F), S) {}\n  explicit APFloat(DoubleAPFloat F, const fltSemantics &S)\n      : U(std::move(F), S) {}\n\n  cmpResult compareAbsoluteValue(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compareAbsoluteValue(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compareAbsoluteValue(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\npublic:\n  APFloat(const fltSemantics &Semantics) : U(Semantics) {}\n  APFloat(const fltSemantics &Semantics, StringRef S);\n  APFloat(const fltSemantics &Semantics, integerPart I) : U(Semantics, I) {}\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>>\n  APFloat(const fltSemantics &Semantics, T V) = delete;\n  // TODO: Remove this constructor. This isn't faster than the first one.\n  APFloat(const fltSemantics &Semantics, uninitializedTag)\n      : U(Semantics, uninitialized) {}\n  APFloat(const fltSemantics &Semantics, const APInt &I) : U(Semantics, I) {}\n  explicit APFloat(double d) : U(IEEEFloat(d), IEEEdouble()) {}\n  explicit APFloat(float f) : U(IEEEFloat(f), IEEEsingle()) {}\n  APFloat(const APFloat &RHS) = default;\n  APFloat(APFloat &&RHS) = default;\n\n  ~APFloat() = default;\n\n  bool needsCleanup() const { APFLOAT_DISPATCH_ON_SEMANTICS(needsCleanup()); }\n\n  /// Factory for Positive and Negative Zero.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeZero(Negative);\n    return Val;\n  }\n\n  /// Factory for Positive and Negative Infinity.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeInf(Negative);\n    return Val;\n  }\n\n  /// Factory for NaN values.\n  ///\n  /// \\param Negative - True iff the NaN generated should be negative.\n  /// \\param payload - The unspecified fill bits for creating the NaN, 0 by\n  /// default.  The value is truncated as necessary.\n  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,\n                        uint64_t payload = 0) {\n    if (payload) {\n      APInt intPayload(64, payload);\n      return getQNaN(Sem, Negative, &intPayload);\n    } else {\n      return getQNaN(Sem, Negative, nullptr);\n    }\n  }\n\n  /// Factory for QNaN values.\n  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(false, Negative, payload);\n    return Val;\n  }\n\n  /// Factory for SNaN values.\n  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(true, Negative, payload);\n    return Val;\n  }\n\n  /// Returns the largest finite number in the given semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeLargest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) finite number in the given semantics.\n  /// Might be denormalized, which implies a relative loss of precision.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallestNormalized(const fltSemantics &Sem,\n                                       bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallestNormalized(Negative);\n    return Val;\n  }\n\n  /// Returns a float which is bitcasted from an all one value int.\n  ///\n  /// \\param Semantics - type float semantics\n  /// \\param BitWidth - Select float type\n  static APFloat getAllOnesValue(const fltSemantics &Semantics,\n                                 unsigned BitWidth);\n\n  /// Used to insert APFloat objects, or objects that contain APFloat objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID &NID) const;\n\n  opStatus add(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.add(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.add(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus subtract(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.subtract(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.subtract(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus multiply(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.multiply(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.multiply(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus divide(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.divide(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.divide(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus remainder(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.remainder(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.remainder(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus mod(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.mod(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.mod(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus fusedMultiplyAdd(const APFloat &Multiplicand, const APFloat &Addend,\n                            roundingMode RM) {\n    assert(&getSemantics() == &Multiplicand.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    assert(&getSemantics() == &Addend.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.fusedMultiplyAdd(Multiplicand.U.IEEE, Addend.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.fusedMultiplyAdd(Multiplicand.U.Double, Addend.U.Double,\n                                       RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus roundToIntegral(roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(roundToIntegral(RM));\n  }\n\n  // TODO: bool parameters are not readable and a source of bugs.\n  // Do something.\n  opStatus next(bool nextDown) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(next(nextDown));\n  }\n\n  /// Negate an APFloat.\n  APFloat operator-() const {\n    APFloat Result(*this);\n    Result.changeSign();\n    return Result;\n  }\n\n  /// Add two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator+(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.add(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Subtract two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator-(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.subtract(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Multiply two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator*(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.multiply(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Divide the first APFloat by the second, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator/(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.divide(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  void changeSign() { APFLOAT_DISPATCH_ON_SEMANTICS(changeSign()); }\n  void clearSign() {\n    if (isNegative())\n      changeSign();\n  }\n  void copySign(const APFloat &RHS) {\n    if (isNegative() != RHS.isNegative())\n      changeSign();\n  }\n\n  /// A static helper to produce a copy of an APFloat value with its sign\n  /// copied from some other APFloat.\n  static APFloat copySign(APFloat Value, const APFloat &Sign) {\n    Value.copySign(Sign);\n    return Value;\n  }\n\n  opStatus convert(const fltSemantics &ToSemantics, roundingMode RM,\n                   bool *losesInfo);\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToInteger(Input, Width, IsSigned, RM, IsExact));\n  }\n  opStatus convertToInteger(APSInt &Result, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned,\n                            roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(convertFromAPInt(Input, IsSigned, RM));\n  }\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(bitcastToAPInt());\n  }\n  double convertToDouble() const { return getIEEE().convertToDouble(); }\n  float convertToFloat() const { return getIEEE().convertToFloat(); }\n\n  bool operator==(const APFloat &RHS) const { return compare(RHS) == cmpEqual; }\n\n  bool operator!=(const APFloat &RHS) const { return compare(RHS) != cmpEqual; }\n\n  bool operator<(const APFloat &RHS) const {\n    return compare(RHS) == cmpLessThan;\n  }\n\n  bool operator>(const APFloat &RHS) const {\n    return compare(RHS) == cmpGreaterThan;\n  }\n\n  bool operator<=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpLessThan || Res == cmpEqual;\n  }\n\n  bool operator>=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpGreaterThan || Res == cmpEqual;\n  }\n\n  cmpResult compare(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compare(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compare(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  bool bitwiseIsEqual(const APFloat &RHS) const {\n    if (&getSemantics() != &RHS.getSemantics())\n      return false;\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.bitwiseIsEqual(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.bitwiseIsEqual(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n  ///\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat Tmp(V);\n    Tmp.convert(getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return bitwiseIsEqual(Tmp);\n  }\n\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToHexString(DST, HexDigits, UpperCase, RM));\n  }\n\n  bool isZero() const { return getCategory() == fcZero; }\n  bool isInfinity() const { return getCategory() == fcInfinity; }\n  bool isNaN() const { return getCategory() == fcNaN; }\n\n  bool isNegative() const { return getIEEE().isNegative(); }\n  bool isDenormal() const { APFLOAT_DISPATCH_ON_SEMANTICS(isDenormal()); }\n  bool isSignaling() const { return getIEEE().isSignaling(); }\n\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  fltCategory getCategory() const { return getIEEE().getCategory(); }\n  const fltSemantics &getSemantics() const { return *U.semantics; }\n  bool isNonZero() const { return !isZero(); }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n  bool isSmallest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isSmallest()); }\n  bool isLargest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isLargest()); }\n  bool isInteger() const { APFLOAT_DISPATCH_ON_SEMANTICS(isInteger()); }\n  bool isIEEE() const { return usesLayout<IEEEFloat>(getSemantics()); }\n\n  APFloat &operator=(const APFloat &RHS) = default;\n  APFloat &operator=(APFloat &&RHS) = default;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero));\n  }\n\n  void print(raw_ostream &) const;\n  void dump() const;\n\n  bool getExactInverse(APFloat *inv) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(getExactInverse(inv));\n  }\n\n  friend hash_code hash_value(const APFloat &Arg);\n  friend int ilogb(const APFloat &Arg) { return ilogb(Arg.getIEEE()); }\n  friend APFloat scalbn(APFloat X, int Exp, roundingMode RM);\n  friend APFloat frexp(const APFloat &X, int &Exp, roundingMode RM);\n  friend IEEEFloat;\n  friend DoubleAPFloat;\n};\n\n/// See friend declarations above.\n///\n/// These additional declarations are required in order to compile LLVM with IBM\n/// xlC compiler.\nhash_code hash_value(const APFloat &Arg);\ninline APFloat scalbn(APFloat X, int Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n\n/// Equivalent of C standard library function.\n///\n/// While the C standard says Exp is an unspecified value for infinity and nan,\n/// this returns INT_MAX for infinities, and INT_MIN for NaNs.\ninline APFloat frexp(const APFloat &X, int &Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n/// Returns the absolute value of the argument.\ninline APFloat abs(APFloat X) {\n  X.clearSign();\n  return X;\n}\n\n/// Returns the negated value of the argument.\ninline APFloat neg(APFloat X) {\n  X.changeSign();\n  return X;\n}\n\n/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat minnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat maxnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return A < B ? B : A;\n}\n\n/// Implements IEEE 754-2018 minimum semantics. Returns the smaller of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat minimum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? A : B;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE 754-2018 maximum semantics. Returns the larger of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat maximum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? B : A;\n  return A < B ? B : A;\n}\n\n} // namespace llvm\n\n#undef APFLOAT_DISPATCH_ON_SEMANTICS\n#endif // LLVM_ADT_APFLOAT_H\n"}, "73": {"id": 73, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "content": "//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines CachedHashString and CachedHashStringRef.  These are owning\n// and not-owning string types that store their hash in addition to their string\n// data.\n//\n// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap\n// (because, unlike std::string, CachedHashString lets us have empty and\n// tombstone values).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_CACHEDHASHSTRING_H\n#define LLVM_ADT_CACHEDHASHSTRING_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\n/// A container which contains a StringRef plus a precomputed hash.\nclass CachedHashStringRef {\n  const char *P;\n  uint32_t Size;\n  uint32_t Hash;\n\npublic:\n  // Explicit because hashing a string isn't free.\n  explicit CachedHashStringRef(StringRef S)\n      : CachedHashStringRef(S, DenseMapInfo<StringRef>::getHashValue(S)) {}\n\n  CachedHashStringRef(StringRef S, uint32_t Hash)\n      : P(S.data()), Size(S.size()), Hash(Hash) {\n    assert(S.size() <= std::numeric_limits<uint32_t>::max());\n  }\n\n  StringRef val() const { return StringRef(P, Size); }\n  const char *data() const { return P; }\n  uint32_t size() const { return Size; }\n  uint32_t hash() const { return Hash; }\n};\n\ntemplate <> struct DenseMapInfo<CachedHashStringRef> {\n  static CachedHashStringRef getEmptyKey() {\n    return CachedHashStringRef(DenseMapInfo<StringRef>::getEmptyKey(), 0);\n  }\n  static CachedHashStringRef getTombstoneKey() {\n    return CachedHashStringRef(DenseMapInfo<StringRef>::getTombstoneKey(), 1);\n  }\n  static unsigned getHashValue(const CachedHashStringRef &S) {\n    assert(!isEqual(S, getEmptyKey()) && \"Cannot hash the empty key!\");\n    assert(!isEqual(S, getTombstoneKey()) && \"Cannot hash the tombstone key!\");\n    return S.hash();\n  }\n  static bool isEqual(const CachedHashStringRef &LHS,\n                      const CachedHashStringRef &RHS) {\n    return LHS.hash() == RHS.hash() &&\n           DenseMapInfo<StringRef>::isEqual(LHS.val(), RHS.val());\n  }\n};\n\n/// A container which contains a string, which it owns, plus a precomputed hash.\n///\n/// We do not null-terminate the string.\nclass CachedHashString {\n  friend struct DenseMapInfo<CachedHashString>;\n\n  char *P;\n  uint32_t Size;\n  uint32_t Hash;\n\n  static char *getEmptyKeyPtr() { return DenseMapInfo<char *>::getEmptyKey(); }\n  static char *getTombstoneKeyPtr() {\n    return DenseMapInfo<char *>::getTombstoneKey();\n  }\n\n  bool isEmptyOrTombstone() const {\n    return P == getEmptyKeyPtr() || P == getTombstoneKeyPtr();\n  }\n\n  struct ConstructEmptyOrTombstoneTy {};\n\n  CachedHashString(ConstructEmptyOrTombstoneTy, char *EmptyOrTombstonePtr)\n      : P(EmptyOrTombstonePtr), Size(0), Hash(0) {\n    assert(isEmptyOrTombstone());\n  }\n\n  // TODO: Use small-string optimization to avoid allocating.\n\npublic:\n  explicit CachedHashString(const char *S) : CachedHashString(StringRef(S)) {}\n\n  // Explicit because copying and hashing a string isn't free.\n  explicit CachedHashString(StringRef S)\n      : CachedHashString(S, DenseMapInfo<StringRef>::getHashValue(S)) {}\n\n  CachedHashString(StringRef S, uint32_t Hash)\n      : P(new char[S.size()]), Size(S.size()), Hash(Hash) {\n    memcpy(P, S.data(), S.size());\n  }\n\n  // Ideally this class would not be copyable.  But SetVector requires copyable\n  // keys, and we want this to be usable there.\n  CachedHashString(const CachedHashString &Other)\n      : Size(Other.Size), Hash(Other.Hash) {\n    if (Other.isEmptyOrTombstone()) {\n      P = Other.P;\n    } else {\n      P = new char[Size];\n      memcpy(P, Other.P, Size);\n    }\n  }\n\n  CachedHashString &operator=(CachedHashString Other) {\n    swap(*this, Other);\n    return *this;\n  }\n\n  CachedHashString(CachedHashString &&Other) noexcept\n      : P(Other.P), Size(Other.Size), Hash(Other.Hash) {\n    Other.P = getEmptyKeyPtr();\n  }\n\n  ~CachedHashString() {\n    if (!isEmptyOrTombstone())\n      delete[] P;\n  }\n\n  StringRef val() const { return StringRef(P, Size); }\n  uint32_t size() const { return Size; }\n  uint32_t hash() const { return Hash; }\n\n  operator StringRef() const { return val(); }\n  operator CachedHashStringRef() const {\n    return CachedHashStringRef(val(), Hash);\n  }\n\n  friend void swap(CachedHashString &LHS, CachedHashString &RHS) {\n    using std::swap;\n    swap(LHS.P, RHS.P);\n    swap(LHS.Size, RHS.Size);\n    swap(LHS.Hash, RHS.Hash);\n  }\n};\n\ntemplate <> struct DenseMapInfo<CachedHashString> {\n  static CachedHashString getEmptyKey() {\n    return CachedHashString(CachedHashString::ConstructEmptyOrTombstoneTy(),\n                            CachedHashString::getEmptyKeyPtr());\n  }\n  static CachedHashString getTombstoneKey() {\n    return CachedHashString(CachedHashString::ConstructEmptyOrTombstoneTy(),\n                            CachedHashString::getTombstoneKeyPtr());\n  }\n  static unsigned getHashValue(const CachedHashString &S) {\n    assert(!isEqual(S, getEmptyKey()) && \"Cannot hash the empty key!\");\n    assert(!isEqual(S, getTombstoneKey()) && \"Cannot hash the tombstone key!\");\n    return S.hash();\n  }\n  static bool isEqual(const CachedHashString &LHS,\n                      const CachedHashString &RHS) {\n    if (LHS.hash() != RHS.hash())\n      return false;\n    if (LHS.P == CachedHashString::getEmptyKeyPtr())\n      return RHS.P == CachedHashString::getEmptyKeyPtr();\n    if (LHS.P == CachedHashString::getTombstoneKeyPtr())\n      return RHS.P == CachedHashString::getTombstoneKeyPtr();\n\n    // This is safe because if RHS.P is the empty or tombstone key, it will have\n    // length 0, so we'll never dereference its pointer.\n    return LHS.val() == RHS.val();\n  }\n};\n\n} // namespace llvm\n\n#endif\n"}, "94": {"id": 94, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h", "content": "//===-- llvm/Support/DynamicLibrary.h - Portable Dynamic Library -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the sys::DynamicLibrary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DYNAMICLIBRARY_H\n#define LLVM_SUPPORT_DYNAMICLIBRARY_H\n\n#include <string>\n\nnamespace llvm {\n\nclass StringRef;\n\nnamespace sys {\n\n  /// This class provides a portable interface to dynamic libraries which also\n  /// might be known as shared libraries, shared objects, dynamic shared\n  /// objects, or dynamic link libraries. Regardless of the terminology or the\n  /// operating system interface, this class provides a portable interface that\n  /// allows dynamic libraries to be loaded and searched for externally\n  /// defined symbols. This is typically used to provide \"plug-in\" support.\n  /// It also allows for symbols to be defined which don't live in any library,\n  /// but rather the main program itself, useful on Windows where the main\n  /// executable cannot be searched.\n  ///\n  /// Note: there is currently no interface for temporarily loading a library,\n  /// or for unloading libraries when the LLVM library is unloaded.\n  class DynamicLibrary {\n    // Placeholder whose address represents an invalid library.\n    // We use this instead of NULL or a pointer-int pair because the OS library\n    // might define 0 or 1 to be \"special\" handles, such as \"search all\".\n    static char Invalid;\n\n    // Opaque data used to interface with OS-specific dynamic library handling.\n    void *Data;\n\n  public:\n    explicit DynamicLibrary(void *data = &Invalid) : Data(data) {}\n\n    /// Returns true if the object refers to a valid library.\n    bool isValid() const { return Data != &Invalid; }\n\n    /// Searches through the library for the symbol \\p symbolName. If it is\n    /// found, the address of that symbol is returned. If not, NULL is returned.\n    /// Note that NULL will also be returned if the library failed to load.\n    /// Use isValid() to distinguish these cases if it is important.\n    /// Note that this will \\e not search symbols explicitly registered by\n    /// AddSymbol().\n    void *getAddressOfSymbol(const char *symbolName);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// The library will only be unloaded when llvm_shutdown() is called.\n    /// This returns a valid DynamicLibrary instance on success and an invalid\n    /// instance on failure (see isValid()). \\p *errMsg will only be modified\n    /// if the library fails to load.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    /// Open a dynamic library permanently.\n    static DynamicLibrary getPermanentLibrary(const char *filename,\n                                              std::string *errMsg = nullptr);\n\n    /// Registers an externally loaded library. The library will be unloaded\n    /// when the program terminates.\n    ///\n    /// It is safe to call this function multiple times for the same library,\n    /// though ownership is only taken if there was no error.\n    ///\n    /// \\returns An empty \\p DynamicLibrary if the library was already loaded.\n    static DynamicLibrary addPermanentLibrary(void *handle,\n                                              std::string *errMsg = nullptr);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// Use this instead of getPermanentLibrary() when you won't need to get\n    /// symbols from the library itself.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    static bool LoadLibraryPermanently(const char *Filename,\n                                       std::string *ErrMsg = nullptr) {\n      return !getPermanentLibrary(Filename, ErrMsg).isValid();\n    }\n\n    enum SearchOrdering {\n      /// SO_Linker - Search as a call to dlsym(dlopen(NULL)) would when\n      /// DynamicLibrary::getPermanentLibrary(NULL) has been called or\n      /// search the list of explcitly loaded symbols if not.\n      SO_Linker,\n      /// SO_LoadedFirst - Search all loaded libraries, then as SO_Linker would.\n      SO_LoadedFirst,\n      /// SO_LoadedLast - Search as SO_Linker would, then loaded libraries.\n      /// Only useful to search if libraries with RTLD_LOCAL have been added.\n      SO_LoadedLast,\n      /// SO_LoadOrder - Or this in to search libraries in the ordered loaded.\n      /// The default bahaviour is to search loaded libraries in reverse.\n      SO_LoadOrder = 4\n    };\n    static SearchOrdering SearchOrder; // = SO_Linker\n\n    /// This function will search through all previously loaded dynamic\n    /// libraries for the symbol \\p symbolName. If it is found, the address of\n    /// that symbol is returned. If not, null is returned. Note that this will\n    /// search permanently loaded libraries (getPermanentLibrary()) as well\n    /// as explicitly registered symbols (AddSymbol()).\n    /// @throws std::string on error.\n    /// Search through libraries for address of a symbol\n    static void *SearchForAddressOfSymbol(const char *symbolName);\n\n    /// Convenience function for C++ophiles.\n    static void *SearchForAddressOfSymbol(const std::string &symbolName) {\n      return SearchForAddressOfSymbol(symbolName.c_str());\n    }\n\n    /// This functions permanently adds the symbol \\p symbolName with the\n    /// value \\p symbolValue.  These symbols are searched before any\n    /// libraries.\n    /// Add searchable symbol/value pair.\n    static void AddSymbol(StringRef symbolName, void *symbolValue);\n\n    class HandleSet;\n  };\n\n} // End sys namespace\n} // End llvm namespace\n\n#endif\n"}, "100": {"id": 100, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "content": "//===- MemoryBufferRef.h - Memory Buffer Reference --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the MemoryBuffer interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_MEMORYBUFFERREF_H\n#define LLVM_SUPPORT_MEMORYBUFFERREF_H\n\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nclass MemoryBufferRef {\n  StringRef Buffer;\n  StringRef Identifier;\n\npublic:\n  MemoryBufferRef() = default;\n  MemoryBufferRef(const MemoryBuffer &Buffer);\n  MemoryBufferRef(StringRef Buffer, StringRef Identifier)\n      : Buffer(Buffer), Identifier(Identifier) {}\n\n  StringRef getBuffer() const { return Buffer; }\n  StringRef getBufferIdentifier() const { return Identifier; }\n\n  const char *getBufferStart() const { return Buffer.begin(); }\n  const char *getBufferEnd() const { return Buffer.end(); }\n  size_t getBufferSize() const { return Buffer.size(); }\n\n  /// Check pointer identity (not value) of identifier and data.\n  friend bool operator==(const MemoryBufferRef &LHS,\n                         const MemoryBufferRef &RHS) {\n    return LHS.Buffer.begin() == RHS.Buffer.begin() &&\n           LHS.Buffer.end() == RHS.Buffer.end() &&\n           LHS.Identifier.begin() == RHS.Identifier.begin() &&\n           LHS.Identifier.end() == RHS.Identifier.end();\n  }\n\n  friend bool operator!=(const MemoryBufferRef &LHS,\n                         const MemoryBufferRef &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_MEMORYBUFFERREF_H\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 1, "line": 46}, "message": "destructor '~CollectMainFileMacros' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "reportHash": "737a83a67514ab8b61c0d4f4bec2e4b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 2, "line": 39}, "message": "default constructor 'ParseOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "reportHash": "11885412fe58960e5358ee4c52a288fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 2, "line": 39}, "message": "destructor '~ParseOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "reportHash": "fb9c8da02a74ca18ee2912c48d07e15d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 2, "line": 39}, "message": "move constructor 'ParseOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "reportHash": "b89a06ccb3a936000f0c5cf26aafde0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 147}, "message": "default constructor 'Position' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "11386204233973c61124097462e100e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 147}, "message": "destructor '~Position' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "66288552f10104324a8cb25f51ffe238", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 147}, "message": "move constructor 'Position' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "718242d7eab17033feb5ad222d6afdcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 176}, "message": "default constructor 'Range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "90f9df2c900a1a3ef93fd87a678a88c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 176}, "message": "destructor '~Range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "6c8a895cc5a385a48594a50bc5bae165", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 1572}, "message": "default constructor 'SelectionRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "cfae2a3bff1b4f9cffb7a5d45b828fcd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 1628}, "message": "default constructor 'FoldingRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "c1487c45de79d228405706b8cf0b50e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 28}, "message": "destructor '~URI' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "reportHash": "8393b3e3c92c115b59e46588c3461165", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 87}, "message": "destructor '~Ref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "70b414461eadf081458a3525efe988f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 32}, "message": "destructor '~SymbolID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "reportHash": "3e737b3b4e89271ffb3dee095635ea5a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 32}, "message": "move constructor 'SymbolID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "reportHash": "5d6d6bd9641a49ae180e1919c332fcc3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 19}, "message": "destructor '~SymbolLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "d9a3a34254e6f318f3bbc393c7dc0c77", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 7, "line": 32}, "message": "destructor '~Position' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "daba2590aeb02664e900eeed31616d28", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 58}, "message": "move constructor 'Deadline' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "30035c40fda5216c613a00d1fee2c675", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 9, "line": 146}, "message": "destructor '~LValueBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "48bde291bab164149488bdd5035d2441", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 9, "line": 191}, "message": "destructor '~LocalState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "2036b25918c41f94e009961c63ed2021", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 9, "line": 194}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "2c2168dd2bad87b3022435b60544003c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 9, "line": 294}, "message": "default constructor 'AddrLabelDiffData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "37af5974d57cfed67f8d7ad6ebc31ffc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 52}, "message": "destructor '~ASTNodeKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "f7d37cf6dee2c87670a3968dd20ad603", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 52}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "626f26e6eaac9e448fa2ed941d4a4a91", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 52}, "message": "move constructor 'ASTNodeKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "b2a9ba2a9e2cfd8ed832fcbe6b34869b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 233}, "message": "default constructor 'DynTypedNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "78e7cd16cfb61f1ce9ff5a19ac5f58c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 233}, "message": "move constructor 'DynTypedNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "2d59fabba3505a4f0975e915f0df25fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 184}, "message": "destructor '~PathDiagnosticRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "df35cf29b092c3973bc4a6830363d365", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 184}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "cbe457266ac4e8c3dee8b06492b4d4e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 184}, "message": "move constructor 'PathDiagnosticRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "8194a358ade06395eea74766f6a91470", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 196}, "message": "destructor '~PathDiagnosticLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "ea8a3a174acba1381eb4d58b242a0a74", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 196}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "8590731e0a13270bc74310a1f36b0bc5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 196}, "message": "move constructor 'PathDiagnosticLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "e2477b6f0b134d265c2ab51b1f574567", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 374}, "message": "destructor '~PathDiagnosticLocationPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "9d5dbb1ac95ed7ce22e5f53f6a39d6e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 495}, "message": "default constructor 'PathPieces' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "4cf84dcf7f1f49298ba76b60526a5619", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 495}, "message": "move constructor 'PathPieces' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "21405aa2b25869aa07701b1e38c57c04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 509}, "message": "destructor '~PathDiagnosticSpotPiece' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "e632f080ff45009ea776c6c6c58158e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 45}, "message": "destructor '~DirectoryEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "e2b9bede14c605058f98abfa555f04a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 45}, "message": "move constructor 'DirectoryEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "74b15f25c3b459629a578e619693ed30", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 95}, "message": "default constructor 'dense_map_empty_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "b81bf028b44159968012d6683a2671c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 95}, "message": "destructor '~dense_map_empty_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "13c0ab18117b993614fed7d30144c714", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 95}, "message": "move constructor 'dense_map_empty_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "a16b834054c51ec74dc15de6bee23dc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 96}, "message": "default constructor 'dense_map_tombstone_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "be7c5bdad20b29a61a10e1915cfcfecd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 96}, "message": "destructor '~dense_map_tombstone_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "0f4bf2c426433f1db98cf3da5cb27243", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 96}, "message": "move constructor 'dense_map_tombstone_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "4b5a2402d50d121ad1ec4cd395505482", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 60}, "message": "destructor '~FileEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "f0bbaf304194052d410a156c98d2d08e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 60}, "message": "move constructor 'FileEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "a68ce7af81a0389435930fe71b6ed455", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 170}, "message": "default constructor 'dense_map_empty_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "3c92f2111384fb9b13347db537900c09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 170}, "message": "destructor '~dense_map_empty_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "9699940052235dbd2f29ac3f3fd9f613", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 170}, "message": "move constructor 'dense_map_empty_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "57de75ee151e12832ab57a258c87d7ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 171}, "message": "default constructor 'dense_map_tombstone_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "aa40d795f6750fd862784433aeeb09e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 171}, "message": "destructor '~dense_map_tombstone_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "9c96407c90ecf5c8f2d853d375334ede", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 171}, "message": "move constructor 'dense_map_tombstone_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "293b1aa693d677b8d0469b5cea639691", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 41, "line": 34}, "message": "destructor '~SmallString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LLVM.h", "reportHash": "c74c593d52add5b7114d8cb92879870e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 41, "line": 37}, "message": "destructor '~Optional' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LLVM.h", "reportHash": "5b93e06ddc04675682e9c2340cf3e5c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 43, "line": 56}, "message": "move constructor 'ASTFileSignature' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "2237fd301c97d5f995faccfdfc72476b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 189}, "message": "destructor '~Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "3187d36920721451d67195ec47bf5cf6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 189}, "message": "move constructor 'Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "5eeeb72450fd7fc9be3363c34ff15df2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 41}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "0415470958e9500ecb9d666f8ca17575", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 304}, "message": "destructor '~PresumedLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "2abe1d764c019c9ab53cd846085cec77", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 366}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "60ac81413180ef7f7445949f82d727b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 46, "line": 128}, "message": "destructor '~ContentCache' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "b366d799ca808fbd936a2b7cf9d523d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 282}, "message": "default constructor 'FileInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "9f710efeedfcb05310110aaa07105eac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 282}, "message": "move constructor 'FileInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "54bc51ce66303711e75be03ef28d25d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 347}, "message": "default constructor 'ExpansionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "543cbcf2d83228f5f9c26bd9a3499215", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 347}, "message": "destructor '~ExpansionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "bcd88e16c24ae04a711a7c1edef19593", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 347}, "message": "move constructor 'ExpansionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "66053518919b26cb5361a30916fcdfd8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 467}, "message": "move constructor 'SLocEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "ef2593851f346a98ec6eb82b67f3b314", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 46, "line": 653}, "message": "default constructor 'OverriddenFilesInfoTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "3c26cea87eab0c31690b86023ec2f365", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 47, "line": 88}, "message": "default constructor 'WrittenBuiltinSpecs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Specifiers.h", "reportHash": "fd32a920c27094d2fb34880e23d307f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 24}, "message": "default constructor 'ParsedSourceLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "reportHash": "fe7afaa54cd3e77d769e714a8c84497c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 24}, "message": "destructor '~ParsedSourceLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "reportHash": "c4cd57150aaf1a48c7abf8351156d161", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 24}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "reportHash": "500e701cbc014e9076ebc966d7e53d2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 24}, "message": "move constructor 'ParsedSourceLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "reportHash": "98d76679eac4859705074e2aea472b7d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 243}, "message": "destructor '~ASTFrontendAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "reportHash": "66118d00586fa184bb95322b28e98391", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 144}, "message": "destructor '~InputKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "reportHash": "373dcda12a85a63c6d2359cba92b6d13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 144}, "message": "move constructor 'InputKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "reportHash": "a336018775069f4c0d27384e68e2c1a5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 53, "line": 77}, "message": "default constructor 'DependencyCollector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/Utils.h", "reportHash": "2fafef6b16a2302b513201138af5ccef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 54, "line": 141}, "message": "default constructor 'SymbolInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Index/IndexSymbol.h", "reportHash": "0513babf5a4d2df137848a3145b9801c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 54, "line": 141}, "message": "destructor '~SymbolInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Index/IndexSymbol.h", "reportHash": "cceccb93baf97bd7cf09752eadb07bd9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 54, "line": 141}, "message": "move constructor 'SymbolInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Index/IndexSymbol.h", "reportHash": "9e0b33b041e6ee66dc1fc06f7ad75dbd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 290}, "message": "destructor '~MacroDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "98a94d0ab52772b7c22496706ce5db96", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 55, "line": 338}, "message": "destructor '~DefInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "6695a3c66a8a16b80867a37305609dcd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 55, "line": 338}, "message": "move constructor 'DefInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "21d984e9980e72d4da7468eeba3260d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 406}, "message": "destructor '~DefMacroDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "66d962d6618cdceb0f283495ab14eee2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 564}, "message": "move constructor 'MacroDefinition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "dc899dbda5b7a045f8a786194988f944", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 35}, "message": "default constructor 'PPCallbacks' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PPCallbacks.h", "reportHash": "2d223bfcfd0b9c5c330e8a280d313de6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 96}, "message": "destructor '~PragmaNamespace' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "reportHash": "b07552f16b7394a0d65d09d13bdcb57c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 58, "line": 339}, "message": "destructor '~PPEntityID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "6f2960d69202973cb1cf0a3e4df608a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 58, "line": 339}, "message": "move constructor 'PPEntityID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "3ffafbb62c5013b8c203016eee551974", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 58, "line": 430}, "message": "destructor '~iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "fdb500d072c7a5a505c7804eee6aa317", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 58, "line": 430}, "message": "move constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "4a7840105bc99fdec67ef95da15bc192", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 300}, "message": "destructor '~ImportSeq' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "e02e9af5b5ceb7eaa395ff0b12d1e3eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 300}, "message": "move constructor 'ImportSeq' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "79d56bc607be21e563c389ed8bce2573", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 59, "line": 628}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 59, "line": 628}, "message": "move constructor 'MacroState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "2410095840e4c0702be17dab03a0adf5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 59, "line": 632}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 59, "line": 632}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "c6f89eef18fe3965029dd68e0b42e86e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 60, "line": 315}, "message": "default constructor 'PPConditionalInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Token.h", "reportHash": "305c02b121c9ca02e5934e5042ec23a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 1171}, "message": "destructor '~PrintingCodeCompleteConsumer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "d0c0aab5a35316528e6f07dc8c13719d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 15}, "message": "destructor '~CodeCompleteOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h", "reportHash": "638bf1010e5e865b5b28e25f6dd8fb8d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 64}, "message": "destructor '~CXXScopeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "abcb7ec39ab36fec5e482de646964787", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 229}, "message": "destructor '~DeclSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "53c8f1bbdd370cfc28ec56ef5b42c001", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 63, "line": 1173}, "message": "move constructor 'DeclaratorChunk' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "a779903e21758d6e3e4ff8368b3d928f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 63, "line": 1193}, "message": "default constructor 'PointerTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "2d4330a09af6427faca1e15cfa37659a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 63, "line": 1522}, "message": "default constructor 'MemberPointerTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "64afe0b64665ae6cf7ee8d9d2cdf29a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 64, "line": 123}, "message": "destructor '~AvailabilityChange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "565d225d5a5d50698f03e371fc5bc593", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 64, "line": 851}, "message": "destructor '~iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "6e6d48d04dea7f379fee3b13355efb25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 88}, "message": "destructor '~TypeIdx' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "ab1682a9877918cf65cb0f58fe0f6a1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 88}, "message": "move constructor 'TypeIdx' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "7416dcf4f49c37d8d77057ce7ccc3c8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 2054}, "message": "destructor '~DeclarationNameKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "49ece137b3e2bc8f23939fbb0df8ef63", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 2054}, "message": "move constructor 'DeclarationNameKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "d41d7ee1c5809e9e534b0dd027e722f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 169}, "message": "destructor '~Tree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "b6cf8e6a7770f2b171e5921929716917", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 66, "line": 217}, "message": "default constructor 'ChildIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "b8fdc41d8c9adaaf9d97f3cc7b4b1325", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 67, "line": 33}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "43c6feb6e1c8053ed829ec8b57532b18", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 68, "line": 143}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "34a955da5e17ea2c5ab6184b192dbb02", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 73, "line": 28}, "message": "destructor '~CachedHashStringRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "a2256af3b429d6c83fc2bccd7eb89996", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 73, "line": 28}, "message": "move constructor 'CachedHashStringRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "bb504f1798dd7fec63df0950bb39af15", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 73, "line": 87}, "message": "default constructor 'ConstructEmptyOrTombstoneTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "246baceb737b21ec70e994522fae6b06", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 73, "line": 87}, "message": "destructor '~ConstructEmptyOrTombstoneTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "454c76b1a0792c08daa74bea8b3aae31", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 73, "line": 87}, "message": "move constructor 'ConstructEmptyOrTombstoneTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "f4b074714edb3eb3de06e053b02ea54c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 73, "line": 125}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 73, "line": 125}, "message": "move constructor 'CachedHashString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "21c3373134c09b0eec5d25b50d6d8b7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 94, "line": 36}, "message": "destructor '~DynamicLibrary' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h", "reportHash": "f503a98cef492d9680270b195f9793e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 22}, "message": "move constructor 'MemoryBufferRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "reportHash": "e3d15cc54dbe3f1eb13d9736c97b58d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
