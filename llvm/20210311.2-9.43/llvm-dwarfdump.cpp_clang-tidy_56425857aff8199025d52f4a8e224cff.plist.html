<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "content": "//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some templates that are useful if you are working with the\n// STL at all.\n//\n// No library is required when using these functions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STLEXTRAS_H\n#define LLVM_ADT_STLEXTRAS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#ifdef EXPENSIVE_CHECKS\n#include <random> // for std::mt19937\n#endif\n\nnamespace llvm {\n\n// Only used by compiler if both template types are the same.  Useful when\n// using SFINAE to test for the existence of member functions.\ntemplate <typename T, T> struct SameType;\n\nnamespace detail {\n\ntemplate <typename RangeT>\nusing IterOfRange = decltype(std::begin(std::declval<RangeT &>()));\n\ntemplate <typename RangeT>\nusing ValueOfRange = typename std::remove_reference<decltype(\n    *std::begin(std::declval<RangeT &>()))>::type;\n\n} // end namespace detail\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <type_traits>\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T>\nstruct negation : std::integral_constant<bool, !bool(T::value)> {};\n\ntemplate <typename...> struct conjunction : std::true_type {};\ntemplate <typename B1> struct conjunction<B1> : B1 {};\ntemplate <typename B1, typename... Bn>\nstruct conjunction<B1, Bn...>\n    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};\n\ntemplate <typename T> struct make_const_ptr {\n  using type =\n      typename std::add_pointer<typename std::add_const<T>::type>::type;\n};\n\ntemplate <typename T> struct make_const_ref {\n  using type = typename std::add_lvalue_reference<\n      typename std::add_const<T>::type>::type;\n};\n\n/// Utilities for detecting if a given trait holds for some set of arguments\n/// 'Args'. For example, the given trait could be used to detect if a given type\n/// has a copy assignment operator:\n///   template<class T>\n///   using has_copy_assign_t = decltype(std::declval<T&>()\n///                                                 = std::declval<const T&>());\n///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;\nnamespace detail {\ntemplate <typename...> using void_t = void;\ntemplate <class, template <class...> class Op, class... Args> struct detector {\n  using value_t = std::false_type;\n};\ntemplate <template <class...> class Op, class... Args>\nstruct detector<void_t<Op<Args...>>, Op, Args...> {\n  using value_t = std::true_type;\n};\n} // end namespace detail\n\ntemplate <template <class...> class Op, class... Args>\nusing is_detected = typename detail::detector<void, Op, Args...>::value_t;\n\n/// Check if a Callable type can be invoked with the given set of arg types.\nnamespace detail {\ntemplate <typename Callable, typename... Args>\nusing is_invocable =\n    decltype(std::declval<Callable &>()(std::declval<Args>()...));\n} // namespace detail\n\ntemplate <typename Callable, typename... Args>\nusing is_invocable = is_detected<detail::is_invocable, Callable, Args...>;\n\n/// This class provides various trait information about a callable object.\n///   * To access the number of arguments: Traits::num_args\n///   * To access the type of an argument: Traits::arg_t<Index>\n///   * To access the type of the result:  Traits::result_t\ntemplate <typename T, bool isClass = std::is_class<T>::value>\nstruct function_traits : public function_traits<decltype(&T::operator())> {};\n\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...) const, false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t Index>\n  using arg_t = typename std::tuple_element<Index, std::tuple<Args...>>::type;\n};\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...), false>\n    : function_traits<ReturnType (ClassType::*)(Args...) const> {};\n/// Overload for non-class function types.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (*)(Args...), false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t i>\n  using arg_t = typename std::tuple_element<i, std::tuple<Args...>>::type;\n};\n/// Overload for non-class function type references.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (&)(Args...), false>\n    : public function_traits<ReturnType (*)(Args...)> {};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <functional>\n//===----------------------------------------------------------------------===//\n\ntemplate <class Ty> struct identity {\n  using argument_type = Ty;\n\n  Ty &operator()(Ty &self) const {\n    return self;\n  }\n  const Ty &operator()(const Ty &self) const {\n    return self;\n  }\n};\n\n/// An efficient, type-erasing, non-owning reference to a callable. This is\n/// intended for use as the type of a function parameter that is not used\n/// after the function in question returns.\n///\n/// This class does not own the callable, so it is not in general safe to store\n/// a function_ref.\ntemplate<typename Fn> class function_ref;\n\ntemplate<typename Ret, typename ...Params>\nclass function_ref<Ret(Params...)> {\n  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;\n  intptr_t callable;\n\n  template<typename Callable>\n  static Ret callback_fn(intptr_t callable, Params ...params) {\n    return (*reinterpret_cast<Callable*>(callable))(\n        std::forward<Params>(params)...);\n  }\n\npublic:\n  function_ref() = default;\n  function_ref(std::nullptr_t) {}\n\n  template <typename Callable>\n  function_ref(\n      Callable &&callable,\n      // This is not the copy-constructor.\n      std::enable_if_t<\n          !std::is_same<std::remove_cv_t<std::remove_reference_t<Callable>>,\n                        function_ref>::value> * = nullptr,\n      // Functor must be callable and return a suitable type.\n      std::enable_if_t<std::is_void<Ret>::value ||\n                       std::is_convertible<decltype(std::declval<Callable>()(\n                                               std::declval<Params>()...)),\n                                           Ret>::value> * = nullptr)\n      : callback(callback_fn<typename std::remove_reference<Callable>::type>),\n        callable(reinterpret_cast<intptr_t>(&callable)) {}\n\n  Ret operator()(Params ...params) const {\n    return callback(callable, std::forward<Params>(params)...);\n  }\n\n  explicit operator bool() const { return callback; }\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <iterator>\n//===----------------------------------------------------------------------===//\n\nnamespace adl_detail {\n\nusing std::begin;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return begin(std::forward<ContainerTy>(container));\n}\n\nusing std::end;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return end(std::forward<ContainerTy>(container));\n}\n\nusing std::swap;\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),\n                                                       std::declval<T>()))) {\n  swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n} // end namespace adl_detail\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return adl_detail::adl_begin(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return adl_detail::adl_end(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(\n    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {\n  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n/// Test whether \\p RangeOrContainer is empty. Similar to C++17 std::empty.\ntemplate <typename T>\nconstexpr bool empty(const T &RangeOrContainer) {\n  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);\n}\n\n/// Returns true if the given container only contains a single element.\ntemplate <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {\n  auto B = std::begin(C), E = std::end(C);\n  return B != E && std::next(B) == E;\n}\n\n/// Return a range covering \\p RangeOrContainer with the first N elements\n/// excluded.\ntemplate <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {\n  return make_range(std::next(adl_begin(RangeOrContainer), N),\n                    adl_end(RangeOrContainer));\n}\n\n// mapped_iterator - This is a simple iterator adapter that causes a function to\n// be applied whenever operator* is invoked on the iterator.\n\ntemplate <typename ItTy, typename FuncTy,\n          typename FuncReturnTy =\n            decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>\nclass mapped_iterator\n    : public iterator_adaptor_base<\n             mapped_iterator<ItTy, FuncTy>, ItTy,\n             typename std::iterator_traits<ItTy>::iterator_category,\n             typename std::remove_reference<FuncReturnTy>::type> {\npublic:\n  mapped_iterator(ItTy U, FuncTy F)\n    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}\n\n  ItTy getCurrent() { return this->I; }\n\n  FuncReturnTy operator*() const { return F(*this->I); }\n\nprivate:\n  FuncTy F;\n};\n\n// map_iterator - Provide a convenient way to create mapped_iterators, just like\n// make_pair is useful for creating pairs...\ntemplate <class ItTy, class FuncTy>\ninline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {\n  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));\n}\n\ntemplate <class ContainerTy, class FuncTy>\nauto map_range(ContainerTy &&C, FuncTy F) {\n  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));\n}\n\n/// Helper to determine if type T has a member called rbegin().\ntemplate <typename Ty> class has_rbegin_impl {\n  using yes = char[1];\n  using no = char[2];\n\n  template <typename Inner>\n  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);\n\n  template <typename>\n  static no& test(...);\n\npublic:\n  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);\n};\n\n/// Metafunction to determine if T& or T has a member called rbegin().\ntemplate <typename Ty>\nstruct has_rbegin : has_rbegin_impl<typename std::remove_reference<Ty>::type> {\n};\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have rbegin()/rend() methods for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(C.rbegin(), C.rend());\n}\n\n// Returns a std::reverse_iterator wrapped around the given iterator.\ntemplate <typename IteratorTy>\nstd::reverse_iterator<IteratorTy> make_reverse_iterator(IteratorTy It) {\n  return std::reverse_iterator<IteratorTy>(It);\n}\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have begin()/end() methods which return\n// bidirectional iterators for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<!has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(llvm::make_reverse_iterator(std::end(C)),\n                    llvm::make_reverse_iterator(std::begin(C)));\n}\n\n/// An iterator adaptor that filters the elements of given inner iterators.\n///\n/// The predicate parameter should be a callable object that accepts the wrapped\n/// iterator's reference type and returns a bool. When incrementing or\n/// decrementing the iterator, it will call the predicate on each element and\n/// skip any where it returns false.\n///\n/// \\code\n///   int A[] = { 1, 2, 3, 4 };\n///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });\n///   // R contains { 1, 3 }.\n/// \\endcode\n///\n/// Note: filter_iterator_base implements support for forward iteration.\n/// filter_iterator_impl exists to provide support for bidirectional iteration,\n/// conditional on whether the wrapped iterator supports it.\ntemplate <typename WrappedIteratorT, typename PredicateT, typename IterTag>\nclass filter_iterator_base\n    : public iterator_adaptor_base<\n          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n          WrappedIteratorT,\n          typename std::common_type<\n              IterTag, typename std::iterator_traits<\n                           WrappedIteratorT>::iterator_category>::type> {\n  using BaseT = iterator_adaptor_base<\n      filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n      WrappedIteratorT,\n      typename std::common_type<\n          IterTag, typename std::iterator_traits<\n                       WrappedIteratorT>::iterator_category>::type>;\n\nprotected:\n  WrappedIteratorT End;\n  PredicateT Pred;\n\n  void findNextValid() {\n    while (this->I != End && !Pred(*this->I))\n      BaseT::operator++();\n  }\n\n  // Construct the iterator. The begin iterator needs to know where the end\n  // is, so that it can properly stop when it gets there. The end iterator only\n  // needs the predicate to support bidirectional iteration.\n  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin), End(End), Pred(Pred) {\n    findNextValid();\n  }\n\npublic:\n  using BaseT::operator++;\n\n  filter_iterator_base &operator++() {\n    BaseT::operator++();\n    findNextValid();\n    return *this;\n  }\n};\n\n/// Specialization of filter_iterator_base for forward iteration only.\ntemplate <typename WrappedIteratorT, typename PredicateT,\n          typename IterTag = std::forward_iterator_tag>\nclass filter_iterator_impl\n    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>;\n\npublic:\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n};\n\n/// Specialization of filter_iterator_base for bidirectional iteration.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nclass filter_iterator_impl<WrappedIteratorT, PredicateT,\n                           std::bidirectional_iterator_tag>\n    : public filter_iterator_base<WrappedIteratorT, PredicateT,\n                                  std::bidirectional_iterator_tag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT,\n                                     std::bidirectional_iterator_tag>;\n  void findPrevValid() {\n    while (!this->Pred(*this->I))\n      BaseT::operator--();\n  }\n\npublic:\n  using BaseT::operator--;\n\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n\n  filter_iterator_impl &operator--() {\n    BaseT::operator--();\n    findPrevValid();\n    return *this;\n  }\n};\n\nnamespace detail {\n\ntemplate <bool is_bidirectional> struct fwd_or_bidi_tag_impl {\n  using type = std::forward_iterator_tag;\n};\n\ntemplate <> struct fwd_or_bidi_tag_impl<true> {\n  using type = std::bidirectional_iterator_tag;\n};\n\n/// Helper which sets its type member to forward_iterator_tag if the category\n/// of \\p IterT does not derive from bidirectional_iterator_tag, and to\n/// bidirectional_iterator_tag otherwise.\ntemplate <typename IterT> struct fwd_or_bidi_tag {\n  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<\n      std::bidirectional_iterator_tag,\n      typename std::iterator_traits<IterT>::iterator_category>::value>::type;\n};\n\n} // namespace detail\n\n/// Defines filter_iterator to a suitable specialization of\n/// filter_iterator_impl, based on the underlying iterator's category.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nusing filter_iterator = filter_iterator_impl<\n    WrappedIteratorT, PredicateT,\n    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;\n\n/// Convenience function that takes a range of elements and a predicate,\n/// and return a new filter_iterator range.\n///\n/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the\n/// lifetime of that temporary is not kept by the returned range object, and the\n/// temporary is going to be dropped on the floor after the make_iterator_range\n/// full expression that contains this function call.\ntemplate <typename RangeT, typename PredicateT>\niterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>\nmake_filter_range(RangeT &&Range, PredicateT Pred) {\n  using FilterIteratorT =\n      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;\n  return make_range(\n      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred),\n      FilterIteratorT(std::end(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred));\n}\n\n/// A pseudo-iterator adaptor that is designed to implement \"early increment\"\n/// style loops.\n///\n/// This is *not a normal iterator* and should almost never be used directly. It\n/// is intended primarily to be used with range based for loops and some range\n/// algorithms.\n///\n/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but\n/// somewhere between them. The constraints of these iterators are:\n///\n/// - On construction or after being incremented, it is comparable and\n///   dereferencable. It is *not* incrementable.\n/// - After being dereferenced, it is neither comparable nor dereferencable, it\n///   is only incrementable.\n///\n/// This means you can only dereference the iterator once, and you can only\n/// increment it once between dereferences.\ntemplate <typename WrappedIteratorT>\nclass early_inc_iterator_impl\n    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                                   WrappedIteratorT, std::input_iterator_tag> {\n  using BaseT =\n      iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                            WrappedIteratorT, std::input_iterator_tag>;\n\n  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;\n\nprotected:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool IsEarlyIncremented = false;\n#endif\n\npublic:\n  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}\n\n  using BaseT::operator*;\n  decltype(*std::declval<WrappedIteratorT>()) operator*() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!IsEarlyIncremented && \"Cannot dereference twice!\");\n    IsEarlyIncremented = true;\n#endif\n    return *(this->I)++;\n  }\n\n  using BaseT::operator++;\n  early_inc_iterator_impl &operator++() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(IsEarlyIncremented && \"Cannot increment before dereferencing!\");\n    IsEarlyIncremented = false;\n#endif\n    return *this;\n  }\n\n  friend bool operator==(const early_inc_iterator_impl &LHS,\n                         const early_inc_iterator_impl &RHS) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\");\n#endif\n    return (const BaseT &)LHS == (const BaseT &)RHS;\n  }\n};\n\n/// Make a range that does early increment to allow mutation of the underlying\n/// range without disrupting iteration.\n///\n/// The underlying iterator will be incremented immediately after it is\n/// dereferenced, allowing deletion of the current node or insertion of nodes to\n/// not disrupt iteration provided they do not invalidate the *next* iterator --\n/// the current iterator can be invalidated.\n///\n/// This requires a very exact pattern of use that is only really suitable to\n/// range based for loops and other range algorithms that explicitly guarantee\n/// to dereference exactly once each element, and to increment exactly once each\n/// element.\ntemplate <typename RangeT>\niterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>\nmake_early_inc_range(RangeT &&Range) {\n  using EarlyIncIteratorT =\n      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;\n  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\n// forward declarations required by zip_shortest/zip_first/zip_longest\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&range, UnaryPredicate P);\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&range, UnaryPredicate P);\n\nnamespace detail {\n\nusing std::declval;\n\n// We have to alias this since inlining the actual type at the usage site\n// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.\ntemplate<typename... Iters> struct ZipTupleType {\n  using type = std::tuple<decltype(*declval<Iters>())...>;\n};\n\ntemplate <typename ZipType, typename... Iters>\nusing zip_traits = iterator_facade_base<\n    ZipType, typename std::common_type<std::bidirectional_iterator_tag,\n                                       typename std::iterator_traits<\n                                           Iters>::iterator_category...>::type,\n    // ^ TODO: Implement random access methods.\n    typename ZipTupleType<Iters...>::type,\n    typename std::iterator_traits<typename std::tuple_element<\n        0, std::tuple<Iters...>>::type>::difference_type,\n    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all\n    // inner iterators have the same difference_type. It would fail if, for\n    // instance, the second field's difference_type were non-numeric while the\n    // first is.\n    typename ZipTupleType<Iters...>::type *,\n    typename ZipTupleType<Iters...>::type>;\n\ntemplate <typename ZipType, typename... Iters>\nstruct zip_common : public zip_traits<ZipType, Iters...> {\n  using Base = zip_traits<ZipType, Iters...>;\n  using value_type = typename Base::value_type;\n\n  std::tuple<Iters...> iterators;\n\nprotected:\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(*std::get<Ns>(iterators)...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);\n  }\n\npublic:\n  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  const value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  ZipType &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n\n  ZipType &operator--() {\n    static_assert(Base::IsBidirectional,\n                  \"All inner iterators must be at least bidirectional.\");\n    iterators = tup_dec(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n};\n\ntemplate <typename... Iters>\nstruct zip_first : public zip_common<zip_first<Iters...>, Iters...> {\n  using Base = zip_common<zip_first<Iters...>, Iters...>;\n\n  bool operator==(const zip_first<Iters...> &other) const {\n    return std::get<0>(this->iterators) == std::get<0>(other.iterators);\n  }\n\n  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n};\n\ntemplate <typename... Iters>\nclass zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {\n  template <size_t... Ns>\n  bool test(const zip_shortest<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                              std::get<Ns>(other.iterators)...},\n                  identity<bool>{});\n  }\n\npublic:\n  using Base = zip_common<zip_shortest<Iters...>, Iters...>;\n\n  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n\n  bool operator==(const zip_shortest<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <template <typename...> class ItType, typename... Args> class zippy {\npublic:\n  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::begin(std::get<Ns>(ts))...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::end(std::get<Ns>(ts))...);\n  }\n\npublic:\n  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n\n} // end namespace detail\n\n/// zip iterator for two or more iteratable types.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,\n                                                       Args &&... args) {\n  return detail::zippy<detail::zip_shortest, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// zip iterator that, for the sake of efficiency, assumes the first iteratee to\n/// be the shortest.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,\n                                                          Args &&... args) {\n  return detail::zippy<detail::zip_first, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\nnamespace detail {\ntemplate <typename Iter>\nIter next_or_end(const Iter &I, const Iter &End) {\n  if (I == End)\n    return End;\n  return std::next(I);\n}\n\ntemplate <typename Iter>\nauto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<\n    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {\n  if (I == End)\n    return None;\n  return *I;\n}\n\ntemplate <typename Iter> struct ZipLongestItemType {\n  using type =\n      llvm::Optional<typename std::remove_const<typename std::remove_reference<\n          decltype(*std::declval<Iter>())>::type>::type>;\n};\n\ntemplate <typename... Iters> struct ZipLongestTupleType {\n  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;\n};\n\ntemplate <typename... Iters>\nclass zip_longest_iterator\n    : public iterator_facade_base<\n          zip_longest_iterator<Iters...>,\n          typename std::common_type<\n              std::forward_iterator_tag,\n              typename std::iterator_traits<Iters>::iterator_category...>::type,\n          typename ZipLongestTupleType<Iters...>::type,\n          typename std::iterator_traits<typename std::tuple_element<\n              0, std::tuple<Iters...>>::type>::difference_type,\n          typename ZipLongestTupleType<Iters...>::type *,\n          typename ZipLongestTupleType<Iters...>::type> {\npublic:\n  using value_type = typename ZipLongestTupleType<Iters...>::type;\n\nprivate:\n  std::tuple<Iters...> iterators;\n  std::tuple<Iters...> end_iterators;\n\n  template <size_t... Ns>\n  bool test(const zip_longest_iterator<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return llvm::any_of(\n        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                    std::get<Ns>(other.iterators)...},\n        identity<bool>{});\n  }\n\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(\n        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(\n        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\npublic:\n  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)\n      : iterators(std::forward<Iters>(ts.first)...),\n        end_iterators(std::forward<Iters>(ts.second)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  zip_longest_iterator<Iters...> &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *this;\n  }\n\n  bool operator==(const zip_longest_iterator<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <typename... Args> class zip_longest_range {\npublic:\n  using iterator =\n      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\npublic:\n  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n} // namespace detail\n\n/// Iterate over two or more iterators at the same time. Iteration continues\n/// until all iterators reach the end. The llvm::Optional only contains a value\n/// if the iterator has not reached the end.\ntemplate <typename T, typename U, typename... Args>\ndetail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,\n                                                     Args &&... args) {\n  return detail::zip_longest_range<T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// Iterator wrapper that concatenates sequences together.\n///\n/// This can concatenate different iterators, even with different types, into\n/// a single iterator provided the value types of all the concatenated\n/// iterators expose `reference` and `pointer` types that can be converted to\n/// `ValueT &` and `ValueT *` respectively. It doesn't support more\n/// interesting/customized pointer or reference types.\n///\n/// Currently this only supports forward or higher iterator categories as\n/// inputs and always exposes a forward iterator interface.\ntemplate <typename ValueT, typename... IterTs>\nclass concat_iterator\n    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,\n                                  std::forward_iterator_tag, ValueT> {\n  using BaseT = typename concat_iterator::iterator_facade_base;\n\n  /// We store both the current and end iterators for each concatenated\n  /// sequence in a tuple of pairs.\n  ///\n  /// Note that something like iterator_range seems nice at first here, but the\n  /// range properties are of little benefit and end up getting in the way\n  /// because we need to do mutation on the current iterators.\n  std::tuple<IterTs...> Begins;\n  std::tuple<IterTs...> Ends;\n\n  /// Attempts to increment a specific iterator.\n  ///\n  /// Returns true if it was able to increment the iterator. Returns false if\n  /// the iterator is already at the end iterator.\n  template <size_t Index> bool incrementHelper() {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return false;\n\n    ++Begin;\n    return true;\n  }\n\n  /// Increments the first non-end iterator.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {\n    // Build a sequence of functions to increment each iterator if possible.\n    bool (concat_iterator::*IncrementHelperFns[])() = {\n        &concat_iterator::incrementHelper<Ns>...};\n\n    // Loop over them, and stop as soon as we succeed at incrementing one.\n    for (auto &IncrementHelperFn : IncrementHelperFns)\n      if ((this->*IncrementHelperFn)())\n        return;\n\n    llvm_unreachable(\"Attempted to increment an end concat iterator!\");\n  }\n\n  /// Returns null if the specified iterator is at the end. Otherwise,\n  /// dereferences the iterator and returns the address of the resulting\n  /// reference.\n  template <size_t Index> ValueT *getHelper() const {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return nullptr;\n\n    return &*Begin;\n  }\n\n  /// Finds the first non-end iterator, dereferences, and returns the resulting\n  /// reference.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {\n    // Build a sequence of functions to get from iterator if possible.\n    ValueT *(concat_iterator::*GetHelperFns[])() const = {\n        &concat_iterator::getHelper<Ns>...};\n\n    // Loop over them, and return the first result we find.\n    for (auto &GetHelperFn : GetHelperFns)\n      if (ValueT *P = (this->*GetHelperFn)())\n        return *P;\n\n    llvm_unreachable(\"Attempted to get a pointer from an end concat iterator!\");\n  }\n\npublic:\n  /// Constructs an iterator from a sequence of ranges.\n  ///\n  /// We need the full range to know how to switch between each of the\n  /// iterators.\n  template <typename... RangeTs>\n  explicit concat_iterator(RangeTs &&... Ranges)\n      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}\n\n  using BaseT::operator++;\n\n  concat_iterator &operator++() {\n    increment(std::index_sequence_for<IterTs...>());\n    return *this;\n  }\n\n  ValueT &operator*() const {\n    return get(std::index_sequence_for<IterTs...>());\n  }\n\n  bool operator==(const concat_iterator &RHS) const {\n    return Begins == RHS.Begins && Ends == RHS.Ends;\n  }\n};\n\nnamespace detail {\n\n/// Helper to store a sequence of ranges being concatenated and access them.\n///\n/// This is designed to facilitate providing actual storage when temporaries\n/// are passed into the constructor such that we can use it as part of range\n/// based for loops.\ntemplate <typename ValueT, typename... RangeTs> class concat_range {\npublic:\n  using iterator =\n      concat_iterator<ValueT,\n                      decltype(std::begin(std::declval<RangeTs &>()))...>;\n\nprivate:\n  std::tuple<RangeTs...> Ranges;\n\n  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {\n    return iterator(std::get<Ns>(Ranges)...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {\n    return iterator(make_range(std::end(std::get<Ns>(Ranges)),\n                               std::end(std::get<Ns>(Ranges)))...);\n  }\n\npublic:\n  concat_range(RangeTs &&... Ranges)\n      : Ranges(std::forward<RangeTs>(Ranges)...) {}\n\n  iterator begin() { return begin_impl(std::index_sequence_for<RangeTs...>{}); }\n  iterator end() { return end_impl(std::index_sequence_for<RangeTs...>{}); }\n};\n\n} // end namespace detail\n\n/// Concatenated range across two or more ranges.\n///\n/// The desired value type must be explicitly specified.\ntemplate <typename ValueT, typename... RangeTs>\ndetail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {\n  static_assert(sizeof...(RangeTs) > 1,\n                \"Need more than one range to concatenate!\");\n  return detail::concat_range<ValueT, RangeTs...>(\n      std::forward<RangeTs>(Ranges)...);\n}\n\n/// A utility class used to implement an iterator that contains some base object\n/// and an index. The iterator moves the index but keeps the base constant.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_iterator\n    : public llvm::iterator_facade_base<DerivedT,\n                                        std::random_access_iterator_tag, T,\n                                        std::ptrdiff_t, PointerT, ReferenceT> {\npublic:\n  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index - rhs.index;\n  }\n  bool operator==(const indexed_accessor_iterator &rhs) const {\n    return base == rhs.base && index == rhs.index;\n  }\n  bool operator<(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index < rhs.index;\n  }\n\n  DerivedT &operator+=(ptrdiff_t offset) {\n    this->index += offset;\n    return static_cast<DerivedT &>(*this);\n  }\n  DerivedT &operator-=(ptrdiff_t offset) {\n    this->index -= offset;\n    return static_cast<DerivedT &>(*this);\n  }\n\n  /// Returns the current index of the iterator.\n  ptrdiff_t getIndex() const { return index; }\n\n  /// Returns the current base of the iterator.\n  const BaseT &getBase() const { return base; }\n\nprotected:\n  indexed_accessor_iterator(BaseT base, ptrdiff_t index)\n      : base(base), index(index) {}\n  BaseT base;\n  ptrdiff_t index;\n};\n\nnamespace detail {\n/// The class represents the base of a range of indexed_accessor_iterators. It\n/// provides support for many different range functionalities, e.g.\n/// drop_front/slice/etc.. Derived range classes must implement the following\n/// static methods:\n///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to the base object at the given\n///       index.\n///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n///     - Return a new base that is offset from the provide base by 'index'\n///       elements.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range_base {\npublic:\n  using RangeBaseT =\n      indexed_accessor_range_base<DerivedT, BaseT, T, PointerT, ReferenceT>;\n\n  /// An iterator element of this range.\n  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,\n                                                    PointerT, ReferenceT> {\n  public:\n    // Index into this iterator, invoking a static method on the derived type.\n    ReferenceT operator*() const {\n      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());\n    }\n\n  private:\n    iterator(BaseT owner, ptrdiff_t curIndex)\n        : indexed_accessor_iterator<iterator, BaseT, T, PointerT, ReferenceT>(\n              owner, curIndex) {}\n\n    /// Allow access to the constructor.\n    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,\n                                       ReferenceT>;\n  };\n\n  indexed_accessor_range_base(iterator begin, iterator end)\n      : base(offset_base(begin.getBase(), begin.getIndex())),\n        count(end.getIndex() - begin.getIndex()) {}\n  indexed_accessor_range_base(const iterator_range<iterator> &range)\n      : indexed_accessor_range_base(range.begin(), range.end()) {}\n  indexed_accessor_range_base(BaseT base, ptrdiff_t count)\n      : base(base), count(count) {}\n\n  iterator begin() const { return iterator(base, 0); }\n  iterator end() const { return iterator(base, count); }\n  ReferenceT operator[](size_t Index) const {\n    assert(Index < size() && \"invalid index for value range\");\n    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));\n  }\n  ReferenceT front() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[0];\n  }\n  ReferenceT back() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[size() - 1];\n  }\n\n  /// Compare this range with another.\n  template <typename OtherT> bool operator==(const OtherT &other) const {\n    return size() ==\n               static_cast<size_t>(std::distance(other.begin(), other.end())) &&\n           std::equal(begin(), end(), other.begin());\n  }\n  template <typename OtherT> bool operator!=(const OtherT &other) const {\n    return !(*this == other);\n  }\n\n  /// Return the size of this range.\n  size_t size() const { return count; }\n\n  /// Return if the range is empty.\n  bool empty() const { return size() == 0; }\n\n  /// Drop the first N elements, and keep M elements.\n  DerivedT slice(size_t n, size_t m) const {\n    assert(n + m <= size() && \"invalid size specifiers\");\n    return DerivedT(offset_base(base, n), m);\n  }\n\n  /// Drop the first n elements.\n  DerivedT drop_front(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return slice(n, size() - n);\n  }\n  /// Drop the last n elements.\n  DerivedT drop_back(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return DerivedT(base, size() - n);\n  }\n\n  /// Take the first n elements.\n  DerivedT take_front(size_t n = 1) const {\n    return n < size() ? drop_back(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Take the last n elements.\n  DerivedT take_back(size_t n = 1) const {\n    return n < size() ? drop_front(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Allow conversion to any type accepting an iterator_range.\n  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<\n                                 RangeT, iterator_range<iterator>>::value>>\n  operator RangeT() const {\n    return RangeT(iterator_range<iterator>(*this));\n  }\n\n  /// Returns the base of this range.\n  const BaseT &getBase() const { return base; }\n\nprivate:\n  /// Offset the given base by the given amount.\n  static BaseT offset_base(const BaseT &base, size_t n) {\n    return n == 0 ? base : DerivedT::offset_base(base, n);\n  }\n\nprotected:\n  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;\n  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;\n  indexed_accessor_range_base &\n  operator=(const indexed_accessor_range_base &) = default;\n\n  /// The base that owns the provided range of values.\n  BaseT base;\n  /// The size from the owning range.\n  ptrdiff_t count;\n};\n} // end namespace detail\n\n/// This class provides an implementation of a range of\n/// indexed_accessor_iterators where the base is not indexable. Ranges with\n/// bases that are offsetable should derive from indexed_accessor_range_base\n/// instead. Derived range classes are expected to implement the following\n/// static method:\n///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to a parent base at the given index.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range\n    : public detail::indexed_accessor_range_base<\n          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {\npublic:\n  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)\n      : detail::indexed_accessor_range_base<\n            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(\n            std::make_pair(base, startIndex), count) {}\n  using detail::indexed_accessor_range_base<\n      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,\n      ReferenceT>::indexed_accessor_range_base;\n\n  /// Returns the current base of the range.\n  const BaseT &getBase() const { return this->base.first; }\n\n  /// Returns the current start index of the range.\n  ptrdiff_t getStartIndex() const { return this->base.second; }\n\n  /// See `detail::indexed_accessor_range_base` for details.\n  static std::pair<BaseT, ptrdiff_t>\n  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {\n    // We encode the internal base as a pair of the derived base and a start\n    // index into the derived base.\n    return std::make_pair(base.first, base.second + index);\n  }\n  /// See `detail::indexed_accessor_range_base` for details.\n  static ReferenceT\n  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,\n                       ptrdiff_t index) {\n    return DerivedT::dereference(base.first, base.second + index);\n  }\n};\n\n/// Given a container of pairs, return a range over the first elements.\ntemplate <typename ContainerTy> auto make_first_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.first)) {\n        return elt.first;\n      });\n}\n\n/// Given a container of pairs, return a range over the second elements.\ntemplate <typename ContainerTy> auto make_second_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.second)) {\n        return elt.second;\n      });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <utility>\n//===----------------------------------------------------------------------===//\n\n/// Function object to check whether the first component of a std::pair\n/// compares less than the first component of another std::pair.\nstruct less_first {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.first < rhs.first;\n  }\n};\n\n/// Function object to check whether the second component of a std::pair\n/// compares less than the second component of another std::pair.\nstruct less_second {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.second < rhs.second;\n  }\n};\n\n/// \\brief Function object to apply a binary function to the first component of\n/// a std::pair.\ntemplate<typename FuncTy>\nstruct on_first {\n  FuncTy func;\n\n  template <typename T>\n  decltype(auto) operator()(const T &lhs, const T &rhs) const {\n    return func(lhs.first, rhs.first);\n  }\n};\n\n/// Utility type to build an inheritance chain that makes it easy to rank\n/// overload candidates.\ntemplate <int N> struct rank : rank<N - 1> {};\ntemplate <> struct rank<0> {};\n\n/// traits class for checking whether type T is one of any of the given\n/// types in the variadic list.\ntemplate <typename T, typename... Ts> struct is_one_of {\n  static const bool value = false;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct is_one_of<T, U, Ts...> {\n  static const bool value =\n      std::is_same<T, U>::value || is_one_of<T, Ts...>::value;\n};\n\n/// traits class for checking whether type T is a base class for all\n///  the given types in the variadic list.\ntemplate <typename T, typename... Ts> struct are_base_of {\n  static const bool value = true;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct are_base_of<T, U, Ts...> {\n  static const bool value =\n      std::is_base_of<T, U>::value && are_base_of<T, Ts...>::value;\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions for arrays\n//===----------------------------------------------------------------------===//\n\n// We have a copy here so that LLVM behaves the same when using different\n// standard libraries.\ntemplate <class Iterator, class RNG>\nvoid shuffle(Iterator first, Iterator last, RNG &&g) {\n  // It would be better to use a std::uniform_int_distribution,\n  // but that would be stdlib dependent.\n  typedef\n      typename std::iterator_traits<Iterator>::difference_type difference_type;\n  for (auto size = last - first; size > 1; ++first, (void)--size) {\n    difference_type offset = g() % size;\n    // Avoid self-assignment due to incorrect assertions in libstdc++\n    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).\n    if (offset != difference_type(0))\n      std::iter_swap(first, first + offset);\n  }\n}\n\n/// Find the length of an array.\ntemplate <class T, std::size_t N>\nconstexpr inline size_t array_lengthof(T (&)[N]) {\n  return N;\n}\n\n/// Adapt std::less<T> for array_pod_sort.\ntemplate<typename T>\ninline int array_pod_sort_comparator(const void *P1, const void *P2) {\n  if (std::less<T>()(*reinterpret_cast<const T*>(P1),\n                     *reinterpret_cast<const T*>(P2)))\n    return -1;\n  if (std::less<T>()(*reinterpret_cast<const T*>(P2),\n                     *reinterpret_cast<const T*>(P1)))\n    return 1;\n  return 0;\n}\n\n/// get_array_pod_sort_comparator - This is an internal helper function used to\n/// get type deduction of T right.\ntemplate<typename T>\ninline int (*get_array_pod_sort_comparator(const T &))\n             (const void*, const void*) {\n  return array_pod_sort_comparator<T>;\n}\n\n#ifdef EXPENSIVE_CHECKS\nnamespace detail {\n\ninline unsigned presortShuffleEntropy() {\n  static unsigned Result(std::random_device{}());\n  return Result;\n}\n\ntemplate <class IteratorTy>\ninline void presortShuffle(IteratorTy Start, IteratorTy End) {\n  std::mt19937 Generator(presortShuffleEntropy());\n  llvm::shuffle(Start, End, Generator);\n}\n\n} // end namespace detail\n#endif\n\n/// array_pod_sort - This sorts an array with the specified start and end\n/// extent.  This is just like std::sort, except that it calls qsort instead of\n/// using an inlined template.  qsort is slightly slower than std::sort, but\n/// most sorts are not performance critical in LLVM and std::sort has to be\n/// template instantiated for each type, leading to significant measured code\n/// bloat.  This function should generally be used instead of std::sort where\n/// possible.\n///\n/// This function assumes that you have simple POD-like types that can be\n/// compared with std::less and can be moved with memcpy.  If this isn't true,\n/// you should use std::sort.\n///\n/// NOTE: If qsort_r were portable, we could allow a custom comparator and\n/// default to std::less.\ntemplate<class IteratorTy>\ninline void array_pod_sort(IteratorTy Start, IteratorTy End) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));\n}\n\ntemplate <class IteratorTy>\ninline void array_pod_sort(\n    IteratorTy Start, IteratorTy End,\n    int (*Compare)(\n        const typename std::iterator_traits<IteratorTy>::value_type *,\n        const typename std::iterator_traits<IteratorTy>::value_type *)) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start),\n        reinterpret_cast<int (*)(const void *, const void *)>(Compare));\n}\n\nnamespace detail {\ntemplate <typename T>\n// We can use qsort if the iterator type is a pointer and the underlying value\n// is trivially copyable.\nusing sort_trivially_copyable = conjunction<\n    std::is_pointer<T>,\n    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;\n} // namespace detail\n\n// Provide wrappers to std::sort which shuffle the elements before sorting\n// to help uncover non-deterministic behavior (PR35135).\ntemplate <typename IteratorTy,\n          std::enable_if_t<!detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End);\n}\n\n// Forward trivially copyable types to array_pod_sort. This avoids a large\n// amount of code bloat for a minor performance hit.\ntemplate <typename IteratorTy,\n          std::enable_if_t<detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n  array_pod_sort(Start, End);\n}\n\ntemplate <typename Container> inline void sort(Container &&C) {\n  llvm::sort(adl_begin(C), adl_end(C));\n}\n\ntemplate <typename IteratorTy, typename Compare>\ninline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End, Comp);\n}\n\ntemplate <typename Container, typename Compare>\ninline void sort(Container &&C, Compare Comp) {\n  llvm::sort(adl_begin(C), adl_end(C), Comp);\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <algorithm>\n//===----------------------------------------------------------------------===//\n\n/// Get the size of a range. This is a wrapper function around std::distance\n/// which is only enabled when the operation is O(1).\ntemplate <typename R>\nauto size(R &&Range,\n          std::enable_if_t<\n              std::is_base_of<std::random_access_iterator_tag,\n                              typename std::iterator_traits<decltype(\n                                  Range.begin())>::iterator_category>::value,\n              void> * = nullptr) {\n  return std::distance(Range.begin(), Range.end());\n}\n\n/// Provide wrappers to std::for_each which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryFunction>\nUnaryFunction for_each(R &&Range, UnaryFunction F) {\n  return std::for_each(adl_begin(Range), adl_end(Range), F);\n}\n\n/// Provide wrappers to std::all_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&Range, UnaryPredicate P) {\n  return std::all_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::any_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&Range, UnaryPredicate P) {\n  return std::any_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::none_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool none_of(R &&Range, UnaryPredicate P) {\n  return std::none_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::find which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename T> auto find(R &&Range, const T &Val) {\n  return std::find(adl_begin(Range), adl_end(Range), Val);\n}\n\n/// Provide wrappers to std::find_if which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto find_if(R &&Range, UnaryPredicate P) {\n  return std::find_if(adl_begin(Range), adl_end(Range), P);\n}\n\ntemplate <typename R, typename UnaryPredicate>\nauto find_if_not(R &&Range, UnaryPredicate P) {\n  return std::find_if_not(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::remove_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto remove_if(R &&Range, UnaryPredicate P) {\n  return std::remove_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::copy_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt, typename UnaryPredicate>\nOutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {\n  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);\n}\n\ntemplate <typename R, typename OutputIt>\nOutputIt copy(R &&Range, OutputIt Out) {\n  return std::copy(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Provide wrappers to std::move which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt>\nOutputIt move(R &&Range, OutputIt Out) {\n  return std::move(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Wrapper function around std::find to detect if an element exists\n/// in a container.\ntemplate <typename R, typename E>\nbool is_contained(R &&Range, const E &Element) {\n  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted with respect to a comparator \\p C.\ntemplate <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted in non-descending order.\ntemplate <typename R> bool is_sorted(R &&Range) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range));\n}\n\n/// Wrapper function around std::count to count the number of times an element\n/// \\p Element occurs in the given range \\p Range.\ntemplate <typename R, typename E> auto count(R &&Range, const E &Element) {\n  return std::count(adl_begin(Range), adl_end(Range), Element);\n}\n\n/// Wrapper function around std::count_if to count the number of times an\n/// element satisfying a given predicate occurs in a range.\ntemplate <typename R, typename UnaryPredicate>\nauto count_if(R &&Range, UnaryPredicate P) {\n  return std::count_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::transform to apply a function to a range and\n/// store the result elsewhere.\ntemplate <typename R, typename OutputIt, typename UnaryFunction>\nOutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {\n  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);\n}\n\n/// Provide wrappers to std::partition which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto partition(R &&Range, UnaryPredicate P) {\n  return std::partition(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::lower_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto lower_bound(R &&Range, T &&Value, Compare C) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\n/// Provide wrappers to std::upper_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto upper_bound(R &&Range, T &&Value, Compare C) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\ntemplate <typename R>\nvoid stable_sort(R &&Range) {\n  std::stable_sort(adl_begin(Range), adl_end(Range));\n}\n\ntemplate <typename R, typename Compare>\nvoid stable_sort(R &&Range, Compare C) {\n  std::stable_sort(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Binary search for the first iterator in a range where a predicate is false.\n/// Requires that C is always true below some limit, and always false above it.\ntemplate <typename R, typename Predicate,\n          typename Val = decltype(*adl_begin(std::declval<R>()))>\nauto partition_point(R &&Range, Predicate P) {\n  return std::partition_point(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::equal to detect if all elements\n/// in a container are same.\ntemplate <typename R>\nbool is_splat(R &&Range) {\n  size_t range_size = size(Range);\n  return range_size != 0 && (range_size == 1 ||\n         std::equal(adl_begin(Range) + 1, adl_end(Range), adl_begin(Range)));\n}\n\n/// Provide a container algorithm similar to C++ Library Fundamentals v2's\n/// `erase_if` which is equivalent to:\n///\n///   C.erase(remove_if(C, pred), C.end());\n///\n/// This version works for any container with an erase method call accepting\n/// two iterators.\ntemplate <typename Container, typename UnaryPredicate>\nvoid erase_if(Container &C, UnaryPredicate P) {\n  C.erase(remove_if(C, P), C.end());\n}\n\n/// Wrapper function to remove a value from a container:\n///\n/// C.erase(remove(C.begin(), C.end(), V), C.end());\ntemplate <typename Container, typename ValueType>\nvoid erase_value(Container &C, ValueType V) {\n  C.erase(std::remove(C.begin(), C.end(), V), C.end());\n}\n\n/// Wrapper function to append a range to a container.\n///\n/// C.insert(C.end(), R.begin(), R.end());\ntemplate <typename Container, typename Range>\ninline void append_range(Container &C, Range &&R) {\n  C.insert(C.end(), R.begin(), R.end());\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range [ValIt, ValEnd) (which is not from the same container).\ntemplate<typename Container, typename RandomAccessIterator>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, RandomAccessIterator ValIt,\n             RandomAccessIterator ValEnd) {\n  while (true) {\n    if (ValIt == ValEnd) {\n      Cont.erase(ContIt, ContEnd);\n      return;\n    } else if (ContIt == ContEnd) {\n      Cont.insert(ContIt, ValIt, ValEnd);\n      return;\n    }\n    *ContIt++ = *ValIt++;\n  }\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range R.\ntemplate<typename Container, typename Range = std::initializer_list<\n                                 typename Container::value_type>>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, Range R) {\n  replace(Cont, ContIt, ContEnd, R.begin(), R.end());\n}\n\n/// An STL-style algorithm similar to std::for_each that applies a second\n/// functor between every pair of elements.\n///\n/// This provides the control flow logic to, for example, print a\n/// comma-separated list:\n/// \\code\n///   interleave(names.begin(), names.end(),\n///              [&](StringRef name) { os << name; },\n///              [&] { os << \", \"; });\n/// \\endcode\ntemplate <typename ForwardIterator, typename UnaryFunctor,\n          typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(ForwardIterator begin, ForwardIterator end,\n                       UnaryFunctor each_fn, NullaryFunctor between_fn) {\n  if (begin == end)\n    return;\n  each_fn(*begin);\n  ++begin;\n  for (; begin != end; ++begin) {\n    between_fn();\n    each_fn(*begin);\n  }\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(const Container &c, UnaryFunctor each_fn,\n                       NullaryFunctor between_fn) {\n  interleave(c.begin(), c.end(), each_fn, between_fn);\n}\n\n/// Overload of interleave for the common case of string separator.\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,\n                       const StringRef &separator) {\n  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os,\n                       const StringRef &separator) {\n  interleave(\n      c, os, [&](const T &a) { os << a; }, separator);\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os,\n                            UnaryFunctor each_fn) {\n  interleave(c, os, each_fn, \", \");\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os) {\n  interleaveComma(c, os, [&](const T &a) { os << a; });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <memory>\n//===----------------------------------------------------------------------===//\n\nstruct FreeDeleter {\n  void operator()(void* v) {\n    ::free(v);\n  }\n};\n\ntemplate<typename First, typename Second>\nstruct pair_hash {\n  size_t operator()(const std::pair<First, Second> &P) const {\n    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);\n  }\n};\n\n/// Binary functor that adapts to any other binary functor after dereferencing\n/// operands.\ntemplate <typename T> struct deref {\n  T func;\n\n  // Could be further improved to cope with non-derivable functors and\n  // non-binary functors (should be a variadic template member function\n  // operator()).\n  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {\n    assert(lhs);\n    assert(rhs);\n    return func(*lhs, *rhs);\n  }\n};\n\nnamespace detail {\n\ntemplate <typename R> class enumerator_iter;\n\ntemplate <typename R> struct result_pair {\n  using value_reference =\n      typename std::iterator_traits<IterOfRange<R>>::reference;\n\n  friend class enumerator_iter<R>;\n\n  result_pair() = default;\n  result_pair(std::size_t Index, IterOfRange<R> Iter)\n      : Index(Index), Iter(Iter) {}\n\n  result_pair(const result_pair<R> &Other)\n      : Index(Other.Index), Iter(Other.Iter) {}\n  result_pair &operator=(const result_pair &Other) {\n    Index = Other.Index;\n    Iter = Other.Iter;\n    return *this;\n  }\n\n  std::size_t index() const { return Index; }\n  const value_reference value() const { return *Iter; }\n  value_reference value() { return *Iter; }\n\nprivate:\n  std::size_t Index = std::numeric_limits<std::size_t>::max();\n  IterOfRange<R> Iter;\n};\n\ntemplate <typename R>\nclass enumerator_iter\n    : public iterator_facade_base<\n          enumerator_iter<R>, std::forward_iterator_tag, result_pair<R>,\n          typename std::iterator_traits<IterOfRange<R>>::difference_type,\n          typename std::iterator_traits<IterOfRange<R>>::pointer,\n          typename std::iterator_traits<IterOfRange<R>>::reference> {\n  using result_type = result_pair<R>;\n\npublic:\n  explicit enumerator_iter(IterOfRange<R> EndIter)\n      : Result(std::numeric_limits<size_t>::max(), EndIter) {}\n\n  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)\n      : Result(Index, Iter) {}\n\n  result_type &operator*() { return Result; }\n  const result_type &operator*() const { return Result; }\n\n  enumerator_iter &operator++() {\n    assert(Result.Index != std::numeric_limits<size_t>::max());\n    ++Result.Iter;\n    ++Result.Index;\n    return *this;\n  }\n\n  bool operator==(const enumerator_iter &RHS) const {\n    // Don't compare indices here, only iterators.  It's possible for an end\n    // iterator to have different indices depending on whether it was created\n    // by calling std::end() versus incrementing a valid iterator.\n    return Result.Iter == RHS.Result.Iter;\n  }\n\n  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}\n  enumerator_iter &operator=(const enumerator_iter &Other) {\n    Result = Other.Result;\n    return *this;\n  }\n\nprivate:\n  result_type Result;\n};\n\ntemplate <typename R> class enumerator {\npublic:\n  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}\n\n  enumerator_iter<R> begin() {\n    return enumerator_iter<R>(0, std::begin(TheRange));\n  }\n\n  enumerator_iter<R> end() {\n    return enumerator_iter<R>(std::end(TheRange));\n  }\n\nprivate:\n  R TheRange;\n};\n\n} // end namespace detail\n\n/// Given an input range, returns a new range whose values are are pair (A,B)\n/// such that A is the 0-based index of the item in the sequence, and B is\n/// the value from the original sequence.  Example:\n///\n/// std::vector<char> Items = {'A', 'B', 'C', 'D'};\n/// for (auto X : enumerate(Items)) {\n///   printf(\"Item %d - %c\\n\", X.index(), X.value());\n/// }\n///\n/// Output:\n///   Item 0 - A\n///   Item 1 - B\n///   Item 2 - C\n///   Item 3 - D\n///\ntemplate <typename R> detail::enumerator<R> enumerate(R &&TheRange) {\n  return detail::enumerator<R>(std::forward<R>(TheRange));\n}\n\nnamespace detail {\n\ntemplate <typename F, typename Tuple, std::size_t... I>\ndecltype(auto) apply_tuple_impl(F &&f, Tuple &&t, std::index_sequence<I...>) {\n  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);\n}\n\n} // end namespace detail\n\n/// Given an input tuple (a1, a2, ..., an), pass the arguments of the\n/// tuple variadically to f as if by calling f(a1, a2, ..., an) and\n/// return the result.\ntemplate <typename F, typename Tuple>\ndecltype(auto) apply_tuple(F &&f, Tuple &&t) {\n  using Indices = std::make_index_sequence<\n      std::tuple_size<typename std::decay<Tuple>::type>::value>;\n\n  return detail::apply_tuple_impl(std::forward<F>(f), std::forward<Tuple>(t),\n                                  Indices{});\n}\n\n/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to filter lazily some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItems(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  for (; Begin != End; ++Begin)\n    if (ShouldBeCounted(*Begin))\n      return false; // Too many.\n  return true;\n}\n\n/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrMore(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  return true;\n}\n\n/// Returns true if the sequence [Begin, End) has N or less items. Can\n/// optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrLess(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {\n      return true;\n    }) {\n  assert(N != std::numeric_limits<unsigned>::max());\n  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);\n}\n\n/// Returns true if the given container has exactly N items\ntemplate <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {\n  return hasNItems(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or more items\ntemplate <typename ContainerTy>\nbool hasNItemsOrMore(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrMore(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or less items\ntemplate <typename ContainerTy>\nbool hasNItemsOrLess(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrLess(std::begin(C), std::end(C), N);\n}\n\n/// Returns a raw pointer that represents the same address as the argument.\n///\n/// This implementation can be removed once we move to C++20 where it's defined\n/// as std::to_address().\n///\n/// The std::pointer_traits<>::to_address(p) variations of these overloads has\n/// not been implemented.\ntemplate <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }\ntemplate <class T> constexpr T *to_address(T *P) { return P; }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STLEXTRAS_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "content": "//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAP_H\n#define LLVM_ADT_STRINGMAP_H\n\n#include \"llvm/ADT/StringMapEntry.h\"\n#include \"llvm/Support/AllocatorBase.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <initializer_list>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename ValueTy> class StringMapConstIterator;\ntemplate <typename ValueTy> class StringMapIterator;\ntemplate <typename ValueTy> class StringMapKeyIterator;\n\n/// StringMapImpl - This is the base class of StringMap that is shared among\n/// all of its instantiations.\nclass StringMapImpl {\nprotected:\n  // Array of NumBuckets pointers to entries, null pointers are holes.\n  // TheTable[NumBuckets] contains a sentinel value for easy iteration. Followed\n  // by an array of the actual hash values as unsigned integers.\n  StringMapEntryBase **TheTable = nullptr;\n  unsigned NumBuckets = 0;\n  unsigned NumItems = 0;\n  unsigned NumTombstones = 0;\n  unsigned ItemSize;\n\nprotected:\n  explicit StringMapImpl(unsigned itemSize) : ItemSize(itemSize) {}\n  StringMapImpl(StringMapImpl &&RHS)\n      : TheTable(RHS.TheTable), NumBuckets(RHS.NumBuckets),\n        NumItems(RHS.NumItems), NumTombstones(RHS.NumTombstones),\n        ItemSize(RHS.ItemSize) {\n    RHS.TheTable = nullptr;\n    RHS.NumBuckets = 0;\n    RHS.NumItems = 0;\n    RHS.NumTombstones = 0;\n  }\n\n  StringMapImpl(unsigned InitSize, unsigned ItemSize);\n  unsigned RehashTable(unsigned BucketNo = 0);\n\n  /// LookupBucketFor - Look up the bucket that the specified string should end\n  /// up in.  If it already exists as a key in the map, the Item pointer for the\n  /// specified bucket will be non-null.  Otherwise, it will be null.  In either\n  /// case, the FullHashValue field of the bucket will be set to the hash value\n  /// of the string.\n  unsigned LookupBucketFor(StringRef Key);\n\n  /// FindKey - Look up the bucket that contains the specified key. If it exists\n  /// in the map, return the bucket number of the key.  Otherwise return -1.\n  /// This does not modify the map.\n  int FindKey(StringRef Key) const;\n\n  /// RemoveKey - Remove the specified StringMapEntry from the table, but do not\n  /// delete it.  This aborts if the value isn't in the table.\n  void RemoveKey(StringMapEntryBase *V);\n\n  /// RemoveKey - Remove the StringMapEntry for the specified key from the\n  /// table, returning it.  If the key is not in the table, this returns null.\n  StringMapEntryBase *RemoveKey(StringRef Key);\n\n  /// Allocate the table with the specified number of buckets and otherwise\n  /// setup the map as empty.\n  void init(unsigned Size);\n\npublic:\n  static constexpr uintptr_t TombstoneIntVal =\n      static_cast<uintptr_t>(-1)\n      << PointerLikeTypeTraits<StringMapEntryBase *>::NumLowBitsAvailable;\n\n  static StringMapEntryBase *getTombstoneVal() {\n    return reinterpret_cast<StringMapEntryBase *>(TombstoneIntVal);\n  }\n\n  unsigned getNumBuckets() const { return NumBuckets; }\n  unsigned getNumItems() const { return NumItems; }\n\n  bool empty() const { return NumItems == 0; }\n  unsigned size() const { return NumItems; }\n\n  void swap(StringMapImpl &Other) {\n    std::swap(TheTable, Other.TheTable);\n    std::swap(NumBuckets, Other.NumBuckets);\n    std::swap(NumItems, Other.NumItems);\n    std::swap(NumTombstones, Other.NumTombstones);\n  }\n};\n\n/// StringMap - This is an unconventional map that is specialized for handling\n/// keys that are \"strings\", which are basically ranges of bytes. This does some\n/// funky memory allocation and hashing things to make it extremely efficient,\n/// storing the string data *after* the value in the map.\ntemplate <typename ValueTy, typename AllocatorTy = MallocAllocator>\nclass StringMap : public StringMapImpl {\n  AllocatorTy Allocator;\n\npublic:\n  using MapEntryTy = StringMapEntry<ValueTy>;\n\n  StringMap() : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(unsigned InitialSize)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(AllocatorTy A)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))), Allocator(A) {\n  }\n\n  StringMap(unsigned InitialSize, AllocatorTy A)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(A) {}\n\n  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)\n      : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {\n    for (const auto &P : List) {\n      insert(P);\n    }\n  }\n\n  StringMap(StringMap &&RHS)\n      : StringMapImpl(std::move(RHS)), Allocator(std::move(RHS.Allocator)) {}\n\n  StringMap(const StringMap &RHS)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(RHS.Allocator) {\n    if (RHS.empty())\n      return;\n\n    // Allocate TheTable of the same size as RHS's TheTable, and set the\n    // sentinel appropriately (and NumBuckets).\n    init(RHS.NumBuckets);\n    unsigned *HashTable = (unsigned *)(TheTable + NumBuckets + 1),\n             *RHSHashTable = (unsigned *)(RHS.TheTable + NumBuckets + 1);\n\n    NumItems = RHS.NumItems;\n    NumTombstones = RHS.NumTombstones;\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *Bucket = RHS.TheTable[I];\n      if (!Bucket || Bucket == getTombstoneVal()) {\n        TheTable[I] = Bucket;\n        continue;\n      }\n\n      TheTable[I] = MapEntryTy::Create(\n          static_cast<MapEntryTy *>(Bucket)->getKey(), Allocator,\n          static_cast<MapEntryTy *>(Bucket)->getValue());\n      HashTable[I] = RHSHashTable[I];\n    }\n\n    // Note that here we've copied everything from the RHS into this object,\n    // tombstones included. We could, instead, have re-probed for each key to\n    // instantiate this new object without any tombstone buckets. The\n    // assumption here is that items are rarely deleted from most StringMaps,\n    // and so tombstones are rare, so the cost of re-probing for all inputs is\n    // not worthwhile.\n  }\n\n  StringMap &operator=(StringMap RHS) {\n    StringMapImpl::swap(RHS);\n    std::swap(Allocator, RHS.Allocator);\n    return *this;\n  }\n\n  ~StringMap() {\n    // Delete all the elements in the map, but don't reset the elements\n    // to default values.  This is a copy of clear(), but avoids unnecessary\n    // work not required in the destructor.\n    if (!empty()) {\n      for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n        StringMapEntryBase *Bucket = TheTable[I];\n        if (Bucket && Bucket != getTombstoneVal()) {\n          static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n        }\n      }\n    }\n    free(TheTable);\n  }\n\n  AllocatorTy &getAllocator() { return Allocator; }\n  const AllocatorTy &getAllocator() const { return Allocator; }\n\n  using key_type = const char *;\n  using mapped_type = ValueTy;\n  using value_type = StringMapEntry<ValueTy>;\n  using size_type = size_t;\n\n  using const_iterator = StringMapConstIterator<ValueTy>;\n  using iterator = StringMapIterator<ValueTy>;\n\n  iterator begin() { return iterator(TheTable, NumBuckets == 0); }\n  iterator end() { return iterator(TheTable + NumBuckets, true); }\n  const_iterator begin() const {\n    return const_iterator(TheTable, NumBuckets == 0);\n  }\n  const_iterator end() const {\n    return const_iterator(TheTable + NumBuckets, true);\n  }\n\n  iterator_range<StringMapKeyIterator<ValueTy>> keys() const {\n    return make_range(StringMapKeyIterator<ValueTy>(begin()),\n                      StringMapKeyIterator<ValueTy>(end()));\n  }\n\n  iterator find(StringRef Key) {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return iterator(TheTable + Bucket, true);\n  }\n\n  const_iterator find(StringRef Key) const {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return const_iterator(TheTable + Bucket, true);\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueTy lookup(StringRef Key) const {\n    const_iterator it = find(Key);\n    if (it != end())\n      return it->second;\n    return ValueTy();\n  }\n\n  /// Lookup the ValueTy for the \\p Key, or create a default constructed value\n  /// if the key is not in the map.\n  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }\n\n  /// count - Return 1 if the element is in the map, 0 otherwise.\n  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }\n\n  template <typename InputTy>\n  size_type count(const StringMapEntry<InputTy> &MapEntry) const {\n    return count(MapEntry.getKey());\n  }\n\n  /// equal - check whether both of the containers are equal.\n  bool operator==(const StringMap &RHS) const {\n    if (size() != RHS.size())\n      return false;\n\n    for (const auto &KeyValue : *this) {\n      auto FindInRHS = RHS.find(KeyValue.getKey());\n\n      if (FindInRHS == RHS.end())\n        return false;\n\n      if (!(KeyValue.getValue() == FindInRHS->getValue()))\n        return false;\n    }\n\n    return true;\n  }\n\n  bool operator!=(const StringMap &RHS) const { return !(*this == RHS); }\n\n  /// insert - Insert the specified key/value pair into the map.  If the key\n  /// already exists in the map, return false and ignore the request, otherwise\n  /// insert it and return true.\n  bool insert(MapEntryTy *KeyValue) {\n    unsigned BucketNo = LookupBucketFor(KeyValue->getKey());\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return false; // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = KeyValue;\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    RehashTable();\n    return true;\n  }\n\n  /// insert - Inserts the specified key/value pair into the map if the key\n  /// isn't already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {\n    return try_emplace(KV.first, std::move(KV.second));\n  }\n\n  /// Inserts an element or assigns to the current element if the key already\n  /// exists. The return type is the same as try_emplace.\n  template <typename V>\n  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {\n    auto Ret = try_emplace(Key, std::forward<V>(Val));\n    if (!Ret.second)\n      Ret.first->second = std::forward<V>(Val);\n    return Ret;\n  }\n\n  /// Emplace a new element for the specified key into the map if the key isn't\n  /// already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  template <typename... ArgsTy>\n  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {\n    unsigned BucketNo = LookupBucketFor(Key);\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return std::make_pair(iterator(TheTable + BucketNo, false),\n                            false); // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = MapEntryTy::Create(Key, Allocator, std::forward<ArgsTy>(Args)...);\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    BucketNo = RehashTable(BucketNo);\n    return std::make_pair(iterator(TheTable + BucketNo, false), true);\n  }\n\n  // clear - Empties out the StringMap\n  void clear() {\n    if (empty())\n      return;\n\n    // Zap all values, resetting the keys back to non-present (not tombstone),\n    // which is safe because we're removing all elements.\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *&Bucket = TheTable[I];\n      if (Bucket && Bucket != getTombstoneVal()) {\n        static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n      }\n      Bucket = nullptr;\n    }\n\n    NumItems = 0;\n    NumTombstones = 0;\n  }\n\n  /// remove - Remove the specified key/value pair from the map, but do not\n  /// erase it.  This aborts if the key is not in the map.\n  void remove(MapEntryTy *KeyValue) { RemoveKey(KeyValue); }\n\n  void erase(iterator I) {\n    MapEntryTy &V = *I;\n    remove(&V);\n    V.Destroy(Allocator);\n  }\n\n  bool erase(StringRef Key) {\n    iterator I = find(Key);\n    if (I == end())\n      return false;\n    erase(I);\n    return true;\n  }\n};\n\ntemplate <typename DerivedTy, typename ValueTy>\nclass StringMapIterBase\n    : public iterator_facade_base<DerivedTy, std::forward_iterator_tag,\n                                  ValueTy> {\nprotected:\n  StringMapEntryBase **Ptr = nullptr;\n\npublic:\n  StringMapIterBase() = default;\n\n  explicit StringMapIterBase(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : Ptr(Bucket) {\n    if (!NoAdvance)\n      AdvancePastEmptyBuckets();\n  }\n\n  DerivedTy &operator=(const DerivedTy &Other) {\n    Ptr = Other.Ptr;\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  friend bool operator==(const DerivedTy &LHS, const DerivedTy &RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  DerivedTy &operator++() { // Preincrement\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  DerivedTy operator++(int) { // Post-increment\n    DerivedTy Tmp(Ptr);\n    ++*this;\n    return Tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())\n      ++Ptr;\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapConstIterator\n    : public StringMapIterBase<StringMapConstIterator<ValueTy>,\n                               const StringMapEntry<ValueTy>> {\n  using base = StringMapIterBase<StringMapConstIterator<ValueTy>,\n                                 const StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapConstIterator() = default;\n  explicit StringMapConstIterator(StringMapEntryBase **Bucket,\n                                  bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  const StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<const StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapIterator : public StringMapIterBase<StringMapIterator<ValueTy>,\n                                                   StringMapEntry<ValueTy>> {\n  using base =\n      StringMapIterBase<StringMapIterator<ValueTy>, StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapIterator() = default;\n  explicit StringMapIterator(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n\n  operator StringMapConstIterator<ValueTy>() const {\n    return StringMapConstIterator<ValueTy>(this->Ptr, true);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapKeyIterator\n    : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                   StringMapConstIterator<ValueTy>,\n                                   std::forward_iterator_tag, StringRef> {\n  using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                     StringMapConstIterator<ValueTy>,\n                                     std::forward_iterator_tag, StringRef>;\n\npublic:\n  StringMapKeyIterator() = default;\n  explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)\n      : base(std::move(Iter)) {}\n\n  StringRef &operator*() {\n    Key = this->wrapped()->getKey();\n    return Key;\n  }\n\nprivate:\n  StringRef Key;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAP_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h", "content": "//===- StringMapEntry.h - String Hash table map interface -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMapEntry class - it is intended to be a low\n// dependency implementation detail of StringMap that is more suitable for\n// inclusion in public headers than StringMap.h itself is.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAPENTRY_H\n#define LLVM_ADT_STRINGMAPENTRY_H\n\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\n/// StringMapEntryBase - Shared base class of StringMapEntry instances.\nclass StringMapEntryBase {\n  size_t keyLength;\n\npublic:\n  explicit StringMapEntryBase(size_t keyLength) : keyLength(keyLength) {}\n\n  size_t getKeyLength() const { return keyLength; }\n};\n\n/// StringMapEntryStorage - Holds the value in a StringMapEntry.\n///\n/// Factored out into a separate base class to make it easier to specialize.\n/// This is primarily intended to support StringSet, which doesn't need a value\n/// stored at all.\ntemplate <typename ValueTy>\nclass StringMapEntryStorage : public StringMapEntryBase {\npublic:\n  ValueTy second;\n\n  explicit StringMapEntryStorage(size_t keyLength)\n      : StringMapEntryBase(keyLength), second() {}\n  template <typename... InitTy>\n  StringMapEntryStorage(size_t keyLength, InitTy &&... initVals)\n      : StringMapEntryBase(keyLength),\n        second(std::forward<InitTy>(initVals)...) {}\n  StringMapEntryStorage(StringMapEntryStorage &e) = delete;\n\n  const ValueTy &getValue() const { return second; }\n  ValueTy &getValue() { return second; }\n\n  void setValue(const ValueTy &V) { second = V; }\n};\n\ntemplate <> class StringMapEntryStorage<NoneType> : public StringMapEntryBase {\npublic:\n  explicit StringMapEntryStorage(size_t keyLength, NoneType none = None)\n      : StringMapEntryBase(keyLength) {}\n  StringMapEntryStorage(StringMapEntryStorage &entry) = delete;\n\n  NoneType getValue() const { return None; }\n};\n\n/// StringMapEntry - This is used to represent one value that is inserted into\n/// a StringMap.  It contains the Value itself and the key: the string length\n/// and data.\ntemplate <typename ValueTy>\nclass StringMapEntry final : public StringMapEntryStorage<ValueTy> {\npublic:\n  using StringMapEntryStorage<ValueTy>::StringMapEntryStorage;\n\n  StringRef getKey() const {\n    return StringRef(getKeyData(), this->getKeyLength());\n  }\n\n  /// getKeyData - Return the start of the string data that is the key for this\n  /// value.  The string data is always stored immediately after the\n  /// StringMapEntry object.\n  const char *getKeyData() const {\n    return reinterpret_cast<const char *>(this + 1);\n  }\n\n  StringRef first() const {\n    return StringRef(getKeyData(), this->getKeyLength());\n  }\n\n  /// Create a StringMapEntry for the specified key construct the value using\n  /// \\p InitiVals.\n  template <typename AllocatorTy, typename... InitTy>\n  static StringMapEntry *Create(StringRef key, AllocatorTy &allocator,\n                                InitTy &&... initVals) {\n    size_t keyLength = key.size();\n\n    // Allocate a new item with space for the string at the end and a null\n    // terminator.\n    size_t allocSize = sizeof(StringMapEntry) + keyLength + 1;\n    size_t alignment = alignof(StringMapEntry);\n\n    StringMapEntry *newItem =\n        static_cast<StringMapEntry *>(allocator.Allocate(allocSize, alignment));\n    assert(newItem && \"Unhandled out-of-memory\");\n\n    // Construct the value.\n    new (newItem) StringMapEntry(keyLength, std::forward<InitTy>(initVals)...);\n\n    // Copy the string information.\n    char *strBuffer = const_cast<char *>(newItem->getKeyData());\n    if (keyLength > 0)\n      memcpy(strBuffer, key.data(), keyLength);\n    strBuffer[keyLength] = 0; // Null terminate for convenience of clients.\n    return newItem;\n  }\n\n  /// GetStringMapEntryFromKeyData - Given key data that is known to be embedded\n  /// into a StringMapEntry, return the StringMapEntry itself.\n  static StringMapEntry &GetStringMapEntryFromKeyData(const char *keyData) {\n    char *ptr = const_cast<char *>(keyData) - sizeof(StringMapEntry<ValueTy>);\n    return *reinterpret_cast<StringMapEntry *>(ptr);\n  }\n\n  /// Destroy - Destroy this StringMapEntry, releasing memory back to the\n  /// specified allocator.\n  template <typename AllocatorTy> void Destroy(AllocatorTy &allocator) {\n    // Free memory referenced by the item.\n    size_t AllocSize = sizeof(StringMapEntry) + this->getKeyLength() + 1;\n    this->~StringMapEntry();\n    allocator.Deallocate(static_cast<void *>(this), AllocSize,\n                         alignof(StringMapEntry));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAPENTRY_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "content": "//===-- llvm/BinaryFormat/MachO.h - The MachO file format -------*- C++/-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines manifest constants for the MachO object file format.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_MACHO_H\n#define LLVM_BINARYFORMAT_MACHO_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n\nnamespace llvm {\n\nclass Triple;\n\nnamespace MachO {\n// Enums from <mach-o/loader.h>\nenum : uint32_t {\n  // Constants for the \"magic\" field in llvm::MachO::mach_header and\n  // llvm::MachO::mach_header_64\n  MH_MAGIC = 0xFEEDFACEu,\n  MH_CIGAM = 0xCEFAEDFEu,\n  MH_MAGIC_64 = 0xFEEDFACFu,\n  MH_CIGAM_64 = 0xCFFAEDFEu,\n  FAT_MAGIC = 0xCAFEBABEu,\n  FAT_CIGAM = 0xBEBAFECAu,\n  FAT_MAGIC_64 = 0xCAFEBABFu,\n  FAT_CIGAM_64 = 0xBFBAFECAu\n};\n\nenum HeaderFileType {\n  // Constants for the \"filetype\" field in llvm::MachO::mach_header and\n  // llvm::MachO::mach_header_64\n  MH_OBJECT = 0x1u,\n  MH_EXECUTE = 0x2u,\n  MH_FVMLIB = 0x3u,\n  MH_CORE = 0x4u,\n  MH_PRELOAD = 0x5u,\n  MH_DYLIB = 0x6u,\n  MH_DYLINKER = 0x7u,\n  MH_BUNDLE = 0x8u,\n  MH_DYLIB_STUB = 0x9u,\n  MH_DSYM = 0xAu,\n  MH_KEXT_BUNDLE = 0xBu\n};\n\nenum {\n  // Constant bits for the \"flags\" field in llvm::MachO::mach_header and\n  // llvm::MachO::mach_header_64\n  MH_NOUNDEFS = 0x00000001u,\n  MH_INCRLINK = 0x00000002u,\n  MH_DYLDLINK = 0x00000004u,\n  MH_BINDATLOAD = 0x00000008u,\n  MH_PREBOUND = 0x00000010u,\n  MH_SPLIT_SEGS = 0x00000020u,\n  MH_LAZY_INIT = 0x00000040u,\n  MH_TWOLEVEL = 0x00000080u,\n  MH_FORCE_FLAT = 0x00000100u,\n  MH_NOMULTIDEFS = 0x00000200u,\n  MH_NOFIXPREBINDING = 0x00000400u,\n  MH_PREBINDABLE = 0x00000800u,\n  MH_ALLMODSBOUND = 0x00001000u,\n  MH_SUBSECTIONS_VIA_SYMBOLS = 0x00002000u,\n  MH_CANONICAL = 0x00004000u,\n  MH_WEAK_DEFINES = 0x00008000u,\n  MH_BINDS_TO_WEAK = 0x00010000u,\n  MH_ALLOW_STACK_EXECUTION = 0x00020000u,\n  MH_ROOT_SAFE = 0x00040000u,\n  MH_SETUID_SAFE = 0x00080000u,\n  MH_NO_REEXPORTED_DYLIBS = 0x00100000u,\n  MH_PIE = 0x00200000u,\n  MH_DEAD_STRIPPABLE_DYLIB = 0x00400000u,\n  MH_HAS_TLV_DESCRIPTORS = 0x00800000u,\n  MH_NO_HEAP_EXECUTION = 0x01000000u,\n  MH_APP_EXTENSION_SAFE = 0x02000000u,\n  MH_NLIST_OUTOFSYNC_WITH_DYLDINFO = 0x04000000u,\n  MH_SIM_SUPPORT = 0x08000000u,\n  MH_DYLIB_IN_CACHE = 0x80000000u,\n};\n\nenum : uint32_t {\n  // Flags for the \"cmd\" field in llvm::MachO::load_command\n  LC_REQ_DYLD = 0x80000000u\n};\n\n#define HANDLE_LOAD_COMMAND(LCName, LCValue, LCStruct) LCName = LCValue,\n\nenum LoadCommandType : uint32_t {\n#include \"llvm/BinaryFormat/MachO.def\"\n};\n\n#undef HANDLE_LOAD_COMMAND\n\nenum : uint32_t {\n  // Constant bits for the \"flags\" field in llvm::MachO::segment_command\n  SG_HIGHVM = 0x1u,\n  SG_FVMLIB = 0x2u,\n  SG_NORELOC = 0x4u,\n  SG_PROTECTED_VERSION_1 = 0x8u,\n\n  // Constant masks for the \"flags\" field in llvm::MachO::section and\n  // llvm::MachO::section_64\n  SECTION_TYPE = 0x000000ffu,           // SECTION_TYPE\n  SECTION_ATTRIBUTES = 0xffffff00u,     // SECTION_ATTRIBUTES\n  SECTION_ATTRIBUTES_USR = 0xff000000u, // SECTION_ATTRIBUTES_USR\n  SECTION_ATTRIBUTES_SYS = 0x00ffff00u  // SECTION_ATTRIBUTES_SYS\n};\n\n/// These are the section type and attributes fields.  A MachO section can\n/// have only one Type, but can have any of the attributes specified.\nenum SectionType : uint32_t {\n  // Constant masks for the \"flags[7:0]\" field in llvm::MachO::section and\n  // llvm::MachO::section_64 (mask \"flags\" with SECTION_TYPE)\n\n  /// S_REGULAR - Regular section.\n  S_REGULAR = 0x00u,\n  /// S_ZEROFILL - Zero fill on demand section.\n  S_ZEROFILL = 0x01u,\n  /// S_CSTRING_LITERALS - Section with literal C strings.\n  S_CSTRING_LITERALS = 0x02u,\n  /// S_4BYTE_LITERALS - Section with 4 byte literals.\n  S_4BYTE_LITERALS = 0x03u,\n  /// S_8BYTE_LITERALS - Section with 8 byte literals.\n  S_8BYTE_LITERALS = 0x04u,\n  /// S_LITERAL_POINTERS - Section with pointers to literals.\n  S_LITERAL_POINTERS = 0x05u,\n  /// S_NON_LAZY_SYMBOL_POINTERS - Section with non-lazy symbol pointers.\n  S_NON_LAZY_SYMBOL_POINTERS = 0x06u,\n  /// S_LAZY_SYMBOL_POINTERS - Section with lazy symbol pointers.\n  S_LAZY_SYMBOL_POINTERS = 0x07u,\n  /// S_SYMBOL_STUBS - Section with symbol stubs, byte size of stub in\n  /// the Reserved2 field.\n  S_SYMBOL_STUBS = 0x08u,\n  /// S_MOD_INIT_FUNC_POINTERS - Section with only function pointers for\n  /// initialization.\n  S_MOD_INIT_FUNC_POINTERS = 0x09u,\n  /// S_MOD_TERM_FUNC_POINTERS - Section with only function pointers for\n  /// termination.\n  S_MOD_TERM_FUNC_POINTERS = 0x0au,\n  /// S_COALESCED - Section contains symbols that are to be coalesced.\n  S_COALESCED = 0x0bu,\n  /// S_GB_ZEROFILL - Zero fill on demand section (that can be larger than 4\n  /// gigabytes).\n  S_GB_ZEROFILL = 0x0cu,\n  /// S_INTERPOSING - Section with only pairs of function pointers for\n  /// interposing.\n  S_INTERPOSING = 0x0du,\n  /// S_16BYTE_LITERALS - Section with only 16 byte literals.\n  S_16BYTE_LITERALS = 0x0eu,\n  /// S_DTRACE_DOF - Section contains DTrace Object Format.\n  S_DTRACE_DOF = 0x0fu,\n  /// S_LAZY_DYLIB_SYMBOL_POINTERS - Section with lazy symbol pointers to\n  /// lazy loaded dylibs.\n  S_LAZY_DYLIB_SYMBOL_POINTERS = 0x10u,\n  /// S_THREAD_LOCAL_REGULAR - Thread local data section.\n  S_THREAD_LOCAL_REGULAR = 0x11u,\n  /// S_THREAD_LOCAL_ZEROFILL - Thread local zerofill section.\n  S_THREAD_LOCAL_ZEROFILL = 0x12u,\n  /// S_THREAD_LOCAL_VARIABLES - Section with thread local variable\n  /// structure data.\n  S_THREAD_LOCAL_VARIABLES = 0x13u,\n  /// S_THREAD_LOCAL_VARIABLE_POINTERS - Section with pointers to thread\n  /// local structures.\n  S_THREAD_LOCAL_VARIABLE_POINTERS = 0x14u,\n  /// S_THREAD_LOCAL_INIT_FUNCTION_POINTERS - Section with thread local\n  /// variable initialization pointers to functions.\n  S_THREAD_LOCAL_INIT_FUNCTION_POINTERS = 0x15u,\n\n  LAST_KNOWN_SECTION_TYPE = S_THREAD_LOCAL_INIT_FUNCTION_POINTERS\n};\n\nenum : uint32_t {\n  // Constant masks for the \"flags[31:24]\" field in llvm::MachO::section and\n  // llvm::MachO::section_64 (mask \"flags\" with SECTION_ATTRIBUTES_USR)\n\n  /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine\n  /// instructions.\n  S_ATTR_PURE_INSTRUCTIONS = 0x80000000u,\n  /// S_ATTR_NO_TOC - Section contains coalesced symbols that are not to be\n  /// in a ranlib table of contents.\n  S_ATTR_NO_TOC = 0x40000000u,\n  /// S_ATTR_STRIP_STATIC_SYMS - Ok to strip static symbols in this section\n  /// in files with the MY_DYLDLINK flag.\n  S_ATTR_STRIP_STATIC_SYMS = 0x20000000u,\n  /// S_ATTR_NO_DEAD_STRIP - No dead stripping.\n  S_ATTR_NO_DEAD_STRIP = 0x10000000u,\n  /// S_ATTR_LIVE_SUPPORT - Blocks are live if they reference live blocks.\n  S_ATTR_LIVE_SUPPORT = 0x08000000u,\n  /// S_ATTR_SELF_MODIFYING_CODE - Used with i386 code stubs written on by\n  /// dyld.\n  S_ATTR_SELF_MODIFYING_CODE = 0x04000000u,\n  /// S_ATTR_DEBUG - A debug section.\n  S_ATTR_DEBUG = 0x02000000u,\n\n  // Constant masks for the \"flags[23:8]\" field in llvm::MachO::section and\n  // llvm::MachO::section_64 (mask \"flags\" with SECTION_ATTRIBUTES_SYS)\n\n  /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.\n  S_ATTR_SOME_INSTRUCTIONS = 0x00000400u,\n  /// S_ATTR_EXT_RELOC - Section has external relocation entries.\n  S_ATTR_EXT_RELOC = 0x00000200u,\n  /// S_ATTR_LOC_RELOC - Section has local relocation entries.\n  S_ATTR_LOC_RELOC = 0x00000100u,\n\n  // Constant masks for the value of an indirect symbol in an indirect\n  // symbol table\n  INDIRECT_SYMBOL_LOCAL = 0x80000000u,\n  INDIRECT_SYMBOL_ABS = 0x40000000u\n};\n\nenum DataRegionType {\n  // Constants for the \"kind\" field in a data_in_code_entry structure\n  DICE_KIND_DATA = 1u,\n  DICE_KIND_JUMP_TABLE8 = 2u,\n  DICE_KIND_JUMP_TABLE16 = 3u,\n  DICE_KIND_JUMP_TABLE32 = 4u,\n  DICE_KIND_ABS_JUMP_TABLE32 = 5u\n};\n\nenum RebaseType {\n  REBASE_TYPE_POINTER = 1u,\n  REBASE_TYPE_TEXT_ABSOLUTE32 = 2u,\n  REBASE_TYPE_TEXT_PCREL32 = 3u\n};\n\nenum { REBASE_OPCODE_MASK = 0xF0u, REBASE_IMMEDIATE_MASK = 0x0Fu };\n\nenum RebaseOpcode {\n  REBASE_OPCODE_DONE = 0x00u,\n  REBASE_OPCODE_SET_TYPE_IMM = 0x10u,\n  REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB = 0x20u,\n  REBASE_OPCODE_ADD_ADDR_ULEB = 0x30u,\n  REBASE_OPCODE_ADD_ADDR_IMM_SCALED = 0x40u,\n  REBASE_OPCODE_DO_REBASE_IMM_TIMES = 0x50u,\n  REBASE_OPCODE_DO_REBASE_ULEB_TIMES = 0x60u,\n  REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB = 0x70u,\n  REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB = 0x80u\n};\n\nenum BindType {\n  BIND_TYPE_POINTER = 1u,\n  BIND_TYPE_TEXT_ABSOLUTE32 = 2u,\n  BIND_TYPE_TEXT_PCREL32 = 3u\n};\n\nenum BindSpecialDylib {\n  BIND_SPECIAL_DYLIB_SELF = 0,\n  BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE = -1,\n  BIND_SPECIAL_DYLIB_FLAT_LOOKUP = -2\n};\n\nenum {\n  BIND_SYMBOL_FLAGS_WEAK_IMPORT = 0x1u,\n  BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION = 0x8u,\n\n  BIND_OPCODE_MASK = 0xF0u,\n  BIND_IMMEDIATE_MASK = 0x0Fu\n};\n\nenum BindOpcode {\n  BIND_OPCODE_DONE = 0x00u,\n  BIND_OPCODE_SET_DYLIB_ORDINAL_IMM = 0x10u,\n  BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB = 0x20u,\n  BIND_OPCODE_SET_DYLIB_SPECIAL_IMM = 0x30u,\n  BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM = 0x40u,\n  BIND_OPCODE_SET_TYPE_IMM = 0x50u,\n  BIND_OPCODE_SET_ADDEND_SLEB = 0x60u,\n  BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB = 0x70u,\n  BIND_OPCODE_ADD_ADDR_ULEB = 0x80u,\n  BIND_OPCODE_DO_BIND = 0x90u,\n  BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB = 0xA0u,\n  BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED = 0xB0u,\n  BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB = 0xC0u\n};\n\nenum {\n  EXPORT_SYMBOL_FLAGS_KIND_MASK = 0x03u,\n  EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION = 0x04u,\n  EXPORT_SYMBOL_FLAGS_REEXPORT = 0x08u,\n  EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER = 0x10u\n};\n\nenum ExportSymbolKind {\n  EXPORT_SYMBOL_FLAGS_KIND_REGULAR = 0x00u,\n  EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL = 0x01u,\n  EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE = 0x02u\n};\n\nenum {\n  // Constant masks for the \"n_type\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  N_STAB = 0xe0,\n  N_PEXT = 0x10,\n  N_TYPE = 0x0e,\n  N_EXT = 0x01\n};\n\nenum NListType : uint8_t {\n  // Constants for the \"n_type & N_TYPE\" llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  N_UNDF = 0x0u,\n  N_ABS = 0x2u,\n  N_SECT = 0xeu,\n  N_PBUD = 0xcu,\n  N_INDR = 0xau\n};\n\nenum SectionOrdinal {\n  // Constants for the \"n_sect\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  NO_SECT = 0u,\n  MAX_SECT = 0xffu\n};\n\nenum {\n  // Constant masks for the \"n_desc\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  // The low 3 bits are the for the REFERENCE_TYPE.\n  REFERENCE_TYPE = 0x7,\n  REFERENCE_FLAG_UNDEFINED_NON_LAZY = 0,\n  REFERENCE_FLAG_UNDEFINED_LAZY = 1,\n  REFERENCE_FLAG_DEFINED = 2,\n  REFERENCE_FLAG_PRIVATE_DEFINED = 3,\n  REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY = 4,\n  REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY = 5,\n  // Flag bits (some overlap with the library ordinal bits).\n  N_ARM_THUMB_DEF = 0x0008u,\n  REFERENCED_DYNAMICALLY = 0x0010u,\n  N_NO_DEAD_STRIP = 0x0020u,\n  N_WEAK_REF = 0x0040u,\n  N_WEAK_DEF = 0x0080u,\n  N_SYMBOL_RESOLVER = 0x0100u,\n  N_ALT_ENTRY = 0x0200u,\n  N_COLD_FUNC = 0x0400u,\n  // For undefined symbols coming from libraries, see GET_LIBRARY_ORDINAL()\n  // as these are in the top 8 bits.\n  SELF_LIBRARY_ORDINAL = 0x0,\n  MAX_LIBRARY_ORDINAL = 0xfd,\n  DYNAMIC_LOOKUP_ORDINAL = 0xfe,\n  EXECUTABLE_ORDINAL = 0xff\n};\n\nenum StabType {\n  // Constant values for the \"n_type\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64 when \"(n_type & N_STAB) != 0\"\n  N_GSYM = 0x20u,\n  N_FNAME = 0x22u,\n  N_FUN = 0x24u,\n  N_STSYM = 0x26u,\n  N_LCSYM = 0x28u,\n  N_BNSYM = 0x2Eu,\n  N_PC = 0x30u,\n  N_AST = 0x32u,\n  N_OPT = 0x3Cu,\n  N_RSYM = 0x40u,\n  N_SLINE = 0x44u,\n  N_ENSYM = 0x4Eu,\n  N_SSYM = 0x60u,\n  N_SO = 0x64u,\n  N_OSO = 0x66u,\n  N_LSYM = 0x80u,\n  N_BINCL = 0x82u,\n  N_SOL = 0x84u,\n  N_PARAMS = 0x86u,\n  N_VERSION = 0x88u,\n  N_OLEVEL = 0x8Au,\n  N_PSYM = 0xA0u,\n  N_EINCL = 0xA2u,\n  N_ENTRY = 0xA4u,\n  N_LBRAC = 0xC0u,\n  N_EXCL = 0xC2u,\n  N_RBRAC = 0xE0u,\n  N_BCOMM = 0xE2u,\n  N_ECOMM = 0xE4u,\n  N_ECOML = 0xE8u,\n  N_LENG = 0xFEu\n};\n\nenum : uint32_t {\n  // Constant values for the r_symbolnum field in an\n  // llvm::MachO::relocation_info structure when r_extern is 0.\n  R_ABS = 0,\n\n  // Constant bits for the r_address field in an\n  // llvm::MachO::relocation_info structure.\n  R_SCATTERED = 0x80000000\n};\n\nenum RelocationInfoType {\n  // Constant values for the r_type field in an\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n  GENERIC_RELOC_INVALID = 0xff,\n  GENERIC_RELOC_VANILLA = 0,\n  GENERIC_RELOC_PAIR = 1,\n  GENERIC_RELOC_SECTDIFF = 2,\n  GENERIC_RELOC_PB_LA_PTR = 3,\n  GENERIC_RELOC_LOCAL_SECTDIFF = 4,\n  GENERIC_RELOC_TLV = 5,\n\n  // Constant values for the r_type field in a PowerPC architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n  PPC_RELOC_VANILLA = GENERIC_RELOC_VANILLA,\n  PPC_RELOC_PAIR = GENERIC_RELOC_PAIR,\n  PPC_RELOC_BR14 = 2,\n  PPC_RELOC_BR24 = 3,\n  PPC_RELOC_HI16 = 4,\n  PPC_RELOC_LO16 = 5,\n  PPC_RELOC_HA16 = 6,\n  PPC_RELOC_LO14 = 7,\n  PPC_RELOC_SECTDIFF = 8,\n  PPC_RELOC_PB_LA_PTR = 9,\n  PPC_RELOC_HI16_SECTDIFF = 10,\n  PPC_RELOC_LO16_SECTDIFF = 11,\n  PPC_RELOC_HA16_SECTDIFF = 12,\n  PPC_RELOC_JBSR = 13,\n  PPC_RELOC_LO14_SECTDIFF = 14,\n  PPC_RELOC_LOCAL_SECTDIFF = 15,\n\n  // Constant values for the r_type field in an ARM architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n  ARM_RELOC_VANILLA = GENERIC_RELOC_VANILLA,\n  ARM_RELOC_PAIR = GENERIC_RELOC_PAIR,\n  ARM_RELOC_SECTDIFF = GENERIC_RELOC_SECTDIFF,\n  ARM_RELOC_LOCAL_SECTDIFF = 3,\n  ARM_RELOC_PB_LA_PTR = 4,\n  ARM_RELOC_BR24 = 5,\n  ARM_THUMB_RELOC_BR22 = 6,\n  ARM_THUMB_32BIT_BRANCH = 7, // obsolete\n  ARM_RELOC_HALF = 8,\n  ARM_RELOC_HALF_SECTDIFF = 9,\n\n  // Constant values for the r_type field in an ARM64 architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n\n  // For pointers.\n  ARM64_RELOC_UNSIGNED = 0,\n  // Must be followed by an ARM64_RELOC_UNSIGNED\n  ARM64_RELOC_SUBTRACTOR = 1,\n  // A B/BL instruction with 26-bit displacement.\n  ARM64_RELOC_BRANCH26 = 2,\n  // PC-rel distance to page of target.\n  ARM64_RELOC_PAGE21 = 3,\n  // Offset within page, scaled by r_length.\n  ARM64_RELOC_PAGEOFF12 = 4,\n  // PC-rel distance to page of GOT slot.\n  ARM64_RELOC_GOT_LOAD_PAGE21 = 5,\n  // Offset within page of GOT slot, scaled by r_length.\n  ARM64_RELOC_GOT_LOAD_PAGEOFF12 = 6,\n  // For pointers to GOT slots.\n  ARM64_RELOC_POINTER_TO_GOT = 7,\n  // PC-rel distance to page of TLVP slot.\n  ARM64_RELOC_TLVP_LOAD_PAGE21 = 8,\n  // Offset within page of TLVP slot, scaled by r_length.\n  ARM64_RELOC_TLVP_LOAD_PAGEOFF12 = 9,\n  // Must be followed by ARM64_RELOC_PAGE21 or ARM64_RELOC_PAGEOFF12.\n  ARM64_RELOC_ADDEND = 10,\n\n  // Constant values for the r_type field in an x86_64 architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure\n  X86_64_RELOC_UNSIGNED = 0,\n  X86_64_RELOC_SIGNED = 1,\n  X86_64_RELOC_BRANCH = 2,\n  X86_64_RELOC_GOT_LOAD = 3,\n  X86_64_RELOC_GOT = 4,\n  X86_64_RELOC_SUBTRACTOR = 5,\n  X86_64_RELOC_SIGNED_1 = 6,\n  X86_64_RELOC_SIGNED_2 = 7,\n  X86_64_RELOC_SIGNED_4 = 8,\n  X86_64_RELOC_TLV = 9\n};\n\n// Values for segment_command.initprot.\n// From <mach/vm_prot.h>\nenum { VM_PROT_READ = 0x1, VM_PROT_WRITE = 0x2, VM_PROT_EXECUTE = 0x4 };\n\n// Values for platform field in build_version_command.\nenum PlatformType {\n  PLATFORM_MACOS = 1,\n  PLATFORM_IOS = 2,\n  PLATFORM_TVOS = 3,\n  PLATFORM_WATCHOS = 4,\n  PLATFORM_BRIDGEOS = 5,\n  PLATFORM_MACCATALYST = 6,\n  PLATFORM_IOSSIMULATOR = 7,\n  PLATFORM_TVOSSIMULATOR = 8,\n  PLATFORM_WATCHOSSIMULATOR = 9,\n  PLATFORM_DRIVERKIT = 10,\n};\n\n// Values for tools enum in build_tool_version.\nenum { TOOL_CLANG = 1, TOOL_SWIFT = 2, TOOL_LD = 3 };\n\n// Structs from <mach-o/loader.h>\n\nstruct mach_header {\n  uint32_t magic;\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint32_t filetype;\n  uint32_t ncmds;\n  uint32_t sizeofcmds;\n  uint32_t flags;\n};\n\nstruct mach_header_64 {\n  uint32_t magic;\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint32_t filetype;\n  uint32_t ncmds;\n  uint32_t sizeofcmds;\n  uint32_t flags;\n  uint32_t reserved;\n};\n\nstruct load_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\nstruct segment_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  char segname[16];\n  uint32_t vmaddr;\n  uint32_t vmsize;\n  uint32_t fileoff;\n  uint32_t filesize;\n  uint32_t maxprot;\n  uint32_t initprot;\n  uint32_t nsects;\n  uint32_t flags;\n};\n\nstruct segment_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  char segname[16];\n  uint64_t vmaddr;\n  uint64_t vmsize;\n  uint64_t fileoff;\n  uint64_t filesize;\n  uint32_t maxprot;\n  uint32_t initprot;\n  uint32_t nsects;\n  uint32_t flags;\n};\n\nstruct section {\n  char sectname[16];\n  char segname[16];\n  uint32_t addr;\n  uint32_t size;\n  uint32_t offset;\n  uint32_t align;\n  uint32_t reloff;\n  uint32_t nreloc;\n  uint32_t flags;\n  uint32_t reserved1;\n  uint32_t reserved2;\n};\n\nstruct section_64 {\n  char sectname[16];\n  char segname[16];\n  uint64_t addr;\n  uint64_t size;\n  uint32_t offset;\n  uint32_t align;\n  uint32_t reloff;\n  uint32_t nreloc;\n  uint32_t flags;\n  uint32_t reserved1;\n  uint32_t reserved2;\n  uint32_t reserved3;\n};\n\ninline bool isVirtualSection(uint8_t type) {\n  return (type == MachO::S_ZEROFILL || type == MachO::S_GB_ZEROFILL ||\n          type == MachO::S_THREAD_LOCAL_ZEROFILL);\n}\n\nstruct fvmlib {\n  uint32_t name;\n  uint32_t minor_version;\n  uint32_t header_addr;\n};\n\n// The fvmlib_command is obsolete and no longer supported.\nstruct fvmlib_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  struct fvmlib fvmlib;\n};\n\nstruct dylib {\n  uint32_t name;\n  uint32_t timestamp;\n  uint32_t current_version;\n  uint32_t compatibility_version;\n};\n\nstruct dylib_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  struct dylib dylib;\n};\n\nstruct sub_framework_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t umbrella;\n};\n\nstruct sub_client_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t client;\n};\n\nstruct sub_umbrella_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t sub_umbrella;\n};\n\nstruct sub_library_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t sub_library;\n};\n\n// The prebound_dylib_command is obsolete and no longer supported.\nstruct prebound_dylib_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t name;\n  uint32_t nmodules;\n  uint32_t linked_modules;\n};\n\nstruct dylinker_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t name;\n};\n\nstruct thread_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\nstruct routines_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t init_address;\n  uint32_t init_module;\n  uint32_t reserved1;\n  uint32_t reserved2;\n  uint32_t reserved3;\n  uint32_t reserved4;\n  uint32_t reserved5;\n  uint32_t reserved6;\n};\n\nstruct routines_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint64_t init_address;\n  uint64_t init_module;\n  uint64_t reserved1;\n  uint64_t reserved2;\n  uint64_t reserved3;\n  uint64_t reserved4;\n  uint64_t reserved5;\n  uint64_t reserved6;\n};\n\nstruct symtab_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t symoff;\n  uint32_t nsyms;\n  uint32_t stroff;\n  uint32_t strsize;\n};\n\nstruct dysymtab_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t ilocalsym;\n  uint32_t nlocalsym;\n  uint32_t iextdefsym;\n  uint32_t nextdefsym;\n  uint32_t iundefsym;\n  uint32_t nundefsym;\n  uint32_t tocoff;\n  uint32_t ntoc;\n  uint32_t modtaboff;\n  uint32_t nmodtab;\n  uint32_t extrefsymoff;\n  uint32_t nextrefsyms;\n  uint32_t indirectsymoff;\n  uint32_t nindirectsyms;\n  uint32_t extreloff;\n  uint32_t nextrel;\n  uint32_t locreloff;\n  uint32_t nlocrel;\n};\n\nstruct dylib_table_of_contents {\n  uint32_t symbol_index;\n  uint32_t module_index;\n};\n\nstruct dylib_module {\n  uint32_t module_name;\n  uint32_t iextdefsym;\n  uint32_t nextdefsym;\n  uint32_t irefsym;\n  uint32_t nrefsym;\n  uint32_t ilocalsym;\n  uint32_t nlocalsym;\n  uint32_t iextrel;\n  uint32_t nextrel;\n  uint32_t iinit_iterm;\n  uint32_t ninit_nterm;\n  uint32_t objc_module_info_addr;\n  uint32_t objc_module_info_size;\n};\n\nstruct dylib_module_64 {\n  uint32_t module_name;\n  uint32_t iextdefsym;\n  uint32_t nextdefsym;\n  uint32_t irefsym;\n  uint32_t nrefsym;\n  uint32_t ilocalsym;\n  uint32_t nlocalsym;\n  uint32_t iextrel;\n  uint32_t nextrel;\n  uint32_t iinit_iterm;\n  uint32_t ninit_nterm;\n  uint32_t objc_module_info_size;\n  uint64_t objc_module_info_addr;\n};\n\nstruct dylib_reference {\n  uint32_t isym : 24, flags : 8;\n};\n\n// The twolevel_hints_command is obsolete and no longer supported.\nstruct twolevel_hints_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t offset;\n  uint32_t nhints;\n};\n\n// The twolevel_hints_command is obsolete and no longer supported.\nstruct twolevel_hint {\n  uint32_t isub_image : 8, itoc : 24;\n};\n\n// The prebind_cksum_command is obsolete and no longer supported.\nstruct prebind_cksum_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cksum;\n};\n\nstruct uuid_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint8_t uuid[16];\n};\n\nstruct rpath_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t path;\n};\n\nstruct linkedit_data_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t dataoff;\n  uint32_t datasize;\n};\n\nstruct data_in_code_entry {\n  uint32_t offset;\n  uint16_t length;\n  uint16_t kind;\n};\n\nstruct source_version_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint64_t version;\n};\n\nstruct encryption_info_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cryptoff;\n  uint32_t cryptsize;\n  uint32_t cryptid;\n};\n\nstruct encryption_info_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cryptoff;\n  uint32_t cryptsize;\n  uint32_t cryptid;\n  uint32_t pad;\n};\n\nstruct version_min_command {\n  uint32_t cmd;     // LC_VERSION_MIN_MACOSX or\n                    // LC_VERSION_MIN_IPHONEOS\n  uint32_t cmdsize; // sizeof(struct version_min_command)\n  uint32_t version; // X.Y.Z is encoded in nibbles xxxx.yy.zz\n  uint32_t sdk;     // X.Y.Z is encoded in nibbles xxxx.yy.zz\n};\n\nstruct note_command {\n  uint32_t cmd;        // LC_NOTE\n  uint32_t cmdsize;    // sizeof(struct note_command)\n  char data_owner[16]; // owner name for this LC_NOTE\n  uint64_t offset;     // file offset of this data\n  uint64_t size;       // length of data region\n};\n\nstruct build_tool_version {\n  uint32_t tool;    // enum for the tool\n  uint32_t version; // version of the tool\n};\n\nstruct build_version_command {\n  uint32_t cmd;      // LC_BUILD_VERSION\n  uint32_t cmdsize;  // sizeof(struct build_version_command) +\n                     // ntools * sizeof(struct build_tool_version)\n  uint32_t platform; // platform\n  uint32_t minos;    // X.Y.Z is encoded in nibbles xxxx.yy.zz\n  uint32_t sdk;      // X.Y.Z is encoded in nibbles xxxx.yy.zz\n  uint32_t ntools;   // number of tool entries following this\n};\n\nstruct dyld_info_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t rebase_off;\n  uint32_t rebase_size;\n  uint32_t bind_off;\n  uint32_t bind_size;\n  uint32_t weak_bind_off;\n  uint32_t weak_bind_size;\n  uint32_t lazy_bind_off;\n  uint32_t lazy_bind_size;\n  uint32_t export_off;\n  uint32_t export_size;\n};\n\nstruct linker_option_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t count;\n};\n\n// The symseg_command is obsolete and no longer supported.\nstruct symseg_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t offset;\n  uint32_t size;\n};\n\n// The ident_command is obsolete and no longer supported.\nstruct ident_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\n// The fvmfile_command is obsolete and no longer supported.\nstruct fvmfile_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t name;\n  uint32_t header_addr;\n};\n\nstruct tlv_descriptor_32 {\n  uint32_t thunk;\n  uint32_t key;\n  uint32_t offset;\n};\n\nstruct tlv_descriptor_64 {\n  uint64_t thunk;\n  uint64_t key;\n  uint64_t offset;\n};\n\nstruct tlv_descriptor {\n  uintptr_t thunk;\n  uintptr_t key;\n  uintptr_t offset;\n};\n\nstruct entry_point_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint64_t entryoff;\n  uint64_t stacksize;\n};\n\n// Structs from <mach-o/fat.h>\nstruct fat_header {\n  uint32_t magic;\n  uint32_t nfat_arch;\n};\n\nstruct fat_arch {\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint32_t offset;\n  uint32_t size;\n  uint32_t align;\n};\n\nstruct fat_arch_64 {\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint64_t offset;\n  uint64_t size;\n  uint32_t align;\n  uint32_t reserved;\n};\n\n// Structs from <mach-o/reloc.h>\nstruct relocation_info {\n  int32_t r_address;\n  uint32_t r_symbolnum : 24, r_pcrel : 1, r_length : 2, r_extern : 1,\n      r_type : 4;\n};\n\nstruct scattered_relocation_info {\n#if defined(BYTE_ORDER) && defined(BIG_ENDIAN) && (BYTE_ORDER == BIG_ENDIAN)\n  uint32_t r_scattered : 1, r_pcrel : 1, r_length : 2, r_type : 4,\n      r_address : 24;\n#else\n  uint32_t r_address : 24, r_type : 4, r_length : 2, r_pcrel : 1,\n      r_scattered : 1;\n#endif\n  int32_t r_value;\n};\n\n// Structs NOT from <mach-o/reloc.h>, but that make LLVM's life easier\nstruct any_relocation_info {\n  uint32_t r_word0, r_word1;\n};\n\n// Structs from <mach-o/nlist.h>\nstruct nlist_base {\n  uint32_t n_strx;\n  uint8_t n_type;\n  uint8_t n_sect;\n  uint16_t n_desc;\n};\n\nstruct nlist {\n  uint32_t n_strx;\n  uint8_t n_type;\n  uint8_t n_sect;\n  int16_t n_desc;\n  uint32_t n_value;\n};\n\nstruct nlist_64 {\n  uint32_t n_strx;\n  uint8_t n_type;\n  uint8_t n_sect;\n  uint16_t n_desc;\n  uint64_t n_value;\n};\n\n// Byte order swapping functions for MachO structs\n\ninline void swapStruct(fat_header &mh) {\n  sys::swapByteOrder(mh.magic);\n  sys::swapByteOrder(mh.nfat_arch);\n}\n\ninline void swapStruct(fat_arch &mh) {\n  sys::swapByteOrder(mh.cputype);\n  sys::swapByteOrder(mh.cpusubtype);\n  sys::swapByteOrder(mh.offset);\n  sys::swapByteOrder(mh.size);\n  sys::swapByteOrder(mh.align);\n}\n\ninline void swapStruct(fat_arch_64 &mh) {\n  sys::swapByteOrder(mh.cputype);\n  sys::swapByteOrder(mh.cpusubtype);\n  sys::swapByteOrder(mh.offset);\n  sys::swapByteOrder(mh.size);\n  sys::swapByteOrder(mh.align);\n  sys::swapByteOrder(mh.reserved);\n}\n\ninline void swapStruct(mach_header &mh) {\n  sys::swapByteOrder(mh.magic);\n  sys::swapByteOrder(mh.cputype);\n  sys::swapByteOrder(mh.cpusubtype);\n  sys::swapByteOrder(mh.filetype);\n  sys::swapByteOrder(mh.ncmds);\n  sys::swapByteOrder(mh.sizeofcmds);\n  sys::swapByteOrder(mh.flags);\n}\n\ninline void swapStruct(mach_header_64 &H) {\n  sys::swapByteOrder(H.magic);\n  sys::swapByteOrder(H.cputype);\n  sys::swapByteOrder(H.cpusubtype);\n  sys::swapByteOrder(H.filetype);\n  sys::swapByteOrder(H.ncmds);\n  sys::swapByteOrder(H.sizeofcmds);\n  sys::swapByteOrder(H.flags);\n  sys::swapByteOrder(H.reserved);\n}\n\ninline void swapStruct(load_command &lc) {\n  sys::swapByteOrder(lc.cmd);\n  sys::swapByteOrder(lc.cmdsize);\n}\n\ninline void swapStruct(symtab_command &lc) {\n  sys::swapByteOrder(lc.cmd);\n  sys::swapByteOrder(lc.cmdsize);\n  sys::swapByteOrder(lc.symoff);\n  sys::swapByteOrder(lc.nsyms);\n  sys::swapByteOrder(lc.stroff);\n  sys::swapByteOrder(lc.strsize);\n}\n\ninline void swapStruct(segment_command_64 &seg) {\n  sys::swapByteOrder(seg.cmd);\n  sys::swapByteOrder(seg.cmdsize);\n  sys::swapByteOrder(seg.vmaddr);\n  sys::swapByteOrder(seg.vmsize);\n  sys::swapByteOrder(seg.fileoff);\n  sys::swapByteOrder(seg.filesize);\n  sys::swapByteOrder(seg.maxprot);\n  sys::swapByteOrder(seg.initprot);\n  sys::swapByteOrder(seg.nsects);\n  sys::swapByteOrder(seg.flags);\n}\n\ninline void swapStruct(segment_command &seg) {\n  sys::swapByteOrder(seg.cmd);\n  sys::swapByteOrder(seg.cmdsize);\n  sys::swapByteOrder(seg.vmaddr);\n  sys::swapByteOrder(seg.vmsize);\n  sys::swapByteOrder(seg.fileoff);\n  sys::swapByteOrder(seg.filesize);\n  sys::swapByteOrder(seg.maxprot);\n  sys::swapByteOrder(seg.initprot);\n  sys::swapByteOrder(seg.nsects);\n  sys::swapByteOrder(seg.flags);\n}\n\ninline void swapStruct(section_64 &sect) {\n  sys::swapByteOrder(sect.addr);\n  sys::swapByteOrder(sect.size);\n  sys::swapByteOrder(sect.offset);\n  sys::swapByteOrder(sect.align);\n  sys::swapByteOrder(sect.reloff);\n  sys::swapByteOrder(sect.nreloc);\n  sys::swapByteOrder(sect.flags);\n  sys::swapByteOrder(sect.reserved1);\n  sys::swapByteOrder(sect.reserved2);\n}\n\ninline void swapStruct(section &sect) {\n  sys::swapByteOrder(sect.addr);\n  sys::swapByteOrder(sect.size);\n  sys::swapByteOrder(sect.offset);\n  sys::swapByteOrder(sect.align);\n  sys::swapByteOrder(sect.reloff);\n  sys::swapByteOrder(sect.nreloc);\n  sys::swapByteOrder(sect.flags);\n  sys::swapByteOrder(sect.reserved1);\n  sys::swapByteOrder(sect.reserved2);\n}\n\ninline void swapStruct(dyld_info_command &info) {\n  sys::swapByteOrder(info.cmd);\n  sys::swapByteOrder(info.cmdsize);\n  sys::swapByteOrder(info.rebase_off);\n  sys::swapByteOrder(info.rebase_size);\n  sys::swapByteOrder(info.bind_off);\n  sys::swapByteOrder(info.bind_size);\n  sys::swapByteOrder(info.weak_bind_off);\n  sys::swapByteOrder(info.weak_bind_size);\n  sys::swapByteOrder(info.lazy_bind_off);\n  sys::swapByteOrder(info.lazy_bind_size);\n  sys::swapByteOrder(info.export_off);\n  sys::swapByteOrder(info.export_size);\n}\n\ninline void swapStruct(dylib_command &d) {\n  sys::swapByteOrder(d.cmd);\n  sys::swapByteOrder(d.cmdsize);\n  sys::swapByteOrder(d.dylib.name);\n  sys::swapByteOrder(d.dylib.timestamp);\n  sys::swapByteOrder(d.dylib.current_version);\n  sys::swapByteOrder(d.dylib.compatibility_version);\n}\n\ninline void swapStruct(sub_framework_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.umbrella);\n}\n\ninline void swapStruct(sub_umbrella_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.sub_umbrella);\n}\n\ninline void swapStruct(sub_library_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.sub_library);\n}\n\ninline void swapStruct(sub_client_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.client);\n}\n\ninline void swapStruct(routines_command &r) {\n  sys::swapByteOrder(r.cmd);\n  sys::swapByteOrder(r.cmdsize);\n  sys::swapByteOrder(r.init_address);\n  sys::swapByteOrder(r.init_module);\n  sys::swapByteOrder(r.reserved1);\n  sys::swapByteOrder(r.reserved2);\n  sys::swapByteOrder(r.reserved3);\n  sys::swapByteOrder(r.reserved4);\n  sys::swapByteOrder(r.reserved5);\n  sys::swapByteOrder(r.reserved6);\n}\n\ninline void swapStruct(routines_command_64 &r) {\n  sys::swapByteOrder(r.cmd);\n  sys::swapByteOrder(r.cmdsize);\n  sys::swapByteOrder(r.init_address);\n  sys::swapByteOrder(r.init_module);\n  sys::swapByteOrder(r.reserved1);\n  sys::swapByteOrder(r.reserved2);\n  sys::swapByteOrder(r.reserved3);\n  sys::swapByteOrder(r.reserved4);\n  sys::swapByteOrder(r.reserved5);\n  sys::swapByteOrder(r.reserved6);\n}\n\ninline void swapStruct(thread_command &t) {\n  sys::swapByteOrder(t.cmd);\n  sys::swapByteOrder(t.cmdsize);\n}\n\ninline void swapStruct(dylinker_command &d) {\n  sys::swapByteOrder(d.cmd);\n  sys::swapByteOrder(d.cmdsize);\n  sys::swapByteOrder(d.name);\n}\n\ninline void swapStruct(uuid_command &u) {\n  sys::swapByteOrder(u.cmd);\n  sys::swapByteOrder(u.cmdsize);\n}\n\ninline void swapStruct(rpath_command &r) {\n  sys::swapByteOrder(r.cmd);\n  sys::swapByteOrder(r.cmdsize);\n  sys::swapByteOrder(r.path);\n}\n\ninline void swapStruct(source_version_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.version);\n}\n\ninline void swapStruct(entry_point_command &e) {\n  sys::swapByteOrder(e.cmd);\n  sys::swapByteOrder(e.cmdsize);\n  sys::swapByteOrder(e.entryoff);\n  sys::swapByteOrder(e.stacksize);\n}\n\ninline void swapStruct(encryption_info_command &e) {\n  sys::swapByteOrder(e.cmd);\n  sys::swapByteOrder(e.cmdsize);\n  sys::swapByteOrder(e.cryptoff);\n  sys::swapByteOrder(e.cryptsize);\n  sys::swapByteOrder(e.cryptid);\n}\n\ninline void swapStruct(encryption_info_command_64 &e) {\n  sys::swapByteOrder(e.cmd);\n  sys::swapByteOrder(e.cmdsize);\n  sys::swapByteOrder(e.cryptoff);\n  sys::swapByteOrder(e.cryptsize);\n  sys::swapByteOrder(e.cryptid);\n  sys::swapByteOrder(e.pad);\n}\n\ninline void swapStruct(dysymtab_command &dst) {\n  sys::swapByteOrder(dst.cmd);\n  sys::swapByteOrder(dst.cmdsize);\n  sys::swapByteOrder(dst.ilocalsym);\n  sys::swapByteOrder(dst.nlocalsym);\n  sys::swapByteOrder(dst.iextdefsym);\n  sys::swapByteOrder(dst.nextdefsym);\n  sys::swapByteOrder(dst.iundefsym);\n  sys::swapByteOrder(dst.nundefsym);\n  sys::swapByteOrder(dst.tocoff);\n  sys::swapByteOrder(dst.ntoc);\n  sys::swapByteOrder(dst.modtaboff);\n  sys::swapByteOrder(dst.nmodtab);\n  sys::swapByteOrder(dst.extrefsymoff);\n  sys::swapByteOrder(dst.nextrefsyms);\n  sys::swapByteOrder(dst.indirectsymoff);\n  sys::swapByteOrder(dst.nindirectsyms);\n  sys::swapByteOrder(dst.extreloff);\n  sys::swapByteOrder(dst.nextrel);\n  sys::swapByteOrder(dst.locreloff);\n  sys::swapByteOrder(dst.nlocrel);\n}\n\ninline void swapStruct(any_relocation_info &reloc) {\n  sys::swapByteOrder(reloc.r_word0);\n  sys::swapByteOrder(reloc.r_word1);\n}\n\ninline void swapStruct(nlist_base &S) {\n  sys::swapByteOrder(S.n_strx);\n  sys::swapByteOrder(S.n_desc);\n}\n\ninline void swapStruct(nlist &sym) {\n  sys::swapByteOrder(sym.n_strx);\n  sys::swapByteOrder(sym.n_desc);\n  sys::swapByteOrder(sym.n_value);\n}\n\ninline void swapStruct(nlist_64 &sym) {\n  sys::swapByteOrder(sym.n_strx);\n  sys::swapByteOrder(sym.n_desc);\n  sys::swapByteOrder(sym.n_value);\n}\n\ninline void swapStruct(linkedit_data_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.dataoff);\n  sys::swapByteOrder(C.datasize);\n}\n\ninline void swapStruct(linker_option_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.count);\n}\n\ninline void swapStruct(version_min_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.version);\n  sys::swapByteOrder(C.sdk);\n}\n\ninline void swapStruct(note_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.size);\n}\n\ninline void swapStruct(build_version_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.platform);\n  sys::swapByteOrder(C.minos);\n  sys::swapByteOrder(C.sdk);\n  sys::swapByteOrder(C.ntools);\n}\n\ninline void swapStruct(build_tool_version &C) {\n  sys::swapByteOrder(C.tool);\n  sys::swapByteOrder(C.version);\n}\n\ninline void swapStruct(data_in_code_entry &C) {\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.length);\n  sys::swapByteOrder(C.kind);\n}\n\ninline void swapStruct(uint32_t &C) { sys::swapByteOrder(C); }\n\n// The prebind_cksum_command is obsolete and no longer supported.\ninline void swapStruct(prebind_cksum_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.cksum);\n}\n\n// The twolevel_hints_command is obsolete and no longer supported.\ninline void swapStruct(twolevel_hints_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.nhints);\n}\n\n// The prebound_dylib_command is obsolete and no longer supported.\ninline void swapStruct(prebound_dylib_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.name);\n  sys::swapByteOrder(C.nmodules);\n  sys::swapByteOrder(C.linked_modules);\n}\n\n// The fvmfile_command is obsolete and no longer supported.\ninline void swapStruct(fvmfile_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.name);\n  sys::swapByteOrder(C.header_addr);\n}\n\n// The symseg_command is obsolete and no longer supported.\ninline void swapStruct(symseg_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.size);\n}\n\n// The ident_command is obsolete and no longer supported.\ninline void swapStruct(ident_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n}\n\ninline void swapStruct(fvmlib &C) {\n  sys::swapByteOrder(C.name);\n  sys::swapByteOrder(C.minor_version);\n  sys::swapByteOrder(C.header_addr);\n}\n\n// The fvmlib_command is obsolete and no longer supported.\ninline void swapStruct(fvmlib_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  swapStruct(C.fvmlib);\n}\n\n// Get/Set functions from <mach-o/nlist.h>\n\ninline uint16_t GET_LIBRARY_ORDINAL(uint16_t n_desc) {\n  return (((n_desc) >> 8u) & 0xffu);\n}\n\ninline void SET_LIBRARY_ORDINAL(uint16_t &n_desc, uint8_t ordinal) {\n  n_desc = (((n_desc)&0x00ff) | (((ordinal)&0xff) << 8));\n}\n\ninline uint8_t GET_COMM_ALIGN(uint16_t n_desc) {\n  return (n_desc >> 8u) & 0x0fu;\n}\n\ninline void SET_COMM_ALIGN(uint16_t &n_desc, uint8_t align) {\n  n_desc = ((n_desc & 0xf0ffu) | ((align & 0x0fu) << 8u));\n}\n\n// Enums from <mach/machine.h>\nenum : uint32_t {\n  // Capability bits used in the definition of cpu_type.\n  CPU_ARCH_MASK = 0xff000000, // Mask for architecture bits\n  CPU_ARCH_ABI64 = 0x01000000, // 64 bit ABI\n  CPU_ARCH_ABI64_32 = 0x02000000, // ILP32 ABI on 64-bit hardware\n};\n\n// Constants for the cputype field.\nenum CPUType {\n  CPU_TYPE_ANY = -1,\n  CPU_TYPE_X86 = 7,\n  CPU_TYPE_I386 = CPU_TYPE_X86,\n  CPU_TYPE_X86_64 = CPU_TYPE_X86 | CPU_ARCH_ABI64,\n  /* CPU_TYPE_MIPS      = 8, */\n  CPU_TYPE_MC98000 = 10, // Old Motorola PowerPC\n  CPU_TYPE_ARM = 12,\n  CPU_TYPE_ARM64 = CPU_TYPE_ARM | CPU_ARCH_ABI64,\n  CPU_TYPE_ARM64_32 = CPU_TYPE_ARM | CPU_ARCH_ABI64_32,\n  CPU_TYPE_SPARC = 14,\n  CPU_TYPE_POWERPC = 18,\n  CPU_TYPE_POWERPC64 = CPU_TYPE_POWERPC | CPU_ARCH_ABI64\n};\n\nenum : uint32_t {\n  // Capability bits used in the definition of cpusubtype.\n  CPU_SUBTYPE_MASK = 0xff000000,  // Mask for architecture bits\n  CPU_SUBTYPE_LIB64 = 0x80000000, // 64 bit libraries\n\n  // Special CPU subtype constants.\n  CPU_SUBTYPE_MULTIPLE = ~0u\n};\n\n// Constants for the cpusubtype field.\nenum CPUSubTypeX86 {\n  CPU_SUBTYPE_I386_ALL = 3,\n  CPU_SUBTYPE_386 = 3,\n  CPU_SUBTYPE_486 = 4,\n  CPU_SUBTYPE_486SX = 0x84,\n  CPU_SUBTYPE_586 = 5,\n  CPU_SUBTYPE_PENT = CPU_SUBTYPE_586,\n  CPU_SUBTYPE_PENTPRO = 0x16,\n  CPU_SUBTYPE_PENTII_M3 = 0x36,\n  CPU_SUBTYPE_PENTII_M5 = 0x56,\n  CPU_SUBTYPE_CELERON = 0x67,\n  CPU_SUBTYPE_CELERON_MOBILE = 0x77,\n  CPU_SUBTYPE_PENTIUM_3 = 0x08,\n  CPU_SUBTYPE_PENTIUM_3_M = 0x18,\n  CPU_SUBTYPE_PENTIUM_3_XEON = 0x28,\n  CPU_SUBTYPE_PENTIUM_M = 0x09,\n  CPU_SUBTYPE_PENTIUM_4 = 0x0a,\n  CPU_SUBTYPE_PENTIUM_4_M = 0x1a,\n  CPU_SUBTYPE_ITANIUM = 0x0b,\n  CPU_SUBTYPE_ITANIUM_2 = 0x1b,\n  CPU_SUBTYPE_XEON = 0x0c,\n  CPU_SUBTYPE_XEON_MP = 0x1c,\n\n  CPU_SUBTYPE_X86_ALL = 3,\n  CPU_SUBTYPE_X86_64_ALL = 3,\n  CPU_SUBTYPE_X86_ARCH1 = 4,\n  CPU_SUBTYPE_X86_64_H = 8\n};\ninline int CPU_SUBTYPE_INTEL(int Family, int Model) {\n  return Family | (Model << 4);\n}\ninline int CPU_SUBTYPE_INTEL_FAMILY(CPUSubTypeX86 ST) {\n  return ((int)ST) & 0x0f;\n}\ninline int CPU_SUBTYPE_INTEL_MODEL(CPUSubTypeX86 ST) { return ((int)ST) >> 4; }\nenum { CPU_SUBTYPE_INTEL_FAMILY_MAX = 15, CPU_SUBTYPE_INTEL_MODEL_ALL = 0 };\n\nenum CPUSubTypeARM {\n  CPU_SUBTYPE_ARM_ALL = 0,\n  CPU_SUBTYPE_ARM_V4T = 5,\n  CPU_SUBTYPE_ARM_V6 = 6,\n  CPU_SUBTYPE_ARM_V5 = 7,\n  CPU_SUBTYPE_ARM_V5TEJ = 7,\n  CPU_SUBTYPE_ARM_XSCALE = 8,\n  CPU_SUBTYPE_ARM_V7 = 9,\n  //  unused  ARM_V7F     = 10,\n  CPU_SUBTYPE_ARM_V7S = 11,\n  CPU_SUBTYPE_ARM_V7K = 12,\n  CPU_SUBTYPE_ARM_V6M = 14,\n  CPU_SUBTYPE_ARM_V7M = 15,\n  CPU_SUBTYPE_ARM_V7EM = 16\n};\n\nenum CPUSubTypeARM64 {\n  CPU_SUBTYPE_ARM64_ALL = 0,\n  CPU_SUBTYPE_ARM64_V8 = 1,\n  CPU_SUBTYPE_ARM64E = 2,\n};\n\nenum CPUSubTypeARM64_32 { CPU_SUBTYPE_ARM64_32_V8 = 1 };\n\nenum CPUSubTypeSPARC { CPU_SUBTYPE_SPARC_ALL = 0 };\n\nenum CPUSubTypePowerPC {\n  CPU_SUBTYPE_POWERPC_ALL = 0,\n  CPU_SUBTYPE_POWERPC_601 = 1,\n  CPU_SUBTYPE_POWERPC_602 = 2,\n  CPU_SUBTYPE_POWERPC_603 = 3,\n  CPU_SUBTYPE_POWERPC_603e = 4,\n  CPU_SUBTYPE_POWERPC_603ev = 5,\n  CPU_SUBTYPE_POWERPC_604 = 6,\n  CPU_SUBTYPE_POWERPC_604e = 7,\n  CPU_SUBTYPE_POWERPC_620 = 8,\n  CPU_SUBTYPE_POWERPC_750 = 9,\n  CPU_SUBTYPE_POWERPC_7400 = 10,\n  CPU_SUBTYPE_POWERPC_7450 = 11,\n  CPU_SUBTYPE_POWERPC_970 = 100,\n\n  CPU_SUBTYPE_MC980000_ALL = CPU_SUBTYPE_POWERPC_ALL,\n  CPU_SUBTYPE_MC98601 = CPU_SUBTYPE_POWERPC_601\n};\n\nExpected<uint32_t> getCPUType(const Triple &T);\nExpected<uint32_t> getCPUSubType(const Triple &T);\n\nstruct x86_thread_state32_t {\n  uint32_t eax;\n  uint32_t ebx;\n  uint32_t ecx;\n  uint32_t edx;\n  uint32_t edi;\n  uint32_t esi;\n  uint32_t ebp;\n  uint32_t esp;\n  uint32_t ss;\n  uint32_t eflags;\n  uint32_t eip;\n  uint32_t cs;\n  uint32_t ds;\n  uint32_t es;\n  uint32_t fs;\n  uint32_t gs;\n};\n\nstruct x86_thread_state64_t {\n  uint64_t rax;\n  uint64_t rbx;\n  uint64_t rcx;\n  uint64_t rdx;\n  uint64_t rdi;\n  uint64_t rsi;\n  uint64_t rbp;\n  uint64_t rsp;\n  uint64_t r8;\n  uint64_t r9;\n  uint64_t r10;\n  uint64_t r11;\n  uint64_t r12;\n  uint64_t r13;\n  uint64_t r14;\n  uint64_t r15;\n  uint64_t rip;\n  uint64_t rflags;\n  uint64_t cs;\n  uint64_t fs;\n  uint64_t gs;\n};\n\nenum x86_fp_control_precis {\n  x86_FP_PREC_24B = 0,\n  x86_FP_PREC_53B = 2,\n  x86_FP_PREC_64B = 3\n};\n\nenum x86_fp_control_rc {\n  x86_FP_RND_NEAR = 0,\n  x86_FP_RND_DOWN = 1,\n  x86_FP_RND_UP = 2,\n  x86_FP_CHOP = 3\n};\n\nstruct fp_control_t {\n  unsigned short invalid : 1, denorm : 1, zdiv : 1, ovrfl : 1, undfl : 1,\n      precis : 1, : 2, pc : 2, rc : 2, : 1, : 3;\n};\n\nstruct fp_status_t {\n  unsigned short invalid : 1, denorm : 1, zdiv : 1, ovrfl : 1, undfl : 1,\n      precis : 1, stkflt : 1, errsumm : 1, c0 : 1, c1 : 1, c2 : 1, tos : 3,\n      c3 : 1, busy : 1;\n};\n\nstruct mmst_reg_t {\n  char mmst_reg[10];\n  char mmst_rsrv[6];\n};\n\nstruct xmm_reg_t {\n  char xmm_reg[16];\n};\n\nstruct x86_float_state64_t {\n  int32_t fpu_reserved[2];\n  fp_control_t fpu_fcw;\n  fp_status_t fpu_fsw;\n  uint8_t fpu_ftw;\n  uint8_t fpu_rsrv1;\n  uint16_t fpu_fop;\n  uint32_t fpu_ip;\n  uint16_t fpu_cs;\n  uint16_t fpu_rsrv2;\n  uint32_t fpu_dp;\n  uint16_t fpu_ds;\n  uint16_t fpu_rsrv3;\n  uint32_t fpu_mxcsr;\n  uint32_t fpu_mxcsrmask;\n  mmst_reg_t fpu_stmm0;\n  mmst_reg_t fpu_stmm1;\n  mmst_reg_t fpu_stmm2;\n  mmst_reg_t fpu_stmm3;\n  mmst_reg_t fpu_stmm4;\n  mmst_reg_t fpu_stmm5;\n  mmst_reg_t fpu_stmm6;\n  mmst_reg_t fpu_stmm7;\n  xmm_reg_t fpu_xmm0;\n  xmm_reg_t fpu_xmm1;\n  xmm_reg_t fpu_xmm2;\n  xmm_reg_t fpu_xmm3;\n  xmm_reg_t fpu_xmm4;\n  xmm_reg_t fpu_xmm5;\n  xmm_reg_t fpu_xmm6;\n  xmm_reg_t fpu_xmm7;\n  xmm_reg_t fpu_xmm8;\n  xmm_reg_t fpu_xmm9;\n  xmm_reg_t fpu_xmm10;\n  xmm_reg_t fpu_xmm11;\n  xmm_reg_t fpu_xmm12;\n  xmm_reg_t fpu_xmm13;\n  xmm_reg_t fpu_xmm14;\n  xmm_reg_t fpu_xmm15;\n  char fpu_rsrv4[6 * 16];\n  uint32_t fpu_reserved1;\n};\n\nstruct x86_exception_state64_t {\n  uint16_t trapno;\n  uint16_t cpu;\n  uint32_t err;\n  uint64_t faultvaddr;\n};\n\ninline void swapStruct(x86_thread_state32_t &x) {\n  sys::swapByteOrder(x.eax);\n  sys::swapByteOrder(x.ebx);\n  sys::swapByteOrder(x.ecx);\n  sys::swapByteOrder(x.edx);\n  sys::swapByteOrder(x.edi);\n  sys::swapByteOrder(x.esi);\n  sys::swapByteOrder(x.ebp);\n  sys::swapByteOrder(x.esp);\n  sys::swapByteOrder(x.ss);\n  sys::swapByteOrder(x.eflags);\n  sys::swapByteOrder(x.eip);\n  sys::swapByteOrder(x.cs);\n  sys::swapByteOrder(x.ds);\n  sys::swapByteOrder(x.es);\n  sys::swapByteOrder(x.fs);\n  sys::swapByteOrder(x.gs);\n}\n\ninline void swapStruct(x86_thread_state64_t &x) {\n  sys::swapByteOrder(x.rax);\n  sys::swapByteOrder(x.rbx);\n  sys::swapByteOrder(x.rcx);\n  sys::swapByteOrder(x.rdx);\n  sys::swapByteOrder(x.rdi);\n  sys::swapByteOrder(x.rsi);\n  sys::swapByteOrder(x.rbp);\n  sys::swapByteOrder(x.rsp);\n  sys::swapByteOrder(x.r8);\n  sys::swapByteOrder(x.r9);\n  sys::swapByteOrder(x.r10);\n  sys::swapByteOrder(x.r11);\n  sys::swapByteOrder(x.r12);\n  sys::swapByteOrder(x.r13);\n  sys::swapByteOrder(x.r14);\n  sys::swapByteOrder(x.r15);\n  sys::swapByteOrder(x.rip);\n  sys::swapByteOrder(x.rflags);\n  sys::swapByteOrder(x.cs);\n  sys::swapByteOrder(x.fs);\n  sys::swapByteOrder(x.gs);\n}\n\ninline void swapStruct(x86_float_state64_t &x) {\n  sys::swapByteOrder(x.fpu_reserved[0]);\n  sys::swapByteOrder(x.fpu_reserved[1]);\n  // TODO swap: fp_control_t fpu_fcw;\n  // TODO swap: fp_status_t fpu_fsw;\n  sys::swapByteOrder(x.fpu_fop);\n  sys::swapByteOrder(x.fpu_ip);\n  sys::swapByteOrder(x.fpu_cs);\n  sys::swapByteOrder(x.fpu_rsrv2);\n  sys::swapByteOrder(x.fpu_dp);\n  sys::swapByteOrder(x.fpu_ds);\n  sys::swapByteOrder(x.fpu_rsrv3);\n  sys::swapByteOrder(x.fpu_mxcsr);\n  sys::swapByteOrder(x.fpu_mxcsrmask);\n  sys::swapByteOrder(x.fpu_reserved1);\n}\n\ninline void swapStruct(x86_exception_state64_t &x) {\n  sys::swapByteOrder(x.trapno);\n  sys::swapByteOrder(x.cpu);\n  sys::swapByteOrder(x.err);\n  sys::swapByteOrder(x.faultvaddr);\n}\n\nstruct x86_state_hdr_t {\n  uint32_t flavor;\n  uint32_t count;\n};\n\nstruct x86_thread_state_t {\n  x86_state_hdr_t tsh;\n  union {\n    x86_thread_state64_t ts64;\n    x86_thread_state32_t ts32;\n  } uts;\n};\n\nstruct x86_float_state_t {\n  x86_state_hdr_t fsh;\n  union {\n    x86_float_state64_t fs64;\n  } ufs;\n};\n\nstruct x86_exception_state_t {\n  x86_state_hdr_t esh;\n  union {\n    x86_exception_state64_t es64;\n  } ues;\n};\n\ninline void swapStruct(x86_state_hdr_t &x) {\n  sys::swapByteOrder(x.flavor);\n  sys::swapByteOrder(x.count);\n}\n\nenum X86ThreadFlavors {\n  x86_THREAD_STATE32 = 1,\n  x86_FLOAT_STATE32 = 2,\n  x86_EXCEPTION_STATE32 = 3,\n  x86_THREAD_STATE64 = 4,\n  x86_FLOAT_STATE64 = 5,\n  x86_EXCEPTION_STATE64 = 6,\n  x86_THREAD_STATE = 7,\n  x86_FLOAT_STATE = 8,\n  x86_EXCEPTION_STATE = 9,\n  x86_DEBUG_STATE32 = 10,\n  x86_DEBUG_STATE64 = 11,\n  x86_DEBUG_STATE = 12\n};\n\ninline void swapStruct(x86_thread_state_t &x) {\n  swapStruct(x.tsh);\n  if (x.tsh.flavor == x86_THREAD_STATE64)\n    swapStruct(x.uts.ts64);\n}\n\ninline void swapStruct(x86_float_state_t &x) {\n  swapStruct(x.fsh);\n  if (x.fsh.flavor == x86_FLOAT_STATE64)\n    swapStruct(x.ufs.fs64);\n}\n\ninline void swapStruct(x86_exception_state_t &x) {\n  swapStruct(x.esh);\n  if (x.esh.flavor == x86_EXCEPTION_STATE64)\n    swapStruct(x.ues.es64);\n}\n\nconst uint32_t x86_THREAD_STATE32_COUNT =\n    sizeof(x86_thread_state32_t) / sizeof(uint32_t);\n\nconst uint32_t x86_THREAD_STATE64_COUNT =\n    sizeof(x86_thread_state64_t) / sizeof(uint32_t);\nconst uint32_t x86_FLOAT_STATE64_COUNT =\n    sizeof(x86_float_state64_t) / sizeof(uint32_t);\nconst uint32_t x86_EXCEPTION_STATE64_COUNT =\n    sizeof(x86_exception_state64_t) / sizeof(uint32_t);\n\nconst uint32_t x86_THREAD_STATE_COUNT =\n    sizeof(x86_thread_state_t) / sizeof(uint32_t);\nconst uint32_t x86_FLOAT_STATE_COUNT =\n    sizeof(x86_float_state_t) / sizeof(uint32_t);\nconst uint32_t x86_EXCEPTION_STATE_COUNT =\n    sizeof(x86_exception_state_t) / sizeof(uint32_t);\n\nstruct arm_thread_state32_t {\n  uint32_t r[13];\n  uint32_t sp;\n  uint32_t lr;\n  uint32_t pc;\n  uint32_t cpsr;\n};\n\ninline void swapStruct(arm_thread_state32_t &x) {\n  for (int i = 0; i < 13; i++)\n    sys::swapByteOrder(x.r[i]);\n  sys::swapByteOrder(x.sp);\n  sys::swapByteOrder(x.lr);\n  sys::swapByteOrder(x.pc);\n  sys::swapByteOrder(x.cpsr);\n}\n\nstruct arm_thread_state64_t {\n  uint64_t x[29];\n  uint64_t fp;\n  uint64_t lr;\n  uint64_t sp;\n  uint64_t pc;\n  uint32_t cpsr;\n  uint32_t pad;\n};\n\ninline void swapStruct(arm_thread_state64_t &x) {\n  for (int i = 0; i < 29; i++)\n    sys::swapByteOrder(x.x[i]);\n  sys::swapByteOrder(x.fp);\n  sys::swapByteOrder(x.lr);\n  sys::swapByteOrder(x.sp);\n  sys::swapByteOrder(x.pc);\n  sys::swapByteOrder(x.cpsr);\n}\n\nstruct arm_state_hdr_t {\n  uint32_t flavor;\n  uint32_t count;\n};\n\nstruct arm_thread_state_t {\n  arm_state_hdr_t tsh;\n  union {\n    arm_thread_state32_t ts32;\n  } uts;\n};\n\ninline void swapStruct(arm_state_hdr_t &x) {\n  sys::swapByteOrder(x.flavor);\n  sys::swapByteOrder(x.count);\n}\n\nenum ARMThreadFlavors {\n  ARM_THREAD_STATE = 1,\n  ARM_VFP_STATE = 2,\n  ARM_EXCEPTION_STATE = 3,\n  ARM_DEBUG_STATE = 4,\n  ARN_THREAD_STATE_NONE = 5,\n  ARM_THREAD_STATE64 = 6,\n  ARM_EXCEPTION_STATE64 = 7\n};\n\ninline void swapStruct(arm_thread_state_t &x) {\n  swapStruct(x.tsh);\n  if (x.tsh.flavor == ARM_THREAD_STATE)\n    swapStruct(x.uts.ts32);\n}\n\nconst uint32_t ARM_THREAD_STATE_COUNT =\n    sizeof(arm_thread_state32_t) / sizeof(uint32_t);\n\nconst uint32_t ARM_THREAD_STATE64_COUNT =\n    sizeof(arm_thread_state64_t) / sizeof(uint32_t);\n\nstruct ppc_thread_state32_t {\n  uint32_t srr0;\n  uint32_t srr1;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t r4;\n  uint32_t r5;\n  uint32_t r6;\n  uint32_t r7;\n  uint32_t r8;\n  uint32_t r9;\n  uint32_t r10;\n  uint32_t r11;\n  uint32_t r12;\n  uint32_t r13;\n  uint32_t r14;\n  uint32_t r15;\n  uint32_t r16;\n  uint32_t r17;\n  uint32_t r18;\n  uint32_t r19;\n  uint32_t r20;\n  uint32_t r21;\n  uint32_t r22;\n  uint32_t r23;\n  uint32_t r24;\n  uint32_t r25;\n  uint32_t r26;\n  uint32_t r27;\n  uint32_t r28;\n  uint32_t r29;\n  uint32_t r30;\n  uint32_t r31;\n  uint32_t ct;\n  uint32_t xer;\n  uint32_t lr;\n  uint32_t ctr;\n  uint32_t mq;\n  uint32_t vrsave;\n};\n\ninline void swapStruct(ppc_thread_state32_t &x) {\n  sys::swapByteOrder(x.srr0);\n  sys::swapByteOrder(x.srr1);\n  sys::swapByteOrder(x.r0);\n  sys::swapByteOrder(x.r1);\n  sys::swapByteOrder(x.r2);\n  sys::swapByteOrder(x.r3);\n  sys::swapByteOrder(x.r4);\n  sys::swapByteOrder(x.r5);\n  sys::swapByteOrder(x.r6);\n  sys::swapByteOrder(x.r7);\n  sys::swapByteOrder(x.r8);\n  sys::swapByteOrder(x.r9);\n  sys::swapByteOrder(x.r10);\n  sys::swapByteOrder(x.r11);\n  sys::swapByteOrder(x.r12);\n  sys::swapByteOrder(x.r13);\n  sys::swapByteOrder(x.r14);\n  sys::swapByteOrder(x.r15);\n  sys::swapByteOrder(x.r16);\n  sys::swapByteOrder(x.r17);\n  sys::swapByteOrder(x.r18);\n  sys::swapByteOrder(x.r19);\n  sys::swapByteOrder(x.r20);\n  sys::swapByteOrder(x.r21);\n  sys::swapByteOrder(x.r22);\n  sys::swapByteOrder(x.r23);\n  sys::swapByteOrder(x.r24);\n  sys::swapByteOrder(x.r25);\n  sys::swapByteOrder(x.r26);\n  sys::swapByteOrder(x.r27);\n  sys::swapByteOrder(x.r28);\n  sys::swapByteOrder(x.r29);\n  sys::swapByteOrder(x.r30);\n  sys::swapByteOrder(x.r31);\n  sys::swapByteOrder(x.ct);\n  sys::swapByteOrder(x.xer);\n  sys::swapByteOrder(x.lr);\n  sys::swapByteOrder(x.ctr);\n  sys::swapByteOrder(x.mq);\n  sys::swapByteOrder(x.vrsave);\n}\n\nstruct ppc_state_hdr_t {\n  uint32_t flavor;\n  uint32_t count;\n};\n\nstruct ppc_thread_state_t {\n  ppc_state_hdr_t tsh;\n  union {\n    ppc_thread_state32_t ts32;\n  } uts;\n};\n\ninline void swapStruct(ppc_state_hdr_t &x) {\n  sys::swapByteOrder(x.flavor);\n  sys::swapByteOrder(x.count);\n}\n\nenum PPCThreadFlavors {\n  PPC_THREAD_STATE = 1,\n  PPC_FLOAT_STATE = 2,\n  PPC_EXCEPTION_STATE = 3,\n  PPC_VECTOR_STATE = 4,\n  PPC_THREAD_STATE64 = 5,\n  PPC_EXCEPTION_STATE64 = 6,\n  PPC_THREAD_STATE_NONE = 7\n};\n\ninline void swapStruct(ppc_thread_state_t &x) {\n  swapStruct(x.tsh);\n  if (x.tsh.flavor == PPC_THREAD_STATE)\n    swapStruct(x.uts.ts32);\n}\n\nconst uint32_t PPC_THREAD_STATE_COUNT =\n    sizeof(ppc_thread_state32_t) / sizeof(uint32_t);\n\n// Define a union of all load command structs\n#define LOAD_COMMAND_STRUCT(LCStruct) LCStruct LCStruct##_data;\n\nLLVM_PACKED_START\nunion alignas(4) macho_load_command {\n#include \"llvm/BinaryFormat/MachO.def\"\n};\nLLVM_PACKED_END\n\n/* code signing attributes of a process */\n\nenum CodeSignAttrs {\n  CS_VALID = 0x00000001,          /* dynamically valid */\n  CS_ADHOC = 0x00000002,          /* ad hoc signed */\n  CS_GET_TASK_ALLOW = 0x00000004, /* has get-task-allow entitlement */\n  CS_INSTALLER = 0x00000008,      /* has installer entitlement */\n\n  CS_FORCED_LV =\n      0x00000010, /* Library Validation required by Hardened System Policy */\n  CS_INVALID_ALLOWED = 0x00000020, /* (macOS Only) Page invalidation allowed by\n                                      task port policy */\n\n  CS_HARD = 0x00000100,             /* don't load invalid pages */\n  CS_KILL = 0x00000200,             /* kill process if it becomes invalid */\n  CS_CHECK_EXPIRATION = 0x00000400, /* force expiration checking */\n  CS_RESTRICT = 0x00000800,         /* tell dyld to treat restricted */\n\n  CS_ENFORCEMENT = 0x00001000, /* require enforcement */\n  CS_REQUIRE_LV = 0x00002000,  /* require library validation */\n  CS_ENTITLEMENTS_VALIDATED =\n      0x00004000, /* code signature permits restricted entitlements */\n  CS_NVRAM_UNRESTRICTED =\n      0x00008000, /* has com.apple.rootless.restricted-nvram-variables.heritable\n                     entitlement */\n\n  CS_RUNTIME = 0x00010000,       /* Apply hardened runtime policies */\n  CS_LINKER_SIGNED = 0x00020000, /* Automatically signed by the linker */\n\n  CS_ALLOWED_MACHO =\n      (CS_ADHOC | CS_HARD | CS_KILL | CS_CHECK_EXPIRATION | CS_RESTRICT |\n       CS_ENFORCEMENT | CS_REQUIRE_LV | CS_RUNTIME | CS_LINKER_SIGNED),\n\n  CS_EXEC_SET_HARD = 0x00100000, /* set CS_HARD on any exec'ed process */\n  CS_EXEC_SET_KILL = 0x00200000, /* set CS_KILL on any exec'ed process */\n  CS_EXEC_SET_ENFORCEMENT =\n      0x00400000, /* set CS_ENFORCEMENT on any exec'ed process */\n  CS_EXEC_INHERIT_SIP =\n      0x00800000, /* set CS_INSTALLER on any exec'ed process */\n\n  CS_KILLED = 0x01000000, /* was killed by kernel for invalidity */\n  CS_DYLD_PLATFORM =\n      0x02000000, /* dyld used to load this is a platform binary */\n  CS_PLATFORM_BINARY = 0x04000000, /* this is a platform binary */\n  CS_PLATFORM_PATH =\n      0x08000000, /* platform binary by the fact of path (osx only) */\n\n  CS_DEBUGGED = 0x10000000, /* process is currently or has previously been\n                debugged and allowed to run with invalid pages */\n  CS_SIGNED = 0x20000000, /* process has a signature (may have gone invalid) */\n  CS_DEV_CODE =\n      0x40000000, /* code is dev signed, cannot be loaded into prod signed code\n                     (will go away with rdar://problem/28322552) */\n  CS_DATAVAULT_CONTROLLER =\n      0x80000000, /* has Data Vault controller entitlement */\n\n  CS_ENTITLEMENT_FLAGS = (CS_GET_TASK_ALLOW | CS_INSTALLER |\n                          CS_DATAVAULT_CONTROLLER | CS_NVRAM_UNRESTRICTED),\n};\n\n/* executable segment flags */\n\nenum CodeSignExecSegFlags {\n\n  CS_EXECSEG_MAIN_BINARY = 0x1,     /* executable segment denotes main binary */\n  CS_EXECSEG_ALLOW_UNSIGNED = 0x10, /* allow unsigned pages (for debugging) */\n  CS_EXECSEG_DEBUGGER = 0x20,       /* main binary is debugger */\n  CS_EXECSEG_JIT = 0x40,            /* JIT enabled */\n  CS_EXECSEG_SKIP_LV = 0x80,        /* OBSOLETE: skip library validation */\n  CS_EXECSEG_CAN_LOAD_CDHASH = 0x100, /* can bless cdhash for execution */\n  CS_EXECSEG_CAN_EXEC_CDHASH = 0x200, /* can execute blessed cdhash */\n\n};\n\n/* Magic numbers used by Code Signing */\n\nenum CodeSignMagic {\n  CSMAGIC_REQUIREMENT = 0xfade0c00, /* single Requirement blob */\n  CSMAGIC_REQUIREMENTS =\n      0xfade0c01, /* Requirements vector (internal requirements) */\n  CSMAGIC_CODEDIRECTORY = 0xfade0c02,      /* CodeDirectory blob */\n  CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */\n  CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02, /* XXX */\n  CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,  /* embedded entitlements */\n  CSMAGIC_DETACHED_SIGNATURE =\n      0xfade0cc1, /* multi-arch collection of embedded signatures */\n  CSMAGIC_BLOBWRAPPER = 0xfade0b01, /* CMS Signature, among other things */\n\n  CS_SUPPORTSSCATTER = 0x20100,\n  CS_SUPPORTSTEAMID = 0x20200,\n  CS_SUPPORTSCODELIMIT64 = 0x20300,\n  CS_SUPPORTSEXECSEG = 0x20400,\n  CS_SUPPORTSRUNTIME = 0x20500,\n  CS_SUPPORTSLINKAGE = 0x20600,\n\n  CSSLOT_CODEDIRECTORY = 0, /* slot index for CodeDirectory */\n  CSSLOT_INFOSLOT = 1,\n  CSSLOT_REQUIREMENTS = 2,\n  CSSLOT_RESOURCEDIR = 3,\n  CSSLOT_APPLICATION = 4,\n  CSSLOT_ENTITLEMENTS = 5,\n\n  CSSLOT_ALTERNATE_CODEDIRECTORIES =\n      0x1000, /* first alternate CodeDirectory, if any */\n  CSSLOT_ALTERNATE_CODEDIRECTORY_MAX = 5, /* max number of alternate CD slots */\n  CSSLOT_ALTERNATE_CODEDIRECTORY_LIMIT =\n      CSSLOT_ALTERNATE_CODEDIRECTORIES +\n      CSSLOT_ALTERNATE_CODEDIRECTORY_MAX, /* one past the last */\n\n  CSSLOT_SIGNATURESLOT = 0x10000, /* CMS Signature */\n  CSSLOT_IDENTIFICATIONSLOT = 0x10001,\n  CSSLOT_TICKETSLOT = 0x10002,\n\n  CSTYPE_INDEX_REQUIREMENTS = 0x00000002, /* compat with amfi */\n  CSTYPE_INDEX_ENTITLEMENTS = 0x00000005, /* compat with amfi */\n\n  CS_HASHTYPE_SHA1 = 1,\n  CS_HASHTYPE_SHA256 = 2,\n  CS_HASHTYPE_SHA256_TRUNCATED = 3,\n  CS_HASHTYPE_SHA384 = 4,\n\n  CS_SHA1_LEN = 20,\n  CS_SHA256_LEN = 32,\n  CS_SHA256_TRUNCATED_LEN = 20,\n\n  CS_CDHASH_LEN = 20,    /* always - larger hashes are truncated */\n  CS_HASH_MAX_SIZE = 48, /* max size of the hash we'll support */\n\n  /*\n   * Currently only to support Legacy VPN plugins, and Mac App Store\n   * but intended to replace all the various platform code, dev code etc. bits.\n   */\n  CS_SIGNER_TYPE_UNKNOWN = 0,\n  CS_SIGNER_TYPE_LEGACYVPN = 5,\n  CS_SIGNER_TYPE_MAC_APP_STORE = 6,\n\n  CS_SUPPL_SIGNER_TYPE_UNKNOWN = 0,\n  CS_SUPPL_SIGNER_TYPE_TRUSTCACHE = 7,\n  CS_SUPPL_SIGNER_TYPE_LOCAL = 8,\n};\n\nstruct CS_CodeDirectory {\n  uint32_t magic;         /* magic number (CSMAGIC_CODEDIRECTORY) */\n  uint32_t length;        /* total length of CodeDirectory blob */\n  uint32_t version;       /* compatibility version */\n  uint32_t flags;         /* setup and mode flags */\n  uint32_t hashOffset;    /* offset of hash slot element at index zero */\n  uint32_t identOffset;   /* offset of identifier string */\n  uint32_t nSpecialSlots; /* number of special hash slots */\n  uint32_t nCodeSlots;    /* number of ordinary (code) hash slots */\n  uint32_t codeLimit;     /* limit to main image signature range */\n  uint8_t hashSize;       /* size of each hash in bytes */\n  uint8_t hashType;       /* type of hash (cdHashType* constants) */\n  uint8_t platform;       /* platform identifier; zero if not platform binary */\n  uint8_t pageSize;       /* log2(page size in bytes); 0 => infinite */\n  uint32_t spare2;        /* unused (must be zero) */\n\n  /* Version 0x20100 */\n  uint32_t scatterOffset; /* offset of optional scatter vector */\n\n  /* Version 0x20200 */\n  uint32_t teamOffset; /* offset of optional team identifier */\n\n  /* Version 0x20300 */\n  uint32_t spare3;      /* unused (must be zero) */\n  uint64_t codeLimit64; /* limit to main image signature range, 64 bits */\n\n  /* Version 0x20400 */\n  uint64_t execSegBase;  /* offset of executable segment */\n  uint64_t execSegLimit; /* limit of executable segment */\n  uint64_t execSegFlags; /* executable segment flags */\n};\n\nstatic_assert(sizeof(CS_CodeDirectory) == 88, \"\");\n\nstruct CS_BlobIndex {\n  uint32_t type;   /* type of entry */\n  uint32_t offset; /* offset of entry */\n};\n\nstruct CS_SuperBlob {\n  uint32_t magic;  /* magic number */\n  uint32_t length; /* total length of SuperBlob */\n  uint32_t count;  /* number of index entries following */\n  /* followed by Blobs in no particular order as indicated by index offsets */\n};\n\nenum SecCSDigestAlgorithm {\n  kSecCodeSignatureNoHash = 0,     /* null value */\n  kSecCodeSignatureHashSHA1 = 1,   /* SHA-1 */\n  kSecCodeSignatureHashSHA256 = 2, /* SHA-256 */\n  kSecCodeSignatureHashSHA256Truncated =\n      3,                           /* SHA-256 truncated to first 20 bytes */\n  kSecCodeSignatureHashSHA384 = 4, /* SHA-384 */\n  kSecCodeSignatureHashSHA512 = 5, /* SHA-512 */\n};\n\n} // end namespace MachO\n} // end namespace llvm\n\n#endif\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "content": "//===- DWARFAcceleratorTable.h ----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFACCELERATORTABLE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFACCELERATORTABLE_H\n\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass ScopedPrinter;\n\n/// The accelerator tables are designed to allow efficient random access\n/// (using a symbol name as a key) into debug info by providing an index of the\n/// debug info DIEs. This class implements the common functionality of Apple and\n/// DWARF 5 accelerator tables.\n/// TODO: Generalize the rest of the AppleAcceleratorTable interface and move it\n/// to this class.\nclass DWARFAcceleratorTable {\nprotected:\n  DWARFDataExtractor AccelSection;\n  DataExtractor StringSection;\n\npublic:\n  /// An abstract class representing a single entry in the accelerator tables.\n  class Entry {\n  protected:\n    SmallVector<DWARFFormValue, 3> Values;\n\n    Entry() = default;\n\n    // Make these protected so only (final) subclasses can be copied around.\n    Entry(const Entry &) = default;\n    Entry(Entry &&) = default;\n    Entry &operator=(const Entry &) = default;\n    Entry &operator=(Entry &&) = default;\n    ~Entry() = default;\n\n\n  public:\n    /// Returns the Offset of the Compilation Unit associated with this\n    /// Accelerator Entry or None if the Compilation Unit offset is not recorded\n    /// in this Accelerator Entry.\n    virtual Optional<uint64_t> getCUOffset() const = 0;\n\n    /// Returns the Tag of the Debug Info Entry associated with this\n    /// Accelerator Entry or None if the Tag is not recorded in this\n    /// Accelerator Entry.\n    virtual Optional<dwarf::Tag> getTag() const = 0;\n\n    /// Returns the raw values of fields in the Accelerator Entry. In general,\n    /// these can only be interpreted with the help of the metadata in the\n    /// owning Accelerator Table.\n    ArrayRef<DWARFFormValue> getValues() const { return Values; }\n  };\n\n  DWARFAcceleratorTable(const DWARFDataExtractor &AccelSection,\n                        DataExtractor StringSection)\n      : AccelSection(AccelSection), StringSection(StringSection) {}\n  virtual ~DWARFAcceleratorTable();\n\n  virtual Error extract() = 0;\n  virtual void dump(raw_ostream &OS) const = 0;\n\n  DWARFAcceleratorTable(const DWARFAcceleratorTable &) = delete;\n  void operator=(const DWARFAcceleratorTable &) = delete;\n};\n\n/// This implements the Apple accelerator table format, a precursor of the\n/// DWARF 5 accelerator table format.\nclass AppleAcceleratorTable : public DWARFAcceleratorTable {\n  struct Header {\n    uint32_t Magic;\n    uint16_t Version;\n    uint16_t HashFunction;\n    uint32_t BucketCount;\n    uint32_t HashCount;\n    uint32_t HeaderDataLength;\n\n    void dump(ScopedPrinter &W) const;\n  };\n\n  struct HeaderData {\n    using AtomType = uint16_t;\n    using Form = dwarf::Form;\n\n    uint64_t DIEOffsetBase;\n    SmallVector<std::pair<AtomType, Form>, 3> Atoms;\n\n    Optional<uint64_t> extractOffset(Optional<DWARFFormValue> Value) const;\n  };\n\n  struct Header Hdr;\n  struct HeaderData HdrData;\n  bool IsValid = false;\n\n  /// Returns true if we should continue scanning for entries or false if we've\n  /// reached the last (sentinel) entry of encountered a parsing error.\n  bool dumpName(ScopedPrinter &W, SmallVectorImpl<DWARFFormValue> &AtomForms,\n                uint64_t *DataOffset) const;\n\npublic:\n  /// Apple-specific implementation of an Accelerator Entry.\n  class Entry final : public DWARFAcceleratorTable::Entry {\n    const HeaderData *HdrData = nullptr;\n\n    Entry(const HeaderData &Data);\n    Entry() = default;\n\n    void extract(const AppleAcceleratorTable &AccelTable, uint64_t *Offset);\n\n  public:\n    Optional<uint64_t> getCUOffset() const override;\n\n    /// Returns the Section Offset of the Debug Info Entry associated with this\n    /// Accelerator Entry or None if the DIE offset is not recorded in this\n    /// Accelerator Entry. The returned offset is relative to the start of the\n    /// Section containing the DIE.\n    Optional<uint64_t> getDIESectionOffset() const;\n\n    Optional<dwarf::Tag> getTag() const override;\n\n    /// Returns the value of the Atom in this Accelerator Entry, if the Entry\n    /// contains such Atom.\n    Optional<DWARFFormValue> lookup(HeaderData::AtomType Atom) const;\n\n    friend class AppleAcceleratorTable;\n    friend class ValueIterator;\n  };\n\n  class ValueIterator : public std::iterator<std::input_iterator_tag, Entry> {\n    const AppleAcceleratorTable *AccelTable = nullptr;\n    Entry Current;           ///< The current entry.\n    uint64_t DataOffset = 0; ///< Offset into the section.\n    unsigned Data = 0; ///< Current data entry.\n    unsigned NumData = 0; ///< Number of data entries.\n\n    /// Advance the iterator.\n    void Next();\n  public:\n    /// Construct a new iterator for the entries at \\p DataOffset.\n    ValueIterator(const AppleAcceleratorTable &AccelTable, uint64_t DataOffset);\n    /// End marker.\n    ValueIterator() = default;\n\n    const Entry &operator*() const { return Current; }\n    ValueIterator &operator++() { Next(); return *this; }\n    ValueIterator operator++(int) {\n      ValueIterator I = *this;\n      Next();\n      return I;\n    }\n    friend bool operator==(const ValueIterator &A, const ValueIterator &B) {\n      return A.NumData == B.NumData && A.DataOffset == B.DataOffset;\n    }\n    friend bool operator!=(const ValueIterator &A, const ValueIterator &B) {\n      return !(A == B);\n    }\n  };\n\n  AppleAcceleratorTable(const DWARFDataExtractor &AccelSection,\n                        DataExtractor StringSection)\n      : DWARFAcceleratorTable(AccelSection, StringSection) {}\n\n  Error extract() override;\n  uint32_t getNumBuckets();\n  uint32_t getNumHashes();\n  uint32_t getSizeHdr();\n  uint32_t getHeaderDataLength();\n\n  /// Return the Atom description, which can be used to interpret the raw values\n  /// of the Accelerator Entries in this table.\n  ArrayRef<std::pair<HeaderData::AtomType, HeaderData::Form>> getAtomsDesc();\n  bool validateForms();\n\n  /// Return information related to the DWARF DIE we're looking for when\n  /// performing a lookup by name.\n  ///\n  /// \\param HashDataOffset an offset into the hash data table\n  /// \\returns <DieOffset, DieTag>\n  /// DieOffset is the offset into the .debug_info section for the DIE\n  /// related to the input hash data offset.\n  /// DieTag is the tag of the DIE\n  std::pair<uint64_t, dwarf::Tag> readAtoms(uint64_t *HashDataOffset);\n  void dump(raw_ostream &OS) const override;\n\n  /// Look up all entries in the accelerator table matching \\c Key.\n  iterator_range<ValueIterator> equal_range(StringRef Key) const;\n};\n\n/// .debug_names section consists of one or more units. Each unit starts with a\n/// header, which is followed by a list of compilation units, local and foreign\n/// type units.\n///\n/// These may be followed by an (optional) hash lookup table, which consists of\n/// an array of buckets and hashes similar to the apple tables above. The only\n/// difference is that the hashes array is 1-based, and consequently an empty\n/// bucket is denoted by 0 and not UINT32_MAX.\n///\n/// Next is the name table, which consists of an array of names and array of\n/// entry offsets. This is different from the apple tables, which store names\n/// next to the actual entries.\n///\n/// The structure of the entries is described by an abbreviations table, which\n/// comes after the name table. Unlike the apple tables, which have a uniform\n/// entry structure described in the header, each .debug_names entry may have\n/// different index attributes (DW_IDX_???) attached to it.\n///\n/// The last segment consists of a list of entries, which is a 0-terminated list\n/// referenced by the name table and interpreted with the help of the\n/// abbreviation table.\nclass DWARFDebugNames : public DWARFAcceleratorTable {\npublic:\n  class NameIndex;\n  class NameIterator;\n  class ValueIterator;\n\n  /// DWARF v5 Name Index header.\n  struct Header {\n    uint64_t UnitLength;\n    dwarf::DwarfFormat Format;\n    uint16_t Version;\n    uint32_t CompUnitCount;\n    uint32_t LocalTypeUnitCount;\n    uint32_t ForeignTypeUnitCount;\n    uint32_t BucketCount;\n    uint32_t NameCount;\n    uint32_t AbbrevTableSize;\n    uint32_t AugmentationStringSize;\n    SmallString<8> AugmentationString;\n\n    Error extract(const DWARFDataExtractor &AS, uint64_t *Offset);\n    void dump(ScopedPrinter &W) const;\n  };\n\n  /// Index attribute and its encoding.\n  struct AttributeEncoding {\n    dwarf::Index Index;\n    dwarf::Form Form;\n\n    constexpr AttributeEncoding(dwarf::Index Index, dwarf::Form Form)\n        : Index(Index), Form(Form) {}\n\n    friend bool operator==(const AttributeEncoding &LHS,\n                           const AttributeEncoding &RHS) {\n      return LHS.Index == RHS.Index && LHS.Form == RHS.Form;\n    }\n  };\n\n  /// Abbreviation describing the encoding of Name Index entries.\n  struct Abbrev {\n    uint32_t Code;  ///< Abbreviation code\n    dwarf::Tag Tag; ///< Dwarf Tag of the described entity.\n    std::vector<AttributeEncoding> Attributes; ///< List of index attributes.\n\n    Abbrev(uint32_t Code, dwarf::Tag Tag,\n           std::vector<AttributeEncoding> Attributes)\n        : Code(Code), Tag(Tag), Attributes(std::move(Attributes)) {}\n\n    void dump(ScopedPrinter &W) const;\n  };\n\n  /// DWARF v5-specific implementation of an Accelerator Entry.\n  class Entry final : public DWARFAcceleratorTable::Entry {\n    const NameIndex *NameIdx;\n    const Abbrev *Abbr;\n\n    Entry(const NameIndex &NameIdx, const Abbrev &Abbr);\n\n  public:\n    Optional<uint64_t> getCUOffset() const override;\n    Optional<dwarf::Tag> getTag() const override { return tag(); }\n\n    /// Returns the Index into the Compilation Unit list of the owning Name\n    /// Index or None if this Accelerator Entry does not have an associated\n    /// Compilation Unit. It is up to the user to verify that the returned Index\n    /// is valid in the owning NameIndex (or use getCUOffset(), which will\n    /// handle that check itself). Note that entries in NameIndexes which index\n    /// just a single Compilation Unit are implicitly associated with that unit,\n    /// so this function will return 0 even without an explicit\n    /// DW_IDX_compile_unit attribute.\n    Optional<uint64_t> getCUIndex() const;\n\n    /// .debug_names-specific getter, which always succeeds (DWARF v5 index\n    /// entries always have a tag).\n    dwarf::Tag tag() const { return Abbr->Tag; }\n\n    /// Returns the Offset of the DIE within the containing CU or TU.\n    Optional<uint64_t> getDIEUnitOffset() const;\n\n    /// Return the Abbreviation that can be used to interpret the raw values of\n    /// this Accelerator Entry.\n    const Abbrev &getAbbrev() const { return *Abbr; }\n\n    /// Returns the value of the Index Attribute in this Accelerator Entry, if\n    /// the Entry contains such Attribute.\n    Optional<DWARFFormValue> lookup(dwarf::Index Index) const;\n\n    void dump(ScopedPrinter &W) const;\n\n    friend class NameIndex;\n    friend class ValueIterator;\n  };\n\n  /// Error returned by NameIndex::getEntry to report it has reached the end of\n  /// the entry list.\n  class SentinelError : public ErrorInfo<SentinelError> {\n  public:\n    static char ID;\n\n    void log(raw_ostream &OS) const override { OS << \"Sentinel\"; }\n    std::error_code convertToErrorCode() const override;\n  };\n\nprivate:\n  /// DenseMapInfo for struct Abbrev.\n  struct AbbrevMapInfo {\n    static Abbrev getEmptyKey();\n    static Abbrev getTombstoneKey();\n    static unsigned getHashValue(uint32_t Code) {\n      return DenseMapInfo<uint32_t>::getHashValue(Code);\n    }\n    static unsigned getHashValue(const Abbrev &Abbr) {\n      return getHashValue(Abbr.Code);\n    }\n    static bool isEqual(uint32_t LHS, const Abbrev &RHS) {\n      return LHS == RHS.Code;\n    }\n    static bool isEqual(const Abbrev &LHS, const Abbrev &RHS) {\n      return LHS.Code == RHS.Code;\n    }\n  };\n\npublic:\n  /// A single entry in the Name Table (DWARF v5 sect. 6.1.1.4.6) of the Name\n  /// Index.\n  class NameTableEntry {\n    DataExtractor StrData;\n\n    uint32_t Index;\n    uint64_t StringOffset;\n    uint64_t EntryOffset;\n\n  public:\n    NameTableEntry(const DataExtractor &StrData, uint32_t Index,\n                   uint64_t StringOffset, uint64_t EntryOffset)\n        : StrData(StrData), Index(Index), StringOffset(StringOffset),\n          EntryOffset(EntryOffset) {}\n\n    /// Return the index of this name in the parent Name Index.\n    uint32_t getIndex() const { return Index; }\n\n    /// Returns the offset of the name of the described entities.\n    uint64_t getStringOffset() const { return StringOffset; }\n\n    /// Return the string referenced by this name table entry or nullptr if the\n    /// string offset is not valid.\n    const char *getString() const {\n      uint64_t Off = StringOffset;\n      return StrData.getCStr(&Off);\n    }\n\n    /// Returns the offset of the first Entry in the list.\n    uint64_t getEntryOffset() const { return EntryOffset; }\n  };\n\n  /// Represents a single accelerator table within the DWARF v5 .debug_names\n  /// section.\n  class NameIndex {\n    DenseSet<Abbrev, AbbrevMapInfo> Abbrevs;\n    struct Header Hdr;\n    const DWARFDebugNames &Section;\n\n    // Base of the whole unit and of various important tables, as offsets from\n    // the start of the section.\n    uint64_t Base;\n    uint64_t CUsBase;\n    uint64_t BucketsBase;\n    uint64_t HashesBase;\n    uint64_t StringOffsetsBase;\n    uint64_t EntryOffsetsBase;\n    uint64_t EntriesBase;\n\n    void dumpCUs(ScopedPrinter &W) const;\n    void dumpLocalTUs(ScopedPrinter &W) const;\n    void dumpForeignTUs(ScopedPrinter &W) const;\n    void dumpAbbreviations(ScopedPrinter &W) const;\n    bool dumpEntry(ScopedPrinter &W, uint64_t *Offset) const;\n    void dumpName(ScopedPrinter &W, const NameTableEntry &NTE,\n                  Optional<uint32_t> Hash) const;\n    void dumpBucket(ScopedPrinter &W, uint32_t Bucket) const;\n\n    Expected<AttributeEncoding> extractAttributeEncoding(uint64_t *Offset);\n\n    Expected<std::vector<AttributeEncoding>>\n    extractAttributeEncodings(uint64_t *Offset);\n\n    Expected<Abbrev> extractAbbrev(uint64_t *Offset);\n\n  public:\n    NameIndex(const DWARFDebugNames &Section, uint64_t Base)\n        : Section(Section), Base(Base) {}\n\n    /// Reads offset of compilation unit CU. CU is 0-based.\n    uint64_t getCUOffset(uint32_t CU) const;\n    uint32_t getCUCount() const { return Hdr.CompUnitCount; }\n\n    /// Reads offset of local type unit TU, TU is 0-based.\n    uint64_t getLocalTUOffset(uint32_t TU) const;\n    uint32_t getLocalTUCount() const { return Hdr.LocalTypeUnitCount; }\n\n    /// Reads signature of foreign type unit TU. TU is 0-based.\n    uint64_t getForeignTUSignature(uint32_t TU) const;\n    uint32_t getForeignTUCount() const { return Hdr.ForeignTypeUnitCount; }\n\n    /// Reads an entry in the Bucket Array for the given Bucket. The returned\n    /// value is a (1-based) index into the Names, StringOffsets and\n    /// EntryOffsets arrays. The input Bucket index is 0-based.\n    uint32_t getBucketArrayEntry(uint32_t Bucket) const;\n    uint32_t getBucketCount() const { return Hdr.BucketCount; }\n\n    /// Reads an entry in the Hash Array for the given Index. The input Index\n    /// is 1-based.\n    uint32_t getHashArrayEntry(uint32_t Index) const;\n\n    /// Reads an entry in the Name Table for the given Index. The Name Table\n    /// consists of two arrays -- String Offsets and Entry Offsets. The returned\n    /// offsets are relative to the starts of respective sections. Input Index\n    /// is 1-based.\n    NameTableEntry getNameTableEntry(uint32_t Index) const;\n\n    uint32_t getNameCount() const { return Hdr.NameCount; }\n\n    const DenseSet<Abbrev, AbbrevMapInfo> &getAbbrevs() const {\n      return Abbrevs;\n    }\n\n    Expected<Entry> getEntry(uint64_t *Offset) const;\n\n    /// Look up all entries in this Name Index matching \\c Key.\n    iterator_range<ValueIterator> equal_range(StringRef Key) const;\n\n    NameIterator begin() const { return NameIterator(this, 1); }\n    NameIterator end() const { return NameIterator(this, getNameCount() + 1); }\n\n    Error extract();\n    uint64_t getUnitOffset() const { return Base; }\n    uint64_t getNextUnitOffset() const {\n      return Base + dwarf::getUnitLengthFieldByteSize(Hdr.Format) +\n             Hdr.UnitLength;\n    }\n    void dump(ScopedPrinter &W) const;\n\n    friend class DWARFDebugNames;\n  };\n\n  class ValueIterator : public std::iterator<std::input_iterator_tag, Entry> {\n\n    /// The Name Index we are currently iterating through. The implementation\n    /// relies on the fact that this can also be used as an iterator into the\n    /// \"NameIndices\" vector in the Accelerator section.\n    const NameIndex *CurrentIndex = nullptr;\n\n    /// Whether this is a local iterator (searches in CurrentIndex only) or not\n    /// (searches all name indices).\n    bool IsLocal;\n\n    Optional<Entry> CurrentEntry;\n    uint64_t DataOffset = 0; ///< Offset into the section.\n    std::string Key;         ///< The Key we are searching for.\n    Optional<uint32_t> Hash; ///< Hash of Key, if it has been computed.\n\n    bool getEntryAtCurrentOffset();\n    Optional<uint64_t> findEntryOffsetInCurrentIndex();\n    bool findInCurrentIndex();\n    void searchFromStartOfCurrentIndex();\n    void next();\n\n    /// Set the iterator to the \"end\" state.\n    void setEnd() { *this = ValueIterator(); }\n\n  public:\n    /// Create a \"begin\" iterator for looping over all entries in the\n    /// accelerator table matching Key. The iterator will run through all Name\n    /// Indexes in the section in sequence.\n    ValueIterator(const DWARFDebugNames &AccelTable, StringRef Key);\n\n    /// Create a \"begin\" iterator for looping over all entries in a specific\n    /// Name Index. Other indices in the section will not be visited.\n    ValueIterator(const NameIndex &NI, StringRef Key);\n\n    /// End marker.\n    ValueIterator() = default;\n\n    const Entry &operator*() const { return *CurrentEntry; }\n    ValueIterator &operator++() {\n      next();\n      return *this;\n    }\n    ValueIterator operator++(int) {\n      ValueIterator I = *this;\n      next();\n      return I;\n    }\n\n    friend bool operator==(const ValueIterator &A, const ValueIterator &B) {\n      return A.CurrentIndex == B.CurrentIndex && A.DataOffset == B.DataOffset;\n    }\n    friend bool operator!=(const ValueIterator &A, const ValueIterator &B) {\n      return !(A == B);\n    }\n  };\n\n  class NameIterator {\n\n    /// The Name Index we are iterating through.\n    const NameIndex *CurrentIndex;\n\n    /// The current name in the Name Index.\n    uint32_t CurrentName;\n\n    void next() {\n      assert(CurrentName <= CurrentIndex->getNameCount());\n      ++CurrentName;\n    }\n\n  public:\n    using iterator_category = std::input_iterator_tag;\n    using value_type = NameTableEntry;\n    using difference_type = uint32_t;\n    using pointer = NameTableEntry *;\n    using reference = NameTableEntry; // We return entries by value.\n\n    /// Creates an iterator whose initial position is name CurrentName in\n    /// CurrentIndex.\n    NameIterator(const NameIndex *CurrentIndex, uint32_t CurrentName)\n        : CurrentIndex(CurrentIndex), CurrentName(CurrentName) {}\n\n    NameTableEntry operator*() const {\n      return CurrentIndex->getNameTableEntry(CurrentName);\n    }\n    NameIterator &operator++() {\n      next();\n      return *this;\n    }\n    NameIterator operator++(int) {\n      NameIterator I = *this;\n      next();\n      return I;\n    }\n\n    friend bool operator==(const NameIterator &A, const NameIterator &B) {\n      return A.CurrentIndex == B.CurrentIndex && A.CurrentName == B.CurrentName;\n    }\n    friend bool operator!=(const NameIterator &A, const NameIterator &B) {\n      return !(A == B);\n    }\n  };\n\nprivate:\n  SmallVector<NameIndex, 0> NameIndices;\n  DenseMap<uint64_t, const NameIndex *> CUToNameIndex;\n\npublic:\n  DWARFDebugNames(const DWARFDataExtractor &AccelSection,\n                  DataExtractor StringSection)\n      : DWARFAcceleratorTable(AccelSection, StringSection) {}\n\n  Error extract() override;\n  void dump(raw_ostream &OS) const override;\n\n  /// Look up all entries in the accelerator table matching \\c Key.\n  iterator_range<ValueIterator> equal_range(StringRef Key) const;\n\n  using const_iterator = SmallVector<NameIndex, 0>::const_iterator;\n  const_iterator begin() const { return NameIndices.begin(); }\n  const_iterator end() const { return NameIndices.end(); }\n\n  /// Return the Name Index covering the compile unit at CUOffset, or nullptr if\n  /// there is no Name Index covering that unit.\n  const NameIndex *getCUNameIndex(uint64_t CUOffset);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFACCELERATORTABLE_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h", "content": "//===- DWARFContext.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===/\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFCONTEXT_H\n#define LLVM_DEBUGINFO_DWARF_DWARFCONTEXT_H\n\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFCompileUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugAranges.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugFrame.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLine.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugMacro.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDie.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFGdbIndex.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFObject.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFSection.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFTypeUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnitIndex.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Host.h\"\n#include <cstdint>\n#include <deque>\n#include <map>\n#include <memory>\n\nnamespace llvm {\n\nclass MCRegisterInfo;\nclass MemoryBuffer;\nclass raw_ostream;\n\n/// DWARFContext\n/// This data structure is the top level entity that deals with dwarf debug\n/// information parsing. The actual data is supplied through DWARFObj.\nclass DWARFContext : public DIContext {\n  DWARFUnitVector NormalUnits;\n  std::unique_ptr<DWARFUnitIndex> CUIndex;\n  std::unique_ptr<DWARFGdbIndex> GdbIndex;\n  std::unique_ptr<DWARFUnitIndex> TUIndex;\n  std::unique_ptr<DWARFDebugAbbrev> Abbrev;\n  std::unique_ptr<DWARFDebugLoc> Loc;\n  std::unique_ptr<DWARFDebugAranges> Aranges;\n  std::unique_ptr<DWARFDebugLine> Line;\n  std::unique_ptr<DWARFDebugFrame> DebugFrame;\n  std::unique_ptr<DWARFDebugFrame> EHFrame;\n  std::unique_ptr<DWARFDebugMacro> Macro;\n  std::unique_ptr<DWARFDebugMacro> Macinfo;\n  std::unique_ptr<DWARFDebugNames> Names;\n  std::unique_ptr<AppleAcceleratorTable> AppleNames;\n  std::unique_ptr<AppleAcceleratorTable> AppleTypes;\n  std::unique_ptr<AppleAcceleratorTable> AppleNamespaces;\n  std::unique_ptr<AppleAcceleratorTable> AppleObjC;\n\n  DWARFUnitVector DWOUnits;\n  std::unique_ptr<DWARFDebugAbbrev> AbbrevDWO;\n  std::unique_ptr<DWARFDebugMacro> MacinfoDWO;\n  std::unique_ptr<DWARFDebugMacro> MacroDWO;\n\n  /// The maximum DWARF version of all units.\n  unsigned MaxVersion = 0;\n\n  struct DWOFile {\n    object::OwningBinary<object::ObjectFile> File;\n    std::unique_ptr<DWARFContext> Context;\n  };\n  StringMap<std::weak_ptr<DWOFile>> DWOFiles;\n  std::weak_ptr<DWOFile> DWP;\n  bool CheckedForDWP = false;\n  std::string DWPName;\n\n  std::unique_ptr<MCRegisterInfo> RegInfo;\n\n  std::function<void(Error)> RecoverableErrorHandler =\n      WithColor::defaultErrorHandler;\n  std::function<void(Error)> WarningHandler = WithColor::defaultWarningHandler;\n\n  /// Read compile units from the debug_info section (if necessary)\n  /// and type units from the debug_types sections (if necessary)\n  /// and store them in NormalUnits.\n  void parseNormalUnits();\n\n  /// Read compile units from the debug_info.dwo section (if necessary)\n  /// and type units from the debug_types.dwo section (if necessary)\n  /// and store them in DWOUnits.\n  /// If \\p Lazy is true, set up to parse but don't actually parse them.\n  enum { EagerParse = false, LazyParse = true };\n  void parseDWOUnits(bool Lazy = false);\n\n  std::unique_ptr<const DWARFObject> DObj;\n\n  /// Helper enum to distinguish between macro[.dwo] and macinfo[.dwo]\n  /// section.\n  enum MacroSecType {\n    MacinfoSection,\n    MacinfoDwoSection,\n    MacroSection,\n    MacroDwoSection\n  };\n\npublic:\n  DWARFContext(std::unique_ptr<const DWARFObject> DObj,\n               std::string DWPName = \"\",\n               std::function<void(Error)> RecoverableErrorHandler =\n                   WithColor::defaultErrorHandler,\n               std::function<void(Error)> WarningHandler =\n                   WithColor::defaultWarningHandler);\n  ~DWARFContext();\n\n  DWARFContext(DWARFContext &) = delete;\n  DWARFContext &operator=(DWARFContext &) = delete;\n\n  const DWARFObject &getDWARFObj() const { return *DObj; }\n\n  static bool classof(const DIContext *DICtx) {\n    return DICtx->getKind() == CK_DWARF;\n  }\n\n  /// Dump a textual representation to \\p OS. If any \\p DumpOffsets are present,\n  /// dump only the record at the specified offset.\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts,\n            std::array<Optional<uint64_t>, DIDT_ID_Count> DumpOffsets);\n\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts) override {\n    std::array<Optional<uint64_t>, DIDT_ID_Count> DumpOffsets;\n    dump(OS, DumpOpts, DumpOffsets);\n  }\n\n  bool verify(raw_ostream &OS, DIDumpOptions DumpOpts = {}) override;\n\n  using unit_iterator_range = DWARFUnitVector::iterator_range;\n  using compile_unit_range = DWARFUnitVector::compile_unit_range;\n\n  /// Get units from .debug_info in this context.\n  unit_iterator_range info_section_units() {\n    parseNormalUnits();\n    return unit_iterator_range(NormalUnits.begin(),\n                               NormalUnits.begin() +\n                                   NormalUnits.getNumInfoUnits());\n  }\n\n  /// Get units from .debug_types in this context.\n  unit_iterator_range types_section_units() {\n    parseNormalUnits();\n    return unit_iterator_range(\n        NormalUnits.begin() + NormalUnits.getNumInfoUnits(), NormalUnits.end());\n  }\n\n  /// Get compile units in this context.\n  compile_unit_range compile_units() {\n    return make_filter_range(info_section_units(), isCompileUnit);\n  }\n\n  // If you want type_units(), it'll need to be a concat iterator of a filter of\n  // TUs in info_section + all the (all type) units in types_section\n\n  /// Get all normal compile/type units in this context.\n  unit_iterator_range normal_units() {\n    parseNormalUnits();\n    return unit_iterator_range(NormalUnits.begin(), NormalUnits.end());\n  }\n\n  /// Get units from .debug_info..dwo in the DWO context.\n  unit_iterator_range dwo_info_section_units() {\n    parseDWOUnits();\n    return unit_iterator_range(DWOUnits.begin(),\n                               DWOUnits.begin() + DWOUnits.getNumInfoUnits());\n  }\n\n  /// Get units from .debug_types.dwo in the DWO context.\n  unit_iterator_range dwo_types_section_units() {\n    parseDWOUnits();\n    return unit_iterator_range(DWOUnits.begin() + DWOUnits.getNumInfoUnits(),\n                               DWOUnits.end());\n  }\n\n  /// Get compile units in the DWO context.\n  compile_unit_range dwo_compile_units() {\n    return make_filter_range(dwo_info_section_units(), isCompileUnit);\n  }\n\n  // If you want dwo_type_units(), it'll need to be a concat iterator of a\n  // filter of TUs in dwo_info_section + all the (all type) units in\n  // dwo_types_section.\n\n  /// Get all units in the DWO context.\n  unit_iterator_range dwo_units() {\n    parseDWOUnits();\n    return unit_iterator_range(DWOUnits.begin(), DWOUnits.end());\n  }\n\n  /// Get the number of compile units in this context.\n  unsigned getNumCompileUnits() {\n    parseNormalUnits();\n    return NormalUnits.getNumInfoUnits();\n  }\n\n  /// Get the number of type units in this context.\n  unsigned getNumTypeUnits() {\n    parseNormalUnits();\n    return NormalUnits.getNumTypesUnits();\n  }\n\n  /// Get the number of compile units in the DWO context.\n  unsigned getNumDWOCompileUnits() {\n    parseDWOUnits();\n    return DWOUnits.getNumInfoUnits();\n  }\n\n  /// Get the number of type units in the DWO context.\n  unsigned getNumDWOTypeUnits() {\n    parseDWOUnits();\n    return DWOUnits.getNumTypesUnits();\n  }\n\n  /// Get the unit at the specified index.\n  DWARFUnit *getUnitAtIndex(unsigned index) {\n    parseNormalUnits();\n    return NormalUnits[index].get();\n  }\n\n  /// Get the unit at the specified index for the DWO units.\n  DWARFUnit *getDWOUnitAtIndex(unsigned index) {\n    parseDWOUnits();\n    return DWOUnits[index].get();\n  }\n\n  DWARFCompileUnit *getDWOCompileUnitForHash(uint64_t Hash);\n\n  /// Return the compile unit that includes an offset (relative to .debug_info).\n  DWARFCompileUnit *getCompileUnitForOffset(uint64_t Offset);\n\n  /// Get a DIE given an exact offset.\n  DWARFDie getDIEForOffset(uint64_t Offset);\n\n  unsigned getMaxVersion() {\n    // Ensure info units have been parsed to discover MaxVersion\n    info_section_units();\n    return MaxVersion;\n  }\n\n  unsigned getMaxDWOVersion() {\n    // Ensure DWO info units have been parsed to discover MaxVersion\n    dwo_info_section_units();\n    return MaxVersion;\n  }\n\n  void setMaxVersionIfGreater(unsigned Version) {\n    if (Version > MaxVersion)\n      MaxVersion = Version;\n  }\n\n  const DWARFUnitIndex &getCUIndex();\n  DWARFGdbIndex &getGdbIndex();\n  const DWARFUnitIndex &getTUIndex();\n\n  /// Get a pointer to the parsed DebugAbbrev object.\n  const DWARFDebugAbbrev *getDebugAbbrev();\n\n  /// Get a pointer to the parsed DebugLoc object.\n  const DWARFDebugLoc *getDebugLoc();\n\n  /// Get a pointer to the parsed dwo abbreviations object.\n  const DWARFDebugAbbrev *getDebugAbbrevDWO();\n\n  /// Get a pointer to the parsed DebugAranges object.\n  const DWARFDebugAranges *getDebugAranges();\n\n  /// Get a pointer to the parsed frame information object.\n  Expected<const DWARFDebugFrame *> getDebugFrame();\n\n  /// Get a pointer to the parsed eh frame information object.\n  Expected<const DWARFDebugFrame *> getEHFrame();\n\n  /// Get a pointer to the parsed DebugMacinfo information object.\n  const DWARFDebugMacro *getDebugMacinfo();\n\n  /// Get a pointer to the parsed DebugMacinfoDWO information object.\n  const DWARFDebugMacro *getDebugMacinfoDWO();\n\n  /// Get a pointer to the parsed DebugMacro information object.\n  const DWARFDebugMacro *getDebugMacro();\n\n  /// Get a pointer to the parsed DebugMacroDWO information object.\n  const DWARFDebugMacro *getDebugMacroDWO();\n\n  /// Get a reference to the parsed accelerator table object.\n  const DWARFDebugNames &getDebugNames();\n\n  /// Get a reference to the parsed accelerator table object.\n  const AppleAcceleratorTable &getAppleNames();\n\n  /// Get a reference to the parsed accelerator table object.\n  const AppleAcceleratorTable &getAppleTypes();\n\n  /// Get a reference to the parsed accelerator table object.\n  const AppleAcceleratorTable &getAppleNamespaces();\n\n  /// Get a reference to the parsed accelerator table object.\n  const AppleAcceleratorTable &getAppleObjC();\n\n  /// Get a pointer to a parsed line table corresponding to a compile unit.\n  /// Report any parsing issues as warnings on stderr.\n  const DWARFDebugLine::LineTable *getLineTableForUnit(DWARFUnit *U);\n\n  /// Get a pointer to a parsed line table corresponding to a compile unit.\n  /// Report any recoverable parsing problems using the handler.\n  Expected<const DWARFDebugLine::LineTable *>\n  getLineTableForUnit(DWARFUnit *U,\n                      function_ref<void(Error)> RecoverableErrorHandler);\n\n  DataExtractor getStringExtractor() const {\n    return DataExtractor(DObj->getStrSection(), false, 0);\n  }\n  DataExtractor getStringDWOExtractor() const {\n    return DataExtractor(DObj->getStrDWOSection(), false, 0);\n  }\n  DataExtractor getLineStringExtractor() const {\n    return DataExtractor(DObj->getLineStrSection(), false, 0);\n  }\n\n  /// Wraps the returned DIEs for a given address.\n  struct DIEsForAddress {\n    DWARFCompileUnit *CompileUnit = nullptr;\n    DWARFDie FunctionDIE;\n    DWARFDie BlockDIE;\n    explicit operator bool() const { return CompileUnit != nullptr; }\n  };\n\n  /// Get the compilation unit, the function DIE and lexical block DIE for the\n  /// given address where applicable.\n  /// TODO: change input parameter from \"uint64_t Address\"\n  ///       into \"SectionedAddress Address\"\n  DIEsForAddress getDIEsForAddress(uint64_t Address);\n\n  DILineInfo getLineInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) override;\n  DILineInfoTable getLineInfoForAddressRange(\n      object::SectionedAddress Address, uint64_t Size,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) override;\n  DIInliningInfo getInliningInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) override;\n\n  std::vector<DILocal>\n  getLocalsForAddress(object::SectionedAddress Address) override;\n\n  bool isLittleEndian() const { return DObj->isLittleEndian(); }\n  static bool isSupportedVersion(unsigned version) {\n    return version == 2 || version == 3 || version == 4 || version == 5;\n  }\n\n  static bool isAddressSizeSupported(unsigned AddressSize) {\n    return AddressSize == 2 || AddressSize == 4 || AddressSize == 8;\n  }\n\n  std::shared_ptr<DWARFContext> getDWOContext(StringRef AbsolutePath);\n\n  const MCRegisterInfo *getRegisterInfo() const { return RegInfo.get(); }\n\n  function_ref<void(Error)> getRecoverableErrorHandler() {\n    return RecoverableErrorHandler;\n  }\n\n  function_ref<void(Error)> getWarningHandler() { return WarningHandler; }\n\n  static std::unique_ptr<DWARFContext>\n  create(const object::ObjectFile &Obj, const LoadedObjectInfo *L = nullptr,\n         std::string DWPName = \"\",\n         std::function<void(Error)> RecoverableErrorHandler =\n             WithColor::defaultErrorHandler,\n         std::function<void(Error)> WarningHandler =\n             WithColor::defaultWarningHandler);\n\n  static std::unique_ptr<DWARFContext>\n  create(const StringMap<std::unique_ptr<MemoryBuffer>> &Sections,\n         uint8_t AddrSize, bool isLittleEndian = sys::IsLittleEndianHost,\n         std::function<void(Error)> RecoverableErrorHandler =\n             WithColor::defaultErrorHandler,\n         std::function<void(Error)> WarningHandler =\n             WithColor::defaultWarningHandler);\n\n  /// Loads register info for the architecture of the provided object file.\n  /// Improves readability of dumped DWARF expressions. Requires the caller to\n  /// have initialized the relevant target descriptions.\n  Error loadRegisterInfo(const object::ObjectFile &Obj);\n\n  /// Get address size from CUs.\n  /// TODO: refactor compile_units() to make this const.\n  uint8_t getCUAddrSize();\n\n  Triple::ArchType getArch() const {\n    return getDWARFObj().getFile()->getArch();\n  }\n\n  /// Return the compile unit which contains instruction with provided\n  /// address.\n  /// TODO: change input parameter from \"uint64_t Address\"\n  ///       into \"SectionedAddress Address\"\n  DWARFCompileUnit *getCompileUnitForAddress(uint64_t Address);\n\nprivate:\n  /// Parse a macro[.dwo] or macinfo[.dwo] section.\n  std::unique_ptr<DWARFDebugMacro>\n  parseMacroOrMacinfo(MacroSecType SectionType);\n\n  void addLocalsForDie(DWARFCompileUnit *CU, DWARFDie Subprogram, DWARFDie Die,\n                       std::vector<DILocal> &Result);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFCONTEXT_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "content": "//===- DWARFDebugFrame.h - Parsing of .debug_frame --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGFRAME_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGFRAME_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFExpression.h\"\n#include \"llvm/Support/Error.h\"\n#include <map>\n#include <memory>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nnamespace dwarf {\n\nconstexpr uint32_t InvalidRegisterNumber = UINT32_MAX;\n\n/// A class that represents a location for the Call Frame Address (CFA) or a\n/// register. This is decoded from the DWARF Call Frame Information\n/// instructions and put into an UnwindRow.\nclass UnwindLocation {\npublic:\n  enum Location {\n    /// Not specified.\n    Unspecified,\n    /// Register is not available and can't be recovered.\n    Undefined,\n    /// Register value is in the register, nothing needs to be done to unwind\n    /// it:\n    ///   reg = reg\n    Same,\n    /// Register is in or at the CFA plus an offset:\n    ///   reg = CFA + offset\n    ///   reg = defef(CFA + offset)\n    CFAPlusOffset,\n    /// Register it in or at a register plus offset:\n    ///   reg = reg + offset\n    ///   reg = deref(reg + offset)\n    RegPlusOffset,\n    /// Register value is in or at a value found by evaluating a DWARF\n    /// expression:\n    ///   reg = eval(dwarf_expr)\n    ///   reg = deref(eval(dwarf_expr))\n    DWARFExpr,\n    /// Value is a constant value contained in \"Offset\":\n    ///   reg = Offset\n    Constant,\n  };\n\nprivate:\n  Location Kind;   /// The type of the location that describes how to unwind it.\n  uint32_t RegNum; /// The register number for Kind == RegPlusOffset.\n  int32_t Offset;  /// The offset for Kind == CFAPlusOffset or RegPlusOffset.\n  Optional<DWARFExpression> Expr; /// The DWARF expression for Kind ==\n                                  /// DWARFExpression.\n  bool Dereference; /// If true, the resulting location must be dereferenced\n                    /// after the location value is computed.\n\n  // Constructors are private to force people to use the create static\n  // functions.\n  UnwindLocation(Location K)\n      : Kind(K), RegNum(InvalidRegisterNumber), Offset(0), Dereference(false) {}\n\n  UnwindLocation(Location K, uint32_t Reg, int32_t Off, bool Deref)\n      : Kind(K), RegNum(Reg), Offset(Off), Dereference(Deref) {}\n\n  UnwindLocation(DWARFExpression E, bool Deref)\n      : Kind(DWARFExpr), RegNum(InvalidRegisterNumber), Offset(0), Expr(E),\n        Dereference(Deref) {}\n\npublic:\n  /// Create a location whose rule is set to Unspecified. This means the\n  /// register value might be in the same register but it wasn't specified in\n  /// the unwind opcodes.\n  static UnwindLocation createUnspecified();\n  /// Create a location where the value is undefined and not available. This can\n  /// happen when a register is volatile and can't be recovered.\n  static UnwindLocation createUndefined();\n  /// Create a location where the value is known to be in the register itself.\n  static UnwindLocation createSame();\n  /// Create a location that is in (Deref == false) or at (Deref == true) the\n  /// CFA plus an offset. Most registers that are spilled onto the stack use\n  /// this rule. The rule for the register will use this rule and specify a\n  /// unique offset from the CFA with \\a Deref set to true. This value will be\n  /// relative to a CFA value which is typically defined using the register\n  /// plus offset location. \\see createRegisterPlusOffset(...) for more\n  /// information.\n  static UnwindLocation createIsCFAPlusOffset(int32_t Off);\n  static UnwindLocation createAtCFAPlusOffset(int32_t Off);\n  /// Create a location where the saved value is in (Deref == false) or at\n  /// (Deref == true) a regiser plus an offset.\n  ///\n  /// The CFA is usually defined using this rule by using the stack pointer or\n  /// frame pointer as the register, with an offset that accounts for all\n  /// spilled registers and all local variables in a function, and Deref ==\n  /// false.\n  static UnwindLocation createIsRegisterPlusOffset(uint32_t Reg, int32_t Off);\n  static UnwindLocation createAtRegisterPlusOffset(uint32_t Reg, int32_t Off);\n  /// Create a location whose value is the result of evaluating a DWARF\n  /// expression. This allows complex expressions to be evaluated in order to\n  /// unwind a register or CFA value.\n  static UnwindLocation createIsDWARFExpression(DWARFExpression Expr);\n  static UnwindLocation createAtDWARFExpression(DWARFExpression Expr);\n  static UnwindLocation createIsConstant(int32_t Value);\n\n  Location getLocation() const { return Kind; }\n  uint32_t getRegister() const { return RegNum; }\n  int32_t getOffset() const { return Offset; }\n  int32_t getConstant() const { return Offset; }\n  /// Some opcodes will modify the CFA location's register only, so we need\n  /// to be able to modify the CFA register when evaluating DWARF Call Frame\n  /// Information opcodes.\n  void setRegister(uint32_t NewRegNum) { RegNum = NewRegNum; }\n  /// Some opcodes will modify the CFA location's offset only, so we need\n  /// to be able to modify the CFA register when evaluating DWARF Call Frame\n  /// Information opcodes.\n  void setOffset(int32_t NewOffset) { Offset = NewOffset; }\n  /// Some opcodes modify a constant value and we need to be able to update\n  /// the constant value (DW_CFA_GNU_window_save which is also known as\n  // DW_CFA_AARCH64_negate_ra_state).\n  void setConstant(int32_t Value) { Offset = Value; }\n\n  Optional<DWARFExpression> getDWARFExpressionBytes() const { return Expr; }\n  /// Dump a location expression as text and use the register information if\n  /// some is provided.\n  ///\n  /// \\param OS the stream to use for output.\n  ///\n  /// \\param MRI register information that helps emit register names insteead\n  /// of raw register numbers.\n  ///\n  /// \\param IsEH true if the DWARF Call Frame Information is from .eh_frame\n  /// instead of from .debug_frame. This is needed for register number\n  /// conversion because some register numbers differ between the two sections\n  /// for certain architectures like x86.\n  void dump(raw_ostream &OS, const MCRegisterInfo *MRI, bool IsEH) const;\n\n  bool operator==(const UnwindLocation &RHS) const;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const UnwindLocation &R);\n\n/// A class that can track all registers with locations in a UnwindRow object.\n///\n/// Register locations use a map where the key is the register number and the\n/// the value is a UnwindLocation.\n///\n/// The register maps are put into a class so that all register locations can\n/// be copied when parsing the unwind opcodes DW_CFA_remember_state and\n/// DW_CFA_restore_state.\nclass RegisterLocations {\n  std::map<uint32_t, UnwindLocation> Locations;\n\npublic:\n  /// Return the location for the register in \\a RegNum if there is a location.\n  ///\n  /// \\param RegNum the register number to find a location for.\n  ///\n  /// \\returns A location if one is available for \\a RegNum, or llvm::None\n  /// otherwise.\n  Optional<UnwindLocation> getRegisterLocation(uint32_t RegNum) const {\n    auto Pos = Locations.find(RegNum);\n    if (Pos == Locations.end())\n      return llvm::None;\n    return Pos->second;\n  }\n\n  /// Set the location for the register in \\a RegNum to \\a Location.\n  ///\n  /// \\param RegNum the register number to set the location for.\n  ///\n  /// \\param Location the UnwindLocation that describes how to unwind the value.\n  void setRegisterLocation(uint32_t RegNum, const UnwindLocation &Location) {\n    Locations.erase(RegNum);\n    Locations.insert(std::make_pair(RegNum, Location));\n  }\n\n  /// Removes any rule for the register in \\a RegNum.\n  ///\n  /// \\param RegNum the register number to remove the location for.\n  void removeRegisterLocation(uint32_t RegNum) { Locations.erase(RegNum); }\n\n  /// Dump all registers + locations that are currently defined in this object.\n  ///\n  /// \\param OS the stream to use for output.\n  ///\n  /// \\param MRI register information that helps emit register names insteead\n  /// of raw register numbers.\n  ///\n  /// \\param IsEH true if the DWARF Call Frame Information is from .eh_frame\n  /// instead of from .debug_frame. This is needed for register number\n  /// conversion because some register numbers differ between the two sections\n  /// for certain architectures like x86.\n  void dump(raw_ostream &OS, const MCRegisterInfo *MRI, bool IsEH) const;\n\n  /// Returns true if we have any register locations in this object.\n  bool hasLocations() const { return !Locations.empty(); }\n\n  size_t size() const { return Locations.size(); }\n\n  bool operator==(const RegisterLocations &RHS) const {\n    return Locations == RHS.Locations;\n  }\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const RegisterLocations &RL);\n\n/// A class that represents a single row in the unwind table that is decoded by\n/// parsing the DWARF Call Frame Information opcodes.\n///\n/// The row consists of an optional address, the rule to unwind the CFA and all\n/// rules to unwind any registers. If the address doesn't have a value, this\n/// row represents the initial instructions for a CIE. If the address has a\n/// value the UnwindRow represents a row in the UnwindTable for a FDE. The\n/// address is the first address for which the CFA location and register rules\n/// are valid within a function.\n///\n/// UnwindRow objects are created by parsing opcodes in the DWARF Call Frame\n/// Information and UnwindRow objects are lazily populated and pushed onto a\n/// stack in the UnwindTable when evaluating this state machine. Accessors are\n/// needed for the address, CFA value, and register locations as the opcodes\n/// encode a state machine that produces a sorted array of UnwindRow objects\n/// \\see UnwindTable.\nclass UnwindRow {\n  /// The address will be valid when parsing the instructions in a FDE. If\n  /// invalid, this object represents the initial instructions of a CIE.\n  Optional<uint64_t> Address; ///< Address for row in FDE, invalid for CIE.\n  UnwindLocation CFAValue;    ///< How to unwind the Call Frame Address (CFA).\n  RegisterLocations RegLocs;  ///< How to unwind all registers in this list.\n\npublic:\n  UnwindRow() : CFAValue(UnwindLocation::createUnspecified()) {}\n\n  /// Returns true if the address is valid in this object.\n  bool hasAddress() const { return Address.hasValue(); }\n\n  /// Get the address for this row.\n  ///\n  /// Clients should only call this function after verifying it has a valid\n  /// address with a call to \\see hasAddress().\n  uint64_t getAddress() const { return *Address; }\n\n  /// Set the address for this UnwindRow.\n  ///\n  /// The address represents the first address for which the CFAValue and\n  /// RegLocs are valid within a function.\n  void setAddress(uint64_t Addr) { Address = Addr; }\n\n  /// Offset the address for this UnwindRow.\n  ///\n  /// The address represents the first address for which the CFAValue and\n  /// RegLocs are valid within a function. Clients must ensure that this object\n  /// already has an address (\\see hasAddress()) prior to calling this\n  /// function.\n  void slideAddress(uint64_t Offset) { *Address += Offset; }\n  UnwindLocation &getCFAValue() { return CFAValue; }\n  const UnwindLocation &getCFAValue() const { return CFAValue; }\n  RegisterLocations &getRegisterLocations() { return RegLocs; }\n  const RegisterLocations &getRegisterLocations() const { return RegLocs; }\n\n  /// Dump the UnwindRow to the stream.\n  ///\n  /// \\param OS the stream to use for output.\n  ///\n  /// \\param MRI register information that helps emit register names insteead\n  /// of raw register numbers.\n  ///\n  /// \\param IsEH true if the DWARF Call Frame Information is from .eh_frame\n  /// instead of from .debug_frame. This is needed for register number\n  /// conversion because some register numbers differ between the two sections\n  /// for certain architectures like x86.\n  ///\n  /// \\param IndentLevel specify the indent level as an integer. The UnwindRow\n  /// will be output to the stream preceded by 2 * IndentLevel number of spaces.\n  void dump(raw_ostream &OS, const MCRegisterInfo *MRI, bool IsEH,\n            unsigned IndentLevel = 0) const;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const UnwindRow &Row);\n\nclass CFIProgram;\nclass CIE;\nclass FDE;\n\n/// A class that contains all UnwindRow objects for an FDE or a single unwind\n/// row for a CIE. To unwind an address the rows, which are sorted by start\n/// address, can be searched to find the UnwindRow with the lowest starting\n/// address that is greater than or equal to the address that is being looked\n/// up.\nclass UnwindTable {\npublic:\n  using RowContainer = std::vector<UnwindRow>;\n  using iterator = RowContainer::iterator;\n  using const_iterator = RowContainer::const_iterator;\n\n  size_t size() const { return Rows.size(); }\n  iterator begin() { return Rows.begin(); }\n  const_iterator begin() const { return Rows.begin(); }\n  iterator end() { return Rows.end(); }\n  const_iterator end() const { return Rows.end(); }\n  const UnwindRow &operator[](size_t Index) const {\n    assert(Index < size());\n    return Rows[Index];\n  }\n\n  /// Dump the UnwindTable to the stream.\n  ///\n  /// \\param OS the stream to use for output.\n  ///\n  /// \\param MRI register information that helps emit register names insteead\n  /// of raw register numbers.\n  ///\n  /// \\param IsEH true if the DWARF Call Frame Information is from .eh_frame\n  /// instead of from .debug_frame. This is needed for register number\n  /// conversion because some register numbers differ between the two sections\n  /// for certain architectures like x86.\n  ///\n  /// \\param IndentLevel specify the indent level as an integer. The UnwindRow\n  /// will be output to the stream preceded by 2 * IndentLevel number of spaces.\n  void dump(raw_ostream &OS, const MCRegisterInfo *MRI, bool IsEH,\n            unsigned IndentLevel = 0) const;\n\n  /// Create an UnwindTable from a Common Information Entry (CIE).\n  ///\n  /// \\param Cie The Common Information Entry to extract the table from. The\n  /// CFIProgram is retrieved from the \\a Cie object and used to create the\n  /// UnwindTable.\n  ///\n  /// \\returns An error if the DWARF Call Frame Information opcodes have state\n  /// machine errors, or a valid UnwindTable otherwise.\n  static Expected<UnwindTable> create(const CIE *Cie);\n\n  /// Create an UnwindTable from a Frame Descriptor Entry (FDE).\n  ///\n  /// \\param Fde The Frame Descriptor Entry to extract the table from. The\n  /// CFIProgram is retrieved from the \\a Fde object and used to create the\n  /// UnwindTable.\n  ///\n  /// \\returns An error if the DWARF Call Frame Information opcodes have state\n  /// machine errors, or a valid UnwindTable otherwise.\n  static Expected<UnwindTable> create(const FDE *Fde);\n\nprivate:\n  RowContainer Rows;\n  /// The end address when data is extracted from a FDE. This value will be\n  /// invalid when a UnwindTable is extracted from a CIE.\n  Optional<uint64_t> EndAddress;\n\n  /// Parse the information in the CFIProgram and update the CurrRow object\n  /// that the state machine describes.\n  ///\n  /// This is an internal implementation that emulates the state machine\n  /// described in the DWARF Call Frame Information opcodes and will push\n  /// CurrRow onto the Rows container when needed.\n  ///\n  /// \\param CFIP the CFI program that contains the opcodes from a CIE or FDE.\n  ///\n  /// \\param CurrRow the current row to modify while parsing the state machine.\n  ///\n  /// \\param InitialLocs If non-NULL, we are parsing a FDE and this contains\n  /// the initial register locations from the CIE. If NULL, then a CIE's\n  /// opcodes are being parsed and this is not needed. This is used for the\n  /// DW_CFA_restore and DW_CFA_restore_extended opcodes.\n  Error parseRows(const CFIProgram &CFIP, UnwindRow &CurrRow,\n                  const RegisterLocations *InitialLocs);\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const UnwindTable &Rows);\n\n/// Represent a sequence of Call Frame Information instructions that, when read\n/// in order, construct a table mapping PC to frame state. This can also be\n/// referred to as \"CFI rules\" in DWARF literature to avoid confusion with\n/// computer programs in the broader sense, and in this context each instruction\n/// would be a rule to establish the mapping. Refer to pg. 172 in the DWARF5\n/// manual, \"6.4.1 Structure of Call Frame Information\".\nclass CFIProgram {\npublic:\n  typedef SmallVector<uint64_t, 2> Operands;\n\n  /// An instruction consists of a DWARF CFI opcode and an optional sequence of\n  /// operands. If it refers to an expression, then this expression has its own\n  /// sequence of operations and operands handled separately by DWARFExpression.\n  struct Instruction {\n    Instruction(uint8_t Opcode) : Opcode(Opcode) {}\n\n    uint8_t Opcode;\n    Operands Ops;\n    // Associated DWARF expression in case this instruction refers to one\n    Optional<DWARFExpression> Expression;\n\n    Expected<uint64_t> getOperandAsUnsigned(const CFIProgram &CFIP,\n                                            uint32_t OperandIdx) const;\n\n    Expected<int64_t> getOperandAsSigned(const CFIProgram &CFIP,\n                                         uint32_t OperandIdx) const;\n  };\n\n  using InstrList = std::vector<Instruction>;\n  using iterator = InstrList::iterator;\n  using const_iterator = InstrList::const_iterator;\n\n  iterator begin() { return Instructions.begin(); }\n  const_iterator begin() const { return Instructions.begin(); }\n  iterator end() { return Instructions.end(); }\n  const_iterator end() const { return Instructions.end(); }\n\n  unsigned size() const { return (unsigned)Instructions.size(); }\n  bool empty() const { return Instructions.empty(); }\n  uint64_t codeAlign() const { return CodeAlignmentFactor; }\n  int64_t dataAlign() const { return DataAlignmentFactor; }\n  Triple::ArchType triple() const { return Arch; }\n\n  CFIProgram(uint64_t CodeAlignmentFactor, int64_t DataAlignmentFactor,\n             Triple::ArchType Arch)\n      : CodeAlignmentFactor(CodeAlignmentFactor),\n        DataAlignmentFactor(DataAlignmentFactor),\n        Arch(Arch) {}\n\n  /// Parse and store a sequence of CFI instructions from Data,\n  /// starting at *Offset and ending at EndOffset. *Offset is updated\n  /// to EndOffset upon successful parsing, or indicates the offset\n  /// where a problem occurred in case an error is returned.\n  Error parse(DWARFDataExtractor Data, uint64_t *Offset, uint64_t EndOffset);\n\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts, const MCRegisterInfo *MRI,\n            bool IsEH, unsigned IndentLevel = 1) const;\n\n  void addInstruction(const Instruction &I) { Instructions.push_back(I); }\n\n  /// Get a DWARF CFI call frame string for the given DW_CFA opcode.\n  StringRef callFrameString(unsigned Opcode) const;\n\nprivate:\n  std::vector<Instruction> Instructions;\n  const uint64_t CodeAlignmentFactor;\n  const int64_t DataAlignmentFactor;\n  Triple::ArchType Arch;\n\n  /// Convenience method to add a new instruction with the given opcode.\n  void addInstruction(uint8_t Opcode) {\n    Instructions.push_back(Instruction(Opcode));\n  }\n\n  /// Add a new single-operand instruction.\n  void addInstruction(uint8_t Opcode, uint64_t Operand1) {\n    Instructions.push_back(Instruction(Opcode));\n    Instructions.back().Ops.push_back(Operand1);\n  }\n\n  /// Add a new instruction that has two operands.\n  void addInstruction(uint8_t Opcode, uint64_t Operand1, uint64_t Operand2) {\n    Instructions.push_back(Instruction(Opcode));\n    Instructions.back().Ops.push_back(Operand1);\n    Instructions.back().Ops.push_back(Operand2);\n  }\n\n  /// Types of operands to CFI instructions\n  /// In DWARF, this type is implicitly tied to a CFI instruction opcode and\n  /// thus this type doesn't need to be explictly written to the file (this is\n  /// not a DWARF encoding). The relationship of instrs to operand types can\n  /// be obtained from getOperandTypes() and is only used to simplify\n  /// instruction printing.\n  enum OperandType {\n    OT_Unset,\n    OT_None,\n    OT_Address,\n    OT_Offset,\n    OT_FactoredCodeOffset,\n    OT_SignedFactDataOffset,\n    OT_UnsignedFactDataOffset,\n    OT_Register,\n    OT_Expression\n  };\n\n  /// Get the OperandType as a \"const char *\".\n  static const char *operandTypeString(OperandType OT);\n\n  /// Retrieve the array describing the types of operands according to the enum\n  /// above. This is indexed by opcode.\n  static ArrayRef<OperandType[2]> getOperandTypes();\n\n  /// Print \\p Opcode's operand number \\p OperandIdx which has value \\p Operand.\n  void printOperand(raw_ostream &OS, DIDumpOptions DumpOpts,\n                    const MCRegisterInfo *MRI, bool IsEH,\n                    const Instruction &Instr, unsigned OperandIdx,\n                    uint64_t Operand) const;\n};\n\n/// An entry in either debug_frame or eh_frame. This entry can be a CIE or an\n/// FDE.\nclass FrameEntry {\npublic:\n  enum FrameKind { FK_CIE, FK_FDE };\n\n  FrameEntry(FrameKind K, bool IsDWARF64, uint64_t Offset, uint64_t Length,\n             uint64_t CodeAlign, int64_t DataAlign, Triple::ArchType Arch)\n      : Kind(K), IsDWARF64(IsDWARF64), Offset(Offset), Length(Length),\n        CFIs(CodeAlign, DataAlign, Arch) {}\n\n  virtual ~FrameEntry() {}\n\n  FrameKind getKind() const { return Kind; }\n  uint64_t getOffset() const { return Offset; }\n  uint64_t getLength() const { return Length; }\n  const CFIProgram &cfis() const { return CFIs; }\n  CFIProgram &cfis() { return CFIs; }\n\n  /// Dump the instructions in this CFI fragment\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts,\n                    const MCRegisterInfo *MRI, bool IsEH) const = 0;\n\nprotected:\n  const FrameKind Kind;\n\n  const bool IsDWARF64;\n\n  /// Offset of this entry in the section.\n  const uint64_t Offset;\n\n  /// Entry length as specified in DWARF.\n  const uint64_t Length;\n\n  CFIProgram CFIs;\n};\n\n/// DWARF Common Information Entry (CIE)\nclass CIE : public FrameEntry {\npublic:\n  // CIEs (and FDEs) are simply container classes, so the only sensible way to\n  // create them is by providing the full parsed contents in the constructor.\n  CIE(bool IsDWARF64, uint64_t Offset, uint64_t Length, uint8_t Version,\n      SmallString<8> Augmentation, uint8_t AddressSize,\n      uint8_t SegmentDescriptorSize, uint64_t CodeAlignmentFactor,\n      int64_t DataAlignmentFactor, uint64_t ReturnAddressRegister,\n      SmallString<8> AugmentationData, uint32_t FDEPointerEncoding,\n      uint32_t LSDAPointerEncoding, Optional<uint64_t> Personality,\n      Optional<uint32_t> PersonalityEnc, Triple::ArchType Arch)\n      : FrameEntry(FK_CIE, IsDWARF64, Offset, Length, CodeAlignmentFactor,\n                   DataAlignmentFactor, Arch),\n        Version(Version), Augmentation(std::move(Augmentation)),\n        AddressSize(AddressSize), SegmentDescriptorSize(SegmentDescriptorSize),\n        CodeAlignmentFactor(CodeAlignmentFactor),\n        DataAlignmentFactor(DataAlignmentFactor),\n        ReturnAddressRegister(ReturnAddressRegister),\n        AugmentationData(std::move(AugmentationData)),\n        FDEPointerEncoding(FDEPointerEncoding),\n        LSDAPointerEncoding(LSDAPointerEncoding), Personality(Personality),\n        PersonalityEnc(PersonalityEnc) {}\n\n  static bool classof(const FrameEntry *FE) { return FE->getKind() == FK_CIE; }\n\n  StringRef getAugmentationString() const { return Augmentation; }\n  uint64_t getCodeAlignmentFactor() const { return CodeAlignmentFactor; }\n  int64_t getDataAlignmentFactor() const { return DataAlignmentFactor; }\n  uint8_t getVersion() const { return Version; }\n  uint64_t getReturnAddressRegister() const { return ReturnAddressRegister; }\n  Optional<uint64_t> getPersonalityAddress() const { return Personality; }\n  Optional<uint32_t> getPersonalityEncoding() const { return PersonalityEnc; }\n\n  uint32_t getFDEPointerEncoding() const { return FDEPointerEncoding; }\n\n  uint32_t getLSDAPointerEncoding() const { return LSDAPointerEncoding; }\n\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts, const MCRegisterInfo *MRI,\n            bool IsEH) const override;\n\nprivate:\n  /// The following fields are defined in section 6.4.1 of the DWARF standard v4\n  const uint8_t Version;\n  const SmallString<8> Augmentation;\n  const uint8_t AddressSize;\n  const uint8_t SegmentDescriptorSize;\n  const uint64_t CodeAlignmentFactor;\n  const int64_t DataAlignmentFactor;\n  const uint64_t ReturnAddressRegister;\n\n  // The following are used when the CIE represents an EH frame entry.\n  const SmallString<8> AugmentationData;\n  const uint32_t FDEPointerEncoding;\n  const uint32_t LSDAPointerEncoding;\n  const Optional<uint64_t> Personality;\n  const Optional<uint32_t> PersonalityEnc;\n};\n\n/// DWARF Frame Description Entry (FDE)\nclass FDE : public FrameEntry {\npublic:\n  FDE(bool IsDWARF64, uint64_t Offset, uint64_t Length, uint64_t CIEPointer,\n      uint64_t InitialLocation, uint64_t AddressRange, CIE *Cie,\n      Optional<uint64_t> LSDAAddress, Triple::ArchType Arch)\n      : FrameEntry(FK_FDE, IsDWARF64, Offset, Length,\n                   Cie ? Cie->getCodeAlignmentFactor() : 0,\n                   Cie ? Cie->getDataAlignmentFactor() : 0,\n                   Arch),\n        CIEPointer(CIEPointer), InitialLocation(InitialLocation),\n        AddressRange(AddressRange), LinkedCIE(Cie), LSDAAddress(LSDAAddress) {}\n\n  ~FDE() override = default;\n\n  const CIE *getLinkedCIE() const { return LinkedCIE; }\n  uint64_t getInitialLocation() const { return InitialLocation; }\n  uint64_t getAddressRange() const { return AddressRange; }\n  Optional<uint64_t> getLSDAAddress() const { return LSDAAddress; }\n\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts, const MCRegisterInfo *MRI,\n            bool IsEH) const override;\n\n  static bool classof(const FrameEntry *FE) { return FE->getKind() == FK_FDE; }\n\nprivate:\n  /// The following fields are defined in section 6.4.1 of the DWARFv3 standard.\n  /// Note that CIE pointers in EH FDEs, unlike DWARF FDEs, contain relative\n  /// offsets to the linked CIEs. See the following link for more info:\n  /// https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html\n  const uint64_t CIEPointer;\n  const uint64_t InitialLocation;\n  const uint64_t AddressRange;\n  const CIE *LinkedCIE;\n  const Optional<uint64_t> LSDAAddress;\n};\n\n} // end namespace dwarf\n\n/// A parsed .debug_frame or .eh_frame section\nclass DWARFDebugFrame {\n  const Triple::ArchType Arch;\n  // True if this is parsing an eh_frame section.\n  const bool IsEH;\n  // Not zero for sane pointer values coming out of eh_frame\n  const uint64_t EHFrameAddress;\n\n  std::vector<std::unique_ptr<dwarf::FrameEntry>> Entries;\n  using iterator = pointee_iterator<decltype(Entries)::const_iterator>;\n\n  /// Return the entry at the given offset or nullptr.\n  dwarf::FrameEntry *getEntryAtOffset(uint64_t Offset) const;\n\npublic:\n  // If IsEH is true, assume it is a .eh_frame section. Otherwise,\n  // it is a .debug_frame section. EHFrameAddress should be different\n  // than zero for correct parsing of .eh_frame addresses when they\n  // use a PC-relative encoding.\n  DWARFDebugFrame(Triple::ArchType Arch,\n                  bool IsEH = false, uint64_t EHFrameAddress = 0);\n  ~DWARFDebugFrame();\n\n  /// Dump the section data into the given stream.\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts, const MCRegisterInfo *MRI,\n            Optional<uint64_t> Offset) const;\n\n  /// Parse the section from raw data. \\p Data is assumed to contain the whole\n  /// frame section contents to be parsed.\n  Error parse(DWARFDataExtractor Data);\n\n  /// Return whether the section has any entries.\n  bool empty() const { return Entries.empty(); }\n\n  /// DWARF Frame entries accessors\n  iterator begin() const { return Entries.begin(); }\n  iterator end() const { return Entries.end(); }\n  iterator_range<iterator> entries() const {\n    return iterator_range<iterator>(Entries.begin(), Entries.end());\n  }\n\n  uint64_t getEHFrameAddress() const { return EHFrameAddress; }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGFRAME_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "content": "//===- DWARFDebugLine.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGLINE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGLINE_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFCompileUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFRelocMap.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFTypeUnit.h\"\n#include \"llvm/Support/MD5.h\"\n#include \"llvm/Support/Path.h\"\n#include <cstdint>\n#include <map>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass DWARFUnit;\nclass raw_ostream;\n\nclass DWARFDebugLine {\npublic:\n  struct FileNameEntry {\n    FileNameEntry() = default;\n\n    DWARFFormValue Name;\n    uint64_t DirIdx = 0;\n    uint64_t ModTime = 0;\n    uint64_t Length = 0;\n    MD5::MD5Result Checksum;\n    DWARFFormValue Source;\n  };\n\n  /// Tracks which optional content types are present in a DWARF file name\n  /// entry format.\n  struct ContentTypeTracker {\n    ContentTypeTracker() = default;\n\n    /// Whether filename entries provide a modification timestamp.\n    bool HasModTime = false;\n    /// Whether filename entries provide a file size.\n    bool HasLength = false;\n    /// For v5, whether filename entries provide an MD5 checksum.\n    bool HasMD5 = false;\n    /// For v5, whether filename entries provide source text.\n    bool HasSource = false;\n\n    /// Update tracked content types with \\p ContentType.\n    void trackContentType(dwarf::LineNumberEntryFormat ContentType);\n  };\n\n  struct Prologue {\n    Prologue();\n\n    /// The size in bytes of the statement information for this compilation unit\n    /// (not including the total_length field itself).\n    uint64_t TotalLength;\n    /// Version, address size (starting in v5), and DWARF32/64 format; these\n    /// parameters affect interpretation of forms (used in the directory and\n    /// file tables starting with v5).\n    dwarf::FormParams FormParams;\n    /// The number of bytes following the prologue_length field to the beginning\n    /// of the first byte of the statement program itself.\n    uint64_t PrologueLength;\n    /// In v5, size in bytes of a segment selector.\n    uint8_t SegSelectorSize;\n    /// The size in bytes of the smallest target machine instruction. Statement\n    /// program opcodes that alter the address register first multiply their\n    /// operands by this value.\n    uint8_t MinInstLength;\n    /// The maximum number of individual operations that may be encoded in an\n    /// instruction.\n    uint8_t MaxOpsPerInst;\n    /// The initial value of theis_stmtregister.\n    uint8_t DefaultIsStmt;\n    /// This parameter affects the meaning of the special opcodes. See below.\n    int8_t LineBase;\n    /// This parameter affects the meaning of the special opcodes. See below.\n    uint8_t LineRange;\n    /// The number assigned to the first special opcode.\n    uint8_t OpcodeBase;\n    /// This tracks which optional file format content types are present.\n    ContentTypeTracker ContentTypes;\n    std::vector<uint8_t> StandardOpcodeLengths;\n    std::vector<DWARFFormValue> IncludeDirectories;\n    std::vector<FileNameEntry> FileNames;\n\n    const dwarf::FormParams getFormParams() const { return FormParams; }\n    uint16_t getVersion() const { return FormParams.Version; }\n    uint8_t getAddressSize() const { return FormParams.AddrSize; }\n    bool isDWARF64() const { return FormParams.Format == dwarf::DWARF64; }\n\n    uint32_t sizeofTotalLength() const { return isDWARF64() ? 12 : 4; }\n\n    uint32_t sizeofPrologueLength() const { return isDWARF64() ? 8 : 4; }\n\n    bool totalLengthIsValid() const;\n\n    /// Length of the prologue in bytes.\n    uint64_t getLength() const;\n\n    int32_t getMaxLineIncrementForSpecialOpcode() const {\n      return LineBase + (int8_t)LineRange - 1;\n    }\n\n    /// Get DWARF-version aware access to the file name entry at the provided\n    /// index.\n    const llvm::DWARFDebugLine::FileNameEntry &\n    getFileNameEntry(uint64_t Index) const;\n\n    bool hasFileAtIndex(uint64_t FileIndex) const;\n\n    Optional<uint64_t> getLastValidFileIndex() const;\n\n    bool\n    getFileNameByIndex(uint64_t FileIndex, StringRef CompDir,\n                       DILineInfoSpecifier::FileLineInfoKind Kind,\n                       std::string &Result,\n                       sys::path::Style Style = sys::path::Style::native) const;\n\n    void clear();\n    void dump(raw_ostream &OS, DIDumpOptions DumpOptions) const;\n    Error parse(DWARFDataExtractor Data, uint64_t *OffsetPtr,\n                function_ref<void(Error)> RecoverableErrorHandler,\n                const DWARFContext &Ctx, const DWARFUnit *U = nullptr);\n  };\n\n  /// Standard .debug_line state machine structure.\n  struct Row {\n    explicit Row(bool DefaultIsStmt = false);\n\n    /// Called after a row is appended to the matrix.\n    void postAppend();\n    void reset(bool DefaultIsStmt);\n    void dump(raw_ostream &OS) const;\n\n    static void dumpTableHeader(raw_ostream &OS, unsigned Indent);\n\n    static bool orderByAddress(const Row &LHS, const Row &RHS) {\n      return std::tie(LHS.Address.SectionIndex, LHS.Address.Address) <\n             std::tie(RHS.Address.SectionIndex, RHS.Address.Address);\n    }\n\n    /// The program-counter value corresponding to a machine instruction\n    /// generated by the compiler and section index pointing to the section\n    /// containg this PC. If relocation information is present then section\n    /// index is the index of the section which contains above address.\n    /// Otherwise this is object::SectionedAddress::Undef value.\n    object::SectionedAddress Address;\n    /// An unsigned integer indicating a source line number. Lines are numbered\n    /// beginning at 1. The compiler may emit the value 0 in cases where an\n    /// instruction cannot be attributed to any source line.\n    uint32_t Line;\n    /// An unsigned integer indicating a column number within a source line.\n    /// Columns are numbered beginning at 1. The value 0 is reserved to indicate\n    /// that a statement begins at the 'left edge' of the line.\n    uint16_t Column;\n    /// An unsigned integer indicating the identity of the source file\n    /// corresponding to a machine instruction.\n    uint16_t File;\n    /// An unsigned integer representing the DWARF path discriminator value\n    /// for this location.\n    uint32_t Discriminator;\n    /// An unsigned integer whose value encodes the applicable instruction set\n    /// architecture for the current instruction.\n    uint8_t Isa;\n    /// A boolean indicating that the current instruction is the beginning of a\n    /// statement.\n    uint8_t IsStmt : 1,\n        /// A boolean indicating that the current instruction is the\n        /// beginning of a basic block.\n        BasicBlock : 1,\n        /// A boolean indicating that the current address is that of the\n        /// first byte after the end of a sequence of target machine\n        /// instructions.\n        EndSequence : 1,\n        /// A boolean indicating that the current address is one (of possibly\n        /// many) where execution should be suspended for an entry breakpoint\n        /// of a function.\n        PrologueEnd : 1,\n        /// A boolean indicating that the current address is one (of possibly\n        /// many) where execution should be suspended for an exit breakpoint\n        /// of a function.\n        EpilogueBegin : 1;\n  };\n\n  /// Represents a series of contiguous machine instructions. Line table for\n  /// each compilation unit may consist of multiple sequences, which are not\n  /// guaranteed to be in the order of ascending instruction address.\n  struct Sequence {\n    Sequence();\n\n    /// Sequence describes instructions at address range [LowPC, HighPC)\n    /// and is described by line table rows [FirstRowIndex, LastRowIndex).\n    uint64_t LowPC;\n    uint64_t HighPC;\n    /// If relocation information is present then this is the index of the\n    /// section which contains above addresses. Otherwise this is\n    /// object::SectionedAddress::Undef value.\n    uint64_t SectionIndex;\n    unsigned FirstRowIndex;\n    unsigned LastRowIndex;\n    bool Empty;\n\n    void reset();\n\n    static bool orderByHighPC(const Sequence &LHS, const Sequence &RHS) {\n      return std::tie(LHS.SectionIndex, LHS.HighPC) <\n             std::tie(RHS.SectionIndex, RHS.HighPC);\n    }\n\n    bool isValid() const {\n      return !Empty && (LowPC < HighPC) && (FirstRowIndex < LastRowIndex);\n    }\n\n    bool containsPC(object::SectionedAddress PC) const {\n      return SectionIndex == PC.SectionIndex &&\n             (LowPC <= PC.Address && PC.Address < HighPC);\n    }\n  };\n\n  struct LineTable {\n    LineTable();\n\n    /// Represents an invalid row\n    const uint32_t UnknownRowIndex = UINT32_MAX;\n\n    void appendRow(const DWARFDebugLine::Row &R) { Rows.push_back(R); }\n\n    void appendSequence(const DWARFDebugLine::Sequence &S) {\n      Sequences.push_back(S);\n    }\n\n    /// Returns the index of the row with file/line info for a given address,\n    /// or UnknownRowIndex if there is no such row.\n    uint32_t lookupAddress(object::SectionedAddress Address) const;\n\n    bool lookupAddressRange(object::SectionedAddress Address, uint64_t Size,\n                            std::vector<uint32_t> &Result) const;\n\n    bool hasFileAtIndex(uint64_t FileIndex) const {\n      return Prologue.hasFileAtIndex(FileIndex);\n    }\n\n    Optional<uint64_t> getLastValidFileIndex() const {\n      return Prologue.getLastValidFileIndex();\n    }\n\n    /// Extracts filename by its index in filename table in prologue.\n    /// In Dwarf 4, the files are 1-indexed and the current compilation file\n    /// name is not represented in the list. In DWARF v5, the files are\n    /// 0-indexed and the primary source file has the index 0.\n    /// Returns true on success.\n    bool getFileNameByIndex(uint64_t FileIndex, StringRef CompDir,\n                            DILineInfoSpecifier::FileLineInfoKind Kind,\n                            std::string &Result) const {\n      return Prologue.getFileNameByIndex(FileIndex, CompDir, Kind, Result);\n    }\n\n    /// Fills the Result argument with the file and line information\n    /// corresponding to Address. Returns true on success.\n    bool getFileLineInfoForAddress(object::SectionedAddress Address,\n                                   const char *CompDir,\n                                   DILineInfoSpecifier::FileLineInfoKind Kind,\n                                   DILineInfo &Result) const;\n\n    void dump(raw_ostream &OS, DIDumpOptions DumpOptions) const;\n    void clear();\n\n    /// Parse prologue and all rows.\n    Error parse(DWARFDataExtractor &DebugLineData, uint64_t *OffsetPtr,\n                const DWARFContext &Ctx, const DWARFUnit *U,\n                function_ref<void(Error)> RecoverableErrorHandler,\n                raw_ostream *OS = nullptr, bool Verbose = false);\n\n    using RowVector = std::vector<Row>;\n    using RowIter = RowVector::const_iterator;\n    using SequenceVector = std::vector<Sequence>;\n    using SequenceIter = SequenceVector::const_iterator;\n\n    struct Prologue Prologue;\n    RowVector Rows;\n    SequenceVector Sequences;\n\n  private:\n    uint32_t findRowInSeq(const DWARFDebugLine::Sequence &Seq,\n                          object::SectionedAddress Address) const;\n    Optional<StringRef>\n    getSourceByIndex(uint64_t FileIndex,\n                     DILineInfoSpecifier::FileLineInfoKind Kind) const;\n\n    uint32_t lookupAddressImpl(object::SectionedAddress Address) const;\n\n    bool lookupAddressRangeImpl(object::SectionedAddress Address, uint64_t Size,\n                                std::vector<uint32_t> &Result) const;\n  };\n\n  const LineTable *getLineTable(uint64_t Offset) const;\n  Expected<const LineTable *>\n  getOrParseLineTable(DWARFDataExtractor &DebugLineData, uint64_t Offset,\n                      const DWARFContext &Ctx, const DWARFUnit *U,\n                      function_ref<void(Error)> RecoverableErrorHandler);\n\n  /// Helper to allow for parsing of an entire .debug_line section in sequence.\n  class SectionParser {\n  public:\n    using LineToUnitMap = std::map<uint64_t, DWARFUnit *>;\n\n    SectionParser(DWARFDataExtractor &Data, const DWARFContext &C,\n                  DWARFUnitVector::iterator_range Units);\n\n    /// Get the next line table from the section. Report any issues via the\n    /// handlers.\n    ///\n    /// \\param RecoverableErrorHandler - any issues that don't prevent further\n    /// parsing of the table will be reported through this handler.\n    /// \\param UnrecoverableErrorHandler - any issues that prevent further\n    /// parsing of the table will be reported through this handler.\n    /// \\param OS - if not null, the parser will print information about the\n    /// table as it parses it.\n    /// \\param Verbose - if true, the parser will print verbose information when\n    /// printing to the output.\n    LineTable parseNext(function_ref<void(Error)> RecoverableErrorHandler,\n                        function_ref<void(Error)> UnrecoverableErrorHandler,\n                        raw_ostream *OS = nullptr, bool Verbose = false);\n\n    /// Skip the current line table and go to the following line table (if\n    /// present) immediately.\n    ///\n    /// \\param RecoverableErrorHandler - report any recoverable prologue\n    /// parsing issues via this handler.\n    /// \\param UnrecoverableErrorHandler - report any unrecoverable prologue\n    /// parsing issues via this handler.\n    void skip(function_ref<void(Error)> RecoverableErrorHandler,\n              function_ref<void(Error)> UnrecoverableErrorHandler);\n\n    /// Indicates if the parser has parsed as much as possible.\n    ///\n    /// \\note Certain problems with the line table structure might mean that\n    /// parsing stops before the end of the section is reached.\n    bool done() const { return Done; }\n\n    /// Get the offset the parser has reached.\n    uint64_t getOffset() const { return Offset; }\n\n  private:\n    DWARFUnit *prepareToParse(uint64_t Offset);\n    void moveToNextTable(uint64_t OldOffset, const Prologue &P);\n\n    LineToUnitMap LineToUnit;\n\n    DWARFDataExtractor &DebugLineData;\n    const DWARFContext &Context;\n    uint64_t Offset = 0;\n    bool Done = false;\n  };\n\nprivate:\n  struct ParsingState {\n    ParsingState(struct LineTable *LT, uint64_t TableOffset,\n                 function_ref<void(Error)> ErrorHandler);\n\n    void resetRowAndSequence();\n    void appendRowToMatrix();\n\n    /// Advance the address by the \\p OperationAdvance value. \\returns the\n    /// amount advanced by.\n    uint64_t advanceAddr(uint64_t OperationAdvance, uint8_t Opcode,\n                         uint64_t OpcodeOffset);\n\n    struct AddrAndAdjustedOpcode {\n      uint64_t AddrDelta;\n      uint8_t AdjustedOpcode;\n    };\n\n    /// Advance the address as required by the specified \\p Opcode.\n    /// \\returns the amount advanced by and the calculated adjusted opcode.\n    AddrAndAdjustedOpcode advanceAddrForOpcode(uint8_t Opcode,\n                                               uint64_t OpcodeOffset);\n\n    struct AddrAndLineDelta {\n      uint64_t Address;\n      int32_t Line;\n    };\n\n    /// Advance the line and address as required by the specified special \\p\n    /// Opcode. \\returns the address and line delta.\n    AddrAndLineDelta handleSpecialOpcode(uint8_t Opcode, uint64_t OpcodeOffset);\n\n    /// Line table we're currently parsing.\n    struct LineTable *LineTable;\n    struct Row Row;\n    struct Sequence Sequence;\n\n  private:\n    uint64_t LineTableOffset;\n\n    bool ReportAdvanceAddrProblem = true;\n    bool ReportBadLineRange = true;\n    function_ref<void(Error)> ErrorHandler;\n  };\n\n  using LineTableMapTy = std::map<uint64_t, LineTable>;\n  using LineTableIter = LineTableMapTy::iterator;\n  using LineTableConstIter = LineTableMapTy::const_iterator;\n\n  LineTableMapTy LineTableMap;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGLINE_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "content": "//===- DWARFDebugMacro.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGMACRO_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGMACRO_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnit.h\"\n#include \"llvm/Support/Errc.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFDebugMacro {\n  /// DWARFv5 section 6.3.1 Macro Information Header.\n  enum HeaderFlagMask {\n#define HANDLE_MACRO_FLAG(ID, NAME) MACRO_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  };\n  struct MacroHeader {\n    /// Macro version information number.\n    uint16_t Version = 0;\n\n    /// The bits of the flags field are interpreted as a set of flags, some of\n    /// which may indicate that additional fields follow. The following flags,\n    /// beginning with the least significant bit, are defined:\n    /// offset_size_flag:\n    ///   If the offset_size_flag is zero, the header is for a 32-bit DWARF\n    ///   format macro section and all offsets are 4 bytes long; if it is one,\n    ///   the header is for a 64-bit DWARF format macro section and all offsets\n    ///   are 8 bytes long.\n    /// debug_line_offset_flag:\n    ///   If the debug_line_offset_flag is one, the debug_line_offset field (see\n    ///   below) is present. If zero, that field is omitted.\n    /// opcode_operands_table_flag:\n    ///   If the opcode_operands_table_flag is one, the opcode_operands_table\n    ///   field (see below) is present. If zero, that field is omitted.\n    uint8_t Flags = 0;\n\n    /// debug_line_offset\n    ///   An offset in the .debug_line section of the beginning of the line\n    ///   number information in the containing compilation unit, encoded as a\n    ///   4-byte offset for a 32-bit DWARF format macro section and an 8-byte\n    ///   offset for a 64-bit DWARF format macro section.\n    uint64_t DebugLineOffset;\n\n    /// Print the macro header from the debug_macro section.\n    void dumpMacroHeader(raw_ostream &OS) const;\n\n    /// Parse the debug_macro header.\n    Error parseMacroHeader(DWARFDataExtractor Data, uint64_t *Offset);\n\n    /// Get the DWARF format according to the flags.\n    dwarf::DwarfFormat getDwarfFormat() const;\n\n    /// Get the size of a reference according to the DWARF format.\n    uint8_t getOffsetByteSize() const;\n  };\n\n  /// A single macro entry within a macro list.\n  struct Entry {\n    /// The type of the macro entry.\n    uint32_t Type;\n    union {\n      /// The source line where the macro is defined.\n      uint64_t Line;\n      /// Vendor extension constant value.\n      uint64_t ExtConstant;\n      /// Macro unit import offset.\n      uint64_t ImportOffset;\n    };\n\n    union {\n      /// The string (name, value) of the macro entry.\n      const char *MacroStr;\n      // An unsigned integer indicating the identity of the source file.\n      uint64_t File;\n      /// Vendor extension string.\n      const char *ExtStr;\n    };\n  };\n\n  struct MacroList {\n    // A value 0 in the `Header.Version` field indicates that we're parsing\n    // a macinfo[.dwo] section which doesn't have header itself, hence\n    // for that case other fields in the `Header` are uninitialized.\n    MacroHeader Header;\n    SmallVector<Entry, 4> Macros;\n    uint64_t Offset;\n\n    /// Whether or not this is a .debug_macro section.\n    bool IsDebugMacro;\n  };\n\n  /// A list of all the macro entries in the debug_macinfo section.\n  std::vector<MacroList> MacroLists;\n\npublic:\n  DWARFDebugMacro() = default;\n\n  /// Print the macro list found within the debug_macinfo/debug_macro section.\n  void dump(raw_ostream &OS) const;\n\n  Error parseMacro(DWARFUnitVector::compile_unit_range Units,\n                   DataExtractor StringExtractor,\n                   DWARFDataExtractor MacroData) {\n    return parseImpl(Units, StringExtractor, MacroData, /*IsMacro=*/true);\n  }\n\n  Error parseMacinfo(DWARFDataExtractor MacroData) {\n    return parseImpl(None, None, MacroData, /*IsMacro=*/false);\n  }\n\n  /// Return whether the section has any entries.\n  bool empty() const { return MacroLists.empty(); }\n\nprivate:\n  /// Parse the debug_macinfo/debug_macro section accessible via the 'MacroData'\n  /// parameter.\n  Error parseImpl(Optional<DWARFUnitVector::compile_unit_range> Units,\n                  Optional<DataExtractor> StringExtractor,\n                  DWARFDataExtractor Data, bool IsMacro);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGMACRO_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "content": "//===--- DWARFExpression.h - DWARF Expression handling ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFEXPRESSION_H\n#define LLVM_DEBUGINFO_DWARF_DWARFEXPRESSION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/Support/DataExtractor.h\"\n\nnamespace llvm {\nclass DWARFUnit;\nclass MCRegisterInfo;\nclass raw_ostream;\n\nclass DWARFExpression {\npublic:\n  class iterator;\n\n  /// This class represents an Operation in the Expression. Each operation can\n  /// have up to 2 oprerands.\n  ///\n  /// An Operation can be in Error state (check with isError()). This\n  /// means that it couldn't be decoded successfully and if it is the\n  /// case, all others fields contain undefined values.\n  class Operation {\n  public:\n    /// Size and signedness of expression operations' operands.\n    enum Encoding : uint8_t {\n      Size1 = 0,\n      Size2 = 1,\n      Size4 = 2,\n      Size8 = 3,\n      SizeLEB = 4,\n      SizeAddr = 5,\n      SizeRefAddr = 6,\n      SizeBlock = 7, ///< Preceding operand contains block size\n      BaseTypeRef = 8,\n      WasmLocationArg = 30,\n      SignBit = 0x80,\n      SignedSize1 = SignBit | Size1,\n      SignedSize2 = SignBit | Size2,\n      SignedSize4 = SignBit | Size4,\n      SignedSize8 = SignBit | Size8,\n      SignedSizeLEB = SignBit | SizeLEB,\n      SizeNA = 0xFF ///< Unused operands get this encoding.\n    };\n\n    enum DwarfVersion : uint8_t {\n      DwarfNA, ///< Serves as a marker for unused entries\n      Dwarf2 = 2,\n      Dwarf3,\n      Dwarf4,\n      Dwarf5\n    };\n\n    /// Description of the encoding of one expression Op.\n    struct Description {\n      DwarfVersion Version; ///< Dwarf version where the Op was introduced.\n      Encoding Op[2];       ///< Encoding for Op operands, or SizeNA.\n\n      Description(DwarfVersion Version = DwarfNA, Encoding Op1 = SizeNA,\n                  Encoding Op2 = SizeNA)\n          : Version(Version) {\n        Op[0] = Op1;\n        Op[1] = Op2;\n      }\n    };\n\n  private:\n    friend class DWARFExpression::iterator;\n    uint8_t Opcode; ///< The Op Opcode, DW_OP_<something>.\n    Description Desc;\n    bool Error = false;\n    uint64_t EndOffset;\n    uint64_t Operands[2];\n    uint64_t OperandEndOffsets[2];\n\n  public:\n    Description &getDescription() { return Desc; }\n    uint8_t getCode() { return Opcode; }\n    uint64_t getRawOperand(unsigned Idx) { return Operands[Idx]; }\n    uint64_t getOperandEndOffset(unsigned Idx) { return OperandEndOffsets[Idx]; }\n    uint64_t getEndOffset() { return EndOffset; }\n    bool extract(DataExtractor Data, uint8_t AddressSize, uint64_t Offset,\n                 Optional<dwarf::DwarfFormat> Format);\n    bool isError() { return Error; }\n    bool print(raw_ostream &OS, DIDumpOptions DumpOpts,\n               const DWARFExpression *Expr, const MCRegisterInfo *RegInfo,\n               DWARFUnit *U, bool isEH);\n    bool verify(DWARFUnit *U);\n  };\n\n  /// An iterator to go through the expression operations.\n  class iterator\n      : public iterator_facade_base<iterator, std::forward_iterator_tag,\n                                    Operation> {\n    friend class DWARFExpression;\n    const DWARFExpression *Expr;\n    uint64_t Offset;\n    Operation Op;\n    iterator(const DWARFExpression *Expr, uint64_t Offset)\n        : Expr(Expr), Offset(Offset) {\n      Op.Error =\n          Offset >= Expr->Data.getData().size() ||\n          !Op.extract(Expr->Data, Expr->AddressSize, Offset, Expr->Format);\n    }\n\n  public:\n    class Operation &operator++() {\n      Offset = Op.isError() ? Expr->Data.getData().size() : Op.EndOffset;\n      Op.Error =\n          Offset >= Expr->Data.getData().size() ||\n          !Op.extract(Expr->Data, Expr->AddressSize, Offset, Expr->Format);\n      return Op;\n    }\n\n    class Operation &operator*() {\n      return Op;\n    }\n\n    iterator skipBytes(uint64_t Add) {\n      return iterator(Expr, Op.EndOffset + Add);\n    }\n\n    // Comparison operators are provided out of line.\n    friend bool operator==(const iterator &, const iterator &);\n  };\n\n  DWARFExpression(DataExtractor Data, uint8_t AddressSize,\n                  Optional<dwarf::DwarfFormat> Format = None)\n      : Data(Data), AddressSize(AddressSize), Format(Format) {\n    assert(AddressSize == 8 || AddressSize == 4 || AddressSize == 2);\n  }\n\n  iterator begin() const { return iterator(this, 0); }\n  iterator end() const { return iterator(this, Data.getData().size()); }\n\n  void print(raw_ostream &OS, DIDumpOptions DumpOpts,\n             const MCRegisterInfo *RegInfo, DWARFUnit *U,\n             bool IsEH = false) const;\n\n  /// Print the expression in a format intended to be compact and useful to a\n  /// user, but not perfectly unambiguous, or capable of representing every\n  /// valid DWARF expression. Returns true if the expression was sucessfully\n  /// printed.\n  bool printCompact(raw_ostream &OS, const MCRegisterInfo &RegInfo);\n\n  bool verify(DWARFUnit *U);\n\n  bool operator==(const DWARFExpression &RHS) const;\n\nprivate:\n  DataExtractor Data;\n  uint8_t AddressSize;\n  Optional<dwarf::DwarfFormat> Format;\n};\n\ninline bool operator==(const DWARFExpression::iterator &LHS,\n                       const DWARFExpression::iterator &RHS) {\n  return LHS.Expr == RHS.Expr && LHS.Offset == RHS.Offset;\n}\n}\n#endif\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "content": "//===- DWARFGdbIndex.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFGDBINDEX_H\n#define LLVM_DEBUGINFO_DWARF_DWARFGDBINDEX_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFGdbIndex {\n  uint32_t Version;\n\n  uint32_t CuListOffset;\n  uint32_t TuListOffset;\n  uint32_t AddressAreaOffset;\n  uint32_t SymbolTableOffset;\n  uint32_t ConstantPoolOffset;\n\n  struct CompUnitEntry {\n    uint64_t Offset; /// Offset of a CU in the .debug_info section.\n    uint64_t Length; /// Length of that CU.\n  };\n  SmallVector<CompUnitEntry, 0> CuList;\n\n  struct TypeUnitEntry {\n    uint64_t Offset;\n    uint64_t TypeOffset;\n    uint64_t TypeSignature;\n  };\n  SmallVector<TypeUnitEntry, 0> TuList;\n\n  struct AddressEntry {\n    uint64_t LowAddress;  /// The low address.\n    uint64_t HighAddress; /// The high address.\n    uint32_t CuIndex;     /// The CU index.\n  };\n  SmallVector<AddressEntry, 0> AddressArea;\n\n  struct SymTableEntry {\n    uint32_t NameOffset; /// Offset of the symbol's name in the constant pool.\n    uint32_t VecOffset;  /// Offset of the CU vector in the constant pool.\n  };\n  SmallVector<SymTableEntry, 0> SymbolTable;\n\n  /// Each value is CU index + attributes.\n  SmallVector<std::pair<uint32_t, SmallVector<uint32_t, 0>>, 0>\n      ConstantPoolVectors;\n\n  StringRef ConstantPoolStrings;\n  uint32_t StringPoolOffset;\n\n  void dumpCUList(raw_ostream &OS) const;\n  void dumpTUList(raw_ostream &OS) const;\n  void dumpAddressArea(raw_ostream &OS) const;\n  void dumpSymbolTable(raw_ostream &OS) const;\n  void dumpConstantPool(raw_ostream &OS) const;\n\n  bool parseImpl(DataExtractor Data);\n\npublic:\n  void dump(raw_ostream &OS);\n  void parse(DataExtractor Data);\n\n  bool HasContent = false;\n  bool HasError = false;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFGDBINDEX_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFTypeUnit.h", "content": "//===- DWARFTypeUnit.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFTYPEUNIT_H\n#define LLVM_DEBUGINFO_DWARF_DWARFTYPEUNIT_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnitIndex.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass DWARFContext;\nclass DWARFDebugAbbrev;\nstruct DWARFSection;\nclass raw_ostream;\n\nclass DWARFTypeUnit : public DWARFUnit {\npublic:\n  DWARFTypeUnit(DWARFContext &Context, const DWARFSection &Section,\n                const DWARFUnitHeader &Header, const DWARFDebugAbbrev *DA,\n                const DWARFSection *RS, const DWARFSection *LocSection,\n                StringRef SS, const DWARFSection &SOS, const DWARFSection *AOS,\n                const DWARFSection &LS, bool LE, bool IsDWO,\n                const DWARFUnitVector &UnitVector)\n      : DWARFUnit(Context, Section, Header, DA, RS, LocSection, SS, SOS, AOS,\n                  LS, LE, IsDWO, UnitVector) {}\n\n  uint64_t getTypeHash() const { return getHeader().getTypeHash(); }\n  uint64_t getTypeOffset() const { return getHeader().getTypeOffset(); }\n\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts = {}) override;\n  // Enable LLVM-style RTTI.\n  static bool classof(const DWARFUnit *U) { return U->isTypeUnit(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFTYPEUNIT_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "content": "//===- DWARFUnit.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n#define LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRnglists.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDie.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFRelocMap.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFSection.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnitIndex.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass DWARFAbbreviationDeclarationSet;\nclass DWARFContext;\nclass DWARFDebugAbbrev;\nclass DWARFUnit;\n\n/// Base class describing the header of any kind of \"unit.\"  Some information\n/// is specific to certain unit types.  We separate this class out so we can\n/// parse the header before deciding what specific kind of unit to construct.\nclass DWARFUnitHeader {\n  // Offset within section.\n  uint64_t Offset = 0;\n  // Version, address size, and DWARF format.\n  dwarf::FormParams FormParams;\n  uint64_t Length = 0;\n  uint64_t AbbrOffset = 0;\n\n  // For DWO units only.\n  const DWARFUnitIndex::Entry *IndexEntry = nullptr;\n\n  // For type units only.\n  uint64_t TypeHash = 0;\n  uint64_t TypeOffset = 0;\n\n  // For v5 split or skeleton compile units only.\n  Optional<uint64_t> DWOId;\n\n  // Unit type as parsed, or derived from the section kind.\n  uint8_t UnitType = 0;\n\n  // Size as parsed. uint8_t for compactness.\n  uint8_t Size = 0;\n\npublic:\n  /// Parse a unit header from \\p debug_info starting at \\p offset_ptr.\n  /// Note that \\p SectionKind is used as a hint to guess the unit type\n  /// for DWARF formats prior to DWARFv5. In DWARFv5 the unit type is\n  /// explicitly defined in the header and the hint is ignored.\n  bool extract(DWARFContext &Context, const DWARFDataExtractor &debug_info,\n               uint64_t *offset_ptr, DWARFSectionKind SectionKind);\n  // For units in DWARF Package File, remember the index entry and update\n  // the abbreviation offset read by extract().\n  bool applyIndexEntry(const DWARFUnitIndex::Entry *Entry);\n  uint64_t getOffset() const { return Offset; }\n  const dwarf::FormParams &getFormParams() const { return FormParams; }\n  uint16_t getVersion() const { return FormParams.Version; }\n  dwarf::DwarfFormat getFormat() const { return FormParams.Format; }\n  uint8_t getAddressByteSize() const { return FormParams.AddrSize; }\n  uint8_t getRefAddrByteSize() const { return FormParams.getRefAddrByteSize(); }\n  uint8_t getDwarfOffsetByteSize() const {\n    return FormParams.getDwarfOffsetByteSize();\n  }\n  uint64_t getLength() const { return Length; }\n  uint64_t getAbbrOffset() const { return AbbrOffset; }\n  Optional<uint64_t> getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t Id) {\n    assert((!DWOId || *DWOId == Id) && \"setting DWOId to a different value\");\n    DWOId = Id;\n  }\n  const DWARFUnitIndex::Entry *getIndexEntry() const { return IndexEntry; }\n  uint64_t getTypeHash() const { return TypeHash; }\n  uint64_t getTypeOffset() const { return TypeOffset; }\n  uint8_t getUnitType() const { return UnitType; }\n  bool isTypeUnit() const {\n    return UnitType == dwarf::DW_UT_type || UnitType == dwarf::DW_UT_split_type;\n  }\n  uint8_t getSize() const { return Size; }\n  uint8_t getUnitLengthFieldByteSize() const {\n    return dwarf::getUnitLengthFieldByteSize(FormParams.Format);\n  }\n  uint64_t getNextUnitOffset() const {\n    return Offset + Length + getUnitLengthFieldByteSize();\n  }\n};\n\nconst DWARFUnitIndex &getDWARFUnitIndex(DWARFContext &Context,\n                                        DWARFSectionKind Kind);\n\nbool isCompileUnit(const std::unique_ptr<DWARFUnit> &U);\n\n/// Describe a collection of units. Intended to hold all units either from\n/// .debug_info and .debug_types, or from .debug_info.dwo and .debug_types.dwo.\nclass DWARFUnitVector final : public SmallVector<std::unique_ptr<DWARFUnit>, 1> {\n  std::function<std::unique_ptr<DWARFUnit>(uint64_t, DWARFSectionKind,\n                                           const DWARFSection *,\n                                           const DWARFUnitIndex::Entry *)>\n      Parser;\n  int NumInfoUnits = -1;\n\npublic:\n  using UnitVector = SmallVectorImpl<std::unique_ptr<DWARFUnit>>;\n  using iterator = typename UnitVector::iterator;\n  using iterator_range = llvm::iterator_range<typename UnitVector::iterator>;\n\n  using compile_unit_range =\n      decltype(make_filter_range(std::declval<iterator_range>(), isCompileUnit));\n\n  DWARFUnit *getUnitForOffset(uint64_t Offset) const;\n  DWARFUnit *getUnitForIndexEntry(const DWARFUnitIndex::Entry &E);\n\n  /// Read units from a .debug_info or .debug_types section.  Calls made\n  /// before finishedInfoUnits() are assumed to be for .debug_info sections,\n  /// calls after finishedInfoUnits() are for .debug_types sections.  Caller\n  /// must not mix calls to addUnitsForSection and addUnitsForDWOSection.\n  void addUnitsForSection(DWARFContext &C, const DWARFSection &Section,\n                          DWARFSectionKind SectionKind);\n  /// Read units from a .debug_info.dwo or .debug_types.dwo section.  Calls\n  /// made before finishedInfoUnits() are assumed to be for .debug_info.dwo\n  /// sections, calls after finishedInfoUnits() are for .debug_types.dwo\n  /// sections.  Caller must not mix calls to addUnitsForSection and\n  /// addUnitsForDWOSection.\n  void addUnitsForDWOSection(DWARFContext &C, const DWARFSection &DWOSection,\n                             DWARFSectionKind SectionKind, bool Lazy = false);\n\n  /// Add an existing DWARFUnit to this UnitVector. This is used by the DWARF\n  /// verifier to process unit separately.\n  DWARFUnit *addUnit(std::unique_ptr<DWARFUnit> Unit);\n\n  /// Returns number of all units held by this instance.\n  unsigned getNumUnits() const { return size(); }\n  /// Returns number of units from all .debug_info[.dwo] sections.\n  unsigned getNumInfoUnits() const {\n    return NumInfoUnits == -1 ? size() : NumInfoUnits;\n  }\n  /// Returns number of units from all .debug_types[.dwo] sections.\n  unsigned getNumTypesUnits() const { return size() - NumInfoUnits; }\n  /// Indicate that parsing .debug_info[.dwo] is done, and remaining units\n  /// will be from .debug_types[.dwo].\n  void finishedInfoUnits() { NumInfoUnits = size(); }\n\nprivate:\n  void addUnitsImpl(DWARFContext &Context, const DWARFObject &Obj,\n                    const DWARFSection &Section, const DWARFDebugAbbrev *DA,\n                    const DWARFSection *RS, const DWARFSection *LocSection,\n                    StringRef SS, const DWARFSection &SOS,\n                    const DWARFSection *AOS, const DWARFSection &LS, bool LE,\n                    bool IsDWO, bool Lazy, DWARFSectionKind SectionKind);\n};\n\n/// Represents base address of the CU.\n/// Represents a unit's contribution to the string offsets table.\nstruct StrOffsetsContributionDescriptor {\n  uint64_t Base = 0;\n  /// The contribution size not including the header.\n  uint64_t Size = 0;\n  /// Format and version.\n  dwarf::FormParams FormParams = {0, 0, dwarf::DwarfFormat::DWARF32};\n\n  StrOffsetsContributionDescriptor(uint64_t Base, uint64_t Size,\n                                   uint8_t Version, dwarf::DwarfFormat Format)\n      : Base(Base), Size(Size), FormParams({Version, 0, Format}) {}\n  StrOffsetsContributionDescriptor() = default;\n\n  uint8_t getVersion() const { return FormParams.Version; }\n  dwarf::DwarfFormat getFormat() const { return FormParams.Format; }\n  uint8_t getDwarfOffsetByteSize() const {\n    return FormParams.getDwarfOffsetByteSize();\n  }\n  /// Determine whether a contribution to the string offsets table is\n  /// consistent with the relevant section size and that its length is\n  /// a multiple of the size of one of its entries.\n  Expected<StrOffsetsContributionDescriptor>\n  validateContributionSize(DWARFDataExtractor &DA);\n};\n\nclass DWARFUnit {\n  DWARFContext &Context;\n  /// Section containing this DWARFUnit.\n  const DWARFSection &InfoSection;\n\n  DWARFUnitHeader Header;\n  const DWARFDebugAbbrev *Abbrev;\n  const DWARFSection *RangeSection;\n  uint64_t RangeSectionBase;\n  uint64_t LocSectionBase;\n\n  /// Location table of this unit.\n  std::unique_ptr<DWARFLocationTable> LocTable;\n\n  const DWARFSection &LineSection;\n  StringRef StringSection;\n  const DWARFSection &StringOffsetSection;\n  const DWARFSection *AddrOffsetSection;\n  Optional<uint64_t> AddrOffsetSectionBase;\n  bool isLittleEndian;\n  bool IsDWO;\n  const DWARFUnitVector &UnitVector;\n\n  /// Start, length, and DWARF format of the unit's contribution to the string\n  /// offsets table (DWARF v5).\n  Optional<StrOffsetsContributionDescriptor> StringOffsetsTableContribution;\n\n  mutable const DWARFAbbreviationDeclarationSet *Abbrevs;\n  llvm::Optional<object::SectionedAddress> BaseAddr;\n  /// The compile unit debug information entry items.\n  std::vector<DWARFDebugInfoEntry> DieArray;\n\n  /// Map from range's start address to end address and corresponding DIE.\n  /// IntervalMap does not support range removal, as a result, we use the\n  /// std::map::upper_bound for address range lookup.\n  std::map<uint64_t, std::pair<uint64_t, DWARFDie>> AddrDieMap;\n\n  using die_iterator_range =\n      iterator_range<std::vector<DWARFDebugInfoEntry>::iterator>;\n\n  std::shared_ptr<DWARFUnit> DWO;\n\n  uint32_t getDIEIndex(const DWARFDebugInfoEntry *Die) {\n    auto First = DieArray.data();\n    assert(Die >= First && Die < First + DieArray.size());\n    return Die - First;\n  }\n\nprotected:\n  const DWARFUnitHeader &getHeader() const { return Header; }\n\n  /// Size in bytes of the parsed unit header.\n  uint32_t getHeaderSize() const { return Header.getSize(); }\n\n  /// Find the unit's contribution to the string offsets table and determine its\n  /// length and form. The given offset is expected to be derived from the unit\n  /// DIE's DW_AT_str_offsets_base attribute.\n  Expected<Optional<StrOffsetsContributionDescriptor>>\n  determineStringOffsetsTableContribution(DWARFDataExtractor &DA);\n\n  /// Find the unit's contribution to the string offsets table and determine its\n  /// length and form. The given offset is expected to be 0 in a dwo file or,\n  /// in a dwp file, the start of the unit's contribution to the string offsets\n  /// table section (as determined by the index table).\n  Expected<Optional<StrOffsetsContributionDescriptor>>\n  determineStringOffsetsTableContributionDWO(DWARFDataExtractor &DA);\n\npublic:\n  DWARFUnit(DWARFContext &Context, const DWARFSection &Section,\n            const DWARFUnitHeader &Header, const DWARFDebugAbbrev *DA,\n            const DWARFSection *RS, const DWARFSection *LocSection,\n            StringRef SS, const DWARFSection &SOS, const DWARFSection *AOS,\n            const DWARFSection &LS, bool LE, bool IsDWO,\n            const DWARFUnitVector &UnitVector);\n\n  virtual ~DWARFUnit();\n\n  bool isDWOUnit() const { return IsDWO; }\n  DWARFContext& getContext() const { return Context; }\n  const DWARFSection &getInfoSection() const { return InfoSection; }\n  uint64_t getOffset() const { return Header.getOffset(); }\n  const dwarf::FormParams &getFormParams() const {\n    return Header.getFormParams();\n  }\n  uint16_t getVersion() const { return Header.getVersion(); }\n  uint8_t getAddressByteSize() const { return Header.getAddressByteSize(); }\n  uint8_t getRefAddrByteSize() const { return Header.getRefAddrByteSize(); }\n  uint8_t getDwarfOffsetByteSize() const {\n    return Header.getDwarfOffsetByteSize();\n  }\n  uint64_t getLength() const { return Header.getLength(); }\n  dwarf::DwarfFormat getFormat() const { return Header.getFormat(); }\n  uint8_t getUnitType() const { return Header.getUnitType(); }\n  bool isTypeUnit() const { return Header.isTypeUnit(); }\n  uint64_t getAbbrOffset() const { return Header.getAbbrOffset(); }\n  uint64_t getNextUnitOffset() const { return Header.getNextUnitOffset(); }\n  const DWARFSection &getLineSection() const { return LineSection; }\n  StringRef getStringSection() const { return StringSection; }\n  const DWARFSection &getStringOffsetSection() const {\n    return StringOffsetSection;\n  }\n\n  void setAddrOffsetSection(const DWARFSection *AOS, uint64_t Base) {\n    AddrOffsetSection = AOS;\n    AddrOffsetSectionBase = Base;\n  }\n\n  Optional<uint64_t> getAddrOffsetSectionBase() const {\n    return AddrOffsetSectionBase;\n  }\n\n  /// Recursively update address to Die map.\n  void updateAddressDieMap(DWARFDie Die);\n\n  void setRangesSection(const DWARFSection *RS, uint64_t Base) {\n    RangeSection = RS;\n    RangeSectionBase = Base;\n  }\n\n  uint64_t getLocSectionBase() const {\n    return LocSectionBase;\n  }\n\n  Optional<object::SectionedAddress>\n  getAddrOffsetSectionItem(uint32_t Index) const;\n  Optional<uint64_t> getStringOffsetSectionItem(uint32_t Index) const;\n\n  DWARFDataExtractor getDebugInfoExtractor() const;\n\n  DataExtractor getStringExtractor() const {\n    return DataExtractor(StringSection, false, 0);\n  }\n\n  const DWARFLocationTable &getLocationTable() { return *LocTable; }\n\n  /// Extract the range list referenced by this compile unit from the\n  /// .debug_ranges section. If the extraction is unsuccessful, an error\n  /// is returned. Successful extraction requires that the compile unit\n  /// has already been extracted.\n  Error extractRangeList(uint64_t RangeListOffset,\n                         DWARFDebugRangeList &RangeList) const;\n  void clear();\n\n  const Optional<StrOffsetsContributionDescriptor> &\n  getStringOffsetsTableContribution() const {\n    return StringOffsetsTableContribution;\n  }\n\n  uint8_t getDwarfStringOffsetsByteSize() const {\n    assert(StringOffsetsTableContribution);\n    return StringOffsetsTableContribution->getDwarfOffsetByteSize();\n  }\n\n  uint64_t getStringOffsetsBase() const {\n    assert(StringOffsetsTableContribution);\n    return StringOffsetsTableContribution->Base;\n  }\n\n  const DWARFAbbreviationDeclarationSet *getAbbreviations() const;\n\n  static bool isMatchingUnitTypeAndTag(uint8_t UnitType, dwarf::Tag Tag) {\n    switch (UnitType) {\n    case dwarf::DW_UT_compile:\n      return Tag == dwarf::DW_TAG_compile_unit;\n    case dwarf::DW_UT_type:\n      return Tag == dwarf::DW_TAG_type_unit;\n    case dwarf::DW_UT_partial:\n      return Tag == dwarf::DW_TAG_partial_unit;\n    case dwarf::DW_UT_skeleton:\n      return Tag == dwarf::DW_TAG_skeleton_unit;\n    case dwarf::DW_UT_split_compile:\n    case dwarf::DW_UT_split_type:\n      return dwarf::isUnitType(Tag);\n    }\n    return false;\n  }\n\n  llvm::Optional<object::SectionedAddress> getBaseAddress();\n\n  DWARFDie getUnitDIE(bool ExtractUnitDIEOnly = true) {\n    extractDIEsIfNeeded(ExtractUnitDIEOnly);\n    if (DieArray.empty())\n      return DWARFDie();\n    return DWARFDie(this, &DieArray[0]);\n  }\n\n  DWARFDie getNonSkeletonUnitDIE(bool ExtractUnitDIEOnly = true) {\n    parseDWO();\n    if (DWO)\n      return DWO->getUnitDIE(ExtractUnitDIEOnly);\n    return getUnitDIE(ExtractUnitDIEOnly);\n  }\n\n  const char *getCompilationDir();\n  Optional<uint64_t> getDWOId() {\n    extractDIEsIfNeeded(/*CUDieOnly*/ true);\n    return getHeader().getDWOId();\n  }\n  void setDWOId(uint64_t NewID) { Header.setDWOId(NewID); }\n\n  /// Return a vector of address ranges resulting from a (possibly encoded)\n  /// range list starting at a given offset in the appropriate ranges section.\n  Expected<DWARFAddressRangesVector> findRnglistFromOffset(uint64_t Offset);\n\n  /// Return a vector of address ranges retrieved from an encoded range\n  /// list whose offset is found via a table lookup given an index (DWARF v5\n  /// and later).\n  Expected<DWARFAddressRangesVector> findRnglistFromIndex(uint32_t Index);\n\n  /// Return a rangelist's offset based on an index. The index designates\n  /// an entry in the rangelist table's offset array and is supplied by\n  /// DW_FORM_rnglistx.\n  Optional<uint64_t> getRnglistOffset(uint32_t Index);\n\n  Optional<uint64_t> getLoclistOffset(uint32_t Index);\n\n  Expected<DWARFAddressRangesVector> collectAddressRanges();\n\n  Expected<DWARFLocationExpressionsVector>\n  findLoclistFromOffset(uint64_t Offset);\n\n  /// Returns subprogram DIE with address range encompassing the provided\n  /// address. The pointer is alive as long as parsed compile unit DIEs are not\n  /// cleared.\n  DWARFDie getSubroutineForAddress(uint64_t Address);\n\n  /// getInlinedChainForAddress - fetches inlined chain for a given address.\n  /// Returns empty chain if there is no subprogram containing address. The\n  /// chain is valid as long as parsed compile unit DIEs are not cleared.\n  void getInlinedChainForAddress(uint64_t Address,\n                                 SmallVectorImpl<DWARFDie> &InlinedChain);\n\n  /// Return the DWARFUnitVector containing this unit.\n  const DWARFUnitVector &getUnitVector() const { return UnitVector; }\n\n  /// Returns the number of DIEs in the unit. Parses the unit\n  /// if necessary.\n  unsigned getNumDIEs() {\n    extractDIEsIfNeeded(false);\n    return DieArray.size();\n  }\n\n  /// Return the index of a DIE inside the unit's DIE vector.\n  ///\n  /// It is illegal to call this method with a DIE that hasn't be\n  /// created by this unit. In other word, it's illegal to call this\n  /// method on a DIE that isn't accessible by following\n  /// children/sibling links starting from this unit's getUnitDIE().\n  uint32_t getDIEIndex(const DWARFDie &D) {\n    return getDIEIndex(D.getDebugInfoEntry());\n  }\n\n  /// Return the DIE object at the given index.\n  DWARFDie getDIEAtIndex(unsigned Index) {\n    assert(Index < DieArray.size());\n    return DWARFDie(this, &DieArray[Index]);\n  }\n\n  DWARFDie getParent(const DWARFDebugInfoEntry *Die);\n  DWARFDie getSibling(const DWARFDebugInfoEntry *Die);\n  DWARFDie getPreviousSibling(const DWARFDebugInfoEntry *Die);\n  DWARFDie getFirstChild(const DWARFDebugInfoEntry *Die);\n  DWARFDie getLastChild(const DWARFDebugInfoEntry *Die);\n\n  /// Return the DIE object for a given offset inside the\n  /// unit's DIE vector.\n  ///\n  /// The unit needs to have its DIEs extracted for this method to work.\n  DWARFDie getDIEForOffset(uint64_t Offset) {\n    extractDIEsIfNeeded(false);\n    auto It =\n        llvm::partition_point(DieArray, [=](const DWARFDebugInfoEntry &DIE) {\n          return DIE.getOffset() < Offset;\n        });\n    if (It != DieArray.end() && It->getOffset() == Offset)\n      return DWARFDie(this, &*It);\n    return DWARFDie();\n  }\n\n  uint32_t getLineTableOffset() const {\n    if (auto IndexEntry = Header.getIndexEntry())\n      if (const auto *Contrib = IndexEntry->getContribution(DW_SECT_LINE))\n        return Contrib->Offset;\n    return 0;\n  }\n\n  die_iterator_range dies() {\n    extractDIEsIfNeeded(false);\n    return die_iterator_range(DieArray.begin(), DieArray.end());\n  }\n\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts) = 0;\n\n  Error tryExtractDIEsIfNeeded(bool CUDieOnly);\n\nprivate:\n  /// Size in bytes of the .debug_info data associated with this compile unit.\n  size_t getDebugInfoSize() const {\n    return Header.getLength() + Header.getUnitLengthFieldByteSize() -\n           getHeaderSize();\n  }\n\n  /// extractDIEsIfNeeded - Parses a compile unit and indexes its DIEs if it\n  /// hasn't already been done\n  void extractDIEsIfNeeded(bool CUDieOnly);\n\n  /// extractDIEsToVector - Appends all parsed DIEs to a vector.\n  void extractDIEsToVector(bool AppendCUDie, bool AppendNonCUDIEs,\n                           std::vector<DWARFDebugInfoEntry> &DIEs) const;\n\n  /// clearDIEs - Clear parsed DIEs to keep memory usage low.\n  void clearDIEs(bool KeepCUDie);\n\n  /// parseDWO - Parses .dwo file for current compile unit. Returns true if\n  /// it was actually constructed.\n  bool parseDWO();\n};\n\ninline bool isCompileUnit(const std::unique_ptr<DWARFUnit> &U) {\n  return !U->isTypeUnit();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Archive.h", "content": "//===- Archive.h - ar archive file format -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ar archive file format class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ARCHIVE_H\n#define LLVM_OBJECT_ARCHIVE_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/fallible_iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace llvm {\nnamespace object {\n\nclass Archive;\n\nclass ArchiveMemberHeader {\npublic:\n  friend class Archive;\n\n  ArchiveMemberHeader(Archive const *Parent, const char *RawHeaderPtr,\n                      uint64_t Size, Error *Err);\n  // ArchiveMemberHeader() = default;\n\n  /// Get the name without looking up long names.\n  Expected<StringRef> getRawName() const;\n\n  /// Get the name looking up long names.\n  Expected<StringRef> getName(uint64_t Size) const;\n\n  Expected<uint64_t> getSize() const;\n\n  Expected<sys::fs::perms> getAccessMode() const;\n  Expected<sys::TimePoint<std::chrono::seconds>> getLastModified() const;\n\n  StringRef getRawLastModified() const {\n    return StringRef(ArMemHdr->LastModified,\n                     sizeof(ArMemHdr->LastModified)).rtrim(' ');\n  }\n\n  Expected<unsigned> getUID() const;\n  Expected<unsigned> getGID() const;\n\n  // This returns the size of the private struct ArMemHdrType\n  uint64_t getSizeOf() const {\n    return sizeof(ArMemHdrType);\n  }\n\nprivate:\n  struct ArMemHdrType {\n    char Name[16];\n    char LastModified[12];\n    char UID[6];\n    char GID[6];\n    char AccessMode[8];\n    char Size[10]; ///< Size of data, not including header or padding.\n    char Terminator[2];\n  };\n  Archive const *Parent;\n  ArMemHdrType const *ArMemHdr;\n};\n\nclass Archive : public Binary {\n  virtual void anchor();\n\npublic:\n  class Child {\n    friend Archive;\n    friend ArchiveMemberHeader;\n\n    const Archive *Parent;\n    ArchiveMemberHeader Header;\n    /// Includes header but not padding byte.\n    StringRef Data;\n    /// Offset from Data to the start of the file.\n    uint16_t StartOfFile;\n\n    Expected<bool> isThinMember() const;\n\n  public:\n    Child(const Archive *Parent, const char *Start, Error *Err);\n    Child(const Archive *Parent, StringRef Data, uint16_t StartOfFile);\n\n    bool operator ==(const Child &other) const {\n      assert(!Parent || !other.Parent || Parent == other.Parent);\n      return Data.begin() == other.Data.begin();\n    }\n\n    const Archive *getParent() const { return Parent; }\n    Expected<Child> getNext() const;\n\n    Expected<StringRef> getName() const;\n    Expected<std::string> getFullName() const;\n    Expected<StringRef> getRawName() const { return Header.getRawName(); }\n\n    Expected<sys::TimePoint<std::chrono::seconds>> getLastModified() const {\n      return Header.getLastModified();\n    }\n\n    StringRef getRawLastModified() const {\n      return Header.getRawLastModified();\n    }\n\n    Expected<unsigned> getUID() const { return Header.getUID(); }\n    Expected<unsigned> getGID() const { return Header.getGID(); }\n\n    Expected<sys::fs::perms> getAccessMode() const {\n      return Header.getAccessMode();\n    }\n\n    /// \\return the size of the archive member without the header or padding.\n    Expected<uint64_t> getSize() const;\n    /// \\return the size in the archive header for this member.\n    Expected<uint64_t> getRawSize() const;\n\n    Expected<StringRef> getBuffer() const;\n    uint64_t getChildOffset() const;\n    uint64_t getDataOffset() const { return getChildOffset() + StartOfFile; }\n\n    Expected<MemoryBufferRef> getMemoryBufferRef() const;\n\n    Expected<std::unique_ptr<Binary>>\n    getAsBinary(LLVMContext *Context = nullptr) const;\n  };\n\n  class ChildFallibleIterator {\n    Child C;\n\n  public:\n    ChildFallibleIterator() : C(Child(nullptr, nullptr, nullptr)) {}\n    ChildFallibleIterator(const Child &C) : C(C) {}\n\n    const Child *operator->() const { return &C; }\n    const Child &operator*() const { return C; }\n\n    bool operator==(const ChildFallibleIterator &other) const {\n      // Ignore errors here: If an error occurred during increment then getNext\n      // will have been set to child_end(), and the following comparison should\n      // do the right thing.\n      return C == other.C;\n    }\n\n    bool operator!=(const ChildFallibleIterator &other) const {\n      return !(*this == other);\n    }\n\n    Error inc() {\n      auto NextChild = C.getNext();\n      if (!NextChild)\n        return NextChild.takeError();\n      C = std::move(*NextChild);\n      return Error::success();\n    }\n  };\n\n  using child_iterator = fallible_iterator<ChildFallibleIterator>;\n\n  class Symbol {\n    const Archive *Parent;\n    uint32_t SymbolIndex;\n    uint32_t StringIndex; // Extra index to the string.\n\n  public:\n    Symbol(const Archive *p, uint32_t symi, uint32_t stri)\n      : Parent(p)\n      , SymbolIndex(symi)\n      , StringIndex(stri) {}\n\n    bool operator ==(const Symbol &other) const {\n      return (Parent == other.Parent) && (SymbolIndex == other.SymbolIndex);\n    }\n\n    StringRef getName() const;\n    Expected<Child> getMember() const;\n    Symbol getNext() const;\n  };\n\n  class symbol_iterator {\n    Symbol symbol;\n\n  public:\n    symbol_iterator(const Symbol &s) : symbol(s) {}\n\n    const Symbol *operator->() const { return &symbol; }\n    const Symbol &operator*() const { return symbol; }\n\n    bool operator==(const symbol_iterator &other) const {\n      return symbol == other.symbol;\n    }\n\n    bool operator!=(const symbol_iterator &other) const {\n      return !(*this == other);\n    }\n\n    symbol_iterator& operator++() {  // Preincrement\n      symbol = symbol.getNext();\n      return *this;\n    }\n  };\n\n  Archive(MemoryBufferRef Source, Error &Err);\n  static Expected<std::unique_ptr<Archive>> create(MemoryBufferRef Source);\n\n  /// Size field is 10 decimal digits long\n  static const uint64_t MaxMemberSize = 9999999999;\n\n  enum Kind {\n    K_GNU,\n    K_GNU64,\n    K_BSD,\n    K_DARWIN,\n    K_DARWIN64,\n    K_COFF\n  };\n\n  Kind kind() const { return (Kind)Format; }\n  bool isThin() const { return IsThin; }\n\n  child_iterator child_begin(Error &Err, bool SkipInternal = true) const;\n  child_iterator child_end() const;\n  iterator_range<child_iterator> children(Error &Err,\n                                          bool SkipInternal = true) const {\n    return make_range(child_begin(Err, SkipInternal), child_end());\n  }\n\n  symbol_iterator symbol_begin() const;\n  symbol_iterator symbol_end() const;\n  iterator_range<symbol_iterator> symbols() const {\n    return make_range(symbol_begin(), symbol_end());\n  }\n\n  // Cast methods.\n  static bool classof(Binary const *v) {\n    return v->isArchive();\n  }\n\n  // check if a symbol is in the archive\n  Expected<Optional<Child>> findSym(StringRef name) const;\n\n  bool isEmpty() const;\n  bool hasSymbolTable() const;\n  StringRef getSymbolTable() const { return SymbolTable; }\n  StringRef getStringTable() const { return StringTable; }\n  uint32_t getNumberOfSymbols() const;\n\n  std::vector<std::unique_ptr<MemoryBuffer>> takeThinBuffers() {\n    return std::move(ThinBuffers);\n  }\n\nprivate:\n  StringRef SymbolTable;\n  StringRef StringTable;\n\n  StringRef FirstRegularData;\n  uint16_t FirstRegularStartOfFile = -1;\n  void setFirstRegular(const Child &C);\n\n  unsigned Format : 3;\n  unsigned IsThin : 1;\n  mutable std::vector<std::unique_ptr<MemoryBuffer>> ThinBuffers;\n};\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_ARCHIVE_H\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "content": "//===- MachO.h - MachO object file implementation ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the MachOObjectFile class, which implement the ObjectFile\n// interface for MachO files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_MACHO_H\n#define LLVM_OBJECT_MACHO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/MachO.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\n/// DiceRef - This is a value type class that represents a single\n/// data in code entry in the table in a Mach-O object file.\nclass DiceRef {\n  DataRefImpl DicePimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  DiceRef() = default;\n  DiceRef(DataRefImpl DiceP, const ObjectFile *Owner);\n\n  bool operator==(const DiceRef &Other) const;\n  bool operator<(const DiceRef &Other) const;\n\n  void moveNext();\n\n  std::error_code getOffset(uint32_t &Result) const;\n  std::error_code getLength(uint16_t &Result) const;\n  std::error_code getKind(uint16_t &Result) const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObjectFile() const;\n};\nusing dice_iterator = content_iterator<DiceRef>;\n\n/// ExportEntry encapsulates the current-state-of-the-walk used when doing a\n/// non-recursive walk of the trie data structure.  This allows you to iterate\n/// across all exported symbols using:\n///      Error Err = Error::success();\n///      for (const llvm::object::ExportEntry &AnExport : Obj->exports(&Err)) {\n///      }\n///      if (Err) { report error ...\nclass ExportEntry {\npublic:\n  ExportEntry(Error *Err, const MachOObjectFile *O, ArrayRef<uint8_t> Trie);\n\n  StringRef name() const;\n  uint64_t flags() const;\n  uint64_t address() const;\n  uint64_t other() const;\n  StringRef otherName() const;\n  uint32_t nodeOffset() const;\n\n  bool operator==(const ExportEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const uint8_t *&p, const char **error);\n  void pushDownUntilBottom();\n  void pushNode(uint64_t Offset);\n\n  // Represents a node in the mach-o exports trie.\n  struct NodeState {\n    NodeState(const uint8_t *Ptr);\n\n    const uint8_t *Start;\n    const uint8_t *Current;\n    uint64_t Flags = 0;\n    uint64_t Address = 0;\n    uint64_t Other = 0;\n    const char *ImportName = nullptr;\n    unsigned ChildCount = 0;\n    unsigned NextChildIndex = 0;\n    unsigned ParentStringLength = 0;\n    bool IsExportNode = false;\n  };\n  using NodeList = SmallVector<NodeState, 16>;\n  using node_iterator = NodeList::const_iterator;\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Trie;\n  SmallString<256> CumulativeString;\n  NodeList Stack;\n  bool Done = false;\n\n  iterator_range<node_iterator> nodes() const {\n    return make_range(Stack.begin(), Stack.end());\n  }\n};\nusing export_iterator = content_iterator<ExportEntry>;\n\n// Segment info so SegIndex/SegOffset pairs in a Mach-O Bind or Rebase entry\n// can be checked and translated.  Only the SegIndex/SegOffset pairs from\n// checked entries are to be used with the segmentName(), sectionName() and\n// address() methods below.\nclass BindRebaseSegInfo {\npublic:\n  BindRebaseSegInfo(const MachOObjectFile *Obj);\n\n  // Used to check a Mach-O Bind or Rebase entry for errors when iterating.\n  const char* checkSegAndOffsets(int32_t SegIndex, uint64_t SegOffset,\n                                 uint8_t PointerSize, uint32_t Count=1,\n                                 uint32_t Skip=0);\n  // Used with valid SegIndex/SegOffset values from checked entries.\n  StringRef segmentName(int32_t SegIndex);\n  StringRef sectionName(int32_t SegIndex, uint64_t SegOffset);\n  uint64_t address(uint32_t SegIndex, uint64_t SegOffset);\n\nprivate:\n  struct SectionInfo {\n    uint64_t Address;\n    uint64_t Size;\n    StringRef SectionName;\n    StringRef SegmentName;\n    uint64_t OffsetInSegment;\n    uint64_t SegmentStartAddress;\n    int32_t SegmentIndex;\n  };\n  const SectionInfo &findSection(int32_t SegIndex, uint64_t SegOffset);\n\n  SmallVector<SectionInfo, 32> Sections;\n  int32_t MaxSegIndex;\n};\n\n/// MachORebaseEntry encapsulates the current state in the decompression of\n/// rebasing opcodes. This allows you to iterate through the compressed table of\n/// rebasing using:\n///    Error Err = Error::success();\n///    for (const llvm::object::MachORebaseEntry &Entry : Obj->rebaseTable(&Err)) {\n///    }\n///    if (Err) { report error ...\nclass MachORebaseEntry {\npublic:\n  MachORebaseEntry(Error *Err, const MachOObjectFile *O,\n                   ArrayRef<uint8_t> opcodes, bool is64Bit);\n\n  int32_t segmentIndex() const;\n  uint64_t segmentOffset() const;\n  StringRef typeName() const;\n  StringRef segmentName() const;\n  StringRef sectionName() const;\n  uint64_t address() const;\n\n  bool operator==(const MachORebaseEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const char **error);\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Opcodes;\n  const uint8_t *Ptr;\n  uint64_t SegmentOffset = 0;\n  int32_t SegmentIndex = -1;\n  uint64_t RemainingLoopCount = 0;\n  uint64_t AdvanceAmount = 0;\n  uint8_t  RebaseType = 0;\n  uint8_t  PointerSize;\n  bool     Done = false;\n};\nusing rebase_iterator = content_iterator<MachORebaseEntry>;\n\n/// MachOBindEntry encapsulates the current state in the decompression of\n/// binding opcodes. This allows you to iterate through the compressed table of\n/// bindings using:\n///    Error Err = Error::success();\n///    for (const llvm::object::MachOBindEntry &Entry : Obj->bindTable(&Err)) {\n///    }\n///    if (Err) { report error ...\nclass MachOBindEntry {\npublic:\n  enum class Kind { Regular, Lazy, Weak };\n\n  MachOBindEntry(Error *Err, const MachOObjectFile *O,\n                 ArrayRef<uint8_t> Opcodes, bool is64Bit, MachOBindEntry::Kind);\n\n  int32_t segmentIndex() const;\n  uint64_t segmentOffset() const;\n  StringRef typeName() const;\n  StringRef symbolName() const;\n  uint32_t flags() const;\n  int64_t addend() const;\n  int ordinal() const;\n\n  StringRef segmentName() const;\n  StringRef sectionName() const;\n  uint64_t address() const;\n\n  bool operator==(const MachOBindEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const char **error);\n  int64_t readSLEB128(const char **error);\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Opcodes;\n  const uint8_t *Ptr;\n  uint64_t SegmentOffset = 0;\n  int32_t  SegmentIndex = -1;\n  StringRef SymbolName;\n  bool     LibraryOrdinalSet = false;\n  int      Ordinal = 0;\n  uint32_t Flags = 0;\n  int64_t  Addend = 0;\n  uint64_t RemainingLoopCount = 0;\n  uint64_t AdvanceAmount = 0;\n  uint8_t  BindType = 0;\n  uint8_t  PointerSize;\n  Kind     TableKind;\n  bool     Done = false;\n};\nusing bind_iterator = content_iterator<MachOBindEntry>;\n\nclass MachOObjectFile : public ObjectFile {\npublic:\n  struct LoadCommandInfo {\n    const char *Ptr;      // Where in memory the load command is.\n    MachO::load_command C; // The command itself.\n  };\n  using LoadCommandList = SmallVector<LoadCommandInfo, 4>;\n  using load_command_iterator = LoadCommandList::const_iterator;\n\n  static Expected<std::unique_ptr<MachOObjectFile>>\n  create(MemoryBufferRef Object, bool IsLittleEndian, bool Is64Bits,\n         uint32_t UniversalCputype = 0, uint32_t UniversalIndex = 0);\n\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n\n  uint64_t getNValue(DataRefImpl Sym) const;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n\n  // MachO specific.\n  Error checkSymbolTable() const;\n\n  std::error_code getIndirectName(DataRefImpl Symb, StringRef &Res) const;\n  unsigned getSectionType(SectionRef Sec) const;\n\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n  unsigned getSymbolSectionID(SymbolRef Symb) const;\n  unsigned getSectionID(SectionRef Sec) const;\n\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  ArrayRef<uint8_t> getSectionContents(uint32_t Offset, uint64_t Size) const;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  Expected<SectionRef> getSection(unsigned SectionIndex) const;\n  Expected<SectionRef> getSection(StringRef SectionName) const;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isSectionBitcode(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n\n  /// When dsymutil generates the companion file, it strips all unnecessary\n  /// sections (e.g. everything in the _TEXT segment) by omitting their body\n  /// and setting the offset in their corresponding load command to zero.\n  ///\n  /// While the load command itself is valid, reading the section corresponds\n  /// to reading the number of bytes specified in the load command, starting\n  /// from offset 0 (i.e. the Mach-O header at the beginning of the file).\n  bool isSectionStripped(DataRefImpl Sec) const override;\n\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n\n  relocation_iterator extrel_begin() const;\n  relocation_iterator extrel_end() const;\n  iterator_range<relocation_iterator> external_relocations() const {\n    return make_range(extrel_begin(), extrel_end());\n  }\n\n  relocation_iterator locrel_begin() const;\n  relocation_iterator locrel_end() const;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  section_iterator getRelocationSection(DataRefImpl Rel) const;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n  uint8_t getRelocationLength(DataRefImpl Rel) const;\n\n  // MachO specific.\n  std::error_code getLibraryShortNameByIndex(unsigned Index, StringRef &) const;\n  uint32_t getLibraryCount() const;\n\n  section_iterator getRelocationRelocatedSection(relocation_iterator Rel) const;\n\n  // TODO: Would be useful to have an iterator based version\n  // of the load command interface too.\n\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n\n  // MachO specific.\n  symbol_iterator getSymbolByIndex(unsigned Index) const;\n  uint64_t getSymbolIndex(DataRefImpl Symb) const;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  uint8_t getBytesInAddress() const override;\n\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  SubtargetFeatures getFeatures() const override { return SubtargetFeatures(); }\n  Triple getArchTriple(const char **McpuDefault = nullptr) const;\n\n  relocation_iterator section_rel_begin(unsigned Index) const;\n  relocation_iterator section_rel_end(unsigned Index) const;\n\n  dice_iterator begin_dices() const;\n  dice_iterator end_dices() const;\n\n  load_command_iterator begin_load_commands() const;\n  load_command_iterator end_load_commands() const;\n  iterator_range<load_command_iterator> load_commands() const;\n\n  /// For use iterating over all exported symbols.\n  iterator_range<export_iterator> exports(Error &Err) const;\n\n  /// For use examining a trie not in a MachOObjectFile.\n  static iterator_range<export_iterator> exports(Error &Err,\n                                                 ArrayRef<uint8_t> Trie,\n                                                 const MachOObjectFile *O =\n                                                                      nullptr);\n\n  /// For use iterating over all rebase table entries.\n  iterator_range<rebase_iterator> rebaseTable(Error &Err);\n\n  /// For use examining rebase opcodes in a MachOObjectFile.\n  static iterator_range<rebase_iterator> rebaseTable(Error &Err,\n                                                     MachOObjectFile *O,\n                                                     ArrayRef<uint8_t> Opcodes,\n                                                     bool is64);\n\n  /// For use iterating over all bind table entries.\n  iterator_range<bind_iterator> bindTable(Error &Err);\n\n  /// For use iterating over all lazy bind table entries.\n  iterator_range<bind_iterator> lazyBindTable(Error &Err);\n\n  /// For use iterating over all weak bind table entries.\n  iterator_range<bind_iterator> weakBindTable(Error &Err);\n\n  /// For use examining bind opcodes in a MachOObjectFile.\n  static iterator_range<bind_iterator> bindTable(Error &Err,\n                                                 MachOObjectFile *O,\n                                                 ArrayRef<uint8_t> Opcodes,\n                                                 bool is64,\n                                                 MachOBindEntry::Kind);\n\n  // Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n  // that fully contains a pointer at that location. Multiple fixups in a bind\n  // (such as with the BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB opcode) can\n  // be tested via the Count and Skip parameters.\n  //\n  // This is used by MachOBindEntry::moveNext() to validate a MachOBindEntry.\n  const char *BindEntryCheckSegAndOffsets(int32_t SegIndex, uint64_t SegOffset,\n                                         uint8_t PointerSize, uint32_t Count=1,\n                                          uint32_t Skip=0) const {\n    return BindRebaseSectionTable->checkSegAndOffsets(SegIndex, SegOffset,\n                                                     PointerSize, Count, Skip);\n  }\n\n  // Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n  // that fully contains a pointer at that location. Multiple fixups in a rebase\n  // (such as with the REBASE_OPCODE_DO_*_TIMES* opcodes) can be tested via the\n  // Count and Skip parameters.\n  //\n  // This is used by MachORebaseEntry::moveNext() to validate a MachORebaseEntry\n  const char *RebaseEntryCheckSegAndOffsets(int32_t SegIndex,\n                                            uint64_t SegOffset,\n                                            uint8_t PointerSize,\n                                            uint32_t Count=1,\n                                            uint32_t Skip=0) const {\n    return BindRebaseSectionTable->checkSegAndOffsets(SegIndex, SegOffset,\n                                                      PointerSize, Count, Skip);\n  }\n\n  /// For use with the SegIndex of a checked Mach-O Bind or Rebase entry to\n  /// get the segment name.\n  StringRef BindRebaseSegmentName(int32_t SegIndex) const {\n    return BindRebaseSectionTable->segmentName(SegIndex);\n  }\n\n  /// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or\n  /// Rebase entry to get the section name.\n  StringRef BindRebaseSectionName(uint32_t SegIndex, uint64_t SegOffset) const {\n    return BindRebaseSectionTable->sectionName(SegIndex, SegOffset);\n  }\n\n  /// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or\n  /// Rebase entry to get the address.\n  uint64_t BindRebaseAddress(uint32_t SegIndex, uint64_t SegOffset) const {\n    return BindRebaseSectionTable->address(SegIndex, SegOffset);\n  }\n\n  // In a MachO file, sections have a segment name. This is used in the .o\n  // files. They have a single segment, but this field specifies which segment\n  // a section should be put in the final object.\n  StringRef getSectionFinalSegmentName(DataRefImpl Sec) const;\n\n  // Names are stored as 16 bytes. These returns the raw 16 bytes without\n  // interpreting them as a C string.\n  ArrayRef<char> getSectionRawName(DataRefImpl Sec) const;\n  ArrayRef<char> getSectionRawFinalSegmentName(DataRefImpl Sec) const;\n\n  // MachO specific Info about relocations.\n  bool isRelocationScattered(const MachO::any_relocation_info &RE) const;\n  unsigned getPlainRelocationSymbolNum(\n                                    const MachO::any_relocation_info &RE) const;\n  bool getPlainRelocationExternal(const MachO::any_relocation_info &RE) const;\n  bool getScatteredRelocationScattered(\n                                    const MachO::any_relocation_info &RE) const;\n  uint32_t getScatteredRelocationValue(\n                                    const MachO::any_relocation_info &RE) const;\n  uint32_t getScatteredRelocationType(\n                                    const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationAddress(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationPCRel(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationLength(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationType(const MachO::any_relocation_info &RE) const;\n  SectionRef getAnyRelocationSection(const MachO::any_relocation_info &RE) const;\n\n  // MachO specific structures.\n  MachO::section getSection(DataRefImpl DRI) const;\n  MachO::section_64 getSection64(DataRefImpl DRI) const;\n  MachO::section getSection(const LoadCommandInfo &L, unsigned Index) const;\n  MachO::section_64 getSection64(const LoadCommandInfo &L,unsigned Index) const;\n  MachO::nlist getSymbolTableEntry(DataRefImpl DRI) const;\n  MachO::nlist_64 getSymbol64TableEntry(DataRefImpl DRI) const;\n\n  MachO::linkedit_data_command\n  getLinkeditDataLoadCommand(const LoadCommandInfo &L) const;\n  MachO::segment_command\n  getSegmentLoadCommand(const LoadCommandInfo &L) const;\n  MachO::segment_command_64\n  getSegment64LoadCommand(const LoadCommandInfo &L) const;\n  MachO::linker_option_command\n  getLinkerOptionLoadCommand(const LoadCommandInfo &L) const;\n  MachO::version_min_command\n  getVersionMinLoadCommand(const LoadCommandInfo &L) const;\n  MachO::note_command\n  getNoteLoadCommand(const LoadCommandInfo &L) const;\n  MachO::build_version_command\n  getBuildVersionLoadCommand(const LoadCommandInfo &L) const;\n  MachO::build_tool_version\n  getBuildToolVersion(unsigned index) const;\n  MachO::dylib_command\n  getDylibIDLoadCommand(const LoadCommandInfo &L) const;\n  MachO::dyld_info_command\n  getDyldInfoLoadCommand(const LoadCommandInfo &L) const;\n  MachO::dylinker_command\n  getDylinkerCommand(const LoadCommandInfo &L) const;\n  MachO::uuid_command\n  getUuidCommand(const LoadCommandInfo &L) const;\n  MachO::rpath_command\n  getRpathCommand(const LoadCommandInfo &L) const;\n  MachO::source_version_command\n  getSourceVersionCommand(const LoadCommandInfo &L) const;\n  MachO::entry_point_command\n  getEntryPointCommand(const LoadCommandInfo &L) const;\n  MachO::encryption_info_command\n  getEncryptionInfoCommand(const LoadCommandInfo &L) const;\n  MachO::encryption_info_command_64\n  getEncryptionInfoCommand64(const LoadCommandInfo &L) const;\n  MachO::sub_framework_command\n  getSubFrameworkCommand(const LoadCommandInfo &L) const;\n  MachO::sub_umbrella_command\n  getSubUmbrellaCommand(const LoadCommandInfo &L) const;\n  MachO::sub_library_command\n  getSubLibraryCommand(const LoadCommandInfo &L) const;\n  MachO::sub_client_command\n  getSubClientCommand(const LoadCommandInfo &L) const;\n  MachO::routines_command\n  getRoutinesCommand(const LoadCommandInfo &L) const;\n  MachO::routines_command_64\n  getRoutinesCommand64(const LoadCommandInfo &L) const;\n  MachO::thread_command\n  getThreadCommand(const LoadCommandInfo &L) const;\n\n  MachO::any_relocation_info getRelocation(DataRefImpl Rel) const;\n  MachO::data_in_code_entry getDice(DataRefImpl Rel) const;\n  const MachO::mach_header &getHeader() const;\n  const MachO::mach_header_64 &getHeader64() const;\n  uint32_t\n  getIndirectSymbolTableEntry(const MachO::dysymtab_command &DLC,\n                              unsigned Index) const;\n  MachO::data_in_code_entry getDataInCodeTableEntry(uint32_t DataOffset,\n                                                    unsigned Index) const;\n  MachO::symtab_command getSymtabLoadCommand() const;\n  MachO::dysymtab_command getDysymtabLoadCommand() const;\n  MachO::linkedit_data_command getDataInCodeLoadCommand() const;\n  MachO::linkedit_data_command getLinkOptHintsLoadCommand() const;\n  ArrayRef<uint8_t> getDyldInfoRebaseOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoWeakBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoLazyBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoExportsTrie() const;\n  ArrayRef<uint8_t> getUuid() const;\n\n  StringRef getStringTableData() const;\n  bool is64Bit() const;\n  void ReadULEB128s(uint64_t Index, SmallVectorImpl<uint64_t> &Out) const;\n\n  static StringRef guessLibraryShortName(StringRef Name, bool &isFramework,\n                                         StringRef &Suffix);\n\n  static Triple::ArchType getArch(uint32_t CPUType, uint32_t CPUSubType);\n  static Triple getArchTriple(uint32_t CPUType, uint32_t CPUSubType,\n                              const char **McpuDefault = nullptr,\n                              const char **ArchFlag = nullptr);\n  static bool isValidArch(StringRef ArchFlag);\n  static ArrayRef<StringRef> getValidArchs();\n  static Triple getHostArch();\n\n  bool isRelocatableObject() const override;\n\n  StringRef mapDebugSectionName(StringRef Name) const override;\n\n  bool hasPageZeroSegment() const { return HasPageZeroSegment; }\n\n  static bool classof(const Binary *v) {\n    return v->isMachO();\n  }\n\n  static uint32_t\n  getVersionMinMajor(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return (VersionOrSDK >> 16) & 0xffff;\n  }\n\n  static uint32_t\n  getVersionMinMinor(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return (VersionOrSDK >> 8) & 0xff;\n  }\n\n  static uint32_t\n  getVersionMinUpdate(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return VersionOrSDK & 0xff;\n  }\n\n  static std::string getBuildPlatform(uint32_t platform) {\n    switch (platform) {\n    case MachO::PLATFORM_MACOS: return \"macos\";\n    case MachO::PLATFORM_IOS: return \"ios\";\n    case MachO::PLATFORM_TVOS: return \"tvos\";\n    case MachO::PLATFORM_WATCHOS: return \"watchos\";\n    case MachO::PLATFORM_BRIDGEOS: return \"bridgeos\";\n    case MachO::PLATFORM_MACCATALYST: return \"macCatalyst\";\n    case MachO::PLATFORM_IOSSIMULATOR: return \"iossimulator\";\n    case MachO::PLATFORM_TVOSSIMULATOR: return \"tvossimulator\";\n    case MachO::PLATFORM_WATCHOSSIMULATOR: return \"watchossimulator\";\n    case MachO::PLATFORM_DRIVERKIT: return \"driverkit\";\n    default:\n      std::string ret;\n      raw_string_ostream ss(ret);\n      ss << format_hex(platform, 8, true);\n      return ss.str();\n    }\n  }\n\n  static std::string getBuildTool(uint32_t tools) {\n    switch (tools) {\n    case MachO::TOOL_CLANG: return \"clang\";\n    case MachO::TOOL_SWIFT: return \"swift\";\n    case MachO::TOOL_LD: return \"ld\";\n    default:\n      std::string ret;\n      raw_string_ostream ss(ret);\n      ss << format_hex(tools, 8, true);\n      return ss.str();\n    }\n  }\n\n  static std::string getVersionString(uint32_t version) {\n    uint32_t major = (version >> 16) & 0xffff;\n    uint32_t minor = (version >> 8) & 0xff;\n    uint32_t update = version & 0xff;\n\n    SmallString<32> Version;\n    Version = utostr(major) + \".\" + utostr(minor);\n    if (update != 0)\n      Version += \".\" + utostr(update);\n    return std::string(std::string(Version.str()));\n  }\n\nprivate:\n  MachOObjectFile(MemoryBufferRef Object, bool IsLittleEndian, bool Is64Bits,\n                  Error &Err, uint32_t UniversalCputype = 0,\n                  uint32_t UniversalIndex = 0);\n\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n\n  union {\n    MachO::mach_header_64 Header64;\n    MachO::mach_header Header;\n  };\n  using SectionList = SmallVector<const char*, 1>;\n  SectionList Sections;\n  using LibraryList = SmallVector<const char*, 1>;\n  LibraryList Libraries;\n  LoadCommandList LoadCommands;\n  using LibraryShortName = SmallVector<StringRef, 1>;\n  using BuildToolList = SmallVector<const char*, 1>;\n  BuildToolList BuildTools;\n  mutable LibraryShortName LibrariesShortNames;\n  std::unique_ptr<BindRebaseSegInfo> BindRebaseSectionTable;\n  const char *SymtabLoadCmd = nullptr;\n  const char *DysymtabLoadCmd = nullptr;\n  const char *DataInCodeLoadCmd = nullptr;\n  const char *LinkOptHintsLoadCmd = nullptr;\n  const char *DyldInfoLoadCmd = nullptr;\n  const char *UuidLoadCmd = nullptr;\n  bool HasPageZeroSegment = false;\n};\n\n/// DiceRef\ninline DiceRef::DiceRef(DataRefImpl DiceP, const ObjectFile *Owner)\n  : DicePimpl(DiceP) , OwningObject(Owner) {}\n\ninline bool DiceRef::operator==(const DiceRef &Other) const {\n  return DicePimpl == Other.DicePimpl;\n}\n\ninline bool DiceRef::operator<(const DiceRef &Other) const {\n  return DicePimpl < Other.DicePimpl;\n}\n\ninline void DiceRef::moveNext() {\n  const MachO::data_in_code_entry *P =\n    reinterpret_cast<const MachO::data_in_code_entry *>(DicePimpl.p);\n  DicePimpl.p = reinterpret_cast<uintptr_t>(P + 1);\n}\n\n// Since a Mach-O data in code reference, a DiceRef, can only be created when\n// the OwningObject ObjectFile is a MachOObjectFile a static_cast<> is used for\n// the methods that get the values of the fields of the reference.\n\ninline std::error_code DiceRef::getOffset(uint32_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.offset;\n  return std::error_code();\n}\n\ninline std::error_code DiceRef::getLength(uint16_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.length;\n  return std::error_code();\n}\n\ninline std::error_code DiceRef::getKind(uint16_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.kind;\n  return std::error_code();\n}\n\ninline DataRefImpl DiceRef::getRawDataRefImpl() const {\n  return DicePimpl;\n}\n\ninline const ObjectFile *DiceRef::getObjectFile() const {\n  return OwningObject;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_MACHO_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachOUniversal.h", "content": "//===- MachOUniversal.h - Mach-O universal binaries -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares Mach-O fat/universal binaries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_MACHOUNIVERSAL_H\n#define LLVM_OBJECT_MACHOUNIVERSAL_H\n\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/MachO.h\"\n#include \"llvm/Object/Archive.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/MachO.h\"\n\nnamespace llvm {\nclass StringRef;\nclass Module;\nclass LLVMContext;\n\nnamespace object {\nclass IRObjectFile;\n\nclass MachOUniversalBinary : public Binary {\n  virtual void anchor();\n\n  uint32_t Magic;\n  uint32_t NumberOfObjects;\npublic:\n  static constexpr uint32_t MaxSectionAlignment = 15; /* 2**15 or 0x8000 */\n\n  class ObjectForArch {\n    const MachOUniversalBinary *Parent;\n    /// Index of object in the universal binary.\n    uint32_t Index;\n    /// Descriptor of the object.\n    MachO::fat_arch Header;\n    MachO::fat_arch_64 Header64;\n\n  public:\n    ObjectForArch(const MachOUniversalBinary *Parent, uint32_t Index);\n\n    void clear() {\n      Parent = nullptr;\n      Index = 0;\n    }\n\n    bool operator==(const ObjectForArch &Other) const {\n      return (Parent == Other.Parent) && (Index == Other.Index);\n    }\n\n    ObjectForArch getNext() const { return ObjectForArch(Parent, Index + 1); }\n    uint32_t getCPUType() const {\n      if (Parent->getMagic() == MachO::FAT_MAGIC)\n        return Header.cputype;\n      else // Parent->getMagic() == MachO::FAT_MAGIC_64\n        return Header64.cputype;\n    }\n    uint32_t getCPUSubType() const {\n      if (Parent->getMagic() == MachO::FAT_MAGIC)\n        return Header.cpusubtype;\n      else // Parent->getMagic() == MachO::FAT_MAGIC_64\n        return Header64.cpusubtype;\n    }\n    uint64_t getOffset() const {\n      if (Parent->getMagic() == MachO::FAT_MAGIC)\n        return Header.offset;\n      else // Parent->getMagic() == MachO::FAT_MAGIC_64\n        return Header64.offset;\n    }\n    uint64_t getSize() const {\n      if (Parent->getMagic() == MachO::FAT_MAGIC)\n        return Header.size;\n      else // Parent->getMagic() == MachO::FAT_MAGIC_64\n        return Header64.size;\n    }\n    uint32_t getAlign() const {\n      if (Parent->getMagic() == MachO::FAT_MAGIC)\n        return Header.align;\n      else // Parent->getMagic() == MachO::FAT_MAGIC_64\n        return Header64.align;\n    }\n    uint32_t getReserved() const {\n      if (Parent->getMagic() == MachO::FAT_MAGIC)\n        return 0;\n      else // Parent->getMagic() == MachO::FAT_MAGIC_64\n        return Header64.reserved;\n    }\n    Triple getTriple() const {\n      return MachOObjectFile::getArchTriple(getCPUType(), getCPUSubType());\n    }\n    std::string getArchFlagName() const {\n      const char *McpuDefault, *ArchFlag;\n      MachOObjectFile::getArchTriple(getCPUType(), getCPUSubType(),\n                                     &McpuDefault, &ArchFlag);\n      return ArchFlag ? ArchFlag : std::string();\n    }\n\n    Expected<std::unique_ptr<MachOObjectFile>> getAsObjectFile() const;\n    Expected<std::unique_ptr<IRObjectFile>>\n    getAsIRObject(LLVMContext &Ctx) const;\n\n    Expected<std::unique_ptr<Archive>> getAsArchive() const;\n  };\n\n  class object_iterator {\n    ObjectForArch Obj;\n  public:\n    object_iterator(const ObjectForArch &Obj) : Obj(Obj) {}\n    const ObjectForArch *operator->() const { return &Obj; }\n    const ObjectForArch &operator*() const { return Obj; }\n\n    bool operator==(const object_iterator &Other) const {\n      return Obj == Other.Obj;\n    }\n    bool operator!=(const object_iterator &Other) const {\n      return !(*this == Other);\n    }\n\n    object_iterator& operator++() {  // Preincrement\n      Obj = Obj.getNext();\n      return *this;\n    }\n  };\n\n  MachOUniversalBinary(MemoryBufferRef Souce, Error &Err);\n  static Expected<std::unique_ptr<MachOUniversalBinary>>\n  create(MemoryBufferRef Source);\n\n  object_iterator begin_objects() const {\n    return ObjectForArch(this, 0);\n  }\n  object_iterator end_objects() const {\n    return ObjectForArch(nullptr, 0);\n  }\n\n  iterator_range<object_iterator> objects() const {\n    return make_range(begin_objects(), end_objects());\n  }\n\n  uint32_t getMagic() const { return Magic; }\n  uint32_t getNumberOfObjects() const { return NumberOfObjects; }\n\n  // Cast methods.\n  static bool classof(Binary const *V) {\n    return V->isMachOUniversalBinary();\n  }\n\n  Expected<ObjectForArch>\n  getObjectForArch(StringRef ArchName) const;\n\n  Expected<std::unique_ptr<MachOObjectFile>>\n  getMachOObjectForArch(StringRef ArchName) const;\n\n  Expected<std::unique_ptr<IRObjectFile>>\n  getIRObjectForArch(StringRef ArchName, LLVMContext &Ctx) const;\n\n  Expected<std::unique_ptr<Archive>>\n  getArchiveForArch(StringRef ArchName) const;\n};\n\n}\n}\n\n#endif\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "content": "//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a command line argument processor that is useful when\n// creating a tool.  It provides a simple, minimalistic interface that is easily\n// extensible and supports nonlocal (library) command line options.\n//\n// Note that rather than trying to figure out what this code does, you should\n// read the library documentation located in docs/CommandLine.html or looks at\n// the many example usages in tools/*/*.cpp\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_COMMANDLINE_H\n#define LLVM_SUPPORT_COMMANDLINE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <functional>\n#include <initializer_list>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass StringSaver;\n\n/// cl Namespace - This namespace contains all of the command line option\n/// processing machinery.  It is intentionally a short name to make qualified\n/// usage concise.\nnamespace cl {\n\n//===----------------------------------------------------------------------===//\n// ParseCommandLineOptions - Command line option processing entry point.\n//\n// Returns true on success. Otherwise, this will print the error message to\n// stderr and exit if \\p Errs is not set (nullptr by default), or print the\n// error message to \\p Errs and return false if \\p Errs is provided.\n//\n// If EnvVar is not nullptr, command-line options are also parsed from the\n// environment variable named by EnvVar.  Precedence is given to occurrences\n// from argv.  This precedence is currently implemented by parsing argv after\n// the environment variable, so it is only implemented correctly for options\n// that give precedence to later occurrences.  If your program supports options\n// that give precedence to earlier occurrences, you will need to extend this\n// function to support it correctly.\nbool ParseCommandLineOptions(int argc, const char *const *argv,\n                             StringRef Overview = \"\",\n                             raw_ostream *Errs = nullptr,\n                             const char *EnvVar = nullptr,\n                             bool LongOptionsUseDoubleDash = false);\n\n// Function pointer type for printing version information.\nusing VersionPrinterTy = std::function<void(raw_ostream &)>;\n\n///===---------------------------------------------------------------------===//\n/// SetVersionPrinter - Override the default (LLVM specific) version printer\n///                     used to print out the version when --version is given\n///                     on the command line. This allows other systems using the\n///                     CommandLine utilities to print their own version string.\nvoid SetVersionPrinter(VersionPrinterTy func);\n\n///===---------------------------------------------------------------------===//\n/// AddExtraVersionPrinter - Add an extra printer to use in addition to the\n///                          default one. This can be called multiple times,\n///                          and each time it adds a new function to the list\n///                          which will be called after the basic LLVM version\n///                          printing is complete. Each can then add additional\n///                          information specific to the tool.\nvoid AddExtraVersionPrinter(VersionPrinterTy func);\n\n// PrintOptionValues - Print option values.\n// With -print-options print the difference between option values and defaults.\n// With -print-all-options print all option values.\n// (Currently not perfect, but best-effort.)\nvoid PrintOptionValues();\n\n// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.\nclass Option;\n\n/// Adds a new option for parsing and provides the option it refers to.\n///\n/// \\param O pointer to the option\n/// \\param Name the string name for the option to handle during parsing\n///\n/// Literal options are used by some parsers to register special option values.\n/// This is how the PassNameParser registers pass names for opt.\nvoid AddLiteralOption(Option &O, StringRef Name);\n\n//===----------------------------------------------------------------------===//\n// Flags permitted to be passed to command line arguments\n//\n\nenum NumOccurrencesFlag { // Flags for the number of occurrences allowed\n  Optional = 0x00,        // Zero or One occurrence\n  ZeroOrMore = 0x01,      // Zero or more occurrences allowed\n  Required = 0x02,        // One occurrence required\n  OneOrMore = 0x03,       // One or more occurrences required\n\n  // ConsumeAfter - Indicates that this option is fed anything that follows the\n  // last positional argument required by the application (it is an error if\n  // there are zero positional arguments, and a ConsumeAfter option is used).\n  // Thus, for example, all arguments to LLI are processed until a filename is\n  // found.  Once a filename is found, all of the succeeding arguments are\n  // passed, unprocessed, to the ConsumeAfter option.\n  //\n  ConsumeAfter = 0x04\n};\n\nenum ValueExpected { // Is a value required for the option?\n  // zero reserved for the unspecified value\n  ValueOptional = 0x01,  // The value can appear... or not\n  ValueRequired = 0x02,  // The value is required to appear!\n  ValueDisallowed = 0x03 // A value may not be specified (for flags)\n};\n\nenum OptionHidden {   // Control whether -help shows this option\n  NotHidden = 0x00,   // Option included in -help & -help-hidden\n  Hidden = 0x01,      // -help doesn't, but -help-hidden does\n  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg\n};\n\n// Formatting flags - This controls special features that the option might have\n// that cause it to be parsed differently...\n//\n// Prefix - This option allows arguments that are otherwise unrecognized to be\n// matched by options that are a prefix of the actual value.  This is useful for\n// cases like a linker, where options are typically of the form '-lfoo' or\n// '-L../../include' where -l or -L are the actual flags.  When prefix is\n// enabled, and used, the value for the flag comes from the suffix of the\n// argument.\n//\n// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject\n// the Option=Value form.\n//\n\nenum FormattingFlags {\n  NormalFormatting = 0x00, // Nothing special\n  Positional = 0x01,       // Is a positional argument, no '-' required\n  Prefix = 0x02,           // Can this option directly prefix its value?\n  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?\n};\n\nenum MiscFlags {             // Miscellaneous flags to adjust argument\n  CommaSeparated = 0x01,     // Should this cl::list split between commas?\n  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?\n  Sink = 0x04,               // Should this cl::list eat all unknown options?\n\n  // Grouping - Can this option group with other options?\n  // If this is enabled, multiple letter options are allowed to bunch together\n  // with only a single hyphen for the whole group.  This allows emulation\n  // of the behavior that ls uses for example: ls -la === ls -l -a\n  Grouping = 0x08,\n\n  // Default option\n  DefaultOption = 0x10\n};\n\n//===----------------------------------------------------------------------===//\n// Option Category class\n//\nclass OptionCategory {\nprivate:\n  StringRef const Name;\n  StringRef const Description;\n\n  void registerCategory();\n\npublic:\n  OptionCategory(StringRef const Name,\n                 StringRef const Description = \"\")\n      : Name(Name), Description(Description) {\n    registerCategory();\n  }\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n};\n\n// The general Option Category (used as default category).\nextern OptionCategory GeneralCategory;\n\n//===----------------------------------------------------------------------===//\n// SubCommand class\n//\nclass SubCommand {\nprivate:\n  StringRef Name;\n  StringRef Description;\n\nprotected:\n  void registerSubCommand();\n  void unregisterSubCommand();\n\npublic:\n  SubCommand(StringRef Name, StringRef Description = \"\")\n      : Name(Name), Description(Description) {\n        registerSubCommand();\n  }\n  SubCommand() = default;\n\n  void reset();\n\n  explicit operator bool() const;\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n\n  SmallVector<Option *, 4> PositionalOpts;\n  SmallVector<Option *, 4> SinkOpts;\n  StringMap<Option *> OptionsMap;\n\n  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.\n};\n\n// A special subcommand representing no subcommand\nextern ManagedStatic<SubCommand> TopLevelSubCommand;\n\n// A special subcommand that can be used to put an option into all subcommands.\nextern ManagedStatic<SubCommand> AllSubCommands;\n\n//===----------------------------------------------------------------------===//\n// Option Base class\n//\nclass Option {\n  friend class alias;\n\n  // handleOccurrences - Overriden by subclasses to handle the value passed into\n  // an argument.  Should return true if there was an error processing the\n  // argument and the program should exit.\n  //\n  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,\n                                StringRef Arg) = 0;\n\n  virtual enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // Out of line virtual function to provide home for the class.\n  virtual void anchor();\n\n  uint16_t NumOccurrences; // The number of times specified\n  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid\n  // problems with signed enums in bitfields.\n  uint16_t Occurrences : 3; // enum NumOccurrencesFlag\n  // not using the enum type for 'Value' because zero is an implementation\n  // detail representing the non-value\n  uint16_t Value : 2;\n  uint16_t HiddenFlag : 2; // enum OptionHidden\n  uint16_t Formatting : 2; // enum FormattingFlags\n  uint16_t Misc : 5;\n  uint16_t FullyInitialized : 1; // Has addArgument been called?\n  uint16_t Position;             // Position of last occurrence of the option\n  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.\n\npublic:\n  StringRef ArgStr;   // The argument string itself (ex: \"help\", \"o\")\n  StringRef HelpStr;  // The descriptive text message for -help\n  StringRef ValueStr; // String describing what the value of this option is\n  SmallVector<OptionCategory *, 1>\n      Categories;                    // The Categories this option belongs to\n  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.\n\n  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {\n    return (enum NumOccurrencesFlag)Occurrences;\n  }\n\n  inline enum ValueExpected getValueExpectedFlag() const {\n    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();\n  }\n\n  inline enum OptionHidden getOptionHiddenFlag() const {\n    return (enum OptionHidden)HiddenFlag;\n  }\n\n  inline enum FormattingFlags getFormattingFlag() const {\n    return (enum FormattingFlags)Formatting;\n  }\n\n  inline unsigned getMiscFlags() const { return Misc; }\n  inline unsigned getPosition() const { return Position; }\n  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }\n\n  // hasArgStr - Return true if the argstr != \"\"\n  bool hasArgStr() const { return !ArgStr.empty(); }\n  bool isPositional() const { return getFormattingFlag() == cl::Positional; }\n  bool isSink() const { return getMiscFlags() & cl::Sink; }\n  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }\n\n  bool isConsumeAfter() const {\n    return getNumOccurrencesFlag() == cl::ConsumeAfter;\n  }\n\n  bool isInAllSubCommands() const {\n    return any_of(Subs, [](const SubCommand *SC) {\n      return SC == &*AllSubCommands;\n    });\n  }\n\n  //-------------------------------------------------------------------------===\n  // Accessor functions set by OptionModifiers\n  //\n  void setArgStr(StringRef S);\n  void setDescription(StringRef S) { HelpStr = S; }\n  void setValueStr(StringRef S) { ValueStr = S; }\n  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }\n  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }\n  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }\n  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }\n  void setMiscFlag(enum MiscFlags M) { Misc |= M; }\n  void setPosition(unsigned pos) { Position = pos; }\n  void addCategory(OptionCategory &C);\n  void addSubCommand(SubCommand &S) { Subs.insert(&S); }\n\nprotected:\n  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,\n                  enum OptionHidden Hidden)\n      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),\n        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),\n        FullyInitialized(false), Position(0), AdditionalVals(0) {\n    Categories.push_back(&GeneralCategory);\n  }\n\n  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }\n\npublic:\n  virtual ~Option() = default;\n\n  // addArgument - Register this argument with the commandline system.\n  //\n  void addArgument();\n\n  /// Unregisters this option from the CommandLine system.\n  ///\n  /// This option must have been the last option registered.\n  /// For testing purposes only.\n  void removeArgument();\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth() const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(size_t GlobalWidth) const = 0;\n\n  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;\n\n  virtual void setDefault() = 0;\n\n  // Prints the help string for an option.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the --<option name>.\n  static void printHelpStr(StringRef HelpStr, size_t Indent,\n                           size_t FirstLineIndentedBy);\n\n  // Prints the help string for an enum value.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the =<value>.\n  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,\n                                  size_t FirstLineIndentedBy);\n\n  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  // addOccurrence - Wrapper around handleOccurrence that enforces Flags.\n  //\n  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,\n                             bool MultiArg = false);\n\n  // Prints option name followed by message.  Always returns true.\n  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());\n  bool error(const Twine &Message, raw_ostream &Errs) {\n    return error(Message, StringRef(), Errs);\n  }\n\n  inline int getNumOccurrences() const { return NumOccurrences; }\n  void reset();\n};\n\n//===----------------------------------------------------------------------===//\n// Command line option modifiers that can be used to modify the behavior of\n// command line option parsers...\n//\n\n// desc - Modifier to set the description shown in the -help output...\nstruct desc {\n  StringRef Desc;\n\n  desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setDescription(Desc); }\n};\n\n// value_desc - Modifier to set the value description shown in the -help\n// output...\nstruct value_desc {\n  StringRef Desc;\n\n  value_desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setValueStr(Desc); }\n};\n\n// init - Specify a default (initial) value for the command line argument, if\n// the default constructor for the argument type does not give you what you\n// want.  This is only valid on \"opt\" arguments, not on \"list\" arguments.\n//\ntemplate <class Ty> struct initializer {\n  const Ty &Init;\n  initializer(const Ty &Val) : Init(Val) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }\n};\n\ntemplate <class Ty> initializer<Ty> init(const Ty &Val) {\n  return initializer<Ty>(Val);\n}\n\n// location - Allow the user to specify which external variable they want to\n// store the results of the command line argument processing into, if they don't\n// want to store it in the option itself.\n//\ntemplate <class Ty> struct LocationClass {\n  Ty &Loc;\n\n  LocationClass(Ty &L) : Loc(L) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }\n};\n\ntemplate <class Ty> LocationClass<Ty> location(Ty &L) {\n  return LocationClass<Ty>(L);\n}\n\n// cat - Specifiy the Option category for the command line argument to belong\n// to.\nstruct cat {\n  OptionCategory &Category;\n\n  cat(OptionCategory &c) : Category(c) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }\n};\n\n// sub - Specify the subcommand that this option belongs to.\nstruct sub {\n  SubCommand &Sub;\n\n  sub(SubCommand &S) : Sub(S) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }\n};\n\n// Specify a callback function to be called when an option is seen.\n// Can be used to set other options automatically.\ntemplate <typename R, typename Ty> struct cb {\n  std::function<R(Ty)> CB;\n\n  cb(std::function<R(Ty)> CB) : CB(CB) {}\n\n  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }\n};\n\nnamespace detail {\ntemplate <typename F>\nstruct callback_traits : public callback_traits<decltype(&F::operator())> {};\n\ntemplate <typename R, typename C, typename... Args>\nstruct callback_traits<R (C::*)(Args...) const> {\n  using result_type = R;\n  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;\n  static_assert(sizeof...(Args) == 1, \"callback function must have one and only one parameter\");\n  static_assert(std::is_same<result_type, void>::value,\n                \"callback return type must be void\");\n  static_assert(std::is_lvalue_reference<arg_type>::value &&\n                    std::is_const<std::remove_reference_t<arg_type>>::value,\n                \"callback arg_type must be a const lvalue reference\");\n};\n} // namespace detail\n\ntemplate <typename F>\ncb<typename detail::callback_traits<F>::result_type,\n   typename detail::callback_traits<F>::arg_type>\ncallback(F CB) {\n  using result_type = typename detail::callback_traits<F>::result_type;\n  using arg_type = typename detail::callback_traits<F>::arg_type;\n  return cb<result_type, arg_type>(CB);\n}\n\n//===----------------------------------------------------------------------===//\n// OptionValue class\n\n// Support value comparison outside the template.\nstruct GenericOptionValue {\n  virtual bool compare(const GenericOptionValue &V) const = 0;\n\nprotected:\n  GenericOptionValue() = default;\n  GenericOptionValue(const GenericOptionValue&) = default;\n  GenericOptionValue &operator=(const GenericOptionValue &) = default;\n  ~GenericOptionValue() = default;\n\nprivate:\n  virtual void anchor();\n};\n\ntemplate <class DataType> struct OptionValue;\n\n// The default value safely does nothing. Option value printing is only\n// best-effort.\ntemplate <class DataType, bool isClass>\nstruct OptionValueBase : public GenericOptionValue {\n  // Temporary storage for argument passing.\n  using WrapperType = OptionValue<DataType>;\n\n  bool hasValue() const { return false; }\n\n  const DataType &getValue() const { llvm_unreachable(\"no default value\"); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> void setValue(const DT & /*V*/) {}\n\n  bool compare(const DataType & /*V*/) const { return false; }\n\n  bool compare(const GenericOptionValue & /*V*/) const override {\n    return false;\n  }\n\nprotected:\n  ~OptionValueBase() = default;\n};\n\n// Simple copy of the option value.\ntemplate <class DataType> class OptionValueCopy : public GenericOptionValue {\n  DataType Value;\n  bool Valid = false;\n\nprotected:\n  OptionValueCopy(const OptionValueCopy&) = default;\n  OptionValueCopy &operator=(const OptionValueCopy &) = default;\n  ~OptionValueCopy() = default;\n\npublic:\n  OptionValueCopy() = default;\n\n  bool hasValue() const { return Valid; }\n\n  const DataType &getValue() const {\n    assert(Valid && \"invalid option value\");\n    return Value;\n  }\n\n  void setValue(const DataType &V) {\n    Valid = true;\n    Value = V;\n  }\n\n  bool compare(const DataType &V) const { return Valid && (Value != V); }\n\n  bool compare(const GenericOptionValue &V) const override {\n    const OptionValueCopy<DataType> &VC =\n        static_cast<const OptionValueCopy<DataType> &>(V);\n    if (!VC.hasValue())\n      return false;\n    return compare(VC.getValue());\n  }\n};\n\n// Non-class option values.\ntemplate <class DataType>\nstruct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {\n  using WrapperType = DataType;\n\nprotected:\n  OptionValueBase() = default;\n  OptionValueBase(const OptionValueBase&) = default;\n  OptionValueBase &operator=(const OptionValueBase &) = default;\n  ~OptionValueBase() = default;\n};\n\n// Top-level option class.\ntemplate <class DataType>\nstruct OptionValue final\n    : OptionValueBase<DataType, std::is_class<DataType>::value> {\n  OptionValue() = default;\n\n  OptionValue(const DataType &V) { this->setValue(V); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> OptionValue<DataType> &operator=(const DT &V) {\n    this->setValue(V);\n    return *this;\n  }\n};\n\n// Other safe-to-copy-by-value common option types.\nenum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };\ntemplate <>\nstruct OptionValue<cl::boolOrDefault> final\n    : OptionValueCopy<cl::boolOrDefault> {\n  using WrapperType = cl::boolOrDefault;\n\n  OptionValue() = default;\n\n  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }\n\n  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\ntemplate <>\nstruct OptionValue<std::string> final : OptionValueCopy<std::string> {\n  using WrapperType = StringRef;\n\n  OptionValue() = default;\n\n  OptionValue(const std::string &V) { this->setValue(V); }\n\n  OptionValue<std::string> &operator=(const std::string &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\n//===----------------------------------------------------------------------===//\n// Enum valued command line option\n//\n\n// This represents a single enum value, using \"int\" as the underlying type.\nstruct OptionEnumValue {\n  StringRef Name;\n  int Value;\n  StringRef Description;\n};\n\n#define clEnumVal(ENUMVAL, DESC)                                               \\\n  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }\n#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \\\n  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }\n\n// values - For custom data types, allow specifying a group of values together\n// as the values that go into the mapping that the option handler uses.\n//\nclass ValuesClass {\n  // Use a vector instead of a map, because the lists should be short,\n  // the overhead is less, and most importantly, it keeps them in the order\n  // inserted so we can print our option out nicely.\n  SmallVector<OptionEnumValue, 4> Values;\n\npublic:\n  ValuesClass(std::initializer_list<OptionEnumValue> Options)\n      : Values(Options) {}\n\n  template <class Opt> void apply(Opt &O) const {\n    for (const auto &Value : Values)\n      O.getParser().addLiteralOption(Value.Name, Value.Value,\n                                     Value.Description);\n  }\n};\n\n/// Helper to build a ValuesClass by forwarding a variable number of arguments\n/// as an initializer list to the ValuesClass constructor.\ntemplate <typename... OptsTy> ValuesClass values(OptsTy... Options) {\n  return ValuesClass({Options...});\n}\n\n//===----------------------------------------------------------------------===//\n// parser class - Parameterizable parser for different data types.  By default,\n// known data types (string, int, bool) have specialized parsers, that do what\n// you would expect.  The default parser, used for data types that are not\n// built-in, uses a mapping table to map specific options to values, which is\n// used, among other things, to handle enum types.\n\n//--------------------------------------------------\n// generic_parser_base - This class holds all the non-generic code that we do\n// not need replicated for every instance of the generic parser.  This also\n// allows us to put stuff into CommandLine.cpp\n//\nclass generic_parser_base {\nprotected:\n  class GenericOptionInfo {\n  public:\n    GenericOptionInfo(StringRef name, StringRef helpStr)\n        : Name(name), HelpStr(helpStr) {}\n    StringRef Name;\n    StringRef HelpStr;\n  };\n\npublic:\n  generic_parser_base(Option &O) : Owner(O) {}\n\n  virtual ~generic_parser_base() = default;\n  // Base class should have virtual-destructor\n\n  // getNumOptions - Virtual function implemented by generic subclass to\n  // indicate how many entries are in Values.\n  //\n  virtual unsigned getNumOptions() const = 0;\n\n  // getOption - Return option name N.\n  virtual StringRef getOption(unsigned N) const = 0;\n\n  // getDescription - Return description N\n  virtual StringRef getDescription(unsigned N) const = 0;\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth(const Option &O) const;\n\n  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,\n                              const GenericOptionValue &Default,\n                              size_t GlobalWidth) const;\n\n  // printOptionDiff - print the value of an option and it's default.\n  //\n  // Template definition ensures that the option and default have the same\n  // DataType (via the same AnyOptionValue).\n  template <class AnyOptionValue>\n  void printOptionDiff(const Option &O, const AnyOptionValue &V,\n                       const AnyOptionValue &Default,\n                       size_t GlobalWidth) const {\n    printGenericOptionDiff(O, V, Default, GlobalWidth);\n  }\n\n  void initialize() {}\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {\n    // If there has been no argstr specified, that means that we need to add an\n    // argument for every possible option.  This ensures that our options are\n    // vectored to us.\n    if (!Owner.hasArgStr())\n      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)\n        OptionNames.push_back(getOption(i));\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    // If there is an ArgStr specified, then we are of the form:\n    //\n    //    -opt=O2   or   -opt O2  or  -optO2\n    //\n    // In which case, the value is required.  Otherwise if an arg str has not\n    // been specified, we are of the form:\n    //\n    //    -O2 or O2 or -la (where -l and -a are separate options)\n    //\n    // If this is the case, we cannot allow a value.\n    //\n    if (Owner.hasArgStr())\n      return ValueRequired;\n    else\n      return ValueDisallowed;\n  }\n\n  // findOption - Return the option number corresponding to the specified\n  // argument string.  If the option is not found, getNumOptions() is returned.\n  //\n  unsigned findOption(StringRef Name);\n\nprotected:\n  Option &Owner;\n};\n\n// Default parser implementation - This implementation depends on having a\n// mapping of recognized options to values of some sort.  In addition to this,\n// each entry in the mapping also tracks a help message that is printed with the\n// command line option for -help.  Because this is a simple mapping parser, the\n// data type can be any unsupported type.\n//\ntemplate <class DataType> class parser : public generic_parser_base {\nprotected:\n  class OptionInfo : public GenericOptionInfo {\n  public:\n    OptionInfo(StringRef name, DataType v, StringRef helpStr)\n        : GenericOptionInfo(name, helpStr), V(v) {}\n\n    OptionValue<DataType> V;\n  };\n  SmallVector<OptionInfo, 8> Values;\n\npublic:\n  parser(Option &O) : generic_parser_base(O) {}\n\n  using parser_data_type = DataType;\n\n  // Implement virtual functions needed by generic_parser_base\n  unsigned getNumOptions() const override { return unsigned(Values.size()); }\n  StringRef getOption(unsigned N) const override { return Values[N].Name; }\n  StringRef getDescription(unsigned N) const override {\n    return Values[N].HelpStr;\n  }\n\n  // getOptionValue - Return the value of option name N.\n  const GenericOptionValue &getOptionValue(unsigned N) const override {\n    return Values[N].V;\n  }\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {\n    StringRef ArgVal;\n    if (Owner.hasArgStr())\n      ArgVal = Arg;\n    else\n      ArgVal = ArgName;\n\n    for (size_t i = 0, e = Values.size(); i != e; ++i)\n      if (Values[i].Name == ArgVal) {\n        V = Values[i].V.getValue();\n        return false;\n      }\n\n    return O.error(\"Cannot find option named '\" + ArgVal + \"'!\");\n  }\n\n  /// addLiteralOption - Add an entry to the mapping table.\n  ///\n  template <class DT>\n  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {\n    assert(findOption(Name) == Values.size() && \"Option already exists!\");\n    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);\n    Values.push_back(X);\n    AddLiteralOption(Owner, Name);\n  }\n\n  /// removeLiteralOption - Remove the specified option.\n  ///\n  void removeLiteralOption(StringRef Name) {\n    unsigned N = findOption(Name);\n    assert(N != Values.size() && \"Option not found!\");\n    Values.erase(Values.begin() + N);\n  }\n};\n\n//--------------------------------------------------\n// basic_parser - Super class of parsers to provide boilerplate code\n//\nclass basic_parser_impl { // non-template implementation of basic_parser<t>\npublic:\n  basic_parser_impl(Option &) {}\n\n  virtual ~basic_parser_impl() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueRequired;\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  void initialize() {}\n\n  // Return the width of the option tag for printing...\n  size_t getOptionWidth(const Option &O) const;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  // printOptionNoValue - Print a placeholder for options that don't yet support\n  // printOptionDiff().\n  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;\n\n  // getValueName - Overload in subclass to provide a better default value.\n  virtual StringRef getValueName() const { return \"value\"; }\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  virtual void anchor();\n\nprotected:\n  // A helper for basic_parser::printOptionDiff.\n  void printOptionName(const Option &O, size_t GlobalWidth) const;\n};\n\n// basic_parser - The real basic parser is just a template wrapper that provides\n// a typedef for the provided data type.\n//\ntemplate <class DataType> class basic_parser : public basic_parser_impl {\npublic:\n  using parser_data_type = DataType;\n  using OptVal = OptionValue<DataType>;\n\n  basic_parser(Option &O) : basic_parser_impl(O) {}\n};\n\n//--------------------------------------------------\n// parser<bool>\n//\ntemplate <> class parser<bool> : public basic_parser<bool> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);\n\n  void initialize() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, bool V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<bool>;\n\n//--------------------------------------------------\n// parser<boolOrDefault>\ntemplate <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<boolOrDefault>;\n\n//--------------------------------------------------\n// parser<int>\n//\ntemplate <> class parser<int> : public basic_parser<int> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"int\"; }\n\n  void printOptionDiff(const Option &O, int V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<int>;\n\n//--------------------------------------------------\n// parser<long>\n//\ntemplate <> class parser<long> final : public basic_parser<long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long>;\n\n//--------------------------------------------------\n// parser<long long>\n//\ntemplate <> class parser<long long> : public basic_parser<long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long long>;\n\n//--------------------------------------------------\n// parser<unsigned>\n//\ntemplate <> class parser<unsigned> : public basic_parser<unsigned> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"uint\"; }\n\n  void printOptionDiff(const Option &O, unsigned V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned>;\n\n//--------------------------------------------------\n// parser<unsigned long>\n//\ntemplate <>\nclass parser<unsigned long> final : public basic_parser<unsigned long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long>;\n\n//--------------------------------------------------\n// parser<unsigned long long>\n//\ntemplate <>\nclass parser<unsigned long long> : public basic_parser<unsigned long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg,\n             unsigned long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long long>;\n\n//--------------------------------------------------\n// parser<double>\n//\ntemplate <> class parser<double> : public basic_parser<double> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, double V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<double>;\n\n//--------------------------------------------------\n// parser<float>\n//\ntemplate <> class parser<float> : public basic_parser<float> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, float V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<float>;\n\n//--------------------------------------------------\n// parser<std::string>\n//\ntemplate <> class parser<std::string> : public basic_parser<std::string> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {\n    Value = Arg.str();\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"string\"; }\n\n  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<std::string>;\n\n//--------------------------------------------------\n// parser<char>\n//\ntemplate <> class parser<char> : public basic_parser<char> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, char &Value) {\n    Value = Arg[0];\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"char\"; }\n\n  void printOptionDiff(const Option &O, char V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<char>;\n\n//--------------------------------------------------\n// PrintOptionDiff\n//\n// This collection of wrappers is the intermediary between class opt and class\n// parser to handle all the template nastiness.\n\n// This overloaded function is selected by the generic parser.\ntemplate <class ParserClass, class DT>\nvoid printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,\n                     const OptionValue<DT> &Default, size_t GlobalWidth) {\n  OptionValue<DT> OV = V;\n  P.printOptionDiff(O, OV, Default, GlobalWidth);\n}\n\n// This is instantiated for basic parsers when the parsed value has a different\n// type than the option value. e.g. HelpPrinter.\ntemplate <class ParserDT, class ValDT> struct OptionDiffPrinter {\n  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,\n             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {\n    P.printOptionNoValue(O, GlobalWidth);\n  }\n};\n\n// This is instantiated for basic parsers when the parsed value has the same\n// type as the option value.\ntemplate <class DT> struct OptionDiffPrinter<DT, DT> {\n  void print(const Option &O, const parser<DT> &P, const DT &V,\n             const OptionValue<DT> &Default, size_t GlobalWidth) {\n    P.printOptionDiff(O, V, Default, GlobalWidth);\n  }\n};\n\n// This overloaded function is selected by the basic parser, which may parse a\n// different type than the option type.\ntemplate <class ParserClass, class ValDT>\nvoid printOptionDiff(\n    const Option &O,\n    const basic_parser<typename ParserClass::parser_data_type> &P,\n    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {\n\n  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;\n  printer.print(O, static_cast<const ParserClass &>(P), V, Default,\n                GlobalWidth);\n}\n\n//===----------------------------------------------------------------------===//\n// applicator class - This class is used because we must use partial\n// specialization to handle literal string arguments specially (const char* does\n// not correctly respond to the apply method).  Because the syntax to use this\n// is a pain, we have the 'apply' method below to handle the nastiness...\n//\ntemplate <class Mod> struct applicator {\n  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }\n};\n\n// Handle const char* as a special case...\ntemplate <unsigned n> struct applicator<char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <unsigned n> struct applicator<const char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <> struct applicator<StringRef > {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\n\ntemplate <> struct applicator<NumOccurrencesFlag> {\n  static void opt(NumOccurrencesFlag N, Option &O) {\n    O.setNumOccurrencesFlag(N);\n  }\n};\n\ntemplate <> struct applicator<ValueExpected> {\n  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }\n};\n\ntemplate <> struct applicator<OptionHidden> {\n  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }\n};\n\ntemplate <> struct applicator<FormattingFlags> {\n  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }\n};\n\ntemplate <> struct applicator<MiscFlags> {\n  static void opt(MiscFlags MF, Option &O) {\n    assert((MF != Grouping || O.ArgStr.size() == 1) &&\n           \"cl::Grouping can only apply to single charater Options.\");\n    O.setMiscFlag(MF);\n  }\n};\n\n// apply method - Apply modifiers to an option in a type safe way.\ntemplate <class Opt, class Mod, class... Mods>\nvoid apply(Opt *O, const Mod &M, const Mods &... Ms) {\n  applicator<Mod>::opt(M, *O);\n  apply(O, Ms...);\n}\n\ntemplate <class Opt, class Mod> void apply(Opt *O, const Mod &M) {\n  applicator<Mod>::opt(M, *O);\n}\n\n//===----------------------------------------------------------------------===//\n// opt_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, bool ExternalStorage, bool isClass>\nclass opt_storage {\n  DataType *Location = nullptr; // Where to store the object...\n  OptionValue<DataType> Default;\n\n  void check_location() const {\n    assert(Location && \"cl::location(...) not specified for a command \"\n                       \"line option with external storage, \"\n                       \"or cl::init specified before cl::location()!!\");\n  }\n\npublic:\n  opt_storage() = default;\n\n  bool setLocation(Option &O, DataType &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    Default = L;\n    return false;\n  }\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    check_location();\n    *Location = V;\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() {\n    check_location();\n    return *Location;\n  }\n  const DataType &getValue() const {\n    check_location();\n    return *Location;\n  }\n\n  operator DataType() const { return this->getValue(); }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define how to hold a class type object, such as a string.  Since we can\n// inherit from a class, we do so.  This makes us exactly compatible with the\n// object in all cases that it is used.\n//\ntemplate <class DataType>\nclass opt_storage<DataType, false, true> : public DataType {\npublic:\n  OptionValue<DataType> Default;\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    DataType::operator=(V);\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() { return *this; }\n  const DataType &getValue() const { return *this; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define a partial specialization to handle things we cannot inherit from.  In\n// this case, we store an instance through containment, and overload operators\n// to get at the value.\n//\ntemplate <class DataType> class opt_storage<DataType, false, false> {\npublic:\n  DataType Value;\n  OptionValue<DataType> Default;\n\n  // Make sure we initialize the value with the default constructor for the\n  // type.\n  opt_storage() : Value(DataType()), Default(DataType()) {}\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    Value = V;\n    if (initial)\n      Default = V;\n  }\n  DataType &getValue() { return Value; }\n  DataType getValue() const { return Value; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n\n  operator DataType() const { return getValue(); }\n\n  // If the datatype is a pointer, support -> on it.\n  DataType operator->() const { return Value; }\n};\n\n//===----------------------------------------------------------------------===//\n// opt - A scalar command line option.\n//\ntemplate <class DataType, bool ExternalStorage = false,\n          class ParserClass = parser<DataType>>\nclass opt : public Option,\n            public opt_storage<DataType, ExternalStorage,\n                               std::is_class<DataType>::value> {\n  ParserClass Parser;\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse error!\n    this->setValue(Val);\n    this->setPosition(pos);\n    Callback(Val);\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  void printOptionValue(size_t GlobalWidth, bool Force) const override {\n    if (Force || this->getDefault().compare(this->getValue())) {\n      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),\n                                       this->getDefault(), GlobalWidth);\n    }\n  }\n\n  template <class T,\n            class = std::enable_if_t<std::is_assignable<T &, T>::value>>\n  void setDefaultImpl() {\n    const OptionValue<DataType> &V = this->getDefault();\n    if (V.hasValue())\n      this->setValue(V.getValue());\n  }\n\n  template <class T,\n            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>\n  void setDefaultImpl(...) {}\n\n  void setDefault() override { setDefaultImpl<DataType>(); }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  opt(const opt &) = delete;\n  opt &operator=(const opt &) = delete;\n\n  // setInitialValue - Used by the cl::init modifier...\n  void setInitialValue(const DataType &V) { this->setValue(V, true); }\n\n  ParserClass &getParser() { return Parser; }\n\n  template <class T> DataType &operator=(const T &Val) {\n    this->setValue(Val);\n    Callback(Val);\n    return this->getValue();\n  }\n\n  template <class... Mods>\n  explicit opt(const Mods &... Ms)\n      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\nextern template class opt<unsigned>;\nextern template class opt<int>;\nextern template class opt<std::string>;\nextern template class opt<char>;\nextern template class opt<bool>;\n\n//===----------------------------------------------------------------------===//\n// list_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class list_storage {\n  StorageClass *Location = nullptr; // Where to store the object...\n\npublic:\n  list_storage() = default;\n\n  void clear() {}\n\n  bool setLocation(Option &O, StorageClass &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    Location->push_back(V);\n  }\n};\n\n// Define how to hold a class type object, such as a string.\n// Originally this code inherited from std::vector. In transitioning to a new\n// API for command line options we should change this. The new implementation\n// of this list_storage specialization implements the minimum subset of the\n// std::vector API required for all the current clients.\n//\n// FIXME: Reduce this API to a more narrow subset of std::vector\n//\ntemplate <class DataType> class list_storage<DataType, bool> {\n  std::vector<DataType> Storage;\n\npublic:\n  using iterator = typename std::vector<DataType>::iterator;\n\n  iterator begin() { return Storage.begin(); }\n  iterator end() { return Storage.end(); }\n\n  using const_iterator = typename std::vector<DataType>::const_iterator;\n\n  const_iterator begin() const { return Storage.begin(); }\n  const_iterator end() const { return Storage.end(); }\n\n  using size_type = typename std::vector<DataType>::size_type;\n\n  size_type size() const { return Storage.size(); }\n\n  bool empty() const { return Storage.empty(); }\n\n  void push_back(const DataType &value) { Storage.push_back(value); }\n  void push_back(DataType &&value) { Storage.push_back(value); }\n\n  using reference = typename std::vector<DataType>::reference;\n  using const_reference = typename std::vector<DataType>::const_reference;\n\n  reference operator[](size_type pos) { return Storage[pos]; }\n  const_reference operator[](size_type pos) const { return Storage[pos]; }\n\n  void clear() {\n    Storage.clear();\n  }\n\n  iterator erase(const_iterator pos) { return Storage.erase(pos); }\n  iterator erase(const_iterator first, const_iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator erase(iterator pos) { return Storage.erase(pos); }\n  iterator erase(iterator first, iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator insert(const_iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(const_iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  iterator insert(iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  reference front() { return Storage.front(); }\n  const_reference front() const { return Storage.front(); }\n\n  operator std::vector<DataType> &() { return Storage; }\n  operator ArrayRef<DataType>() const { return Storage; }\n  std::vector<DataType> *operator&() { return &Storage; }\n  const std::vector<DataType> *operator&() const { return &Storage; }\n\n  template <class T> void addValue(const T &V) { Storage.push_back(V); }\n};\n\n//===----------------------------------------------------------------------===//\n// list - A list of command line options.\n//\ntemplate <class DataType, class StorageClass = bool,\n          class ParserClass = parser<DataType>>\nclass list : public Option, public list_storage<DataType, StorageClass> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    list_storage<DataType, StorageClass>::addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: list options don't currently store their default value.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {\n    Positions.clear();\n    list_storage<DataType, StorageClass>::clear();\n  }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  list(const list &) = delete;\n  list &operator=(const list &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }\n\n  template <class... Mods>\n  explicit list(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n// multi_val - Modifier to set the number of additional values.\nstruct multi_val {\n  unsigned AdditionalVals;\n  explicit multi_val(unsigned N) : AdditionalVals(N) {}\n\n  template <typename D, typename S, typename P>\n  void apply(list<D, S, P> &L) const {\n    L.setNumAdditionalVals(AdditionalVals);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// bits_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class bits_storage {\n  unsigned *Location = nullptr; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = reinterpret_cast<unsigned>(V);\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  bits_storage() = default;\n\n  bool setLocation(Option &O, unsigned &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    *Location |= Bit(V);\n  }\n\n  unsigned getBits() { return *Location; }\n\n  template <class T> bool isSet(const T &V) {\n    return (*Location & Bit(V)) != 0;\n  }\n};\n\n// Define how to hold bits.  Since we can inherit from a class, we do so.\n// This makes us exactly compatible with the bits in all cases that it is used.\n//\ntemplate <class DataType> class bits_storage<DataType, bool> {\n  unsigned Bits; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = (unsigned)V;\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  template <class T> void addValue(const T &V) { Bits |= Bit(V); }\n\n  unsigned getBits() { return Bits; }\n\n  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }\n};\n\n//===----------------------------------------------------------------------===//\n// bits - A bit vector of command options.\n//\ntemplate <class DataType, class Storage = bool,\n          class ParserClass = parser<DataType>>\nclass bits : public Option, public bits_storage<DataType, Storage> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    this->addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: bits options don't currently store their default values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {}\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  bits(const bits &) = delete;\n  bits &operator=(const bits &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  template <class... Mods>\n  explicit bits(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n//===----------------------------------------------------------------------===//\n// Aliased command line option (alias this name to a preexisting name)\n//\n\nclass alias : public Option {\n  Option *AliasFor;\n\n  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,\n                        StringRef Arg) override {\n    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);\n  }\n\n  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,\n                     bool MultiArg = false) override {\n    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);\n  }\n\n  // Handle printing stuff...\n  size_t getOptionWidth() const override;\n  void printOptionInfo(size_t GlobalWidth) const override;\n\n  // Aliases do not need to print their values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override { AliasFor->setDefault(); }\n\n  ValueExpected getValueExpectedFlagDefault() const override {\n    return AliasFor->getValueExpectedFlag();\n  }\n\n  void done() {\n    if (!hasArgStr())\n      error(\"cl::alias must have argument name specified!\");\n    if (!AliasFor)\n      error(\"cl::alias must have an cl::aliasopt(option) specified!\");\n    if (!Subs.empty())\n      error(\"cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!\");\n    Subs = AliasFor->Subs;\n    Categories = AliasFor->Categories;\n    addArgument();\n  }\n\npublic:\n  // Command line options should not be copyable\n  alias(const alias &) = delete;\n  alias &operator=(const alias &) = delete;\n\n  void setAliasFor(Option &O) {\n    if (AliasFor)\n      error(\"cl::alias must only have one cl::aliasopt(...) specified!\");\n    AliasFor = &O;\n  }\n\n  template <class... Mods>\n  explicit alias(const Mods &... Ms)\n      : Option(Optional, Hidden), AliasFor(nullptr) {\n    apply(this, Ms...);\n    done();\n  }\n};\n\n// aliasfor - Modifier to set the option an alias aliases.\nstruct aliasopt {\n  Option &Opt;\n\n  explicit aliasopt(Option &O) : Opt(O) {}\n\n  void apply(alias &A) const { A.setAliasFor(Opt); }\n};\n\n// extrahelp - provide additional help at the end of the normal help\n// output. All occurrences of cl::extrahelp will be accumulated and\n// printed to stderr at the end of the regular help, just before\n// exit is called.\nstruct extrahelp {\n  StringRef morehelp;\n\n  explicit extrahelp(StringRef help);\n};\n\nvoid PrintVersionMessage();\n\n/// This function just prints the help message, exactly the same way as if the\n/// -help or -help-hidden option had been given on the command line.\n///\n/// \\param Hidden if true will print hidden options\n/// \\param Categorized if true print options in categories\nvoid PrintHelpMessage(bool Hidden = false, bool Categorized = false);\n\n//===----------------------------------------------------------------------===//\n// Public interface for accessing registered options.\n//\n\n/// Use this to get a StringMap to all registered named options\n/// (e.g. -help).\n///\n/// \\return A reference to the StringMap used by the cl APIs to parse options.\n///\n/// Access to unnamed arguments (i.e. positional) are not provided because\n/// it is expected that the client already has access to these.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc,char* argv[]) {\n/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();\n/// assert(opts.count(\"help\") == 1)\n/// opts[\"help\"]->setDescription(\"Show alphabetical help information\")\n/// // More code\n/// llvm::cl::ParseCommandLineOptions(argc,argv);\n/// //More code\n/// }\n/// \\endcode\n///\n/// This interface is useful for modifying options in libraries that are out of\n/// the control of the client. The options should be modified before calling\n/// llvm::cl::ParseCommandLineOptions().\n///\n/// Hopefully this API can be deprecated soon. Any situation where options need\n/// to be modified by tools or libraries should be handled by sane APIs rather\n/// than just handing around a global list.\nStringMap<Option *> &getRegisteredOptions(SubCommand &Sub = *TopLevelSubCommand);\n\n/// Use this to get all registered SubCommands from the provided parser.\n///\n/// \\return A range of all SubCommand pointers registered with the parser.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc, char* argv[]) {\n///   llvm::cl::ParseCommandLineOptions(argc, argv);\n///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {\n///     if (*S) {\n///       std::cout << \"Executing subcommand: \" << S->getName() << std::endl;\n///       // Execute some function based on the name...\n///     }\n///   }\n/// }\n/// \\endcode\n///\n/// This interface is useful for defining subcommands in libraries and\n/// the dispatch from a single point (like in the main function).\niterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>\ngetRegisteredSubcommands();\n\n//===----------------------------------------------------------------------===//\n// Standalone command line processing utilities.\n//\n\n/// Tokenizes a command line that can contain escapes and quotes.\n//\n/// The quoting rules match those used by GCC and other tools that use\n/// libiberty's buildargv() or expandargv() utilities, and do not match bash.\n/// They differ from buildargv() on treatment of backslashes that do not escape\n/// a special character to make it possible to accept most Windows file paths.\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,\n                            SmallVectorImpl<const char *> &NewArgv,\n                            bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line which may contain quotes and escaped\n/// quotes.\n///\n/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.\n/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,\n                                SmallVectorImpl<const char *> &NewArgv,\n                                bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line while attempting to avoid copies. If no\n/// quoting or escaping was used, this produces substrings of the original\n/// string. If a token requires unquoting, it will be allocated with the\n/// StringSaver.\nvoid TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,\n                                      SmallVectorImpl<StringRef> &NewArgv);\n\n/// String tokenization function type.  Should be compatible with either\n/// Windows or Unix command line tokenizers.\nusing TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,\n                                   SmallVectorImpl<const char *> &NewArgv,\n                                   bool MarkEOLs);\n\n/// Tokenizes content of configuration file.\n///\n/// \\param [in] Source The string representing content of config file.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\n/// \\param [in] MarkEOLs Added for compatibility with TokenizerCallback.\n///\n/// It works like TokenizeGNUCommandLine with ability to skip comment lines.\n///\nvoid tokenizeConfigFile(StringRef Source, StringSaver &Saver,\n                        SmallVectorImpl<const char *> &NewArgv,\n                        bool MarkEOLs = false);\n\n/// Reads command line options from the given configuration file.\n///\n/// \\param [in] CfgFileName Path to configuration file.\n/// \\param [in] Saver  Objects that saves allocated strings.\n/// \\param [out] Argv Array to which the read options are added.\n/// \\return true if the file was successfully read.\n///\n/// It reads content of the specified file, tokenizes it and expands \"@file\"\n/// commands resolving file names in them relative to the directory where\n/// CfgFilename resides.\n///\nbool readConfigFile(StringRef CfgFileName, StringSaver &Saver,\n                    SmallVectorImpl<const char *> &Argv);\n\n/// Expand response files on a command line recursively using the given\n/// StringSaver and tokenization strategy.  Argv should contain the command line\n/// before expansion and will be modified in place. If requested, Argv will\n/// also be populated with nullptrs indicating where each response file line\n/// ends, which is useful for the \"/link\" argument that needs to consume all\n/// remaining arguments only until the next end of line, when in a response\n/// file.\n///\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] Tokenizer Tokenization strategy. Typically Unix or Windows.\n/// \\param [in,out] Argv Command line into which to expand response files.\n/// \\param [in] MarkEOLs Mark end of lines and the end of the response file\n/// with nullptrs in the Argv vector.\n/// \\param [in] RelativeNames true if names of nested response files must be\n/// resolved relative to including file.\n/// \\param [in] FS File system used for all file access when running the tool.\n/// \\param [in] CurrentDir Path used to resolve relative rsp files. If set to\n/// None, process' cwd is used instead.\n/// \\return true if all @files were expanded successfully or there were none.\nbool ExpandResponseFiles(\n    StringSaver &Saver, TokenizerCallback Tokenizer,\n    SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false,\n    bool RelativeNames = false,\n    llvm::vfs::FileSystem &FS = *llvm::vfs::getRealFileSystem(),\n    llvm::Optional<llvm::StringRef> CurrentDir = llvm::None);\n\n/// A convenience helper which concatenates the options specified by the\n/// environment variable EnvVar and command line options, then expands response\n/// files recursively. The tokenizer is a predefined GNU or Windows one.\n/// \\return true if all @files were expanded successfully or there were none.\nbool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,\n                         StringSaver &Saver,\n                         SmallVectorImpl<const char *> &NewArgv);\n\n/// Mark all options not part of this category as cl::ReallyHidden.\n///\n/// \\param Category the category of options to keep displaying\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(cl::OptionCategory &Category,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Mark all options not part of the categories as cl::ReallyHidden.\n///\n/// \\param Categories the categories of options to keep displaying.\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Reset all command line options to a state that looks as if they have\n/// never appeared on the command line.  This is useful for being able to parse\n/// a command line multiple times (especially useful for writing tests).\nvoid ResetAllOptionOccurrences();\n\n/// Reset the command line parser back to its initial state.  This\n/// removes\n/// all options, categories, and subcommands and returns the parser to a state\n/// where no options are supported.\nvoid ResetCommandLineParser();\n\n/// Parses `Arg` into the option handler `Handler`.\nbool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);\n\n} // end namespace cl\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_COMMANDLINE_H\n"}, "84": {"id": 84, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ToolOutputFile.h", "content": "//===- ToolOutputFile.h - Output files for compiler-like tools -----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ToolOutputFile class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TOOLOUTPUTFILE_H\n#define LLVM_SUPPORT_TOOLOUTPUTFILE_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\n/// This class contains a raw_fd_ostream and adds a few extra features commonly\n/// needed for compiler-like tool output files:\n///   - The file is automatically deleted if the process is killed.\n///   - The file is automatically deleted when the ToolOutputFile\n///     object is destroyed unless the client calls keep().\nclass ToolOutputFile {\n  /// This class is declared before the raw_fd_ostream so that it is constructed\n  /// before the raw_fd_ostream is constructed and destructed after the\n  /// raw_fd_ostream is destructed. It installs cleanups in its constructor and\n  /// uninstalls them in its destructor.\n  class CleanupInstaller {\n    /// The name of the file.\n    std::string Filename;\n  public:\n    /// The flag which indicates whether we should not delete the file.\n    bool Keep;\n\n    StringRef getFilename() { return Filename; }\n    explicit CleanupInstaller(StringRef Filename);\n    ~CleanupInstaller();\n  } Installer;\n\n  /// Storage for the stream, if we're owning our own stream. This is\n  /// intentionally declared after Installer.\n  Optional<raw_fd_ostream> OSHolder;\n\n  /// The actual stream to use.\n  raw_fd_ostream *OS;\n\npublic:\n  /// This constructor's arguments are passed to raw_fd_ostream's\n  /// constructor.\n  ToolOutputFile(StringRef Filename, std::error_code &EC,\n                 sys::fs::OpenFlags Flags);\n\n  ToolOutputFile(StringRef Filename, int FD);\n\n  /// Return the contained raw_fd_ostream.\n  raw_fd_ostream &os() { return *OS; }\n\n  /// Return the filename initialized with.\n  StringRef getFilename() { return Installer.getFilename(); }\n\n  /// Indicate that the tool's job wrt this output file has been successful and\n  /// the file should not be deleted.\n  void keep() { Installer.Keep = true; }\n};\n\n} // end llvm namespace\n\n#endif\n"}, "87": {"id": 87, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "content": "//===-- llvm-dwarfdump.cpp - Debug info dumping utility for llvm ----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This program is a utility that works like \"dwarfdump\".\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm-dwarfdump.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFContext.h\"\n#include \"llvm/Object/Archive.h\"\n#include \"llvm/Object/MachOUniversal.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/InitLLVM.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/TargetSelect.h\"\n#include \"llvm/Support/ToolOutputFile.h\"\n#include \"llvm/Support/WithColor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdlib>\n\nusing namespace llvm;\nusing namespace llvm::dwarfdump;\nusing namespace llvm::object;\n\nnamespace {\n/// Parser for options that take an optional offest argument.\n/// @{\nstruct OffsetOption {\n  uint64_t Val = 0;\n  bool HasValue = false;\n  bool IsRequested = false;\n};\nstruct BoolOption : public OffsetOption {};\n} // namespace\n\nnamespace llvm {\nnamespace cl {\ntemplate <>\nclass parser<OffsetOption> final : public basic_parser<OffsetOption> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  /// Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, OffsetOption &Val) {\n    if (Arg == \"\") {\n      Val.Val = 0;\n      Val.HasValue = false;\n      Val.IsRequested = true;\n      return false;\n    }\n    if (Arg.getAsInteger(0, Val.Val))\n      return O.error(\"'\" + Arg + \"' value invalid for integer argument\");\n    Val.HasValue = true;\n    Val.IsRequested = true;\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  StringRef getValueName() const override { return StringRef(\"offset\"); }\n\n  void printOptionDiff(const Option &O, OffsetOption V, OptVal Default,\n                       size_t GlobalWidth) const {\n    printOptionName(O, GlobalWidth);\n    outs() << \"[=offset]\";\n  }\n};\n\ntemplate <> class parser<BoolOption> final : public basic_parser<BoolOption> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  /// Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, BoolOption &Val) {\n    if (Arg != \"\")\n      return O.error(\"this is a flag and does not take a value\");\n    Val.Val = 0;\n    Val.HasValue = false;\n    Val.IsRequested = true;\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, OffsetOption V, OptVal Default,\n                       size_t GlobalWidth) const {\n    printOptionName(O, GlobalWidth);\n  }\n};\n} // namespace cl\n} // namespace llvm\n\n/// @}\n/// Command line options.\n/// @{\n\nnamespace {\nusing namespace cl;\n\nOptionCategory DwarfDumpCategory(\"Specific Options\");\nstatic list<std::string>\n    InputFilenames(Positional, desc(\"<input object files or .dSYM bundles>\"),\n                   ZeroOrMore, cat(DwarfDumpCategory));\n\ncl::OptionCategory SectionCategory(\"Section-specific Dump Options\",\n                                   \"These control which sections are dumped. \"\n                                   \"Where applicable these parameters take an \"\n                                   \"optional =<offset> argument to dump only \"\n                                   \"the entry at the specified offset.\");\n\nstatic opt<bool> DumpAll(\"all\", desc(\"Dump all debug info sections\"),\n                         cat(SectionCategory));\nstatic alias DumpAllAlias(\"a\", desc(\"Alias for -all\"), aliasopt(DumpAll));\n\n// Options for dumping specific sections.\nstatic unsigned DumpType = DIDT_Null;\nstatic std::array<llvm::Optional<uint64_t>, (unsigned)DIDT_ID_Count>\n    DumpOffsets;\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  static opt<OPTION> Dump##ENUM_NAME(CMDLINE_NAME,                             \\\n                                     desc(\"Dump the \" ELF_NAME \" section\"),    \\\n                                     cat(SectionCategory));\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n\nstatic alias DumpDebugFrameAlias(\"eh-frame\", desc(\"Alias for -debug-frame\"),\n                                 NotHidden, cat(SectionCategory),\n                                 aliasopt(DumpDebugFrame));\nstatic list<std::string>\n    ArchFilters(\"arch\",\n                desc(\"Dump debug information for the specified CPU \"\n                     \"architecture only. Architectures may be specified by \"\n                     \"name or by number. This option can be specified \"\n                     \"multiple times, once for each desired architecture.\"),\n                cat(DwarfDumpCategory));\nstatic opt<bool>\n    Diff(\"diff\",\n         desc(\"Emit diff-friendly output by omitting offsets and addresses.\"),\n         cat(DwarfDumpCategory));\nstatic list<std::string>\n    Find(\"find\",\n         desc(\"Search for the exact match for <name> in the accelerator tables \"\n              \"and print the matching debug information entries. When no \"\n              \"accelerator tables are available, the slower but more complete \"\n              \"-name option can be used instead.\"),\n         value_desc(\"name\"), cat(DwarfDumpCategory));\nstatic alias FindAlias(\"f\", desc(\"Alias for -find.\"), aliasopt(Find));\nstatic opt<bool> IgnoreCase(\"ignore-case\",\n                            desc(\"Ignore case distinctions when searching.\"),\n                            value_desc(\"i\"), cat(DwarfDumpCategory));\nstatic alias IgnoreCaseAlias(\"i\", desc(\"Alias for -ignore-case.\"),\n                             aliasopt(IgnoreCase));\nstatic list<std::string> Name(\n    \"name\",\n    desc(\"Find and print all debug info entries whose name (DW_AT_name \"\n         \"attribute) matches the exact text in <pattern>.  When used with the \"\n         \"the -regex option <pattern> is interpreted as a regular expression.\"),\n    value_desc(\"pattern\"), cat(DwarfDumpCategory));\nstatic alias NameAlias(\"n\", desc(\"Alias for -name\"), aliasopt(Name));\nstatic opt<uint64_t>\n    Lookup(\"lookup\",\n           desc(\"Lookup <address> in the debug information and print out any \"\n                \"available file, function, block and line table details.\"),\n           value_desc(\"address\"), cat(DwarfDumpCategory));\nstatic opt<std::string>\n    OutputFilename(\"o\", cl::init(\"-\"),\n                   cl::desc(\"Redirect output to the specified file.\"),\n                   cl::value_desc(\"filename\"), cat(DwarfDumpCategory));\nstatic alias OutputFilenameAlias(\"out-file\", desc(\"Alias for -o.\"),\n                                 aliasopt(OutputFilename));\nstatic opt<bool>\n    UseRegex(\"regex\",\n             desc(\"Treat any <pattern> strings as regular expressions when \"\n                  \"searching instead of just as an exact string match.\"),\n             cat(DwarfDumpCategory));\nstatic alias RegexAlias(\"x\", desc(\"Alias for -regex\"), aliasopt(UseRegex));\nstatic opt<bool>\n    ShowChildren(\"show-children\",\n                 desc(\"Show a debug info entry's children when selectively \"\n                      \"printing entries.\"),\n                 cat(DwarfDumpCategory));\nstatic alias ShowChildrenAlias(\"c\", desc(\"Alias for -show-children.\"),\n                               aliasopt(ShowChildren));\nstatic opt<bool>\n    ShowParents(\"show-parents\",\n                desc(\"Show a debug info entry's parents when selectively \"\n                     \"printing entries.\"),\n                cat(DwarfDumpCategory));\nstatic alias ShowParentsAlias(\"p\", desc(\"Alias for -show-parents.\"),\n                              aliasopt(ShowParents));\nstatic opt<bool>\n    ShowForm(\"show-form\",\n             desc(\"Show DWARF form types after the DWARF attribute types.\"),\n             cat(DwarfDumpCategory));\nstatic alias ShowFormAlias(\"F\", desc(\"Alias for -show-form.\"),\n                           aliasopt(ShowForm), cat(DwarfDumpCategory));\nstatic opt<unsigned>\n    ChildRecurseDepth(\"recurse-depth\",\n                      desc(\"Only recurse to a depth of N when displaying \"\n                           \"children of debug info entries.\"),\n                      cat(DwarfDumpCategory), init(-1U), value_desc(\"N\"));\nstatic alias ChildRecurseDepthAlias(\"r\", desc(\"Alias for -recurse-depth.\"),\n                                    aliasopt(ChildRecurseDepth));\nstatic opt<unsigned>\n    ParentRecurseDepth(\"parent-recurse-depth\",\n                       desc(\"Only recurse to a depth of N when displaying \"\n                            \"parents of debug info entries.\"),\n                       cat(DwarfDumpCategory), init(-1U), value_desc(\"N\"));\nstatic opt<bool>\n    SummarizeTypes(\"summarize-types\",\n                   desc(\"Abbreviate the description of type unit entries.\"),\n                   cat(DwarfDumpCategory));\nstatic cl::opt<bool>\n    Statistics(\"statistics\",\n               cl::desc(\"Emit JSON-formatted debug info quality metrics.\"),\n               cat(DwarfDumpCategory));\nstatic cl::opt<bool>\n    ShowSectionSizes(\"show-section-sizes\",\n                     cl::desc(\"Show the sizes of all debug sections, \"\n                              \"expressed in bytes.\"),\n                     cat(DwarfDumpCategory));\nstatic opt<bool> Verify(\"verify\", desc(\"Verify the DWARF debug info.\"),\n                        cat(DwarfDumpCategory));\nstatic opt<bool> Quiet(\"quiet\", desc(\"Use with -verify to not emit to STDOUT.\"),\n                       cat(DwarfDumpCategory));\nstatic opt<bool> DumpUUID(\"uuid\", desc(\"Show the UUID for each architecture.\"),\n                          cat(DwarfDumpCategory));\nstatic alias DumpUUIDAlias(\"u\", desc(\"Alias for -uuid.\"), aliasopt(DumpUUID));\nstatic opt<bool> Verbose(\"verbose\",\n                         desc(\"Print more low-level encoding details.\"),\n                         cat(DwarfDumpCategory));\nstatic alias VerboseAlias(\"v\", desc(\"Alias for -verbose.\"), aliasopt(Verbose),\n                          cat(DwarfDumpCategory));\nstatic cl::extrahelp\n    HelpResponse(\"\\nPass @FILE as argument to read options from FILE.\\n\");\n} // namespace\n/// @}\n//===----------------------------------------------------------------------===//\n\nstatic void error(StringRef Prefix, std::error_code EC) {\n  if (!EC)\n    return;\n  WithColor::error() << Prefix << \": \" << EC.message() << \"\\n\";\n  exit(1);\n}\n\nstatic DIDumpOptions getDumpOpts(DWARFContext &C) {\n  DIDumpOptions DumpOpts;\n  DumpOpts.DumpType = DumpType;\n  DumpOpts.ChildRecurseDepth = ChildRecurseDepth;\n  DumpOpts.ParentRecurseDepth = ParentRecurseDepth;\n  DumpOpts.ShowAddresses = !Diff;\n  DumpOpts.ShowChildren = ShowChildren;\n  DumpOpts.ShowParents = ShowParents;\n  DumpOpts.ShowForm = ShowForm;\n  DumpOpts.SummarizeTypes = SummarizeTypes;\n  DumpOpts.Verbose = Verbose;\n  DumpOpts.RecoverableErrorHandler = C.getRecoverableErrorHandler();\n  // In -verify mode, print DIEs without children in error messages.\n  if (Verify)\n    return DumpOpts.noImplicitRecursion();\n  return DumpOpts;\n}\n\nstatic uint32_t getCPUType(MachOObjectFile &MachO) {\n  if (MachO.is64Bit())\n    return MachO.getHeader64().cputype;\n  else\n    return MachO.getHeader().cputype;\n}\n\n/// Return true if the object file has not been filtered by an --arch option.\nstatic bool filterArch(ObjectFile &Obj) {\n  if (ArchFilters.empty())\n    return true;\n\n  if (auto *MachO = dyn_cast<MachOObjectFile>(&Obj)) {\n    for (auto Arch : ArchFilters) {\n      // Match architecture number.\n      unsigned Value;\n      if (!StringRef(Arch).getAsInteger(0, Value))\n        if (Value == getCPUType(*MachO))\n          return true;\n\n      // Match as name.\n      if (MachO->getArchTriple().getArchName() == Triple(Arch).getArchName())\n        return true;\n    }\n  }\n  return false;\n}\n\nusing HandlerFn = std::function<bool(ObjectFile &, DWARFContext &DICtx,\n                                     const Twine &, raw_ostream &)>;\n\n/// Print only DIEs that have a certain name.\nstatic bool filterByName(const StringSet<> &Names, DWARFDie Die,\n                         StringRef NameRef, raw_ostream &OS) {\n  DIDumpOptions DumpOpts = getDumpOpts(Die.getDwarfUnit()->getContext());\n  std::string Name =\n      (IgnoreCase && !UseRegex) ? NameRef.lower() : NameRef.str();\n  if (UseRegex) {\n    // Match regular expression.\n    for (auto Pattern : Names.keys()) {\n      Regex RE(Pattern, IgnoreCase ? Regex::IgnoreCase : Regex::NoFlags);\n      std::string Error;\n      if (!RE.isValid(Error)) {\n        errs() << \"error in regular expression: \" << Error << \"\\n\";\n        exit(1);\n      }\n      if (RE.match(Name)) {\n        Die.dump(OS, 0, DumpOpts);\n        return true;\n      }\n    }\n  } else if (Names.count(Name)) {\n    // Match full text.\n    Die.dump(OS, 0, DumpOpts);\n    return true;\n  }\n  return false;\n}\n\n/// Print only DIEs that have a certain name.\nstatic void filterByName(const StringSet<> &Names,\n                         DWARFContext::unit_iterator_range CUs,\n                         raw_ostream &OS) {\n  for (const auto &CU : CUs)\n    for (const auto &Entry : CU->dies()) {\n      DWARFDie Die = {CU.get(), &Entry};\n      if (const char *Name = Die.getName(DINameKind::ShortName))\n        if (filterByName(Names, Die, Name, OS))\n          continue;\n      if (const char *Name = Die.getName(DINameKind::LinkageName))\n        filterByName(Names, Die, Name, OS);\n    }\n}\n\nstatic void getDies(DWARFContext &DICtx, const AppleAcceleratorTable &Accel,\n                    StringRef Name, SmallVectorImpl<DWARFDie> &Dies) {\n  for (const auto &Entry : Accel.equal_range(Name)) {\n    if (llvm::Optional<uint64_t> Off = Entry.getDIESectionOffset()) {\n      if (DWARFDie Die = DICtx.getDIEForOffset(*Off))\n        Dies.push_back(Die);\n    }\n  }\n}\n\nstatic DWARFDie toDie(const DWARFDebugNames::Entry &Entry,\n                      DWARFContext &DICtx) {\n  llvm::Optional<uint64_t> CUOff = Entry.getCUOffset();\n  llvm::Optional<uint64_t> Off = Entry.getDIEUnitOffset();\n  if (!CUOff || !Off)\n    return DWARFDie();\n\n  DWARFCompileUnit *CU = DICtx.getCompileUnitForOffset(*CUOff);\n  if (!CU)\n    return DWARFDie();\n\n  if (llvm::Optional<uint64_t> DWOId = CU->getDWOId()) {\n    // This is a skeleton unit. Look up the DIE in the DWO unit.\n    CU = DICtx.getDWOCompileUnitForHash(*DWOId);\n    if (!CU)\n      return DWARFDie();\n  }\n\n  return CU->getDIEForOffset(CU->getOffset() + *Off);\n}\n\nstatic void getDies(DWARFContext &DICtx, const DWARFDebugNames &Accel,\n                    StringRef Name, SmallVectorImpl<DWARFDie> &Dies) {\n  for (const auto &Entry : Accel.equal_range(Name)) {\n    if (DWARFDie Die = toDie(Entry, DICtx))\n      Dies.push_back(Die);\n  }\n}\n\n/// Print only DIEs that have a certain name.\nstatic void filterByAccelName(ArrayRef<std::string> Names, DWARFContext &DICtx,\n                              raw_ostream &OS) {\n  SmallVector<DWARFDie, 4> Dies;\n  for (const auto &Name : Names) {\n    getDies(DICtx, DICtx.getAppleNames(), Name, Dies);\n    getDies(DICtx, DICtx.getAppleTypes(), Name, Dies);\n    getDies(DICtx, DICtx.getAppleNamespaces(), Name, Dies);\n    getDies(DICtx, DICtx.getDebugNames(), Name, Dies);\n  }\n  llvm::sort(Dies);\n  Dies.erase(std::unique(Dies.begin(), Dies.end()), Dies.end());\n\n  DIDumpOptions DumpOpts = getDumpOpts(DICtx);\n  for (DWARFDie Die : Dies)\n    Die.dump(OS, 0, DumpOpts);\n}\n\n/// Handle the --lookup option and dump the DIEs and line info for the given\n/// address.\n/// TODO: specified Address for --lookup option could relate for several\n/// different sections(in case not-linked object file). llvm-dwarfdump\n/// need to do something with this: extend lookup option with section\n/// information or probably display all matched entries, or something else...\nstatic bool lookup(ObjectFile &Obj, DWARFContext &DICtx, uint64_t Address,\n                   raw_ostream &OS) {\n  auto DIEsForAddr = DICtx.getDIEsForAddress(Lookup);\n\n  if (!DIEsForAddr)\n    return false;\n\n  DIDumpOptions DumpOpts = getDumpOpts(DICtx);\n  DumpOpts.ChildRecurseDepth = 0;\n  DIEsForAddr.CompileUnit->dump(OS, DumpOpts);\n  if (DIEsForAddr.FunctionDIE) {\n    DIEsForAddr.FunctionDIE.dump(OS, 2, DumpOpts);\n    if (DIEsForAddr.BlockDIE)\n      DIEsForAddr.BlockDIE.dump(OS, 4, DumpOpts);\n  }\n\n  // TODO: it is neccessary to set proper SectionIndex here.\n  // object::SectionedAddress::UndefSection works for only absolute addresses.\n  if (DILineInfo LineInfo = DICtx.getLineInfoForAddress(\n          {Lookup, object::SectionedAddress::UndefSection}))\n    LineInfo.dump(OS);\n\n  return true;\n}\n\nstatic bool dumpObjectFile(ObjectFile &Obj, DWARFContext &DICtx,\n                           const Twine &Filename, raw_ostream &OS) {\n  logAllUnhandledErrors(DICtx.loadRegisterInfo(Obj), errs(),\n                        Filename.str() + \": \");\n  // The UUID dump already contains all the same information.\n  if (!(DumpType & DIDT_UUID) || DumpType == DIDT_All)\n    OS << Filename << \":\\tfile format \" << Obj.getFileFormatName() << '\\n';\n\n  // Handle the --lookup option.\n  if (Lookup)\n    return lookup(Obj, DICtx, Lookup, OS);\n\n  // Handle the --name option.\n  if (!Name.empty()) {\n    StringSet<> Names;\n    for (auto name : Name)\n      Names.insert((IgnoreCase && !UseRegex) ? StringRef(name).lower() : name);\n\n    filterByName(Names, DICtx.normal_units(), OS);\n    filterByName(Names, DICtx.dwo_units(), OS);\n    return true;\n  }\n\n  // Handle the --find option and lower it to --debug-info=<offset>.\n  if (!Find.empty()) {\n    filterByAccelName(Find, DICtx, OS);\n    return true;\n  }\n\n  // Dump the complete DWARF structure.\n  DICtx.dump(OS, getDumpOpts(DICtx), DumpOffsets);\n  return true;\n}\n\nstatic bool verifyObjectFile(ObjectFile &Obj, DWARFContext &DICtx,\n                             const Twine &Filename, raw_ostream &OS) {\n  // Verify the DWARF and exit with non-zero exit status if verification\n  // fails.\n  raw_ostream &stream = Quiet ? nulls() : OS;\n  stream << \"Verifying \" << Filename.str() << \":\\tfile format \"\n  << Obj.getFileFormatName() << \"\\n\";\n  bool Result = DICtx.verify(stream, getDumpOpts(DICtx));\n  if (Result)\n    stream << \"No errors.\\n\";\n  else\n    stream << \"Errors detected.\\n\";\n  return Result;\n}\n\nstatic bool handleBuffer(StringRef Filename, MemoryBufferRef Buffer,\n                         HandlerFn HandleObj, raw_ostream &OS);\n\nstatic bool handleArchive(StringRef Filename, Archive &Arch,\n                          HandlerFn HandleObj, raw_ostream &OS) {\n  bool Result = true;\n  Error Err = Error::success();\n  for (auto Child : Arch.children(Err)) {\n    auto BuffOrErr = Child.getMemoryBufferRef();\n    error(Filename, errorToErrorCode(BuffOrErr.takeError()));\n    auto NameOrErr = Child.getName();\n    error(Filename, errorToErrorCode(NameOrErr.takeError()));\n    std::string Name = (Filename + \"(\" + NameOrErr.get() + \")\").str();\n    Result &= handleBuffer(Name, BuffOrErr.get(), HandleObj, OS);\n  }\n  error(Filename, errorToErrorCode(std::move(Err)));\n\n  return Result;\n}\n\nstatic bool handleBuffer(StringRef Filename, MemoryBufferRef Buffer,\n                         HandlerFn HandleObj, raw_ostream &OS) {\n  Expected<std::unique_ptr<Binary>> BinOrErr = object::createBinary(Buffer);\n  error(Filename, errorToErrorCode(BinOrErr.takeError()));\n\n  bool Result = true;\n  auto RecoverableErrorHandler = [&](Error E) {\n    Result = false;\n    WithColor::defaultErrorHandler(std::move(E));\n  };\n  if (auto *Obj = dyn_cast<ObjectFile>(BinOrErr->get())) {\n    if (filterArch(*Obj)) {\n      std::unique_ptr<DWARFContext> DICtx =\n          DWARFContext::create(*Obj, nullptr, \"\", RecoverableErrorHandler);\n      if (!HandleObj(*Obj, *DICtx, Filename, OS))\n        Result = false;\n    }\n  }\n  else if (auto *Fat = dyn_cast<MachOUniversalBinary>(BinOrErr->get()))\n    for (auto &ObjForArch : Fat->objects()) {\n      std::string ObjName =\n          (Filename + \"(\" + ObjForArch.getArchFlagName() + \")\").str();\n      if (auto MachOOrErr = ObjForArch.getAsObjectFile()) {\n        auto &Obj = **MachOOrErr;\n        if (filterArch(Obj)) {\n          std::unique_ptr<DWARFContext> DICtx =\n              DWARFContext::create(Obj, nullptr, \"\", RecoverableErrorHandler);\n          if (!HandleObj(Obj, *DICtx, ObjName, OS))\n            Result = false;\n        }\n        continue;\n      } else\n        consumeError(MachOOrErr.takeError());\n      if (auto ArchiveOrErr = ObjForArch.getAsArchive()) {\n        error(ObjName, errorToErrorCode(ArchiveOrErr.takeError()));\n        if (!handleArchive(ObjName, *ArchiveOrErr.get(), HandleObj, OS))\n          Result = false;\n        continue;\n      } else\n        consumeError(ArchiveOrErr.takeError());\n    }\n  else if (auto *Arch = dyn_cast<Archive>(BinOrErr->get()))\n    Result = handleArchive(Filename, *Arch, HandleObj, OS);\n  return Result;\n}\n\nstatic bool handleFile(StringRef Filename, HandlerFn HandleObj,\n                       raw_ostream &OS) {\n  ErrorOr<std::unique_ptr<MemoryBuffer>> BuffOrErr =\n  MemoryBuffer::getFileOrSTDIN(Filename);\n  error(Filename, BuffOrErr.getError());\n  std::unique_ptr<MemoryBuffer> Buffer = std::move(BuffOrErr.get());\n  return handleBuffer(Filename, *Buffer, HandleObj, OS);\n}\n\n/// If the input path is a .dSYM bundle (as created by the dsymutil tool),\n/// replace it with individual entries for each of the object files inside the\n/// bundle otherwise return the input path.\nstatic std::vector<std::string> expandBundle(const std::string &InputPath) {\n  std::vector<std::string> BundlePaths;\n  SmallString<256> BundlePath(InputPath);\n  // Normalize input path. This is necessary to accept `bundle.dSYM/`.\n  sys::path::remove_dots(BundlePath);\n  // Manually open up the bundle to avoid introducing additional dependencies.\n  if (sys::fs::is_directory(BundlePath) &&\n      sys::path::extension(BundlePath) == \".dSYM\") {\n    std::error_code EC;\n    sys::path::append(BundlePath, \"Contents\", \"Resources\", \"DWARF\");\n    for (sys::fs::directory_iterator Dir(BundlePath, EC), DirEnd;\n         Dir != DirEnd && !EC; Dir.increment(EC)) {\n      const std::string &Path = Dir->path();\n      sys::fs::file_status Status;\n      EC = sys::fs::status(Path, Status);\n      error(Path, EC);\n      switch (Status.type()) {\n      case sys::fs::file_type::regular_file:\n      case sys::fs::file_type::symlink_file:\n      case sys::fs::file_type::type_unknown:\n        BundlePaths.push_back(Path);\n        break;\n      default: /*ignore*/;\n      }\n    }\n    error(BundlePath, EC);\n  }\n  if (!BundlePaths.size())\n    BundlePaths.push_back(InputPath);\n  return BundlePaths;\n}\n\nint main(int argc, char **argv) {\n  InitLLVM X(argc, argv);\n\n  // Flush outs() when printing to errs(). This avoids interleaving output\n  // between the two.\n  errs().tie(&outs());\n\n  llvm::InitializeAllTargetInfos();\n  llvm::InitializeAllTargetMCs();\n\n  HideUnrelatedOptions({&DwarfDumpCategory, &SectionCategory, &ColorCategory});\n  cl::ParseCommandLineOptions(\n      argc, argv,\n      \"pretty-print DWARF debug information in object files\"\n      \" and debug info archives.\\n\");\n\n  // FIXME: Audit interactions between these two options and make them\n  //        compatible.\n  if (Diff && Verbose) {\n    WithColor::error() << \"incompatible arguments: specifying both -diff and \"\n                          \"-verbose is currently not supported\";\n    return 1;\n  }\n\n  std::error_code EC;\n  ToolOutputFile OutputFile(OutputFilename, EC, sys::fs::OF_Text);\n  error(\"Unable to open output file\" + OutputFilename, EC);\n  // Don't remove output file if we exit with an error.\n  OutputFile.keep();\n\n  bool OffsetRequested = false;\n\n  // Defaults to dumping all sections, unless brief mode is specified in which\n  // case only the .debug_info section in dumped.\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  if (Dump##ENUM_NAME.IsRequested) {                                           \\\n    DumpType |= DIDT_##ENUM_NAME;                                              \\\n    if (Dump##ENUM_NAME.HasValue) {                                            \\\n      DumpOffsets[DIDT_ID_##ENUM_NAME] = Dump##ENUM_NAME.Val;                  \\\n      OffsetRequested = true;                                                  \\\n    }                                                                          \\\n  }\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  if (DumpUUID)\n    DumpType |= DIDT_UUID;\n  if (DumpAll)\n    DumpType = DIDT_All;\n  if (DumpType == DIDT_Null) {\n    if (Verbose)\n      DumpType = DIDT_All;\n    else\n      DumpType = DIDT_DebugInfo;\n  }\n\n  // Unless dumping a specific DIE, default to --show-children.\n  if (!ShowChildren && !Verify && !OffsetRequested && Name.empty() && Find.empty())\n    ShowChildren = true;\n\n  // Defaults to a.out if no filenames specified.\n  if (InputFilenames.empty())\n    InputFilenames.push_back(\"a.out\");\n\n  // Expand any .dSYM bundles to the individual object files contained therein.\n  std::vector<std::string> Objects;\n  for (const auto &F : InputFilenames) {\n    auto Objs = expandBundle(F);\n    llvm::append_range(Objects, Objs);\n  }\n\n  bool Success = true;\n  if (Verify) {\n    for (auto Object : Objects)\n      Success &= handleFile(Object, verifyObjectFile, OutputFile.os());\n  } else if (Statistics) {\n    for (auto Object : Objects)\n      Success &= handleFile(Object, collectStatsForObjectFile, OutputFile.os());\n  } else if (ShowSectionSizes) {\n    for (auto Object : Objects)\n      Success &= handleFile(Object, collectObjectSectionSizes, OutputFile.os());\n  } else {\n    for (auto Object : Objects)\n      Success &= handleFile(Object, dumpObjectFile, OutputFile.os());\n  }\n\n  return Success ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 9, "line": 376}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "81a7cec96f9240e665b133908632b8dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 433}, "message": "destructor '~filter_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "6aeb07b2c110c0d8ad8f90a598a70ff4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 433}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "fdb02556ecee6e692cc565a57ba6df55", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 433}, "message": "move constructor 'filter_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "4b21e561d6dc6eef3ee224ce32e8f2a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 455}, "message": "destructor '~StringMapKeyIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "16201e921c7af9c730e8862845e01078", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 455}, "message": "move constructor 'StringMapKeyIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "837cc487024d120190de16efab2126a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 14, "line": 56}, "message": "destructor '~StringMapEntryStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h", "reportHash": "805f5a0c25cc8cc678af520842030259", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 207}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "b04a071ff0c80094511a3f4958986f64", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 509}, "message": "destructor '~mach_header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "a1816cf87690607ff826663d2bf00a92", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 519}, "message": "destructor '~mach_header_64' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "50b603887bd590c535ce4bfa3e69f2ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 939}, "message": "destructor '~fat_arch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "432572a1426df10b5272ca40eded2c78", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 939}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "88abc7e6072e99f49e7126cbcd40fa33", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 939}, "message": "move constructor 'fat_arch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "a78109bc2fa5df394b371eda0723c557", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 947}, "message": "destructor '~fat_arch_64' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "9912133a0f044d349f4fa6a37fc43a62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 947}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "0236cbb7857926e8f63d705b6fbd50be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 947}, "message": "move constructor 'fat_arch_64' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "cf165f010954bc4557db5308033f63ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 83}, "message": "destructor '~AppleAcceleratorTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "b46f0622ac716fea40cbf105ff3c0dbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 84}, "message": "default constructor 'Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "7f5db124b32a079306999afe20dbf936", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 84}, "message": "destructor '~Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "fc312556af9868dcb4c742f78a6fc104", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 95}, "message": "destructor '~HeaderData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "14e61564cfa03be774a4d84cf55965a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 116}, "message": "destructor '~Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "78d16cf9c17efbc7809fd387b23635f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 143}, "message": "destructor '~ValueIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "764fe2d908789886d87274b5540f5634", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 224}, "message": "destructor '~DWARFDebugNames' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "db8d9a1d0399664e9d35235580f099c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 231}, "message": "destructor '~Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "fc312556af9868dcb4c742f78a6fc104", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 249}, "message": "destructor '~AttributeEncoding' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "59a82b003f6363ba837961a88b526eab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 263}, "message": "destructor '~Abbrev' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "cacf6d67372e5e2bb56acacac28f4044", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 263}, "message": "move constructor 'Abbrev' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "c4559265832b25ca92e12633c0b682c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 276}, "message": "destructor '~Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "78d16cf9c17efbc7809fd387b23635f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 349}, "message": "destructor '~NameTableEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "5f88f598aa4e6c916da3ec0b4ae33569", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 349}, "message": "move constructor 'NameTableEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "bcfc34ec8acbe0c854f9df80cdb71987", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 381}, "message": "destructor '~NameIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "61be32aea7915fab21b4ba9ad85ee3af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 469}, "message": "destructor '~ValueIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "764fe2d908789886d87274b5540f5634", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 526}, "message": "destructor '~NameIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "53a9c5771cc5ce5b8e199099617c747f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 526}, "message": "move constructor 'NameIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h", "reportHash": "1bcf5566ca6dd43d9673839ec867e018", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 32, "line": 340}, "message": "destructor '~DIEsForAddress' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h", "reportHash": "3bb5a74f5ece621643d21ad8f1e16aab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 32, "line": 340}, "message": "move constructor 'DIEsForAddress' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h", "reportHash": "6987c8b04eb3902406aedd7148663d3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 34}, "message": "destructor '~UnwindLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "e8e88a0827b1a2a06245e39eec518f87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 34}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "58635f851d4b784b7008e9046df24926", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 34}, "message": "move constructor 'UnwindLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "8d2fbc778a5a1f6af8d44da97b6be853", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 164}, "message": "default constructor 'RegisterLocations' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "4db076e98a121ccafc22a63c7741c270", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 164}, "message": "destructor '~RegisterLocations' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "fe7fdc4ac413fa992930f07171d9c6cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 389}, "message": "destructor '~CFIProgram' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "87f83c2451146ade9a19ee6ad5f6a6a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 396}, "message": "destructor '~Instruction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "0a5e23b583d054b86494241d96eb8259", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 540}, "message": "destructor '~CIE' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h", "reportHash": "fb9edbdc9368b9eb470924c4d7b2839f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 140}, "message": "destructor '~Row' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "reportHash": "3e8c0757043bfd2508c9607d18ad2d02", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 140}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "reportHash": "bbd53717c0ff4f3a51fa8852c8ac4c7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 140}, "message": "move constructor 'Row' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "reportHash": "2b5d898a54e28cb397c3d0d6a19e3647", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 201}, "message": "destructor '~Sequence' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "reportHash": "d2f2d33f5dbdc8fefedfdf420288813a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 201}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "reportHash": "8456e626278988c18b29ff10dbbeeaa8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 201}, "message": "move constructor 'Sequence' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h", "reportHash": "107baaa0ce42a8b1b9ac296c71c691e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 70}, "message": "destructor '~Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "reportHash": "9e2ac0c5f88ce24f7e05678ba3d5b877", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 70}, "message": "move constructor 'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "reportHash": "4f1430726228c8e0b8fb9a5d65076ec0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 73}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "reportHash": "9eda755b89f0a61dd959cf29c7afa19e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 73}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "reportHash": "cc8caf2edf88b03688244d46e8ca9ff1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 82}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "reportHash": "9eda755b89f0a61dd959cf29c7afa19e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 82}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugMacro.h", "reportHash": "cc8caf2edf88b03688244d46e8ca9ff1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 25}, "message": "destructor '~DWARFExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "5cc9dd690fe6af0293dbca5416da91e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 25}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "d6fe6937f57b05bfa532fa04e6f318ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 25}, "message": "move constructor 'DWARFExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "ccac5901ded753f3174b415f4bc76508", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 41, "line": 35}, "message": "destructor '~Operation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "19dfe75fb39efe534d15d674278ab4ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 41, "line": 35}, "message": "move constructor 'Operation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "86f64d313b6bc0021d1f9ee2ef11f9b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 41, "line": 67}, "message": "destructor '~Description' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "d20bba92344ecbc8fa131f27a7bab538", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 41, "line": 67}, "message": "move constructor 'Description' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "ee3c13ef555a8e2fabb5192b81d9b337", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 41, "line": 104}, "message": "destructor '~iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "884e471030f167784c038d99e5c62f9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 41, "line": 104}, "message": "move constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h", "reportHash": "9067f56c86099fe19d951b5b79f52c15", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 31}, "message": "destructor '~CompUnitEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "f4f2366ba469555242cfd10ea4f89c97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 31}, "message": "move constructor 'CompUnitEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "104b42c32c6bc7a0c9f12d62093ff53d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 37}, "message": "destructor '~TypeUnitEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "567069093e6caa5082dc7ce2af0b2d2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 37}, "message": "move constructor 'TypeUnitEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "f0badb42785abdbe78acb138214a709b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 44}, "message": "destructor '~AddressEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "68bf7ff1625c25c7c031b27bcdf518cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 44}, "message": "move constructor 'AddressEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "9e5ecba0d8a39631171bbcbd47796ec9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 51}, "message": "destructor '~SymTableEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "21337a53ae48a88bbe56929fd20f3aa9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 51}, "message": "move constructor 'SymTableEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFGdbIndex.h", "reportHash": "f454c8e9bc9a72da1c86b4b9550a219c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 25}, "message": "destructor '~DWARFTypeUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFTypeUnit.h", "reportHash": "ee79c5145e7cecc9ca94d5dd2e685d8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 47}, "message": "destructor '~DWARFUnitHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "25e323b90f53220aab7851a93c535114", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 120}, "message": "destructor '~DWARFUnitVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "b1706c2d9d0db5c2360ae896dd3aebc3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 53, "line": 83}, "message": "destructor '~Archive' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Archive.h", "reportHash": "0f2481b5a9cb45d601f8216866150cb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 58, "line": 131}, "message": "destructor '~BindRebaseSegInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "0ab39d9eeffa5c2ba3a7ed1d18716119", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 58, "line": 262}, "message": "destructor '~MachOObjectFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "f94152137d3c59de61e6b5f0c32c3842", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 58, "line": 659}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "5f3305851331fcbf578a1582c18519b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 39}, "message": "destructor '~ObjectForArch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachOUniversal.h", "reportHash": "c6642e9bf32f6ac825ceb99f7e2b3660", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 39}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachOUniversal.h", "reportHash": "dc64117b16c41a2fdd5a3629fd81e000", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 39}, "message": "move constructor 'ObjectForArch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachOUniversal.h", "reportHash": "a19c71aa0597ca2c51c5dae9c8a0656a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 113}, "message": "destructor '~object_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachOUniversal.h", "reportHash": "02ecc3d699d37346e5c7dbc243dfa612", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 113}, "message": "move constructor 'object_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachOUniversal.h", "reportHash": "ab57a076ecca4bf393020fecc01e8655", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 69, "line": 537}, "message": "default constructor 'OptionValueBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "3d79b6dd00a1c1ca48386543948757e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 69, "line": 1230}, "message": "default constructor 'OptionDiffPrinter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "4db1435e1b917c492c2f044d7fdf7623", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 1369}, "message": "destructor '~opt_storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "9349b0785b27bb90dcd3106d456efe3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 1419}, "message": "destructor '~opt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "0961dde12029b35d991ef3b51f24b76c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 69, "line": 1511}, "message": "destructor '~opt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "628235f1add36141f729ba452261b677", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 84, "line": 26}, "message": "destructor '~ToolOutputFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ToolOutputFile.h", "reportHash": "41be4c640edbbdf50917fb584bc09538", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 42}, "message": "default constructor 'OffsetOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "0c87284631d31be2d0a596452d4dc651", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 42}, "message": "destructor '~OffsetOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "3df5914f94ec3c9c518a884c7c338b29", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 42}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "4c6375280b9d325a25c30ac57454749c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 42}, "message": "move constructor 'OffsetOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "aff9ddeb200420c4ac7fb8b30d4f3836", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 47}, "message": "default constructor 'BoolOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "9e44e144aaf800576758ac2f5e4765a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 47}, "message": "destructor '~BoolOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "f61e3a55bf988c7bd80c82f4f51e1a7f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 47}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "fe972d17cb20215a0893eb95d80d85bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 47}, "message": "move constructor 'BoolOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "3f0e02b3ae527b7cbb2d109cdbfc23f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 87, "line": 53}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "f0d763b7afa32d5d6d3ce684e7002be0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 87, "line": 85}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "741ec50027008c65f0810749dcc8163c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 87, "line": 522}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "de599a8350c49e0cd2c740c9b6c53ca7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 87, "line": 522}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp", "reportHash": "d14b60cadeb0f8d096cfdc5bf383dc4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
