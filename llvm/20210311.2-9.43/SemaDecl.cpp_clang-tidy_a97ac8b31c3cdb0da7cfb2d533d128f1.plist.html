<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "content": "//===--- SemaDecl.cpp - Semantic Analysis for Declarations ----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements semantic analysis for declarations.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TypeLocBuilder.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/CommentDiagnostic.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/EvaluatedExprVisitor.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/NonTrivialTypeVisitor.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/HeaderSearch.h\" // TODO: Sema shouldn't depend on Lex\n#include \"clang/Lex/Lexer.h\" // TODO: Extract static functions to fix layering.\n#include \"clang/Lex/ModuleLoader.h\" // TODO: Sema shouldn't depend on Lex\n#include \"clang/Lex/Preprocessor.h\" // Included for isCodeCompletionEnabled()\n#include \"clang/Sema/CXXFieldCollector.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/DelayedDiagnostic.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/ParsedTemplate.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/Triple.h\"\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <unordered_map>\n\nusing namespace clang;\nusing namespace sema;\n\nSema::DeclGroupPtrTy Sema::ConvertDeclToDeclGroup(Decl *Ptr, Decl *OwnedType) {\n  if (OwnedType) {\n    Decl *Group[2] = { OwnedType, Ptr };\n    return DeclGroupPtrTy::make(DeclGroupRef::Create(Context, Group, 2));\n  }\n\n  return DeclGroupPtrTy::make(DeclGroupRef(Ptr));\n}\n\nnamespace {\n\nclass TypeNameValidatorCCC final : public CorrectionCandidateCallback {\n public:\n   TypeNameValidatorCCC(bool AllowInvalid, bool WantClass = false,\n                        bool AllowTemplates = false,\n                        bool AllowNonTemplates = true)\n       : AllowInvalidDecl(AllowInvalid), WantClassName(WantClass),\n         AllowTemplates(AllowTemplates), AllowNonTemplates(AllowNonTemplates) {\n     WantExpressionKeywords = false;\n     WantCXXNamedCasts = false;\n     WantRemainingKeywords = false;\n  }\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    if (NamedDecl *ND = candidate.getCorrectionDecl()) {\n      if (!AllowInvalidDecl && ND->isInvalidDecl())\n        return false;\n\n      if (getAsTypeTemplateDecl(ND))\n        return AllowTemplates;\n\n      bool IsType = isa<TypeDecl>(ND) || isa<ObjCInterfaceDecl>(ND);\n      if (!IsType)\n        return false;\n\n      if (AllowNonTemplates)\n        return true;\n\n      // An injected-class-name of a class template (specialization) is valid\n      // as a template or as a non-template.\n      if (AllowTemplates) {\n        auto *RD = dyn_cast<CXXRecordDecl>(ND);\n        if (!RD || !RD->isInjectedClassName())\n          return false;\n        RD = cast<CXXRecordDecl>(RD->getDeclContext());\n        return RD->getDescribedClassTemplate() ||\n               isa<ClassTemplateSpecializationDecl>(RD);\n      }\n\n      return false;\n    }\n\n    return !WantClassName && candidate.isKeyword();\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<TypeNameValidatorCCC>(*this);\n  }\n\n private:\n  bool AllowInvalidDecl;\n  bool WantClassName;\n  bool AllowTemplates;\n  bool AllowNonTemplates;\n};\n\n} // end anonymous namespace\n\n/// Determine whether the token kind starts a simple-type-specifier.\nbool Sema::isSimpleTypeSpecifier(tok::TokenKind Kind) const {\n  switch (Kind) {\n  // FIXME: Take into account the current language when deciding whether a\n  // token kind is a valid type specifier\n  case tok::kw_short:\n  case tok::kw_long:\n  case tok::kw___int64:\n  case tok::kw___int128:\n  case tok::kw_signed:\n  case tok::kw_unsigned:\n  case tok::kw_void:\n  case tok::kw_char:\n  case tok::kw_int:\n  case tok::kw_half:\n  case tok::kw_float:\n  case tok::kw_double:\n  case tok::kw___bf16:\n  case tok::kw__Float16:\n  case tok::kw___float128:\n  case tok::kw_wchar_t:\n  case tok::kw_bool:\n  case tok::kw___underlying_type:\n  case tok::kw___auto_type:\n    return true;\n\n  case tok::annot_typename:\n  case tok::kw_char16_t:\n  case tok::kw_char32_t:\n  case tok::kw_typeof:\n  case tok::annot_decltype:\n  case tok::kw_decltype:\n    return getLangOpts().CPlusPlus;\n\n  case tok::kw_char8_t:\n    return getLangOpts().Char8;\n\n  default:\n    break;\n  }\n\n  return false;\n}\n\nnamespace {\nenum class UnqualifiedTypeNameLookupResult {\n  NotFound,\n  FoundNonType,\n  FoundType\n};\n} // end anonymous namespace\n\n/// Tries to perform unqualified lookup of the type decls in bases for\n/// dependent class.\n/// \\return \\a NotFound if no any decls is found, \\a FoundNotType if found not a\n/// type decl, \\a FoundType if only type decls are found.\nstatic UnqualifiedTypeNameLookupResult\nlookupUnqualifiedTypeNameInBase(Sema &S, const IdentifierInfo &II,\n                                SourceLocation NameLoc,\n                                const CXXRecordDecl *RD) {\n  if (!RD->hasDefinition())\n    return UnqualifiedTypeNameLookupResult::NotFound;\n  // Look for type decls in base classes.\n  UnqualifiedTypeNameLookupResult FoundTypeDecl =\n      UnqualifiedTypeNameLookupResult::NotFound;\n  for (const auto &Base : RD->bases()) {\n    const CXXRecordDecl *BaseRD = nullptr;\n    if (auto *BaseTT = Base.getType()->getAs<TagType>())\n      BaseRD = BaseTT->getAsCXXRecordDecl();\n    else if (auto *TST = Base.getType()->getAs<TemplateSpecializationType>()) {\n      // Look for type decls in dependent base classes that have known primary\n      // templates.\n      if (!TST || !TST->isDependentType())\n        continue;\n      auto *TD = TST->getTemplateName().getAsTemplateDecl();\n      if (!TD)\n        continue;\n      if (auto *BasePrimaryTemplate =\n          dyn_cast_or_null<CXXRecordDecl>(TD->getTemplatedDecl())) {\n        if (BasePrimaryTemplate->getCanonicalDecl() != RD->getCanonicalDecl())\n          BaseRD = BasePrimaryTemplate;\n        else if (auto *CTD = dyn_cast<ClassTemplateDecl>(TD)) {\n          if (const ClassTemplatePartialSpecializationDecl *PS =\n                  CTD->findPartialSpecialization(Base.getType()))\n            if (PS->getCanonicalDecl() != RD->getCanonicalDecl())\n              BaseRD = PS;\n        }\n      }\n    }\n    if (BaseRD) {\n      for (NamedDecl *ND : BaseRD->lookup(&II)) {\n        if (!isa<TypeDecl>(ND))\n          return UnqualifiedTypeNameLookupResult::FoundNonType;\n        FoundTypeDecl = UnqualifiedTypeNameLookupResult::FoundType;\n      }\n      if (FoundTypeDecl == UnqualifiedTypeNameLookupResult::NotFound) {\n        switch (lookupUnqualifiedTypeNameInBase(S, II, NameLoc, BaseRD)) {\n        case UnqualifiedTypeNameLookupResult::FoundNonType:\n          return UnqualifiedTypeNameLookupResult::FoundNonType;\n        case UnqualifiedTypeNameLookupResult::FoundType:\n          FoundTypeDecl = UnqualifiedTypeNameLookupResult::FoundType;\n          break;\n        case UnqualifiedTypeNameLookupResult::NotFound:\n          break;\n        }\n      }\n    }\n  }\n\n  return FoundTypeDecl;\n}\n\nstatic ParsedType recoverFromTypeInKnownDependentBase(Sema &S,\n                                                      const IdentifierInfo &II,\n                                                      SourceLocation NameLoc) {\n  // Lookup in the parent class template context, if any.\n  const CXXRecordDecl *RD = nullptr;\n  UnqualifiedTypeNameLookupResult FoundTypeDecl =\n      UnqualifiedTypeNameLookupResult::NotFound;\n  for (DeclContext *DC = S.CurContext;\n       DC && FoundTypeDecl == UnqualifiedTypeNameLookupResult::NotFound;\n       DC = DC->getParent()) {\n    // Look for type decls in dependent base classes that have known primary\n    // templates.\n    RD = dyn_cast<CXXRecordDecl>(DC);\n    if (RD && RD->getDescribedClassTemplate())\n      FoundTypeDecl = lookupUnqualifiedTypeNameInBase(S, II, NameLoc, RD);\n  }\n  if (FoundTypeDecl != UnqualifiedTypeNameLookupResult::FoundType)\n    return nullptr;\n\n  // We found some types in dependent base classes.  Recover as if the user\n  // wrote 'typename MyClass::II' instead of 'II'.  We'll fully resolve the\n  // lookup during template instantiation.\n  S.Diag(NameLoc, diag::ext_found_in_dependent_base) << &II;\n\n  ASTContext &Context = S.Context;\n  auto *NNS = NestedNameSpecifier::Create(Context, nullptr, false,\n                                          cast<Type>(Context.getRecordType(RD)));\n  QualType T = Context.getDependentNameType(ETK_Typename, NNS, &II);\n\n  CXXScopeSpec SS;\n  SS.MakeTrivial(Context, NNS, SourceRange(NameLoc));\n\n  TypeLocBuilder Builder;\n  DependentNameTypeLoc DepTL = Builder.push<DependentNameTypeLoc>(T);\n  DepTL.setNameLoc(NameLoc);\n  DepTL.setElaboratedKeywordLoc(SourceLocation());\n  DepTL.setQualifierLoc(SS.getWithLocInContext(Context));\n  return S.CreateParsedType(T, Builder.getTypeSourceInfo(Context, T));\n}\n\n/// If the identifier refers to a type name within this scope,\n/// return the declaration of that type.\n///\n/// This routine performs ordinary name lookup of the identifier II\n/// within the given scope, with optional C++ scope specifier SS, to\n/// determine whether the name refers to a type. If so, returns an\n/// opaque pointer (actually a QualType) corresponding to that\n/// type. Otherwise, returns NULL.\nParsedType Sema::getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,\n                             Scope *S, CXXScopeSpec *SS,\n                             bool isClassName, bool HasTrailingDot,\n                             ParsedType ObjectTypePtr,\n                             bool IsCtorOrDtorName,\n                             bool WantNontrivialTypeSourceInfo,\n                             bool IsClassTemplateDeductionContext,\n                             IdentifierInfo **CorrectedII) {\n  // FIXME: Consider allowing this outside C++1z mode as an extension.\n  bool AllowDeducedTemplate = IsClassTemplateDeductionContext &&\n                              getLangOpts().CPlusPlus17 && !IsCtorOrDtorName &&\n                              !isClassName && !HasTrailingDot;\n\n  // Determine where we will perform name lookup.\n  DeclContext *LookupCtx = nullptr;\n  if (ObjectTypePtr) {\n    QualType ObjectType = ObjectTypePtr.get();\n    if (ObjectType->isRecordType())\n      LookupCtx = computeDeclContext(ObjectType);\n  } else if (SS && SS->isNotEmpty()) {\n    LookupCtx = computeDeclContext(*SS, false);\n\n    if (!LookupCtx) {\n      if (isDependentScopeSpecifier(*SS)) {\n        // C++ [temp.res]p3:\n        //   A qualified-id that refers to a type and in which the\n        //   nested-name-specifier depends on a template-parameter (14.6.2)\n        //   shall be prefixed by the keyword typename to indicate that the\n        //   qualified-id denotes a type, forming an\n        //   elaborated-type-specifier (7.1.5.3).\n        //\n        // We therefore do not perform any name lookup if the result would\n        // refer to a member of an unknown specialization.\n        if (!isClassName && !IsCtorOrDtorName)\n          return nullptr;\n\n        // We know from the grammar that this name refers to a type,\n        // so build a dependent node to describe the type.\n        if (WantNontrivialTypeSourceInfo)\n          return ActOnTypenameType(S, SourceLocation(), *SS, II, NameLoc).get();\n\n        NestedNameSpecifierLoc QualifierLoc = SS->getWithLocInContext(Context);\n        QualType T = CheckTypenameType(ETK_None, SourceLocation(), QualifierLoc,\n                                       II, NameLoc);\n        return ParsedType::make(T);\n      }\n\n      return nullptr;\n    }\n\n    if (!LookupCtx->isDependentContext() &&\n        RequireCompleteDeclContext(*SS, LookupCtx))\n      return nullptr;\n  }\n\n  // FIXME: LookupNestedNameSpecifierName isn't the right kind of\n  // lookup for class-names.\n  LookupNameKind Kind = isClassName ? LookupNestedNameSpecifierName :\n                                      LookupOrdinaryName;\n  LookupResult Result(*this, &II, NameLoc, Kind);\n  if (LookupCtx) {\n    // Perform \"qualified\" name lookup into the declaration context we\n    // computed, which is either the type of the base of a member access\n    // expression or the declaration context associated with a prior\n    // nested-name-specifier.\n    LookupQualifiedName(Result, LookupCtx);\n\n    if (ObjectTypePtr && Result.empty()) {\n      // C++ [basic.lookup.classref]p3:\n      //   If the unqualified-id is ~type-name, the type-name is looked up\n      //   in the context of the entire postfix-expression. If the type T of\n      //   the object expression is of a class type C, the type-name is also\n      //   looked up in the scope of class C. At least one of the lookups shall\n      //   find a name that refers to (possibly cv-qualified) T.\n      LookupName(Result, S);\n    }\n  } else {\n    // Perform unqualified name lookup.\n    LookupName(Result, S);\n\n    // For unqualified lookup in a class template in MSVC mode, look into\n    // dependent base classes where the primary class template is known.\n    if (Result.empty() && getLangOpts().MSVCCompat && (!SS || SS->isEmpty())) {\n      if (ParsedType TypeInBase =\n              recoverFromTypeInKnownDependentBase(*this, II, NameLoc))\n        return TypeInBase;\n    }\n  }\n\n  NamedDecl *IIDecl = nullptr;\n  switch (Result.getResultKind()) {\n  case LookupResult::NotFound:\n  case LookupResult::NotFoundInCurrentInstantiation:\n    if (CorrectedII) {\n      TypeNameValidatorCCC CCC(/*AllowInvalid=*/true, isClassName,\n                               AllowDeducedTemplate);\n      TypoCorrection Correction = CorrectTypo(Result.getLookupNameInfo(), Kind,\n                                              S, SS, CCC, CTK_ErrorRecovery);\n      IdentifierInfo *NewII = Correction.getCorrectionAsIdentifierInfo();\n      TemplateTy Template;\n      bool MemberOfUnknownSpecialization;\n      UnqualifiedId TemplateName;\n      TemplateName.setIdentifier(NewII, NameLoc);\n      NestedNameSpecifier *NNS = Correction.getCorrectionSpecifier();\n      CXXScopeSpec NewSS, *NewSSPtr = SS;\n      if (SS && NNS) {\n        NewSS.MakeTrivial(Context, NNS, SourceRange(NameLoc));\n        NewSSPtr = &NewSS;\n      }\n      if (Correction && (NNS || NewII != &II) &&\n          // Ignore a correction to a template type as the to-be-corrected\n          // identifier is not a template (typo correction for template names\n          // is handled elsewhere).\n          !(getLangOpts().CPlusPlus && NewSSPtr &&\n            isTemplateName(S, *NewSSPtr, false, TemplateName, nullptr, false,\n                           Template, MemberOfUnknownSpecialization))) {\n        ParsedType Ty = getTypeName(*NewII, NameLoc, S, NewSSPtr,\n                                    isClassName, HasTrailingDot, ObjectTypePtr,\n                                    IsCtorOrDtorName,\n                                    WantNontrivialTypeSourceInfo,\n                                    IsClassTemplateDeductionContext);\n        if (Ty) {\n          diagnoseTypo(Correction,\n                       PDiag(diag::err_unknown_type_or_class_name_suggest)\n                         << Result.getLookupName() << isClassName);\n          if (SS && NNS)\n            SS->MakeTrivial(Context, NNS, SourceRange(NameLoc));\n          *CorrectedII = NewII;\n          return Ty;\n        }\n      }\n    }\n    // If typo correction failed or was not performed, fall through\n    LLVM_FALLTHROUGH;\n  case LookupResult::FoundOverloaded:\n  case LookupResult::FoundUnresolvedValue:\n    Result.suppressDiagnostics();\n    return nullptr;\n\n  case LookupResult::Ambiguous:\n    // Recover from type-hiding ambiguities by hiding the type.  We'll\n    // do the lookup again when looking for an object, and we can\n    // diagnose the error then.  If we don't do this, then the error\n    // about hiding the type will be immediately followed by an error\n    // that only makes sense if the identifier was treated like a type.\n    if (Result.getAmbiguityKind() == LookupResult::AmbiguousTagHiding) {\n      Result.suppressDiagnostics();\n      return nullptr;\n    }\n\n    // Look to see if we have a type anywhere in the list of results.\n    for (LookupResult::iterator Res = Result.begin(), ResEnd = Result.end();\n         Res != ResEnd; ++Res) {\n      if (isa<TypeDecl>(*Res) || isa<ObjCInterfaceDecl>(*Res) ||\n          (AllowDeducedTemplate && getAsTypeTemplateDecl(*Res))) {\n        if (!IIDecl || (*Res)->getLocation() < IIDecl->getLocation())\n          IIDecl = *Res;\n      }\n    }\n\n    if (!IIDecl) {\n      // None of the entities we found is a type, so there is no way\n      // to even assume that the result is a type. In this case, don't\n      // complain about the ambiguity. The parser will either try to\n      // perform this lookup again (e.g., as an object name), which\n      // will produce the ambiguity, or will complain that it expected\n      // a type name.\n      Result.suppressDiagnostics();\n      return nullptr;\n    }\n\n    // We found a type within the ambiguous lookup; diagnose the\n    // ambiguity and then return that type. This might be the right\n    // answer, or it might not be, but it suppresses any attempt to\n    // perform the name lookup again.\n    break;\n\n  case LookupResult::Found:\n    IIDecl = Result.getFoundDecl();\n    break;\n  }\n\n  assert(IIDecl && \"Didn't find decl\");\n\n  QualType T;\n  if (TypeDecl *TD = dyn_cast<TypeDecl>(IIDecl)) {\n    // C++ [class.qual]p2: A lookup that would find the injected-class-name\n    // instead names the constructors of the class, except when naming a class.\n    // This is ill-formed when we're not actually forming a ctor or dtor name.\n    auto *LookupRD = dyn_cast_or_null<CXXRecordDecl>(LookupCtx);\n    auto *FoundRD = dyn_cast<CXXRecordDecl>(TD);\n    if (!isClassName && !IsCtorOrDtorName && LookupRD && FoundRD &&\n        FoundRD->isInjectedClassName() &&\n        declaresSameEntity(LookupRD, cast<Decl>(FoundRD->getParent())))\n      Diag(NameLoc, diag::err_out_of_line_qualified_id_type_names_constructor)\n          << &II << /*Type*/1;\n\n    DiagnoseUseOfDecl(IIDecl, NameLoc);\n\n    T = Context.getTypeDeclType(TD);\n    MarkAnyDeclReferenced(TD->getLocation(), TD, /*OdrUse=*/false);\n  } else if (ObjCInterfaceDecl *IDecl = dyn_cast<ObjCInterfaceDecl>(IIDecl)) {\n    (void)DiagnoseUseOfDecl(IDecl, NameLoc);\n    if (!HasTrailingDot)\n      T = Context.getObjCInterfaceType(IDecl);\n  } else if (AllowDeducedTemplate) {\n    if (auto *TD = getAsTypeTemplateDecl(IIDecl))\n      T = Context.getDeducedTemplateSpecializationType(TemplateName(TD),\n                                                       QualType(), false);\n  }\n\n  if (T.isNull()) {\n    // If it's not plausibly a type, suppress diagnostics.\n    Result.suppressDiagnostics();\n    return nullptr;\n  }\n\n  // NOTE: avoid constructing an ElaboratedType(Loc) if this is a\n  // constructor or destructor name (in such a case, the scope specifier\n  // will be attached to the enclosing Expr or Decl node).\n  if (SS && SS->isNotEmpty() && !IsCtorOrDtorName &&\n      !isa<ObjCInterfaceDecl>(IIDecl)) {\n    if (WantNontrivialTypeSourceInfo) {\n      // Construct a type with type-source information.\n      TypeLocBuilder Builder;\n      Builder.pushTypeSpec(T).setNameLoc(NameLoc);\n\n      T = getElaboratedType(ETK_None, *SS, T);\n      ElaboratedTypeLoc ElabTL = Builder.push<ElaboratedTypeLoc>(T);\n      ElabTL.setElaboratedKeywordLoc(SourceLocation());\n      ElabTL.setQualifierLoc(SS->getWithLocInContext(Context));\n      return CreateParsedType(T, Builder.getTypeSourceInfo(Context, T));\n    } else {\n      T = getElaboratedType(ETK_None, *SS, T);\n    }\n  }\n\n  return ParsedType::make(T);\n}\n\n// Builds a fake NNS for the given decl context.\nstatic NestedNameSpecifier *\nsynthesizeCurrentNestedNameSpecifier(ASTContext &Context, DeclContext *DC) {\n  for (;; DC = DC->getLookupParent()) {\n    DC = DC->getPrimaryContext();\n    auto *ND = dyn_cast<NamespaceDecl>(DC);\n    if (ND && !ND->isInline() && !ND->isAnonymousNamespace())\n      return NestedNameSpecifier::Create(Context, nullptr, ND);\n    else if (auto *RD = dyn_cast<CXXRecordDecl>(DC))\n      return NestedNameSpecifier::Create(Context, nullptr, RD->isTemplateDecl(),\n                                         RD->getTypeForDecl());\n    else if (isa<TranslationUnitDecl>(DC))\n      return NestedNameSpecifier::GlobalSpecifier(Context);\n  }\n  llvm_unreachable(\"something isn't in TU scope?\");\n}\n\n/// Find the parent class with dependent bases of the innermost enclosing method\n/// context. Do not look for enclosing CXXRecordDecls directly, or we will end\n/// up allowing unqualified dependent type names at class-level, which MSVC\n/// correctly rejects.\nstatic const CXXRecordDecl *\nfindRecordWithDependentBasesOfEnclosingMethod(const DeclContext *DC) {\n  for (; DC && DC->isDependentContext(); DC = DC->getLookupParent()) {\n    DC = DC->getPrimaryContext();\n    if (const auto *MD = dyn_cast<CXXMethodDecl>(DC))\n      if (MD->getParent()->hasAnyDependentBases())\n        return MD->getParent();\n  }\n  return nullptr;\n}\n\nParsedType Sema::ActOnMSVCUnknownTypeName(const IdentifierInfo &II,\n                                          SourceLocation NameLoc,\n                                          bool IsTemplateTypeArg) {\n  assert(getLangOpts().MSVCCompat && \"shouldn't be called in non-MSVC mode\");\n\n  NestedNameSpecifier *NNS = nullptr;\n  if (IsTemplateTypeArg && getCurScope()->isTemplateParamScope()) {\n    // If we weren't able to parse a default template argument, delay lookup\n    // until instantiation time by making a non-dependent DependentTypeName. We\n    // pretend we saw a NestedNameSpecifier referring to the current scope, and\n    // lookup is retried.\n    // FIXME: This hurts our diagnostic quality, since we get errors like \"no\n    // type named 'Foo' in 'current_namespace'\" when the user didn't write any\n    // name specifiers.\n    NNS = synthesizeCurrentNestedNameSpecifier(Context, CurContext);\n    Diag(NameLoc, diag::ext_ms_delayed_template_argument) << &II;\n  } else if (const CXXRecordDecl *RD =\n                 findRecordWithDependentBasesOfEnclosingMethod(CurContext)) {\n    // Build a DependentNameType that will perform lookup into RD at\n    // instantiation time.\n    NNS = NestedNameSpecifier::Create(Context, nullptr, RD->isTemplateDecl(),\n                                      RD->getTypeForDecl());\n\n    // Diagnose that this identifier was undeclared, and retry the lookup during\n    // template instantiation.\n    Diag(NameLoc, diag::ext_undeclared_unqual_id_with_dependent_base) << &II\n                                                                      << RD;\n  } else {\n    // This is not a situation that we should recover from.\n    return ParsedType();\n  }\n\n  QualType T = Context.getDependentNameType(ETK_None, NNS, &II);\n\n  // Build type location information.  We synthesized the qualifier, so we have\n  // to build a fake NestedNameSpecifierLoc.\n  NestedNameSpecifierLocBuilder NNSLocBuilder;\n  NNSLocBuilder.MakeTrivial(Context, NNS, SourceRange(NameLoc));\n  NestedNameSpecifierLoc QualifierLoc = NNSLocBuilder.getWithLocInContext(Context);\n\n  TypeLocBuilder Builder;\n  DependentNameTypeLoc DepTL = Builder.push<DependentNameTypeLoc>(T);\n  DepTL.setNameLoc(NameLoc);\n  DepTL.setElaboratedKeywordLoc(SourceLocation());\n  DepTL.setQualifierLoc(QualifierLoc);\n  return CreateParsedType(T, Builder.getTypeSourceInfo(Context, T));\n}\n\n/// isTagName() - This method is called *for error recovery purposes only*\n/// to determine if the specified name is a valid tag name (\"struct foo\").  If\n/// so, this returns the TST for the tag corresponding to it (TST_enum,\n/// TST_union, TST_struct, TST_interface, TST_class).  This is used to diagnose\n/// cases in C where the user forgot to specify the tag.\nDeclSpec::TST Sema::isTagName(IdentifierInfo &II, Scope *S) {\n  // Do a tag name lookup in this scope.\n  LookupResult R(*this, &II, SourceLocation(), LookupTagName);\n  LookupName(R, S, false);\n  R.suppressDiagnostics();\n  if (R.getResultKind() == LookupResult::Found)\n    if (const TagDecl *TD = R.getAsSingle<TagDecl>()) {\n      switch (TD->getTagKind()) {\n      case TTK_Struct: return DeclSpec::TST_struct;\n      case TTK_Interface: return DeclSpec::TST_interface;\n      case TTK_Union:  return DeclSpec::TST_union;\n      case TTK_Class:  return DeclSpec::TST_class;\n      case TTK_Enum:   return DeclSpec::TST_enum;\n      }\n    }\n\n  return DeclSpec::TST_unspecified;\n}\n\n/// isMicrosoftMissingTypename - In Microsoft mode, within class scope,\n/// if a CXXScopeSpec's type is equal to the type of one of the base classes\n/// then downgrade the missing typename error to a warning.\n/// This is needed for MSVC compatibility; Example:\n/// @code\n/// template<class T> class A {\n/// public:\n///   typedef int TYPE;\n/// };\n/// template<class T> class B : public A<T> {\n/// public:\n///   A<T>::TYPE a; // no typename required because A<T> is a base class.\n/// };\n/// @endcode\nbool Sema::isMicrosoftMissingTypename(const CXXScopeSpec *SS, Scope *S) {\n  if (CurContext->isRecord()) {\n    if (SS->getScopeRep()->getKind() == NestedNameSpecifier::Super)\n      return true;\n\n    const Type *Ty = SS->getScopeRep()->getAsType();\n\n    CXXRecordDecl *RD = cast<CXXRecordDecl>(CurContext);\n    for (const auto &Base : RD->bases())\n      if (Ty && Context.hasSameUnqualifiedType(QualType(Ty, 1), Base.getType()))\n        return true;\n    return S->isFunctionPrototypeScope();\n  }\n  return CurContext->isFunctionOrMethod() || S->isFunctionPrototypeScope();\n}\n\nvoid Sema::DiagnoseUnknownTypeName(IdentifierInfo *&II,\n                                   SourceLocation IILoc,\n                                   Scope *S,\n                                   CXXScopeSpec *SS,\n                                   ParsedType &SuggestedType,\n                                   bool IsTemplateName) {\n  // Don't report typename errors for editor placeholders.\n  if (II->isEditorPlaceholder())\n    return;\n  // We don't have anything to suggest (yet).\n  SuggestedType = nullptr;\n\n  // There may have been a typo in the name of the type. Look up typo\n  // results, in case we have something that we can suggest.\n  TypeNameValidatorCCC CCC(/*AllowInvalid=*/false, /*WantClass=*/false,\n                           /*AllowTemplates=*/IsTemplateName,\n                           /*AllowNonTemplates=*/!IsTemplateName);\n  if (TypoCorrection Corrected =\n          CorrectTypo(DeclarationNameInfo(II, IILoc), LookupOrdinaryName, S, SS,\n                      CCC, CTK_ErrorRecovery)) {\n    // FIXME: Support error recovery for the template-name case.\n    bool CanRecover = !IsTemplateName;\n    if (Corrected.isKeyword()) {\n      // We corrected to a keyword.\n      diagnoseTypo(Corrected,\n                   PDiag(IsTemplateName ? diag::err_no_template_suggest\n                                        : diag::err_unknown_typename_suggest)\n                       << II);\n      II = Corrected.getCorrectionAsIdentifierInfo();\n    } else {\n      // We found a similarly-named type or interface; suggest that.\n      if (!SS || !SS->isSet()) {\n        diagnoseTypo(Corrected,\n                     PDiag(IsTemplateName ? diag::err_no_template_suggest\n                                          : diag::err_unknown_typename_suggest)\n                         << II, CanRecover);\n      } else if (DeclContext *DC = computeDeclContext(*SS, false)) {\n        std::string CorrectedStr(Corrected.getAsString(getLangOpts()));\n        bool DroppedSpecifier = Corrected.WillReplaceSpecifier() &&\n                                II->getName().equals(CorrectedStr);\n        diagnoseTypo(Corrected,\n                     PDiag(IsTemplateName\n                               ? diag::err_no_member_template_suggest\n                               : diag::err_unknown_nested_typename_suggest)\n                         << II << DC << DroppedSpecifier << SS->getRange(),\n                     CanRecover);\n      } else {\n        llvm_unreachable(\"could not have corrected a typo here\");\n      }\n\n      if (!CanRecover)\n        return;\n\n      CXXScopeSpec tmpSS;\n      if (Corrected.getCorrectionSpecifier())\n        tmpSS.MakeTrivial(Context, Corrected.getCorrectionSpecifier(),\n                          SourceRange(IILoc));\n      // FIXME: Support class template argument deduction here.\n      SuggestedType =\n          getTypeName(*Corrected.getCorrectionAsIdentifierInfo(), IILoc, S,\n                      tmpSS.isSet() ? &tmpSS : SS, false, false, nullptr,\n                      /*IsCtorOrDtorName=*/false,\n                      /*WantNontrivialTypeSourceInfo=*/true);\n    }\n    return;\n  }\n\n  if (getLangOpts().CPlusPlus && !IsTemplateName) {\n    // See if II is a class template that the user forgot to pass arguments to.\n    UnqualifiedId Name;\n    Name.setIdentifier(II, IILoc);\n    CXXScopeSpec EmptySS;\n    TemplateTy TemplateResult;\n    bool MemberOfUnknownSpecialization;\n    if (isTemplateName(S, SS ? *SS : EmptySS, /*hasTemplateKeyword=*/false,\n                       Name, nullptr, true, TemplateResult,\n                       MemberOfUnknownSpecialization) == TNK_Type_template) {\n      diagnoseMissingTemplateArguments(TemplateResult.get(), IILoc);\n      return;\n    }\n  }\n\n  // FIXME: Should we move the logic that tries to recover from a missing tag\n  // (struct, union, enum) from Parser::ParseImplicitInt here, instead?\n\n  if (!SS || (!SS->isSet() && !SS->isInvalid()))\n    Diag(IILoc, IsTemplateName ? diag::err_no_template\n                               : diag::err_unknown_typename)\n        << II;\n  else if (DeclContext *DC = computeDeclContext(*SS, false))\n    Diag(IILoc, IsTemplateName ? diag::err_no_member_template\n                               : diag::err_typename_nested_not_found)\n        << II << DC << SS->getRange();\n  else if (SS->isValid() && SS->getScopeRep()->containsErrors()) {\n    SuggestedType =\n        ActOnTypenameType(S, SourceLocation(), *SS, *II, IILoc).get();\n  } else if (isDependentScopeSpecifier(*SS)) {\n    unsigned DiagID = diag::err_typename_missing;\n    if (getLangOpts().MSVCCompat && isMicrosoftMissingTypename(SS, S))\n      DiagID = diag::ext_typename_missing;\n\n    Diag(SS->getRange().getBegin(), DiagID)\n      << SS->getScopeRep() << II->getName()\n      << SourceRange(SS->getRange().getBegin(), IILoc)\n      << FixItHint::CreateInsertion(SS->getRange().getBegin(), \"typename \");\n    SuggestedType = ActOnTypenameType(S, SourceLocation(),\n                                      *SS, *II, IILoc).get();\n  } else {\n    assert(SS && SS->isInvalid() &&\n           \"Invalid scope specifier has already been diagnosed\");\n  }\n}\n\n/// Determine whether the given result set contains either a type name\n/// or\nstatic bool isResultTypeOrTemplate(LookupResult &R, const Token &NextToken) {\n  bool CheckTemplate = R.getSema().getLangOpts().CPlusPlus &&\n                       NextToken.is(tok::less);\n\n  for (LookupResult::iterator I = R.begin(), IEnd = R.end(); I != IEnd; ++I) {\n    if (isa<TypeDecl>(*I) || isa<ObjCInterfaceDecl>(*I))\n      return true;\n\n    if (CheckTemplate && isa<TemplateDecl>(*I))\n      return true;\n  }\n\n  return false;\n}\n\nstatic bool isTagTypeWithMissingTag(Sema &SemaRef, LookupResult &Result,\n                                    Scope *S, CXXScopeSpec &SS,\n                                    IdentifierInfo *&Name,\n                                    SourceLocation NameLoc) {\n  LookupResult R(SemaRef, Name, NameLoc, Sema::LookupTagName);\n  SemaRef.LookupParsedName(R, S, &SS);\n  if (TagDecl *Tag = R.getAsSingle<TagDecl>()) {\n    StringRef FixItTagName;\n    switch (Tag->getTagKind()) {\n      case TTK_Class:\n        FixItTagName = \"class \";\n        break;\n\n      case TTK_Enum:\n        FixItTagName = \"enum \";\n        break;\n\n      case TTK_Struct:\n        FixItTagName = \"struct \";\n        break;\n\n      case TTK_Interface:\n        FixItTagName = \"__interface \";\n        break;\n\n      case TTK_Union:\n        FixItTagName = \"union \";\n        break;\n    }\n\n    StringRef TagName = FixItTagName.drop_back();\n    SemaRef.Diag(NameLoc, diag::err_use_of_tag_name_without_tag)\n      << Name << TagName << SemaRef.getLangOpts().CPlusPlus\n      << FixItHint::CreateInsertion(NameLoc, FixItTagName);\n\n    for (LookupResult::iterator I = Result.begin(), IEnd = Result.end();\n         I != IEnd; ++I)\n      SemaRef.Diag((*I)->getLocation(), diag::note_decl_hiding_tag_type)\n        << Name << TagName;\n\n    // Replace lookup results with just the tag decl.\n    Result.clear(Sema::LookupTagName);\n    SemaRef.LookupParsedName(Result, S, &SS);\n    return true;\n  }\n\n  return false;\n}\n\n/// Build a ParsedType for a simple-type-specifier with a nested-name-specifier.\nstatic ParsedType buildNestedType(Sema &S, CXXScopeSpec &SS,\n                                  QualType T, SourceLocation NameLoc) {\n  ASTContext &Context = S.Context;\n\n  TypeLocBuilder Builder;\n  Builder.pushTypeSpec(T).setNameLoc(NameLoc);\n\n  T = S.getElaboratedType(ETK_None, SS, T);\n  ElaboratedTypeLoc ElabTL = Builder.push<ElaboratedTypeLoc>(T);\n  ElabTL.setElaboratedKeywordLoc(SourceLocation());\n  ElabTL.setQualifierLoc(SS.getWithLocInContext(Context));\n  return S.CreateParsedType(T, Builder.getTypeSourceInfo(Context, T));\n}\n\nSema::NameClassification Sema::ClassifyName(Scope *S, CXXScopeSpec &SS,\n                                            IdentifierInfo *&Name,\n                                            SourceLocation NameLoc,\n                                            const Token &NextToken,\n                                            CorrectionCandidateCallback *CCC) {\n  DeclarationNameInfo NameInfo(Name, NameLoc);\n  ObjCMethodDecl *CurMethod = getCurMethodDecl();\n\n  assert(NextToken.isNot(tok::coloncolon) &&\n         \"parse nested name specifiers before calling ClassifyName\");\n  if (getLangOpts().CPlusPlus && SS.isSet() &&\n      isCurrentClassName(*Name, S, &SS)) {\n    // Per [class.qual]p2, this names the constructors of SS, not the\n    // injected-class-name. We don't have a classification for that.\n    // There's not much point caching this result, since the parser\n    // will reject it later.\n    return NameClassification::Unknown();\n  }\n\n  LookupResult Result(*this, Name, NameLoc, LookupOrdinaryName);\n  LookupParsedName(Result, S, &SS, !CurMethod);\n\n  if (SS.isInvalid())\n    return NameClassification::Error();\n\n  // For unqualified lookup in a class template in MSVC mode, look into\n  // dependent base classes where the primary class template is known.\n  if (Result.empty() && SS.isEmpty() && getLangOpts().MSVCCompat) {\n    if (ParsedType TypeInBase =\n            recoverFromTypeInKnownDependentBase(*this, *Name, NameLoc))\n      return TypeInBase;\n  }\n\n  // Perform lookup for Objective-C instance variables (including automatically\n  // synthesized instance variables), if we're in an Objective-C method.\n  // FIXME: This lookup really, really needs to be folded in to the normal\n  // unqualified lookup mechanism.\n  if (SS.isEmpty() && CurMethod && !isResultTypeOrTemplate(Result, NextToken)) {\n    DeclResult Ivar = LookupIvarInObjCMethod(Result, S, Name);\n    if (Ivar.isInvalid())\n      return NameClassification::Error();\n    if (Ivar.isUsable())\n      return NameClassification::NonType(cast<NamedDecl>(Ivar.get()));\n\n    // We defer builtin creation until after ivar lookup inside ObjC methods.\n    if (Result.empty())\n      LookupBuiltin(Result);\n  }\n\n  bool SecondTry = false;\n  bool IsFilteredTemplateName = false;\n\nCorrected:\n  switch (Result.getResultKind()) {\n  case LookupResult::NotFound:\n    // If an unqualified-id is followed by a '(', then we have a function\n    // call.\n    if (SS.isEmpty() && NextToken.is(tok::l_paren)) {\n      // In C++, this is an ADL-only call.\n      // FIXME: Reference?\n      if (getLangOpts().CPlusPlus)\n        return NameClassification::UndeclaredNonType();\n\n      // C90 6.3.2.2:\n      //   If the expression that precedes the parenthesized argument list in a\n      //   function call consists solely of an identifier, and if no\n      //   declaration is visible for this identifier, the identifier is\n      //   implicitly declared exactly as if, in the innermost block containing\n      //   the function call, the declaration\n      //\n      //     extern int identifier ();\n      //\n      //   appeared.\n      //\n      // We also allow this in C99 as an extension.\n      if (NamedDecl *D = ImplicitlyDefineFunction(NameLoc, *Name, S))\n        return NameClassification::NonType(D);\n    }\n\n    if (getLangOpts().CPlusPlus20 && SS.isEmpty() && NextToken.is(tok::less)) {\n      // In C++20 onwards, this could be an ADL-only call to a function\n      // template, and we're required to assume that this is a template name.\n      //\n      // FIXME: Find a way to still do typo correction in this case.\n      TemplateName Template =\n          Context.getAssumedTemplateName(NameInfo.getName());\n      return NameClassification::UndeclaredTemplate(Template);\n    }\n\n    // In C, we first see whether there is a tag type by the same name, in\n    // which case it's likely that the user just forgot to write \"enum\",\n    // \"struct\", or \"union\".\n    if (!getLangOpts().CPlusPlus && !SecondTry &&\n        isTagTypeWithMissingTag(*this, Result, S, SS, Name, NameLoc)) {\n      break;\n    }\n\n    // Perform typo correction to determine if there is another name that is\n    // close to this name.\n    if (!SecondTry && CCC) {\n      SecondTry = true;\n      if (TypoCorrection Corrected =\n              CorrectTypo(Result.getLookupNameInfo(), Result.getLookupKind(), S,\n                          &SS, *CCC, CTK_ErrorRecovery)) {\n        unsigned UnqualifiedDiag = diag::err_undeclared_var_use_suggest;\n        unsigned QualifiedDiag = diag::err_no_member_suggest;\n\n        NamedDecl *FirstDecl = Corrected.getFoundDecl();\n        NamedDecl *UnderlyingFirstDecl = Corrected.getCorrectionDecl();\n        if (getLangOpts().CPlusPlus && NextToken.is(tok::less) &&\n            UnderlyingFirstDecl && isa<TemplateDecl>(UnderlyingFirstDecl)) {\n          UnqualifiedDiag = diag::err_no_template_suggest;\n          QualifiedDiag = diag::err_no_member_template_suggest;\n        } else if (UnderlyingFirstDecl &&\n                   (isa<TypeDecl>(UnderlyingFirstDecl) ||\n                    isa<ObjCInterfaceDecl>(UnderlyingFirstDecl) ||\n                    isa<ObjCCompatibleAliasDecl>(UnderlyingFirstDecl))) {\n          UnqualifiedDiag = diag::err_unknown_typename_suggest;\n          QualifiedDiag = diag::err_unknown_nested_typename_suggest;\n        }\n\n        if (SS.isEmpty()) {\n          diagnoseTypo(Corrected, PDiag(UnqualifiedDiag) << Name);\n        } else {// FIXME: is this even reachable? Test it.\n          std::string CorrectedStr(Corrected.getAsString(getLangOpts()));\n          bool DroppedSpecifier = Corrected.WillReplaceSpecifier() &&\n                                  Name->getName().equals(CorrectedStr);\n          diagnoseTypo(Corrected, PDiag(QualifiedDiag)\n                                    << Name << computeDeclContext(SS, false)\n                                    << DroppedSpecifier << SS.getRange());\n        }\n\n        // Update the name, so that the caller has the new name.\n        Name = Corrected.getCorrectionAsIdentifierInfo();\n\n        // Typo correction corrected to a keyword.\n        if (Corrected.isKeyword())\n          return Name;\n\n        // Also update the LookupResult...\n        // FIXME: This should probably go away at some point\n        Result.clear();\n        Result.setLookupName(Corrected.getCorrection());\n        if (FirstDecl)\n          Result.addDecl(FirstDecl);\n\n        // If we found an Objective-C instance variable, let\n        // LookupInObjCMethod build the appropriate expression to\n        // reference the ivar.\n        // FIXME: This is a gross hack.\n        if (ObjCIvarDecl *Ivar = Result.getAsSingle<ObjCIvarDecl>()) {\n          DeclResult R =\n              LookupIvarInObjCMethod(Result, S, Ivar->getIdentifier());\n          if (R.isInvalid())\n            return NameClassification::Error();\n          if (R.isUsable())\n            return NameClassification::NonType(Ivar);\n        }\n\n        goto Corrected;\n      }\n    }\n\n    // We failed to correct; just fall through and let the parser deal with it.\n    Result.suppressDiagnostics();\n    return NameClassification::Unknown();\n\n  case LookupResult::NotFoundInCurrentInstantiation: {\n    // We performed name lookup into the current instantiation, and there were\n    // dependent bases, so we treat this result the same way as any other\n    // dependent nested-name-specifier.\n\n    // C++ [temp.res]p2:\n    //   A name used in a template declaration or definition and that is\n    //   dependent on a template-parameter is assumed not to name a type\n    //   unless the applicable name lookup finds a type name or the name is\n    //   qualified by the keyword typename.\n    //\n    // FIXME: If the next token is '<', we might want to ask the parser to\n    // perform some heroics to see if we actually have a\n    // template-argument-list, which would indicate a missing 'template'\n    // keyword here.\n    return NameClassification::DependentNonType();\n  }\n\n  case LookupResult::Found:\n  case LookupResult::FoundOverloaded:\n  case LookupResult::FoundUnresolvedValue:\n    break;\n\n  case LookupResult::Ambiguous:\n    if (getLangOpts().CPlusPlus && NextToken.is(tok::less) &&\n        hasAnyAcceptableTemplateNames(Result, /*AllowFunctionTemplates=*/true,\n                                      /*AllowDependent=*/false)) {\n      // C++ [temp.local]p3:\n      //   A lookup that finds an injected-class-name (10.2) can result in an\n      //   ambiguity in certain cases (for example, if it is found in more than\n      //   one base class). If all of the injected-class-names that are found\n      //   refer to specializations of the same class template, and if the name\n      //   is followed by a template-argument-list, the reference refers to the\n      //   class template itself and not a specialization thereof, and is not\n      //   ambiguous.\n      //\n      // This filtering can make an ambiguous result into an unambiguous one,\n      // so try again after filtering out template names.\n      FilterAcceptableTemplateNames(Result);\n      if (!Result.isAmbiguous()) {\n        IsFilteredTemplateName = true;\n        break;\n      }\n    }\n\n    // Diagnose the ambiguity and return an error.\n    return NameClassification::Error();\n  }\n\n  if (getLangOpts().CPlusPlus && NextToken.is(tok::less) &&\n      (IsFilteredTemplateName ||\n       hasAnyAcceptableTemplateNames(\n           Result, /*AllowFunctionTemplates=*/true,\n           /*AllowDependent=*/false,\n           /*AllowNonTemplateFunctions*/ SS.isEmpty() &&\n               getLangOpts().CPlusPlus20))) {\n    // C++ [temp.names]p3:\n    //   After name lookup (3.4) finds that a name is a template-name or that\n    //   an operator-function-id or a literal- operator-id refers to a set of\n    //   overloaded functions any member of which is a function template if\n    //   this is followed by a <, the < is always taken as the delimiter of a\n    //   template-argument-list and never as the less-than operator.\n    // C++2a [temp.names]p2:\n    //   A name is also considered to refer to a template if it is an\n    //   unqualified-id followed by a < and name lookup finds either one\n    //   or more functions or finds nothing.\n    if (!IsFilteredTemplateName)\n      FilterAcceptableTemplateNames(Result);\n\n    bool IsFunctionTemplate;\n    bool IsVarTemplate;\n    TemplateName Template;\n    if (Result.end() - Result.begin() > 1) {\n      IsFunctionTemplate = true;\n      Template = Context.getOverloadedTemplateName(Result.begin(),\n                                                   Result.end());\n    } else if (!Result.empty()) {\n      auto *TD = cast<TemplateDecl>(getAsTemplateNameDecl(\n          *Result.begin(), /*AllowFunctionTemplates=*/true,\n          /*AllowDependent=*/false));\n      IsFunctionTemplate = isa<FunctionTemplateDecl>(TD);\n      IsVarTemplate = isa<VarTemplateDecl>(TD);\n\n      if (SS.isNotEmpty())\n        Template =\n            Context.getQualifiedTemplateName(SS.getScopeRep(),\n                                             /*TemplateKeyword=*/false, TD);\n      else\n        Template = TemplateName(TD);\n    } else {\n      // All results were non-template functions. This is a function template\n      // name.\n      IsFunctionTemplate = true;\n      Template = Context.getAssumedTemplateName(NameInfo.getName());\n    }\n\n    if (IsFunctionTemplate) {\n      // Function templates always go through overload resolution, at which\n      // point we'll perform the various checks (e.g., accessibility) we need\n      // to based on which function we selected.\n      Result.suppressDiagnostics();\n\n      return NameClassification::FunctionTemplate(Template);\n    }\n\n    return IsVarTemplate ? NameClassification::VarTemplate(Template)\n                         : NameClassification::TypeTemplate(Template);\n  }\n\n  NamedDecl *FirstDecl = (*Result.begin())->getUnderlyingDecl();\n  if (TypeDecl *Type = dyn_cast<TypeDecl>(FirstDecl)) {\n    DiagnoseUseOfDecl(Type, NameLoc);\n    MarkAnyDeclReferenced(Type->getLocation(), Type, /*OdrUse=*/false);\n    QualType T = Context.getTypeDeclType(Type);\n    if (SS.isNotEmpty())\n      return buildNestedType(*this, SS, T, NameLoc);\n    return ParsedType::make(T);\n  }\n\n  ObjCInterfaceDecl *Class = dyn_cast<ObjCInterfaceDecl>(FirstDecl);\n  if (!Class) {\n    // FIXME: It's unfortunate that we don't have a Type node for handling this.\n    if (ObjCCompatibleAliasDecl *Alias =\n            dyn_cast<ObjCCompatibleAliasDecl>(FirstDecl))\n      Class = Alias->getClassInterface();\n  }\n\n  if (Class) {\n    DiagnoseUseOfDecl(Class, NameLoc);\n\n    if (NextToken.is(tok::period)) {\n      // Interface. <something> is parsed as a property reference expression.\n      // Just return \"unknown\" as a fall-through for now.\n      Result.suppressDiagnostics();\n      return NameClassification::Unknown();\n    }\n\n    QualType T = Context.getObjCInterfaceType(Class);\n    return ParsedType::make(T);\n  }\n\n  if (isa<ConceptDecl>(FirstDecl))\n    return NameClassification::Concept(\n        TemplateName(cast<TemplateDecl>(FirstDecl)));\n\n  // We can have a type template here if we're classifying a template argument.\n  if (isa<TemplateDecl>(FirstDecl) && !isa<FunctionTemplateDecl>(FirstDecl) &&\n      !isa<VarTemplateDecl>(FirstDecl))\n    return NameClassification::TypeTemplate(\n        TemplateName(cast<TemplateDecl>(FirstDecl)));\n\n  // Check for a tag type hidden by a non-type decl in a few cases where it\n  // seems likely a type is wanted instead of the non-type that was found.\n  bool NextIsOp = NextToken.isOneOf(tok::amp, tok::star);\n  if ((NextToken.is(tok::identifier) ||\n       (NextIsOp &&\n        FirstDecl->getUnderlyingDecl()->isFunctionOrFunctionTemplate())) &&\n      isTagTypeWithMissingTag(*this, Result, S, SS, Name, NameLoc)) {\n    TypeDecl *Type = Result.getAsSingle<TypeDecl>();\n    DiagnoseUseOfDecl(Type, NameLoc);\n    QualType T = Context.getTypeDeclType(Type);\n    if (SS.isNotEmpty())\n      return buildNestedType(*this, SS, T, NameLoc);\n    return ParsedType::make(T);\n  }\n\n  // If we already know which single declaration is referenced, just annotate\n  // that declaration directly. Defer resolving even non-overloaded class\n  // member accesses, as we need to defer certain access checks until we know\n  // the context.\n  bool ADL = UseArgumentDependentLookup(SS, Result, NextToken.is(tok::l_paren));\n  if (Result.isSingleResult() && !ADL && !FirstDecl->isCXXClassMember())\n    return NameClassification::NonType(Result.getRepresentativeDecl());\n\n  // Otherwise, this is an overload set that we will need to resolve later.\n  Result.suppressDiagnostics();\n  return NameClassification::OverloadSet(UnresolvedLookupExpr::Create(\n      Context, Result.getNamingClass(), SS.getWithLocInContext(Context),\n      Result.getLookupNameInfo(), ADL, Result.isOverloadedResult(),\n      Result.begin(), Result.end()));\n}\n\nExprResult\nSema::ActOnNameClassifiedAsUndeclaredNonType(IdentifierInfo *Name,\n                                             SourceLocation NameLoc) {\n  assert(getLangOpts().CPlusPlus && \"ADL-only call in C?\");\n  CXXScopeSpec SS;\n  LookupResult Result(*this, Name, NameLoc, LookupOrdinaryName);\n  return BuildDeclarationNameExpr(SS, Result, /*ADL=*/true);\n}\n\nExprResult\nSema::ActOnNameClassifiedAsDependentNonType(const CXXScopeSpec &SS,\n                                            IdentifierInfo *Name,\n                                            SourceLocation NameLoc,\n                                            bool IsAddressOfOperand) {\n  DeclarationNameInfo NameInfo(Name, NameLoc);\n  return ActOnDependentIdExpression(SS, /*TemplateKWLoc=*/SourceLocation(),\n                                    NameInfo, IsAddressOfOperand,\n                                    /*TemplateArgs=*/nullptr);\n}\n\nExprResult Sema::ActOnNameClassifiedAsNonType(Scope *S, const CXXScopeSpec &SS,\n                                              NamedDecl *Found,\n                                              SourceLocation NameLoc,\n                                              const Token &NextToken) {\n  if (getCurMethodDecl() && SS.isEmpty())\n    if (auto *Ivar = dyn_cast<ObjCIvarDecl>(Found->getUnderlyingDecl()))\n      return BuildIvarRefExpr(S, NameLoc, Ivar);\n\n  // Reconstruct the lookup result.\n  LookupResult Result(*this, Found->getDeclName(), NameLoc, LookupOrdinaryName);\n  Result.addDecl(Found);\n  Result.resolveKind();\n\n  bool ADL = UseArgumentDependentLookup(SS, Result, NextToken.is(tok::l_paren));\n  return BuildDeclarationNameExpr(SS, Result, ADL);\n}\n\nExprResult Sema::ActOnNameClassifiedAsOverloadSet(Scope *S, Expr *E) {\n  // For an implicit class member access, transform the result into a member\n  // access expression if necessary.\n  auto *ULE = cast<UnresolvedLookupExpr>(E);\n  if ((*ULE->decls_begin())->isCXXClassMember()) {\n    CXXScopeSpec SS;\n    SS.Adopt(ULE->getQualifierLoc());\n\n    // Reconstruct the lookup result.\n    LookupResult Result(*this, ULE->getName(), ULE->getNameLoc(),\n                        LookupOrdinaryName);\n    Result.setNamingClass(ULE->getNamingClass());\n    for (auto I = ULE->decls_begin(), E = ULE->decls_end(); I != E; ++I)\n      Result.addDecl(*I, I.getAccess());\n    Result.resolveKind();\n    return BuildPossibleImplicitMemberExpr(SS, SourceLocation(), Result,\n                                           nullptr, S);\n  }\n\n  // Otherwise, this is already in the form we needed, and no further checks\n  // are necessary.\n  return ULE;\n}\n\nSema::TemplateNameKindForDiagnostics\nSema::getTemplateNameKindForDiagnostics(TemplateName Name) {\n  auto *TD = Name.getAsTemplateDecl();\n  if (!TD)\n    return TemplateNameKindForDiagnostics::DependentTemplate;\n  if (isa<ClassTemplateDecl>(TD))\n    return TemplateNameKindForDiagnostics::ClassTemplate;\n  if (isa<FunctionTemplateDecl>(TD))\n    return TemplateNameKindForDiagnostics::FunctionTemplate;\n  if (isa<VarTemplateDecl>(TD))\n    return TemplateNameKindForDiagnostics::VarTemplate;\n  if (isa<TypeAliasTemplateDecl>(TD))\n    return TemplateNameKindForDiagnostics::AliasTemplate;\n  if (isa<TemplateTemplateParmDecl>(TD))\n    return TemplateNameKindForDiagnostics::TemplateTemplateParam;\n  if (isa<ConceptDecl>(TD))\n    return TemplateNameKindForDiagnostics::Concept;\n  return TemplateNameKindForDiagnostics::DependentTemplate;\n}\n\nvoid Sema::PushDeclContext(Scope *S, DeclContext *DC) {\n  assert(DC->getLexicalParent() == CurContext &&\n      \"The next DeclContext should be lexically contained in the current one.\");\n  CurContext = DC;\n  S->setEntity(DC);\n}\n\nvoid Sema::PopDeclContext() {\n  assert(CurContext && \"DeclContext imbalance!\");\n\n  CurContext = CurContext->getLexicalParent();\n  assert(CurContext && \"Popped translation unit!\");\n}\n\nSema::SkippedDefinitionContext Sema::ActOnTagStartSkippedDefinition(Scope *S,\n                                                                    Decl *D) {\n  // Unlike PushDeclContext, the context to which we return is not necessarily\n  // the containing DC of TD, because the new context will be some pre-existing\n  // TagDecl definition instead of a fresh one.\n  auto Result = static_cast<SkippedDefinitionContext>(CurContext);\n  CurContext = cast<TagDecl>(D)->getDefinition();\n  assert(CurContext && \"skipping definition of undefined tag\");\n  // Start lookups from the parent of the current context; we don't want to look\n  // into the pre-existing complete definition.\n  S->setEntity(CurContext->getLookupParent());\n  return Result;\n}\n\nvoid Sema::ActOnTagFinishSkippedDefinition(SkippedDefinitionContext Context) {\n  CurContext = static_cast<decltype(CurContext)>(Context);\n}\n\n/// EnterDeclaratorContext - Used when we must lookup names in the context\n/// of a declarator's nested name specifier.\n///\nvoid Sema::EnterDeclaratorContext(Scope *S, DeclContext *DC) {\n  // C++0x [basic.lookup.unqual]p13:\n  //   A name used in the definition of a static data member of class\n  //   X (after the qualified-id of the static member) is looked up as\n  //   if the name was used in a member function of X.\n  // C++0x [basic.lookup.unqual]p14:\n  //   If a variable member of a namespace is defined outside of the\n  //   scope of its namespace then any name used in the definition of\n  //   the variable member (after the declarator-id) is looked up as\n  //   if the definition of the variable member occurred in its\n  //   namespace.\n  // Both of these imply that we should push a scope whose context\n  // is the semantic context of the declaration.  We can't use\n  // PushDeclContext here because that context is not necessarily\n  // lexically contained in the current context.  Fortunately,\n  // the containing scope should have the appropriate information.\n\n  assert(!S->getEntity() && \"scope already has entity\");\n\n#ifndef NDEBUG\n  Scope *Ancestor = S->getParent();\n  while (!Ancestor->getEntity()) Ancestor = Ancestor->getParent();\n  assert(Ancestor->getEntity() == CurContext && \"ancestor context mismatch\");\n#endif\n\n  CurContext = DC;\n  S->setEntity(DC);\n\n  if (S->getParent()->isTemplateParamScope()) {\n    // Also set the corresponding entities for all immediately-enclosing\n    // template parameter scopes.\n    EnterTemplatedContext(S->getParent(), DC);\n  }\n}\n\nvoid Sema::ExitDeclaratorContext(Scope *S) {\n  assert(S->getEntity() == CurContext && \"Context imbalance!\");\n\n  // Switch back to the lexical context.  The safety of this is\n  // enforced by an assert in EnterDeclaratorContext.\n  Scope *Ancestor = S->getParent();\n  while (!Ancestor->getEntity()) Ancestor = Ancestor->getParent();\n  CurContext = Ancestor->getEntity();\n\n  // We don't need to do anything with the scope, which is going to\n  // disappear.\n}\n\nvoid Sema::EnterTemplatedContext(Scope *S, DeclContext *DC) {\n  assert(S->isTemplateParamScope() &&\n         \"expected to be initializing a template parameter scope\");\n\n  // C++20 [temp.local]p7:\n  //   In the definition of a member of a class template that appears outside\n  //   of the class template definition, the name of a member of the class\n  //   template hides the name of a template-parameter of any enclosing class\n  //   templates (but not a template-parameter of the member if the member is a\n  //   class or function template).\n  // C++20 [temp.local]p9:\n  //   In the definition of a class template or in the definition of a member\n  //   of such a template that appears outside of the template definition, for\n  //   each non-dependent base class (13.8.2.1), if the name of the base class\n  //   or the name of a member of the base class is the same as the name of a\n  //   template-parameter, the base class name or member name hides the\n  //   template-parameter name (6.4.10).\n  //\n  // This means that a template parameter scope should be searched immediately\n  // after searching the DeclContext for which it is a template parameter\n  // scope. For example, for\n  //   template<typename T> template<typename U> template<typename V>\n  //     void N::A<T>::B<U>::f(...)\n  // we search V then B<U> (and base classes) then U then A<T> (and base\n  // classes) then T then N then ::.\n  unsigned ScopeDepth = getTemplateDepth(S);\n  for (; S && S->isTemplateParamScope(); S = S->getParent(), --ScopeDepth) {\n    DeclContext *SearchDCAfterScope = DC;\n    for (; DC; DC = DC->getLookupParent()) {\n      if (const TemplateParameterList *TPL =\n              cast<Decl>(DC)->getDescribedTemplateParams()) {\n        unsigned DCDepth = TPL->getDepth() + 1;\n        if (DCDepth > ScopeDepth)\n          continue;\n        if (ScopeDepth == DCDepth)\n          SearchDCAfterScope = DC = DC->getLookupParent();\n        break;\n      }\n    }\n    S->setLookupEntity(SearchDCAfterScope);\n  }\n}\n\nvoid Sema::ActOnReenterFunctionContext(Scope* S, Decl *D) {\n  // We assume that the caller has already called\n  // ActOnReenterTemplateScope so getTemplatedDecl() works.\n  FunctionDecl *FD = D->getAsFunction();\n  if (!FD)\n    return;\n\n  // Same implementation as PushDeclContext, but enters the context\n  // from the lexical parent, rather than the top-level class.\n  assert(CurContext == FD->getLexicalParent() &&\n    \"The next DeclContext should be lexically contained in the current one.\");\n  CurContext = FD;\n  S->setEntity(CurContext);\n\n  for (unsigned P = 0, NumParams = FD->getNumParams(); P < NumParams; ++P) {\n    ParmVarDecl *Param = FD->getParamDecl(P);\n    // If the parameter has an identifier, then add it to the scope\n    if (Param->getIdentifier()) {\n      S->AddDecl(Param);\n      IdResolver.AddDecl(Param);\n    }\n  }\n}\n\nvoid Sema::ActOnExitFunctionContext() {\n  // Same implementation as PopDeclContext, but returns to the lexical parent,\n  // rather than the top-level class.\n  assert(CurContext && \"DeclContext imbalance!\");\n  CurContext = CurContext->getLexicalParent();\n  assert(CurContext && \"Popped translation unit!\");\n}\n\n/// Determine whether we allow overloading of the function\n/// PrevDecl with another declaration.\n///\n/// This routine determines whether overloading is possible, not\n/// whether some new function is actually an overload. It will return\n/// true in C++ (where we can always provide overloads) or, as an\n/// extension, in C when the previous function is already an\n/// overloaded function declaration or has the \"overloadable\"\n/// attribute.\nstatic bool AllowOverloadingOfFunction(LookupResult &Previous,\n                                       ASTContext &Context,\n                                       const FunctionDecl *New) {\n  if (Context.getLangOpts().CPlusPlus)\n    return true;\n\n  if (Previous.getResultKind() == LookupResult::FoundOverloaded)\n    return true;\n\n  return Previous.getResultKind() == LookupResult::Found &&\n         (Previous.getFoundDecl()->hasAttr<OverloadableAttr>() ||\n          New->hasAttr<OverloadableAttr>());\n}\n\n/// Add this decl to the scope shadowed decl chains.\nvoid Sema::PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext) {\n  // Move up the scope chain until we find the nearest enclosing\n  // non-transparent context. The declaration will be introduced into this\n  // scope.\n  while (S->getEntity() && S->getEntity()->isTransparentContext())\n    S = S->getParent();\n\n  // Add scoped declarations into their context, so that they can be\n  // found later. Declarations without a context won't be inserted\n  // into any context.\n  if (AddToContext)\n    CurContext->addDecl(D);\n\n  // Out-of-line definitions shouldn't be pushed into scope in C++, unless they\n  // are function-local declarations.\n  if (getLangOpts().CPlusPlus && D->isOutOfLine() && !S->getFnParent())\n    return;\n\n  // Template instantiations should also not be pushed into scope.\n  if (isa<FunctionDecl>(D) &&\n      cast<FunctionDecl>(D)->isFunctionTemplateSpecialization())\n    return;\n\n  // If this replaces anything in the current scope,\n  IdentifierResolver::iterator I = IdResolver.begin(D->getDeclName()),\n                               IEnd = IdResolver.end();\n  for (; I != IEnd; ++I) {\n    if (S->isDeclScope(*I) && D->declarationReplaces(*I)) {\n      S->RemoveDecl(*I);\n      IdResolver.RemoveDecl(*I);\n\n      // Should only need to replace one decl.\n      break;\n    }\n  }\n\n  S->AddDecl(D);\n\n  if (isa<LabelDecl>(D) && !cast<LabelDecl>(D)->isGnuLocal()) {\n    // Implicitly-generated labels may end up getting generated in an order that\n    // isn't strictly lexical, which breaks name lookup. Be careful to insert\n    // the label at the appropriate place in the identifier chain.\n    for (I = IdResolver.begin(D->getDeclName()); I != IEnd; ++I) {\n      DeclContext *IDC = (*I)->getLexicalDeclContext()->getRedeclContext();\n      if (IDC == CurContext) {\n        if (!S->isDeclScope(*I))\n          continue;\n      } else if (IDC->Encloses(CurContext))\n        break;\n    }\n\n    IdResolver.InsertDeclAfter(I, D);\n  } else {\n    IdResolver.AddDecl(D);\n  }\n}\n\nbool Sema::isDeclInScope(NamedDecl *D, DeclContext *Ctx, Scope *S,\n                         bool AllowInlineNamespace) {\n  return IdResolver.isDeclInScope(D, Ctx, S, AllowInlineNamespace);\n}\n\nScope *Sema::getScopeForDeclContext(Scope *S, DeclContext *DC) {\n  DeclContext *TargetDC = DC->getPrimaryContext();\n  do {\n    if (DeclContext *ScopeDC = S->getEntity())\n      if (ScopeDC->getPrimaryContext() == TargetDC)\n        return S;\n  } while ((S = S->getParent()));\n\n  return nullptr;\n}\n\nstatic bool isOutOfScopePreviousDeclaration(NamedDecl *,\n                                            DeclContext*,\n                                            ASTContext&);\n\n/// Filters out lookup results that don't fall within the given scope\n/// as determined by isDeclInScope.\nvoid Sema::FilterLookupForScope(LookupResult &R, DeclContext *Ctx, Scope *S,\n                                bool ConsiderLinkage,\n                                bool AllowInlineNamespace) {\n  LookupResult::Filter F = R.makeFilter();\n  while (F.hasNext()) {\n    NamedDecl *D = F.next();\n\n    if (isDeclInScope(D, Ctx, S, AllowInlineNamespace))\n      continue;\n\n    if (ConsiderLinkage && isOutOfScopePreviousDeclaration(D, Ctx, Context))\n      continue;\n\n    F.erase();\n  }\n\n  F.done();\n}\n\n/// We've determined that \\p New is a redeclaration of \\p Old. Check that they\n/// have compatible owning modules.\nbool Sema::CheckRedeclarationModuleOwnership(NamedDecl *New, NamedDecl *Old) {\n  // FIXME: The Modules TS is not clear about how friend declarations are\n  // to be treated. It's not meaningful to have different owning modules for\n  // linkage in redeclarations of the same entity, so for now allow the\n  // redeclaration and change the owning modules to match.\n  if (New->getFriendObjectKind() &&\n      Old->getOwningModuleForLinkage() != New->getOwningModuleForLinkage()) {\n    New->setLocalOwningModule(Old->getOwningModule());\n    makeMergedDefinitionVisible(New);\n    return false;\n  }\n\n  Module *NewM = New->getOwningModule();\n  Module *OldM = Old->getOwningModule();\n\n  if (NewM && NewM->Kind == Module::PrivateModuleFragment)\n    NewM = NewM->Parent;\n  if (OldM && OldM->Kind == Module::PrivateModuleFragment)\n    OldM = OldM->Parent;\n\n  if (NewM == OldM)\n    return false;\n\n  bool NewIsModuleInterface = NewM && NewM->isModulePurview();\n  bool OldIsModuleInterface = OldM && OldM->isModulePurview();\n  if (NewIsModuleInterface || OldIsModuleInterface) {\n    // C++ Modules TS [basic.def.odr] 6.2/6.7 [sic]:\n    //   if a declaration of D [...] appears in the purview of a module, all\n    //   other such declarations shall appear in the purview of the same module\n    Diag(New->getLocation(), diag::err_mismatched_owning_module)\n      << New\n      << NewIsModuleInterface\n      << (NewIsModuleInterface ? NewM->getFullModuleName() : \"\")\n      << OldIsModuleInterface\n      << (OldIsModuleInterface ? OldM->getFullModuleName() : \"\");\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n    New->setInvalidDecl();\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool isUsingDecl(NamedDecl *D) {\n  return isa<UsingShadowDecl>(D) ||\n         isa<UnresolvedUsingTypenameDecl>(D) ||\n         isa<UnresolvedUsingValueDecl>(D);\n}\n\n/// Removes using shadow declarations from the lookup results.\nstatic void RemoveUsingDecls(LookupResult &R) {\n  LookupResult::Filter F = R.makeFilter();\n  while (F.hasNext())\n    if (isUsingDecl(F.next()))\n      F.erase();\n\n  F.done();\n}\n\n/// Check for this common pattern:\n/// @code\n/// class S {\n///   S(const S&); // DO NOT IMPLEMENT\n///   void operator=(const S&); // DO NOT IMPLEMENT\n/// };\n/// @endcode\nstatic bool IsDisallowedCopyOrAssign(const CXXMethodDecl *D) {\n  // FIXME: Should check for private access too but access is set after we get\n  // the decl here.\n  if (D->doesThisDeclarationHaveABody())\n    return false;\n\n  if (const CXXConstructorDecl *CD = dyn_cast<CXXConstructorDecl>(D))\n    return CD->isCopyConstructor();\n  return D->isCopyAssignmentOperator();\n}\n\n// We need this to handle\n//\n// typedef struct {\n//   void *foo() { return 0; }\n// } A;\n//\n// When we see foo we don't know if after the typedef we will get 'A' or '*A'\n// for example. If 'A', foo will have external linkage. If we have '*A',\n// foo will have no linkage. Since we can't know until we get to the end\n// of the typedef, this function finds out if D might have non-external linkage.\n// Callers should verify at the end of the TU if it D has external linkage or\n// not.\nbool Sema::mightHaveNonExternalLinkage(const DeclaratorDecl *D) {\n  const DeclContext *DC = D->getDeclContext();\n  while (!DC->isTranslationUnit()) {\n    if (const RecordDecl *RD = dyn_cast<RecordDecl>(DC)){\n      if (!RD->hasNameForLinkage())\n        return true;\n    }\n    DC = DC->getParent();\n  }\n\n  return !D->isExternallyVisible();\n}\n\n// FIXME: This needs to be refactored; some other isInMainFile users want\n// these semantics.\nstatic bool isMainFileLoc(const Sema &S, SourceLocation Loc) {\n  if (S.TUKind != TU_Complete)\n    return false;\n  return S.SourceMgr.isInMainFile(Loc);\n}\n\nbool Sema::ShouldWarnIfUnusedFileScopedDecl(const DeclaratorDecl *D) const {\n  assert(D);\n\n  if (D->isInvalidDecl() || D->isUsed() || D->hasAttr<UnusedAttr>())\n    return false;\n\n  // Ignore all entities declared within templates, and out-of-line definitions\n  // of members of class templates.\n  if (D->getDeclContext()->isDependentContext() ||\n      D->getLexicalDeclContext()->isDependentContext())\n    return false;\n\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    if (FD->getTemplateSpecializationKind() == TSK_ImplicitInstantiation)\n      return false;\n    // A non-out-of-line declaration of a member specialization was implicitly\n    // instantiated; it's the out-of-line declaration that we're interested in.\n    if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization &&\n        FD->getMemberSpecializationInfo() && !FD->isOutOfLine())\n      return false;\n\n    if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD)) {\n      if (MD->isVirtual() || IsDisallowedCopyOrAssign(MD))\n        return false;\n    } else {\n      // 'static inline' functions are defined in headers; don't warn.\n      if (FD->isInlined() && !isMainFileLoc(*this, FD->getLocation()))\n        return false;\n    }\n\n    if (FD->doesThisDeclarationHaveABody() &&\n        Context.DeclMustBeEmitted(FD))\n      return false;\n  } else if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    // Constants and utility variables are defined in headers with internal\n    // linkage; don't warn.  (Unlike functions, there isn't a convenient marker\n    // like \"inline\".)\n    if (!isMainFileLoc(*this, VD->getLocation()))\n      return false;\n\n    if (Context.DeclMustBeEmitted(VD))\n      return false;\n\n    if (VD->isStaticDataMember() &&\n        VD->getTemplateSpecializationKind() == TSK_ImplicitInstantiation)\n      return false;\n    if (VD->isStaticDataMember() &&\n        VD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization &&\n        VD->getMemberSpecializationInfo() && !VD->isOutOfLine())\n      return false;\n\n    if (VD->isInline() && !isMainFileLoc(*this, VD->getLocation()))\n      return false;\n  } else {\n    return false;\n  }\n\n  // Only warn for unused decls internal to the translation unit.\n  // FIXME: This seems like a bogus check; it suppresses -Wunused-function\n  // for inline functions defined in the main source file, for instance.\n  return mightHaveNonExternalLinkage(D);\n}\n\nvoid Sema::MarkUnusedFileScopedDecl(const DeclaratorDecl *D) {\n  if (!D)\n    return;\n\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    const FunctionDecl *First = FD->getFirstDecl();\n    if (FD != First && ShouldWarnIfUnusedFileScopedDecl(First))\n      return; // First should already be in the vector.\n  }\n\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    const VarDecl *First = VD->getFirstDecl();\n    if (VD != First && ShouldWarnIfUnusedFileScopedDecl(First))\n      return; // First should already be in the vector.\n  }\n\n  if (ShouldWarnIfUnusedFileScopedDecl(D))\n    UnusedFileScopedDecls.push_back(D);\n}\n\nstatic bool ShouldDiagnoseUnusedDecl(const NamedDecl *D) {\n  if (D->isInvalidDecl())\n    return false;\n\n  if (auto *DD = dyn_cast<DecompositionDecl>(D)) {\n    // For a decomposition declaration, warn if none of the bindings are\n    // referenced, instead of if the variable itself is referenced (which\n    // it is, by the bindings' expressions).\n    for (auto *BD : DD->bindings())\n      if (BD->isReferenced())\n        return false;\n  } else if (!D->getDeclName()) {\n    return false;\n  } else if (D->isReferenced() || D->isUsed()) {\n    return false;\n  }\n\n  if (D->hasAttr<UnusedAttr>() || D->hasAttr<ObjCPreciseLifetimeAttr>())\n    return false;\n\n  if (isa<LabelDecl>(D))\n    return true;\n\n  // Except for labels, we only care about unused decls that are local to\n  // functions.\n  bool WithinFunction = D->getDeclContext()->isFunctionOrMethod();\n  if (const auto *R = dyn_cast<CXXRecordDecl>(D->getDeclContext()))\n    // For dependent types, the diagnostic is deferred.\n    WithinFunction =\n        WithinFunction || (R->isLocalClass() && !R->isDependentType());\n  if (!WithinFunction)\n    return false;\n\n  if (isa<TypedefNameDecl>(D))\n    return true;\n\n  // White-list anything that isn't a local variable.\n  if (!isa<VarDecl>(D) || isa<ParmVarDecl>(D) || isa<ImplicitParamDecl>(D))\n    return false;\n\n  // Types of valid local variables should be complete, so this should succeed.\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n\n    // White-list anything with an __attribute__((unused)) type.\n    const auto *Ty = VD->getType().getTypePtr();\n\n    // Only look at the outermost level of typedef.\n    if (const TypedefType *TT = Ty->getAs<TypedefType>()) {\n      if (TT->getDecl()->hasAttr<UnusedAttr>())\n        return false;\n    }\n\n    // If we failed to complete the type for some reason, or if the type is\n    // dependent, don't diagnose the variable.\n    if (Ty->isIncompleteType() || Ty->isDependentType())\n      return false;\n\n    // Look at the element type to ensure that the warning behaviour is\n    // consistent for both scalars and arrays.\n    Ty = Ty->getBaseElementTypeUnsafe();\n\n    if (const TagType *TT = Ty->getAs<TagType>()) {\n      const TagDecl *Tag = TT->getDecl();\n      if (Tag->hasAttr<UnusedAttr>())\n        return false;\n\n      if (const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(Tag)) {\n        if (!RD->hasTrivialDestructor() && !RD->hasAttr<WarnUnusedAttr>())\n          return false;\n\n        if (const Expr *Init = VD->getInit()) {\n          if (const ExprWithCleanups *Cleanups =\n                  dyn_cast<ExprWithCleanups>(Init))\n            Init = Cleanups->getSubExpr();\n          const CXXConstructExpr *Construct =\n            dyn_cast<CXXConstructExpr>(Init);\n          if (Construct && !Construct->isElidable()) {\n            CXXConstructorDecl *CD = Construct->getConstructor();\n            if (!CD->isTrivial() && !RD->hasAttr<WarnUnusedAttr>() &&\n                (VD->getInit()->isValueDependent() || !VD->evaluateValue()))\n              return false;\n          }\n\n          // Suppress the warning if we don't know how this is constructed, and\n          // it could possibly be non-trivial constructor.\n          if (Init->isTypeDependent())\n            for (const CXXConstructorDecl *Ctor : RD->ctors())\n              if (!Ctor->isTrivial())\n                return false;\n        }\n      }\n    }\n\n    // TODO: __attribute__((unused)) templates?\n  }\n\n  return true;\n}\n\nstatic void GenerateFixForUnusedDecl(const NamedDecl *D, ASTContext &Ctx,\n                                     FixItHint &Hint) {\n  if (isa<LabelDecl>(D)) {\n    SourceLocation AfterColon = Lexer::findLocationAfterToken(\n        D->getEndLoc(), tok::colon, Ctx.getSourceManager(), Ctx.getLangOpts(),\n        true);\n    if (AfterColon.isInvalid())\n      return;\n    Hint = FixItHint::CreateRemoval(\n        CharSourceRange::getCharRange(D->getBeginLoc(), AfterColon));\n  }\n}\n\nvoid Sema::DiagnoseUnusedNestedTypedefs(const RecordDecl *D) {\n  if (D->getTypeForDecl()->isDependentType())\n    return;\n\n  for (auto *TmpD : D->decls()) {\n    if (const auto *T = dyn_cast<TypedefNameDecl>(TmpD))\n      DiagnoseUnusedDecl(T);\n    else if(const auto *R = dyn_cast<RecordDecl>(TmpD))\n      DiagnoseUnusedNestedTypedefs(R);\n  }\n}\n\n/// DiagnoseUnusedDecl - Emit warnings about declarations that are not used\n/// unless they are marked attr(unused).\nvoid Sema::DiagnoseUnusedDecl(const NamedDecl *D) {\n  if (!ShouldDiagnoseUnusedDecl(D))\n    return;\n\n  if (auto *TD = dyn_cast<TypedefNameDecl>(D)) {\n    // typedefs can be referenced later on, so the diagnostics are emitted\n    // at end-of-translation-unit.\n    UnusedLocalTypedefNameCandidates.insert(TD);\n    return;\n  }\n\n  FixItHint Hint;\n  GenerateFixForUnusedDecl(D, Context, Hint);\n\n  unsigned DiagID;\n  if (isa<VarDecl>(D) && cast<VarDecl>(D)->isExceptionVariable())\n    DiagID = diag::warn_unused_exception_param;\n  else if (isa<LabelDecl>(D))\n    DiagID = diag::warn_unused_label;\n  else\n    DiagID = diag::warn_unused_variable;\n\n  Diag(D->getLocation(), DiagID) << D << Hint;\n}\n\nstatic void CheckPoppedLabel(LabelDecl *L, Sema &S) {\n  // Verify that we have no forward references left.  If so, there was a goto\n  // or address of a label taken, but no definition of it.  Label fwd\n  // definitions are indicated with a null substmt which is also not a resolved\n  // MS inline assembly label name.\n  bool Diagnose = false;\n  if (L->isMSAsmLabel())\n    Diagnose = !L->isResolvedMSAsmLabel();\n  else\n    Diagnose = L->getStmt() == nullptr;\n  if (Diagnose)\n    S.Diag(L->getLocation(), diag::err_undeclared_label_use) << L;\n}\n\nvoid Sema::ActOnPopScope(SourceLocation Loc, Scope *S) {\n  S->mergeNRVOIntoParent();\n\n  if (S->decl_empty()) return;\n  assert((S->getFlags() & (Scope::DeclScope | Scope::TemplateParamScope)) &&\n         \"Scope shouldn't contain decls!\");\n\n  for (auto *TmpD : S->decls()) {\n    assert(TmpD && \"This decl didn't get pushed??\");\n\n    assert(isa<NamedDecl>(TmpD) && \"Decl isn't NamedDecl?\");\n    NamedDecl *D = cast<NamedDecl>(TmpD);\n\n    // Diagnose unused variables in this scope.\n    if (!S->hasUnrecoverableErrorOccurred()) {\n      DiagnoseUnusedDecl(D);\n      if (const auto *RD = dyn_cast<RecordDecl>(D))\n        DiagnoseUnusedNestedTypedefs(RD);\n    }\n\n    if (!D->getDeclName()) continue;\n\n    // If this was a forward reference to a label, verify it was defined.\n    if (LabelDecl *LD = dyn_cast<LabelDecl>(D))\n      CheckPoppedLabel(LD, *this);\n\n    // Remove this name from our lexical scope, and warn on it if we haven't\n    // already.\n    IdResolver.RemoveDecl(D);\n    auto ShadowI = ShadowingDecls.find(D);\n    if (ShadowI != ShadowingDecls.end()) {\n      if (const auto *FD = dyn_cast<FieldDecl>(ShadowI->second)) {\n        Diag(D->getLocation(), diag::warn_ctor_parm_shadows_field)\n            << D << FD << FD->getParent();\n        Diag(FD->getLocation(), diag::note_previous_declaration);\n      }\n      ShadowingDecls.erase(ShadowI);\n    }\n  }\n}\n\n/// Look for an Objective-C class in the translation unit.\n///\n/// \\param Id The name of the Objective-C class we're looking for. If\n/// typo-correction fixes this name, the Id will be updated\n/// to the fixed name.\n///\n/// \\param IdLoc The location of the name in the translation unit.\n///\n/// \\param DoTypoCorrection If true, this routine will attempt typo correction\n/// if there is no class with the given name.\n///\n/// \\returns The declaration of the named Objective-C class, or NULL if the\n/// class could not be found.\nObjCInterfaceDecl *Sema::getObjCInterfaceDecl(IdentifierInfo *&Id,\n                                              SourceLocation IdLoc,\n                                              bool DoTypoCorrection) {\n  // The third \"scope\" argument is 0 since we aren't enabling lazy built-in\n  // creation from this context.\n  NamedDecl *IDecl = LookupSingleName(TUScope, Id, IdLoc, LookupOrdinaryName);\n\n  if (!IDecl && DoTypoCorrection) {\n    // Perform typo correction at the given location, but only if we\n    // find an Objective-C class name.\n    DeclFilterCCC<ObjCInterfaceDecl> CCC{};\n    if (TypoCorrection C =\n            CorrectTypo(DeclarationNameInfo(Id, IdLoc), LookupOrdinaryName,\n                        TUScope, nullptr, CCC, CTK_ErrorRecovery)) {\n      diagnoseTypo(C, PDiag(diag::err_undef_interface_suggest) << Id);\n      IDecl = C.getCorrectionDeclAs<ObjCInterfaceDecl>();\n      Id = IDecl->getIdentifier();\n    }\n  }\n  ObjCInterfaceDecl *Def = dyn_cast_or_null<ObjCInterfaceDecl>(IDecl);\n  // This routine must always return a class definition, if any.\n  if (Def && Def->getDefinition())\n      Def = Def->getDefinition();\n  return Def;\n}\n\n/// getNonFieldDeclScope - Retrieves the innermost scope, starting\n/// from S, where a non-field would be declared. This routine copes\n/// with the difference between C and C++ scoping rules in structs and\n/// unions. For example, the following code is well-formed in C but\n/// ill-formed in C++:\n/// @code\n/// struct S6 {\n///   enum { BAR } e;\n/// };\n///\n/// void test_S6() {\n///   struct S6 a;\n///   a.e = BAR;\n/// }\n/// @endcode\n/// For the declaration of BAR, this routine will return a different\n/// scope. The scope S will be the scope of the unnamed enumeration\n/// within S6. In C++, this routine will return the scope associated\n/// with S6, because the enumeration's scope is a transparent\n/// context but structures can contain non-field names. In C, this\n/// routine will return the translation unit scope, since the\n/// enumeration's scope is a transparent context and structures cannot\n/// contain non-field names.\nScope *Sema::getNonFieldDeclScope(Scope *S) {\n  while (((S->getFlags() & Scope::DeclScope) == 0) ||\n         (S->getEntity() && S->getEntity()->isTransparentContext()) ||\n         (S->isClassScope() && !getLangOpts().CPlusPlus))\n    S = S->getParent();\n  return S;\n}\n\nstatic StringRef getHeaderName(Builtin::Context &BuiltinInfo, unsigned ID,\n                               ASTContext::GetBuiltinTypeError Error) {\n  switch (Error) {\n  case ASTContext::GE_None:\n    return \"\";\n  case ASTContext::GE_Missing_type:\n    return BuiltinInfo.getHeaderName(ID);\n  case ASTContext::GE_Missing_stdio:\n    return \"stdio.h\";\n  case ASTContext::GE_Missing_setjmp:\n    return \"setjmp.h\";\n  case ASTContext::GE_Missing_ucontext:\n    return \"ucontext.h\";\n  }\n  llvm_unreachable(\"unhandled error kind\");\n}\n\nFunctionDecl *Sema::CreateBuiltin(IdentifierInfo *II, QualType Type,\n                                  unsigned ID, SourceLocation Loc) {\n  DeclContext *Parent = Context.getTranslationUnitDecl();\n\n  if (getLangOpts().CPlusPlus) {\n    LinkageSpecDecl *CLinkageDecl = LinkageSpecDecl::Create(\n        Context, Parent, Loc, Loc, LinkageSpecDecl::lang_c, false);\n    CLinkageDecl->setImplicit();\n    Parent->addDecl(CLinkageDecl);\n    Parent = CLinkageDecl;\n  }\n\n  FunctionDecl *New = FunctionDecl::Create(Context, Parent, Loc, Loc, II, Type,\n                                           /*TInfo=*/nullptr, SC_Extern, false,\n                                           Type->isFunctionProtoType());\n  New->setImplicit();\n  New->addAttr(BuiltinAttr::CreateImplicit(Context, ID));\n\n  // Create Decl objects for each parameter, adding them to the\n  // FunctionDecl.\n  if (const FunctionProtoType *FT = dyn_cast<FunctionProtoType>(Type)) {\n    SmallVector<ParmVarDecl *, 16> Params;\n    for (unsigned i = 0, e = FT->getNumParams(); i != e; ++i) {\n      ParmVarDecl *parm = ParmVarDecl::Create(\n          Context, New, SourceLocation(), SourceLocation(), nullptr,\n          FT->getParamType(i), /*TInfo=*/nullptr, SC_None, nullptr);\n      parm->setScopeInfo(0, i);\n      Params.push_back(parm);\n    }\n    New->setParams(Params);\n  }\n\n  AddKnownFunctionAttributes(New);\n  return New;\n}\n\n/// LazilyCreateBuiltin - The specified Builtin-ID was first used at\n/// file scope.  lazily create a decl for it. ForRedeclaration is true\n/// if we're creating this built-in in anticipation of redeclaring the\n/// built-in.\nNamedDecl *Sema::LazilyCreateBuiltin(IdentifierInfo *II, unsigned ID,\n                                     Scope *S, bool ForRedeclaration,\n                                     SourceLocation Loc) {\n  LookupNecessaryTypesForBuiltin(S, ID);\n\n  ASTContext::GetBuiltinTypeError Error;\n  QualType R = Context.GetBuiltinType(ID, Error);\n  if (Error) {\n    if (!ForRedeclaration)\n      return nullptr;\n\n    // If we have a builtin without an associated type we should not emit a\n    // warning when we were not able to find a type for it.\n    if (Error == ASTContext::GE_Missing_type ||\n        Context.BuiltinInfo.allowTypeMismatch(ID))\n      return nullptr;\n\n    // If we could not find a type for setjmp it is because the jmp_buf type was\n    // not defined prior to the setjmp declaration.\n    if (Error == ASTContext::GE_Missing_setjmp) {\n      Diag(Loc, diag::warn_implicit_decl_no_jmp_buf)\n          << Context.BuiltinInfo.getName(ID);\n      return nullptr;\n    }\n\n    // Generally, we emit a warning that the declaration requires the\n    // appropriate header.\n    Diag(Loc, diag::warn_implicit_decl_requires_sysheader)\n        << getHeaderName(Context.BuiltinInfo, ID, Error)\n        << Context.BuiltinInfo.getName(ID);\n    return nullptr;\n  }\n\n  if (!ForRedeclaration &&\n      (Context.BuiltinInfo.isPredefinedLibFunction(ID) ||\n       Context.BuiltinInfo.isHeaderDependentFunction(ID))) {\n    Diag(Loc, diag::ext_implicit_lib_function_decl)\n        << Context.BuiltinInfo.getName(ID) << R;\n    if (const char *Header = Context.BuiltinInfo.getHeaderName(ID))\n      Diag(Loc, diag::note_include_header_or_declare)\n          << Header << Context.BuiltinInfo.getName(ID);\n  }\n\n  if (R.isNull())\n    return nullptr;\n\n  FunctionDecl *New = CreateBuiltin(II, R, ID, Loc);\n  RegisterLocallyScopedExternCDecl(New, S);\n\n  // TUScope is the translation-unit scope to insert this function into.\n  // FIXME: This is hideous. We need to teach PushOnScopeChains to\n  // relate Scopes to DeclContexts, and probably eliminate CurContext\n  // entirely, but we're not there yet.\n  DeclContext *SavedContext = CurContext;\n  CurContext = New->getDeclContext();\n  PushOnScopeChains(New, TUScope);\n  CurContext = SavedContext;\n  return New;\n}\n\n/// Typedef declarations don't have linkage, but they still denote the same\n/// entity if their types are the same.\n/// FIXME: This is notionally doing the same thing as ASTReaderDecl's\n/// isSameEntity.\nstatic void filterNonConflictingPreviousTypedefDecls(Sema &S,\n                                                     TypedefNameDecl *Decl,\n                                                     LookupResult &Previous) {\n  // This is only interesting when modules are enabled.\n  if (!S.getLangOpts().Modules && !S.getLangOpts().ModulesLocalVisibility)\n    return;\n\n  // Empty sets are uninteresting.\n  if (Previous.empty())\n    return;\n\n  LookupResult::Filter Filter = Previous.makeFilter();\n  while (Filter.hasNext()) {\n    NamedDecl *Old = Filter.next();\n\n    // Non-hidden declarations are never ignored.\n    if (S.isVisible(Old))\n      continue;\n\n    // Declarations of the same entity are not ignored, even if they have\n    // different linkages.\n    if (auto *OldTD = dyn_cast<TypedefNameDecl>(Old)) {\n      if (S.Context.hasSameType(OldTD->getUnderlyingType(),\n                                Decl->getUnderlyingType()))\n        continue;\n\n      // If both declarations give a tag declaration a typedef name for linkage\n      // purposes, then they declare the same entity.\n      if (OldTD->getAnonDeclWithTypedefName(/*AnyRedecl*/true) &&\n          Decl->getAnonDeclWithTypedefName())\n        continue;\n    }\n\n    Filter.erase();\n  }\n\n  Filter.done();\n}\n\nbool Sema::isIncompatibleTypedef(TypeDecl *Old, TypedefNameDecl *New) {\n  QualType OldType;\n  if (TypedefNameDecl *OldTypedef = dyn_cast<TypedefNameDecl>(Old))\n    OldType = OldTypedef->getUnderlyingType();\n  else\n    OldType = Context.getTypeDeclType(Old);\n  QualType NewType = New->getUnderlyingType();\n\n  if (NewType->isVariablyModifiedType()) {\n    // Must not redefine a typedef with a variably-modified type.\n    int Kind = isa<TypeAliasDecl>(Old) ? 1 : 0;\n    Diag(New->getLocation(), diag::err_redefinition_variably_modified_typedef)\n      << Kind << NewType;\n    if (Old->getLocation().isValid())\n      notePreviousDefinition(Old, New->getLocation());\n    New->setInvalidDecl();\n    return true;\n  }\n\n  if (OldType != NewType &&\n      !OldType->isDependentType() &&\n      !NewType->isDependentType() &&\n      !Context.hasSameType(OldType, NewType)) {\n    int Kind = isa<TypeAliasDecl>(Old) ? 1 : 0;\n    Diag(New->getLocation(), diag::err_redefinition_different_typedef)\n      << Kind << NewType << OldType;\n    if (Old->getLocation().isValid())\n      notePreviousDefinition(Old, New->getLocation());\n    New->setInvalidDecl();\n    return true;\n  }\n  return false;\n}\n\n/// MergeTypedefNameDecl - We just parsed a typedef 'New' which has the\n/// same name and scope as a previous declaration 'Old'.  Figure out\n/// how to resolve this situation, merging decls or emitting\n/// diagnostics as appropriate. If there was an error, set New to be invalid.\n///\nvoid Sema::MergeTypedefNameDecl(Scope *S, TypedefNameDecl *New,\n                                LookupResult &OldDecls) {\n  // If the new decl is known invalid already, don't bother doing any\n  // merging checks.\n  if (New->isInvalidDecl()) return;\n\n  // Allow multiple definitions for ObjC built-in typedefs.\n  // FIXME: Verify the underlying types are equivalent!\n  if (getLangOpts().ObjC) {\n    const IdentifierInfo *TypeID = New->getIdentifier();\n    switch (TypeID->getLength()) {\n    default: break;\n    case 2:\n      {\n        if (!TypeID->isStr(\"id\"))\n          break;\n        QualType T = New->getUnderlyingType();\n        if (!T->isPointerType())\n          break;\n        if (!T->isVoidPointerType()) {\n          QualType PT = T->castAs<PointerType>()->getPointeeType();\n          if (!PT->isStructureType())\n            break;\n        }\n        Context.setObjCIdRedefinitionType(T);\n        // Install the built-in type for 'id', ignoring the current definition.\n        New->setTypeForDecl(Context.getObjCIdType().getTypePtr());\n        return;\n      }\n    case 5:\n      if (!TypeID->isStr(\"Class\"))\n        break;\n      Context.setObjCClassRedefinitionType(New->getUnderlyingType());\n      // Install the built-in type for 'Class', ignoring the current definition.\n      New->setTypeForDecl(Context.getObjCClassType().getTypePtr());\n      return;\n    case 3:\n      if (!TypeID->isStr(\"SEL\"))\n        break;\n      Context.setObjCSelRedefinitionType(New->getUnderlyingType());\n      // Install the built-in type for 'SEL', ignoring the current definition.\n      New->setTypeForDecl(Context.getObjCSelType().getTypePtr());\n      return;\n    }\n    // Fall through - the typedef name was not a builtin type.\n  }\n\n  // Verify the old decl was also a type.\n  TypeDecl *Old = OldDecls.getAsSingle<TypeDecl>();\n  if (!Old) {\n    Diag(New->getLocation(), diag::err_redefinition_different_kind)\n      << New->getDeclName();\n\n    NamedDecl *OldD = OldDecls.getRepresentativeDecl();\n    if (OldD->getLocation().isValid())\n      notePreviousDefinition(OldD, New->getLocation());\n\n    return New->setInvalidDecl();\n  }\n\n  // If the old declaration is invalid, just give up here.\n  if (Old->isInvalidDecl())\n    return New->setInvalidDecl();\n\n  if (auto *OldTD = dyn_cast<TypedefNameDecl>(Old)) {\n    auto *OldTag = OldTD->getAnonDeclWithTypedefName(/*AnyRedecl*/true);\n    auto *NewTag = New->getAnonDeclWithTypedefName();\n    NamedDecl *Hidden = nullptr;\n    if (OldTag && NewTag &&\n        OldTag->getCanonicalDecl() != NewTag->getCanonicalDecl() &&\n        !hasVisibleDefinition(OldTag, &Hidden)) {\n      // There is a definition of this tag, but it is not visible. Use it\n      // instead of our tag.\n      New->setTypeForDecl(OldTD->getTypeForDecl());\n      if (OldTD->isModed())\n        New->setModedTypeSourceInfo(OldTD->getTypeSourceInfo(),\n                                    OldTD->getUnderlyingType());\n      else\n        New->setTypeSourceInfo(OldTD->getTypeSourceInfo());\n\n      // Make the old tag definition visible.\n      makeMergedDefinitionVisible(Hidden);\n\n      // If this was an unscoped enumeration, yank all of its enumerators\n      // out of the scope.\n      if (isa<EnumDecl>(NewTag)) {\n        Scope *EnumScope = getNonFieldDeclScope(S);\n        for (auto *D : NewTag->decls()) {\n          auto *ED = cast<EnumConstantDecl>(D);\n          assert(EnumScope->isDeclScope(ED));\n          EnumScope->RemoveDecl(ED);\n          IdResolver.RemoveDecl(ED);\n          ED->getLexicalDeclContext()->removeDecl(ED);\n        }\n      }\n    }\n  }\n\n  // If the typedef types are not identical, reject them in all languages and\n  // with any extensions enabled.\n  if (isIncompatibleTypedef(Old, New))\n    return;\n\n  // The types match.  Link up the redeclaration chain and merge attributes if\n  // the old declaration was a typedef.\n  if (TypedefNameDecl *Typedef = dyn_cast<TypedefNameDecl>(Old)) {\n    New->setPreviousDecl(Typedef);\n    mergeDeclAttributes(New, Old);\n  }\n\n  if (getLangOpts().MicrosoftExt)\n    return;\n\n  if (getLangOpts().CPlusPlus) {\n    // C++ [dcl.typedef]p2:\n    //   In a given non-class scope, a typedef specifier can be used to\n    //   redefine the name of any type declared in that scope to refer\n    //   to the type to which it already refers.\n    if (!isa<CXXRecordDecl>(CurContext))\n      return;\n\n    // C++0x [dcl.typedef]p4:\n    //   In a given class scope, a typedef specifier can be used to redefine\n    //   any class-name declared in that scope that is not also a typedef-name\n    //   to refer to the type to which it already refers.\n    //\n    // This wording came in via DR424, which was a correction to the\n    // wording in DR56, which accidentally banned code like:\n    //\n    //   struct S {\n    //     typedef struct A { } A;\n    //   };\n    //\n    // in the C++03 standard. We implement the C++0x semantics, which\n    // allow the above but disallow\n    //\n    //   struct S {\n    //     typedef int I;\n    //     typedef int I;\n    //   };\n    //\n    // since that was the intent of DR56.\n    if (!isa<TypedefNameDecl>(Old))\n      return;\n\n    Diag(New->getLocation(), diag::err_redefinition)\n      << New->getDeclName();\n    notePreviousDefinition(Old, New->getLocation());\n    return New->setInvalidDecl();\n  }\n\n  // Modules always permit redefinition of typedefs, as does C11.\n  if (getLangOpts().Modules || getLangOpts().C11)\n    return;\n\n  // If we have a redefinition of a typedef in C, emit a warning.  This warning\n  // is normally mapped to an error, but can be controlled with\n  // -Wtypedef-redefinition.  If either the original or the redefinition is\n  // in a system header, don't emit this for compatibility with GCC.\n  if (getDiagnostics().getSuppressSystemWarnings() &&\n      // Some standard types are defined implicitly in Clang (e.g. OpenCL).\n      (Old->isImplicit() ||\n       Context.getSourceManager().isInSystemHeader(Old->getLocation()) ||\n       Context.getSourceManager().isInSystemHeader(New->getLocation())))\n    return;\n\n  Diag(New->getLocation(), diag::ext_redefinition_of_typedef)\n    << New->getDeclName();\n  notePreviousDefinition(Old, New->getLocation());\n}\n\n/// DeclhasAttr - returns true if decl Declaration already has the target\n/// attribute.\nstatic bool DeclHasAttr(const Decl *D, const Attr *A) {\n  const OwnershipAttr *OA = dyn_cast<OwnershipAttr>(A);\n  const AnnotateAttr *Ann = dyn_cast<AnnotateAttr>(A);\n  for (const auto *i : D->attrs())\n    if (i->getKind() == A->getKind()) {\n      if (Ann) {\n        if (Ann->getAnnotation() == cast<AnnotateAttr>(i)->getAnnotation())\n          return true;\n        continue;\n      }\n      // FIXME: Don't hardcode this check\n      if (OA && isa<OwnershipAttr>(i))\n        return OA->getOwnKind() == cast<OwnershipAttr>(i)->getOwnKind();\n      return true;\n    }\n\n  return false;\n}\n\nstatic bool isAttributeTargetADefinition(Decl *D) {\n  if (VarDecl *VD = dyn_cast<VarDecl>(D))\n    return VD->isThisDeclarationADefinition();\n  if (TagDecl *TD = dyn_cast<TagDecl>(D))\n    return TD->isCompleteDefinition() || TD->isBeingDefined();\n  return true;\n}\n\n/// Merge alignment attributes from \\p Old to \\p New, taking into account the\n/// special semantics of C11's _Alignas specifier and C++11's alignas attribute.\n///\n/// \\return \\c true if any attributes were added to \\p New.\nstatic bool mergeAlignedAttrs(Sema &S, NamedDecl *New, Decl *Old) {\n  // Look for alignas attributes on Old, and pick out whichever attribute\n  // specifies the strictest alignment requirement.\n  AlignedAttr *OldAlignasAttr = nullptr;\n  AlignedAttr *OldStrictestAlignAttr = nullptr;\n  unsigned OldAlign = 0;\n  for (auto *I : Old->specific_attrs<AlignedAttr>()) {\n    // FIXME: We have no way of representing inherited dependent alignments\n    // in a case like:\n    //   template<int A, int B> struct alignas(A) X;\n    //   template<int A, int B> struct alignas(B) X {};\n    // For now, we just ignore any alignas attributes which are not on the\n    // definition in such a case.\n    if (I->isAlignmentDependent())\n      return false;\n\n    if (I->isAlignas())\n      OldAlignasAttr = I;\n\n    unsigned Align = I->getAlignment(S.Context);\n    if (Align > OldAlign) {\n      OldAlign = Align;\n      OldStrictestAlignAttr = I;\n    }\n  }\n\n  // Look for alignas attributes on New.\n  AlignedAttr *NewAlignasAttr = nullptr;\n  unsigned NewAlign = 0;\n  for (auto *I : New->specific_attrs<AlignedAttr>()) {\n    if (I->isAlignmentDependent())\n      return false;\n\n    if (I->isAlignas())\n      NewAlignasAttr = I;\n\n    unsigned Align = I->getAlignment(S.Context);\n    if (Align > NewAlign)\n      NewAlign = Align;\n  }\n\n  if (OldAlignasAttr && NewAlignasAttr && OldAlign != NewAlign) {\n    // Both declarations have 'alignas' attributes. We require them to match.\n    // C++11 [dcl.align]p6 and C11 6.7.5/7 both come close to saying this, but\n    // fall short. (If two declarations both have alignas, they must both match\n    // every definition, and so must match each other if there is a definition.)\n\n    // If either declaration only contains 'alignas(0)' specifiers, then it\n    // specifies the natural alignment for the type.\n    if (OldAlign == 0 || NewAlign == 0) {\n      QualType Ty;\n      if (ValueDecl *VD = dyn_cast<ValueDecl>(New))\n        Ty = VD->getType();\n      else\n        Ty = S.Context.getTagDeclType(cast<TagDecl>(New));\n\n      if (OldAlign == 0)\n        OldAlign = S.Context.getTypeAlign(Ty);\n      if (NewAlign == 0)\n        NewAlign = S.Context.getTypeAlign(Ty);\n    }\n\n    if (OldAlign != NewAlign) {\n      S.Diag(NewAlignasAttr->getLocation(), diag::err_alignas_mismatch)\n        << (unsigned)S.Context.toCharUnitsFromBits(OldAlign).getQuantity()\n        << (unsigned)S.Context.toCharUnitsFromBits(NewAlign).getQuantity();\n      S.Diag(OldAlignasAttr->getLocation(), diag::note_previous_declaration);\n    }\n  }\n\n  if (OldAlignasAttr && !NewAlignasAttr && isAttributeTargetADefinition(New)) {\n    // C++11 [dcl.align]p6:\n    //   if any declaration of an entity has an alignment-specifier,\n    //   every defining declaration of that entity shall specify an\n    //   equivalent alignment.\n    // C11 6.7.5/7:\n    //   If the definition of an object does not have an alignment\n    //   specifier, any other declaration of that object shall also\n    //   have no alignment specifier.\n    S.Diag(New->getLocation(), diag::err_alignas_missing_on_definition)\n      << OldAlignasAttr;\n    S.Diag(OldAlignasAttr->getLocation(), diag::note_alignas_on_declaration)\n      << OldAlignasAttr;\n  }\n\n  bool AnyAdded = false;\n\n  // Ensure we have an attribute representing the strictest alignment.\n  if (OldAlign > NewAlign) {\n    AlignedAttr *Clone = OldStrictestAlignAttr->clone(S.Context);\n    Clone->setInherited(true);\n    New->addAttr(Clone);\n    AnyAdded = true;\n  }\n\n  // Ensure we have an alignas attribute if the old declaration had one.\n  if (OldAlignasAttr && !NewAlignasAttr &&\n      !(AnyAdded && OldStrictestAlignAttr->isAlignas())) {\n    AlignedAttr *Clone = OldAlignasAttr->clone(S.Context);\n    Clone->setInherited(true);\n    New->addAttr(Clone);\n    AnyAdded = true;\n  }\n\n  return AnyAdded;\n}\n\nstatic bool mergeDeclAttribute(Sema &S, NamedDecl *D,\n                               const InheritableAttr *Attr,\n                               Sema::AvailabilityMergeKind AMK) {\n  // This function copies an attribute Attr from a previous declaration to the\n  // new declaration D if the new declaration doesn't itself have that attribute\n  // yet or if that attribute allows duplicates.\n  // If you're adding a new attribute that requires logic different from\n  // \"use explicit attribute on decl if present, else use attribute from\n  // previous decl\", for example if the attribute needs to be consistent\n  // between redeclarations, you need to call a custom merge function here.\n  InheritableAttr *NewAttr = nullptr;\n  if (const auto *AA = dyn_cast<AvailabilityAttr>(Attr))\n    NewAttr = S.mergeAvailabilityAttr(\n        D, *AA, AA->getPlatform(), AA->isImplicit(), AA->getIntroduced(),\n        AA->getDeprecated(), AA->getObsoleted(), AA->getUnavailable(),\n        AA->getMessage(), AA->getStrict(), AA->getReplacement(), AMK,\n        AA->getPriority());\n  else if (const auto *VA = dyn_cast<VisibilityAttr>(Attr))\n    NewAttr = S.mergeVisibilityAttr(D, *VA, VA->getVisibility());\n  else if (const auto *VA = dyn_cast<TypeVisibilityAttr>(Attr))\n    NewAttr = S.mergeTypeVisibilityAttr(D, *VA, VA->getVisibility());\n  else if (const auto *ImportA = dyn_cast<DLLImportAttr>(Attr))\n    NewAttr = S.mergeDLLImportAttr(D, *ImportA);\n  else if (const auto *ExportA = dyn_cast<DLLExportAttr>(Attr))\n    NewAttr = S.mergeDLLExportAttr(D, *ExportA);\n  else if (const auto *FA = dyn_cast<FormatAttr>(Attr))\n    NewAttr = S.mergeFormatAttr(D, *FA, FA->getType(), FA->getFormatIdx(),\n                                FA->getFirstArg());\n  else if (const auto *SA = dyn_cast<SectionAttr>(Attr))\n    NewAttr = S.mergeSectionAttr(D, *SA, SA->getName());\n  else if (const auto *CSA = dyn_cast<CodeSegAttr>(Attr))\n    NewAttr = S.mergeCodeSegAttr(D, *CSA, CSA->getName());\n  else if (const auto *IA = dyn_cast<MSInheritanceAttr>(Attr))\n    NewAttr = S.mergeMSInheritanceAttr(D, *IA, IA->getBestCase(),\n                                       IA->getInheritanceModel());\n  else if (const auto *AA = dyn_cast<AlwaysInlineAttr>(Attr))\n    NewAttr = S.mergeAlwaysInlineAttr(D, *AA,\n                                      &S.Context.Idents.get(AA->getSpelling()));\n  else if (S.getLangOpts().CUDA && isa<FunctionDecl>(D) &&\n           (isa<CUDAHostAttr>(Attr) || isa<CUDADeviceAttr>(Attr) ||\n            isa<CUDAGlobalAttr>(Attr))) {\n    // CUDA target attributes are part of function signature for\n    // overloading purposes and must not be merged.\n    return false;\n  } else if (const auto *MA = dyn_cast<MinSizeAttr>(Attr))\n    NewAttr = S.mergeMinSizeAttr(D, *MA);\n  else if (const auto *SNA = dyn_cast<SwiftNameAttr>(Attr))\n    NewAttr = S.mergeSwiftNameAttr(D, *SNA, SNA->getName());\n  else if (const auto *OA = dyn_cast<OptimizeNoneAttr>(Attr))\n    NewAttr = S.mergeOptimizeNoneAttr(D, *OA);\n  else if (const auto *InternalLinkageA = dyn_cast<InternalLinkageAttr>(Attr))\n    NewAttr = S.mergeInternalLinkageAttr(D, *InternalLinkageA);\n  else if (const auto *CommonA = dyn_cast<CommonAttr>(Attr))\n    NewAttr = S.mergeCommonAttr(D, *CommonA);\n  else if (isa<AlignedAttr>(Attr))\n    // AlignedAttrs are handled separately, because we need to handle all\n    // such attributes on a declaration at the same time.\n    NewAttr = nullptr;\n  else if ((isa<DeprecatedAttr>(Attr) || isa<UnavailableAttr>(Attr)) &&\n           (AMK == Sema::AMK_Override ||\n            AMK == Sema::AMK_ProtocolImplementation))\n    NewAttr = nullptr;\n  else if (const auto *UA = dyn_cast<UuidAttr>(Attr))\n    NewAttr = S.mergeUuidAttr(D, *UA, UA->getGuid(), UA->getGuidDecl());\n  else if (const auto *SLHA = dyn_cast<SpeculativeLoadHardeningAttr>(Attr))\n    NewAttr = S.mergeSpeculativeLoadHardeningAttr(D, *SLHA);\n  else if (const auto *SLHA = dyn_cast<NoSpeculativeLoadHardeningAttr>(Attr))\n    NewAttr = S.mergeNoSpeculativeLoadHardeningAttr(D, *SLHA);\n  else if (const auto *IMA = dyn_cast<WebAssemblyImportModuleAttr>(Attr))\n    NewAttr = S.mergeImportModuleAttr(D, *IMA);\n  else if (const auto *INA = dyn_cast<WebAssemblyImportNameAttr>(Attr))\n    NewAttr = S.mergeImportNameAttr(D, *INA);\n  else if (const auto *TCBA = dyn_cast<EnforceTCBAttr>(Attr))\n    NewAttr = S.mergeEnforceTCBAttr(D, *TCBA);\n  else if (const auto *TCBLA = dyn_cast<EnforceTCBLeafAttr>(Attr))\n    NewAttr = S.mergeEnforceTCBLeafAttr(D, *TCBLA);\n  else if (Attr->shouldInheritEvenIfAlreadyPresent() || !DeclHasAttr(D, Attr))\n    NewAttr = cast<InheritableAttr>(Attr->clone(S.Context));\n\n  if (NewAttr) {\n    NewAttr->setInherited(true);\n    D->addAttr(NewAttr);\n    if (isa<MSInheritanceAttr>(NewAttr))\n      S.Consumer.AssignInheritanceModel(cast<CXXRecordDecl>(D));\n    return true;\n  }\n\n  return false;\n}\n\nstatic const NamedDecl *getDefinition(const Decl *D) {\n  if (const TagDecl *TD = dyn_cast<TagDecl>(D))\n    return TD->getDefinition();\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    const VarDecl *Def = VD->getDefinition();\n    if (Def)\n      return Def;\n    return VD->getActingDefinition();\n  }\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    const FunctionDecl *Def = nullptr;\n    if (FD->isDefined(Def, true))\n      return Def;\n  }\n  return nullptr;\n}\n\nstatic bool hasAttribute(const Decl *D, attr::Kind Kind) {\n  for (const auto *Attribute : D->attrs())\n    if (Attribute->getKind() == Kind)\n      return true;\n  return false;\n}\n\n/// checkNewAttributesAfterDef - If we already have a definition, check that\n/// there are no new attributes in this declaration.\nstatic void checkNewAttributesAfterDef(Sema &S, Decl *New, const Decl *Old) {\n  if (!New->hasAttrs())\n    return;\n\n  const NamedDecl *Def = getDefinition(Old);\n  if (!Def || Def == New)\n    return;\n\n  AttrVec &NewAttributes = New->getAttrs();\n  for (unsigned I = 0, E = NewAttributes.size(); I != E;) {\n    const Attr *NewAttribute = NewAttributes[I];\n\n    if (isa<AliasAttr>(NewAttribute) || isa<IFuncAttr>(NewAttribute)) {\n      if (FunctionDecl *FD = dyn_cast<FunctionDecl>(New)) {\n        Sema::SkipBodyInfo SkipBody;\n        S.CheckForFunctionRedefinition(FD, cast<FunctionDecl>(Def), &SkipBody);\n\n        // If we're skipping this definition, drop the \"alias\" attribute.\n        if (SkipBody.ShouldSkip) {\n          NewAttributes.erase(NewAttributes.begin() + I);\n          --E;\n          continue;\n        }\n      } else {\n        VarDecl *VD = cast<VarDecl>(New);\n        unsigned Diag = cast<VarDecl>(Def)->isThisDeclarationADefinition() ==\n                                VarDecl::TentativeDefinition\n                            ? diag::err_alias_after_tentative\n                            : diag::err_redefinition;\n        S.Diag(VD->getLocation(), Diag) << VD->getDeclName();\n        if (Diag == diag::err_redefinition)\n          S.notePreviousDefinition(Def, VD->getLocation());\n        else\n          S.Diag(Def->getLocation(), diag::note_previous_definition);\n        VD->setInvalidDecl();\n      }\n      ++I;\n      continue;\n    }\n\n    if (const VarDecl *VD = dyn_cast<VarDecl>(Def)) {\n      // Tentative definitions are only interesting for the alias check above.\n      if (VD->isThisDeclarationADefinition() != VarDecl::Definition) {\n        ++I;\n        continue;\n      }\n    }\n\n    if (hasAttribute(Def, NewAttribute->getKind())) {\n      ++I;\n      continue; // regular attr merging will take care of validating this.\n    }\n\n    if (isa<C11NoReturnAttr>(NewAttribute)) {\n      // C's _Noreturn is allowed to be added to a function after it is defined.\n      ++I;\n      continue;\n    } else if (isa<UuidAttr>(NewAttribute)) {\n      // msvc will allow a subsequent definition to add an uuid to a class\n      ++I;\n      continue;\n    } else if (const AlignedAttr *AA = dyn_cast<AlignedAttr>(NewAttribute)) {\n      if (AA->isAlignas()) {\n        // C++11 [dcl.align]p6:\n        //   if any declaration of an entity has an alignment-specifier,\n        //   every defining declaration of that entity shall specify an\n        //   equivalent alignment.\n        // C11 6.7.5/7:\n        //   If the definition of an object does not have an alignment\n        //   specifier, any other declaration of that object shall also\n        //   have no alignment specifier.\n        S.Diag(Def->getLocation(), diag::err_alignas_missing_on_definition)\n          << AA;\n        S.Diag(NewAttribute->getLocation(), diag::note_alignas_on_declaration)\n          << AA;\n        NewAttributes.erase(NewAttributes.begin() + I);\n        --E;\n        continue;\n      }\n    } else if (isa<LoaderUninitializedAttr>(NewAttribute)) {\n      // If there is a C definition followed by a redeclaration with this\n      // attribute then there are two different definitions. In C++, prefer the\n      // standard diagnostics.\n      if (!S.getLangOpts().CPlusPlus) {\n        S.Diag(NewAttribute->getLocation(),\n               diag::err_loader_uninitialized_redeclaration);\n        S.Diag(Def->getLocation(), diag::note_previous_definition);\n        NewAttributes.erase(NewAttributes.begin() + I);\n        --E;\n        continue;\n      }\n    } else if (isa<SelectAnyAttr>(NewAttribute) &&\n               cast<VarDecl>(New)->isInline() &&\n               !cast<VarDecl>(New)->isInlineSpecified()) {\n      // Don't warn about applying selectany to implicitly inline variables.\n      // Older compilers and language modes would require the use of selectany\n      // to make such variables inline, and it would have no effect if we\n      // honored it.\n      ++I;\n      continue;\n    } else if (isa<OMPDeclareVariantAttr>(NewAttribute)) {\n      // We allow to add OMP[Begin]DeclareVariantAttr to be added to\n      // declarations after defintions.\n      ++I;\n      continue;\n    }\n\n    S.Diag(NewAttribute->getLocation(),\n           diag::warn_attribute_precede_definition);\n    S.Diag(Def->getLocation(), diag::note_previous_definition);\n    NewAttributes.erase(NewAttributes.begin() + I);\n    --E;\n  }\n}\n\nstatic void diagnoseMissingConstinit(Sema &S, const VarDecl *InitDecl,\n                                     const ConstInitAttr *CIAttr,\n                                     bool AttrBeforeInit) {\n  SourceLocation InsertLoc = InitDecl->getInnerLocStart();\n\n  // Figure out a good way to write this specifier on the old declaration.\n  // FIXME: We should just use the spelling of CIAttr, but we don't preserve\n  // enough of the attribute list spelling information to extract that without\n  // heroics.\n  std::string SuitableSpelling;\n  if (S.getLangOpts().CPlusPlus20)\n    SuitableSpelling = std::string(\n        S.PP.getLastMacroWithSpelling(InsertLoc, {tok::kw_constinit}));\n  if (SuitableSpelling.empty() && S.getLangOpts().CPlusPlus11)\n    SuitableSpelling = std::string(S.PP.getLastMacroWithSpelling(\n        InsertLoc, {tok::l_square, tok::l_square,\n                    S.PP.getIdentifierInfo(\"clang\"), tok::coloncolon,\n                    S.PP.getIdentifierInfo(\"require_constant_initialization\"),\n                    tok::r_square, tok::r_square}));\n  if (SuitableSpelling.empty())\n    SuitableSpelling = std::string(S.PP.getLastMacroWithSpelling(\n        InsertLoc, {tok::kw___attribute, tok::l_paren, tok::r_paren,\n                    S.PP.getIdentifierInfo(\"require_constant_initialization\"),\n                    tok::r_paren, tok::r_paren}));\n  if (SuitableSpelling.empty() && S.getLangOpts().CPlusPlus20)\n    SuitableSpelling = \"constinit\";\n  if (SuitableSpelling.empty() && S.getLangOpts().CPlusPlus11)\n    SuitableSpelling = \"[[clang::require_constant_initialization]]\";\n  if (SuitableSpelling.empty())\n    SuitableSpelling = \"__attribute__((require_constant_initialization))\";\n  SuitableSpelling += \" \";\n\n  if (AttrBeforeInit) {\n    // extern constinit int a;\n    // int a = 0; // error (missing 'constinit'), accepted as extension\n    assert(CIAttr->isConstinit() && \"should not diagnose this for attribute\");\n    S.Diag(InitDecl->getLocation(), diag::ext_constinit_missing)\n        << InitDecl << FixItHint::CreateInsertion(InsertLoc, SuitableSpelling);\n    S.Diag(CIAttr->getLocation(), diag::note_constinit_specified_here);\n  } else {\n    // int a = 0;\n    // constinit extern int a; // error (missing 'constinit')\n    S.Diag(CIAttr->getLocation(),\n           CIAttr->isConstinit() ? diag::err_constinit_added_too_late\n                                 : diag::warn_require_const_init_added_too_late)\n        << FixItHint::CreateRemoval(SourceRange(CIAttr->getLocation()));\n    S.Diag(InitDecl->getLocation(), diag::note_constinit_missing_here)\n        << CIAttr->isConstinit()\n        << FixItHint::CreateInsertion(InsertLoc, SuitableSpelling);\n  }\n}\n\n/// mergeDeclAttributes - Copy attributes from the Old decl to the New one.\nvoid Sema::mergeDeclAttributes(NamedDecl *New, Decl *Old,\n                               AvailabilityMergeKind AMK) {\n  if (UsedAttr *OldAttr = Old->getMostRecentDecl()->getAttr<UsedAttr>()) {\n    UsedAttr *NewAttr = OldAttr->clone(Context);\n    NewAttr->setInherited(true);\n    New->addAttr(NewAttr);\n  }\n  if (RetainAttr *OldAttr = Old->getMostRecentDecl()->getAttr<RetainAttr>()) {\n    RetainAttr *NewAttr = OldAttr->clone(Context);\n    NewAttr->setInherited(true);\n    New->addAttr(NewAttr);\n  }\n\n  if (!Old->hasAttrs() && !New->hasAttrs())\n    return;\n\n  // [dcl.constinit]p1:\n  //   If the [constinit] specifier is applied to any declaration of a\n  //   variable, it shall be applied to the initializing declaration.\n  const auto *OldConstInit = Old->getAttr<ConstInitAttr>();\n  const auto *NewConstInit = New->getAttr<ConstInitAttr>();\n  if (bool(OldConstInit) != bool(NewConstInit)) {\n    const auto *OldVD = cast<VarDecl>(Old);\n    auto *NewVD = cast<VarDecl>(New);\n\n    // Find the initializing declaration. Note that we might not have linked\n    // the new declaration into the redeclaration chain yet.\n    const VarDecl *InitDecl = OldVD->getInitializingDeclaration();\n    if (!InitDecl &&\n        (NewVD->hasInit() || NewVD->isThisDeclarationADefinition()))\n      InitDecl = NewVD;\n\n    if (InitDecl == NewVD) {\n      // This is the initializing declaration. If it would inherit 'constinit',\n      // that's ill-formed. (Note that we do not apply this to the attribute\n      // form).\n      if (OldConstInit && OldConstInit->isConstinit())\n        diagnoseMissingConstinit(*this, NewVD, OldConstInit,\n                                 /*AttrBeforeInit=*/true);\n    } else if (NewConstInit) {\n      // This is the first time we've been told that this declaration should\n      // have a constant initializer. If we already saw the initializing\n      // declaration, this is too late.\n      if (InitDecl && InitDecl != NewVD) {\n        diagnoseMissingConstinit(*this, InitDecl, NewConstInit,\n                                 /*AttrBeforeInit=*/false);\n        NewVD->dropAttr<ConstInitAttr>();\n      }\n    }\n  }\n\n  // Attributes declared post-definition are currently ignored.\n  checkNewAttributesAfterDef(*this, New, Old);\n\n  if (AsmLabelAttr *NewA = New->getAttr<AsmLabelAttr>()) {\n    if (AsmLabelAttr *OldA = Old->getAttr<AsmLabelAttr>()) {\n      if (!OldA->isEquivalent(NewA)) {\n        // This redeclaration changes __asm__ label.\n        Diag(New->getLocation(), diag::err_different_asm_label);\n        Diag(OldA->getLocation(), diag::note_previous_declaration);\n      }\n    } else if (Old->isUsed()) {\n      // This redeclaration adds an __asm__ label to a declaration that has\n      // already been ODR-used.\n      Diag(New->getLocation(), diag::err_late_asm_label_name)\n        << isa<FunctionDecl>(Old) << New->getAttr<AsmLabelAttr>()->getRange();\n    }\n  }\n\n  // Re-declaration cannot add abi_tag's.\n  if (const auto *NewAbiTagAttr = New->getAttr<AbiTagAttr>()) {\n    if (const auto *OldAbiTagAttr = Old->getAttr<AbiTagAttr>()) {\n      for (const auto &NewTag : NewAbiTagAttr->tags()) {\n        if (std::find(OldAbiTagAttr->tags_begin(), OldAbiTagAttr->tags_end(),\n                      NewTag) == OldAbiTagAttr->tags_end()) {\n          Diag(NewAbiTagAttr->getLocation(),\n               diag::err_new_abi_tag_on_redeclaration)\n              << NewTag;\n          Diag(OldAbiTagAttr->getLocation(), diag::note_previous_declaration);\n        }\n      }\n    } else {\n      Diag(NewAbiTagAttr->getLocation(), diag::err_abi_tag_on_redeclaration);\n      Diag(Old->getLocation(), diag::note_previous_declaration);\n    }\n  }\n\n  // This redeclaration adds a section attribute.\n  if (New->hasAttr<SectionAttr>() && !Old->hasAttr<SectionAttr>()) {\n    if (auto *VD = dyn_cast<VarDecl>(New)) {\n      if (VD->isThisDeclarationADefinition() == VarDecl::DeclarationOnly) {\n        Diag(New->getLocation(), diag::warn_attribute_section_on_redeclaration);\n        Diag(Old->getLocation(), diag::note_previous_declaration);\n      }\n    }\n  }\n\n  // Redeclaration adds code-seg attribute.\n  const auto *NewCSA = New->getAttr<CodeSegAttr>();\n  if (NewCSA && !Old->hasAttr<CodeSegAttr>() &&\n      !NewCSA->isImplicit() && isa<CXXMethodDecl>(New)) {\n    Diag(New->getLocation(), diag::warn_mismatched_section)\n         << 0 /*codeseg*/;\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n  }\n\n  if (!Old->hasAttrs())\n    return;\n\n  bool foundAny = New->hasAttrs();\n\n  // Ensure that any moving of objects within the allocated map is done before\n  // we process them.\n  if (!foundAny) New->setAttrs(AttrVec());\n\n  for (auto *I : Old->specific_attrs<InheritableAttr>()) {\n    // Ignore deprecated/unavailable/availability attributes if requested.\n    AvailabilityMergeKind LocalAMK = AMK_None;\n    if (isa<DeprecatedAttr>(I) ||\n        isa<UnavailableAttr>(I) ||\n        isa<AvailabilityAttr>(I)) {\n      switch (AMK) {\n      case AMK_None:\n        continue;\n\n      case AMK_Redeclaration:\n      case AMK_Override:\n      case AMK_ProtocolImplementation:\n        LocalAMK = AMK;\n        break;\n      }\n    }\n\n    // Already handled.\n    if (isa<UsedAttr>(I) || isa<RetainAttr>(I))\n      continue;\n\n    if (mergeDeclAttribute(*this, New, I, LocalAMK))\n      foundAny = true;\n  }\n\n  if (mergeAlignedAttrs(*this, New, Old))\n    foundAny = true;\n\n  if (!foundAny) New->dropAttrs();\n}\n\n/// mergeParamDeclAttributes - Copy attributes from the old parameter\n/// to the new one.\nstatic void mergeParamDeclAttributes(ParmVarDecl *newDecl,\n                                     const ParmVarDecl *oldDecl,\n                                     Sema &S) {\n  // C++11 [dcl.attr.depend]p2:\n  //   The first declaration of a function shall specify the\n  //   carries_dependency attribute for its declarator-id if any declaration\n  //   of the function specifies the carries_dependency attribute.\n  const CarriesDependencyAttr *CDA = newDecl->getAttr<CarriesDependencyAttr>();\n  if (CDA && !oldDecl->hasAttr<CarriesDependencyAttr>()) {\n    S.Diag(CDA->getLocation(),\n           diag::err_carries_dependency_missing_on_first_decl) << 1/*Param*/;\n    // Find the first declaration of the parameter.\n    // FIXME: Should we build redeclaration chains for function parameters?\n    const FunctionDecl *FirstFD =\n      cast<FunctionDecl>(oldDecl->getDeclContext())->getFirstDecl();\n    const ParmVarDecl *FirstVD =\n      FirstFD->getParamDecl(oldDecl->getFunctionScopeIndex());\n    S.Diag(FirstVD->getLocation(),\n           diag::note_carries_dependency_missing_first_decl) << 1/*Param*/;\n  }\n\n  if (!oldDecl->hasAttrs())\n    return;\n\n  bool foundAny = newDecl->hasAttrs();\n\n  // Ensure that any moving of objects within the allocated map is\n  // done before we process them.\n  if (!foundAny) newDecl->setAttrs(AttrVec());\n\n  for (const auto *I : oldDecl->specific_attrs<InheritableParamAttr>()) {\n    if (!DeclHasAttr(newDecl, I)) {\n      InheritableAttr *newAttr =\n        cast<InheritableParamAttr>(I->clone(S.Context));\n      newAttr->setInherited(true);\n      newDecl->addAttr(newAttr);\n      foundAny = true;\n    }\n  }\n\n  if (!foundAny) newDecl->dropAttrs();\n}\n\nstatic void mergeParamDeclTypes(ParmVarDecl *NewParam,\n                                const ParmVarDecl *OldParam,\n                                Sema &S) {\n  if (auto Oldnullability = OldParam->getType()->getNullability(S.Context)) {\n    if (auto Newnullability = NewParam->getType()->getNullability(S.Context)) {\n      if (*Oldnullability != *Newnullability) {\n        S.Diag(NewParam->getLocation(), diag::warn_mismatched_nullability_attr)\n          << DiagNullabilityKind(\n               *Newnullability,\n               ((NewParam->getObjCDeclQualifier() & Decl::OBJC_TQ_CSNullability)\n                != 0))\n          << DiagNullabilityKind(\n               *Oldnullability,\n               ((OldParam->getObjCDeclQualifier() & Decl::OBJC_TQ_CSNullability)\n                != 0));\n        S.Diag(OldParam->getLocation(), diag::note_previous_declaration);\n      }\n    } else {\n      QualType NewT = NewParam->getType();\n      NewT = S.Context.getAttributedType(\n                         AttributedType::getNullabilityAttrKind(*Oldnullability),\n                         NewT, NewT);\n      NewParam->setType(NewT);\n    }\n  }\n}\n\nnamespace {\n\n/// Used in MergeFunctionDecl to keep track of function parameters in\n/// C.\nstruct GNUCompatibleParamWarning {\n  ParmVarDecl *OldParm;\n  ParmVarDecl *NewParm;\n  QualType PromotedType;\n};\n\n} // end anonymous namespace\n\n// Determine whether the previous declaration was a definition, implicit\n// declaration, or a declaration.\ntemplate <typename T>\nstatic std::pair<diag::kind, SourceLocation>\ngetNoteDiagForInvalidRedeclaration(const T *Old, const T *New) {\n  diag::kind PrevDiag;\n  SourceLocation OldLocation = Old->getLocation();\n  if (Old->isThisDeclarationADefinition())\n    PrevDiag = diag::note_previous_definition;\n  else if (Old->isImplicit()) {\n    PrevDiag = diag::note_previous_implicit_declaration;\n    if (OldLocation.isInvalid())\n      OldLocation = New->getLocation();\n  } else\n    PrevDiag = diag::note_previous_declaration;\n  return std::make_pair(PrevDiag, OldLocation);\n}\n\n/// canRedefineFunction - checks if a function can be redefined. Currently,\n/// only extern inline functions can be redefined, and even then only in\n/// GNU89 mode.\nstatic bool canRedefineFunction(const FunctionDecl *FD,\n                                const LangOptions& LangOpts) {\n  return ((FD->hasAttr<GNUInlineAttr>() || LangOpts.GNUInline) &&\n          !LangOpts.CPlusPlus &&\n          FD->isInlineSpecified() &&\n          FD->getStorageClass() == SC_Extern);\n}\n\nconst AttributedType *Sema::getCallingConvAttributedType(QualType T) const {\n  const AttributedType *AT = T->getAs<AttributedType>();\n  while (AT && !AT->isCallingConv())\n    AT = AT->getModifiedType()->getAs<AttributedType>();\n  return AT;\n}\n\ntemplate <typename T>\nstatic bool haveIncompatibleLanguageLinkages(const T *Old, const T *New) {\n  const DeclContext *DC = Old->getDeclContext();\n  if (DC->isRecord())\n    return false;\n\n  LanguageLinkage OldLinkage = Old->getLanguageLinkage();\n  if (OldLinkage == CXXLanguageLinkage && New->isInExternCContext())\n    return true;\n  if (OldLinkage == CLanguageLinkage && New->isInExternCXXContext())\n    return true;\n  return false;\n}\n\ntemplate<typename T> static bool isExternC(T *D) { return D->isExternC(); }\nstatic bool isExternC(VarTemplateDecl *) { return false; }\n\n/// Check whether a redeclaration of an entity introduced by a\n/// using-declaration is valid, given that we know it's not an overload\n/// (nor a hidden tag declaration).\ntemplate<typename ExpectedDecl>\nstatic bool checkUsingShadowRedecl(Sema &S, UsingShadowDecl *OldS,\n                                   ExpectedDecl *New) {\n  // C++11 [basic.scope.declarative]p4:\n  //   Given a set of declarations in a single declarative region, each of\n  //   which specifies the same unqualified name,\n  //   -- they shall all refer to the same entity, or all refer to functions\n  //      and function templates; or\n  //   -- exactly one declaration shall declare a class name or enumeration\n  //      name that is not a typedef name and the other declarations shall all\n  //      refer to the same variable or enumerator, or all refer to functions\n  //      and function templates; in this case the class name or enumeration\n  //      name is hidden (3.3.10).\n\n  // C++11 [namespace.udecl]p14:\n  //   If a function declaration in namespace scope or block scope has the\n  //   same name and the same parameter-type-list as a function introduced\n  //   by a using-declaration, and the declarations do not declare the same\n  //   function, the program is ill-formed.\n\n  auto *Old = dyn_cast<ExpectedDecl>(OldS->getTargetDecl());\n  if (Old &&\n      !Old->getDeclContext()->getRedeclContext()->Equals(\n          New->getDeclContext()->getRedeclContext()) &&\n      !(isExternC(Old) && isExternC(New)))\n    Old = nullptr;\n\n  if (!Old) {\n    S.Diag(New->getLocation(), diag::err_using_decl_conflict_reverse);\n    S.Diag(OldS->getTargetDecl()->getLocation(), diag::note_using_decl_target);\n    S.Diag(OldS->getUsingDecl()->getLocation(), diag::note_using_decl) << 0;\n    return true;\n  }\n  return false;\n}\n\nstatic bool hasIdenticalPassObjectSizeAttrs(const FunctionDecl *A,\n                                            const FunctionDecl *B) {\n  assert(A->getNumParams() == B->getNumParams());\n\n  auto AttrEq = [](const ParmVarDecl *A, const ParmVarDecl *B) {\n    const auto *AttrA = A->getAttr<PassObjectSizeAttr>();\n    const auto *AttrB = B->getAttr<PassObjectSizeAttr>();\n    if (AttrA == AttrB)\n      return true;\n    return AttrA && AttrB && AttrA->getType() == AttrB->getType() &&\n           AttrA->isDynamic() == AttrB->isDynamic();\n  };\n\n  return std::equal(A->param_begin(), A->param_end(), B->param_begin(), AttrEq);\n}\n\n/// If necessary, adjust the semantic declaration context for a qualified\n/// declaration to name the correct inline namespace within the qualifier.\nstatic void adjustDeclContextForDeclaratorDecl(DeclaratorDecl *NewD,\n                                               DeclaratorDecl *OldD) {\n  // The only case where we need to update the DeclContext is when\n  // redeclaration lookup for a qualified name finds a declaration\n  // in an inline namespace within the context named by the qualifier:\n  //\n  //   inline namespace N { int f(); }\n  //   int ::f(); // Sema DC needs adjusting from :: to N::.\n  //\n  // For unqualified declarations, the semantic context *can* change\n  // along the redeclaration chain (for local extern declarations,\n  // extern \"C\" declarations, and friend declarations in particular).\n  if (!NewD->getQualifier())\n    return;\n\n  // NewD is probably already in the right context.\n  auto *NamedDC = NewD->getDeclContext()->getRedeclContext();\n  auto *SemaDC = OldD->getDeclContext()->getRedeclContext();\n  if (NamedDC->Equals(SemaDC))\n    return;\n\n  assert((NamedDC->InEnclosingNamespaceSetOf(SemaDC) ||\n          NewD->isInvalidDecl() || OldD->isInvalidDecl()) &&\n         \"unexpected context for redeclaration\");\n\n  auto *LexDC = NewD->getLexicalDeclContext();\n  auto FixSemaDC = [=](NamedDecl *D) {\n    if (!D)\n      return;\n    D->setDeclContext(SemaDC);\n    D->setLexicalDeclContext(LexDC);\n  };\n\n  FixSemaDC(NewD);\n  if (auto *FD = dyn_cast<FunctionDecl>(NewD))\n    FixSemaDC(FD->getDescribedFunctionTemplate());\n  else if (auto *VD = dyn_cast<VarDecl>(NewD))\n    FixSemaDC(VD->getDescribedVarTemplate());\n}\n\n/// MergeFunctionDecl - We just parsed a function 'New' from\n/// declarator D which has the same name and scope as a previous\n/// declaration 'Old'.  Figure out how to resolve this situation,\n/// merging decls or emitting diagnostics as appropriate.\n///\n/// In C++, New and Old must be declarations that are not\n/// overloaded. Use IsOverload to determine whether New and Old are\n/// overloaded, and to select the Old declaration that New should be\n/// merged with.\n///\n/// Returns true if there was an error, false otherwise.\nbool Sema::MergeFunctionDecl(FunctionDecl *New, NamedDecl *&OldD,\n                             Scope *S, bool MergeTypeWithOld) {\n  // Verify the old decl was also a function.\n  FunctionDecl *Old = OldD->getAsFunction();\n  if (!Old) {\n    if (UsingShadowDecl *Shadow = dyn_cast<UsingShadowDecl>(OldD)) {\n      if (New->getFriendObjectKind()) {\n        Diag(New->getLocation(), diag::err_using_decl_friend);\n        Diag(Shadow->getTargetDecl()->getLocation(),\n             diag::note_using_decl_target);\n        Diag(Shadow->getUsingDecl()->getLocation(),\n             diag::note_using_decl) << 0;\n        return true;\n      }\n\n      // Check whether the two declarations might declare the same function.\n      if (checkUsingShadowRedecl<FunctionDecl>(*this, Shadow, New))\n        return true;\n      OldD = Old = cast<FunctionDecl>(Shadow->getTargetDecl());\n    } else {\n      Diag(New->getLocation(), diag::err_redefinition_different_kind)\n        << New->getDeclName();\n      notePreviousDefinition(OldD, New->getLocation());\n      return true;\n    }\n  }\n\n  // If the old declaration was found in an inline namespace and the new\n  // declaration was qualified, update the DeclContext to match.\n  adjustDeclContextForDeclaratorDecl(New, Old);\n\n  // If the old declaration is invalid, just give up here.\n  if (Old->isInvalidDecl())\n    return true;\n\n  // Disallow redeclaration of some builtins.\n  if (!getASTContext().canBuiltinBeRedeclared(Old)) {\n    Diag(New->getLocation(), diag::err_builtin_redeclare) << Old->getDeclName();\n    Diag(Old->getLocation(), diag::note_previous_builtin_declaration)\n        << Old << Old->getType();\n    return true;\n  }\n\n  diag::kind PrevDiag;\n  SourceLocation OldLocation;\n  std::tie(PrevDiag, OldLocation) =\n      getNoteDiagForInvalidRedeclaration(Old, New);\n\n  // Don't complain about this if we're in GNU89 mode and the old function\n  // is an extern inline function.\n  // Don't complain about specializations. They are not supposed to have\n  // storage classes.\n  if (!isa<CXXMethodDecl>(New) && !isa<CXXMethodDecl>(Old) &&\n      New->getStorageClass() == SC_Static &&\n      Old->hasExternalFormalLinkage() &&\n      !New->getTemplateSpecializationInfo() &&\n      !canRedefineFunction(Old, getLangOpts())) {\n    if (getLangOpts().MicrosoftExt) {\n      Diag(New->getLocation(), diag::ext_static_non_static) << New;\n      Diag(OldLocation, PrevDiag);\n    } else {\n      Diag(New->getLocation(), diag::err_static_non_static) << New;\n      Diag(OldLocation, PrevDiag);\n      return true;\n    }\n  }\n\n  if (New->hasAttr<InternalLinkageAttr>() &&\n      !Old->hasAttr<InternalLinkageAttr>()) {\n    Diag(New->getLocation(), diag::err_internal_linkage_redeclaration)\n        << New->getDeclName();\n    notePreviousDefinition(Old, New->getLocation());\n    New->dropAttr<InternalLinkageAttr>();\n  }\n\n  if (CheckRedeclarationModuleOwnership(New, Old))\n    return true;\n\n  if (!getLangOpts().CPlusPlus) {\n    bool OldOvl = Old->hasAttr<OverloadableAttr>();\n    if (OldOvl != New->hasAttr<OverloadableAttr>() && !Old->isImplicit()) {\n      Diag(New->getLocation(), diag::err_attribute_overloadable_mismatch)\n        << New << OldOvl;\n\n      // Try our best to find a decl that actually has the overloadable\n      // attribute for the note. In most cases (e.g. programs with only one\n      // broken declaration/definition), this won't matter.\n      //\n      // FIXME: We could do this if we juggled some extra state in\n      // OverloadableAttr, rather than just removing it.\n      const Decl *DiagOld = Old;\n      if (OldOvl) {\n        auto OldIter = llvm::find_if(Old->redecls(), [](const Decl *D) {\n          const auto *A = D->getAttr<OverloadableAttr>();\n          return A && !A->isImplicit();\n        });\n        // If we've implicitly added *all* of the overloadable attrs to this\n        // chain, emitting a \"previous redecl\" note is pointless.\n        DiagOld = OldIter == Old->redecls_end() ? nullptr : *OldIter;\n      }\n\n      if (DiagOld)\n        Diag(DiagOld->getLocation(),\n             diag::note_attribute_overloadable_prev_overload)\n          << OldOvl;\n\n      if (OldOvl)\n        New->addAttr(OverloadableAttr::CreateImplicit(Context));\n      else\n        New->dropAttr<OverloadableAttr>();\n    }\n  }\n\n  // If a function is first declared with a calling convention, but is later\n  // declared or defined without one, all following decls assume the calling\n  // convention of the first.\n  //\n  // It's OK if a function is first declared without a calling convention,\n  // but is later declared or defined with the default calling convention.\n  //\n  // To test if either decl has an explicit calling convention, we look for\n  // AttributedType sugar nodes on the type as written.  If they are missing or\n  // were canonicalized away, we assume the calling convention was implicit.\n  //\n  // Note also that we DO NOT return at this point, because we still have\n  // other tests to run.\n  QualType OldQType = Context.getCanonicalType(Old->getType());\n  QualType NewQType = Context.getCanonicalType(New->getType());\n  const FunctionType *OldType = cast<FunctionType>(OldQType);\n  const FunctionType *NewType = cast<FunctionType>(NewQType);\n  FunctionType::ExtInfo OldTypeInfo = OldType->getExtInfo();\n  FunctionType::ExtInfo NewTypeInfo = NewType->getExtInfo();\n  bool RequiresAdjustment = false;\n\n  if (OldTypeInfo.getCC() != NewTypeInfo.getCC()) {\n    FunctionDecl *First = Old->getFirstDecl();\n    const FunctionType *FT =\n        First->getType().getCanonicalType()->castAs<FunctionType>();\n    FunctionType::ExtInfo FI = FT->getExtInfo();\n    bool NewCCExplicit = getCallingConvAttributedType(New->getType());\n    if (!NewCCExplicit) {\n      // Inherit the CC from the previous declaration if it was specified\n      // there but not here.\n      NewTypeInfo = NewTypeInfo.withCallingConv(OldTypeInfo.getCC());\n      RequiresAdjustment = true;\n    } else if (Old->getBuiltinID()) {\n      // Builtin attribute isn't propagated to the new one yet at this point,\n      // so we check if the old one is a builtin.\n\n      // Calling Conventions on a Builtin aren't really useful and setting a\n      // default calling convention and cdecl'ing some builtin redeclarations is\n      // common, so warn and ignore the calling convention on the redeclaration.\n      Diag(New->getLocation(), diag::warn_cconv_unsupported)\n          << FunctionType::getNameForCallConv(NewTypeInfo.getCC())\n          << (int)CallingConventionIgnoredReason::BuiltinFunction;\n      NewTypeInfo = NewTypeInfo.withCallingConv(OldTypeInfo.getCC());\n      RequiresAdjustment = true;\n    } else {\n      // Calling conventions aren't compatible, so complain.\n      bool FirstCCExplicit = getCallingConvAttributedType(First->getType());\n      Diag(New->getLocation(), diag::err_cconv_change)\n        << FunctionType::getNameForCallConv(NewTypeInfo.getCC())\n        << !FirstCCExplicit\n        << (!FirstCCExplicit ? \"\" :\n            FunctionType::getNameForCallConv(FI.getCC()));\n\n      // Put the note on the first decl, since it is the one that matters.\n      Diag(First->getLocation(), diag::note_previous_declaration);\n      return true;\n    }\n  }\n\n  // FIXME: diagnose the other way around?\n  if (OldTypeInfo.getNoReturn() && !NewTypeInfo.getNoReturn()) {\n    NewTypeInfo = NewTypeInfo.withNoReturn(true);\n    RequiresAdjustment = true;\n  }\n\n  // Merge regparm attribute.\n  if (OldTypeInfo.getHasRegParm() != NewTypeInfo.getHasRegParm() ||\n      OldTypeInfo.getRegParm() != NewTypeInfo.getRegParm()) {\n    if (NewTypeInfo.getHasRegParm()) {\n      Diag(New->getLocation(), diag::err_regparm_mismatch)\n        << NewType->getRegParmType()\n        << OldType->getRegParmType();\n      Diag(OldLocation, diag::note_previous_declaration);\n      return true;\n    }\n\n    NewTypeInfo = NewTypeInfo.withRegParm(OldTypeInfo.getRegParm());\n    RequiresAdjustment = true;\n  }\n\n  // Merge ns_returns_retained attribute.\n  if (OldTypeInfo.getProducesResult() != NewTypeInfo.getProducesResult()) {\n    if (NewTypeInfo.getProducesResult()) {\n      Diag(New->getLocation(), diag::err_function_attribute_mismatch)\n          << \"'ns_returns_retained'\";\n      Diag(OldLocation, diag::note_previous_declaration);\n      return true;\n    }\n\n    NewTypeInfo = NewTypeInfo.withProducesResult(true);\n    RequiresAdjustment = true;\n  }\n\n  if (OldTypeInfo.getNoCallerSavedRegs() !=\n      NewTypeInfo.getNoCallerSavedRegs()) {\n    if (NewTypeInfo.getNoCallerSavedRegs()) {\n      AnyX86NoCallerSavedRegistersAttr *Attr =\n        New->getAttr<AnyX86NoCallerSavedRegistersAttr>();\n      Diag(New->getLocation(), diag::err_function_attribute_mismatch) << Attr;\n      Diag(OldLocation, diag::note_previous_declaration);\n      return true;\n    }\n\n    NewTypeInfo = NewTypeInfo.withNoCallerSavedRegs(true);\n    RequiresAdjustment = true;\n  }\n\n  if (RequiresAdjustment) {\n    const FunctionType *AdjustedType = New->getType()->getAs<FunctionType>();\n    AdjustedType = Context.adjustFunctionType(AdjustedType, NewTypeInfo);\n    New->setType(QualType(AdjustedType, 0));\n    NewQType = Context.getCanonicalType(New->getType());\n  }\n\n  // If this redeclaration makes the function inline, we may need to add it to\n  // UndefinedButUsed.\n  if (!Old->isInlined() && New->isInlined() &&\n      !New->hasAttr<GNUInlineAttr>() &&\n      !getLangOpts().GNUInline &&\n      Old->isUsed(false) &&\n      !Old->isDefined() && !New->isThisDeclarationADefinition())\n    UndefinedButUsed.insert(std::make_pair(Old->getCanonicalDecl(),\n                                           SourceLocation()));\n\n  // If this redeclaration makes it newly gnu_inline, we don't want to warn\n  // about it.\n  if (New->hasAttr<GNUInlineAttr>() &&\n      Old->isInlined() && !Old->hasAttr<GNUInlineAttr>()) {\n    UndefinedButUsed.erase(Old->getCanonicalDecl());\n  }\n\n  // If pass_object_size params don't match up perfectly, this isn't a valid\n  // redeclaration.\n  if (Old->getNumParams() > 0 && Old->getNumParams() == New->getNumParams() &&\n      !hasIdenticalPassObjectSizeAttrs(Old, New)) {\n    Diag(New->getLocation(), diag::err_different_pass_object_size_params)\n        << New->getDeclName();\n    Diag(OldLocation, PrevDiag) << Old << Old->getType();\n    return true;\n  }\n\n  if (getLangOpts().CPlusPlus) {\n    // C++1z [over.load]p2\n    //   Certain function declarations cannot be overloaded:\n    //     -- Function declarations that differ only in the return type,\n    //        the exception specification, or both cannot be overloaded.\n\n    // Check the exception specifications match. This may recompute the type of\n    // both Old and New if it resolved exception specifications, so grab the\n    // types again after this. Because this updates the type, we do this before\n    // any of the other checks below, which may update the \"de facto\" NewQType\n    // but do not necessarily update the type of New.\n    if (CheckEquivalentExceptionSpec(Old, New))\n      return true;\n    OldQType = Context.getCanonicalType(Old->getType());\n    NewQType = Context.getCanonicalType(New->getType());\n\n    // Go back to the type source info to compare the declared return types,\n    // per C++1y [dcl.type.auto]p13:\n    //   Redeclarations or specializations of a function or function template\n    //   with a declared return type that uses a placeholder type shall also\n    //   use that placeholder, not a deduced type.\n    QualType OldDeclaredReturnType = Old->getDeclaredReturnType();\n    QualType NewDeclaredReturnType = New->getDeclaredReturnType();\n    if (!Context.hasSameType(OldDeclaredReturnType, NewDeclaredReturnType) &&\n        canFullyTypeCheckRedeclaration(New, Old, NewDeclaredReturnType,\n                                       OldDeclaredReturnType)) {\n      QualType ResQT;\n      if (NewDeclaredReturnType->isObjCObjectPointerType() &&\n          OldDeclaredReturnType->isObjCObjectPointerType())\n        // FIXME: This does the wrong thing for a deduced return type.\n        ResQT = Context.mergeObjCGCQualifiers(NewQType, OldQType);\n      if (ResQT.isNull()) {\n        if (New->isCXXClassMember() && New->isOutOfLine())\n          Diag(New->getLocation(), diag::err_member_def_does_not_match_ret_type)\n              << New << New->getReturnTypeSourceRange();\n        else\n          Diag(New->getLocation(), diag::err_ovl_diff_return_type)\n              << New->getReturnTypeSourceRange();\n        Diag(OldLocation, PrevDiag) << Old << Old->getType()\n                                    << Old->getReturnTypeSourceRange();\n        return true;\n      }\n      else\n        NewQType = ResQT;\n    }\n\n    QualType OldReturnType = OldType->getReturnType();\n    QualType NewReturnType = cast<FunctionType>(NewQType)->getReturnType();\n    if (OldReturnType != NewReturnType) {\n      // If this function has a deduced return type and has already been\n      // defined, copy the deduced value from the old declaration.\n      AutoType *OldAT = Old->getReturnType()->getContainedAutoType();\n      if (OldAT && OldAT->isDeduced()) {\n        New->setType(\n            SubstAutoType(New->getType(),\n                          OldAT->isDependentType() ? Context.DependentTy\n                                                   : OldAT->getDeducedType()));\n        NewQType = Context.getCanonicalType(\n            SubstAutoType(NewQType,\n                          OldAT->isDependentType() ? Context.DependentTy\n                                                   : OldAT->getDeducedType()));\n      }\n    }\n\n    const CXXMethodDecl *OldMethod = dyn_cast<CXXMethodDecl>(Old);\n    CXXMethodDecl *NewMethod = dyn_cast<CXXMethodDecl>(New);\n    if (OldMethod && NewMethod) {\n      // Preserve triviality.\n      NewMethod->setTrivial(OldMethod->isTrivial());\n\n      // MSVC allows explicit template specialization at class scope:\n      // 2 CXXMethodDecls referring to the same function will be injected.\n      // We don't want a redeclaration error.\n      bool IsClassScopeExplicitSpecialization =\n                              OldMethod->isFunctionTemplateSpecialization() &&\n                              NewMethod->isFunctionTemplateSpecialization();\n      bool isFriend = NewMethod->getFriendObjectKind();\n\n      if (!isFriend && NewMethod->getLexicalDeclContext()->isRecord() &&\n          !IsClassScopeExplicitSpecialization) {\n        //    -- Member function declarations with the same name and the\n        //       same parameter types cannot be overloaded if any of them\n        //       is a static member function declaration.\n        if (OldMethod->isStatic() != NewMethod->isStatic()) {\n          Diag(New->getLocation(), diag::err_ovl_static_nonstatic_member);\n          Diag(OldLocation, PrevDiag) << Old << Old->getType();\n          return true;\n        }\n\n        // C++ [class.mem]p1:\n        //   [...] A member shall not be declared twice in the\n        //   member-specification, except that a nested class or member\n        //   class template can be declared and then later defined.\n        if (!inTemplateInstantiation()) {\n          unsigned NewDiag;\n          if (isa<CXXConstructorDecl>(OldMethod))\n            NewDiag = diag::err_constructor_redeclared;\n          else if (isa<CXXDestructorDecl>(NewMethod))\n            NewDiag = diag::err_destructor_redeclared;\n          else if (isa<CXXConversionDecl>(NewMethod))\n            NewDiag = diag::err_conv_function_redeclared;\n          else\n            NewDiag = diag::err_member_redeclared;\n\n          Diag(New->getLocation(), NewDiag);\n        } else {\n          Diag(New->getLocation(), diag::err_member_redeclared_in_instantiation)\n            << New << New->getType();\n        }\n        Diag(OldLocation, PrevDiag) << Old << Old->getType();\n        return true;\n\n      // Complain if this is an explicit declaration of a special\n      // member that was initially declared implicitly.\n      //\n      // As an exception, it's okay to befriend such methods in order\n      // to permit the implicit constructor/destructor/operator calls.\n      } else if (OldMethod->isImplicit()) {\n        if (isFriend) {\n          NewMethod->setImplicit();\n        } else {\n          Diag(NewMethod->getLocation(),\n               diag::err_definition_of_implicitly_declared_member)\n            << New << getSpecialMember(OldMethod);\n          return true;\n        }\n      } else if (OldMethod->getFirstDecl()->isExplicitlyDefaulted() && !isFriend) {\n        Diag(NewMethod->getLocation(),\n             diag::err_definition_of_explicitly_defaulted_member)\n          << getSpecialMember(OldMethod);\n        return true;\n      }\n    }\n\n    // C++11 [dcl.attr.noreturn]p1:\n    //   The first declaration of a function shall specify the noreturn\n    //   attribute if any declaration of that function specifies the noreturn\n    //   attribute.\n    const CXX11NoReturnAttr *NRA = New->getAttr<CXX11NoReturnAttr>();\n    if (NRA && !Old->hasAttr<CXX11NoReturnAttr>()) {\n      Diag(NRA->getLocation(), diag::err_noreturn_missing_on_first_decl);\n      Diag(Old->getFirstDecl()->getLocation(),\n           diag::note_noreturn_missing_first_decl);\n    }\n\n    // C++11 [dcl.attr.depend]p2:\n    //   The first declaration of a function shall specify the\n    //   carries_dependency attribute for its declarator-id if any declaration\n    //   of the function specifies the carries_dependency attribute.\n    const CarriesDependencyAttr *CDA = New->getAttr<CarriesDependencyAttr>();\n    if (CDA && !Old->hasAttr<CarriesDependencyAttr>()) {\n      Diag(CDA->getLocation(),\n           diag::err_carries_dependency_missing_on_first_decl) << 0/*Function*/;\n      Diag(Old->getFirstDecl()->getLocation(),\n           diag::note_carries_dependency_missing_first_decl) << 0/*Function*/;\n    }\n\n    // (C++98 8.3.5p3):\n    //   All declarations for a function shall agree exactly in both the\n    //   return type and the parameter-type-list.\n    // We also want to respect all the extended bits except noreturn.\n\n    // noreturn should now match unless the old type info didn't have it.\n    QualType OldQTypeForComparison = OldQType;\n    if (!OldTypeInfo.getNoReturn() && NewTypeInfo.getNoReturn()) {\n      auto *OldType = OldQType->castAs<FunctionProtoType>();\n      const FunctionType *OldTypeForComparison\n        = Context.adjustFunctionType(OldType, OldTypeInfo.withNoReturn(true));\n      OldQTypeForComparison = QualType(OldTypeForComparison, 0);\n      assert(OldQTypeForComparison.isCanonical());\n    }\n\n    if (haveIncompatibleLanguageLinkages(Old, New)) {\n      // As a special case, retain the language linkage from previous\n      // declarations of a friend function as an extension.\n      //\n      // This liberal interpretation of C++ [class.friend]p3 matches GCC/MSVC\n      // and is useful because there's otherwise no way to specify language\n      // linkage within class scope.\n      //\n      // Check cautiously as the friend object kind isn't yet complete.\n      if (New->getFriendObjectKind() != Decl::FOK_None) {\n        Diag(New->getLocation(), diag::ext_retained_language_linkage) << New;\n        Diag(OldLocation, PrevDiag);\n      } else {\n        Diag(New->getLocation(), diag::err_different_language_linkage) << New;\n        Diag(OldLocation, PrevDiag);\n        return true;\n      }\n    }\n\n    // If the function types are compatible, merge the declarations. Ignore the\n    // exception specifier because it was already checked above in\n    // CheckEquivalentExceptionSpec, and we don't want follow-on diagnostics\n    // about incompatible types under -fms-compatibility.\n    if (Context.hasSameFunctionTypeIgnoringExceptionSpec(OldQTypeForComparison,\n                                                         NewQType))\n      return MergeCompatibleFunctionDecls(New, Old, S, MergeTypeWithOld);\n\n    // If the types are imprecise (due to dependent constructs in friends or\n    // local extern declarations), it's OK if they differ. We'll check again\n    // during instantiation.\n    if (!canFullyTypeCheckRedeclaration(New, Old, NewQType, OldQType))\n      return false;\n\n    // Fall through for conflicting redeclarations and redefinitions.\n  }\n\n  // C: Function types need to be compatible, not identical. This handles\n  // duplicate function decls like \"void f(int); void f(enum X);\" properly.\n  if (!getLangOpts().CPlusPlus &&\n      Context.typesAreCompatible(OldQType, NewQType)) {\n    const FunctionType *OldFuncType = OldQType->getAs<FunctionType>();\n    const FunctionType *NewFuncType = NewQType->getAs<FunctionType>();\n    const FunctionProtoType *OldProto = nullptr;\n    if (MergeTypeWithOld && isa<FunctionNoProtoType>(NewFuncType) &&\n        (OldProto = dyn_cast<FunctionProtoType>(OldFuncType))) {\n      // The old declaration provided a function prototype, but the\n      // new declaration does not. Merge in the prototype.\n      assert(!OldProto->hasExceptionSpec() && \"Exception spec in C\");\n      SmallVector<QualType, 16> ParamTypes(OldProto->param_types());\n      NewQType =\n          Context.getFunctionType(NewFuncType->getReturnType(), ParamTypes,\n                                  OldProto->getExtProtoInfo());\n      New->setType(NewQType);\n      New->setHasInheritedPrototype();\n\n      // Synthesize parameters with the same types.\n      SmallVector<ParmVarDecl*, 16> Params;\n      for (const auto &ParamType : OldProto->param_types()) {\n        ParmVarDecl *Param = ParmVarDecl::Create(Context, New, SourceLocation(),\n                                                 SourceLocation(), nullptr,\n                                                 ParamType, /*TInfo=*/nullptr,\n                                                 SC_None, nullptr);\n        Param->setScopeInfo(0, Params.size());\n        Param->setImplicit();\n        Params.push_back(Param);\n      }\n\n      New->setParams(Params);\n    }\n\n    return MergeCompatibleFunctionDecls(New, Old, S, MergeTypeWithOld);\n  }\n\n  // Check if the function types are compatible when pointer size address\n  // spaces are ignored.\n  if (Context.hasSameFunctionTypeIgnoringPtrSizes(OldQType, NewQType))\n    return false;\n\n  // GNU C permits a K&R definition to follow a prototype declaration\n  // if the declared types of the parameters in the K&R definition\n  // match the types in the prototype declaration, even when the\n  // promoted types of the parameters from the K&R definition differ\n  // from the types in the prototype. GCC then keeps the types from\n  // the prototype.\n  //\n  // If a variadic prototype is followed by a non-variadic K&R definition,\n  // the K&R definition becomes variadic.  This is sort of an edge case, but\n  // it's legal per the standard depending on how you read C99 6.7.5.3p15 and\n  // C99 6.9.1p8.\n  if (!getLangOpts().CPlusPlus &&\n      Old->hasPrototype() && !New->hasPrototype() &&\n      New->getType()->getAs<FunctionProtoType>() &&\n      Old->getNumParams() == New->getNumParams()) {\n    SmallVector<QualType, 16> ArgTypes;\n    SmallVector<GNUCompatibleParamWarning, 16> Warnings;\n    const FunctionProtoType *OldProto\n      = Old->getType()->getAs<FunctionProtoType>();\n    const FunctionProtoType *NewProto\n      = New->getType()->getAs<FunctionProtoType>();\n\n    // Determine whether this is the GNU C extension.\n    QualType MergedReturn = Context.mergeTypes(OldProto->getReturnType(),\n                                               NewProto->getReturnType());\n    bool LooseCompatible = !MergedReturn.isNull();\n    for (unsigned Idx = 0, End = Old->getNumParams();\n         LooseCompatible && Idx != End; ++Idx) {\n      ParmVarDecl *OldParm = Old->getParamDecl(Idx);\n      ParmVarDecl *NewParm = New->getParamDecl(Idx);\n      if (Context.typesAreCompatible(OldParm->getType(),\n                                     NewProto->getParamType(Idx))) {\n        ArgTypes.push_back(NewParm->getType());\n      } else if (Context.typesAreCompatible(OldParm->getType(),\n                                            NewParm->getType(),\n                                            /*CompareUnqualified=*/true)) {\n        GNUCompatibleParamWarning Warn = { OldParm, NewParm,\n                                           NewProto->getParamType(Idx) };\n        Warnings.push_back(Warn);\n        ArgTypes.push_back(NewParm->getType());\n      } else\n        LooseCompatible = false;\n    }\n\n    if (LooseCompatible) {\n      for (unsigned Warn = 0; Warn < Warnings.size(); ++Warn) {\n        Diag(Warnings[Warn].NewParm->getLocation(),\n             diag::ext_param_promoted_not_compatible_with_prototype)\n          << Warnings[Warn].PromotedType\n          << Warnings[Warn].OldParm->getType();\n        if (Warnings[Warn].OldParm->getLocation().isValid())\n          Diag(Warnings[Warn].OldParm->getLocation(),\n               diag::note_previous_declaration);\n      }\n\n      if (MergeTypeWithOld)\n        New->setType(Context.getFunctionType(MergedReturn, ArgTypes,\n                                             OldProto->getExtProtoInfo()));\n      return MergeCompatibleFunctionDecls(New, Old, S, MergeTypeWithOld);\n    }\n\n    // Fall through to diagnose conflicting types.\n  }\n\n  // A function that has already been declared has been redeclared or\n  // defined with a different type; show an appropriate diagnostic.\n\n  // If the previous declaration was an implicitly-generated builtin\n  // declaration, then at the very least we should use a specialized note.\n  unsigned BuiltinID;\n  if (Old->isImplicit() && (BuiltinID = Old->getBuiltinID())) {\n    // If it's actually a library-defined builtin function like 'malloc'\n    // or 'printf', just warn about the incompatible redeclaration.\n    if (Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID)) {\n      Diag(New->getLocation(), diag::warn_redecl_library_builtin) << New;\n      Diag(OldLocation, diag::note_previous_builtin_declaration)\n        << Old << Old->getType();\n      return false;\n    }\n\n    PrevDiag = diag::note_previous_builtin_declaration;\n  }\n\n  Diag(New->getLocation(), diag::err_conflicting_types) << New->getDeclName();\n  Diag(OldLocation, PrevDiag) << Old << Old->getType();\n  return true;\n}\n\n/// Completes the merge of two function declarations that are\n/// known to be compatible.\n///\n/// This routine handles the merging of attributes and other\n/// properties of function declarations from the old declaration to\n/// the new declaration, once we know that New is in fact a\n/// redeclaration of Old.\n///\n/// \\returns false\nbool Sema::MergeCompatibleFunctionDecls(FunctionDecl *New, FunctionDecl *Old,\n                                        Scope *S, bool MergeTypeWithOld) {\n  // Merge the attributes\n  mergeDeclAttributes(New, Old);\n\n  // Merge \"pure\" flag.\n  if (Old->isPure())\n    New->setPure();\n\n  // Merge \"used\" flag.\n  if (Old->getMostRecentDecl()->isUsed(false))\n    New->setIsUsed();\n\n  // Merge attributes from the parameters.  These can mismatch with K&R\n  // declarations.\n  if (New->getNumParams() == Old->getNumParams())\n      for (unsigned i = 0, e = New->getNumParams(); i != e; ++i) {\n        ParmVarDecl *NewParam = New->getParamDecl(i);\n        ParmVarDecl *OldParam = Old->getParamDecl(i);\n        mergeParamDeclAttributes(NewParam, OldParam, *this);\n        mergeParamDeclTypes(NewParam, OldParam, *this);\n      }\n\n  if (getLangOpts().CPlusPlus)\n    return MergeCXXFunctionDecl(New, Old, S);\n\n  // Merge the function types so the we get the composite types for the return\n  // and argument types. Per C11 6.2.7/4, only update the type if the old decl\n  // was visible.\n  QualType Merged = Context.mergeTypes(Old->getType(), New->getType());\n  if (!Merged.isNull() && MergeTypeWithOld)\n    New->setType(Merged);\n\n  return false;\n}\n\nvoid Sema::mergeObjCMethodDecls(ObjCMethodDecl *newMethod,\n                                ObjCMethodDecl *oldMethod) {\n  // Merge the attributes, including deprecated/unavailable\n  AvailabilityMergeKind MergeKind =\n    isa<ObjCProtocolDecl>(oldMethod->getDeclContext())\n      ? AMK_ProtocolImplementation\n      : isa<ObjCImplDecl>(newMethod->getDeclContext()) ? AMK_Redeclaration\n                                                       : AMK_Override;\n\n  mergeDeclAttributes(newMethod, oldMethod, MergeKind);\n\n  // Merge attributes from the parameters.\n  ObjCMethodDecl::param_const_iterator oi = oldMethod->param_begin(),\n                                       oe = oldMethod->param_end();\n  for (ObjCMethodDecl::param_iterator\n         ni = newMethod->param_begin(), ne = newMethod->param_end();\n       ni != ne && oi != oe; ++ni, ++oi)\n    mergeParamDeclAttributes(*ni, *oi, *this);\n\n  CheckObjCMethodOverride(newMethod, oldMethod);\n}\n\nstatic void diagnoseVarDeclTypeMismatch(Sema &S, VarDecl *New, VarDecl* Old) {\n  assert(!S.Context.hasSameType(New->getType(), Old->getType()));\n\n  S.Diag(New->getLocation(), New->isThisDeclarationADefinition()\n         ? diag::err_redefinition_different_type\n         : diag::err_redeclaration_different_type)\n    << New->getDeclName() << New->getType() << Old->getType();\n\n  diag::kind PrevDiag;\n  SourceLocation OldLocation;\n  std::tie(PrevDiag, OldLocation)\n    = getNoteDiagForInvalidRedeclaration(Old, New);\n  S.Diag(OldLocation, PrevDiag);\n  New->setInvalidDecl();\n}\n\n/// MergeVarDeclTypes - We parsed a variable 'New' which has the same name and\n/// scope as a previous declaration 'Old'.  Figure out how to merge their types,\n/// emitting diagnostics as appropriate.\n///\n/// Declarations using the auto type specifier (C++ [decl.spec.auto]) call back\n/// to here in AddInitializerToDecl. We can't check them before the initializer\n/// is attached.\nvoid Sema::MergeVarDeclTypes(VarDecl *New, VarDecl *Old,\n                             bool MergeTypeWithOld) {\n  if (New->isInvalidDecl() || Old->isInvalidDecl())\n    return;\n\n  QualType MergedT;\n  if (getLangOpts().CPlusPlus) {\n    if (New->getType()->isUndeducedType()) {\n      // We don't know what the new type is until the initializer is attached.\n      return;\n    } else if (Context.hasSameType(New->getType(), Old->getType())) {\n      // These could still be something that needs exception specs checked.\n      return MergeVarDeclExceptionSpecs(New, Old);\n    }\n    // C++ [basic.link]p10:\n    //   [...] the types specified by all declarations referring to a given\n    //   object or function shall be identical, except that declarations for an\n    //   array object can specify array types that differ by the presence or\n    //   absence of a major array bound (8.3.4).\n    else if (Old->getType()->isArrayType() && New->getType()->isArrayType()) {\n      const ArrayType *OldArray = Context.getAsArrayType(Old->getType());\n      const ArrayType *NewArray = Context.getAsArrayType(New->getType());\n\n      // We are merging a variable declaration New into Old. If it has an array\n      // bound, and that bound differs from Old's bound, we should diagnose the\n      // mismatch.\n      if (!NewArray->isIncompleteArrayType() && !NewArray->isDependentType()) {\n        for (VarDecl *PrevVD = Old->getMostRecentDecl(); PrevVD;\n             PrevVD = PrevVD->getPreviousDecl()) {\n          QualType PrevVDTy = PrevVD->getType();\n          if (PrevVDTy->isIncompleteArrayType() || PrevVDTy->isDependentType())\n            continue;\n\n          if (!Context.hasSameType(New->getType(), PrevVDTy))\n            return diagnoseVarDeclTypeMismatch(*this, New, PrevVD);\n        }\n      }\n\n      if (OldArray->isIncompleteArrayType() && NewArray->isArrayType()) {\n        if (Context.hasSameType(OldArray->getElementType(),\n                                NewArray->getElementType()))\n          MergedT = New->getType();\n      }\n      // FIXME: Check visibility. New is hidden but has a complete type. If New\n      // has no array bound, it should not inherit one from Old, if Old is not\n      // visible.\n      else if (OldArray->isArrayType() && NewArray->isIncompleteArrayType()) {\n        if (Context.hasSameType(OldArray->getElementType(),\n                                NewArray->getElementType()))\n          MergedT = Old->getType();\n      }\n    }\n    else if (New->getType()->isObjCObjectPointerType() &&\n               Old->getType()->isObjCObjectPointerType()) {\n      MergedT = Context.mergeObjCGCQualifiers(New->getType(),\n                                              Old->getType());\n    }\n  } else {\n    // C 6.2.7p2:\n    //   All declarations that refer to the same object or function shall have\n    //   compatible type.\n    MergedT = Context.mergeTypes(New->getType(), Old->getType());\n  }\n  if (MergedT.isNull()) {\n    // It's OK if we couldn't merge types if either type is dependent, for a\n    // block-scope variable. In other cases (static data members of class\n    // templates, variable templates, ...), we require the types to be\n    // equivalent.\n    // FIXME: The C++ standard doesn't say anything about this.\n    if ((New->getType()->isDependentType() ||\n         Old->getType()->isDependentType()) && New->isLocalVarDecl()) {\n      // If the old type was dependent, we can't merge with it, so the new type\n      // becomes dependent for now. We'll reproduce the original type when we\n      // instantiate the TypeSourceInfo for the variable.\n      if (!New->getType()->isDependentType() && MergeTypeWithOld)\n        New->setType(Context.DependentTy);\n      return;\n    }\n    return diagnoseVarDeclTypeMismatch(*this, New, Old);\n  }\n\n  // Don't actually update the type on the new declaration if the old\n  // declaration was an extern declaration in a different scope.\n  if (MergeTypeWithOld)\n    New->setType(MergedT);\n}\n\nstatic bool mergeTypeWithPrevious(Sema &S, VarDecl *NewVD, VarDecl *OldVD,\n                                  LookupResult &Previous) {\n  // C11 6.2.7p4:\n  //   For an identifier with internal or external linkage declared\n  //   in a scope in which a prior declaration of that identifier is\n  //   visible, if the prior declaration specifies internal or\n  //   external linkage, the type of the identifier at the later\n  //   declaration becomes the composite type.\n  //\n  // If the variable isn't visible, we do not merge with its type.\n  if (Previous.isShadowed())\n    return false;\n\n  if (S.getLangOpts().CPlusPlus) {\n    // C++11 [dcl.array]p3:\n    //   If there is a preceding declaration of the entity in the same\n    //   scope in which the bound was specified, an omitted array bound\n    //   is taken to be the same as in that earlier declaration.\n    return NewVD->isPreviousDeclInSameBlockScope() ||\n           (!OldVD->getLexicalDeclContext()->isFunctionOrMethod() &&\n            !NewVD->getLexicalDeclContext()->isFunctionOrMethod());\n  } else {\n    // If the old declaration was function-local, don't merge with its\n    // type unless we're in the same function.\n    return !OldVD->getLexicalDeclContext()->isFunctionOrMethod() ||\n           OldVD->getLexicalDeclContext() == NewVD->getLexicalDeclContext();\n  }\n}\n\n/// MergeVarDecl - We just parsed a variable 'New' which has the same name\n/// and scope as a previous declaration 'Old'.  Figure out how to resolve this\n/// situation, merging decls or emitting diagnostics as appropriate.\n///\n/// Tentative definition rules (C99 6.9.2p2) are checked by\n/// FinalizeDeclaratorGroup. Unfortunately, we can't analyze tentative\n/// definitions here, since the initializer hasn't been attached.\n///\nvoid Sema::MergeVarDecl(VarDecl *New, LookupResult &Previous) {\n  // If the new decl is already invalid, don't do any other checking.\n  if (New->isInvalidDecl())\n    return;\n\n  if (!shouldLinkPossiblyHiddenDecl(Previous, New))\n    return;\n\n  VarTemplateDecl *NewTemplate = New->getDescribedVarTemplate();\n\n  // Verify the old decl was also a variable or variable template.\n  VarDecl *Old = nullptr;\n  VarTemplateDecl *OldTemplate = nullptr;\n  if (Previous.isSingleResult()) {\n    if (NewTemplate) {\n      OldTemplate = dyn_cast<VarTemplateDecl>(Previous.getFoundDecl());\n      Old = OldTemplate ? OldTemplate->getTemplatedDecl() : nullptr;\n\n      if (auto *Shadow =\n              dyn_cast<UsingShadowDecl>(Previous.getRepresentativeDecl()))\n        if (checkUsingShadowRedecl<VarTemplateDecl>(*this, Shadow, NewTemplate))\n          return New->setInvalidDecl();\n    } else {\n      Old = dyn_cast<VarDecl>(Previous.getFoundDecl());\n\n      if (auto *Shadow =\n              dyn_cast<UsingShadowDecl>(Previous.getRepresentativeDecl()))\n        if (checkUsingShadowRedecl<VarDecl>(*this, Shadow, New))\n          return New->setInvalidDecl();\n    }\n  }\n  if (!Old) {\n    Diag(New->getLocation(), diag::err_redefinition_different_kind)\n        << New->getDeclName();\n    notePreviousDefinition(Previous.getRepresentativeDecl(),\n                           New->getLocation());\n    return New->setInvalidDecl();\n  }\n\n  // If the old declaration was found in an inline namespace and the new\n  // declaration was qualified, update the DeclContext to match.\n  adjustDeclContextForDeclaratorDecl(New, Old);\n\n  // Ensure the template parameters are compatible.\n  if (NewTemplate &&\n      !TemplateParameterListsAreEqual(NewTemplate->getTemplateParameters(),\n                                      OldTemplate->getTemplateParameters(),\n                                      /*Complain=*/true, TPL_TemplateMatch))\n    return New->setInvalidDecl();\n\n  // C++ [class.mem]p1:\n  //   A member shall not be declared twice in the member-specification [...]\n  //\n  // Here, we need only consider static data members.\n  if (Old->isStaticDataMember() && !New->isOutOfLine()) {\n    Diag(New->getLocation(), diag::err_duplicate_member)\n      << New->getIdentifier();\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n    New->setInvalidDecl();\n  }\n\n  mergeDeclAttributes(New, Old);\n  // Warn if an already-declared variable is made a weak_import in a subsequent\n  // declaration\n  if (New->hasAttr<WeakImportAttr>() &&\n      Old->getStorageClass() == SC_None &&\n      !Old->hasAttr<WeakImportAttr>()) {\n    Diag(New->getLocation(), diag::warn_weak_import) << New->getDeclName();\n    notePreviousDefinition(Old, New->getLocation());\n    // Remove weak_import attribute on new declaration.\n    New->dropAttr<WeakImportAttr>();\n  }\n\n  if (New->hasAttr<InternalLinkageAttr>() &&\n      !Old->hasAttr<InternalLinkageAttr>()) {\n    Diag(New->getLocation(), diag::err_internal_linkage_redeclaration)\n        << New->getDeclName();\n    notePreviousDefinition(Old, New->getLocation());\n    New->dropAttr<InternalLinkageAttr>();\n  }\n\n  // Merge the types.\n  VarDecl *MostRecent = Old->getMostRecentDecl();\n  if (MostRecent != Old) {\n    MergeVarDeclTypes(New, MostRecent,\n                      mergeTypeWithPrevious(*this, New, MostRecent, Previous));\n    if (New->isInvalidDecl())\n      return;\n  }\n\n  MergeVarDeclTypes(New, Old, mergeTypeWithPrevious(*this, New, Old, Previous));\n  if (New->isInvalidDecl())\n    return;\n\n  diag::kind PrevDiag;\n  SourceLocation OldLocation;\n  std::tie(PrevDiag, OldLocation) =\n      getNoteDiagForInvalidRedeclaration(Old, New);\n\n  // [dcl.stc]p8: Check if we have a non-static decl followed by a static.\n  if (New->getStorageClass() == SC_Static &&\n      !New->isStaticDataMember() &&\n      Old->hasExternalFormalLinkage()) {\n    if (getLangOpts().MicrosoftExt) {\n      Diag(New->getLocation(), diag::ext_static_non_static)\n          << New->getDeclName();\n      Diag(OldLocation, PrevDiag);\n    } else {\n      Diag(New->getLocation(), diag::err_static_non_static)\n          << New->getDeclName();\n      Diag(OldLocation, PrevDiag);\n      return New->setInvalidDecl();\n    }\n  }\n  // C99 6.2.2p4:\n  //   For an identifier declared with the storage-class specifier\n  //   extern in a scope in which a prior declaration of that\n  //   identifier is visible,23) if the prior declaration specifies\n  //   internal or external linkage, the linkage of the identifier at\n  //   the later declaration is the same as the linkage specified at\n  //   the prior declaration. If no prior declaration is visible, or\n  //   if the prior declaration specifies no linkage, then the\n  //   identifier has external linkage.\n  if (New->hasExternalStorage() && Old->hasLinkage())\n    /* Okay */;\n  else if (New->getCanonicalDecl()->getStorageClass() != SC_Static &&\n           !New->isStaticDataMember() &&\n           Old->getCanonicalDecl()->getStorageClass() == SC_Static) {\n    Diag(New->getLocation(), diag::err_non_static_static) << New->getDeclName();\n    Diag(OldLocation, PrevDiag);\n    return New->setInvalidDecl();\n  }\n\n  // Check if extern is followed by non-extern and vice-versa.\n  if (New->hasExternalStorage() &&\n      !Old->hasLinkage() && Old->isLocalVarDeclOrParm()) {\n    Diag(New->getLocation(), diag::err_extern_non_extern) << New->getDeclName();\n    Diag(OldLocation, PrevDiag);\n    return New->setInvalidDecl();\n  }\n  if (Old->hasLinkage() && New->isLocalVarDeclOrParm() &&\n      !New->hasExternalStorage()) {\n    Diag(New->getLocation(), diag::err_non_extern_extern) << New->getDeclName();\n    Diag(OldLocation, PrevDiag);\n    return New->setInvalidDecl();\n  }\n\n  if (CheckRedeclarationModuleOwnership(New, Old))\n    return;\n\n  // Variables with external linkage are analyzed in FinalizeDeclaratorGroup.\n\n  // FIXME: The test for external storage here seems wrong? We still\n  // need to check for mismatches.\n  if (!New->hasExternalStorage() && !New->isFileVarDecl() &&\n      // Don't complain about out-of-line definitions of static members.\n      !(Old->getLexicalDeclContext()->isRecord() &&\n        !New->getLexicalDeclContext()->isRecord())) {\n    Diag(New->getLocation(), diag::err_redefinition) << New->getDeclName();\n    Diag(OldLocation, PrevDiag);\n    return New->setInvalidDecl();\n  }\n\n  if (New->isInline() && !Old->getMostRecentDecl()->isInline()) {\n    if (VarDecl *Def = Old->getDefinition()) {\n      // C++1z [dcl.fcn.spec]p4:\n      //   If the definition of a variable appears in a translation unit before\n      //   its first declaration as inline, the program is ill-formed.\n      Diag(New->getLocation(), diag::err_inline_decl_follows_def) << New;\n      Diag(Def->getLocation(), diag::note_previous_definition);\n    }\n  }\n\n  // If this redeclaration makes the variable inline, we may need to add it to\n  // UndefinedButUsed.\n  if (!Old->isInline() && New->isInline() && Old->isUsed(false) &&\n      !Old->getDefinition() && !New->isThisDeclarationADefinition())\n    UndefinedButUsed.insert(std::make_pair(Old->getCanonicalDecl(),\n                                           SourceLocation()));\n\n  if (New->getTLSKind() != Old->getTLSKind()) {\n    if (!Old->getTLSKind()) {\n      Diag(New->getLocation(), diag::err_thread_non_thread) << New->getDeclName();\n      Diag(OldLocation, PrevDiag);\n    } else if (!New->getTLSKind()) {\n      Diag(New->getLocation(), diag::err_non_thread_thread) << New->getDeclName();\n      Diag(OldLocation, PrevDiag);\n    } else {\n      // Do not allow redeclaration to change the variable between requiring\n      // static and dynamic initialization.\n      // FIXME: GCC allows this, but uses the TLS keyword on the first\n      // declaration to determine the kind. Do we need to be compatible here?\n      Diag(New->getLocation(), diag::err_thread_thread_different_kind)\n        << New->getDeclName() << (New->getTLSKind() == VarDecl::TLS_Dynamic);\n      Diag(OldLocation, PrevDiag);\n    }\n  }\n\n  // C++ doesn't have tentative definitions, so go right ahead and check here.\n  if (getLangOpts().CPlusPlus &&\n      New->isThisDeclarationADefinition() == VarDecl::Definition) {\n    if (Old->isStaticDataMember() && Old->getCanonicalDecl()->isInline() &&\n        Old->getCanonicalDecl()->isConstexpr()) {\n      // This definition won't be a definition any more once it's been merged.\n      Diag(New->getLocation(),\n           diag::warn_deprecated_redundant_constexpr_static_def);\n    } else if (VarDecl *Def = Old->getDefinition()) {\n      if (checkVarDeclRedefinition(Def, New))\n        return;\n    }\n  }\n\n  if (haveIncompatibleLanguageLinkages(Old, New)) {\n    Diag(New->getLocation(), diag::err_different_language_linkage) << New;\n    Diag(OldLocation, PrevDiag);\n    New->setInvalidDecl();\n    return;\n  }\n\n  // Merge \"used\" flag.\n  if (Old->getMostRecentDecl()->isUsed(false))\n    New->setIsUsed();\n\n  // Keep a chain of previous declarations.\n  New->setPreviousDecl(Old);\n  if (NewTemplate)\n    NewTemplate->setPreviousDecl(OldTemplate);\n\n  // Inherit access appropriately.\n  New->setAccess(Old->getAccess());\n  if (NewTemplate)\n    NewTemplate->setAccess(New->getAccess());\n\n  if (Old->isInline())\n    New->setImplicitlyInline();\n}\n\nvoid Sema::notePreviousDefinition(const NamedDecl *Old, SourceLocation New) {\n  SourceManager &SrcMgr = getSourceManager();\n  auto FNewDecLoc = SrcMgr.getDecomposedLoc(New);\n  auto FOldDecLoc = SrcMgr.getDecomposedLoc(Old->getLocation());\n  auto *FNew = SrcMgr.getFileEntryForID(FNewDecLoc.first);\n  auto *FOld = SrcMgr.getFileEntryForID(FOldDecLoc.first);\n  auto &HSI = PP.getHeaderSearchInfo();\n  StringRef HdrFilename =\n      SrcMgr.getFilename(SrcMgr.getSpellingLoc(Old->getLocation()));\n\n  auto noteFromModuleOrInclude = [&](Module *Mod,\n                                     SourceLocation IncLoc) -> bool {\n    // Redefinition errors with modules are common with non modular mapped\n    // headers, example: a non-modular header H in module A that also gets\n    // included directly in a TU. Pointing twice to the same header/definition\n    // is confusing, try to get better diagnostics when modules is on.\n    if (IncLoc.isValid()) {\n      if (Mod) {\n        Diag(IncLoc, diag::note_redefinition_modules_same_file)\n            << HdrFilename.str() << Mod->getFullModuleName();\n        if (!Mod->DefinitionLoc.isInvalid())\n          Diag(Mod->DefinitionLoc, diag::note_defined_here)\n              << Mod->getFullModuleName();\n      } else {\n        Diag(IncLoc, diag::note_redefinition_include_same_file)\n            << HdrFilename.str();\n      }\n      return true;\n    }\n\n    return false;\n  };\n\n  // Is it the same file and same offset? Provide more information on why\n  // this leads to a redefinition error.\n  if (FNew == FOld && FNewDecLoc.second == FOldDecLoc.second) {\n    SourceLocation OldIncLoc = SrcMgr.getIncludeLoc(FOldDecLoc.first);\n    SourceLocation NewIncLoc = SrcMgr.getIncludeLoc(FNewDecLoc.first);\n    bool EmittedDiag =\n        noteFromModuleOrInclude(Old->getOwningModule(), OldIncLoc);\n    EmittedDiag |= noteFromModuleOrInclude(getCurrentModule(), NewIncLoc);\n\n    // If the header has no guards, emit a note suggesting one.\n    if (FOld && !HSI.isFileMultipleIncludeGuarded(FOld))\n      Diag(Old->getLocation(), diag::note_use_ifdef_guards);\n\n    if (EmittedDiag)\n      return;\n  }\n\n  // Redefinition coming from different files or couldn't do better above.\n  if (Old->getLocation().isValid())\n    Diag(Old->getLocation(), diag::note_previous_definition);\n}\n\n/// We've just determined that \\p Old and \\p New both appear to be definitions\n/// of the same variable. Either diagnose or fix the problem.\nbool Sema::checkVarDeclRedefinition(VarDecl *Old, VarDecl *New) {\n  if (!hasVisibleDefinition(Old) &&\n      (New->getFormalLinkage() == InternalLinkage ||\n       New->isInline() ||\n       New->getDescribedVarTemplate() ||\n       New->getNumTemplateParameterLists() ||\n       New->getDeclContext()->isDependentContext())) {\n    // The previous definition is hidden, and multiple definitions are\n    // permitted (in separate TUs). Demote this to a declaration.\n    New->demoteThisDefinitionToDeclaration();\n\n    // Make the canonical definition visible.\n    if (auto *OldTD = Old->getDescribedVarTemplate())\n      makeMergedDefinitionVisible(OldTD);\n    makeMergedDefinitionVisible(Old);\n    return false;\n  } else {\n    Diag(New->getLocation(), diag::err_redefinition) << New;\n    notePreviousDefinition(Old, New->getLocation());\n    New->setInvalidDecl();\n    return true;\n  }\n}\n\n/// ParsedFreeStandingDeclSpec - This method is invoked when a declspec with\n/// no declarator (e.g. \"struct foo;\") is parsed.\nDecl *\nSema::ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                 RecordDecl *&AnonRecord) {\n  return ParsedFreeStandingDeclSpec(S, AS, DS, MultiTemplateParamsArg(), false,\n                                    AnonRecord);\n}\n\n// The MS ABI changed between VS2013 and VS2015 with regard to numbers used to\n// disambiguate entities defined in different scopes.\n// While the VS2015 ABI fixes potential miscompiles, it is also breaks\n// compatibility.\n// We will pick our mangling number depending on which version of MSVC is being\n// targeted.\nstatic unsigned getMSManglingNumber(const LangOptions &LO, Scope *S) {\n  return LO.isCompatibleWithMSVC(LangOptions::MSVC2015)\n             ? S->getMSCurManglingNumber()\n             : S->getMSLastManglingNumber();\n}\n\nvoid Sema::handleTagNumbering(const TagDecl *Tag, Scope *TagScope) {\n  if (!Context.getLangOpts().CPlusPlus)\n    return;\n\n  if (isa<CXXRecordDecl>(Tag->getParent())) {\n    // If this tag is the direct child of a class, number it if\n    // it is anonymous.\n    if (!Tag->getName().empty() || Tag->getTypedefNameForAnonDecl())\n      return;\n    MangleNumberingContext &MCtx =\n        Context.getManglingNumberContext(Tag->getParent());\n    Context.setManglingNumber(\n        Tag, MCtx.getManglingNumber(\n                 Tag, getMSManglingNumber(getLangOpts(), TagScope)));\n    return;\n  }\n\n  // If this tag isn't a direct child of a class, number it if it is local.\n  MangleNumberingContext *MCtx;\n  Decl *ManglingContextDecl;\n  std::tie(MCtx, ManglingContextDecl) =\n      getCurrentMangleNumberContext(Tag->getDeclContext());\n  if (MCtx) {\n    Context.setManglingNumber(\n        Tag, MCtx->getManglingNumber(\n                 Tag, getMSManglingNumber(getLangOpts(), TagScope)));\n  }\n}\n\nnamespace {\nstruct NonCLikeKind {\n  enum {\n    None,\n    BaseClass,\n    DefaultMemberInit,\n    Lambda,\n    Friend,\n    OtherMember,\n    Invalid,\n  } Kind = None;\n  SourceRange Range;\n\n  explicit operator bool() { return Kind != None; }\n};\n}\n\n/// Determine whether a class is C-like, according to the rules of C++\n/// [dcl.typedef] for anonymous classes with typedef names for linkage.\nstatic NonCLikeKind getNonCLikeKindForAnonymousStruct(const CXXRecordDecl *RD) {\n  if (RD->isInvalidDecl())\n    return {NonCLikeKind::Invalid, {}};\n\n  // C++ [dcl.typedef]p9: [P1766R1]\n  //   An unnamed class with a typedef name for linkage purposes shall not\n  //\n  //    -- have any base classes\n  if (RD->getNumBases())\n    return {NonCLikeKind::BaseClass,\n            SourceRange(RD->bases_begin()->getBeginLoc(),\n                        RD->bases_end()[-1].getEndLoc())};\n  bool Invalid = false;\n  for (Decl *D : RD->decls()) {\n    // Don't complain about things we already diagnosed.\n    if (D->isInvalidDecl()) {\n      Invalid = true;\n      continue;\n    }\n\n    //  -- have any [...] default member initializers\n    if (auto *FD = dyn_cast<FieldDecl>(D)) {\n      if (FD->hasInClassInitializer()) {\n        auto *Init = FD->getInClassInitializer();\n        return {NonCLikeKind::DefaultMemberInit,\n                Init ? Init->getSourceRange() : D->getSourceRange()};\n      }\n      continue;\n    }\n\n    // FIXME: We don't allow friend declarations. This violates the wording of\n    // P1766, but not the intent.\n    if (isa<FriendDecl>(D))\n      return {NonCLikeKind::Friend, D->getSourceRange()};\n\n    //  -- declare any members other than non-static data members, member\n    //     enumerations, or member classes,\n    if (isa<StaticAssertDecl>(D) || isa<IndirectFieldDecl>(D) ||\n        isa<EnumDecl>(D))\n      continue;\n    auto *MemberRD = dyn_cast<CXXRecordDecl>(D);\n    if (!MemberRD) {\n      if (D->isImplicit())\n        continue;\n      return {NonCLikeKind::OtherMember, D->getSourceRange()};\n    }\n\n    //  -- contain a lambda-expression,\n    if (MemberRD->isLambda())\n      return {NonCLikeKind::Lambda, MemberRD->getSourceRange()};\n\n    //  and all member classes shall also satisfy these requirements\n    //  (recursively).\n    if (MemberRD->isThisDeclarationADefinition()) {\n      if (auto Kind = getNonCLikeKindForAnonymousStruct(MemberRD))\n        return Kind;\n    }\n  }\n\n  return {Invalid ? NonCLikeKind::Invalid : NonCLikeKind::None, {}};\n}\n\nvoid Sema::setTagNameForLinkagePurposes(TagDecl *TagFromDeclSpec,\n                                        TypedefNameDecl *NewTD) {\n  if (TagFromDeclSpec->isInvalidDecl())\n    return;\n\n  // Do nothing if the tag already has a name for linkage purposes.\n  if (TagFromDeclSpec->hasNameForLinkage())\n    return;\n\n  // A well-formed anonymous tag must always be a TUK_Definition.\n  assert(TagFromDeclSpec->isThisDeclarationADefinition());\n\n  // The type must match the tag exactly;  no qualifiers allowed.\n  if (!Context.hasSameType(NewTD->getUnderlyingType(),\n                           Context.getTagDeclType(TagFromDeclSpec))) {\n    if (getLangOpts().CPlusPlus)\n      Context.addTypedefNameForUnnamedTagDecl(TagFromDeclSpec, NewTD);\n    return;\n  }\n\n  // C++ [dcl.typedef]p9: [P1766R1, applied as DR]\n  //   An unnamed class with a typedef name for linkage purposes shall [be\n  //   C-like].\n  //\n  // FIXME: Also diagnose if we've already computed the linkage. That ideally\n  // shouldn't happen, but there are constructs that the language rule doesn't\n  // disallow for which we can't reasonably avoid computing linkage early.\n  const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(TagFromDeclSpec);\n  NonCLikeKind NonCLike = RD ? getNonCLikeKindForAnonymousStruct(RD)\n                             : NonCLikeKind();\n  bool ChangesLinkage = TagFromDeclSpec->hasLinkageBeenComputed();\n  if (NonCLike || ChangesLinkage) {\n    if (NonCLike.Kind == NonCLikeKind::Invalid)\n      return;\n\n    unsigned DiagID = diag::ext_non_c_like_anon_struct_in_typedef;\n    if (ChangesLinkage) {\n      // If the linkage changes, we can't accept this as an extension.\n      if (NonCLike.Kind == NonCLikeKind::None)\n        DiagID = diag::err_typedef_changes_linkage;\n      else\n        DiagID = diag::err_non_c_like_anon_struct_in_typedef;\n    }\n\n    SourceLocation FixitLoc =\n        getLocForEndOfToken(TagFromDeclSpec->getInnerLocStart());\n    llvm::SmallString<40> TextToInsert;\n    TextToInsert += ' ';\n    TextToInsert += NewTD->getIdentifier()->getName();\n\n    Diag(FixitLoc, DiagID)\n      << isa<TypeAliasDecl>(NewTD)\n      << FixItHint::CreateInsertion(FixitLoc, TextToInsert);\n    if (NonCLike.Kind != NonCLikeKind::None) {\n      Diag(NonCLike.Range.getBegin(), diag::note_non_c_like_anon_struct)\n        << NonCLike.Kind - 1 << NonCLike.Range;\n    }\n    Diag(NewTD->getLocation(), diag::note_typedef_for_linkage_here)\n      << NewTD << isa<TypeAliasDecl>(NewTD);\n\n    if (ChangesLinkage)\n      return;\n  }\n\n  // Otherwise, set this as the anon-decl typedef for the tag.\n  TagFromDeclSpec->setTypedefNameForAnonDecl(NewTD);\n}\n\nstatic unsigned GetDiagnosticTypeSpecifierID(DeclSpec::TST T) {\n  switch (T) {\n  case DeclSpec::TST_class:\n    return 0;\n  case DeclSpec::TST_struct:\n    return 1;\n  case DeclSpec::TST_interface:\n    return 2;\n  case DeclSpec::TST_union:\n    return 3;\n  case DeclSpec::TST_enum:\n    return 4;\n  default:\n    llvm_unreachable(\"unexpected type specifier\");\n  }\n}\n\n/// ParsedFreeStandingDeclSpec - This method is invoked when a declspec with\n/// no declarator (e.g. \"struct foo;\") is parsed. It also accepts template\n/// parameters to cope with template friend declarations.\nDecl *\nSema::ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                 MultiTemplateParamsArg TemplateParams,\n                                 bool IsExplicitInstantiation,\n                                 RecordDecl *&AnonRecord) {\n  Decl *TagD = nullptr;\n  TagDecl *Tag = nullptr;\n  if (DS.getTypeSpecType() == DeclSpec::TST_class ||\n      DS.getTypeSpecType() == DeclSpec::TST_struct ||\n      DS.getTypeSpecType() == DeclSpec::TST_interface ||\n      DS.getTypeSpecType() == DeclSpec::TST_union ||\n      DS.getTypeSpecType() == DeclSpec::TST_enum) {\n    TagD = DS.getRepAsDecl();\n\n    if (!TagD) // We probably had an error\n      return nullptr;\n\n    // Note that the above type specs guarantee that the\n    // type rep is a Decl, whereas in many of the others\n    // it's a Type.\n    if (isa<TagDecl>(TagD))\n      Tag = cast<TagDecl>(TagD);\n    else if (ClassTemplateDecl *CTD = dyn_cast<ClassTemplateDecl>(TagD))\n      Tag = CTD->getTemplatedDecl();\n  }\n\n  if (Tag) {\n    handleTagNumbering(Tag, S);\n    Tag->setFreeStanding();\n    if (Tag->isInvalidDecl())\n      return Tag;\n  }\n\n  if (unsigned TypeQuals = DS.getTypeQualifiers()) {\n    // Enforce C99 6.7.3p2: \"Types other than pointer types derived from object\n    // or incomplete types shall not be restrict-qualified.\"\n    if (TypeQuals & DeclSpec::TQ_restrict)\n      Diag(DS.getRestrictSpecLoc(),\n           diag::err_typecheck_invalid_restrict_not_pointer_noarg)\n           << DS.getSourceRange();\n  }\n\n  if (DS.isInlineSpecified())\n    Diag(DS.getInlineSpecLoc(), diag::err_inline_non_function)\n        << getLangOpts().CPlusPlus17;\n\n  if (DS.hasConstexprSpecifier()) {\n    // C++0x [dcl.constexpr]p1: constexpr can only be applied to declarations\n    // and definitions of functions and variables.\n    // C++2a [dcl.constexpr]p1: The consteval specifier shall be applied only to\n    // the declaration of a function or function template\n    if (Tag)\n      Diag(DS.getConstexprSpecLoc(), diag::err_constexpr_tag)\n          << GetDiagnosticTypeSpecifierID(DS.getTypeSpecType())\n          << static_cast<int>(DS.getConstexprSpecifier());\n    else\n      Diag(DS.getConstexprSpecLoc(), diag::err_constexpr_wrong_decl_kind)\n          << static_cast<int>(DS.getConstexprSpecifier());\n    // Don't emit warnings after this error.\n    return TagD;\n  }\n\n  DiagnoseFunctionSpecifiers(DS);\n\n  if (DS.isFriendSpecified()) {\n    // If we're dealing with a decl but not a TagDecl, assume that\n    // whatever routines created it handled the friendship aspect.\n    if (TagD && !Tag)\n      return nullptr;\n    return ActOnFriendTypeDecl(S, DS, TemplateParams);\n  }\n\n  const CXXScopeSpec &SS = DS.getTypeSpecScope();\n  bool IsExplicitSpecialization =\n    !TemplateParams.empty() && TemplateParams.back()->size() == 0;\n  if (Tag && SS.isNotEmpty() && !Tag->isCompleteDefinition() &&\n      !IsExplicitInstantiation && !IsExplicitSpecialization &&\n      !isa<ClassTemplatePartialSpecializationDecl>(Tag)) {\n    // Per C++ [dcl.type.elab]p1, a class declaration cannot have a\n    // nested-name-specifier unless it is an explicit instantiation\n    // or an explicit specialization.\n    //\n    // FIXME: We allow class template partial specializations here too, per the\n    // obvious intent of DR1819.\n    //\n    // Per C++ [dcl.enum]p1, an opaque-enum-declaration can't either.\n    Diag(SS.getBeginLoc(), diag::err_standalone_class_nested_name_specifier)\n        << GetDiagnosticTypeSpecifierID(DS.getTypeSpecType()) << SS.getRange();\n    return nullptr;\n  }\n\n  // Track whether this decl-specifier declares anything.\n  bool DeclaresAnything = true;\n\n  // Handle anonymous struct definitions.\n  if (RecordDecl *Record = dyn_cast_or_null<RecordDecl>(Tag)) {\n    if (!Record->getDeclName() && Record->isCompleteDefinition() &&\n        DS.getStorageClassSpec() != DeclSpec::SCS_typedef) {\n      if (getLangOpts().CPlusPlus ||\n          Record->getDeclContext()->isRecord()) {\n        // If CurContext is a DeclContext that can contain statements,\n        // RecursiveASTVisitor won't visit the decls that\n        // BuildAnonymousStructOrUnion() will put into CurContext.\n        // Also store them here so that they can be part of the\n        // DeclStmt that gets created in this case.\n        // FIXME: Also return the IndirectFieldDecls created by\n        // BuildAnonymousStructOr union, for the same reason?\n        if (CurContext->isFunctionOrMethod())\n          AnonRecord = Record;\n        return BuildAnonymousStructOrUnion(S, DS, AS, Record,\n                                           Context.getPrintingPolicy());\n      }\n\n      DeclaresAnything = false;\n    }\n  }\n\n  // C11 6.7.2.1p2:\n  //   A struct-declaration that does not declare an anonymous structure or\n  //   anonymous union shall contain a struct-declarator-list.\n  //\n  // This rule also existed in C89 and C99; the grammar for struct-declaration\n  // did not permit a struct-declaration without a struct-declarator-list.\n  if (!getLangOpts().CPlusPlus && CurContext->isRecord() &&\n      DS.getStorageClassSpec() == DeclSpec::SCS_unspecified) {\n    // Check for Microsoft C extension: anonymous struct/union member.\n    // Handle 2 kinds of anonymous struct/union:\n    //   struct STRUCT;\n    //   union UNION;\n    // and\n    //   STRUCT_TYPE;  <- where STRUCT_TYPE is a typedef struct.\n    //   UNION_TYPE;   <- where UNION_TYPE is a typedef union.\n    if ((Tag && Tag->getDeclName()) ||\n        DS.getTypeSpecType() == DeclSpec::TST_typename) {\n      RecordDecl *Record = nullptr;\n      if (Tag)\n        Record = dyn_cast<RecordDecl>(Tag);\n      else if (const RecordType *RT =\n                   DS.getRepAsType().get()->getAsStructureType())\n        Record = RT->getDecl();\n      else if (const RecordType *UT = DS.getRepAsType().get()->getAsUnionType())\n        Record = UT->getDecl();\n\n      if (Record && getLangOpts().MicrosoftExt) {\n        Diag(DS.getBeginLoc(), diag::ext_ms_anonymous_record)\n            << Record->isUnion() << DS.getSourceRange();\n        return BuildMicrosoftCAnonymousStruct(S, DS, Record);\n      }\n\n      DeclaresAnything = false;\n    }\n  }\n\n  // Skip all the checks below if we have a type error.\n  if (DS.getTypeSpecType() == DeclSpec::TST_error ||\n      (TagD && TagD->isInvalidDecl()))\n    return TagD;\n\n  if (getLangOpts().CPlusPlus &&\n      DS.getStorageClassSpec() != DeclSpec::SCS_typedef)\n    if (EnumDecl *Enum = dyn_cast_or_null<EnumDecl>(Tag))\n      if (Enum->enumerator_begin() == Enum->enumerator_end() &&\n          !Enum->getIdentifier() && !Enum->isInvalidDecl())\n        DeclaresAnything = false;\n\n  if (!DS.isMissingDeclaratorOk()) {\n    // Customize diagnostic for a typedef missing a name.\n    if (DS.getStorageClassSpec() == DeclSpec::SCS_typedef)\n      Diag(DS.getBeginLoc(), diag::ext_typedef_without_a_name)\n          << DS.getSourceRange();\n    else\n      DeclaresAnything = false;\n  }\n\n  if (DS.isModulePrivateSpecified() &&\n      Tag && Tag->getDeclContext()->isFunctionOrMethod())\n    Diag(DS.getModulePrivateSpecLoc(), diag::err_module_private_local_class)\n      << Tag->getTagKind()\n      << FixItHint::CreateRemoval(DS.getModulePrivateSpecLoc());\n\n  ActOnDocumentableDecl(TagD);\n\n  // C 6.7/2:\n  //   A declaration [...] shall declare at least a declarator [...], a tag,\n  //   or the members of an enumeration.\n  // C++ [dcl.dcl]p3:\n  //   [If there are no declarators], and except for the declaration of an\n  //   unnamed bit-field, the decl-specifier-seq shall introduce one or more\n  //   names into the program, or shall redeclare a name introduced by a\n  //   previous declaration.\n  if (!DeclaresAnything) {\n    // In C, we allow this as a (popular) extension / bug. Don't bother\n    // producing further diagnostics for redundant qualifiers after this.\n    Diag(DS.getBeginLoc(), (IsExplicitInstantiation || !TemplateParams.empty())\n                               ? diag::err_no_declarators\n                               : diag::ext_no_declarators)\n        << DS.getSourceRange();\n    return TagD;\n  }\n\n  // C++ [dcl.stc]p1:\n  //   If a storage-class-specifier appears in a decl-specifier-seq, [...] the\n  //   init-declarator-list of the declaration shall not be empty.\n  // C++ [dcl.fct.spec]p1:\n  //   If a cv-qualifier appears in a decl-specifier-seq, the\n  //   init-declarator-list of the declaration shall not be empty.\n  //\n  // Spurious qualifiers here appear to be valid in C.\n  unsigned DiagID = diag::warn_standalone_specifier;\n  if (getLangOpts().CPlusPlus)\n    DiagID = diag::ext_standalone_specifier;\n\n  // Note that a linkage-specification sets a storage class, but\n  // 'extern \"C\" struct foo;' is actually valid and not theoretically\n  // useless.\n  if (DeclSpec::SCS SCS = DS.getStorageClassSpec()) {\n    if (SCS == DeclSpec::SCS_mutable)\n      // Since mutable is not a viable storage class specifier in C, there is\n      // no reason to treat it as an extension. Instead, diagnose as an error.\n      Diag(DS.getStorageClassSpecLoc(), diag::err_mutable_nonmember);\n    else if (!DS.isExternInLinkageSpec() && SCS != DeclSpec::SCS_typedef)\n      Diag(DS.getStorageClassSpecLoc(), DiagID)\n        << DeclSpec::getSpecifierName(SCS);\n  }\n\n  if (DeclSpec::TSCS TSCS = DS.getThreadStorageClassSpec())\n    Diag(DS.getThreadStorageClassSpecLoc(), DiagID)\n      << DeclSpec::getSpecifierName(TSCS);\n  if (DS.getTypeQualifiers()) {\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_const)\n      Diag(DS.getConstSpecLoc(), DiagID) << \"const\";\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_volatile)\n      Diag(DS.getConstSpecLoc(), DiagID) << \"volatile\";\n    // Restrict is covered above.\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_atomic)\n      Diag(DS.getAtomicSpecLoc(), DiagID) << \"_Atomic\";\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_unaligned)\n      Diag(DS.getUnalignedSpecLoc(), DiagID) << \"__unaligned\";\n  }\n\n  // Warn about ignored type attributes, for example:\n  // __attribute__((aligned)) struct A;\n  // Attributes should be placed after tag to apply to type declaration.\n  if (!DS.getAttributes().empty()) {\n    DeclSpec::TST TypeSpecType = DS.getTypeSpecType();\n    if (TypeSpecType == DeclSpec::TST_class ||\n        TypeSpecType == DeclSpec::TST_struct ||\n        TypeSpecType == DeclSpec::TST_interface ||\n        TypeSpecType == DeclSpec::TST_union ||\n        TypeSpecType == DeclSpec::TST_enum) {\n      for (const ParsedAttr &AL : DS.getAttributes())\n        Diag(AL.getLoc(), diag::warn_declspec_attribute_ignored)\n            << AL << GetDiagnosticTypeSpecifierID(TypeSpecType);\n    }\n  }\n\n  return TagD;\n}\n\n/// We are trying to inject an anonymous member into the given scope;\n/// check if there's an existing declaration that can't be overloaded.\n///\n/// \\return true if this is a forbidden redeclaration\nstatic bool CheckAnonMemberRedeclaration(Sema &SemaRef,\n                                         Scope *S,\n                                         DeclContext *Owner,\n                                         DeclarationName Name,\n                                         SourceLocation NameLoc,\n                                         bool IsUnion) {\n  LookupResult R(SemaRef, Name, NameLoc, Sema::LookupMemberName,\n                 Sema::ForVisibleRedeclaration);\n  if (!SemaRef.LookupName(R, S)) return false;\n\n  // Pick a representative declaration.\n  NamedDecl *PrevDecl = R.getRepresentativeDecl()->getUnderlyingDecl();\n  assert(PrevDecl && \"Expected a non-null Decl\");\n\n  if (!SemaRef.isDeclInScope(PrevDecl, Owner, S))\n    return false;\n\n  SemaRef.Diag(NameLoc, diag::err_anonymous_record_member_redecl)\n    << IsUnion << Name;\n  SemaRef.Diag(PrevDecl->getLocation(), diag::note_previous_declaration);\n\n  return true;\n}\n\n/// InjectAnonymousStructOrUnionMembers - Inject the members of the\n/// anonymous struct or union AnonRecord into the owning context Owner\n/// and scope S. This routine will be invoked just after we realize\n/// that an unnamed union or struct is actually an anonymous union or\n/// struct, e.g.,\n///\n/// @code\n/// union {\n///   int i;\n///   float f;\n/// }; // InjectAnonymousStructOrUnionMembers called here to inject i and\n///    // f into the surrounding scope.x\n/// @endcode\n///\n/// This routine is recursive, injecting the names of nested anonymous\n/// structs/unions into the owning context and scope as well.\nstatic bool\nInjectAnonymousStructOrUnionMembers(Sema &SemaRef, Scope *S, DeclContext *Owner,\n                                    RecordDecl *AnonRecord, AccessSpecifier AS,\n                                    SmallVectorImpl<NamedDecl *> &Chaining) {\n  bool Invalid = false;\n\n  // Look every FieldDecl and IndirectFieldDecl with a name.\n  for (auto *D : AnonRecord->decls()) {\n    if ((isa<FieldDecl>(D) || isa<IndirectFieldDecl>(D)) &&\n        cast<NamedDecl>(D)->getDeclName()) {\n      ValueDecl *VD = cast<ValueDecl>(D);\n      if (CheckAnonMemberRedeclaration(SemaRef, S, Owner, VD->getDeclName(),\n                                       VD->getLocation(),\n                                       AnonRecord->isUnion())) {\n        // C++ [class.union]p2:\n        //   The names of the members of an anonymous union shall be\n        //   distinct from the names of any other entity in the\n        //   scope in which the anonymous union is declared.\n        Invalid = true;\n      } else {\n        // C++ [class.union]p2:\n        //   For the purpose of name lookup, after the anonymous union\n        //   definition, the members of the anonymous union are\n        //   considered to have been defined in the scope in which the\n        //   anonymous union is declared.\n        unsigned OldChainingSize = Chaining.size();\n        if (IndirectFieldDecl *IF = dyn_cast<IndirectFieldDecl>(VD))\n          Chaining.append(IF->chain_begin(), IF->chain_end());\n        else\n          Chaining.push_back(VD);\n\n        assert(Chaining.size() >= 2);\n        NamedDecl **NamedChain =\n          new (SemaRef.Context)NamedDecl*[Chaining.size()];\n        for (unsigned i = 0; i < Chaining.size(); i++)\n          NamedChain[i] = Chaining[i];\n\n        IndirectFieldDecl *IndirectField = IndirectFieldDecl::Create(\n            SemaRef.Context, Owner, VD->getLocation(), VD->getIdentifier(),\n            VD->getType(), {NamedChain, Chaining.size()});\n\n        for (const auto *Attr : VD->attrs())\n          IndirectField->addAttr(Attr->clone(SemaRef.Context));\n\n        IndirectField->setAccess(AS);\n        IndirectField->setImplicit();\n        SemaRef.PushOnScopeChains(IndirectField, S);\n\n        // That includes picking up the appropriate access specifier.\n        if (AS != AS_none) IndirectField->setAccess(AS);\n\n        Chaining.resize(OldChainingSize);\n      }\n    }\n  }\n\n  return Invalid;\n}\n\n/// StorageClassSpecToVarDeclStorageClass - Maps a DeclSpec::SCS to\n/// a VarDecl::StorageClass. Any error reporting is up to the caller:\n/// illegal input values are mapped to SC_None.\nstatic StorageClass\nStorageClassSpecToVarDeclStorageClass(const DeclSpec &DS) {\n  DeclSpec::SCS StorageClassSpec = DS.getStorageClassSpec();\n  assert(StorageClassSpec != DeclSpec::SCS_typedef &&\n         \"Parser allowed 'typedef' as storage class VarDecl.\");\n  switch (StorageClassSpec) {\n  case DeclSpec::SCS_unspecified:    return SC_None;\n  case DeclSpec::SCS_extern:\n    if (DS.isExternInLinkageSpec())\n      return SC_None;\n    return SC_Extern;\n  case DeclSpec::SCS_static:         return SC_Static;\n  case DeclSpec::SCS_auto:           return SC_Auto;\n  case DeclSpec::SCS_register:       return SC_Register;\n  case DeclSpec::SCS_private_extern: return SC_PrivateExtern;\n    // Illegal SCSs map to None: error reporting is up to the caller.\n  case DeclSpec::SCS_mutable:        // Fall through.\n  case DeclSpec::SCS_typedef:        return SC_None;\n  }\n  llvm_unreachable(\"unknown storage class specifier\");\n}\n\nstatic SourceLocation findDefaultInitializer(const CXXRecordDecl *Record) {\n  assert(Record->hasInClassInitializer());\n\n  for (const auto *I : Record->decls()) {\n    const auto *FD = dyn_cast<FieldDecl>(I);\n    if (const auto *IFD = dyn_cast<IndirectFieldDecl>(I))\n      FD = IFD->getAnonField();\n    if (FD && FD->hasInClassInitializer())\n      return FD->getLocation();\n  }\n\n  llvm_unreachable(\"couldn't find in-class initializer\");\n}\n\nstatic void checkDuplicateDefaultInit(Sema &S, CXXRecordDecl *Parent,\n                                      SourceLocation DefaultInitLoc) {\n  if (!Parent->isUnion() || !Parent->hasInClassInitializer())\n    return;\n\n  S.Diag(DefaultInitLoc, diag::err_multiple_mem_union_initialization);\n  S.Diag(findDefaultInitializer(Parent), diag::note_previous_initializer) << 0;\n}\n\nstatic void checkDuplicateDefaultInit(Sema &S, CXXRecordDecl *Parent,\n                                      CXXRecordDecl *AnonUnion) {\n  if (!Parent->isUnion() || !Parent->hasInClassInitializer())\n    return;\n\n  checkDuplicateDefaultInit(S, Parent, findDefaultInitializer(AnonUnion));\n}\n\n/// BuildAnonymousStructOrUnion - Handle the declaration of an\n/// anonymous structure or union. Anonymous unions are a C++ feature\n/// (C++ [class.union]) and a C11 feature; anonymous structures\n/// are a C11 feature and GNU C++ extension.\nDecl *Sema::BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS,\n                                        AccessSpecifier AS,\n                                        RecordDecl *Record,\n                                        const PrintingPolicy &Policy) {\n  DeclContext *Owner = Record->getDeclContext();\n\n  // Diagnose whether this anonymous struct/union is an extension.\n  if (Record->isUnion() && !getLangOpts().CPlusPlus && !getLangOpts().C11)\n    Diag(Record->getLocation(), diag::ext_anonymous_union);\n  else if (!Record->isUnion() && getLangOpts().CPlusPlus)\n    Diag(Record->getLocation(), diag::ext_gnu_anonymous_struct);\n  else if (!Record->isUnion() && !getLangOpts().C11)\n    Diag(Record->getLocation(), diag::ext_c11_anonymous_struct);\n\n  // C and C++ require different kinds of checks for anonymous\n  // structs/unions.\n  bool Invalid = false;\n  if (getLangOpts().CPlusPlus) {\n    const char *PrevSpec = nullptr;\n    if (Record->isUnion()) {\n      // C++ [class.union]p6:\n      // C++17 [class.union.anon]p2:\n      //   Anonymous unions declared in a named namespace or in the\n      //   global namespace shall be declared static.\n      unsigned DiagID;\n      DeclContext *OwnerScope = Owner->getRedeclContext();\n      if (DS.getStorageClassSpec() != DeclSpec::SCS_static &&\n          (OwnerScope->isTranslationUnit() ||\n           (OwnerScope->isNamespace() &&\n            !cast<NamespaceDecl>(OwnerScope)->isAnonymousNamespace()))) {\n        Diag(Record->getLocation(), diag::err_anonymous_union_not_static)\n          << FixItHint::CreateInsertion(Record->getLocation(), \"static \");\n\n        // Recover by adding 'static'.\n        DS.SetStorageClassSpec(*this, DeclSpec::SCS_static, SourceLocation(),\n                               PrevSpec, DiagID, Policy);\n      }\n      // C++ [class.union]p6:\n      //   A storage class is not allowed in a declaration of an\n      //   anonymous union in a class scope.\n      else if (DS.getStorageClassSpec() != DeclSpec::SCS_unspecified &&\n               isa<RecordDecl>(Owner)) {\n        Diag(DS.getStorageClassSpecLoc(),\n             diag::err_anonymous_union_with_storage_spec)\n          << FixItHint::CreateRemoval(DS.getStorageClassSpecLoc());\n\n        // Recover by removing the storage specifier.\n        DS.SetStorageClassSpec(*this, DeclSpec::SCS_unspecified,\n                               SourceLocation(),\n                               PrevSpec, DiagID, Context.getPrintingPolicy());\n      }\n    }\n\n    // Ignore const/volatile/restrict qualifiers.\n    if (DS.getTypeQualifiers()) {\n      if (DS.getTypeQualifiers() & DeclSpec::TQ_const)\n        Diag(DS.getConstSpecLoc(), diag::ext_anonymous_struct_union_qualified)\n          << Record->isUnion() << \"const\"\n          << FixItHint::CreateRemoval(DS.getConstSpecLoc());\n      if (DS.getTypeQualifiers() & DeclSpec::TQ_volatile)\n        Diag(DS.getVolatileSpecLoc(),\n             diag::ext_anonymous_struct_union_qualified)\n          << Record->isUnion() << \"volatile\"\n          << FixItHint::CreateRemoval(DS.getVolatileSpecLoc());\n      if (DS.getTypeQualifiers() & DeclSpec::TQ_restrict)\n        Diag(DS.getRestrictSpecLoc(),\n             diag::ext_anonymous_struct_union_qualified)\n          << Record->isUnion() << \"restrict\"\n          << FixItHint::CreateRemoval(DS.getRestrictSpecLoc());\n      if (DS.getTypeQualifiers() & DeclSpec::TQ_atomic)\n        Diag(DS.getAtomicSpecLoc(),\n             diag::ext_anonymous_struct_union_qualified)\n          << Record->isUnion() << \"_Atomic\"\n          << FixItHint::CreateRemoval(DS.getAtomicSpecLoc());\n      if (DS.getTypeQualifiers() & DeclSpec::TQ_unaligned)\n        Diag(DS.getUnalignedSpecLoc(),\n             diag::ext_anonymous_struct_union_qualified)\n          << Record->isUnion() << \"__unaligned\"\n          << FixItHint::CreateRemoval(DS.getUnalignedSpecLoc());\n\n      DS.ClearTypeQualifiers();\n    }\n\n    // C++ [class.union]p2:\n    //   The member-specification of an anonymous union shall only\n    //   define non-static data members. [Note: nested types and\n    //   functions cannot be declared within an anonymous union. ]\n    for (auto *Mem : Record->decls()) {\n      // Ignore invalid declarations; we already diagnosed them.\n      if (Mem->isInvalidDecl())\n        continue;\n\n      if (auto *FD = dyn_cast<FieldDecl>(Mem)) {\n        // C++ [class.union]p3:\n        //   An anonymous union shall not have private or protected\n        //   members (clause 11).\n        assert(FD->getAccess() != AS_none);\n        if (FD->getAccess() != AS_public) {\n          Diag(FD->getLocation(), diag::err_anonymous_record_nonpublic_member)\n            << Record->isUnion() << (FD->getAccess() == AS_protected);\n          Invalid = true;\n        }\n\n        // C++ [class.union]p1\n        //   An object of a class with a non-trivial constructor, a non-trivial\n        //   copy constructor, a non-trivial destructor, or a non-trivial copy\n        //   assignment operator cannot be a member of a union, nor can an\n        //   array of such objects.\n        if (CheckNontrivialField(FD))\n          Invalid = true;\n      } else if (Mem->isImplicit()) {\n        // Any implicit members are fine.\n      } else if (isa<TagDecl>(Mem) && Mem->getDeclContext() != Record) {\n        // This is a type that showed up in an\n        // elaborated-type-specifier inside the anonymous struct or\n        // union, but which actually declares a type outside of the\n        // anonymous struct or union. It's okay.\n      } else if (auto *MemRecord = dyn_cast<RecordDecl>(Mem)) {\n        if (!MemRecord->isAnonymousStructOrUnion() &&\n            MemRecord->getDeclName()) {\n          // Visual C++ allows type definition in anonymous struct or union.\n          if (getLangOpts().MicrosoftExt)\n            Diag(MemRecord->getLocation(), diag::ext_anonymous_record_with_type)\n              << Record->isUnion();\n          else {\n            // This is a nested type declaration.\n            Diag(MemRecord->getLocation(), diag::err_anonymous_record_with_type)\n              << Record->isUnion();\n            Invalid = true;\n          }\n        } else {\n          // This is an anonymous type definition within another anonymous type.\n          // This is a popular extension, provided by Plan9, MSVC and GCC, but\n          // not part of standard C++.\n          Diag(MemRecord->getLocation(),\n               diag::ext_anonymous_record_with_anonymous_type)\n            << Record->isUnion();\n        }\n      } else if (isa<AccessSpecDecl>(Mem)) {\n        // Any access specifier is fine.\n      } else if (isa<StaticAssertDecl>(Mem)) {\n        // In C++1z, static_assert declarations are also fine.\n      } else {\n        // We have something that isn't a non-static data\n        // member. Complain about it.\n        unsigned DK = diag::err_anonymous_record_bad_member;\n        if (isa<TypeDecl>(Mem))\n          DK = diag::err_anonymous_record_with_type;\n        else if (isa<FunctionDecl>(Mem))\n          DK = diag::err_anonymous_record_with_function;\n        else if (isa<VarDecl>(Mem))\n          DK = diag::err_anonymous_record_with_static;\n\n        // Visual C++ allows type definition in anonymous struct or union.\n        if (getLangOpts().MicrosoftExt &&\n            DK == diag::err_anonymous_record_with_type)\n          Diag(Mem->getLocation(), diag::ext_anonymous_record_with_type)\n            << Record->isUnion();\n        else {\n          Diag(Mem->getLocation(), DK) << Record->isUnion();\n          Invalid = true;\n        }\n      }\n    }\n\n    // C++11 [class.union]p8 (DR1460):\n    //   At most one variant member of a union may have a\n    //   brace-or-equal-initializer.\n    if (cast<CXXRecordDecl>(Record)->hasInClassInitializer() &&\n        Owner->isRecord())\n      checkDuplicateDefaultInit(*this, cast<CXXRecordDecl>(Owner),\n                                cast<CXXRecordDecl>(Record));\n  }\n\n  if (!Record->isUnion() && !Owner->isRecord()) {\n    Diag(Record->getLocation(), diag::err_anonymous_struct_not_member)\n      << getLangOpts().CPlusPlus;\n    Invalid = true;\n  }\n\n  // C++ [dcl.dcl]p3:\n  //   [If there are no declarators], and except for the declaration of an\n  //   unnamed bit-field, the decl-specifier-seq shall introduce one or more\n  //   names into the program\n  // C++ [class.mem]p2:\n  //   each such member-declaration shall either declare at least one member\n  //   name of the class or declare at least one unnamed bit-field\n  //\n  // For C this is an error even for a named struct, and is diagnosed elsewhere.\n  if (getLangOpts().CPlusPlus && Record->field_empty())\n    Diag(DS.getBeginLoc(), diag::ext_no_declarators) << DS.getSourceRange();\n\n  // Mock up a declarator.\n  Declarator Dc(DS, DeclaratorContext::Member);\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(Dc, S);\n  assert(TInfo && \"couldn't build declarator info for anonymous struct/union\");\n\n  // Create a declaration for this anonymous struct/union.\n  NamedDecl *Anon = nullptr;\n  if (RecordDecl *OwningClass = dyn_cast<RecordDecl>(Owner)) {\n    Anon = FieldDecl::Create(\n        Context, OwningClass, DS.getBeginLoc(), Record->getLocation(),\n        /*IdentifierInfo=*/nullptr, Context.getTypeDeclType(Record), TInfo,\n        /*BitWidth=*/nullptr, /*Mutable=*/false,\n        /*InitStyle=*/ICIS_NoInit);\n    Anon->setAccess(AS);\n    ProcessDeclAttributes(S, Anon, Dc);\n\n    if (getLangOpts().CPlusPlus)\n      FieldCollector->Add(cast<FieldDecl>(Anon));\n  } else {\n    DeclSpec::SCS SCSpec = DS.getStorageClassSpec();\n    StorageClass SC = StorageClassSpecToVarDeclStorageClass(DS);\n    if (SCSpec == DeclSpec::SCS_mutable) {\n      // mutable can only appear on non-static class members, so it's always\n      // an error here\n      Diag(Record->getLocation(), diag::err_mutable_nonmember);\n      Invalid = true;\n      SC = SC_None;\n    }\n\n    assert(DS.getAttributes().empty() && \"No attribute expected\");\n    Anon = VarDecl::Create(Context, Owner, DS.getBeginLoc(),\n                           Record->getLocation(), /*IdentifierInfo=*/nullptr,\n                           Context.getTypeDeclType(Record), TInfo, SC);\n\n    // Default-initialize the implicit variable. This initialization will be\n    // trivial in almost all cases, except if a union member has an in-class\n    // initializer:\n    //   union { int n = 0; };\n    ActOnUninitializedDecl(Anon);\n  }\n  Anon->setImplicit();\n\n  // Mark this as an anonymous struct/union type.\n  Record->setAnonymousStructOrUnion(true);\n\n  // Add the anonymous struct/union object to the current\n  // context. We'll be referencing this object when we refer to one of\n  // its members.\n  Owner->addDecl(Anon);\n\n  // Inject the members of the anonymous struct/union into the owning\n  // context and into the identifier resolver chain for name lookup\n  // purposes.\n  SmallVector<NamedDecl*, 2> Chain;\n  Chain.push_back(Anon);\n\n  if (InjectAnonymousStructOrUnionMembers(*this, S, Owner, Record, AS, Chain))\n    Invalid = true;\n\n  if (VarDecl *NewVD = dyn_cast<VarDecl>(Anon)) {\n    if (getLangOpts().CPlusPlus && NewVD->isStaticLocal()) {\n      MangleNumberingContext *MCtx;\n      Decl *ManglingContextDecl;\n      std::tie(MCtx, ManglingContextDecl) =\n          getCurrentMangleNumberContext(NewVD->getDeclContext());\n      if (MCtx) {\n        Context.setManglingNumber(\n            NewVD, MCtx->getManglingNumber(\n                       NewVD, getMSManglingNumber(getLangOpts(), S)));\n        Context.setStaticLocalNumber(NewVD, MCtx->getStaticLocalNumber(NewVD));\n      }\n    }\n  }\n\n  if (Invalid)\n    Anon->setInvalidDecl();\n\n  return Anon;\n}\n\n/// BuildMicrosoftCAnonymousStruct - Handle the declaration of an\n/// Microsoft C anonymous structure.\n/// Ref: http://msdn.microsoft.com/en-us/library/z2cx9y4f.aspx\n/// Example:\n///\n/// struct A { int a; };\n/// struct B { struct A; int b; };\n///\n/// void foo() {\n///   B var;\n///   var.a = 3;\n/// }\n///\nDecl *Sema::BuildMicrosoftCAnonymousStruct(Scope *S, DeclSpec &DS,\n                                           RecordDecl *Record) {\n  assert(Record && \"expected a record!\");\n\n  // Mock up a declarator.\n  Declarator Dc(DS, DeclaratorContext::TypeName);\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(Dc, S);\n  assert(TInfo && \"couldn't build declarator info for anonymous struct\");\n\n  auto *ParentDecl = cast<RecordDecl>(CurContext);\n  QualType RecTy = Context.getTypeDeclType(Record);\n\n  // Create a declaration for this anonymous struct.\n  NamedDecl *Anon =\n      FieldDecl::Create(Context, ParentDecl, DS.getBeginLoc(), DS.getBeginLoc(),\n                        /*IdentifierInfo=*/nullptr, RecTy, TInfo,\n                        /*BitWidth=*/nullptr, /*Mutable=*/false,\n                        /*InitStyle=*/ICIS_NoInit);\n  Anon->setImplicit();\n\n  // Add the anonymous struct object to the current context.\n  CurContext->addDecl(Anon);\n\n  // Inject the members of the anonymous struct into the current\n  // context and into the identifier resolver chain for name lookup\n  // purposes.\n  SmallVector<NamedDecl*, 2> Chain;\n  Chain.push_back(Anon);\n\n  RecordDecl *RecordDef = Record->getDefinition();\n  if (RequireCompleteSizedType(Anon->getLocation(), RecTy,\n                               diag::err_field_incomplete_or_sizeless) ||\n      InjectAnonymousStructOrUnionMembers(*this, S, CurContext, RecordDef,\n                                          AS_none, Chain)) {\n    Anon->setInvalidDecl();\n    ParentDecl->setInvalidDecl();\n  }\n\n  return Anon;\n}\n\n/// GetNameForDeclarator - Determine the full declaration name for the\n/// given Declarator.\nDeclarationNameInfo Sema::GetNameForDeclarator(Declarator &D) {\n  return GetNameFromUnqualifiedId(D.getName());\n}\n\n/// Retrieves the declaration name from a parsed unqualified-id.\nDeclarationNameInfo\nSema::GetNameFromUnqualifiedId(const UnqualifiedId &Name) {\n  DeclarationNameInfo NameInfo;\n  NameInfo.setLoc(Name.StartLocation);\n\n  switch (Name.getKind()) {\n\n  case UnqualifiedIdKind::IK_ImplicitSelfParam:\n  case UnqualifiedIdKind::IK_Identifier:\n    NameInfo.setName(Name.Identifier);\n    return NameInfo;\n\n  case UnqualifiedIdKind::IK_DeductionGuideName: {\n    // C++ [temp.deduct.guide]p3:\n    //   The simple-template-id shall name a class template specialization.\n    //   The template-name shall be the same identifier as the template-name\n    //   of the simple-template-id.\n    // These together intend to imply that the template-name shall name a\n    // class template.\n    // FIXME: template<typename T> struct X {};\n    //        template<typename T> using Y = X<T>;\n    //        Y(int) -> Y<int>;\n    //   satisfies these rules but does not name a class template.\n    TemplateName TN = Name.TemplateName.get().get();\n    auto *Template = TN.getAsTemplateDecl();\n    if (!Template || !isa<ClassTemplateDecl>(Template)) {\n      Diag(Name.StartLocation,\n           diag::err_deduction_guide_name_not_class_template)\n        << (int)getTemplateNameKindForDiagnostics(TN) << TN;\n      if (Template)\n        Diag(Template->getLocation(), diag::note_template_decl_here);\n      return DeclarationNameInfo();\n    }\n\n    NameInfo.setName(\n        Context.DeclarationNames.getCXXDeductionGuideName(Template));\n    return NameInfo;\n  }\n\n  case UnqualifiedIdKind::IK_OperatorFunctionId:\n    NameInfo.setName(Context.DeclarationNames.getCXXOperatorName(\n                                           Name.OperatorFunctionId.Operator));\n    NameInfo.setCXXOperatorNameRange(SourceRange(\n        Name.OperatorFunctionId.SymbolLocations[0], Name.EndLocation));\n    return NameInfo;\n\n  case UnqualifiedIdKind::IK_LiteralOperatorId:\n    NameInfo.setName(Context.DeclarationNames.getCXXLiteralOperatorName(\n                                                           Name.Identifier));\n    NameInfo.setCXXLiteralOperatorNameLoc(Name.EndLocation);\n    return NameInfo;\n\n  case UnqualifiedIdKind::IK_ConversionFunctionId: {\n    TypeSourceInfo *TInfo;\n    QualType Ty = GetTypeFromParser(Name.ConversionFunctionId, &TInfo);\n    if (Ty.isNull())\n      return DeclarationNameInfo();\n    NameInfo.setName(Context.DeclarationNames.getCXXConversionFunctionName(\n                                               Context.getCanonicalType(Ty)));\n    NameInfo.setNamedTypeInfo(TInfo);\n    return NameInfo;\n  }\n\n  case UnqualifiedIdKind::IK_ConstructorName: {\n    TypeSourceInfo *TInfo;\n    QualType Ty = GetTypeFromParser(Name.ConstructorName, &TInfo);\n    if (Ty.isNull())\n      return DeclarationNameInfo();\n    NameInfo.setName(Context.DeclarationNames.getCXXConstructorName(\n                                              Context.getCanonicalType(Ty)));\n    NameInfo.setNamedTypeInfo(TInfo);\n    return NameInfo;\n  }\n\n  case UnqualifiedIdKind::IK_ConstructorTemplateId: {\n    // In well-formed code, we can only have a constructor\n    // template-id that refers to the current context, so go there\n    // to find the actual type being constructed.\n    CXXRecordDecl *CurClass = dyn_cast<CXXRecordDecl>(CurContext);\n    if (!CurClass || CurClass->getIdentifier() != Name.TemplateId->Name)\n      return DeclarationNameInfo();\n\n    // Determine the type of the class being constructed.\n    QualType CurClassType = Context.getTypeDeclType(CurClass);\n\n    // FIXME: Check two things: that the template-id names the same type as\n    // CurClassType, and that the template-id does not occur when the name\n    // was qualified.\n\n    NameInfo.setName(Context.DeclarationNames.getCXXConstructorName(\n                                    Context.getCanonicalType(CurClassType)));\n    // FIXME: should we retrieve TypeSourceInfo?\n    NameInfo.setNamedTypeInfo(nullptr);\n    return NameInfo;\n  }\n\n  case UnqualifiedIdKind::IK_DestructorName: {\n    TypeSourceInfo *TInfo;\n    QualType Ty = GetTypeFromParser(Name.DestructorName, &TInfo);\n    if (Ty.isNull())\n      return DeclarationNameInfo();\n    NameInfo.setName(Context.DeclarationNames.getCXXDestructorName(\n                                              Context.getCanonicalType(Ty)));\n    NameInfo.setNamedTypeInfo(TInfo);\n    return NameInfo;\n  }\n\n  case UnqualifiedIdKind::IK_TemplateId: {\n    TemplateName TName = Name.TemplateId->Template.get();\n    SourceLocation TNameLoc = Name.TemplateId->TemplateNameLoc;\n    return Context.getNameForTemplate(TName, TNameLoc);\n  }\n\n  } // switch (Name.getKind())\n\n  llvm_unreachable(\"Unknown name kind\");\n}\n\nstatic QualType getCoreType(QualType Ty) {\n  do {\n    if (Ty->isPointerType() || Ty->isReferenceType())\n      Ty = Ty->getPointeeType();\n    else if (Ty->isArrayType())\n      Ty = Ty->castAsArrayTypeUnsafe()->getElementType();\n    else\n      return Ty.withoutLocalFastQualifiers();\n  } while (true);\n}\n\n/// hasSimilarParameters - Determine whether the C++ functions Declaration\n/// and Definition have \"nearly\" matching parameters. This heuristic is\n/// used to improve diagnostics in the case where an out-of-line function\n/// definition doesn't match any declaration within the class or namespace.\n/// Also sets Params to the list of indices to the parameters that differ\n/// between the declaration and the definition. If hasSimilarParameters\n/// returns true and Params is empty, then all of the parameters match.\nstatic bool hasSimilarParameters(ASTContext &Context,\n                                     FunctionDecl *Declaration,\n                                     FunctionDecl *Definition,\n                                     SmallVectorImpl<unsigned> &Params) {\n  Params.clear();\n  if (Declaration->param_size() != Definition->param_size())\n    return false;\n  for (unsigned Idx = 0; Idx < Declaration->param_size(); ++Idx) {\n    QualType DeclParamTy = Declaration->getParamDecl(Idx)->getType();\n    QualType DefParamTy = Definition->getParamDecl(Idx)->getType();\n\n    // The parameter types are identical\n    if (Context.hasSameUnqualifiedType(DefParamTy, DeclParamTy))\n      continue;\n\n    QualType DeclParamBaseTy = getCoreType(DeclParamTy);\n    QualType DefParamBaseTy = getCoreType(DefParamTy);\n    const IdentifierInfo *DeclTyName = DeclParamBaseTy.getBaseTypeIdentifier();\n    const IdentifierInfo *DefTyName = DefParamBaseTy.getBaseTypeIdentifier();\n\n    if (Context.hasSameUnqualifiedType(DeclParamBaseTy, DefParamBaseTy) ||\n        (DeclTyName && DeclTyName == DefTyName))\n      Params.push_back(Idx);\n    else  // The two parameters aren't even close\n      return false;\n  }\n\n  return true;\n}\n\n/// NeedsRebuildingInCurrentInstantiation - Checks whether the given\n/// declarator needs to be rebuilt in the current instantiation.\n/// Any bits of declarator which appear before the name are valid for\n/// consideration here.  That's specifically the type in the decl spec\n/// and the base type in any member-pointer chunks.\nstatic bool RebuildDeclaratorInCurrentInstantiation(Sema &S, Declarator &D,\n                                                    DeclarationName Name) {\n  // The types we specifically need to rebuild are:\n  //   - typenames, typeofs, and decltypes\n  //   - types which will become injected class names\n  // Of course, we also need to rebuild any type referencing such a\n  // type.  It's safest to just say \"dependent\", but we call out a\n  // few cases here.\n\n  DeclSpec &DS = D.getMutableDeclSpec();\n  switch (DS.getTypeSpecType()) {\n  case DeclSpec::TST_typename:\n  case DeclSpec::TST_typeofType:\n  case DeclSpec::TST_underlyingType:\n  case DeclSpec::TST_atomic: {\n    // Grab the type from the parser.\n    TypeSourceInfo *TSI = nullptr;\n    QualType T = S.GetTypeFromParser(DS.getRepAsType(), &TSI);\n    if (T.isNull() || !T->isInstantiationDependentType()) break;\n\n    // Make sure there's a type source info.  This isn't really much\n    // of a waste; most dependent types should have type source info\n    // attached already.\n    if (!TSI)\n      TSI = S.Context.getTrivialTypeSourceInfo(T, DS.getTypeSpecTypeLoc());\n\n    // Rebuild the type in the current instantiation.\n    TSI = S.RebuildTypeInCurrentInstantiation(TSI, D.getIdentifierLoc(), Name);\n    if (!TSI) return true;\n\n    // Store the new type back in the decl spec.\n    ParsedType LocType = S.CreateParsedType(TSI->getType(), TSI);\n    DS.UpdateTypeRep(LocType);\n    break;\n  }\n\n  case DeclSpec::TST_decltype:\n  case DeclSpec::TST_typeofExpr: {\n    Expr *E = DS.getRepAsExpr();\n    ExprResult Result = S.RebuildExprInCurrentInstantiation(E);\n    if (Result.isInvalid()) return true;\n    DS.UpdateExprRep(Result.get());\n    break;\n  }\n\n  default:\n    // Nothing to do for these decl specs.\n    break;\n  }\n\n  // It doesn't matter what order we do this in.\n  for (unsigned I = 0, E = D.getNumTypeObjects(); I != E; ++I) {\n    DeclaratorChunk &Chunk = D.getTypeObject(I);\n\n    // The only type information in the declarator which can come\n    // before the declaration name is the base type of a member\n    // pointer.\n    if (Chunk.Kind != DeclaratorChunk::MemberPointer)\n      continue;\n\n    // Rebuild the scope specifier in-place.\n    CXXScopeSpec &SS = Chunk.Mem.Scope();\n    if (S.RebuildNestedNameSpecifierInCurrentInstantiation(SS))\n      return true;\n  }\n\n  return false;\n}\n\nDecl *Sema::ActOnDeclarator(Scope *S, Declarator &D) {\n  D.setFunctionDefinitionKind(FunctionDefinitionKind::Declaration);\n  Decl *Dcl = HandleDeclarator(S, D, MultiTemplateParamsArg());\n\n  if (OriginalLexicalContext && OriginalLexicalContext->isObjCContainer() &&\n      Dcl && Dcl->getDeclContext()->isFileContext())\n    Dcl->setTopLevelDeclInObjCContainer();\n\n  if (getLangOpts().OpenCL)\n    setCurrentOpenCLExtensionForDecl(Dcl);\n\n  return Dcl;\n}\n\n/// DiagnoseClassNameShadow - Implement C++ [class.mem]p13:\n///   If T is the name of a class, then each of the following shall have a\n///   name different from T:\n///     - every static data member of class T;\n///     - every member function of class T\n///     - every member of class T that is itself a type;\n/// \\returns true if the declaration name violates these rules.\nbool Sema::DiagnoseClassNameShadow(DeclContext *DC,\n                                   DeclarationNameInfo NameInfo) {\n  DeclarationName Name = NameInfo.getName();\n\n  CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(DC);\n  while (Record && Record->isAnonymousStructOrUnion())\n    Record = dyn_cast<CXXRecordDecl>(Record->getParent());\n  if (Record && Record->getIdentifier() && Record->getDeclName() == Name) {\n    Diag(NameInfo.getLoc(), diag::err_member_name_of_class) << Name;\n    return true;\n  }\n\n  return false;\n}\n\n/// Diagnose a declaration whose declarator-id has the given\n/// nested-name-specifier.\n///\n/// \\param SS The nested-name-specifier of the declarator-id.\n///\n/// \\param DC The declaration context to which the nested-name-specifier\n/// resolves.\n///\n/// \\param Name The name of the entity being declared.\n///\n/// \\param Loc The location of the name of the entity being declared.\n///\n/// \\param IsTemplateId Whether the name is a (simple-)template-id, and thus\n/// we're declaring an explicit / partial specialization / instantiation.\n///\n/// \\returns true if we cannot safely recover from this error, false otherwise.\nbool Sema::diagnoseQualifiedDeclaration(CXXScopeSpec &SS, DeclContext *DC,\n                                        DeclarationName Name,\n                                        SourceLocation Loc, bool IsTemplateId) {\n  DeclContext *Cur = CurContext;\n  while (isa<LinkageSpecDecl>(Cur) || isa<CapturedDecl>(Cur))\n    Cur = Cur->getParent();\n\n  // If the user provided a superfluous scope specifier that refers back to the\n  // class in which the entity is already declared, diagnose and ignore it.\n  //\n  // class X {\n  //   void X::f();\n  // };\n  //\n  // Note, it was once ill-formed to give redundant qualification in all\n  // contexts, but that rule was removed by DR482.\n  if (Cur->Equals(DC)) {\n    if (Cur->isRecord()) {\n      Diag(Loc, LangOpts.MicrosoftExt ? diag::warn_member_extra_qualification\n                                      : diag::err_member_extra_qualification)\n        << Name << FixItHint::CreateRemoval(SS.getRange());\n      SS.clear();\n    } else {\n      Diag(Loc, diag::warn_namespace_member_extra_qualification) << Name;\n    }\n    return false;\n  }\n\n  // Check whether the qualifying scope encloses the scope of the original\n  // declaration. For a template-id, we perform the checks in\n  // CheckTemplateSpecializationScope.\n  if (!Cur->Encloses(DC) && !IsTemplateId) {\n    if (Cur->isRecord())\n      Diag(Loc, diag::err_member_qualification)\n        << Name << SS.getRange();\n    else if (isa<TranslationUnitDecl>(DC))\n      Diag(Loc, diag::err_invalid_declarator_global_scope)\n        << Name << SS.getRange();\n    else if (isa<FunctionDecl>(Cur))\n      Diag(Loc, diag::err_invalid_declarator_in_function)\n        << Name << SS.getRange();\n    else if (isa<BlockDecl>(Cur))\n      Diag(Loc, diag::err_invalid_declarator_in_block)\n        << Name << SS.getRange();\n    else\n      Diag(Loc, diag::err_invalid_declarator_scope)\n      << Name << cast<NamedDecl>(Cur) << cast<NamedDecl>(DC) << SS.getRange();\n\n    return true;\n  }\n\n  if (Cur->isRecord()) {\n    // Cannot qualify members within a class.\n    Diag(Loc, diag::err_member_qualification)\n      << Name << SS.getRange();\n    SS.clear();\n\n    // C++ constructors and destructors with incorrect scopes can break\n    // our AST invariants by having the wrong underlying types. If\n    // that's the case, then drop this declaration entirely.\n    if ((Name.getNameKind() == DeclarationName::CXXConstructorName ||\n         Name.getNameKind() == DeclarationName::CXXDestructorName) &&\n        !Context.hasSameType(Name.getCXXNameType(),\n                             Context.getTypeDeclType(cast<CXXRecordDecl>(Cur))))\n      return true;\n\n    return false;\n  }\n\n  // C++11 [dcl.meaning]p1:\n  //   [...] \"The nested-name-specifier of the qualified declarator-id shall\n  //   not begin with a decltype-specifer\"\n  NestedNameSpecifierLoc SpecLoc(SS.getScopeRep(), SS.location_data());\n  while (SpecLoc.getPrefix())\n    SpecLoc = SpecLoc.getPrefix();\n  if (dyn_cast_or_null<DecltypeType>(\n        SpecLoc.getNestedNameSpecifier()->getAsType()))\n    Diag(Loc, diag::err_decltype_in_declarator)\n      << SpecLoc.getTypeLoc().getSourceRange();\n\n  return false;\n}\n\nNamedDecl *Sema::HandleDeclarator(Scope *S, Declarator &D,\n                                  MultiTemplateParamsArg TemplateParamLists) {\n  // TODO: consider using NameInfo for diagnostic.\n  DeclarationNameInfo NameInfo = GetNameForDeclarator(D);\n  DeclarationName Name = NameInfo.getName();\n\n  // All of these full declarators require an identifier.  If it doesn't have\n  // one, the ParsedFreeStandingDeclSpec action should be used.\n  if (D.isDecompositionDeclarator()) {\n    return ActOnDecompositionDeclarator(S, D, TemplateParamLists);\n  } else if (!Name) {\n    if (!D.isInvalidType())  // Reject this if we think it is valid.\n      Diag(D.getDeclSpec().getBeginLoc(), diag::err_declarator_need_ident)\n          << D.getDeclSpec().getSourceRange() << D.getSourceRange();\n    return nullptr;\n  } else if (DiagnoseUnexpandedParameterPack(NameInfo, UPPC_DeclarationType))\n    return nullptr;\n\n  // The scope passed in may not be a decl scope.  Zip up the scope tree until\n  // we find one that is.\n  while ((S->getFlags() & Scope::DeclScope) == 0 ||\n         (S->getFlags() & Scope::TemplateParamScope) != 0)\n    S = S->getParent();\n\n  DeclContext *DC = CurContext;\n  if (D.getCXXScopeSpec().isInvalid())\n    D.setInvalidType();\n  else if (D.getCXXScopeSpec().isSet()) {\n    if (DiagnoseUnexpandedParameterPack(D.getCXXScopeSpec(),\n                                        UPPC_DeclarationQualifier))\n      return nullptr;\n\n    bool EnteringContext = !D.getDeclSpec().isFriendSpecified();\n    DC = computeDeclContext(D.getCXXScopeSpec(), EnteringContext);\n    if (!DC || isa<EnumDecl>(DC)) {\n      // If we could not compute the declaration context, it's because the\n      // declaration context is dependent but does not refer to a class,\n      // class template, or class template partial specialization. Complain\n      // and return early, to avoid the coming semantic disaster.\n      Diag(D.getIdentifierLoc(),\n           diag::err_template_qualified_declarator_no_match)\n        << D.getCXXScopeSpec().getScopeRep()\n        << D.getCXXScopeSpec().getRange();\n      return nullptr;\n    }\n    bool IsDependentContext = DC->isDependentContext();\n\n    if (!IsDependentContext &&\n        RequireCompleteDeclContext(D.getCXXScopeSpec(), DC))\n      return nullptr;\n\n    // If a class is incomplete, do not parse entities inside it.\n    if (isa<CXXRecordDecl>(DC) && !cast<CXXRecordDecl>(DC)->hasDefinition()) {\n      Diag(D.getIdentifierLoc(),\n           diag::err_member_def_undefined_record)\n        << Name << DC << D.getCXXScopeSpec().getRange();\n      return nullptr;\n    }\n    if (!D.getDeclSpec().isFriendSpecified()) {\n      if (diagnoseQualifiedDeclaration(\n              D.getCXXScopeSpec(), DC, Name, D.getIdentifierLoc(),\n              D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId)) {\n        if (DC->isRecord())\n          return nullptr;\n\n        D.setInvalidType();\n      }\n    }\n\n    // Check whether we need to rebuild the type of the given\n    // declaration in the current instantiation.\n    if (EnteringContext && IsDependentContext &&\n        TemplateParamLists.size() != 0) {\n      ContextRAII SavedContext(*this, DC);\n      if (RebuildDeclaratorInCurrentInstantiation(*this, D, Name))\n        D.setInvalidType();\n    }\n  }\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType R = TInfo->getType();\n\n  if (DiagnoseUnexpandedParameterPack(D.getIdentifierLoc(), TInfo,\n                                      UPPC_DeclarationType))\n    D.setInvalidType();\n\n  LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                        forRedeclarationInCurContext());\n\n  // See if this is a redefinition of a variable in the same scope.\n  if (!D.getCXXScopeSpec().isSet()) {\n    bool IsLinkageLookup = false;\n    bool CreateBuiltins = false;\n\n    // If the declaration we're planning to build will be a function\n    // or object with linkage, then look for another declaration with\n    // linkage (C99 6.2.2p4-5 and C++ [basic.link]p6).\n    //\n    // If the declaration we're planning to build will be declared with\n    // external linkage in the translation unit, create any builtin with\n    // the same name.\n    if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      /* Do nothing*/;\n    else if (CurContext->isFunctionOrMethod() &&\n             (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_extern ||\n              R->isFunctionType())) {\n      IsLinkageLookup = true;\n      CreateBuiltins =\n          CurContext->getEnclosingNamespaceContext()->isTranslationUnit();\n    } else if (CurContext->getRedeclContext()->isTranslationUnit() &&\n               D.getDeclSpec().getStorageClassSpec() != DeclSpec::SCS_static)\n      CreateBuiltins = true;\n\n    if (IsLinkageLookup) {\n      Previous.clear(LookupRedeclarationWithLinkage);\n      Previous.setRedeclarationKind(ForExternalRedeclaration);\n    }\n\n    LookupName(Previous, S, CreateBuiltins);\n  } else { // Something like \"int foo::x;\"\n    LookupQualifiedName(Previous, DC);\n\n    // C++ [dcl.meaning]p1:\n    //   When the declarator-id is qualified, the declaration shall refer to a\n    //  previously declared member of the class or namespace to which the\n    //  qualifier refers (or, in the case of a namespace, of an element of the\n    //  inline namespace set of that namespace (7.3.1)) or to a specialization\n    //  thereof; [...]\n    //\n    // Note that we already checked the context above, and that we do not have\n    // enough information to make sure that Previous contains the declaration\n    // we want to match. For example, given:\n    //\n    //   class X {\n    //     void f();\n    //     void f(float);\n    //   };\n    //\n    //   void X::f(int) { } // ill-formed\n    //\n    // In this case, Previous will point to the overload set\n    // containing the two f's declared in X, but neither of them\n    // matches.\n\n    // C++ [dcl.meaning]p1:\n    //   [...] the member shall not merely have been introduced by a\n    //   using-declaration in the scope of the class or namespace nominated by\n    //   the nested-name-specifier of the declarator-id.\n    RemoveUsingDecls(Previous);\n  }\n\n  if (Previous.isSingleResult() &&\n      Previous.getFoundDecl()->isTemplateParameter()) {\n    // Maybe we will complain about the shadowed template parameter.\n    if (!D.isInvalidType())\n      DiagnoseTemplateParameterShadow(D.getIdentifierLoc(),\n                                      Previous.getFoundDecl());\n\n    // Just pretend that we didn't see the previous declaration.\n    Previous.clear();\n  }\n\n  if (!R->isFunctionType() && DiagnoseClassNameShadow(DC, NameInfo))\n    // Forget that the previous declaration is the injected-class-name.\n    Previous.clear();\n\n  // In C++, the previous declaration we find might be a tag type\n  // (class or enum). In this case, the new declaration will hide the\n  // tag type. Note that this applies to functions, function templates, and\n  // variables, but not to typedefs (C++ [dcl.typedef]p4) or variable templates.\n  if (Previous.isSingleTagDecl() &&\n      D.getDeclSpec().getStorageClassSpec() != DeclSpec::SCS_typedef &&\n      (TemplateParamLists.size() == 0 || R->isFunctionType()))\n    Previous.clear();\n\n  // Check that there are no default arguments other than in the parameters\n  // of a function declaration (C++ only).\n  if (getLangOpts().CPlusPlus)\n    CheckExtraCXXDefaultArguments(D);\n\n  NamedDecl *New;\n\n  bool AddToScope = true;\n  if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef) {\n    if (TemplateParamLists.size()) {\n      Diag(D.getIdentifierLoc(), diag::err_template_typedef);\n      return nullptr;\n    }\n\n    New = ActOnTypedefDeclarator(S, D, DC, TInfo, Previous);\n  } else if (R->isFunctionType()) {\n    New = ActOnFunctionDeclarator(S, D, DC, TInfo, Previous,\n                                  TemplateParamLists,\n                                  AddToScope);\n  } else {\n    New = ActOnVariableDeclarator(S, D, DC, TInfo, Previous, TemplateParamLists,\n                                  AddToScope);\n  }\n\n  if (!New)\n    return nullptr;\n\n  // If this has an identifier and is not a function template specialization,\n  // add it to the scope stack.\n  if (New->getDeclName() && AddToScope)\n    PushOnScopeChains(New, S);\n\n  if (isInOpenMPDeclareTargetContext())\n    checkDeclIsAllowedInOpenMPTarget(nullptr, New);\n\n  return New;\n}\n\n/// Helper method to turn variable array types into constant array\n/// types in certain situations which would otherwise be errors (for\n/// GCC compatibility).\nstatic QualType TryToFixInvalidVariablyModifiedType(QualType T,\n                                                    ASTContext &Context,\n                                                    bool &SizeIsNegative,\n                                                    llvm::APSInt &Oversized) {\n  // This method tries to turn a variable array into a constant\n  // array even when the size isn't an ICE.  This is necessary\n  // for compatibility with code that depends on gcc's buggy\n  // constant expression folding, like struct {char x[(int)(char*)2];}\n  SizeIsNegative = false;\n  Oversized = 0;\n\n  if (T->isDependentType())\n    return QualType();\n\n  QualifierCollector Qs;\n  const Type *Ty = Qs.strip(T);\n\n  if (const PointerType* PTy = dyn_cast<PointerType>(Ty)) {\n    QualType Pointee = PTy->getPointeeType();\n    QualType FixedType =\n        TryToFixInvalidVariablyModifiedType(Pointee, Context, SizeIsNegative,\n                                            Oversized);\n    if (FixedType.isNull()) return FixedType;\n    FixedType = Context.getPointerType(FixedType);\n    return Qs.apply(Context, FixedType);\n  }\n  if (const ParenType* PTy = dyn_cast<ParenType>(Ty)) {\n    QualType Inner = PTy->getInnerType();\n    QualType FixedType =\n        TryToFixInvalidVariablyModifiedType(Inner, Context, SizeIsNegative,\n                                            Oversized);\n    if (FixedType.isNull()) return FixedType;\n    FixedType = Context.getParenType(FixedType);\n    return Qs.apply(Context, FixedType);\n  }\n\n  const VariableArrayType* VLATy = dyn_cast<VariableArrayType>(T);\n  if (!VLATy)\n    return QualType();\n\n  QualType ElemTy = VLATy->getElementType();\n  if (ElemTy->isVariablyModifiedType()) {\n    ElemTy = TryToFixInvalidVariablyModifiedType(ElemTy, Context,\n                                                 SizeIsNegative, Oversized);\n    if (ElemTy.isNull())\n      return QualType();\n  }\n\n  Expr::EvalResult Result;\n  if (!VLATy->getSizeExpr() ||\n      !VLATy->getSizeExpr()->EvaluateAsInt(Result, Context))\n    return QualType();\n\n  llvm::APSInt Res = Result.Val.getInt();\n\n  // Check whether the array size is negative.\n  if (Res.isSigned() && Res.isNegative()) {\n    SizeIsNegative = true;\n    return QualType();\n  }\n\n  // Check whether the array is too large to be addressed.\n  unsigned ActiveSizeBits =\n      (!ElemTy->isDependentType() && !ElemTy->isVariablyModifiedType() &&\n       !ElemTy->isIncompleteType() && !ElemTy->isUndeducedType())\n          ? ConstantArrayType::getNumAddressingBits(Context, ElemTy, Res)\n          : Res.getActiveBits();\n  if (ActiveSizeBits > ConstantArrayType::getMaxSizeBits(Context)) {\n    Oversized = Res;\n    return QualType();\n  }\n\n  QualType FoldedArrayType = Context.getConstantArrayType(\n      ElemTy, Res, VLATy->getSizeExpr(), ArrayType::Normal, 0);\n  return Qs.apply(Context, FoldedArrayType);\n}\n\nstatic void\nFixInvalidVariablyModifiedTypeLoc(TypeLoc SrcTL, TypeLoc DstTL) {\n  SrcTL = SrcTL.getUnqualifiedLoc();\n  DstTL = DstTL.getUnqualifiedLoc();\n  if (PointerTypeLoc SrcPTL = SrcTL.getAs<PointerTypeLoc>()) {\n    PointerTypeLoc DstPTL = DstTL.castAs<PointerTypeLoc>();\n    FixInvalidVariablyModifiedTypeLoc(SrcPTL.getPointeeLoc(),\n                                      DstPTL.getPointeeLoc());\n    DstPTL.setStarLoc(SrcPTL.getStarLoc());\n    return;\n  }\n  if (ParenTypeLoc SrcPTL = SrcTL.getAs<ParenTypeLoc>()) {\n    ParenTypeLoc DstPTL = DstTL.castAs<ParenTypeLoc>();\n    FixInvalidVariablyModifiedTypeLoc(SrcPTL.getInnerLoc(),\n                                      DstPTL.getInnerLoc());\n    DstPTL.setLParenLoc(SrcPTL.getLParenLoc());\n    DstPTL.setRParenLoc(SrcPTL.getRParenLoc());\n    return;\n  }\n  ArrayTypeLoc SrcATL = SrcTL.castAs<ArrayTypeLoc>();\n  ArrayTypeLoc DstATL = DstTL.castAs<ArrayTypeLoc>();\n  TypeLoc SrcElemTL = SrcATL.getElementLoc();\n  TypeLoc DstElemTL = DstATL.getElementLoc();\n  if (VariableArrayTypeLoc SrcElemATL =\n          SrcElemTL.getAs<VariableArrayTypeLoc>()) {\n    ConstantArrayTypeLoc DstElemATL = DstElemTL.castAs<ConstantArrayTypeLoc>();\n    FixInvalidVariablyModifiedTypeLoc(SrcElemATL, DstElemATL);\n  } else {\n    DstElemTL.initializeFullCopy(SrcElemTL);\n  }\n  DstATL.setLBracketLoc(SrcATL.getLBracketLoc());\n  DstATL.setSizeExpr(SrcATL.getSizeExpr());\n  DstATL.setRBracketLoc(SrcATL.getRBracketLoc());\n}\n\n/// Helper method to turn variable array types into constant array\n/// types in certain situations which would otherwise be errors (for\n/// GCC compatibility).\nstatic TypeSourceInfo*\nTryToFixInvalidVariablyModifiedTypeSourceInfo(TypeSourceInfo *TInfo,\n                                              ASTContext &Context,\n                                              bool &SizeIsNegative,\n                                              llvm::APSInt &Oversized) {\n  QualType FixedTy\n    = TryToFixInvalidVariablyModifiedType(TInfo->getType(), Context,\n                                          SizeIsNegative, Oversized);\n  if (FixedTy.isNull())\n    return nullptr;\n  TypeSourceInfo *FixedTInfo = Context.getTrivialTypeSourceInfo(FixedTy);\n  FixInvalidVariablyModifiedTypeLoc(TInfo->getTypeLoc(),\n                                    FixedTInfo->getTypeLoc());\n  return FixedTInfo;\n}\n\n/// Attempt to fold a variable-sized type to a constant-sized type, returning\n/// true if we were successful.\nstatic bool tryToFixVariablyModifiedVarType(Sema &S, TypeSourceInfo *&TInfo,\n                                            QualType &T, SourceLocation Loc,\n                                            unsigned FailedFoldDiagID) {\n  bool SizeIsNegative;\n  llvm::APSInt Oversized;\n  TypeSourceInfo *FixedTInfo = TryToFixInvalidVariablyModifiedTypeSourceInfo(\n      TInfo, S.Context, SizeIsNegative, Oversized);\n  if (FixedTInfo) {\n    S.Diag(Loc, diag::ext_vla_folded_to_constant);\n    TInfo = FixedTInfo;\n    T = FixedTInfo->getType();\n    return true;\n  }\n\n  if (SizeIsNegative)\n    S.Diag(Loc, diag::err_typecheck_negative_array_size);\n  else if (Oversized.getBoolValue())\n    S.Diag(Loc, diag::err_array_too_large) << Oversized.toString(10);\n  else if (FailedFoldDiagID)\n    S.Diag(Loc, FailedFoldDiagID);\n  return false;\n}\n\n/// Register the given locally-scoped extern \"C\" declaration so\n/// that it can be found later for redeclarations. We include any extern \"C\"\n/// declaration that is not visible in the translation unit here, not just\n/// function-scope declarations.\nvoid\nSema::RegisterLocallyScopedExternCDecl(NamedDecl *ND, Scope *S) {\n  if (!getLangOpts().CPlusPlus &&\n      ND->getLexicalDeclContext()->getRedeclContext()->isTranslationUnit())\n    // Don't need to track declarations in the TU in C.\n    return;\n\n  // Note that we have a locally-scoped external with this name.\n  Context.getExternCContextDecl()->makeDeclVisibleInContext(ND);\n}\n\nNamedDecl *Sema::findLocallyScopedExternCDecl(DeclarationName Name) {\n  // FIXME: We can have multiple results via __attribute__((overloadable)).\n  auto Result = Context.getExternCContextDecl()->lookup(Name);\n  return Result.empty() ? nullptr : *Result.begin();\n}\n\n/// Diagnose function specifiers on a declaration of an identifier that\n/// does not identify a function.\nvoid Sema::DiagnoseFunctionSpecifiers(const DeclSpec &DS) {\n  // FIXME: We should probably indicate the identifier in question to avoid\n  // confusion for constructs like \"virtual int a(), b;\"\n  if (DS.isVirtualSpecified())\n    Diag(DS.getVirtualSpecLoc(),\n         diag::err_virtual_non_function);\n\n  if (DS.hasExplicitSpecifier())\n    Diag(DS.getExplicitSpecLoc(),\n         diag::err_explicit_non_function);\n\n  if (DS.isNoreturnSpecified())\n    Diag(DS.getNoreturnSpecLoc(),\n         diag::err_noreturn_non_function);\n}\n\nNamedDecl*\nSema::ActOnTypedefDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                             TypeSourceInfo *TInfo, LookupResult &Previous) {\n  // Typedef declarators cannot be qualified (C++ [dcl.meaning]p1).\n  if (D.getCXXScopeSpec().isSet()) {\n    Diag(D.getIdentifierLoc(), diag::err_qualified_typedef_declarator)\n      << D.getCXXScopeSpec().getRange();\n    D.setInvalidType();\n    // Pretend we didn't see the scope specifier.\n    DC = CurContext;\n    Previous.clear();\n  }\n\n  DiagnoseFunctionSpecifiers(D.getDeclSpec());\n\n  if (D.getDeclSpec().isInlineSpecified())\n    Diag(D.getDeclSpec().getInlineSpecLoc(), diag::err_inline_non_function)\n        << getLangOpts().CPlusPlus17;\n  if (D.getDeclSpec().hasConstexprSpecifier())\n    Diag(D.getDeclSpec().getConstexprSpecLoc(), diag::err_invalid_constexpr)\n        << 1 << static_cast<int>(D.getDeclSpec().getConstexprSpecifier());\n\n  if (D.getName().Kind != UnqualifiedIdKind::IK_Identifier) {\n    if (D.getName().Kind == UnqualifiedIdKind::IK_DeductionGuideName)\n      Diag(D.getName().StartLocation,\n           diag::err_deduction_guide_invalid_specifier)\n          << \"typedef\";\n    else\n      Diag(D.getName().StartLocation, diag::err_typedef_not_identifier)\n          << D.getName().getSourceRange();\n    return nullptr;\n  }\n\n  TypedefDecl *NewTD = ParseTypedefDecl(S, D, TInfo->getType(), TInfo);\n  if (!NewTD) return nullptr;\n\n  // Handle attributes prior to checking for duplicates in MergeVarDecl\n  ProcessDeclAttributes(S, NewTD, D);\n\n  CheckTypedefForVariablyModifiedType(S, NewTD);\n\n  bool Redeclaration = D.isRedeclaration();\n  NamedDecl *ND = ActOnTypedefNameDecl(S, DC, NewTD, Previous, Redeclaration);\n  D.setRedeclaration(Redeclaration);\n  return ND;\n}\n\nvoid\nSema::CheckTypedefForVariablyModifiedType(Scope *S, TypedefNameDecl *NewTD) {\n  // C99 6.7.7p2: If a typedef name specifies a variably modified type\n  // then it shall have block scope.\n  // Note that variably modified types must be fixed before merging the decl so\n  // that redeclarations will match.\n  TypeSourceInfo *TInfo = NewTD->getTypeSourceInfo();\n  QualType T = TInfo->getType();\n  if (T->isVariablyModifiedType()) {\n    setFunctionHasBranchProtectedScope();\n\n    if (S->getFnParent() == nullptr) {\n      bool SizeIsNegative;\n      llvm::APSInt Oversized;\n      TypeSourceInfo *FixedTInfo =\n        TryToFixInvalidVariablyModifiedTypeSourceInfo(TInfo, Context,\n                                                      SizeIsNegative,\n                                                      Oversized);\n      if (FixedTInfo) {\n        Diag(NewTD->getLocation(), diag::ext_vla_folded_to_constant);\n        NewTD->setTypeSourceInfo(FixedTInfo);\n      } else {\n        if (SizeIsNegative)\n          Diag(NewTD->getLocation(), diag::err_typecheck_negative_array_size);\n        else if (T->isVariableArrayType())\n          Diag(NewTD->getLocation(), diag::err_vla_decl_in_file_scope);\n        else if (Oversized.getBoolValue())\n          Diag(NewTD->getLocation(), diag::err_array_too_large)\n            << Oversized.toString(10);\n        else\n          Diag(NewTD->getLocation(), diag::err_vm_decl_in_file_scope);\n        NewTD->setInvalidDecl();\n      }\n    }\n  }\n}\n\n/// ActOnTypedefNameDecl - Perform semantic checking for a declaration which\n/// declares a typedef-name, either using the 'typedef' type specifier or via\n/// a C++0x [dcl.typedef]p2 alias-declaration: 'using T = A;'.\nNamedDecl*\nSema::ActOnTypedefNameDecl(Scope *S, DeclContext *DC, TypedefNameDecl *NewTD,\n                           LookupResult &Previous, bool &Redeclaration) {\n\n  // Find the shadowed declaration before filtering for scope.\n  NamedDecl *ShadowedDecl = getShadowedDeclaration(NewTD, Previous);\n\n  // Merge the decl with the existing one if appropriate. If the decl is\n  // in an outer scope, it isn't the same thing.\n  FilterLookupForScope(Previous, DC, S, /*ConsiderLinkage*/false,\n                       /*AllowInlineNamespace*/false);\n  filterNonConflictingPreviousTypedefDecls(*this, NewTD, Previous);\n  if (!Previous.empty()) {\n    Redeclaration = true;\n    MergeTypedefNameDecl(S, NewTD, Previous);\n  } else {\n    inferGslPointerAttribute(NewTD);\n  }\n\n  if (ShadowedDecl && !Redeclaration)\n    CheckShadow(NewTD, ShadowedDecl, Previous);\n\n  // If this is the C FILE type, notify the AST context.\n  if (IdentifierInfo *II = NewTD->getIdentifier())\n    if (!NewTD->isInvalidDecl() &&\n        NewTD->getDeclContext()->getRedeclContext()->isTranslationUnit()) {\n      if (II->isStr(\"FILE\"))\n        Context.setFILEDecl(NewTD);\n      else if (II->isStr(\"jmp_buf\"))\n        Context.setjmp_bufDecl(NewTD);\n      else if (II->isStr(\"sigjmp_buf\"))\n        Context.setsigjmp_bufDecl(NewTD);\n      else if (II->isStr(\"ucontext_t\"))\n        Context.setucontext_tDecl(NewTD);\n    }\n\n  return NewTD;\n}\n\n/// Determines whether the given declaration is an out-of-scope\n/// previous declaration.\n///\n/// This routine should be invoked when name lookup has found a\n/// previous declaration (PrevDecl) that is not in the scope where a\n/// new declaration by the same name is being introduced. If the new\n/// declaration occurs in a local scope, previous declarations with\n/// linkage may still be considered previous declarations (C99\n/// 6.2.2p4-5, C++ [basic.link]p6).\n///\n/// \\param PrevDecl the previous declaration found by name\n/// lookup\n///\n/// \\param DC the context in which the new declaration is being\n/// declared.\n///\n/// \\returns true if PrevDecl is an out-of-scope previous declaration\n/// for a new delcaration with the same name.\nstatic bool\nisOutOfScopePreviousDeclaration(NamedDecl *PrevDecl, DeclContext *DC,\n                                ASTContext &Context) {\n  if (!PrevDecl)\n    return false;\n\n  if (!PrevDecl->hasLinkage())\n    return false;\n\n  if (Context.getLangOpts().CPlusPlus) {\n    // C++ [basic.link]p6:\n    //   If there is a visible declaration of an entity with linkage\n    //   having the same name and type, ignoring entities declared\n    //   outside the innermost enclosing namespace scope, the block\n    //   scope declaration declares that same entity and receives the\n    //   linkage of the previous declaration.\n    DeclContext *OuterContext = DC->getRedeclContext();\n    if (!OuterContext->isFunctionOrMethod())\n      // This rule only applies to block-scope declarations.\n      return false;\n\n    DeclContext *PrevOuterContext = PrevDecl->getDeclContext();\n    if (PrevOuterContext->isRecord())\n      // We found a member function: ignore it.\n      return false;\n\n    // Find the innermost enclosing namespace for the new and\n    // previous declarations.\n    OuterContext = OuterContext->getEnclosingNamespaceContext();\n    PrevOuterContext = PrevOuterContext->getEnclosingNamespaceContext();\n\n    // The previous declaration is in a different namespace, so it\n    // isn't the same function.\n    if (!OuterContext->Equals(PrevOuterContext))\n      return false;\n  }\n\n  return true;\n}\n\nstatic void SetNestedNameSpecifier(Sema &S, DeclaratorDecl *DD, Declarator &D) {\n  CXXScopeSpec &SS = D.getCXXScopeSpec();\n  if (!SS.isSet()) return;\n  DD->setQualifierInfo(SS.getWithLocInContext(S.Context));\n}\n\nbool Sema::inferObjCARCLifetime(ValueDecl *decl) {\n  QualType type = decl->getType();\n  Qualifiers::ObjCLifetime lifetime = type.getObjCLifetime();\n  if (lifetime == Qualifiers::OCL_Autoreleasing) {\n    // Various kinds of declaration aren't allowed to be __autoreleasing.\n    unsigned kind = -1U;\n    if (VarDecl *var = dyn_cast<VarDecl>(decl)) {\n      if (var->hasAttr<BlocksAttr>())\n        kind = 0; // __block\n      else if (!var->hasLocalStorage())\n        kind = 1; // global\n    } else if (isa<ObjCIvarDecl>(decl)) {\n      kind = 3; // ivar\n    } else if (isa<FieldDecl>(decl)) {\n      kind = 2; // field\n    }\n\n    if (kind != -1U) {\n      Diag(decl->getLocation(), diag::err_arc_autoreleasing_var)\n        << kind;\n    }\n  } else if (lifetime == Qualifiers::OCL_None) {\n    // Try to infer lifetime.\n    if (!type->isObjCLifetimeType())\n      return false;\n\n    lifetime = type->getObjCARCImplicitLifetime();\n    type = Context.getLifetimeQualifiedType(type, lifetime);\n    decl->setType(type);\n  }\n\n  if (VarDecl *var = dyn_cast<VarDecl>(decl)) {\n    // Thread-local variables cannot have lifetime.\n    if (lifetime && lifetime != Qualifiers::OCL_ExplicitNone &&\n        var->getTLSKind()) {\n      Diag(var->getLocation(), diag::err_arc_thread_ownership)\n        << var->getType();\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvoid Sema::deduceOpenCLAddressSpace(ValueDecl *Decl) {\n  if (Decl->getType().hasAddressSpace())\n    return;\n  if (Decl->getType()->isDependentType())\n    return;\n  if (VarDecl *Var = dyn_cast<VarDecl>(Decl)) {\n    QualType Type = Var->getType();\n    if (Type->isSamplerT() || Type->isVoidType())\n      return;\n    LangAS ImplAS = LangAS::opencl_private;\n    if ((getLangOpts().OpenCLCPlusPlus || getLangOpts().OpenCLVersion >= 200) &&\n        Var->hasGlobalStorage())\n      ImplAS = LangAS::opencl_global;\n    // If the original type from a decayed type is an array type and that array\n    // type has no address space yet, deduce it now.\n    if (auto DT = dyn_cast<DecayedType>(Type)) {\n      auto OrigTy = DT->getOriginalType();\n      if (!OrigTy.hasAddressSpace() && OrigTy->isArrayType()) {\n        // Add the address space to the original array type and then propagate\n        // that to the element type through `getAsArrayType`.\n        OrigTy = Context.getAddrSpaceQualType(OrigTy, ImplAS);\n        OrigTy = QualType(Context.getAsArrayType(OrigTy), 0);\n        // Re-generate the decayed type.\n        Type = Context.getDecayedType(OrigTy);\n      }\n    }\n    Type = Context.getAddrSpaceQualType(Type, ImplAS);\n    // Apply any qualifiers (including address space) from the array type to\n    // the element type. This implements C99 6.7.3p8: \"If the specification of\n    // an array type includes any type qualifiers, the element type is so\n    // qualified, not the array type.\"\n    if (Type->isArrayType())\n      Type = QualType(Context.getAsArrayType(Type), 0);\n    Decl->setType(Type);\n  }\n}\n\nstatic void checkAttributesAfterMerging(Sema &S, NamedDecl &ND) {\n  // Ensure that an auto decl is deduced otherwise the checks below might cache\n  // the wrong linkage.\n  assert(S.ParsingInitForAutoVars.count(&ND) == 0);\n\n  // 'weak' only applies to declarations with external linkage.\n  if (WeakAttr *Attr = ND.getAttr<WeakAttr>()) {\n    if (!ND.isExternallyVisible()) {\n      S.Diag(Attr->getLocation(), diag::err_attribute_weak_static);\n      ND.dropAttr<WeakAttr>();\n    }\n  }\n  if (WeakRefAttr *Attr = ND.getAttr<WeakRefAttr>()) {\n    if (ND.isExternallyVisible()) {\n      S.Diag(Attr->getLocation(), diag::err_attribute_weakref_not_static);\n      ND.dropAttr<WeakRefAttr>();\n      ND.dropAttr<AliasAttr>();\n    }\n  }\n\n  if (auto *VD = dyn_cast<VarDecl>(&ND)) {\n    if (VD->hasInit()) {\n      if (const auto *Attr = VD->getAttr<AliasAttr>()) {\n        assert(VD->isThisDeclarationADefinition() &&\n               !VD->isExternallyVisible() && \"Broken AliasAttr handled late!\");\n        S.Diag(Attr->getLocation(), diag::err_alias_is_definition) << VD << 0;\n        VD->dropAttr<AliasAttr>();\n      }\n    }\n  }\n\n  // 'selectany' only applies to externally visible variable declarations.\n  // It does not apply to functions.\n  if (SelectAnyAttr *Attr = ND.getAttr<SelectAnyAttr>()) {\n    if (isa<FunctionDecl>(ND) || !ND.isExternallyVisible()) {\n      S.Diag(Attr->getLocation(),\n             diag::err_attribute_selectany_non_extern_data);\n      ND.dropAttr<SelectAnyAttr>();\n    }\n  }\n\n  if (const InheritableAttr *Attr = getDLLAttr(&ND)) {\n    auto *VD = dyn_cast<VarDecl>(&ND);\n    bool IsAnonymousNS = false;\n    bool IsMicrosoft = S.Context.getTargetInfo().getCXXABI().isMicrosoft();\n    if (VD) {\n      const NamespaceDecl *NS = dyn_cast<NamespaceDecl>(VD->getDeclContext());\n      while (NS && !IsAnonymousNS) {\n        IsAnonymousNS = NS->isAnonymousNamespace();\n        NS = dyn_cast<NamespaceDecl>(NS->getParent());\n      }\n    }\n    // dll attributes require external linkage. Static locals may have external\n    // linkage but still cannot be explicitly imported or exported.\n    // In Microsoft mode, a variable defined in anonymous namespace must have\n    // external linkage in order to be exported.\n    bool AnonNSInMicrosoftMode = IsAnonymousNS && IsMicrosoft;\n    if ((ND.isExternallyVisible() && AnonNSInMicrosoftMode) ||\n        (!AnonNSInMicrosoftMode &&\n         (!ND.isExternallyVisible() || (VD && VD->isStaticLocal())))) {\n      S.Diag(ND.getLocation(), diag::err_attribute_dll_not_extern)\n        << &ND << Attr;\n      ND.setInvalidDecl();\n    }\n  }\n\n  // Check the attributes on the function type, if any.\n  if (const auto *FD = dyn_cast<FunctionDecl>(&ND)) {\n    // Don't declare this variable in the second operand of the for-statement;\n    // GCC miscompiles that by ending its lifetime before evaluating the\n    // third operand. See gcc.gnu.org/PR86769.\n    AttributedTypeLoc ATL;\n    for (TypeLoc TL = FD->getTypeSourceInfo()->getTypeLoc();\n         (ATL = TL.getAsAdjusted<AttributedTypeLoc>());\n         TL = ATL.getModifiedLoc()) {\n      // The [[lifetimebound]] attribute can be applied to the implicit object\n      // parameter of a non-static member function (other than a ctor or dtor)\n      // by applying it to the function type.\n      if (const auto *A = ATL.getAttrAs<LifetimeBoundAttr>()) {\n        const auto *MD = dyn_cast<CXXMethodDecl>(FD);\n        if (!MD || MD->isStatic()) {\n          S.Diag(A->getLocation(), diag::err_lifetimebound_no_object_param)\n              << !MD << A->getRange();\n        } else if (isa<CXXConstructorDecl>(MD) || isa<CXXDestructorDecl>(MD)) {\n          S.Diag(A->getLocation(), diag::err_lifetimebound_ctor_dtor)\n              << isa<CXXDestructorDecl>(MD) << A->getRange();\n        }\n      }\n    }\n  }\n}\n\nstatic void checkDLLAttributeRedeclaration(Sema &S, NamedDecl *OldDecl,\n                                           NamedDecl *NewDecl,\n                                           bool IsSpecialization,\n                                           bool IsDefinition) {\n  if (OldDecl->isInvalidDecl() || NewDecl->isInvalidDecl())\n    return;\n\n  bool IsTemplate = false;\n  if (TemplateDecl *OldTD = dyn_cast<TemplateDecl>(OldDecl)) {\n    OldDecl = OldTD->getTemplatedDecl();\n    IsTemplate = true;\n    if (!IsSpecialization)\n      IsDefinition = false;\n  }\n  if (TemplateDecl *NewTD = dyn_cast<TemplateDecl>(NewDecl)) {\n    NewDecl = NewTD->getTemplatedDecl();\n    IsTemplate = true;\n  }\n\n  if (!OldDecl || !NewDecl)\n    return;\n\n  const DLLImportAttr *OldImportAttr = OldDecl->getAttr<DLLImportAttr>();\n  const DLLExportAttr *OldExportAttr = OldDecl->getAttr<DLLExportAttr>();\n  const DLLImportAttr *NewImportAttr = NewDecl->getAttr<DLLImportAttr>();\n  const DLLExportAttr *NewExportAttr = NewDecl->getAttr<DLLExportAttr>();\n\n  // dllimport and dllexport are inheritable attributes so we have to exclude\n  // inherited attribute instances.\n  bool HasNewAttr = (NewImportAttr && !NewImportAttr->isInherited()) ||\n                    (NewExportAttr && !NewExportAttr->isInherited());\n\n  // A redeclaration is not allowed to add a dllimport or dllexport attribute,\n  // the only exception being explicit specializations.\n  // Implicitly generated declarations are also excluded for now because there\n  // is no other way to switch these to use dllimport or dllexport.\n  bool AddsAttr = !(OldImportAttr || OldExportAttr) && HasNewAttr;\n\n  if (AddsAttr && !IsSpecialization && !OldDecl->isImplicit()) {\n    // Allow with a warning for free functions and global variables.\n    bool JustWarn = false;\n    if (!OldDecl->isCXXClassMember()) {\n      auto *VD = dyn_cast<VarDecl>(OldDecl);\n      if (VD && !VD->getDescribedVarTemplate())\n        JustWarn = true;\n      auto *FD = dyn_cast<FunctionDecl>(OldDecl);\n      if (FD && FD->getTemplatedKind() == FunctionDecl::TK_NonTemplate)\n        JustWarn = true;\n    }\n\n    // We cannot change a declaration that's been used because IR has already\n    // been emitted. Dllimported functions will still work though (modulo\n    // address equality) as they can use the thunk.\n    if (OldDecl->isUsed())\n      if (!isa<FunctionDecl>(OldDecl) || !NewImportAttr)\n        JustWarn = false;\n\n    unsigned DiagID = JustWarn ? diag::warn_attribute_dll_redeclaration\n                               : diag::err_attribute_dll_redeclaration;\n    S.Diag(NewDecl->getLocation(), DiagID)\n        << NewDecl\n        << (NewImportAttr ? (const Attr *)NewImportAttr : NewExportAttr);\n    S.Diag(OldDecl->getLocation(), diag::note_previous_declaration);\n    if (!JustWarn) {\n      NewDecl->setInvalidDecl();\n      return;\n    }\n  }\n\n  // A redeclaration is not allowed to drop a dllimport attribute, the only\n  // exceptions being inline function definitions (except for function\n  // templates), local extern declarations, qualified friend declarations or\n  // special MSVC extension: in the last case, the declaration is treated as if\n  // it were marked dllexport.\n  bool IsInline = false, IsStaticDataMember = false, IsQualifiedFriend = false;\n  bool IsMicrosoftABI  = S.Context.getTargetInfo().shouldDLLImportComdatSymbols();\n  if (const auto *VD = dyn_cast<VarDecl>(NewDecl)) {\n    // Ignore static data because out-of-line definitions are diagnosed\n    // separately.\n    IsStaticDataMember = VD->isStaticDataMember();\n    IsDefinition = VD->isThisDeclarationADefinition(S.Context) !=\n                   VarDecl::DeclarationOnly;\n  } else if (const auto *FD = dyn_cast<FunctionDecl>(NewDecl)) {\n    IsInline = FD->isInlined();\n    IsQualifiedFriend = FD->getQualifier() &&\n                        FD->getFriendObjectKind() == Decl::FOK_Declared;\n  }\n\n  if (OldImportAttr && !HasNewAttr &&\n      (!IsInline || (IsMicrosoftABI && IsTemplate)) && !IsStaticDataMember &&\n      !NewDecl->isLocalExternDecl() && !IsQualifiedFriend) {\n    if (IsMicrosoftABI && IsDefinition) {\n      S.Diag(NewDecl->getLocation(),\n             diag::warn_redeclaration_without_import_attribute)\n          << NewDecl;\n      S.Diag(OldDecl->getLocation(), diag::note_previous_declaration);\n      NewDecl->dropAttr<DLLImportAttr>();\n      NewDecl->addAttr(\n          DLLExportAttr::CreateImplicit(S.Context, NewImportAttr->getRange()));\n    } else {\n      S.Diag(NewDecl->getLocation(),\n             diag::warn_redeclaration_without_attribute_prev_attribute_ignored)\n          << NewDecl << OldImportAttr;\n      S.Diag(OldDecl->getLocation(), diag::note_previous_declaration);\n      S.Diag(OldImportAttr->getLocation(), diag::note_previous_attribute);\n      OldDecl->dropAttr<DLLImportAttr>();\n      NewDecl->dropAttr<DLLImportAttr>();\n    }\n  } else if (IsInline && OldImportAttr && !IsMicrosoftABI) {\n    // In MinGW, seeing a function declared inline drops the dllimport\n    // attribute.\n    OldDecl->dropAttr<DLLImportAttr>();\n    NewDecl->dropAttr<DLLImportAttr>();\n    S.Diag(NewDecl->getLocation(),\n           diag::warn_dllimport_dropped_from_inline_function)\n        << NewDecl << OldImportAttr;\n  }\n\n  // A specialization of a class template member function is processed here\n  // since it's a redeclaration. If the parent class is dllexport, the\n  // specialization inherits that attribute. This doesn't happen automatically\n  // since the parent class isn't instantiated until later.\n  if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(NewDecl)) {\n    if (MD->getTemplatedKind() == FunctionDecl::TK_MemberSpecialization &&\n        !NewImportAttr && !NewExportAttr) {\n      if (const DLLExportAttr *ParentExportAttr =\n              MD->getParent()->getAttr<DLLExportAttr>()) {\n        DLLExportAttr *NewAttr = ParentExportAttr->clone(S.Context);\n        NewAttr->setInherited(true);\n        NewDecl->addAttr(NewAttr);\n      }\n    }\n  }\n}\n\n/// Given that we are within the definition of the given function,\n/// will that definition behave like C99's 'inline', where the\n/// definition is discarded except for optimization purposes?\nstatic bool isFunctionDefinitionDiscarded(Sema &S, FunctionDecl *FD) {\n  // Try to avoid calling GetGVALinkageForFunction.\n\n  // All cases of this require the 'inline' keyword.\n  if (!FD->isInlined()) return false;\n\n  // This is only possible in C++ with the gnu_inline attribute.\n  if (S.getLangOpts().CPlusPlus && !FD->hasAttr<GNUInlineAttr>())\n    return false;\n\n  // Okay, go ahead and call the relatively-more-expensive function.\n  return S.Context.GetGVALinkageForFunction(FD) == GVA_AvailableExternally;\n}\n\n/// Determine whether a variable is extern \"C\" prior to attaching\n/// an initializer. We can't just call isExternC() here, because that\n/// will also compute and cache whether the declaration is externally\n/// visible, which might change when we attach the initializer.\n///\n/// This can only be used if the declaration is known to not be a\n/// redeclaration of an internal linkage declaration.\n///\n/// For instance:\n///\n///   auto x = []{};\n///\n/// Attaching the initializer here makes this declaration not externally\n/// visible, because its type has internal linkage.\n///\n/// FIXME: This is a hack.\ntemplate<typename T>\nstatic bool isIncompleteDeclExternC(Sema &S, const T *D) {\n  if (S.getLangOpts().CPlusPlus) {\n    // In C++, the overloadable attribute negates the effects of extern \"C\".\n    if (!D->isInExternCContext() || D->template hasAttr<OverloadableAttr>())\n      return false;\n\n    // So do CUDA's host/device attributes.\n    if (S.getLangOpts().CUDA && (D->template hasAttr<CUDADeviceAttr>() ||\n                                 D->template hasAttr<CUDAHostAttr>()))\n      return false;\n  }\n  return D->isExternC();\n}\n\nstatic bool shouldConsiderLinkage(const VarDecl *VD) {\n  const DeclContext *DC = VD->getDeclContext()->getRedeclContext();\n  if (DC->isFunctionOrMethod() || isa<OMPDeclareReductionDecl>(DC) ||\n      isa<OMPDeclareMapperDecl>(DC))\n    return VD->hasExternalStorage();\n  if (DC->isFileContext())\n    return true;\n  if (DC->isRecord())\n    return false;\n  if (isa<RequiresExprBodyDecl>(DC))\n    return false;\n  llvm_unreachable(\"Unexpected context\");\n}\n\nstatic bool shouldConsiderLinkage(const FunctionDecl *FD) {\n  const DeclContext *DC = FD->getDeclContext()->getRedeclContext();\n  if (DC->isFileContext() || DC->isFunctionOrMethod() ||\n      isa<OMPDeclareReductionDecl>(DC) || isa<OMPDeclareMapperDecl>(DC))\n    return true;\n  if (DC->isRecord())\n    return false;\n  llvm_unreachable(\"Unexpected context\");\n}\n\nstatic bool hasParsedAttr(Scope *S, const Declarator &PD,\n                          ParsedAttr::Kind Kind) {\n  // Check decl attributes on the DeclSpec.\n  if (PD.getDeclSpec().getAttributes().hasAttribute(Kind))\n    return true;\n\n  // Walk the declarator structure, checking decl attributes that were in a type\n  // position to the decl itself.\n  for (unsigned I = 0, E = PD.getNumTypeObjects(); I != E; ++I) {\n    if (PD.getTypeObject(I).getAttrs().hasAttribute(Kind))\n      return true;\n  }\n\n  // Finally, check attributes on the decl itself.\n  return PD.getAttributes().hasAttribute(Kind);\n}\n\n/// Adjust the \\c DeclContext for a function or variable that might be a\n/// function-local external declaration.\nbool Sema::adjustContextForLocalExternDecl(DeclContext *&DC) {\n  if (!DC->isFunctionOrMethod())\n    return false;\n\n  // If this is a local extern function or variable declared within a function\n  // template, don't add it into the enclosing namespace scope until it is\n  // instantiated; it might have a dependent type right now.\n  if (DC->isDependentContext())\n    return true;\n\n  // C++11 [basic.link]p7:\n  //   When a block scope declaration of an entity with linkage is not found to\n  //   refer to some other declaration, then that entity is a member of the\n  //   innermost enclosing namespace.\n  //\n  // Per C++11 [namespace.def]p6, the innermost enclosing namespace is a\n  // semantically-enclosing namespace, not a lexically-enclosing one.\n  while (!DC->isFileContext() && !isa<LinkageSpecDecl>(DC))\n    DC = DC->getParent();\n  return true;\n}\n\n/// Returns true if given declaration has external C language linkage.\nstatic bool isDeclExternC(const Decl *D) {\n  if (const auto *FD = dyn_cast<FunctionDecl>(D))\n    return FD->isExternC();\n  if (const auto *VD = dyn_cast<VarDecl>(D))\n    return VD->isExternC();\n\n  llvm_unreachable(\"Unknown type of decl!\");\n}\n/// Returns true if there hasn't been any invalid type diagnosed.\nstatic bool diagnoseOpenCLTypes(Scope *S, Sema &Se, Declarator &D,\n                                DeclContext *DC, QualType R) {\n  // OpenCL v2.0 s6.9.b - Image type can only be used as a function argument.\n  // OpenCL v2.0 s6.13.16.1 - Pipe type can only be used as a function\n  // argument.\n  if (R->isImageType() || R->isPipeType()) {\n    Se.Diag(D.getIdentifierLoc(),\n            diag::err_opencl_type_can_only_be_used_as_function_parameter)\n        << R;\n    D.setInvalidType();\n    return false;\n  }\n\n  // OpenCL v1.2 s6.9.r:\n  // The event type cannot be used to declare a program scope variable.\n  // OpenCL v2.0 s6.9.q:\n  // The clk_event_t and reserve_id_t types cannot be declared in program\n  // scope.\n  if (NULL == S->getParent()) {\n    if (R->isReserveIDT() || R->isClkEventT() || R->isEventT()) {\n      Se.Diag(D.getIdentifierLoc(),\n              diag::err_invalid_type_for_program_scope_var)\n          << R;\n      D.setInvalidType();\n      return false;\n    }\n  }\n\n  // OpenCL v1.0 s6.8.a.3: Pointers to functions are not allowed.\n  if (!Se.getOpenCLOptions().isEnabled(\"__cl_clang_function_pointers\")) {\n    QualType NR = R.getCanonicalType();\n    while (NR->isPointerType() || NR->isMemberFunctionPointerType() ||\n           NR->isReferenceType()) {\n      if (NR->isFunctionPointerType() || NR->isMemberFunctionPointerType() ||\n          NR->isFunctionReferenceType()) {\n        Se.Diag(D.getIdentifierLoc(), diag::err_opencl_function_pointer)\n            << NR->isReferenceType();\n        D.setInvalidType();\n        return false;\n      }\n      NR = NR->getPointeeType();\n    }\n  }\n\n  if (!Se.getOpenCLOptions().isEnabled(\"cl_khr_fp16\")) {\n    // OpenCL v1.2 s6.1.1.1: reject declaring variables of the half and\n    // half array type (unless the cl_khr_fp16 extension is enabled).\n    if (Se.Context.getBaseElementType(R)->isHalfType()) {\n      Se.Diag(D.getIdentifierLoc(), diag::err_opencl_half_declaration) << R;\n      D.setInvalidType();\n      return false;\n    }\n  }\n\n  // OpenCL v1.2 s6.9.r:\n  // The event type cannot be used with the __local, __constant and __global\n  // address space qualifiers.\n  if (R->isEventT()) {\n    if (R.getAddressSpace() != LangAS::opencl_private) {\n      Se.Diag(D.getBeginLoc(), diag::err_event_t_addr_space_qual);\n      D.setInvalidType();\n      return false;\n    }\n  }\n\n  // C++ for OpenCL does not allow the thread_local storage qualifier.\n  // OpenCL C does not support thread_local either, and\n  // also reject all other thread storage class specifiers.\n  DeclSpec::TSCS TSC = D.getDeclSpec().getThreadStorageClassSpec();\n  if (TSC != TSCS_unspecified) {\n    bool IsCXX = Se.getLangOpts().OpenCLCPlusPlus;\n    Se.Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n            diag::err_opencl_unknown_type_specifier)\n        << IsCXX << Se.getLangOpts().getOpenCLVersionTuple().getAsString()\n        << DeclSpec::getSpecifierName(TSC) << 1;\n    D.setInvalidType();\n    return false;\n  }\n\n  if (R->isSamplerT()) {\n    // OpenCL v1.2 s6.9.b p4:\n    // The sampler type cannot be used with the __local and __global address\n    // space qualifiers.\n    if (R.getAddressSpace() == LangAS::opencl_local ||\n        R.getAddressSpace() == LangAS::opencl_global) {\n      Se.Diag(D.getIdentifierLoc(), diag::err_wrong_sampler_addressspace);\n      D.setInvalidType();\n    }\n\n    // OpenCL v1.2 s6.12.14.1:\n    // A global sampler must be declared with either the constant address\n    // space qualifier or with the const qualifier.\n    if (DC->isTranslationUnit() &&\n        !(R.getAddressSpace() == LangAS::opencl_constant ||\n          R.isConstQualified())) {\n      Se.Diag(D.getIdentifierLoc(), diag::err_opencl_nonconst_global_sampler);\n      D.setInvalidType();\n    }\n    if (D.isInvalidType())\n      return false;\n  }\n  return true;\n}\n\nNamedDecl *Sema::ActOnVariableDeclarator(\n    Scope *S, Declarator &D, DeclContext *DC, TypeSourceInfo *TInfo,\n    LookupResult &Previous, MultiTemplateParamsArg TemplateParamLists,\n    bool &AddToScope, ArrayRef<BindingDecl *> Bindings) {\n  QualType R = TInfo->getType();\n  DeclarationName Name = GetNameForDeclarator(D).getName();\n\n  IdentifierInfo *II = Name.getAsIdentifierInfo();\n\n  if (D.isDecompositionDeclarator()) {\n    // Take the name of the first declarator as our name for diagnostic\n    // purposes.\n    auto &Decomp = D.getDecompositionDeclarator();\n    if (!Decomp.bindings().empty()) {\n      II = Decomp.bindings()[0].Name;\n      Name = II;\n    }\n  } else if (!II) {\n    Diag(D.getIdentifierLoc(), diag::err_bad_variable_name) << Name;\n    return nullptr;\n  }\n\n\n  DeclSpec::SCS SCSpec = D.getDeclSpec().getStorageClassSpec();\n  StorageClass SC = StorageClassSpecToVarDeclStorageClass(D.getDeclSpec());\n\n  // dllimport globals without explicit storage class are treated as extern. We\n  // have to change the storage class this early to get the right DeclContext.\n  if (SC == SC_None && !DC->isRecord() &&\n      hasParsedAttr(S, D, ParsedAttr::AT_DLLImport) &&\n      !hasParsedAttr(S, D, ParsedAttr::AT_DLLExport))\n    SC = SC_Extern;\n\n  DeclContext *OriginalDC = DC;\n  bool IsLocalExternDecl = SC == SC_Extern &&\n                           adjustContextForLocalExternDecl(DC);\n\n  if (SCSpec == DeclSpec::SCS_mutable) {\n    // mutable can only appear on non-static class members, so it's always\n    // an error here\n    Diag(D.getIdentifierLoc(), diag::err_mutable_nonmember);\n    D.setInvalidType();\n    SC = SC_None;\n  }\n\n  if (getLangOpts().CPlusPlus11 && SCSpec == DeclSpec::SCS_register &&\n      !D.getAsmLabel() && !getSourceManager().isInSystemMacro(\n                              D.getDeclSpec().getStorageClassSpecLoc())) {\n    // In C++11, the 'register' storage class specifier is deprecated.\n    // Suppress the warning in system macros, it's used in macros in some\n    // popular C system headers, such as in glibc's htonl() macro.\n    Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n         getLangOpts().CPlusPlus17 ? diag::ext_register_storage_class\n                                   : diag::warn_deprecated_register)\n      << FixItHint::CreateRemoval(D.getDeclSpec().getStorageClassSpecLoc());\n  }\n\n  DiagnoseFunctionSpecifiers(D.getDeclSpec());\n\n  if (!DC->isRecord() && S->getFnParent() == nullptr) {\n    // C99 6.9p2: The storage-class specifiers auto and register shall not\n    // appear in the declaration specifiers in an external declaration.\n    // Global Register+Asm is a GNU extension we support.\n    if (SC == SC_Auto || (SC == SC_Register && !D.getAsmLabel())) {\n      Diag(D.getIdentifierLoc(), diag::err_typecheck_sclass_fscope);\n      D.setInvalidType();\n    }\n  }\n\n  // If this variable has a variable-modified type and an initializer, try to\n  // fold to a constant-sized type. This is otherwise invalid.\n  if (D.hasInitializer() && R->isVariablyModifiedType())\n    tryToFixVariablyModifiedVarType(*this, TInfo, R, D.getIdentifierLoc(),\n                                    /*DiagID=*/0);\n\n  bool IsMemberSpecialization = false;\n  bool IsVariableTemplateSpecialization = false;\n  bool IsPartialSpecialization = false;\n  bool IsVariableTemplate = false;\n  VarDecl *NewVD = nullptr;\n  VarTemplateDecl *NewTemplate = nullptr;\n  TemplateParameterList *TemplateParams = nullptr;\n  if (!getLangOpts().CPlusPlus) {\n    NewVD = VarDecl::Create(Context, DC, D.getBeginLoc(), D.getIdentifierLoc(),\n                            II, R, TInfo, SC);\n\n    if (R->getContainedDeducedType())\n      ParsingInitForAutoVars.insert(NewVD);\n\n    if (D.isInvalidType())\n      NewVD->setInvalidDecl();\n\n    if (NewVD->getType().hasNonTrivialToPrimitiveDestructCUnion() &&\n        NewVD->hasLocalStorage())\n      checkNonTrivialCUnion(NewVD->getType(), NewVD->getLocation(),\n                            NTCUC_AutoVar, NTCUK_Destruct);\n  } else {\n    bool Invalid = false;\n\n    if (DC->isRecord() && !CurContext->isRecord()) {\n      // This is an out-of-line definition of a static data member.\n      switch (SC) {\n      case SC_None:\n        break;\n      case SC_Static:\n        Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n             diag::err_static_out_of_line)\n          << FixItHint::CreateRemoval(D.getDeclSpec().getStorageClassSpecLoc());\n        break;\n      case SC_Auto:\n      case SC_Register:\n      case SC_Extern:\n        // [dcl.stc] p2: The auto or register specifiers shall be applied only\n        // to names of variables declared in a block or to function parameters.\n        // [dcl.stc] p6: The extern specifier cannot be used in the declaration\n        // of class members\n\n        Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n             diag::err_storage_class_for_static_member)\n          << FixItHint::CreateRemoval(D.getDeclSpec().getStorageClassSpecLoc());\n        break;\n      case SC_PrivateExtern:\n        llvm_unreachable(\"C storage class in c++!\");\n      }\n    }\n\n    if (SC == SC_Static && CurContext->isRecord()) {\n      if (const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(DC)) {\n        // Walk up the enclosing DeclContexts to check for any that are\n        // incompatible with static data members.\n        const DeclContext *FunctionOrMethod = nullptr;\n        const CXXRecordDecl *AnonStruct = nullptr;\n        for (DeclContext *Ctxt = DC; Ctxt; Ctxt = Ctxt->getParent()) {\n          if (Ctxt->isFunctionOrMethod()) {\n            FunctionOrMethod = Ctxt;\n            break;\n          }\n          const CXXRecordDecl *ParentDecl = dyn_cast<CXXRecordDecl>(Ctxt);\n          if (ParentDecl && !ParentDecl->getDeclName()) {\n            AnonStruct = ParentDecl;\n            break;\n          }\n        }\n        if (FunctionOrMethod) {\n          // C++ [class.static.data]p5: A local class shall not have static data\n          // members.\n          Diag(D.getIdentifierLoc(),\n               diag::err_static_data_member_not_allowed_in_local_class)\n            << Name << RD->getDeclName() << RD->getTagKind();\n        } else if (AnonStruct) {\n          // C++ [class.static.data]p4: Unnamed classes and classes contained\n          // directly or indirectly within unnamed classes shall not contain\n          // static data members.\n          Diag(D.getIdentifierLoc(),\n               diag::err_static_data_member_not_allowed_in_anon_struct)\n            << Name << AnonStruct->getTagKind();\n          Invalid = true;\n        } else if (RD->isUnion()) {\n          // C++98 [class.union]p1: If a union contains a static data member,\n          // the program is ill-formed. C++11 drops this restriction.\n          Diag(D.getIdentifierLoc(),\n               getLangOpts().CPlusPlus11\n                 ? diag::warn_cxx98_compat_static_data_member_in_union\n                 : diag::ext_static_data_member_in_union) << Name;\n        }\n      }\n    }\n\n    // Match up the template parameter lists with the scope specifier, then\n    // determine whether we have a template or a template specialization.\n    bool InvalidScope = false;\n    TemplateParams = MatchTemplateParametersToScopeSpecifier(\n        D.getDeclSpec().getBeginLoc(), D.getIdentifierLoc(),\n        D.getCXXScopeSpec(),\n        D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId\n            ? D.getName().TemplateId\n            : nullptr,\n        TemplateParamLists,\n        /*never a friend*/ false, IsMemberSpecialization, InvalidScope);\n    Invalid |= InvalidScope;\n\n    if (TemplateParams) {\n      if (!TemplateParams->size() &&\n          D.getName().getKind() != UnqualifiedIdKind::IK_TemplateId) {\n        // There is an extraneous 'template<>' for this variable. Complain\n        // about it, but allow the declaration of the variable.\n        Diag(TemplateParams->getTemplateLoc(),\n             diag::err_template_variable_noparams)\n          << II\n          << SourceRange(TemplateParams->getTemplateLoc(),\n                         TemplateParams->getRAngleLoc());\n        TemplateParams = nullptr;\n      } else {\n        // Check that we can declare a template here.\n        if (CheckTemplateDeclScope(S, TemplateParams))\n          return nullptr;\n\n        if (D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId) {\n          // This is an explicit specialization or a partial specialization.\n          IsVariableTemplateSpecialization = true;\n          IsPartialSpecialization = TemplateParams->size() > 0;\n        } else { // if (TemplateParams->size() > 0)\n          // This is a template declaration.\n          IsVariableTemplate = true;\n\n          // Only C++1y supports variable templates (N3651).\n          Diag(D.getIdentifierLoc(),\n               getLangOpts().CPlusPlus14\n                   ? diag::warn_cxx11_compat_variable_template\n                   : diag::ext_variable_template);\n        }\n      }\n    } else {\n      // Check that we can declare a member specialization here.\n      if (!TemplateParamLists.empty() && IsMemberSpecialization &&\n          CheckTemplateDeclScope(S, TemplateParamLists.back()))\n        return nullptr;\n      assert((Invalid ||\n              D.getName().getKind() != UnqualifiedIdKind::IK_TemplateId) &&\n             \"should have a 'template<>' for this decl\");\n    }\n\n    if (IsVariableTemplateSpecialization) {\n      SourceLocation TemplateKWLoc =\n          TemplateParamLists.size() > 0\n              ? TemplateParamLists[0]->getTemplateLoc()\n              : SourceLocation();\n      DeclResult Res = ActOnVarTemplateSpecialization(\n          S, D, TInfo, TemplateKWLoc, TemplateParams, SC,\n          IsPartialSpecialization);\n      if (Res.isInvalid())\n        return nullptr;\n      NewVD = cast<VarDecl>(Res.get());\n      AddToScope = false;\n    } else if (D.isDecompositionDeclarator()) {\n      NewVD = DecompositionDecl::Create(Context, DC, D.getBeginLoc(),\n                                        D.getIdentifierLoc(), R, TInfo, SC,\n                                        Bindings);\n    } else\n      NewVD = VarDecl::Create(Context, DC, D.getBeginLoc(),\n                              D.getIdentifierLoc(), II, R, TInfo, SC);\n\n    // If this is supposed to be a variable template, create it as such.\n    if (IsVariableTemplate) {\n      NewTemplate =\n          VarTemplateDecl::Create(Context, DC, D.getIdentifierLoc(), Name,\n                                  TemplateParams, NewVD);\n      NewVD->setDescribedVarTemplate(NewTemplate);\n    }\n\n    // If this decl has an auto type in need of deduction, make a note of the\n    // Decl so we can diagnose uses of it in its own initializer.\n    if (R->getContainedDeducedType())\n      ParsingInitForAutoVars.insert(NewVD);\n\n    if (D.isInvalidType() || Invalid) {\n      NewVD->setInvalidDecl();\n      if (NewTemplate)\n        NewTemplate->setInvalidDecl();\n    }\n\n    SetNestedNameSpecifier(*this, NewVD, D);\n\n    // If we have any template parameter lists that don't directly belong to\n    // the variable (matching the scope specifier), store them.\n    unsigned VDTemplateParamLists = TemplateParams ? 1 : 0;\n    if (TemplateParamLists.size() > VDTemplateParamLists)\n      NewVD->setTemplateParameterListsInfo(\n          Context, TemplateParamLists.drop_back(VDTemplateParamLists));\n  }\n\n  if (D.getDeclSpec().isInlineSpecified()) {\n    if (!getLangOpts().CPlusPlus) {\n      Diag(D.getDeclSpec().getInlineSpecLoc(), diag::err_inline_non_function)\n          << 0;\n    } else if (CurContext->isFunctionOrMethod()) {\n      // 'inline' is not allowed on block scope variable declaration.\n      Diag(D.getDeclSpec().getInlineSpecLoc(),\n           diag::err_inline_declaration_block_scope) << Name\n        << FixItHint::CreateRemoval(D.getDeclSpec().getInlineSpecLoc());\n    } else {\n      Diag(D.getDeclSpec().getInlineSpecLoc(),\n           getLangOpts().CPlusPlus17 ? diag::warn_cxx14_compat_inline_variable\n                                     : diag::ext_inline_variable);\n      NewVD->setInlineSpecified();\n    }\n  }\n\n  // Set the lexical context. If the declarator has a C++ scope specifier, the\n  // lexical context will be different from the semantic context.\n  NewVD->setLexicalDeclContext(CurContext);\n  if (NewTemplate)\n    NewTemplate->setLexicalDeclContext(CurContext);\n\n  if (IsLocalExternDecl) {\n    if (D.isDecompositionDeclarator())\n      for (auto *B : Bindings)\n        B->setLocalExternDecl();\n    else\n      NewVD->setLocalExternDecl();\n  }\n\n  bool EmitTLSUnsupportedError = false;\n  if (DeclSpec::TSCS TSCS = D.getDeclSpec().getThreadStorageClassSpec()) {\n    // C++11 [dcl.stc]p4:\n    //   When thread_local is applied to a variable of block scope the\n    //   storage-class-specifier static is implied if it does not appear\n    //   explicitly.\n    // Core issue: 'static' is not implied if the variable is declared\n    //   'extern'.\n    if (NewVD->hasLocalStorage() &&\n        (SCSpec != DeclSpec::SCS_unspecified ||\n         TSCS != DeclSpec::TSCS_thread_local ||\n         !DC->isFunctionOrMethod()))\n      Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n           diag::err_thread_non_global)\n        << DeclSpec::getSpecifierName(TSCS);\n    else if (!Context.getTargetInfo().isTLSSupported()) {\n      if (getLangOpts().CUDA || getLangOpts().OpenMPIsDevice ||\n          getLangOpts().SYCLIsDevice) {\n        // Postpone error emission until we've collected attributes required to\n        // figure out whether it's a host or device variable and whether the\n        // error should be ignored.\n        EmitTLSUnsupportedError = true;\n        // We still need to mark the variable as TLS so it shows up in AST with\n        // proper storage class for other tools to use even if we're not going\n        // to emit any code for it.\n        NewVD->setTSCSpec(TSCS);\n      } else\n        Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n             diag::err_thread_unsupported);\n    } else\n      NewVD->setTSCSpec(TSCS);\n  }\n\n  switch (D.getDeclSpec().getConstexprSpecifier()) {\n  case ConstexprSpecKind::Unspecified:\n    break;\n\n  case ConstexprSpecKind::Consteval:\n    Diag(D.getDeclSpec().getConstexprSpecLoc(),\n         diag::err_constexpr_wrong_decl_kind)\n        << static_cast<int>(D.getDeclSpec().getConstexprSpecifier());\n    LLVM_FALLTHROUGH;\n\n  case ConstexprSpecKind::Constexpr:\n    NewVD->setConstexpr(true);\n    MaybeAddCUDAConstantAttr(NewVD);\n    // C++1z [dcl.spec.constexpr]p1:\n    //   A static data member declared with the constexpr specifier is\n    //   implicitly an inline variable.\n    if (NewVD->isStaticDataMember() &&\n        (getLangOpts().CPlusPlus17 ||\n         Context.getTargetInfo().getCXXABI().isMicrosoft()))\n      NewVD->setImplicitlyInline();\n    break;\n\n  case ConstexprSpecKind::Constinit:\n    if (!NewVD->hasGlobalStorage())\n      Diag(D.getDeclSpec().getConstexprSpecLoc(),\n           diag::err_constinit_local_variable);\n    else\n      NewVD->addAttr(ConstInitAttr::Create(\n          Context, D.getDeclSpec().getConstexprSpecLoc(),\n          AttributeCommonInfo::AS_Keyword, ConstInitAttr::Keyword_constinit));\n    break;\n  }\n\n  // C99 6.7.4p3\n  //   An inline definition of a function with external linkage shall\n  //   not contain a definition of a modifiable object with static or\n  //   thread storage duration...\n  // We only apply this when the function is required to be defined\n  // elsewhere, i.e. when the function is not 'extern inline'.  Note\n  // that a local variable with thread storage duration still has to\n  // be marked 'static'.  Also note that it's possible to get these\n  // semantics in C++ using __attribute__((gnu_inline)).\n  if (SC == SC_Static && S->getFnParent() != nullptr &&\n      !NewVD->getType().isConstQualified()) {\n    FunctionDecl *CurFD = getCurFunctionDecl();\n    if (CurFD && isFunctionDefinitionDiscarded(*this, CurFD)) {\n      Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n           diag::warn_static_local_in_extern_inline);\n      MaybeSuggestAddingStaticToDecl(CurFD);\n    }\n  }\n\n  if (D.getDeclSpec().isModulePrivateSpecified()) {\n    if (IsVariableTemplateSpecialization)\n      Diag(NewVD->getLocation(), diag::err_module_private_specialization)\n          << (IsPartialSpecialization ? 1 : 0)\n          << FixItHint::CreateRemoval(\n                 D.getDeclSpec().getModulePrivateSpecLoc());\n    else if (IsMemberSpecialization)\n      Diag(NewVD->getLocation(), diag::err_module_private_specialization)\n        << 2\n        << FixItHint::CreateRemoval(D.getDeclSpec().getModulePrivateSpecLoc());\n    else if (NewVD->hasLocalStorage())\n      Diag(NewVD->getLocation(), diag::err_module_private_local)\n          << 0 << NewVD\n          << SourceRange(D.getDeclSpec().getModulePrivateSpecLoc())\n          << FixItHint::CreateRemoval(\n                 D.getDeclSpec().getModulePrivateSpecLoc());\n    else {\n      NewVD->setModulePrivate();\n      if (NewTemplate)\n        NewTemplate->setModulePrivate();\n      for (auto *B : Bindings)\n        B->setModulePrivate();\n    }\n  }\n\n  if (getLangOpts().OpenCL) {\n\n    deduceOpenCLAddressSpace(NewVD);\n\n    diagnoseOpenCLTypes(S, *this, D, DC, NewVD->getType());\n  }\n\n  // Handle attributes prior to checking for duplicates in MergeVarDecl\n  ProcessDeclAttributes(S, NewVD, D);\n\n  if (getLangOpts().CUDA || getLangOpts().OpenMPIsDevice ||\n      getLangOpts().SYCLIsDevice) {\n    if (EmitTLSUnsupportedError &&\n        ((getLangOpts().CUDA && DeclAttrsMatchCUDAMode(getLangOpts(), NewVD)) ||\n         (getLangOpts().OpenMPIsDevice &&\n          OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(NewVD))))\n      Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n           diag::err_thread_unsupported);\n\n    if (EmitTLSUnsupportedError &&\n        (LangOpts.SYCLIsDevice || (LangOpts.OpenMP && LangOpts.OpenMPIsDevice)))\n      targetDiag(D.getIdentifierLoc(), diag::err_thread_unsupported);\n    // CUDA B.2.5: \"__shared__ and __constant__ variables have implied static\n    // storage [duration].\"\n    if (SC == SC_None && S->getFnParent() != nullptr &&\n        (NewVD->hasAttr<CUDASharedAttr>() ||\n         NewVD->hasAttr<CUDAConstantAttr>())) {\n      NewVD->setStorageClass(SC_Static);\n    }\n  }\n\n  // Ensure that dllimport globals without explicit storage class are treated as\n  // extern. The storage class is set above using parsed attributes. Now we can\n  // check the VarDecl itself.\n  assert(!NewVD->hasAttr<DLLImportAttr>() ||\n         NewVD->getAttr<DLLImportAttr>()->isInherited() ||\n         NewVD->isStaticDataMember() || NewVD->getStorageClass() != SC_None);\n\n  // In auto-retain/release, infer strong retension for variables of\n  // retainable type.\n  if (getLangOpts().ObjCAutoRefCount && inferObjCARCLifetime(NewVD))\n    NewVD->setInvalidDecl();\n\n  // Handle GNU asm-label extension (encoded as an attribute).\n  if (Expr *E = (Expr*)D.getAsmLabel()) {\n    // The parser guarantees this is a string.\n    StringLiteral *SE = cast<StringLiteral>(E);\n    StringRef Label = SE->getString();\n    if (S->getFnParent() != nullptr) {\n      switch (SC) {\n      case SC_None:\n      case SC_Auto:\n        Diag(E->getExprLoc(), diag::warn_asm_label_on_auto_decl) << Label;\n        break;\n      case SC_Register:\n        // Local Named register\n        if (!Context.getTargetInfo().isValidGCCRegisterName(Label) &&\n            DeclAttrsMatchCUDAMode(getLangOpts(), getCurFunctionDecl()))\n          Diag(E->getExprLoc(), diag::err_asm_unknown_register_name) << Label;\n        break;\n      case SC_Static:\n      case SC_Extern:\n      case SC_PrivateExtern:\n        break;\n      }\n    } else if (SC == SC_Register) {\n      // Global Named register\n      if (DeclAttrsMatchCUDAMode(getLangOpts(), NewVD)) {\n        const auto &TI = Context.getTargetInfo();\n        bool HasSizeMismatch;\n\n        if (!TI.isValidGCCRegisterName(Label))\n          Diag(E->getExprLoc(), diag::err_asm_unknown_register_name) << Label;\n        else if (!TI.validateGlobalRegisterVariable(Label,\n                                                    Context.getTypeSize(R),\n                                                    HasSizeMismatch))\n          Diag(E->getExprLoc(), diag::err_asm_invalid_global_var_reg) << Label;\n        else if (HasSizeMismatch)\n          Diag(E->getExprLoc(), diag::err_asm_register_size_mismatch) << Label;\n      }\n\n      if (!R->isIntegralType(Context) && !R->isPointerType()) {\n        Diag(D.getBeginLoc(), diag::err_asm_bad_register_type);\n        NewVD->setInvalidDecl(true);\n      }\n    }\n\n    NewVD->addAttr(AsmLabelAttr::Create(Context, Label,\n                                        /*IsLiteralLabel=*/true,\n                                        SE->getStrTokenLoc(0)));\n  } else if (!ExtnameUndeclaredIdentifiers.empty()) {\n    llvm::DenseMap<IdentifierInfo*,AsmLabelAttr*>::iterator I =\n      ExtnameUndeclaredIdentifiers.find(NewVD->getIdentifier());\n    if (I != ExtnameUndeclaredIdentifiers.end()) {\n      if (isDeclExternC(NewVD)) {\n        NewVD->addAttr(I->second);\n        ExtnameUndeclaredIdentifiers.erase(I);\n      } else\n        Diag(NewVD->getLocation(), diag::warn_redefine_extname_not_applied)\n            << /*Variable*/1 << NewVD;\n    }\n  }\n\n  // Find the shadowed declaration before filtering for scope.\n  NamedDecl *ShadowedDecl = D.getCXXScopeSpec().isEmpty()\n                                ? getShadowedDeclaration(NewVD, Previous)\n                                : nullptr;\n\n  // Don't consider existing declarations that are in a different\n  // scope and are out-of-semantic-context declarations (if the new\n  // declaration has linkage).\n  FilterLookupForScope(Previous, OriginalDC, S, shouldConsiderLinkage(NewVD),\n                       D.getCXXScopeSpec().isNotEmpty() ||\n                       IsMemberSpecialization ||\n                       IsVariableTemplateSpecialization);\n\n  // Check whether the previous declaration is in the same block scope. This\n  // affects whether we merge types with it, per C++11 [dcl.array]p3.\n  if (getLangOpts().CPlusPlus &&\n      NewVD->isLocalVarDecl() && NewVD->hasExternalStorage())\n    NewVD->setPreviousDeclInSameBlockScope(\n        Previous.isSingleResult() && !Previous.isShadowed() &&\n        isDeclInScope(Previous.getFoundDecl(), OriginalDC, S, false));\n\n  if (!getLangOpts().CPlusPlus) {\n    D.setRedeclaration(CheckVariableDeclaration(NewVD, Previous));\n  } else {\n    // If this is an explicit specialization of a static data member, check it.\n    if (IsMemberSpecialization && !NewVD->isInvalidDecl() &&\n        CheckMemberSpecialization(NewVD, Previous))\n      NewVD->setInvalidDecl();\n\n    // Merge the decl with the existing one if appropriate.\n    if (!Previous.empty()) {\n      if (Previous.isSingleResult() &&\n          isa<FieldDecl>(Previous.getFoundDecl()) &&\n          D.getCXXScopeSpec().isSet()) {\n        // The user tried to define a non-static data member\n        // out-of-line (C++ [dcl.meaning]p1).\n        Diag(NewVD->getLocation(), diag::err_nonstatic_member_out_of_line)\n          << D.getCXXScopeSpec().getRange();\n        Previous.clear();\n        NewVD->setInvalidDecl();\n      }\n    } else if (D.getCXXScopeSpec().isSet()) {\n      // No previous declaration in the qualifying scope.\n      Diag(D.getIdentifierLoc(), diag::err_no_member)\n        << Name << computeDeclContext(D.getCXXScopeSpec(), true)\n        << D.getCXXScopeSpec().getRange();\n      NewVD->setInvalidDecl();\n    }\n\n    if (!IsVariableTemplateSpecialization)\n      D.setRedeclaration(CheckVariableDeclaration(NewVD, Previous));\n\n    if (NewTemplate) {\n      VarTemplateDecl *PrevVarTemplate =\n          NewVD->getPreviousDecl()\n              ? NewVD->getPreviousDecl()->getDescribedVarTemplate()\n              : nullptr;\n\n      // Check the template parameter list of this declaration, possibly\n      // merging in the template parameter list from the previous variable\n      // template declaration.\n      if (CheckTemplateParameterList(\n              TemplateParams,\n              PrevVarTemplate ? PrevVarTemplate->getTemplateParameters()\n                              : nullptr,\n              (D.getCXXScopeSpec().isSet() && DC && DC->isRecord() &&\n               DC->isDependentContext())\n                  ? TPC_ClassTemplateMember\n                  : TPC_VarTemplate))\n        NewVD->setInvalidDecl();\n\n      // If we are providing an explicit specialization of a static variable\n      // template, make a note of that.\n      if (PrevVarTemplate &&\n          PrevVarTemplate->getInstantiatedFromMemberTemplate())\n        PrevVarTemplate->setMemberSpecialization();\n    }\n  }\n\n  // Diagnose shadowed variables iff this isn't a redeclaration.\n  if (ShadowedDecl && !D.isRedeclaration())\n    CheckShadow(NewVD, ShadowedDecl, Previous);\n\n  ProcessPragmaWeak(S, NewVD);\n\n  // If this is the first declaration of an extern C variable, update\n  // the map of such variables.\n  if (NewVD->isFirstDecl() && !NewVD->isInvalidDecl() &&\n      isIncompleteDeclExternC(*this, NewVD))\n    RegisterLocallyScopedExternCDecl(NewVD, S);\n\n  if (getLangOpts().CPlusPlus && NewVD->isStaticLocal()) {\n    MangleNumberingContext *MCtx;\n    Decl *ManglingContextDecl;\n    std::tie(MCtx, ManglingContextDecl) =\n        getCurrentMangleNumberContext(NewVD->getDeclContext());\n    if (MCtx) {\n      Context.setManglingNumber(\n          NewVD, MCtx->getManglingNumber(\n                     NewVD, getMSManglingNumber(getLangOpts(), S)));\n      Context.setStaticLocalNumber(NewVD, MCtx->getStaticLocalNumber(NewVD));\n    }\n  }\n\n  // Special handling of variable named 'main'.\n  if (Name.getAsIdentifierInfo() && Name.getAsIdentifierInfo()->isStr(\"main\") &&\n      NewVD->getDeclContext()->getRedeclContext()->isTranslationUnit() &&\n      !getLangOpts().Freestanding && !NewVD->getDescribedVarTemplate()) {\n\n    // C++ [basic.start.main]p3\n    // A program that declares a variable main at global scope is ill-formed.\n    if (getLangOpts().CPlusPlus)\n      Diag(D.getBeginLoc(), diag::err_main_global_variable);\n\n    // In C, and external-linkage variable named main results in undefined\n    // behavior.\n    else if (NewVD->hasExternalFormalLinkage())\n      Diag(D.getBeginLoc(), diag::warn_main_redefined);\n  }\n\n  if (D.isRedeclaration() && !Previous.empty()) {\n    NamedDecl *Prev = Previous.getRepresentativeDecl();\n    checkDLLAttributeRedeclaration(*this, Prev, NewVD, IsMemberSpecialization,\n                                   D.isFunctionDefinition());\n  }\n\n  if (NewTemplate) {\n    if (NewVD->isInvalidDecl())\n      NewTemplate->setInvalidDecl();\n    ActOnDocumentableDecl(NewTemplate);\n    return NewTemplate;\n  }\n\n  if (IsMemberSpecialization && !NewVD->isInvalidDecl())\n    CompleteMemberSpecialization(NewVD, Previous);\n\n  return NewVD;\n}\n\n/// Enum describing the %select options in diag::warn_decl_shadow.\nenum ShadowedDeclKind {\n  SDK_Local,\n  SDK_Global,\n  SDK_StaticMember,\n  SDK_Field,\n  SDK_Typedef,\n  SDK_Using,\n  SDK_StructuredBinding\n};\n\n/// Determine what kind of declaration we're shadowing.\nstatic ShadowedDeclKind computeShadowedDeclKind(const NamedDecl *ShadowedDecl,\n                                                const DeclContext *OldDC) {\n  if (isa<TypeAliasDecl>(ShadowedDecl))\n    return SDK_Using;\n  else if (isa<TypedefDecl>(ShadowedDecl))\n    return SDK_Typedef;\n  else if (isa<BindingDecl>(ShadowedDecl))\n    return SDK_StructuredBinding;\n  else if (isa<RecordDecl>(OldDC))\n    return isa<FieldDecl>(ShadowedDecl) ? SDK_Field : SDK_StaticMember;\n\n  return OldDC->isFileContext() ? SDK_Global : SDK_Local;\n}\n\n/// Return the location of the capture if the given lambda captures the given\n/// variable \\p VD, or an invalid source location otherwise.\nstatic SourceLocation getCaptureLocation(const LambdaScopeInfo *LSI,\n                                         const VarDecl *VD) {\n  for (const Capture &Capture : LSI->Captures) {\n    if (Capture.isVariableCapture() && Capture.getVariable() == VD)\n      return Capture.getLocation();\n  }\n  return SourceLocation();\n}\n\nstatic bool shouldWarnIfShadowedDecl(const DiagnosticsEngine &Diags,\n                                     const LookupResult &R) {\n  // Only diagnose if we're shadowing an unambiguous field or variable.\n  if (R.getResultKind() != LookupResult::Found)\n    return false;\n\n  // Return false if warning is ignored.\n  return !Diags.isIgnored(diag::warn_decl_shadow, R.getNameLoc());\n}\n\n/// Return the declaration shadowed by the given variable \\p D, or null\n/// if it doesn't shadow any declaration or shadowing warnings are disabled.\nNamedDecl *Sema::getShadowedDeclaration(const VarDecl *D,\n                                        const LookupResult &R) {\n  if (!shouldWarnIfShadowedDecl(Diags, R))\n    return nullptr;\n\n  // Don't diagnose declarations at file scope.\n  if (D->hasGlobalStorage())\n    return nullptr;\n\n  NamedDecl *ShadowedDecl = R.getFoundDecl();\n  return isa<VarDecl, FieldDecl, BindingDecl>(ShadowedDecl) ? ShadowedDecl\n                                                            : nullptr;\n}\n\n/// Return the declaration shadowed by the given typedef \\p D, or null\n/// if it doesn't shadow any declaration or shadowing warnings are disabled.\nNamedDecl *Sema::getShadowedDeclaration(const TypedefNameDecl *D,\n                                        const LookupResult &R) {\n  // Don't warn if typedef declaration is part of a class\n  if (D->getDeclContext()->isRecord())\n    return nullptr;\n\n  if (!shouldWarnIfShadowedDecl(Diags, R))\n    return nullptr;\n\n  NamedDecl *ShadowedDecl = R.getFoundDecl();\n  return isa<TypedefNameDecl>(ShadowedDecl) ? ShadowedDecl : nullptr;\n}\n\n/// Return the declaration shadowed by the given variable \\p D, or null\n/// if it doesn't shadow any declaration or shadowing warnings are disabled.\nNamedDecl *Sema::getShadowedDeclaration(const BindingDecl *D,\n                                        const LookupResult &R) {\n  if (!shouldWarnIfShadowedDecl(Diags, R))\n    return nullptr;\n\n  NamedDecl *ShadowedDecl = R.getFoundDecl();\n  return isa<VarDecl, FieldDecl, BindingDecl>(ShadowedDecl) ? ShadowedDecl\n                                                            : nullptr;\n}\n\n/// Diagnose variable or built-in function shadowing.  Implements\n/// -Wshadow.\n///\n/// This method is called whenever a VarDecl is added to a \"useful\"\n/// scope.\n///\n/// \\param ShadowedDecl the declaration that is shadowed by the given variable\n/// \\param R the lookup of the name\n///\nvoid Sema::CheckShadow(NamedDecl *D, NamedDecl *ShadowedDecl,\n                       const LookupResult &R) {\n  DeclContext *NewDC = D->getDeclContext();\n\n  if (FieldDecl *FD = dyn_cast<FieldDecl>(ShadowedDecl)) {\n    // Fields are not shadowed by variables in C++ static methods.\n    if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(NewDC))\n      if (MD->isStatic())\n        return;\n\n    // Fields shadowed by constructor parameters are a special case. Usually\n    // the constructor initializes the field with the parameter.\n    if (isa<CXXConstructorDecl>(NewDC))\n      if (const auto PVD = dyn_cast<ParmVarDecl>(D)) {\n        // Remember that this was shadowed so we can either warn about its\n        // modification or its existence depending on warning settings.\n        ShadowingDecls.insert({PVD->getCanonicalDecl(), FD});\n        return;\n      }\n  }\n\n  if (VarDecl *shadowedVar = dyn_cast<VarDecl>(ShadowedDecl))\n    if (shadowedVar->isExternC()) {\n      // For shadowing external vars, make sure that we point to the global\n      // declaration, not a locally scoped extern declaration.\n      for (auto I : shadowedVar->redecls())\n        if (I->isFileVarDecl()) {\n          ShadowedDecl = I;\n          break;\n        }\n    }\n\n  DeclContext *OldDC = ShadowedDecl->getDeclContext()->getRedeclContext();\n\n  unsigned WarningDiag = diag::warn_decl_shadow;\n  SourceLocation CaptureLoc;\n  if (isa<VarDecl>(D) && isa<VarDecl>(ShadowedDecl) && NewDC &&\n      isa<CXXMethodDecl>(NewDC)) {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(NewDC->getParent())) {\n      if (RD->isLambda() && OldDC->Encloses(NewDC->getLexicalParent())) {\n        if (RD->getLambdaCaptureDefault() == LCD_None) {\n          // Try to avoid warnings for lambdas with an explicit capture list.\n          const auto *LSI = cast<LambdaScopeInfo>(getCurFunction());\n          // Warn only when the lambda captures the shadowed decl explicitly.\n          CaptureLoc = getCaptureLocation(LSI, cast<VarDecl>(ShadowedDecl));\n          if (CaptureLoc.isInvalid())\n            WarningDiag = diag::warn_decl_shadow_uncaptured_local;\n        } else {\n          // Remember that this was shadowed so we can avoid the warning if the\n          // shadowed decl isn't captured and the warning settings allow it.\n          cast<LambdaScopeInfo>(getCurFunction())\n              ->ShadowingDecls.push_back(\n                  {cast<VarDecl>(D), cast<VarDecl>(ShadowedDecl)});\n          return;\n        }\n      }\n\n      if (cast<VarDecl>(ShadowedDecl)->hasLocalStorage()) {\n        // A variable can't shadow a local variable in an enclosing scope, if\n        // they are separated by a non-capturing declaration context.\n        for (DeclContext *ParentDC = NewDC;\n             ParentDC && !ParentDC->Equals(OldDC);\n             ParentDC = getLambdaAwareParentOfDeclContext(ParentDC)) {\n          // Only block literals, captured statements, and lambda expressions\n          // can capture; other scopes don't.\n          if (!isa<BlockDecl>(ParentDC) && !isa<CapturedDecl>(ParentDC) &&\n              !isLambdaCallOperator(ParentDC)) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  // Only warn about certain kinds of shadowing for class members.\n  if (NewDC && NewDC->isRecord()) {\n    // In particular, don't warn about shadowing non-class members.\n    if (!OldDC->isRecord())\n      return;\n\n    // TODO: should we warn about static data members shadowing\n    // static data members from base classes?\n\n    // TODO: don't diagnose for inaccessible shadowed members.\n    // This is hard to do perfectly because we might friend the\n    // shadowing context, but that's just a false negative.\n  }\n\n\n  DeclarationName Name = R.getLookupName();\n\n  // Emit warning and note.\n  if (getSourceManager().isInSystemMacro(R.getNameLoc()))\n    return;\n  ShadowedDeclKind Kind = computeShadowedDeclKind(ShadowedDecl, OldDC);\n  Diag(R.getNameLoc(), WarningDiag) << Name << Kind << OldDC;\n  if (!CaptureLoc.isInvalid())\n    Diag(CaptureLoc, diag::note_var_explicitly_captured_here)\n        << Name << /*explicitly*/ 1;\n  Diag(ShadowedDecl->getLocation(), diag::note_previous_declaration);\n}\n\n/// Diagnose shadowing for variables shadowed in the lambda record \\p LambdaRD\n/// when these variables are captured by the lambda.\nvoid Sema::DiagnoseShadowingLambdaDecls(const LambdaScopeInfo *LSI) {\n  for (const auto &Shadow : LSI->ShadowingDecls) {\n    const VarDecl *ShadowedDecl = Shadow.ShadowedDecl;\n    // Try to avoid the warning when the shadowed decl isn't captured.\n    SourceLocation CaptureLoc = getCaptureLocation(LSI, ShadowedDecl);\n    const DeclContext *OldDC = ShadowedDecl->getDeclContext();\n    Diag(Shadow.VD->getLocation(), CaptureLoc.isInvalid()\n                                       ? diag::warn_decl_shadow_uncaptured_local\n                                       : diag::warn_decl_shadow)\n        << Shadow.VD->getDeclName()\n        << computeShadowedDeclKind(ShadowedDecl, OldDC) << OldDC;\n    if (!CaptureLoc.isInvalid())\n      Diag(CaptureLoc, diag::note_var_explicitly_captured_here)\n          << Shadow.VD->getDeclName() << /*explicitly*/ 0;\n    Diag(ShadowedDecl->getLocation(), diag::note_previous_declaration);\n  }\n}\n\n/// Check -Wshadow without the advantage of a previous lookup.\nvoid Sema::CheckShadow(Scope *S, VarDecl *D) {\n  if (Diags.isIgnored(diag::warn_decl_shadow, D->getLocation()))\n    return;\n\n  LookupResult R(*this, D->getDeclName(), D->getLocation(),\n                 Sema::LookupOrdinaryName, Sema::ForVisibleRedeclaration);\n  LookupName(R, S);\n  if (NamedDecl *ShadowedDecl = getShadowedDeclaration(D, R))\n    CheckShadow(D, ShadowedDecl, R);\n}\n\n/// Check if 'E', which is an expression that is about to be modified, refers\n/// to a constructor parameter that shadows a field.\nvoid Sema::CheckShadowingDeclModification(Expr *E, SourceLocation Loc) {\n  // Quickly ignore expressions that can't be shadowing ctor parameters.\n  if (!getLangOpts().CPlusPlus || ShadowingDecls.empty())\n    return;\n  E = E->IgnoreParenImpCasts();\n  auto *DRE = dyn_cast<DeclRefExpr>(E);\n  if (!DRE)\n    return;\n  const NamedDecl *D = cast<NamedDecl>(DRE->getDecl()->getCanonicalDecl());\n  auto I = ShadowingDecls.find(D);\n  if (I == ShadowingDecls.end())\n    return;\n  const NamedDecl *ShadowedDecl = I->second;\n  const DeclContext *OldDC = ShadowedDecl->getDeclContext();\n  Diag(Loc, diag::warn_modifying_shadowing_decl) << D << OldDC;\n  Diag(D->getLocation(), diag::note_var_declared_here) << D;\n  Diag(ShadowedDecl->getLocation(), diag::note_previous_declaration);\n\n  // Avoid issuing multiple warnings about the same decl.\n  ShadowingDecls.erase(I);\n}\n\n/// Check for conflict between this global or extern \"C\" declaration and\n/// previous global or extern \"C\" declarations. This is only used in C++.\ntemplate<typename T>\nstatic bool checkGlobalOrExternCConflict(\n    Sema &S, const T *ND, bool IsGlobal, LookupResult &Previous) {\n  assert(S.getLangOpts().CPlusPlus && \"only C++ has extern \\\"C\\\"\");\n  NamedDecl *Prev = S.findLocallyScopedExternCDecl(ND->getDeclName());\n\n  if (!Prev && IsGlobal && !isIncompleteDeclExternC(S, ND)) {\n    // The common case: this global doesn't conflict with any extern \"C\"\n    // declaration.\n    return false;\n  }\n\n  if (Prev) {\n    if (!IsGlobal || isIncompleteDeclExternC(S, ND)) {\n      // Both the old and new declarations have C language linkage. This is a\n      // redeclaration.\n      Previous.clear();\n      Previous.addDecl(Prev);\n      return true;\n    }\n\n    // This is a global, non-extern \"C\" declaration, and there is a previous\n    // non-global extern \"C\" declaration. Diagnose if this is a variable\n    // declaration.\n    if (!isa<VarDecl>(ND))\n      return false;\n  } else {\n    // The declaration is extern \"C\". Check for any declaration in the\n    // translation unit which might conflict.\n    if (IsGlobal) {\n      // We have already performed the lookup into the translation unit.\n      IsGlobal = false;\n      for (LookupResult::iterator I = Previous.begin(), E = Previous.end();\n           I != E; ++I) {\n        if (isa<VarDecl>(*I)) {\n          Prev = *I;\n          break;\n        }\n      }\n    } else {\n      DeclContext::lookup_result R =\n          S.Context.getTranslationUnitDecl()->lookup(ND->getDeclName());\n      for (DeclContext::lookup_result::iterator I = R.begin(), E = R.end();\n           I != E; ++I) {\n        if (isa<VarDecl>(*I)) {\n          Prev = *I;\n          break;\n        }\n        // FIXME: If we have any other entity with this name in global scope,\n        // the declaration is ill-formed, but that is a defect: it breaks the\n        // 'stat' hack, for instance. Only variables can have mangled name\n        // clashes with extern \"C\" declarations, so only they deserve a\n        // diagnostic.\n      }\n    }\n\n    if (!Prev)\n      return false;\n  }\n\n  // Use the first declaration's location to ensure we point at something which\n  // is lexically inside an extern \"C\" linkage-spec.\n  assert(Prev && \"should have found a previous declaration to diagnose\");\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(Prev))\n    Prev = FD->getFirstDecl();\n  else\n    Prev = cast<VarDecl>(Prev)->getFirstDecl();\n\n  S.Diag(ND->getLocation(), diag::err_extern_c_global_conflict)\n    << IsGlobal << ND;\n  S.Diag(Prev->getLocation(), diag::note_extern_c_global_conflict)\n    << IsGlobal;\n  return false;\n}\n\n/// Apply special rules for handling extern \"C\" declarations. Returns \\c true\n/// if we have found that this is a redeclaration of some prior entity.\n///\n/// Per C++ [dcl.link]p6:\n///   Two declarations [for a function or variable] with C language linkage\n///   with the same name that appear in different scopes refer to the same\n///   [entity]. An entity with C language linkage shall not be declared with\n///   the same name as an entity in global scope.\ntemplate<typename T>\nstatic bool checkForConflictWithNonVisibleExternC(Sema &S, const T *ND,\n                                                  LookupResult &Previous) {\n  if (!S.getLangOpts().CPlusPlus) {\n    // In C, when declaring a global variable, look for a corresponding 'extern'\n    // variable declared in function scope. We don't need this in C++, because\n    // we find local extern decls in the surrounding file-scope DeclContext.\n    if (ND->getDeclContext()->getRedeclContext()->isTranslationUnit()) {\n      if (NamedDecl *Prev = S.findLocallyScopedExternCDecl(ND->getDeclName())) {\n        Previous.clear();\n        Previous.addDecl(Prev);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // A declaration in the translation unit can conflict with an extern \"C\"\n  // declaration.\n  if (ND->getDeclContext()->getRedeclContext()->isTranslationUnit())\n    return checkGlobalOrExternCConflict(S, ND, /*IsGlobal*/true, Previous);\n\n  // An extern \"C\" declaration can conflict with a declaration in the\n  // translation unit or can be a redeclaration of an extern \"C\" declaration\n  // in another scope.\n  if (isIncompleteDeclExternC(S,ND))\n    return checkGlobalOrExternCConflict(S, ND, /*IsGlobal*/false, Previous);\n\n  // Neither global nor extern \"C\": nothing to do.\n  return false;\n}\n\nvoid Sema::CheckVariableDeclarationType(VarDecl *NewVD) {\n  // If the decl is already known invalid, don't check it.\n  if (NewVD->isInvalidDecl())\n    return;\n\n  QualType T = NewVD->getType();\n\n  // Defer checking an 'auto' type until its initializer is attached.\n  if (T->isUndeducedType())\n    return;\n\n  if (NewVD->hasAttrs())\n    CheckAlignasUnderalignment(NewVD);\n\n  if (T->isObjCObjectType()) {\n    Diag(NewVD->getLocation(), diag::err_statically_allocated_object)\n      << FixItHint::CreateInsertion(NewVD->getLocation(), \"*\");\n    T = Context.getObjCObjectPointerType(T);\n    NewVD->setType(T);\n  }\n\n  // Emit an error if an address space was applied to decl with local storage.\n  // This includes arrays of objects with address space qualifiers, but not\n  // automatic variables that point to other address spaces.\n  // ISO/IEC TR 18037 S5.1.2\n  if (!getLangOpts().OpenCL && NewVD->hasLocalStorage() &&\n      T.getAddressSpace() != LangAS::Default) {\n    Diag(NewVD->getLocation(), diag::err_as_qualified_auto_decl) << 0;\n    NewVD->setInvalidDecl();\n    return;\n  }\n\n  // OpenCL v1.2 s6.8 - The static qualifier is valid only in program\n  // scope.\n  if (getLangOpts().OpenCLVersion == 120 &&\n      !getOpenCLOptions().isEnabled(\"cl_clang_storage_class_specifiers\") &&\n      NewVD->isStaticLocal()) {\n    Diag(NewVD->getLocation(), diag::err_static_function_scope);\n    NewVD->setInvalidDecl();\n    return;\n  }\n\n  if (getLangOpts().OpenCL) {\n    // OpenCL v2.0 s6.12.5 - The __block storage type is not supported.\n    if (NewVD->hasAttr<BlocksAttr>()) {\n      Diag(NewVD->getLocation(), diag::err_opencl_block_storage_type);\n      return;\n    }\n\n    if (T->isBlockPointerType()) {\n      // OpenCL v2.0 s6.12.5 - Any block declaration must be const qualified and\n      // can't use 'extern' storage class.\n      if (!T.isConstQualified()) {\n        Diag(NewVD->getLocation(), diag::err_opencl_invalid_block_declaration)\n            << 0 /*const*/;\n        NewVD->setInvalidDecl();\n        return;\n      }\n      if (NewVD->hasExternalStorage()) {\n        Diag(NewVD->getLocation(), diag::err_opencl_extern_block_declaration);\n        NewVD->setInvalidDecl();\n        return;\n      }\n    }\n    // OpenCL C v1.2 s6.5 - All program scope variables must be declared in the\n    // __constant address space.\n    // OpenCL C v2.0 s6.5.1 - Variables defined at program scope and static\n    // variables inside a function can also be declared in the global\n    // address space.\n    // C++ for OpenCL inherits rule from OpenCL C v2.0.\n    // FIXME: Adding local AS in C++ for OpenCL might make sense.\n    if (NewVD->isFileVarDecl() || NewVD->isStaticLocal() ||\n        NewVD->hasExternalStorage()) {\n      if (!T->isSamplerT() &&\n          !T->isDependentType() &&\n          !(T.getAddressSpace() == LangAS::opencl_constant ||\n            (T.getAddressSpace() == LangAS::opencl_global &&\n             (getLangOpts().OpenCLVersion == 200 ||\n              getLangOpts().OpenCLCPlusPlus)))) {\n        int Scope = NewVD->isStaticLocal() | NewVD->hasExternalStorage() << 1;\n        if (getLangOpts().OpenCLVersion == 200 || getLangOpts().OpenCLCPlusPlus)\n          Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)\n              << Scope << \"global or constant\";\n        else\n          Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)\n              << Scope << \"constant\";\n        NewVD->setInvalidDecl();\n        return;\n      }\n    } else {\n      if (T.getAddressSpace() == LangAS::opencl_global) {\n        Diag(NewVD->getLocation(), diag::err_opencl_function_variable)\n            << 1 /*is any function*/ << \"global\";\n        NewVD->setInvalidDecl();\n        return;\n      }\n      if (T.getAddressSpace() == LangAS::opencl_constant ||\n          T.getAddressSpace() == LangAS::opencl_local) {\n        FunctionDecl *FD = getCurFunctionDecl();\n        // OpenCL v1.1 s6.5.2 and s6.5.3: no local or constant variables\n        // in functions.\n        if (FD && !FD->hasAttr<OpenCLKernelAttr>()) {\n          if (T.getAddressSpace() == LangAS::opencl_constant)\n            Diag(NewVD->getLocation(), diag::err_opencl_function_variable)\n                << 0 /*non-kernel only*/ << \"constant\";\n          else\n            Diag(NewVD->getLocation(), diag::err_opencl_function_variable)\n                << 0 /*non-kernel only*/ << \"local\";\n          NewVD->setInvalidDecl();\n          return;\n        }\n        // OpenCL v2.0 s6.5.2 and s6.5.3: local and constant variables must be\n        // in the outermost scope of a kernel function.\n        if (FD && FD->hasAttr<OpenCLKernelAttr>()) {\n          if (!getCurScope()->isFunctionScope()) {\n            if (T.getAddressSpace() == LangAS::opencl_constant)\n              Diag(NewVD->getLocation(), diag::err_opencl_addrspace_scope)\n                  << \"constant\";\n            else\n              Diag(NewVD->getLocation(), diag::err_opencl_addrspace_scope)\n                  << \"local\";\n            NewVD->setInvalidDecl();\n            return;\n          }\n        }\n      } else if (T.getAddressSpace() != LangAS::opencl_private &&\n                 // If we are parsing a template we didn't deduce an addr\n                 // space yet.\n                 T.getAddressSpace() != LangAS::Default) {\n        // Do not allow other address spaces on automatic variable.\n        Diag(NewVD->getLocation(), diag::err_as_qualified_auto_decl) << 1;\n        NewVD->setInvalidDecl();\n        return;\n      }\n    }\n  }\n\n  if (NewVD->hasLocalStorage() && T.isObjCGCWeak()\n      && !NewVD->hasAttr<BlocksAttr>()) {\n    if (getLangOpts().getGC() != LangOptions::NonGC)\n      Diag(NewVD->getLocation(), diag::warn_gc_attribute_weak_on_local);\n    else {\n      assert(!getLangOpts().ObjCAutoRefCount);\n      Diag(NewVD->getLocation(), diag::warn_attribute_weak_on_local);\n    }\n  }\n\n  bool isVM = T->isVariablyModifiedType();\n  if (isVM || NewVD->hasAttr<CleanupAttr>() ||\n      NewVD->hasAttr<BlocksAttr>())\n    setFunctionHasBranchProtectedScope();\n\n  if ((isVM && NewVD->hasLinkage()) ||\n      (T->isVariableArrayType() && NewVD->hasGlobalStorage())) {\n    bool SizeIsNegative;\n    llvm::APSInt Oversized;\n    TypeSourceInfo *FixedTInfo = TryToFixInvalidVariablyModifiedTypeSourceInfo(\n        NewVD->getTypeSourceInfo(), Context, SizeIsNegative, Oversized);\n    QualType FixedT;\n    if (FixedTInfo &&  T == NewVD->getTypeSourceInfo()->getType())\n      FixedT = FixedTInfo->getType();\n    else if (FixedTInfo) {\n      // Type and type-as-written are canonically different. We need to fix up\n      // both types separately.\n      FixedT = TryToFixInvalidVariablyModifiedType(T, Context, SizeIsNegative,\n                                                   Oversized);\n    }\n    if ((!FixedTInfo || FixedT.isNull()) && T->isVariableArrayType()) {\n      const VariableArrayType *VAT = Context.getAsVariableArrayType(T);\n      // FIXME: This won't give the correct result for\n      // int a[10][n];\n      SourceRange SizeRange = VAT->getSizeExpr()->getSourceRange();\n\n      if (NewVD->isFileVarDecl())\n        Diag(NewVD->getLocation(), diag::err_vla_decl_in_file_scope)\n        << SizeRange;\n      else if (NewVD->isStaticLocal())\n        Diag(NewVD->getLocation(), diag::err_vla_decl_has_static_storage)\n        << SizeRange;\n      else\n        Diag(NewVD->getLocation(), diag::err_vla_decl_has_extern_linkage)\n        << SizeRange;\n      NewVD->setInvalidDecl();\n      return;\n    }\n\n    if (!FixedTInfo) {\n      if (NewVD->isFileVarDecl())\n        Diag(NewVD->getLocation(), diag::err_vm_decl_in_file_scope);\n      else\n        Diag(NewVD->getLocation(), diag::err_vm_decl_has_extern_linkage);\n      NewVD->setInvalidDecl();\n      return;\n    }\n\n    Diag(NewVD->getLocation(), diag::ext_vla_folded_to_constant);\n    NewVD->setType(FixedT);\n    NewVD->setTypeSourceInfo(FixedTInfo);\n  }\n\n  if (T->isVoidType()) {\n    // C++98 [dcl.stc]p5: The extern specifier can be applied only to the names\n    //                    of objects and functions.\n    if (NewVD->isThisDeclarationADefinition() || getLangOpts().CPlusPlus) {\n      Diag(NewVD->getLocation(), diag::err_typecheck_decl_incomplete_type)\n        << T;\n      NewVD->setInvalidDecl();\n      return;\n    }\n  }\n\n  if (!NewVD->hasLocalStorage() && NewVD->hasAttr<BlocksAttr>()) {\n    Diag(NewVD->getLocation(), diag::err_block_on_nonlocal);\n    NewVD->setInvalidDecl();\n    return;\n  }\n\n  if (!NewVD->hasLocalStorage() && T->isSizelessType()) {\n    Diag(NewVD->getLocation(), diag::err_sizeless_nonlocal) << T;\n    NewVD->setInvalidDecl();\n    return;\n  }\n\n  if (isVM && NewVD->hasAttr<BlocksAttr>()) {\n    Diag(NewVD->getLocation(), diag::err_block_on_vm);\n    NewVD->setInvalidDecl();\n    return;\n  }\n\n  if (NewVD->isConstexpr() && !T->isDependentType() &&\n      RequireLiteralType(NewVD->getLocation(), T,\n                         diag::err_constexpr_var_non_literal)) {\n    NewVD->setInvalidDecl();\n    return;\n  }\n\n  // PPC MMA non-pointer types are not allowed as non-local variable types.\n  if (Context.getTargetInfo().getTriple().isPPC64() &&\n      !NewVD->isLocalVarDecl() &&\n      CheckPPCMMAType(T, NewVD->getLocation())) {\n    NewVD->setInvalidDecl();\n    return;\n  }\n}\n\n/// Perform semantic checking on a newly-created variable\n/// declaration.\n///\n/// This routine performs all of the type-checking required for a\n/// variable declaration once it has been built. It is used both to\n/// check variables after they have been parsed and their declarators\n/// have been translated into a declaration, and to check variables\n/// that have been instantiated from a template.\n///\n/// Sets NewVD->isInvalidDecl() if an error was encountered.\n///\n/// Returns true if the variable declaration is a redeclaration.\nbool Sema::CheckVariableDeclaration(VarDecl *NewVD, LookupResult &Previous) {\n  CheckVariableDeclarationType(NewVD);\n\n  // If the decl is already known invalid, don't check it.\n  if (NewVD->isInvalidDecl())\n    return false;\n\n  // If we did not find anything by this name, look for a non-visible\n  // extern \"C\" declaration with the same name.\n  if (Previous.empty() &&\n      checkForConflictWithNonVisibleExternC(*this, NewVD, Previous))\n    Previous.setShadowed();\n\n  if (!Previous.empty()) {\n    MergeVarDecl(NewVD, Previous);\n    return true;\n  }\n  return false;\n}\n\n/// AddOverriddenMethods - See if a method overrides any in the base classes,\n/// and if so, check that it's a valid override and remember it.\nbool Sema::AddOverriddenMethods(CXXRecordDecl *DC, CXXMethodDecl *MD) {\n  llvm::SmallPtrSet<const CXXMethodDecl*, 4> Overridden;\n\n  // Look for methods in base classes that this method might override.\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/false,\n                     /*DetectVirtual=*/false);\n  auto VisitBase = [&] (const CXXBaseSpecifier *Specifier, CXXBasePath &Path) {\n    CXXRecordDecl *BaseRecord = Specifier->getType()->getAsCXXRecordDecl();\n    DeclarationName Name = MD->getDeclName();\n\n    if (Name.getNameKind() == DeclarationName::CXXDestructorName) {\n      // We really want to find the base class destructor here.\n      QualType T = Context.getTypeDeclType(BaseRecord);\n      CanQualType CT = Context.getCanonicalType(T);\n      Name = Context.DeclarationNames.getCXXDestructorName(CT);\n    }\n\n    for (NamedDecl *BaseND : BaseRecord->lookup(Name)) {\n      CXXMethodDecl *BaseMD =\n          dyn_cast<CXXMethodDecl>(BaseND->getCanonicalDecl());\n      if (!BaseMD || !BaseMD->isVirtual() ||\n          IsOverload(MD, BaseMD, /*UseMemberUsingDeclRules=*/false,\n                     /*ConsiderCudaAttrs=*/true,\n                     // C++2a [class.virtual]p2 does not consider requires\n                     // clauses when overriding.\n                     /*ConsiderRequiresClauses=*/false))\n        continue;\n\n      if (Overridden.insert(BaseMD).second) {\n        MD->addOverriddenMethod(BaseMD);\n        CheckOverridingFunctionReturnType(MD, BaseMD);\n        CheckOverridingFunctionAttributes(MD, BaseMD);\n        CheckOverridingFunctionExceptionSpec(MD, BaseMD);\n        CheckIfOverriddenFunctionIsMarkedFinal(MD, BaseMD);\n      }\n\n      // A method can only override one function from each base class. We\n      // don't track indirectly overridden methods from bases of bases.\n      return true;\n    }\n\n    return false;\n  };\n\n  DC->lookupInBases(VisitBase, Paths);\n  return !Overridden.empty();\n}\n\nnamespace {\n  // Struct for holding all of the extra arguments needed by\n  // DiagnoseInvalidRedeclaration to call Sema::ActOnFunctionDeclarator.\n  struct ActOnFDArgs {\n    Scope *S;\n    Declarator &D;\n    MultiTemplateParamsArg TemplateParamLists;\n    bool AddToScope;\n  };\n} // end anonymous namespace\n\nnamespace {\n\n// Callback to only accept typo corrections that have a non-zero edit distance.\n// Also only accept corrections that have the same parent decl.\nclass DifferentNameValidatorCCC final : public CorrectionCandidateCallback {\n public:\n  DifferentNameValidatorCCC(ASTContext &Context, FunctionDecl *TypoFD,\n                            CXXRecordDecl *Parent)\n      : Context(Context), OriginalFD(TypoFD),\n        ExpectedParent(Parent ? Parent->getCanonicalDecl() : nullptr) {}\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    if (candidate.getEditDistance() == 0)\n      return false;\n\n    SmallVector<unsigned, 1> MismatchedParams;\n    for (TypoCorrection::const_decl_iterator CDecl = candidate.begin(),\n                                          CDeclEnd = candidate.end();\n         CDecl != CDeclEnd; ++CDecl) {\n      FunctionDecl *FD = dyn_cast<FunctionDecl>(*CDecl);\n\n      if (FD && !FD->hasBody() &&\n          hasSimilarParameters(Context, FD, OriginalFD, MismatchedParams)) {\n        if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD)) {\n          CXXRecordDecl *Parent = MD->getParent();\n          if (Parent && Parent->getCanonicalDecl() == ExpectedParent)\n            return true;\n        } else if (!ExpectedParent) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<DifferentNameValidatorCCC>(*this);\n  }\n\n private:\n  ASTContext &Context;\n  FunctionDecl *OriginalFD;\n  CXXRecordDecl *ExpectedParent;\n};\n\n} // end anonymous namespace\n\nvoid Sema::MarkTypoCorrectedFunctionDefinition(const NamedDecl *F) {\n  TypoCorrectedFunctionDefinitions.insert(F);\n}\n\n/// Generate diagnostics for an invalid function redeclaration.\n///\n/// This routine handles generating the diagnostic messages for an invalid\n/// function redeclaration, including finding possible similar declarations\n/// or performing typo correction if there are no previous declarations with\n/// the same name.\n///\n/// Returns a NamedDecl iff typo correction was performed and substituting in\n/// the new declaration name does not cause new errors.\nstatic NamedDecl *DiagnoseInvalidRedeclaration(\n    Sema &SemaRef, LookupResult &Previous, FunctionDecl *NewFD,\n    ActOnFDArgs &ExtraArgs, bool IsLocalFriend, Scope *S) {\n  DeclarationName Name = NewFD->getDeclName();\n  DeclContext *NewDC = NewFD->getDeclContext();\n  SmallVector<unsigned, 1> MismatchedParams;\n  SmallVector<std::pair<FunctionDecl *, unsigned>, 1> NearMatches;\n  TypoCorrection Correction;\n  bool IsDefinition = ExtraArgs.D.isFunctionDefinition();\n  unsigned DiagMsg =\n    IsLocalFriend ? diag::err_no_matching_local_friend :\n    NewFD->getFriendObjectKind() ? diag::err_qualified_friend_no_match :\n    diag::err_member_decl_does_not_match;\n  LookupResult Prev(SemaRef, Name, NewFD->getLocation(),\n                    IsLocalFriend ? Sema::LookupLocalFriendName\n                                  : Sema::LookupOrdinaryName,\n                    Sema::ForVisibleRedeclaration);\n\n  NewFD->setInvalidDecl();\n  if (IsLocalFriend)\n    SemaRef.LookupName(Prev, S);\n  else\n    SemaRef.LookupQualifiedName(Prev, NewDC);\n  assert(!Prev.isAmbiguous() &&\n         \"Cannot have an ambiguity in previous-declaration lookup\");\n  CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(NewFD);\n  DifferentNameValidatorCCC CCC(SemaRef.Context, NewFD,\n                                MD ? MD->getParent() : nullptr);\n  if (!Prev.empty()) {\n    for (LookupResult::iterator Func = Prev.begin(), FuncEnd = Prev.end();\n         Func != FuncEnd; ++Func) {\n      FunctionDecl *FD = dyn_cast<FunctionDecl>(*Func);\n      if (FD &&\n          hasSimilarParameters(SemaRef.Context, FD, NewFD, MismatchedParams)) {\n        // Add 1 to the index so that 0 can mean the mismatch didn't\n        // involve a parameter\n        unsigned ParamNum =\n            MismatchedParams.empty() ? 0 : MismatchedParams.front() + 1;\n        NearMatches.push_back(std::make_pair(FD, ParamNum));\n      }\n    }\n  // If the qualified name lookup yielded nothing, try typo correction\n  } else if ((Correction = SemaRef.CorrectTypo(\n                  Prev.getLookupNameInfo(), Prev.getLookupKind(), S,\n                  &ExtraArgs.D.getCXXScopeSpec(), CCC, Sema::CTK_ErrorRecovery,\n                  IsLocalFriend ? nullptr : NewDC))) {\n    // Set up everything for the call to ActOnFunctionDeclarator\n    ExtraArgs.D.SetIdentifier(Correction.getCorrectionAsIdentifierInfo(),\n                              ExtraArgs.D.getIdentifierLoc());\n    Previous.clear();\n    Previous.setLookupName(Correction.getCorrection());\n    for (TypoCorrection::decl_iterator CDecl = Correction.begin(),\n                                    CDeclEnd = Correction.end();\n         CDecl != CDeclEnd; ++CDecl) {\n      FunctionDecl *FD = dyn_cast<FunctionDecl>(*CDecl);\n      if (FD && !FD->hasBody() &&\n          hasSimilarParameters(SemaRef.Context, FD, NewFD, MismatchedParams)) {\n        Previous.addDecl(FD);\n      }\n    }\n    bool wasRedeclaration = ExtraArgs.D.isRedeclaration();\n\n    NamedDecl *Result;\n    // Retry building the function declaration with the new previous\n    // declarations, and with errors suppressed.\n    {\n      // Trap errors.\n      Sema::SFINAETrap Trap(SemaRef);\n\n      // TODO: Refactor ActOnFunctionDeclarator so that we can call only the\n      // pieces need to verify the typo-corrected C++ declaration and hopefully\n      // eliminate the need for the parameter pack ExtraArgs.\n      Result = SemaRef.ActOnFunctionDeclarator(\n          ExtraArgs.S, ExtraArgs.D,\n          Correction.getCorrectionDecl()->getDeclContext(),\n          NewFD->getTypeSourceInfo(), Previous, ExtraArgs.TemplateParamLists,\n          ExtraArgs.AddToScope);\n\n      if (Trap.hasErrorOccurred())\n        Result = nullptr;\n    }\n\n    if (Result) {\n      // Determine which correction we picked.\n      Decl *Canonical = Result->getCanonicalDecl();\n      for (LookupResult::iterator I = Previous.begin(), E = Previous.end();\n           I != E; ++I)\n        if ((*I)->getCanonicalDecl() == Canonical)\n          Correction.setCorrectionDecl(*I);\n\n      // Let Sema know about the correction.\n      SemaRef.MarkTypoCorrectedFunctionDefinition(Result);\n      SemaRef.diagnoseTypo(\n          Correction,\n          SemaRef.PDiag(IsLocalFriend\n                          ? diag::err_no_matching_local_friend_suggest\n                          : diag::err_member_decl_does_not_match_suggest)\n            << Name << NewDC << IsDefinition);\n      return Result;\n    }\n\n    // Pretend the typo correction never occurred\n    ExtraArgs.D.SetIdentifier(Name.getAsIdentifierInfo(),\n                              ExtraArgs.D.getIdentifierLoc());\n    ExtraArgs.D.setRedeclaration(wasRedeclaration);\n    Previous.clear();\n    Previous.setLookupName(Name);\n  }\n\n  SemaRef.Diag(NewFD->getLocation(), DiagMsg)\n      << Name << NewDC << IsDefinition << NewFD->getLocation();\n\n  bool NewFDisConst = false;\n  if (CXXMethodDecl *NewMD = dyn_cast<CXXMethodDecl>(NewFD))\n    NewFDisConst = NewMD->isConst();\n\n  for (SmallVectorImpl<std::pair<FunctionDecl *, unsigned> >::iterator\n       NearMatch = NearMatches.begin(), NearMatchEnd = NearMatches.end();\n       NearMatch != NearMatchEnd; ++NearMatch) {\n    FunctionDecl *FD = NearMatch->first;\n    CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD);\n    bool FDisConst = MD && MD->isConst();\n    bool IsMember = MD || !IsLocalFriend;\n\n    // FIXME: These notes are poorly worded for the local friend case.\n    if (unsigned Idx = NearMatch->second) {\n      ParmVarDecl *FDParam = FD->getParamDecl(Idx-1);\n      SourceLocation Loc = FDParam->getTypeSpecStartLoc();\n      if (Loc.isInvalid()) Loc = FD->getLocation();\n      SemaRef.Diag(Loc, IsMember ? diag::note_member_def_close_param_match\n                                 : diag::note_local_decl_close_param_match)\n        << Idx << FDParam->getType()\n        << NewFD->getParamDecl(Idx - 1)->getType();\n    } else if (FDisConst != NewFDisConst) {\n      SemaRef.Diag(FD->getLocation(), diag::note_member_def_close_const_match)\n          << NewFDisConst << FD->getSourceRange().getEnd();\n    } else\n      SemaRef.Diag(FD->getLocation(),\n                   IsMember ? diag::note_member_def_close_match\n                            : diag::note_local_decl_close_match);\n  }\n  return nullptr;\n}\n\nstatic StorageClass getFunctionStorageClass(Sema &SemaRef, Declarator &D) {\n  switch (D.getDeclSpec().getStorageClassSpec()) {\n  default: llvm_unreachable(\"Unknown storage class!\");\n  case DeclSpec::SCS_auto:\n  case DeclSpec::SCS_register:\n  case DeclSpec::SCS_mutable:\n    SemaRef.Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n                 diag::err_typecheck_sclass_func);\n    D.getMutableDeclSpec().ClearStorageClassSpecs();\n    D.setInvalidType();\n    break;\n  case DeclSpec::SCS_unspecified: break;\n  case DeclSpec::SCS_extern:\n    if (D.getDeclSpec().isExternInLinkageSpec())\n      return SC_None;\n    return SC_Extern;\n  case DeclSpec::SCS_static: {\n    if (SemaRef.CurContext->getRedeclContext()->isFunctionOrMethod()) {\n      // C99 6.7.1p5:\n      //   The declaration of an identifier for a function that has\n      //   block scope shall have no explicit storage-class specifier\n      //   other than extern\n      // See also (C++ [dcl.stc]p4).\n      SemaRef.Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n                   diag::err_static_block_func);\n      break;\n    } else\n      return SC_Static;\n  }\n  case DeclSpec::SCS_private_extern: return SC_PrivateExtern;\n  }\n\n  // No explicit storage class has already been returned\n  return SC_None;\n}\n\nstatic FunctionDecl *CreateNewFunctionDecl(Sema &SemaRef, Declarator &D,\n                                           DeclContext *DC, QualType &R,\n                                           TypeSourceInfo *TInfo,\n                                           StorageClass SC,\n                                           bool &IsVirtualOkay) {\n  DeclarationNameInfo NameInfo = SemaRef.GetNameForDeclarator(D);\n  DeclarationName Name = NameInfo.getName();\n\n  FunctionDecl *NewFD = nullptr;\n  bool isInline = D.getDeclSpec().isInlineSpecified();\n\n  if (!SemaRef.getLangOpts().CPlusPlus) {\n    // Determine whether the function was written with a\n    // prototype. This true when:\n    //   - there is a prototype in the declarator, or\n    //   - the type R of the function is some kind of typedef or other non-\n    //     attributed reference to a type name (which eventually refers to a\n    //     function type).\n    bool HasPrototype =\n      (D.isFunctionDeclarator() && D.getFunctionTypeInfo().hasPrototype) ||\n      (!R->getAsAdjusted<FunctionType>() && R->isFunctionProtoType());\n\n    NewFD = FunctionDecl::Create(SemaRef.Context, DC, D.getBeginLoc(), NameInfo,\n                                 R, TInfo, SC, isInline, HasPrototype,\n                                 ConstexprSpecKind::Unspecified,\n                                 /*TrailingRequiresClause=*/nullptr);\n    if (D.isInvalidType())\n      NewFD->setInvalidDecl();\n\n    return NewFD;\n  }\n\n  ExplicitSpecifier ExplicitSpecifier = D.getDeclSpec().getExplicitSpecifier();\n\n  ConstexprSpecKind ConstexprKind = D.getDeclSpec().getConstexprSpecifier();\n  if (ConstexprKind == ConstexprSpecKind::Constinit) {\n    SemaRef.Diag(D.getDeclSpec().getConstexprSpecLoc(),\n                 diag::err_constexpr_wrong_decl_kind)\n        << static_cast<int>(ConstexprKind);\n    ConstexprKind = ConstexprSpecKind::Unspecified;\n    D.getMutableDeclSpec().ClearConstexprSpec();\n  }\n  Expr *TrailingRequiresClause = D.getTrailingRequiresClause();\n\n  // Check that the return type is not an abstract class type.\n  // For record types, this is done by the AbstractClassUsageDiagnoser once\n  // the class has been completely parsed.\n  if (!DC->isRecord() &&\n      SemaRef.RequireNonAbstractType(\n          D.getIdentifierLoc(), R->castAs<FunctionType>()->getReturnType(),\n          diag::err_abstract_type_in_decl, SemaRef.AbstractReturnType))\n    D.setInvalidType();\n\n  if (Name.getNameKind() == DeclarationName::CXXConstructorName) {\n    // This is a C++ constructor declaration.\n    assert(DC->isRecord() &&\n           \"Constructors can only be declared in a member context\");\n\n    R = SemaRef.CheckConstructorDeclarator(D, R, SC);\n    return CXXConstructorDecl::Create(\n        SemaRef.Context, cast<CXXRecordDecl>(DC), D.getBeginLoc(), NameInfo, R,\n        TInfo, ExplicitSpecifier, isInline,\n        /*isImplicitlyDeclared=*/false, ConstexprKind, InheritedConstructor(),\n        TrailingRequiresClause);\n\n  } else if (Name.getNameKind() == DeclarationName::CXXDestructorName) {\n    // This is a C++ destructor declaration.\n    if (DC->isRecord()) {\n      R = SemaRef.CheckDestructorDeclarator(D, R, SC);\n      CXXRecordDecl *Record = cast<CXXRecordDecl>(DC);\n      CXXDestructorDecl *NewDD = CXXDestructorDecl::Create(\n          SemaRef.Context, Record, D.getBeginLoc(), NameInfo, R, TInfo,\n          isInline, /*isImplicitlyDeclared=*/false, ConstexprKind,\n          TrailingRequiresClause);\n\n      // If the destructor needs an implicit exception specification, set it\n      // now. FIXME: It'd be nice to be able to create the right type to start\n      // with, but the type needs to reference the destructor declaration.\n      if (SemaRef.getLangOpts().CPlusPlus11)\n        SemaRef.AdjustDestructorExceptionSpec(NewDD);\n\n      IsVirtualOkay = true;\n      return NewDD;\n\n    } else {\n      SemaRef.Diag(D.getIdentifierLoc(), diag::err_destructor_not_member);\n      D.setInvalidType();\n\n      // Create a FunctionDecl to satisfy the function definition parsing\n      // code path.\n      return FunctionDecl::Create(SemaRef.Context, DC, D.getBeginLoc(),\n                                  D.getIdentifierLoc(), Name, R, TInfo, SC,\n                                  isInline,\n                                  /*hasPrototype=*/true, ConstexprKind,\n                                  TrailingRequiresClause);\n    }\n\n  } else if (Name.getNameKind() == DeclarationName::CXXConversionFunctionName) {\n    if (!DC->isRecord()) {\n      SemaRef.Diag(D.getIdentifierLoc(),\n           diag::err_conv_function_not_member);\n      return nullptr;\n    }\n\n    SemaRef.CheckConversionDeclarator(D, R, SC);\n    if (D.isInvalidType())\n      return nullptr;\n\n    IsVirtualOkay = true;\n    return CXXConversionDecl::Create(\n        SemaRef.Context, cast<CXXRecordDecl>(DC), D.getBeginLoc(), NameInfo, R,\n        TInfo, isInline, ExplicitSpecifier, ConstexprKind, SourceLocation(),\n        TrailingRequiresClause);\n\n  } else if (Name.getNameKind() == DeclarationName::CXXDeductionGuideName) {\n    if (TrailingRequiresClause)\n      SemaRef.Diag(TrailingRequiresClause->getBeginLoc(),\n                   diag::err_trailing_requires_clause_on_deduction_guide)\n          << TrailingRequiresClause->getSourceRange();\n    SemaRef.CheckDeductionGuideDeclarator(D, R, SC);\n\n    return CXXDeductionGuideDecl::Create(SemaRef.Context, DC, D.getBeginLoc(),\n                                         ExplicitSpecifier, NameInfo, R, TInfo,\n                                         D.getEndLoc());\n  } else if (DC->isRecord()) {\n    // If the name of the function is the same as the name of the record,\n    // then this must be an invalid constructor that has a return type.\n    // (The parser checks for a return type and makes the declarator a\n    // constructor if it has no return type).\n    if (Name.getAsIdentifierInfo() &&\n        Name.getAsIdentifierInfo() == cast<CXXRecordDecl>(DC)->getIdentifier()){\n      SemaRef.Diag(D.getIdentifierLoc(), diag::err_constructor_return_type)\n        << SourceRange(D.getDeclSpec().getTypeSpecTypeLoc())\n        << SourceRange(D.getIdentifierLoc());\n      return nullptr;\n    }\n\n    // This is a C++ method declaration.\n    CXXMethodDecl *Ret = CXXMethodDecl::Create(\n        SemaRef.Context, cast<CXXRecordDecl>(DC), D.getBeginLoc(), NameInfo, R,\n        TInfo, SC, isInline, ConstexprKind, SourceLocation(),\n        TrailingRequiresClause);\n    IsVirtualOkay = !Ret->isStatic();\n    return Ret;\n  } else {\n    bool isFriend =\n        SemaRef.getLangOpts().CPlusPlus && D.getDeclSpec().isFriendSpecified();\n    if (!isFriend && SemaRef.CurContext->isRecord())\n      return nullptr;\n\n    // Determine whether the function was written with a\n    // prototype. This true when:\n    //   - we're in C++ (where every function has a prototype),\n    return FunctionDecl::Create(SemaRef.Context, DC, D.getBeginLoc(), NameInfo,\n                                R, TInfo, SC, isInline, true /*HasPrototype*/,\n                                ConstexprKind, TrailingRequiresClause);\n  }\n}\n\nenum OpenCLParamType {\n  ValidKernelParam,\n  PtrPtrKernelParam,\n  PtrKernelParam,\n  InvalidAddrSpacePtrKernelParam,\n  InvalidKernelParam,\n  RecordKernelParam\n};\n\nstatic bool isOpenCLSizeDependentType(ASTContext &C, QualType Ty) {\n  // Size dependent types are just typedefs to normal integer types\n  // (e.g. unsigned long), so we cannot distinguish them from other typedefs to\n  // integers other than by their names.\n  StringRef SizeTypeNames[] = {\"size_t\", \"intptr_t\", \"uintptr_t\", \"ptrdiff_t\"};\n\n  // Remove typedefs one by one until we reach a typedef\n  // for a size dependent type.\n  QualType DesugaredTy = Ty;\n  do {\n    ArrayRef<StringRef> Names(SizeTypeNames);\n    auto Match = llvm::find(Names, DesugaredTy.getUnqualifiedType().getAsString());\n    if (Names.end() != Match)\n      return true;\n\n    Ty = DesugaredTy;\n    DesugaredTy = Ty.getSingleStepDesugaredType(C);\n  } while (DesugaredTy != Ty);\n\n  return false;\n}\n\nstatic OpenCLParamType getOpenCLKernelParameterType(Sema &S, QualType PT) {\n  if (PT->isPointerType()) {\n    QualType PointeeType = PT->getPointeeType();\n    if (PointeeType.getAddressSpace() == LangAS::opencl_generic ||\n        PointeeType.getAddressSpace() == LangAS::opencl_private ||\n        PointeeType.getAddressSpace() == LangAS::Default)\n      return InvalidAddrSpacePtrKernelParam;\n\n    if (PointeeType->isPointerType()) {\n      // This is a pointer to pointer parameter.\n      // Recursively check inner type.\n      OpenCLParamType ParamKind = getOpenCLKernelParameterType(S, PointeeType);\n      if (ParamKind == InvalidAddrSpacePtrKernelParam ||\n          ParamKind == InvalidKernelParam)\n        return ParamKind;\n\n      return PtrPtrKernelParam;\n    }\n    return PtrKernelParam;\n  }\n\n  // OpenCL v1.2 s6.9.k:\n  // Arguments to kernel functions in a program cannot be declared with the\n  // built-in scalar types bool, half, size_t, ptrdiff_t, intptr_t, and\n  // uintptr_t or a struct and/or union that contain fields declared to be one\n  // of these built-in scalar types.\n  if (isOpenCLSizeDependentType(S.getASTContext(), PT))\n    return InvalidKernelParam;\n\n  if (PT->isImageType())\n    return PtrKernelParam;\n\n  if (PT->isBooleanType() || PT->isEventT() || PT->isReserveIDT())\n    return InvalidKernelParam;\n\n  // OpenCL extension spec v1.2 s9.5:\n  // This extension adds support for half scalar and vector types as built-in\n  // types that can be used for arithmetic operations, conversions etc.\n  if (!S.getOpenCLOptions().isEnabled(\"cl_khr_fp16\") && PT->isHalfType())\n    return InvalidKernelParam;\n\n  if (PT->isRecordType())\n    return RecordKernelParam;\n\n  // Look into an array argument to check if it has a forbidden type.\n  if (PT->isArrayType()) {\n    const Type *UnderlyingTy = PT->getPointeeOrArrayElementType();\n    // Call ourself to check an underlying type of an array. Since the\n    // getPointeeOrArrayElementType returns an innermost type which is not an\n    // array, this recursive call only happens once.\n    return getOpenCLKernelParameterType(S, QualType(UnderlyingTy, 0));\n  }\n\n  return ValidKernelParam;\n}\n\nstatic void checkIsValidOpenCLKernelParameter(\n  Sema &S,\n  Declarator &D,\n  ParmVarDecl *Param,\n  llvm::SmallPtrSetImpl<const Type *> &ValidTypes) {\n  QualType PT = Param->getType();\n\n  // Cache the valid types we encounter to avoid rechecking structs that are\n  // used again\n  if (ValidTypes.count(PT.getTypePtr()))\n    return;\n\n  switch (getOpenCLKernelParameterType(S, PT)) {\n  case PtrPtrKernelParam:\n    // OpenCL v3.0 s6.11.a:\n    // A kernel function argument cannot be declared as a pointer to a pointer\n    // type. [...] This restriction only applies to OpenCL C 1.2 or below.\n    if (S.getLangOpts().OpenCLVersion < 120 &&\n        !S.getLangOpts().OpenCLCPlusPlus) {\n      S.Diag(Param->getLocation(), diag::err_opencl_ptrptr_kernel_param);\n      D.setInvalidType();\n      return;\n    }\n\n    ValidTypes.insert(PT.getTypePtr());\n    return;\n\n  case InvalidAddrSpacePtrKernelParam:\n    // OpenCL v1.0 s6.5:\n    // __kernel function arguments declared to be a pointer of a type can point\n    // to one of the following address spaces only : __global, __local or\n    // __constant.\n    S.Diag(Param->getLocation(), diag::err_kernel_arg_address_space);\n    D.setInvalidType();\n    return;\n\n    // OpenCL v1.2 s6.9.k:\n    // Arguments to kernel functions in a program cannot be declared with the\n    // built-in scalar types bool, half, size_t, ptrdiff_t, intptr_t, and\n    // uintptr_t or a struct and/or union that contain fields declared to be\n    // one of these built-in scalar types.\n\n  case InvalidKernelParam:\n    // OpenCL v1.2 s6.8 n:\n    // A kernel function argument cannot be declared\n    // of event_t type.\n    // Do not diagnose half type since it is diagnosed as invalid argument\n    // type for any function elsewhere.\n    if (!PT->isHalfType()) {\n      S.Diag(Param->getLocation(), diag::err_bad_kernel_param_type) << PT;\n\n      // Explain what typedefs are involved.\n      const TypedefType *Typedef = nullptr;\n      while ((Typedef = PT->getAs<TypedefType>())) {\n        SourceLocation Loc = Typedef->getDecl()->getLocation();\n        // SourceLocation may be invalid for a built-in type.\n        if (Loc.isValid())\n          S.Diag(Loc, diag::note_entity_declared_at) << PT;\n        PT = Typedef->desugar();\n      }\n    }\n\n    D.setInvalidType();\n    return;\n\n  case PtrKernelParam:\n  case ValidKernelParam:\n    ValidTypes.insert(PT.getTypePtr());\n    return;\n\n  case RecordKernelParam:\n    break;\n  }\n\n  // Track nested structs we will inspect\n  SmallVector<const Decl *, 4> VisitStack;\n\n  // Track where we are in the nested structs. Items will migrate from\n  // VisitStack to HistoryStack as we do the DFS for bad field.\n  SmallVector<const FieldDecl *, 4> HistoryStack;\n  HistoryStack.push_back(nullptr);\n\n  // At this point we already handled everything except of a RecordType or\n  // an ArrayType of a RecordType.\n  assert((PT->isArrayType() || PT->isRecordType()) && \"Unexpected type.\");\n  const RecordType *RecTy =\n      PT->getPointeeOrArrayElementType()->getAs<RecordType>();\n  const RecordDecl *OrigRecDecl = RecTy->getDecl();\n\n  VisitStack.push_back(RecTy->getDecl());\n  assert(VisitStack.back() && \"First decl null?\");\n\n  do {\n    const Decl *Next = VisitStack.pop_back_val();\n    if (!Next) {\n      assert(!HistoryStack.empty());\n      // Found a marker, we have gone up a level\n      if (const FieldDecl *Hist = HistoryStack.pop_back_val())\n        ValidTypes.insert(Hist->getType().getTypePtr());\n\n      continue;\n    }\n\n    // Adds everything except the original parameter declaration (which is not a\n    // field itself) to the history stack.\n    const RecordDecl *RD;\n    if (const FieldDecl *Field = dyn_cast<FieldDecl>(Next)) {\n      HistoryStack.push_back(Field);\n\n      QualType FieldTy = Field->getType();\n      // Other field types (known to be valid or invalid) are handled while we\n      // walk around RecordDecl::fields().\n      assert((FieldTy->isArrayType() || FieldTy->isRecordType()) &&\n             \"Unexpected type.\");\n      const Type *FieldRecTy = FieldTy->getPointeeOrArrayElementType();\n\n      RD = FieldRecTy->castAs<RecordType>()->getDecl();\n    } else {\n      RD = cast<RecordDecl>(Next);\n    }\n\n    // Add a null marker so we know when we've gone back up a level\n    VisitStack.push_back(nullptr);\n\n    for (const auto *FD : RD->fields()) {\n      QualType QT = FD->getType();\n\n      if (ValidTypes.count(QT.getTypePtr()))\n        continue;\n\n      OpenCLParamType ParamType = getOpenCLKernelParameterType(S, QT);\n      if (ParamType == ValidKernelParam)\n        continue;\n\n      if (ParamType == RecordKernelParam) {\n        VisitStack.push_back(FD);\n        continue;\n      }\n\n      // OpenCL v1.2 s6.9.p:\n      // Arguments to kernel functions that are declared to be a struct or union\n      // do not allow OpenCL objects to be passed as elements of the struct or\n      // union.\n      if (ParamType == PtrKernelParam || ParamType == PtrPtrKernelParam ||\n          ParamType == InvalidAddrSpacePtrKernelParam) {\n        S.Diag(Param->getLocation(),\n               diag::err_record_with_pointers_kernel_param)\n          << PT->isUnionType()\n          << PT;\n      } else {\n        S.Diag(Param->getLocation(), diag::err_bad_kernel_param_type) << PT;\n      }\n\n      S.Diag(OrigRecDecl->getLocation(), diag::note_within_field_of_type)\n          << OrigRecDecl->getDeclName();\n\n      // We have an error, now let's go back up through history and show where\n      // the offending field came from\n      for (ArrayRef<const FieldDecl *>::const_iterator\n               I = HistoryStack.begin() + 1,\n               E = HistoryStack.end();\n           I != E; ++I) {\n        const FieldDecl *OuterField = *I;\n        S.Diag(OuterField->getLocation(), diag::note_within_field_of_type)\n          << OuterField->getType();\n      }\n\n      S.Diag(FD->getLocation(), diag::note_illegal_field_declared_here)\n        << QT->isPointerType()\n        << QT;\n      D.setInvalidType();\n      return;\n    }\n  } while (!VisitStack.empty());\n}\n\n/// Find the DeclContext in which a tag is implicitly declared if we see an\n/// elaborated type specifier in the specified context, and lookup finds\n/// nothing.\nstatic DeclContext *getTagInjectionContext(DeclContext *DC) {\n  while (!DC->isFileContext() && !DC->isFunctionOrMethod())\n    DC = DC->getParent();\n  return DC;\n}\n\n/// Find the Scope in which a tag is implicitly declared if we see an\n/// elaborated type specifier in the specified context, and lookup finds\n/// nothing.\nstatic Scope *getTagInjectionScope(Scope *S, const LangOptions &LangOpts) {\n  while (S->isClassScope() ||\n         (LangOpts.CPlusPlus &&\n          S->isFunctionPrototypeScope()) ||\n         ((S->getFlags() & Scope::DeclScope) == 0) ||\n         (S->getEntity() && S->getEntity()->isTransparentContext()))\n    S = S->getParent();\n  return S;\n}\n\nNamedDecl*\nSema::ActOnFunctionDeclarator(Scope *S, Declarator &D, DeclContext *DC,\n                              TypeSourceInfo *TInfo, LookupResult &Previous,\n                              MultiTemplateParamsArg TemplateParamListsRef,\n                              bool &AddToScope) {\n  QualType R = TInfo->getType();\n\n  assert(R->isFunctionType());\n  if (R.getCanonicalType()->castAs<FunctionType>()->getCmseNSCallAttr())\n    Diag(D.getIdentifierLoc(), diag::err_function_decl_cmse_ns_call);\n\n  SmallVector<TemplateParameterList *, 4> TemplateParamLists;\n  for (TemplateParameterList *TPL : TemplateParamListsRef)\n    TemplateParamLists.push_back(TPL);\n  if (TemplateParameterList *Invented = D.getInventedTemplateParameterList()) {\n    if (!TemplateParamLists.empty() &&\n        Invented->getDepth() == TemplateParamLists.back()->getDepth())\n      TemplateParamLists.back() = Invented;\n    else\n      TemplateParamLists.push_back(Invented);\n  }\n\n  // TODO: consider using NameInfo for diagnostic.\n  DeclarationNameInfo NameInfo = GetNameForDeclarator(D);\n  DeclarationName Name = NameInfo.getName();\n  StorageClass SC = getFunctionStorageClass(*this, D);\n\n  if (DeclSpec::TSCS TSCS = D.getDeclSpec().getThreadStorageClassSpec())\n    Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n         diag::err_invalid_thread)\n      << DeclSpec::getSpecifierName(TSCS);\n\n  if (D.isFirstDeclarationOfMember())\n    adjustMemberFunctionCC(R, D.isStaticMember(), D.isCtorOrDtor(),\n                           D.getIdentifierLoc());\n\n  bool isFriend = false;\n  FunctionTemplateDecl *FunctionTemplate = nullptr;\n  bool isMemberSpecialization = false;\n  bool isFunctionTemplateSpecialization = false;\n\n  bool isDependentClassScopeExplicitSpecialization = false;\n  bool HasExplicitTemplateArgs = false;\n  TemplateArgumentListInfo TemplateArgs;\n\n  bool isVirtualOkay = false;\n\n  DeclContext *OriginalDC = DC;\n  bool IsLocalExternDecl = adjustContextForLocalExternDecl(DC);\n\n  FunctionDecl *NewFD = CreateNewFunctionDecl(*this, D, DC, R, TInfo, SC,\n                                              isVirtualOkay);\n  if (!NewFD) return nullptr;\n\n  if (OriginalLexicalContext && OriginalLexicalContext->isObjCContainer())\n    NewFD->setTopLevelDeclInObjCContainer();\n\n  // Set the lexical context. If this is a function-scope declaration, or has a\n  // C++ scope specifier, or is the object of a friend declaration, the lexical\n  // context will be different from the semantic context.\n  NewFD->setLexicalDeclContext(CurContext);\n\n  if (IsLocalExternDecl)\n    NewFD->setLocalExternDecl();\n\n  if (getLangOpts().CPlusPlus) {\n    bool isInline = D.getDeclSpec().isInlineSpecified();\n    bool isVirtual = D.getDeclSpec().isVirtualSpecified();\n    bool hasExplicit = D.getDeclSpec().hasExplicitSpecifier();\n    isFriend = D.getDeclSpec().isFriendSpecified();\n    if (isFriend && !isInline && D.isFunctionDefinition()) {\n      // C++ [class.friend]p5\n      //   A function can be defined in a friend declaration of a\n      //   class . . . . Such a function is implicitly inline.\n      NewFD->setImplicitlyInline();\n    }\n\n    // If this is a method defined in an __interface, and is not a constructor\n    // or an overloaded operator, then set the pure flag (isVirtual will already\n    // return true).\n    if (const CXXRecordDecl *Parent =\n          dyn_cast<CXXRecordDecl>(NewFD->getDeclContext())) {\n      if (Parent->isInterface() && cast<CXXMethodDecl>(NewFD)->isUserProvided())\n        NewFD->setPure(true);\n\n      // C++ [class.union]p2\n      //   A union can have member functions, but not virtual functions.\n      if (isVirtual && Parent->isUnion())\n        Diag(D.getDeclSpec().getVirtualSpecLoc(), diag::err_virtual_in_union);\n    }\n\n    SetNestedNameSpecifier(*this, NewFD, D);\n    isMemberSpecialization = false;\n    isFunctionTemplateSpecialization = false;\n    if (D.isInvalidType())\n      NewFD->setInvalidDecl();\n\n    // Match up the template parameter lists with the scope specifier, then\n    // determine whether we have a template or a template specialization.\n    bool Invalid = false;\n    TemplateParameterList *TemplateParams =\n        MatchTemplateParametersToScopeSpecifier(\n            D.getDeclSpec().getBeginLoc(), D.getIdentifierLoc(),\n            D.getCXXScopeSpec(),\n            D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId\n                ? D.getName().TemplateId\n                : nullptr,\n            TemplateParamLists, isFriend, isMemberSpecialization,\n            Invalid);\n    if (TemplateParams) {\n      // Check that we can declare a template here.\n      if (CheckTemplateDeclScope(S, TemplateParams))\n        NewFD->setInvalidDecl();\n\n      if (TemplateParams->size() > 0) {\n        // This is a function template\n\n        // A destructor cannot be a template.\n        if (Name.getNameKind() == DeclarationName::CXXDestructorName) {\n          Diag(NewFD->getLocation(), diag::err_destructor_template);\n          NewFD->setInvalidDecl();\n        }\n\n        // If we're adding a template to a dependent context, we may need to\n        // rebuilding some of the types used within the template parameter list,\n        // now that we know what the current instantiation is.\n        if (DC->isDependentContext()) {\n          ContextRAII SavedContext(*this, DC);\n          if (RebuildTemplateParamsInCurrentInstantiation(TemplateParams))\n            Invalid = true;\n        }\n\n        FunctionTemplate = FunctionTemplateDecl::Create(Context, DC,\n                                                        NewFD->getLocation(),\n                                                        Name, TemplateParams,\n                                                        NewFD);\n        FunctionTemplate->setLexicalDeclContext(CurContext);\n        NewFD->setDescribedFunctionTemplate(FunctionTemplate);\n\n        // For source fidelity, store the other template param lists.\n        if (TemplateParamLists.size() > 1) {\n          NewFD->setTemplateParameterListsInfo(Context,\n              ArrayRef<TemplateParameterList *>(TemplateParamLists)\n                  .drop_back(1));\n        }\n      } else {\n        // This is a function template specialization.\n        isFunctionTemplateSpecialization = true;\n        // For source fidelity, store all the template param lists.\n        if (TemplateParamLists.size() > 0)\n          NewFD->setTemplateParameterListsInfo(Context, TemplateParamLists);\n\n        // C++0x [temp.expl.spec]p20 forbids \"template<> friend void foo(int);\".\n        if (isFriend) {\n          // We want to remove the \"template<>\", found here.\n          SourceRange RemoveRange = TemplateParams->getSourceRange();\n\n          // If we remove the template<> and the name is not a\n          // template-id, we're actually silently creating a problem:\n          // the friend declaration will refer to an untemplated decl,\n          // and clearly the user wants a template specialization.  So\n          // we need to insert '<>' after the name.\n          SourceLocation InsertLoc;\n          if (D.getName().getKind() != UnqualifiedIdKind::IK_TemplateId) {\n            InsertLoc = D.getName().getSourceRange().getEnd();\n            InsertLoc = getLocForEndOfToken(InsertLoc);\n          }\n\n          Diag(D.getIdentifierLoc(), diag::err_template_spec_decl_friend)\n            << Name << RemoveRange\n            << FixItHint::CreateRemoval(RemoveRange)\n            << FixItHint::CreateInsertion(InsertLoc, \"<>\");\n        }\n      }\n    } else {\n      // Check that we can declare a template here.\n      if (!TemplateParamLists.empty() && isMemberSpecialization &&\n          CheckTemplateDeclScope(S, TemplateParamLists.back()))\n        NewFD->setInvalidDecl();\n\n      // All template param lists were matched against the scope specifier:\n      // this is NOT (an explicit specialization of) a template.\n      if (TemplateParamLists.size() > 0)\n        // For source fidelity, store all the template param lists.\n        NewFD->setTemplateParameterListsInfo(Context, TemplateParamLists);\n    }\n\n    if (Invalid) {\n      NewFD->setInvalidDecl();\n      if (FunctionTemplate)\n        FunctionTemplate->setInvalidDecl();\n    }\n\n    // C++ [dcl.fct.spec]p5:\n    //   The virtual specifier shall only be used in declarations of\n    //   nonstatic class member functions that appear within a\n    //   member-specification of a class declaration; see 10.3.\n    //\n    if (isVirtual && !NewFD->isInvalidDecl()) {\n      if (!isVirtualOkay) {\n        Diag(D.getDeclSpec().getVirtualSpecLoc(),\n             diag::err_virtual_non_function);\n      } else if (!CurContext->isRecord()) {\n        // 'virtual' was specified outside of the class.\n        Diag(D.getDeclSpec().getVirtualSpecLoc(),\n             diag::err_virtual_out_of_class)\n          << FixItHint::CreateRemoval(D.getDeclSpec().getVirtualSpecLoc());\n      } else if (NewFD->getDescribedFunctionTemplate()) {\n        // C++ [temp.mem]p3:\n        //  A member function template shall not be virtual.\n        Diag(D.getDeclSpec().getVirtualSpecLoc(),\n             diag::err_virtual_member_function_template)\n          << FixItHint::CreateRemoval(D.getDeclSpec().getVirtualSpecLoc());\n      } else {\n        // Okay: Add virtual to the method.\n        NewFD->setVirtualAsWritten(true);\n      }\n\n      if (getLangOpts().CPlusPlus14 &&\n          NewFD->getReturnType()->isUndeducedType())\n        Diag(D.getDeclSpec().getVirtualSpecLoc(), diag::err_auto_fn_virtual);\n    }\n\n    if (getLangOpts().CPlusPlus14 &&\n        (NewFD->isDependentContext() ||\n         (isFriend && CurContext->isDependentContext())) &&\n        NewFD->getReturnType()->isUndeducedType()) {\n      // If the function template is referenced directly (for instance, as a\n      // member of the current instantiation), pretend it has a dependent type.\n      // This is not really justified by the standard, but is the only sane\n      // thing to do.\n      // FIXME: For a friend function, we have not marked the function as being\n      // a friend yet, so 'isDependentContext' on the FD doesn't work.\n      const FunctionProtoType *FPT =\n          NewFD->getType()->castAs<FunctionProtoType>();\n      QualType Result =\n          SubstAutoType(FPT->getReturnType(), Context.DependentTy);\n      NewFD->setType(Context.getFunctionType(Result, FPT->getParamTypes(),\n                                             FPT->getExtProtoInfo()));\n    }\n\n    // C++ [dcl.fct.spec]p3:\n    //  The inline specifier shall not appear on a block scope function\n    //  declaration.\n    if (isInline && !NewFD->isInvalidDecl()) {\n      if (CurContext->isFunctionOrMethod()) {\n        // 'inline' is not allowed on block scope function declaration.\n        Diag(D.getDeclSpec().getInlineSpecLoc(),\n             diag::err_inline_declaration_block_scope) << Name\n          << FixItHint::CreateRemoval(D.getDeclSpec().getInlineSpecLoc());\n      }\n    }\n\n    // C++ [dcl.fct.spec]p6:\n    //  The explicit specifier shall be used only in the declaration of a\n    //  constructor or conversion function within its class definition;\n    //  see 12.3.1 and 12.3.2.\n    if (hasExplicit && !NewFD->isInvalidDecl() &&\n        !isa<CXXDeductionGuideDecl>(NewFD)) {\n      if (!CurContext->isRecord()) {\n        // 'explicit' was specified outside of the class.\n        Diag(D.getDeclSpec().getExplicitSpecLoc(),\n             diag::err_explicit_out_of_class)\n            << FixItHint::CreateRemoval(D.getDeclSpec().getExplicitSpecRange());\n      } else if (!isa<CXXConstructorDecl>(NewFD) &&\n                 !isa<CXXConversionDecl>(NewFD)) {\n        // 'explicit' was specified on a function that wasn't a constructor\n        // or conversion function.\n        Diag(D.getDeclSpec().getExplicitSpecLoc(),\n             diag::err_explicit_non_ctor_or_conv_function)\n            << FixItHint::CreateRemoval(D.getDeclSpec().getExplicitSpecRange());\n      }\n    }\n\n    ConstexprSpecKind ConstexprKind = D.getDeclSpec().getConstexprSpecifier();\n    if (ConstexprKind != ConstexprSpecKind::Unspecified) {\n      // C++11 [dcl.constexpr]p2: constexpr functions and constexpr constructors\n      // are implicitly inline.\n      NewFD->setImplicitlyInline();\n\n      // C++11 [dcl.constexpr]p3: functions declared constexpr are required to\n      // be either constructors or to return a literal type. Therefore,\n      // destructors cannot be declared constexpr.\n      if (isa<CXXDestructorDecl>(NewFD) &&\n          (!getLangOpts().CPlusPlus20 ||\n           ConstexprKind == ConstexprSpecKind::Consteval)) {\n        Diag(D.getDeclSpec().getConstexprSpecLoc(), diag::err_constexpr_dtor)\n            << static_cast<int>(ConstexprKind);\n        NewFD->setConstexprKind(getLangOpts().CPlusPlus20\n                                    ? ConstexprSpecKind::Unspecified\n                                    : ConstexprSpecKind::Constexpr);\n      }\n      // C++20 [dcl.constexpr]p2: An allocation function, or a\n      // deallocation function shall not be declared with the consteval\n      // specifier.\n      if (ConstexprKind == ConstexprSpecKind::Consteval &&\n          (NewFD->getOverloadedOperator() == OO_New ||\n           NewFD->getOverloadedOperator() == OO_Array_New ||\n           NewFD->getOverloadedOperator() == OO_Delete ||\n           NewFD->getOverloadedOperator() == OO_Array_Delete)) {\n        Diag(D.getDeclSpec().getConstexprSpecLoc(),\n             diag::err_invalid_consteval_decl_kind)\n            << NewFD;\n        NewFD->setConstexprKind(ConstexprSpecKind::Constexpr);\n      }\n    }\n\n    // If __module_private__ was specified, mark the function accordingly.\n    if (D.getDeclSpec().isModulePrivateSpecified()) {\n      if (isFunctionTemplateSpecialization) {\n        SourceLocation ModulePrivateLoc\n          = D.getDeclSpec().getModulePrivateSpecLoc();\n        Diag(ModulePrivateLoc, diag::err_module_private_specialization)\n          << 0\n          << FixItHint::CreateRemoval(ModulePrivateLoc);\n      } else {\n        NewFD->setModulePrivate();\n        if (FunctionTemplate)\n          FunctionTemplate->setModulePrivate();\n      }\n    }\n\n    if (isFriend) {\n      if (FunctionTemplate) {\n        FunctionTemplate->setObjectOfFriendDecl();\n        FunctionTemplate->setAccess(AS_public);\n      }\n      NewFD->setObjectOfFriendDecl();\n      NewFD->setAccess(AS_public);\n    }\n\n    // If a function is defined as defaulted or deleted, mark it as such now.\n    // We'll do the relevant checks on defaulted / deleted functions later.\n    switch (D.getFunctionDefinitionKind()) {\n    case FunctionDefinitionKind::Declaration:\n    case FunctionDefinitionKind::Definition:\n      break;\n\n    case FunctionDefinitionKind::Defaulted:\n      NewFD->setDefaulted();\n      break;\n\n    case FunctionDefinitionKind::Deleted:\n      NewFD->setDeletedAsWritten();\n      break;\n    }\n\n    if (isa<CXXMethodDecl>(NewFD) && DC == CurContext &&\n        D.isFunctionDefinition()) {\n      // C++ [class.mfct]p2:\n      //   A member function may be defined (8.4) in its class definition, in\n      //   which case it is an inline member function (7.1.2)\n      NewFD->setImplicitlyInline();\n    }\n\n    if (SC == SC_Static && isa<CXXMethodDecl>(NewFD) &&\n        !CurContext->isRecord()) {\n      // C++ [class.static]p1:\n      //   A data or function member of a class may be declared static\n      //   in a class definition, in which case it is a static member of\n      //   the class.\n\n      // Complain about the 'static' specifier if it's on an out-of-line\n      // member function definition.\n\n      // MSVC permits the use of a 'static' storage specifier on an out-of-line\n      // member function template declaration and class member template\n      // declaration (MSVC versions before 2015), warn about this.\n      Diag(D.getDeclSpec().getStorageClassSpecLoc(),\n           ((!getLangOpts().isCompatibleWithMSVC(LangOptions::MSVC2015) &&\n             cast<CXXRecordDecl>(DC)->getDescribedClassTemplate()) ||\n           (getLangOpts().MSVCCompat && NewFD->getDescribedFunctionTemplate()))\n           ? diag::ext_static_out_of_line : diag::err_static_out_of_line)\n        << FixItHint::CreateRemoval(D.getDeclSpec().getStorageClassSpecLoc());\n    }\n\n    // C++11 [except.spec]p15:\n    //   A deallocation function with no exception-specification is treated\n    //   as if it were specified with noexcept(true).\n    const FunctionProtoType *FPT = R->getAs<FunctionProtoType>();\n    if ((Name.getCXXOverloadedOperator() == OO_Delete ||\n         Name.getCXXOverloadedOperator() == OO_Array_Delete) &&\n        getLangOpts().CPlusPlus11 && FPT && !FPT->hasExceptionSpec())\n      NewFD->setType(Context.getFunctionType(\n          FPT->getReturnType(), FPT->getParamTypes(),\n          FPT->getExtProtoInfo().withExceptionSpec(EST_BasicNoexcept)));\n  }\n\n  // Filter out previous declarations that don't match the scope.\n  FilterLookupForScope(Previous, OriginalDC, S, shouldConsiderLinkage(NewFD),\n                       D.getCXXScopeSpec().isNotEmpty() ||\n                       isMemberSpecialization ||\n                       isFunctionTemplateSpecialization);\n\n  // Handle GNU asm-label extension (encoded as an attribute).\n  if (Expr *E = (Expr*) D.getAsmLabel()) {\n    // The parser guarantees this is a string.\n    StringLiteral *SE = cast<StringLiteral>(E);\n    NewFD->addAttr(AsmLabelAttr::Create(Context, SE->getString(),\n                                        /*IsLiteralLabel=*/true,\n                                        SE->getStrTokenLoc(0)));\n  } else if (!ExtnameUndeclaredIdentifiers.empty()) {\n    llvm::DenseMap<IdentifierInfo*,AsmLabelAttr*>::iterator I =\n      ExtnameUndeclaredIdentifiers.find(NewFD->getIdentifier());\n    if (I != ExtnameUndeclaredIdentifiers.end()) {\n      if (isDeclExternC(NewFD)) {\n        NewFD->addAttr(I->second);\n        ExtnameUndeclaredIdentifiers.erase(I);\n      } else\n        Diag(NewFD->getLocation(), diag::warn_redefine_extname_not_applied)\n            << /*Variable*/0 << NewFD;\n    }\n  }\n\n  // Copy the parameter declarations from the declarator D to the function\n  // declaration NewFD, if they are available.  First scavenge them into Params.\n  SmallVector<ParmVarDecl*, 16> Params;\n  unsigned FTIIdx;\n  if (D.isFunctionDeclarator(FTIIdx)) {\n    DeclaratorChunk::FunctionTypeInfo &FTI = D.getTypeObject(FTIIdx).Fun;\n\n    // Check for C99 6.7.5.3p10 - foo(void) is a non-varargs\n    // function that takes no arguments, not a function that takes a\n    // single void argument.\n    // We let through \"const void\" here because Sema::GetTypeForDeclarator\n    // already checks for that case.\n    if (FTIHasNonVoidParameters(FTI) && FTI.Params[0].Param) {\n      for (unsigned i = 0, e = FTI.NumParams; i != e; ++i) {\n        ParmVarDecl *Param = cast<ParmVarDecl>(FTI.Params[i].Param);\n        assert(Param->getDeclContext() != NewFD && \"Was set before ?\");\n        Param->setDeclContext(NewFD);\n        Params.push_back(Param);\n\n        if (Param->isInvalidDecl())\n          NewFD->setInvalidDecl();\n      }\n    }\n\n    if (!getLangOpts().CPlusPlus) {\n      // In C, find all the tag declarations from the prototype and move them\n      // into the function DeclContext. Remove them from the surrounding tag\n      // injection context of the function, which is typically but not always\n      // the TU.\n      DeclContext *PrototypeTagContext =\n          getTagInjectionContext(NewFD->getLexicalDeclContext());\n      for (NamedDecl *NonParmDecl : FTI.getDeclsInPrototype()) {\n        auto *TD = dyn_cast<TagDecl>(NonParmDecl);\n\n        // We don't want to reparent enumerators. Look at their parent enum\n        // instead.\n        if (!TD) {\n          if (auto *ECD = dyn_cast<EnumConstantDecl>(NonParmDecl))\n            TD = cast<EnumDecl>(ECD->getDeclContext());\n        }\n        if (!TD)\n          continue;\n        DeclContext *TagDC = TD->getLexicalDeclContext();\n        if (!TagDC->containsDecl(TD))\n          continue;\n        TagDC->removeDecl(TD);\n        TD->setDeclContext(NewFD);\n        NewFD->addDecl(TD);\n\n        // Preserve the lexical DeclContext if it is not the surrounding tag\n        // injection context of the FD. In this example, the semantic context of\n        // E will be f and the lexical context will be S, while both the\n        // semantic and lexical contexts of S will be f:\n        //   void f(struct S { enum E { a } f; } s);\n        if (TagDC != PrototypeTagContext)\n          TD->setLexicalDeclContext(TagDC);\n      }\n    }\n  } else if (const FunctionProtoType *FT = R->getAs<FunctionProtoType>()) {\n    // When we're declaring a function with a typedef, typeof, etc as in the\n    // following example, we'll need to synthesize (unnamed)\n    // parameters for use in the declaration.\n    //\n    // @code\n    // typedef void fn(int);\n    // fn f;\n    // @endcode\n\n    // Synthesize a parameter for each argument type.\n    for (const auto &AI : FT->param_types()) {\n      ParmVarDecl *Param =\n          BuildParmVarDeclForTypedef(NewFD, D.getIdentifierLoc(), AI);\n      Param->setScopeInfo(0, Params.size());\n      Params.push_back(Param);\n    }\n  } else {\n    assert(R->isFunctionNoProtoType() && NewFD->getNumParams() == 0 &&\n           \"Should not need args for typedef of non-prototype fn\");\n  }\n\n  // Finally, we know we have the right number of parameters, install them.\n  NewFD->setParams(Params);\n\n  if (D.getDeclSpec().isNoreturnSpecified())\n    NewFD->addAttr(C11NoReturnAttr::Create(Context,\n                                           D.getDeclSpec().getNoreturnSpecLoc(),\n                                           AttributeCommonInfo::AS_Keyword));\n\n  // Functions returning a variably modified type violate C99 6.7.5.2p2\n  // because all functions have linkage.\n  if (!NewFD->isInvalidDecl() &&\n      NewFD->getReturnType()->isVariablyModifiedType()) {\n    Diag(NewFD->getLocation(), diag::err_vm_func_decl);\n    NewFD->setInvalidDecl();\n  }\n\n  // Apply an implicit SectionAttr if '#pragma clang section text' is active\n  if (PragmaClangTextSection.Valid && D.isFunctionDefinition() &&\n      !NewFD->hasAttr<SectionAttr>())\n    NewFD->addAttr(PragmaClangTextSectionAttr::CreateImplicit(\n        Context, PragmaClangTextSection.SectionName,\n        PragmaClangTextSection.PragmaLocation, AttributeCommonInfo::AS_Pragma));\n\n  // Apply an implicit SectionAttr if #pragma code_seg is active.\n  if (CodeSegStack.CurrentValue && D.isFunctionDefinition() &&\n      !NewFD->hasAttr<SectionAttr>()) {\n    NewFD->addAttr(SectionAttr::CreateImplicit(\n        Context, CodeSegStack.CurrentValue->getString(),\n        CodeSegStack.CurrentPragmaLocation, AttributeCommonInfo::AS_Pragma,\n        SectionAttr::Declspec_allocate));\n    if (UnifySection(CodeSegStack.CurrentValue->getString(),\n                     ASTContext::PSF_Implicit | ASTContext::PSF_Execute |\n                         ASTContext::PSF_Read,\n                     NewFD))\n      NewFD->dropAttr<SectionAttr>();\n  }\n\n  // Apply an implicit CodeSegAttr from class declspec or\n  // apply an implicit SectionAttr from #pragma code_seg if active.\n  if (!NewFD->hasAttr<CodeSegAttr>()) {\n    if (Attr *SAttr = getImplicitCodeSegOrSectionAttrForFunction(NewFD,\n                                                                 D.isFunctionDefinition())) {\n      NewFD->addAttr(SAttr);\n    }\n  }\n\n  // Handle attributes.\n  ProcessDeclAttributes(S, NewFD, D);\n\n  if (getLangOpts().OpenCL) {\n    // OpenCL v1.1 s6.5: Using an address space qualifier in a function return\n    // type declaration will generate a compilation error.\n    LangAS AddressSpace = NewFD->getReturnType().getAddressSpace();\n    if (AddressSpace != LangAS::Default) {\n      Diag(NewFD->getLocation(),\n           diag::err_opencl_return_value_with_address_space);\n      NewFD->setInvalidDecl();\n    }\n  }\n\n  if (LangOpts.SYCLIsDevice || (LangOpts.OpenMP && LangOpts.OpenMPIsDevice))\n    checkDeviceDecl(NewFD, D.getBeginLoc());\n\n  if (!getLangOpts().CPlusPlus) {\n    // Perform semantic checking on the function declaration.\n    if (!NewFD->isInvalidDecl() && NewFD->isMain())\n      CheckMain(NewFD, D.getDeclSpec());\n\n    if (!NewFD->isInvalidDecl() && NewFD->isMSVCRTEntryPoint())\n      CheckMSVCRTEntryPoint(NewFD);\n\n    if (!NewFD->isInvalidDecl())\n      D.setRedeclaration(CheckFunctionDeclaration(S, NewFD, Previous,\n                                                  isMemberSpecialization));\n    else if (!Previous.empty())\n      // Recover gracefully from an invalid redeclaration.\n      D.setRedeclaration(true);\n    assert((NewFD->isInvalidDecl() || !D.isRedeclaration() ||\n            Previous.getResultKind() != LookupResult::FoundOverloaded) &&\n           \"previous declaration set still overloaded\");\n\n    // Diagnose no-prototype function declarations with calling conventions that\n    // don't support variadic calls. Only do this in C and do it after merging\n    // possibly prototyped redeclarations.\n    const FunctionType *FT = NewFD->getType()->castAs<FunctionType>();\n    if (isa<FunctionNoProtoType>(FT) && !D.isFunctionDefinition()) {\n      CallingConv CC = FT->getExtInfo().getCC();\n      if (!supportsVariadicCall(CC)) {\n        // Windows system headers sometimes accidentally use stdcall without\n        // (void) parameters, so we relax this to a warning.\n        int DiagID =\n            CC == CC_X86StdCall ? diag::warn_cconv_knr : diag::err_cconv_knr;\n        Diag(NewFD->getLocation(), DiagID)\n            << FunctionType::getNameForCallConv(CC);\n      }\n    }\n\n   if (NewFD->getReturnType().hasNonTrivialToPrimitiveDestructCUnion() ||\n       NewFD->getReturnType().hasNonTrivialToPrimitiveCopyCUnion())\n     checkNonTrivialCUnion(NewFD->getReturnType(),\n                           NewFD->getReturnTypeSourceRange().getBegin(),\n                           NTCUC_FunctionReturn, NTCUK_Destruct|NTCUK_Copy);\n  } else {\n    // C++11 [replacement.functions]p3:\n    //  The program's definitions shall not be specified as inline.\n    //\n    // N.B. We diagnose declarations instead of definitions per LWG issue 2340.\n    //\n    // Suppress the diagnostic if the function is __attribute__((used)), since\n    // that forces an external definition to be emitted.\n    if (D.getDeclSpec().isInlineSpecified() &&\n        NewFD->isReplaceableGlobalAllocationFunction() &&\n        !NewFD->hasAttr<UsedAttr>())\n      Diag(D.getDeclSpec().getInlineSpecLoc(),\n           diag::ext_operator_new_delete_declared_inline)\n        << NewFD->getDeclName();\n\n    // If the declarator is a template-id, translate the parser's template\n    // argument list into our AST format.\n    if (D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId) {\n      TemplateIdAnnotation *TemplateId = D.getName().TemplateId;\n      TemplateArgs.setLAngleLoc(TemplateId->LAngleLoc);\n      TemplateArgs.setRAngleLoc(TemplateId->RAngleLoc);\n      ASTTemplateArgsPtr TemplateArgsPtr(TemplateId->getTemplateArgs(),\n                                         TemplateId->NumArgs);\n      translateTemplateArguments(TemplateArgsPtr,\n                                 TemplateArgs);\n\n      HasExplicitTemplateArgs = true;\n\n      if (NewFD->isInvalidDecl()) {\n        HasExplicitTemplateArgs = false;\n      } else if (FunctionTemplate) {\n        // Function template with explicit template arguments.\n        Diag(D.getIdentifierLoc(), diag::err_function_template_partial_spec)\n          << SourceRange(TemplateId->LAngleLoc, TemplateId->RAngleLoc);\n\n        HasExplicitTemplateArgs = false;\n      } else {\n        assert((isFunctionTemplateSpecialization ||\n                D.getDeclSpec().isFriendSpecified()) &&\n               \"should have a 'template<>' for this decl\");\n        // \"friend void foo<>(int);\" is an implicit specialization decl.\n        isFunctionTemplateSpecialization = true;\n      }\n    } else if (isFriend && isFunctionTemplateSpecialization) {\n      // This combination is only possible in a recovery case;  the user\n      // wrote something like:\n      //   template <> friend void foo(int);\n      // which we're recovering from as if the user had written:\n      //   friend void foo<>(int);\n      // Go ahead and fake up a template id.\n      HasExplicitTemplateArgs = true;\n      TemplateArgs.setLAngleLoc(D.getIdentifierLoc());\n      TemplateArgs.setRAngleLoc(D.getIdentifierLoc());\n    }\n\n    // We do not add HD attributes to specializations here because\n    // they may have different constexpr-ness compared to their\n    // templates and, after maybeAddCUDAHostDeviceAttrs() is applied,\n    // may end up with different effective targets. Instead, a\n    // specialization inherits its target attributes from its template\n    // in the CheckFunctionTemplateSpecialization() call below.\n    if (getLangOpts().CUDA && !isFunctionTemplateSpecialization)\n      maybeAddCUDAHostDeviceAttrs(NewFD, Previous);\n\n    // If it's a friend (and only if it's a friend), it's possible\n    // that either the specialized function type or the specialized\n    // template is dependent, and therefore matching will fail.  In\n    // this case, don't check the specialization yet.\n    if (isFunctionTemplateSpecialization && isFriend &&\n        (NewFD->getType()->isDependentType() || DC->isDependentContext() ||\n         TemplateSpecializationType::anyInstantiationDependentTemplateArguments(\n             TemplateArgs.arguments()))) {\n      assert(HasExplicitTemplateArgs &&\n             \"friend function specialization without template args\");\n      if (CheckDependentFunctionTemplateSpecialization(NewFD, TemplateArgs,\n                                                       Previous))\n        NewFD->setInvalidDecl();\n    } else if (isFunctionTemplateSpecialization) {\n      if (CurContext->isDependentContext() && CurContext->isRecord()\n          && !isFriend) {\n        isDependentClassScopeExplicitSpecialization = true;\n      } else if (!NewFD->isInvalidDecl() &&\n                 CheckFunctionTemplateSpecialization(\n                     NewFD, (HasExplicitTemplateArgs ? &TemplateArgs : nullptr),\n                     Previous))\n        NewFD->setInvalidDecl();\n\n      // C++ [dcl.stc]p1:\n      //   A storage-class-specifier shall not be specified in an explicit\n      //   specialization (14.7.3)\n      FunctionTemplateSpecializationInfo *Info =\n          NewFD->getTemplateSpecializationInfo();\n      if (Info && SC != SC_None) {\n        if (SC != Info->getTemplate()->getTemplatedDecl()->getStorageClass())\n          Diag(NewFD->getLocation(),\n               diag::err_explicit_specialization_inconsistent_storage_class)\n            << SC\n            << FixItHint::CreateRemoval(\n                                      D.getDeclSpec().getStorageClassSpecLoc());\n\n        else\n          Diag(NewFD->getLocation(),\n               diag::ext_explicit_specialization_storage_class)\n            << FixItHint::CreateRemoval(\n                                      D.getDeclSpec().getStorageClassSpecLoc());\n      }\n    } else if (isMemberSpecialization && isa<CXXMethodDecl>(NewFD)) {\n      if (CheckMemberSpecialization(NewFD, Previous))\n          NewFD->setInvalidDecl();\n    }\n\n    // Perform semantic checking on the function declaration.\n    if (!isDependentClassScopeExplicitSpecialization) {\n      if (!NewFD->isInvalidDecl() && NewFD->isMain())\n        CheckMain(NewFD, D.getDeclSpec());\n\n      if (!NewFD->isInvalidDecl() && NewFD->isMSVCRTEntryPoint())\n        CheckMSVCRTEntryPoint(NewFD);\n\n      if (!NewFD->isInvalidDecl())\n        D.setRedeclaration(CheckFunctionDeclaration(S, NewFD, Previous,\n                                                    isMemberSpecialization));\n      else if (!Previous.empty())\n        // Recover gracefully from an invalid redeclaration.\n        D.setRedeclaration(true);\n    }\n\n    assert((NewFD->isInvalidDecl() || !D.isRedeclaration() ||\n            Previous.getResultKind() != LookupResult::FoundOverloaded) &&\n           \"previous declaration set still overloaded\");\n\n    NamedDecl *PrincipalDecl = (FunctionTemplate\n                                ? cast<NamedDecl>(FunctionTemplate)\n                                : NewFD);\n\n    if (isFriend && NewFD->getPreviousDecl()) {\n      AccessSpecifier Access = AS_public;\n      if (!NewFD->isInvalidDecl())\n        Access = NewFD->getPreviousDecl()->getAccess();\n\n      NewFD->setAccess(Access);\n      if (FunctionTemplate) FunctionTemplate->setAccess(Access);\n    }\n\n    if (NewFD->isOverloadedOperator() && !DC->isRecord() &&\n        PrincipalDecl->isInIdentifierNamespace(Decl::IDNS_Ordinary))\n      PrincipalDecl->setNonMemberOperator();\n\n    // If we have a function template, check the template parameter\n    // list. This will check and merge default template arguments.\n    if (FunctionTemplate) {\n      FunctionTemplateDecl *PrevTemplate =\n                                     FunctionTemplate->getPreviousDecl();\n      CheckTemplateParameterList(FunctionTemplate->getTemplateParameters(),\n                       PrevTemplate ? PrevTemplate->getTemplateParameters()\n                                    : nullptr,\n                            D.getDeclSpec().isFriendSpecified()\n                              ? (D.isFunctionDefinition()\n                                   ? TPC_FriendFunctionTemplateDefinition\n                                   : TPC_FriendFunctionTemplate)\n                              : (D.getCXXScopeSpec().isSet() &&\n                                 DC && DC->isRecord() &&\n                                 DC->isDependentContext())\n                                  ? TPC_ClassTemplateMember\n                                  : TPC_FunctionTemplate);\n    }\n\n    if (NewFD->isInvalidDecl()) {\n      // Ignore all the rest of this.\n    } else if (!D.isRedeclaration()) {\n      struct ActOnFDArgs ExtraArgs = { S, D, TemplateParamLists,\n                                       AddToScope };\n      // Fake up an access specifier if it's supposed to be a class member.\n      if (isa<CXXRecordDecl>(NewFD->getDeclContext()))\n        NewFD->setAccess(AS_public);\n\n      // Qualified decls generally require a previous declaration.\n      if (D.getCXXScopeSpec().isSet()) {\n        // ...with the major exception of templated-scope or\n        // dependent-scope friend declarations.\n\n        // TODO: we currently also suppress this check in dependent\n        // contexts because (1) the parameter depth will be off when\n        // matching friend templates and (2) we might actually be\n        // selecting a friend based on a dependent factor.  But there\n        // are situations where these conditions don't apply and we\n        // can actually do this check immediately.\n        //\n        // Unless the scope is dependent, it's always an error if qualified\n        // redeclaration lookup found nothing at all. Diagnose that now;\n        // nothing will diagnose that error later.\n        if (isFriend &&\n            (D.getCXXScopeSpec().getScopeRep()->isDependent() ||\n             (!Previous.empty() && CurContext->isDependentContext()))) {\n          // ignore these\n        } else {\n          // The user tried to provide an out-of-line definition for a\n          // function that is a member of a class or namespace, but there\n          // was no such member function declared (C++ [class.mfct]p2,\n          // C++ [namespace.memdef]p2). For example:\n          //\n          // class X {\n          //   void f() const;\n          // };\n          //\n          // void X::f() { } // ill-formed\n          //\n          // Complain about this problem, and attempt to suggest close\n          // matches (e.g., those that differ only in cv-qualifiers and\n          // whether the parameter types are references).\n\n          if (NamedDecl *Result = DiagnoseInvalidRedeclaration(\n                  *this, Previous, NewFD, ExtraArgs, false, nullptr)) {\n            AddToScope = ExtraArgs.AddToScope;\n            return Result;\n          }\n        }\n\n        // Unqualified local friend declarations are required to resolve\n        // to something.\n      } else if (isFriend && cast<CXXRecordDecl>(CurContext)->isLocalClass()) {\n        if (NamedDecl *Result = DiagnoseInvalidRedeclaration(\n                *this, Previous, NewFD, ExtraArgs, true, S)) {\n          AddToScope = ExtraArgs.AddToScope;\n          return Result;\n        }\n      }\n    } else if (!D.isFunctionDefinition() &&\n               isa<CXXMethodDecl>(NewFD) && NewFD->isOutOfLine() &&\n               !isFriend && !isFunctionTemplateSpecialization &&\n               !isMemberSpecialization) {\n      // An out-of-line member function declaration must also be a\n      // definition (C++ [class.mfct]p2).\n      // Note that this is not the case for explicit specializations of\n      // function templates or member functions of class templates, per\n      // C++ [temp.expl.spec]p2. We also allow these declarations as an\n      // extension for compatibility with old SWIG code which likes to\n      // generate them.\n      Diag(NewFD->getLocation(), diag::ext_out_of_line_declaration)\n        << D.getCXXScopeSpec().getRange();\n    }\n  }\n\n  // If this is the first declaration of a library builtin function, add\n  // attributes as appropriate.\n  if (!D.isRedeclaration() &&\n      NewFD->getDeclContext()->getRedeclContext()->isFileContext()) {\n    if (IdentifierInfo *II = Previous.getLookupName().getAsIdentifierInfo()) {\n      if (unsigned BuiltinID = II->getBuiltinID()) {\n        if (NewFD->getLanguageLinkage() == CLanguageLinkage) {\n          // Validate the type matches unless this builtin is specified as\n          // matching regardless of its declared type.\n          if (Context.BuiltinInfo.allowTypeMismatch(BuiltinID)) {\n            NewFD->addAttr(BuiltinAttr::CreateImplicit(Context, BuiltinID));\n          } else {\n            ASTContext::GetBuiltinTypeError Error;\n            LookupNecessaryTypesForBuiltin(S, BuiltinID);\n            QualType BuiltinType = Context.GetBuiltinType(BuiltinID, Error);\n\n            if (!Error && !BuiltinType.isNull() &&\n                Context.hasSameFunctionTypeIgnoringExceptionSpec(\n                    NewFD->getType(), BuiltinType))\n              NewFD->addAttr(BuiltinAttr::CreateImplicit(Context, BuiltinID));\n          }\n        } else if (BuiltinID == Builtin::BI__GetExceptionInfo &&\n                   Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n          // FIXME: We should consider this a builtin only in the std namespace.\n          NewFD->addAttr(BuiltinAttr::CreateImplicit(Context, BuiltinID));\n        }\n      }\n    }\n  }\n\n  ProcessPragmaWeak(S, NewFD);\n  checkAttributesAfterMerging(*this, *NewFD);\n\n  AddKnownFunctionAttributes(NewFD);\n\n  if (NewFD->hasAttr<OverloadableAttr>() &&\n      !NewFD->getType()->getAs<FunctionProtoType>()) {\n    Diag(NewFD->getLocation(),\n         diag::err_attribute_overloadable_no_prototype)\n      << NewFD;\n\n    // Turn this into a variadic function with no parameters.\n    const FunctionType *FT = NewFD->getType()->getAs<FunctionType>();\n    FunctionProtoType::ExtProtoInfo EPI(\n        Context.getDefaultCallingConvention(true, false));\n    EPI.Variadic = true;\n    EPI.ExtInfo = FT->getExtInfo();\n\n    QualType R = Context.getFunctionType(FT->getReturnType(), None, EPI);\n    NewFD->setType(R);\n  }\n\n  // If there's a #pragma GCC visibility in scope, and this isn't a class\n  // member, set the visibility of this function.\n  if (!DC->isRecord() && NewFD->isExternallyVisible())\n    AddPushedVisibilityAttribute(NewFD);\n\n  // If there's a #pragma clang arc_cf_code_audited in scope, consider\n  // marking the function.\n  AddCFAuditedAttribute(NewFD);\n\n  // If this is a function definition, check if we have to apply optnone due to\n  // a pragma.\n  if(D.isFunctionDefinition())\n    AddRangeBasedOptnone(NewFD);\n\n  // If this is the first declaration of an extern C variable, update\n  // the map of such variables.\n  if (NewFD->isFirstDecl() && !NewFD->isInvalidDecl() &&\n      isIncompleteDeclExternC(*this, NewFD))\n    RegisterLocallyScopedExternCDecl(NewFD, S);\n\n  // Set this FunctionDecl's range up to the right paren.\n  NewFD->setRangeEnd(D.getSourceRange().getEnd());\n\n  if (D.isRedeclaration() && !Previous.empty()) {\n    NamedDecl *Prev = Previous.getRepresentativeDecl();\n    checkDLLAttributeRedeclaration(*this, Prev, NewFD,\n                                   isMemberSpecialization ||\n                                       isFunctionTemplateSpecialization,\n                                   D.isFunctionDefinition());\n  }\n\n  if (getLangOpts().CUDA) {\n    IdentifierInfo *II = NewFD->getIdentifier();\n    if (II && II->isStr(getCudaConfigureFuncName()) &&\n        !NewFD->isInvalidDecl() &&\n        NewFD->getDeclContext()->getRedeclContext()->isTranslationUnit()) {\n      if (!R->getAs<FunctionType>()->getReturnType()->isScalarType())\n        Diag(NewFD->getLocation(), diag::err_config_scalar_return)\n            << getCudaConfigureFuncName();\n      Context.setcudaConfigureCallDecl(NewFD);\n    }\n\n    // Variadic functions, other than a *declaration* of printf, are not allowed\n    // in device-side CUDA code, unless someone passed\n    // -fcuda-allow-variadic-functions.\n    if (!getLangOpts().CUDAAllowVariadicFunctions && NewFD->isVariadic() &&\n        (NewFD->hasAttr<CUDADeviceAttr>() ||\n         NewFD->hasAttr<CUDAGlobalAttr>()) &&\n        !(II && II->isStr(\"printf\") && NewFD->isExternC() &&\n          !D.isFunctionDefinition())) {\n      Diag(NewFD->getLocation(), diag::err_variadic_device_fn);\n    }\n  }\n\n  MarkUnusedFileScopedDecl(NewFD);\n\n\n\n  if (getLangOpts().OpenCL && NewFD->hasAttr<OpenCLKernelAttr>()) {\n    // OpenCL v1.2 s6.8 static is invalid for kernel functions.\n    if ((getLangOpts().OpenCLVersion >= 120)\n        && (SC == SC_Static)) {\n      Diag(D.getIdentifierLoc(), diag::err_static_kernel);\n      D.setInvalidType();\n    }\n\n    // OpenCL v1.2, s6.9 -- Kernels can only have return type void.\n    if (!NewFD->getReturnType()->isVoidType()) {\n      SourceRange RTRange = NewFD->getReturnTypeSourceRange();\n      Diag(D.getIdentifierLoc(), diag::err_expected_kernel_void_return_type)\n          << (RTRange.isValid() ? FixItHint::CreateReplacement(RTRange, \"void\")\n                                : FixItHint());\n      D.setInvalidType();\n    }\n\n    llvm::SmallPtrSet<const Type *, 16> ValidTypes;\n    for (auto Param : NewFD->parameters())\n      checkIsValidOpenCLKernelParameter(*this, D, Param, ValidTypes);\n\n    if (getLangOpts().OpenCLCPlusPlus) {\n      if (DC->isRecord()) {\n        Diag(D.getIdentifierLoc(), diag::err_method_kernel);\n        D.setInvalidType();\n      }\n      if (FunctionTemplate) {\n        Diag(D.getIdentifierLoc(), diag::err_template_kernel);\n        D.setInvalidType();\n      }\n    }\n  }\n\n  if (getLangOpts().CPlusPlus) {\n    if (FunctionTemplate) {\n      if (NewFD->isInvalidDecl())\n        FunctionTemplate->setInvalidDecl();\n      return FunctionTemplate;\n    }\n\n    if (isMemberSpecialization && !NewFD->isInvalidDecl())\n      CompleteMemberSpecialization(NewFD, Previous);\n  }\n\n  for (const ParmVarDecl *Param : NewFD->parameters()) {\n    QualType PT = Param->getType();\n\n    // OpenCL 2.0 pipe restrictions forbids pipe packet types to be non-value\n    // types.\n    if (getLangOpts().OpenCLVersion >= 200 || getLangOpts().OpenCLCPlusPlus) {\n      if(const PipeType *PipeTy = PT->getAs<PipeType>()) {\n        QualType ElemTy = PipeTy->getElementType();\n          if (ElemTy->isReferenceType() || ElemTy->isPointerType()) {\n            Diag(Param->getTypeSpecStartLoc(), diag::err_reference_pipe_type );\n            D.setInvalidType();\n          }\n      }\n    }\n  }\n\n  // Here we have an function template explicit specialization at class scope.\n  // The actual specialization will be postponed to template instatiation\n  // time via the ClassScopeFunctionSpecializationDecl node.\n  if (isDependentClassScopeExplicitSpecialization) {\n    ClassScopeFunctionSpecializationDecl *NewSpec =\n                         ClassScopeFunctionSpecializationDecl::Create(\n                                Context, CurContext, NewFD->getLocation(),\n                                cast<CXXMethodDecl>(NewFD),\n                                HasExplicitTemplateArgs, TemplateArgs);\n    CurContext->addDecl(NewSpec);\n    AddToScope = false;\n  }\n\n  // Diagnose availability attributes. Availability cannot be used on functions\n  // that are run during load/unload.\n  if (const auto *attr = NewFD->getAttr<AvailabilityAttr>()) {\n    if (NewFD->hasAttr<ConstructorAttr>()) {\n      Diag(attr->getLocation(), diag::warn_availability_on_static_initializer)\n          << 1;\n      NewFD->dropAttr<AvailabilityAttr>();\n    }\n    if (NewFD->hasAttr<DestructorAttr>()) {\n      Diag(attr->getLocation(), diag::warn_availability_on_static_initializer)\n          << 2;\n      NewFD->dropAttr<AvailabilityAttr>();\n    }\n  }\n\n  // Diagnose no_builtin attribute on function declaration that are not a\n  // definition.\n  // FIXME: We should really be doing this in\n  // SemaDeclAttr.cpp::handleNoBuiltinAttr, unfortunately we only have access to\n  // the FunctionDecl and at this point of the code\n  // FunctionDecl::isThisDeclarationADefinition() which always returns `false`\n  // because Sema::ActOnStartOfFunctionDef has not been called yet.\n  if (const auto *NBA = NewFD->getAttr<NoBuiltinAttr>())\n    switch (D.getFunctionDefinitionKind()) {\n    case FunctionDefinitionKind::Defaulted:\n    case FunctionDefinitionKind::Deleted:\n      Diag(NBA->getLocation(),\n           diag::err_attribute_no_builtin_on_defaulted_deleted_function)\n          << NBA->getSpelling();\n      break;\n    case FunctionDefinitionKind::Declaration:\n      Diag(NBA->getLocation(), diag::err_attribute_no_builtin_on_non_definition)\n          << NBA->getSpelling();\n      break;\n    case FunctionDefinitionKind::Definition:\n      break;\n    }\n\n  return NewFD;\n}\n\n/// Return a CodeSegAttr from a containing class.  The Microsoft docs say\n/// when __declspec(code_seg) \"is applied to a class, all member functions of\n/// the class and nested classes -- this includes compiler-generated special\n/// member functions -- are put in the specified segment.\"\n/// The actual behavior is a little more complicated. The Microsoft compiler\n/// won't check outer classes if there is an active value from #pragma code_seg.\n/// The CodeSeg is always applied from the direct parent but only from outer\n/// classes when the #pragma code_seg stack is empty. See:\n/// https://reviews.llvm.org/D22931, the Microsoft feedback page is no longer\n/// available since MS has removed the page.\nstatic Attr *getImplicitCodeSegAttrFromClass(Sema &S, const FunctionDecl *FD) {\n  const auto *Method = dyn_cast<CXXMethodDecl>(FD);\n  if (!Method)\n    return nullptr;\n  const CXXRecordDecl *Parent = Method->getParent();\n  if (const auto *SAttr = Parent->getAttr<CodeSegAttr>()) {\n    Attr *NewAttr = SAttr->clone(S.getASTContext());\n    NewAttr->setImplicit(true);\n    return NewAttr;\n  }\n\n  // The Microsoft compiler won't check outer classes for the CodeSeg\n  // when the #pragma code_seg stack is active.\n  if (S.CodeSegStack.CurrentValue)\n   return nullptr;\n\n  while ((Parent = dyn_cast<CXXRecordDecl>(Parent->getParent()))) {\n    if (const auto *SAttr = Parent->getAttr<CodeSegAttr>()) {\n      Attr *NewAttr = SAttr->clone(S.getASTContext());\n      NewAttr->setImplicit(true);\n      return NewAttr;\n    }\n  }\n  return nullptr;\n}\n\n/// Returns an implicit CodeSegAttr if a __declspec(code_seg) is found on a\n/// containing class. Otherwise it will return implicit SectionAttr if the\n/// function is a definition and there is an active value on CodeSegStack\n/// (from the current #pragma code-seg value).\n///\n/// \\param FD Function being declared.\n/// \\param IsDefinition Whether it is a definition or just a declarartion.\n/// \\returns A CodeSegAttr or SectionAttr to apply to the function or\n///          nullptr if no attribute should be added.\nAttr *Sema::getImplicitCodeSegOrSectionAttrForFunction(const FunctionDecl *FD,\n                                                       bool IsDefinition) {\n  if (Attr *A = getImplicitCodeSegAttrFromClass(*this, FD))\n    return A;\n  if (!FD->hasAttr<SectionAttr>() && IsDefinition &&\n      CodeSegStack.CurrentValue)\n    return SectionAttr::CreateImplicit(\n        getASTContext(), CodeSegStack.CurrentValue->getString(),\n        CodeSegStack.CurrentPragmaLocation, AttributeCommonInfo::AS_Pragma,\n        SectionAttr::Declspec_allocate);\n  return nullptr;\n}\n\n/// Determines if we can perform a correct type check for \\p D as a\n/// redeclaration of \\p PrevDecl. If not, we can generally still perform a\n/// best-effort check.\n///\n/// \\param NewD The new declaration.\n/// \\param OldD The old declaration.\n/// \\param NewT The portion of the type of the new declaration to check.\n/// \\param OldT The portion of the type of the old declaration to check.\nbool Sema::canFullyTypeCheckRedeclaration(ValueDecl *NewD, ValueDecl *OldD,\n                                          QualType NewT, QualType OldT) {\n  if (!NewD->getLexicalDeclContext()->isDependentContext())\n    return true;\n\n  // For dependently-typed local extern declarations and friends, we can't\n  // perform a correct type check in general until instantiation:\n  //\n  //   int f();\n  //   template<typename T> void g() { T f(); }\n  //\n  // (valid if g() is only instantiated with T = int).\n  if (NewT->isDependentType() &&\n      (NewD->isLocalExternDecl() || NewD->getFriendObjectKind()))\n    return false;\n\n  // Similarly, if the previous declaration was a dependent local extern\n  // declaration, we don't really know its type yet.\n  if (OldT->isDependentType() && OldD->isLocalExternDecl())\n    return false;\n\n  return true;\n}\n\n/// Checks if the new declaration declared in dependent context must be\n/// put in the same redeclaration chain as the specified declaration.\n///\n/// \\param D Declaration that is checked.\n/// \\param PrevDecl Previous declaration found with proper lookup method for the\n///                 same declaration name.\n/// \\returns True if D must be added to the redeclaration chain which PrevDecl\n///          belongs to.\n///\nbool Sema::shouldLinkDependentDeclWithPrevious(Decl *D, Decl *PrevDecl) {\n  if (!D->getLexicalDeclContext()->isDependentContext())\n    return true;\n\n  // Don't chain dependent friend function definitions until instantiation, to\n  // permit cases like\n  //\n  //   void func();\n  //   template<typename T> class C1 { friend void func() {} };\n  //   template<typename T> class C2 { friend void func() {} };\n  //\n  // ... which is valid if only one of C1 and C2 is ever instantiated.\n  //\n  // FIXME: This need only apply to function definitions. For now, we proxy\n  // this by checking for a file-scope function. We do not want this to apply\n  // to friend declarations nominating member functions, because that gets in\n  // the way of access checks.\n  if (D->getFriendObjectKind() && D->getDeclContext()->isFileContext())\n    return false;\n\n  auto *VD = dyn_cast<ValueDecl>(D);\n  auto *PrevVD = dyn_cast<ValueDecl>(PrevDecl);\n  return !VD || !PrevVD ||\n         canFullyTypeCheckRedeclaration(VD, PrevVD, VD->getType(),\n                                        PrevVD->getType());\n}\n\n/// Check the target attribute of the function for MultiVersion\n/// validity.\n///\n/// Returns true if there was an error, false otherwise.\nstatic bool CheckMultiVersionValue(Sema &S, const FunctionDecl *FD) {\n  const auto *TA = FD->getAttr<TargetAttr>();\n  assert(TA && \"MultiVersion Candidate requires a target attribute\");\n  ParsedTargetAttr ParseInfo = TA->parse();\n  const TargetInfo &TargetInfo = S.Context.getTargetInfo();\n  enum ErrType { Feature = 0, Architecture = 1 };\n\n  if (!ParseInfo.Architecture.empty() &&\n      !TargetInfo.validateCpuIs(ParseInfo.Architecture)) {\n    S.Diag(FD->getLocation(), diag::err_bad_multiversion_option)\n        << Architecture << ParseInfo.Architecture;\n    return true;\n  }\n\n  for (const auto &Feat : ParseInfo.Features) {\n    auto BareFeat = StringRef{Feat}.substr(1);\n    if (Feat[0] == '-') {\n      S.Diag(FD->getLocation(), diag::err_bad_multiversion_option)\n          << Feature << (\"no-\" + BareFeat).str();\n      return true;\n    }\n\n    if (!TargetInfo.validateCpuSupports(BareFeat) ||\n        !TargetInfo.isValidFeatureName(BareFeat)) {\n      S.Diag(FD->getLocation(), diag::err_bad_multiversion_option)\n          << Feature << BareFeat;\n      return true;\n    }\n  }\n  return false;\n}\n\n// Provide a white-list of attributes that are allowed to be combined with\n// multiversion functions.\nstatic bool AttrCompatibleWithMultiVersion(attr::Kind Kind,\n                                           MultiVersionKind MVType) {\n  // Note: this list/diagnosis must match the list in\n  // checkMultiversionAttributesAllSame.\n  switch (Kind) {\n  default:\n    return false;\n  case attr::Used:\n    return MVType == MultiVersionKind::Target;\n  case attr::NonNull:\n  case attr::NoThrow:\n    return true;\n  }\n}\n\nstatic bool checkNonMultiVersionCompatAttributes(Sema &S,\n                                                 const FunctionDecl *FD,\n                                                 const FunctionDecl *CausedFD,\n                                                 MultiVersionKind MVType) {\n  bool IsCPUSpecificCPUDispatchMVType =\n      MVType == MultiVersionKind::CPUDispatch ||\n      MVType == MultiVersionKind::CPUSpecific;\n  const auto Diagnose = [FD, CausedFD, IsCPUSpecificCPUDispatchMVType](\n                            Sema &S, const Attr *A) {\n    S.Diag(FD->getLocation(), diag::err_multiversion_disallowed_other_attr)\n        << IsCPUSpecificCPUDispatchMVType << A;\n    if (CausedFD)\n      S.Diag(CausedFD->getLocation(), diag::note_multiversioning_caused_here);\n    return true;\n  };\n\n  for (const Attr *A : FD->attrs()) {\n    switch (A->getKind()) {\n    case attr::CPUDispatch:\n    case attr::CPUSpecific:\n      if (MVType != MultiVersionKind::CPUDispatch &&\n          MVType != MultiVersionKind::CPUSpecific)\n        return Diagnose(S, A);\n      break;\n    case attr::Target:\n      if (MVType != MultiVersionKind::Target)\n        return Diagnose(S, A);\n      break;\n    default:\n      if (!AttrCompatibleWithMultiVersion(A->getKind(), MVType))\n        return Diagnose(S, A);\n      break;\n    }\n  }\n  return false;\n}\n\nbool Sema::areMultiversionVariantFunctionsCompatible(\n    const FunctionDecl *OldFD, const FunctionDecl *NewFD,\n    const PartialDiagnostic &NoProtoDiagID,\n    const PartialDiagnosticAt &NoteCausedDiagIDAt,\n    const PartialDiagnosticAt &NoSupportDiagIDAt,\n    const PartialDiagnosticAt &DiffDiagIDAt, bool TemplatesSupported,\n    bool ConstexprSupported, bool CLinkageMayDiffer) {\n  enum DoesntSupport {\n    FuncTemplates = 0,\n    VirtFuncs = 1,\n    DeducedReturn = 2,\n    Constructors = 3,\n    Destructors = 4,\n    DeletedFuncs = 5,\n    DefaultedFuncs = 6,\n    ConstexprFuncs = 7,\n    ConstevalFuncs = 8,\n  };\n  enum Different {\n    CallingConv = 0,\n    ReturnType = 1,\n    ConstexprSpec = 2,\n    InlineSpec = 3,\n    StorageClass = 4,\n    Linkage = 5,\n  };\n\n  if (NoProtoDiagID.getDiagID() != 0 && OldFD &&\n      !OldFD->getType()->getAs<FunctionProtoType>()) {\n    Diag(OldFD->getLocation(), NoProtoDiagID);\n    Diag(NoteCausedDiagIDAt.first, NoteCausedDiagIDAt.second);\n    return true;\n  }\n\n  if (NoProtoDiagID.getDiagID() != 0 &&\n      !NewFD->getType()->getAs<FunctionProtoType>())\n    return Diag(NewFD->getLocation(), NoProtoDiagID);\n\n  if (!TemplatesSupported &&\n      NewFD->getTemplatedKind() == FunctionDecl::TK_FunctionTemplate)\n    return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n           << FuncTemplates;\n\n  if (const auto *NewCXXFD = dyn_cast<CXXMethodDecl>(NewFD)) {\n    if (NewCXXFD->isVirtual())\n      return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n             << VirtFuncs;\n\n    if (isa<CXXConstructorDecl>(NewCXXFD))\n      return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n             << Constructors;\n\n    if (isa<CXXDestructorDecl>(NewCXXFD))\n      return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n             << Destructors;\n  }\n\n  if (NewFD->isDeleted())\n    return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n           << DeletedFuncs;\n\n  if (NewFD->isDefaulted())\n    return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n           << DefaultedFuncs;\n\n  if (!ConstexprSupported && NewFD->isConstexpr())\n    return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n           << (NewFD->isConsteval() ? ConstevalFuncs : ConstexprFuncs);\n\n  QualType NewQType = Context.getCanonicalType(NewFD->getType());\n  const auto *NewType = cast<FunctionType>(NewQType);\n  QualType NewReturnType = NewType->getReturnType();\n\n  if (NewReturnType->isUndeducedType())\n    return Diag(NoSupportDiagIDAt.first, NoSupportDiagIDAt.second)\n           << DeducedReturn;\n\n  // Ensure the return type is identical.\n  if (OldFD) {\n    QualType OldQType = Context.getCanonicalType(OldFD->getType());\n    const auto *OldType = cast<FunctionType>(OldQType);\n    FunctionType::ExtInfo OldTypeInfo = OldType->getExtInfo();\n    FunctionType::ExtInfo NewTypeInfo = NewType->getExtInfo();\n\n    if (OldTypeInfo.getCC() != NewTypeInfo.getCC())\n      return Diag(DiffDiagIDAt.first, DiffDiagIDAt.second) << CallingConv;\n\n    QualType OldReturnType = OldType->getReturnType();\n\n    if (OldReturnType != NewReturnType)\n      return Diag(DiffDiagIDAt.first, DiffDiagIDAt.second) << ReturnType;\n\n    if (OldFD->getConstexprKind() != NewFD->getConstexprKind())\n      return Diag(DiffDiagIDAt.first, DiffDiagIDAt.second) << ConstexprSpec;\n\n    if (OldFD->isInlineSpecified() != NewFD->isInlineSpecified())\n      return Diag(DiffDiagIDAt.first, DiffDiagIDAt.second) << InlineSpec;\n\n    if (OldFD->getStorageClass() != NewFD->getStorageClass())\n      return Diag(DiffDiagIDAt.first, DiffDiagIDAt.second) << StorageClass;\n\n    if (!CLinkageMayDiffer && OldFD->isExternC() != NewFD->isExternC())\n      return Diag(DiffDiagIDAt.first, DiffDiagIDAt.second) << Linkage;\n\n    if (CheckEquivalentExceptionSpec(\n            OldFD->getType()->getAs<FunctionProtoType>(), OldFD->getLocation(),\n            NewFD->getType()->getAs<FunctionProtoType>(), NewFD->getLocation()))\n      return true;\n  }\n  return false;\n}\n\nstatic bool CheckMultiVersionAdditionalRules(Sema &S, const FunctionDecl *OldFD,\n                                             const FunctionDecl *NewFD,\n                                             bool CausesMV,\n                                             MultiVersionKind MVType) {\n  if (!S.getASTContext().getTargetInfo().supportsMultiVersioning()) {\n    S.Diag(NewFD->getLocation(), diag::err_multiversion_not_supported);\n    if (OldFD)\n      S.Diag(OldFD->getLocation(), diag::note_previous_declaration);\n    return true;\n  }\n\n  bool IsCPUSpecificCPUDispatchMVType =\n      MVType == MultiVersionKind::CPUDispatch ||\n      MVType == MultiVersionKind::CPUSpecific;\n\n  if (CausesMV && OldFD &&\n      checkNonMultiVersionCompatAttributes(S, OldFD, NewFD, MVType))\n    return true;\n\n  if (checkNonMultiVersionCompatAttributes(S, NewFD, nullptr, MVType))\n    return true;\n\n  // Only allow transition to MultiVersion if it hasn't been used.\n  if (OldFD && CausesMV && OldFD->isUsed(false))\n    return S.Diag(NewFD->getLocation(), diag::err_multiversion_after_used);\n\n  return S.areMultiversionVariantFunctionsCompatible(\n      OldFD, NewFD, S.PDiag(diag::err_multiversion_noproto),\n      PartialDiagnosticAt(NewFD->getLocation(),\n                          S.PDiag(diag::note_multiversioning_caused_here)),\n      PartialDiagnosticAt(NewFD->getLocation(),\n                          S.PDiag(diag::err_multiversion_doesnt_support)\n                              << IsCPUSpecificCPUDispatchMVType),\n      PartialDiagnosticAt(NewFD->getLocation(),\n                          S.PDiag(diag::err_multiversion_diff)),\n      /*TemplatesSupported=*/false,\n      /*ConstexprSupported=*/!IsCPUSpecificCPUDispatchMVType,\n      /*CLinkageMayDiffer=*/false);\n}\n\n/// Check the validity of a multiversion function declaration that is the\n/// first of its kind. Also sets the multiversion'ness' of the function itself.\n///\n/// This sets NewFD->isInvalidDecl() to true if there was an error.\n///\n/// Returns true if there was an error, false otherwise.\nstatic bool CheckMultiVersionFirstFunction(Sema &S, FunctionDecl *FD,\n                                           MultiVersionKind MVType,\n                                           const TargetAttr *TA) {\n  assert(MVType != MultiVersionKind::None &&\n         \"Function lacks multiversion attribute\");\n\n  // Target only causes MV if it is default, otherwise this is a normal\n  // function.\n  if (MVType == MultiVersionKind::Target && !TA->isDefaultVersion())\n    return false;\n\n  if (MVType == MultiVersionKind::Target && CheckMultiVersionValue(S, FD)) {\n    FD->setInvalidDecl();\n    return true;\n  }\n\n  if (CheckMultiVersionAdditionalRules(S, nullptr, FD, true, MVType)) {\n    FD->setInvalidDecl();\n    return true;\n  }\n\n  FD->setIsMultiVersion();\n  return false;\n}\n\nstatic bool PreviousDeclsHaveMultiVersionAttribute(const FunctionDecl *FD) {\n  for (const Decl *D = FD->getPreviousDecl(); D; D = D->getPreviousDecl()) {\n    if (D->getAsFunction()->getMultiVersionKind() != MultiVersionKind::None)\n      return true;\n  }\n\n  return false;\n}\n\nstatic bool CheckTargetCausesMultiVersioning(\n    Sema &S, FunctionDecl *OldFD, FunctionDecl *NewFD, const TargetAttr *NewTA,\n    bool &Redeclaration, NamedDecl *&OldDecl, bool &MergeTypeWithPrevious,\n    LookupResult &Previous) {\n  const auto *OldTA = OldFD->getAttr<TargetAttr>();\n  ParsedTargetAttr NewParsed = NewTA->parse();\n  // Sort order doesn't matter, it just needs to be consistent.\n  llvm::sort(NewParsed.Features);\n\n  // If the old decl is NOT MultiVersioned yet, and we don't cause that\n  // to change, this is a simple redeclaration.\n  if (!NewTA->isDefaultVersion() &&\n      (!OldTA || OldTA->getFeaturesStr() == NewTA->getFeaturesStr()))\n    return false;\n\n  // Otherwise, this decl causes MultiVersioning.\n  if (!S.getASTContext().getTargetInfo().supportsMultiVersioning()) {\n    S.Diag(NewFD->getLocation(), diag::err_multiversion_not_supported);\n    S.Diag(OldFD->getLocation(), diag::note_previous_declaration);\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  if (CheckMultiVersionAdditionalRules(S, OldFD, NewFD, true,\n                                       MultiVersionKind::Target)) {\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  if (CheckMultiVersionValue(S, NewFD)) {\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  // If this is 'default', permit the forward declaration.\n  if (!OldFD->isMultiVersion() && !OldTA && NewTA->isDefaultVersion()) {\n    Redeclaration = true;\n    OldDecl = OldFD;\n    OldFD->setIsMultiVersion();\n    NewFD->setIsMultiVersion();\n    return false;\n  }\n\n  if (CheckMultiVersionValue(S, OldFD)) {\n    S.Diag(NewFD->getLocation(), diag::note_multiversioning_caused_here);\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  ParsedTargetAttr OldParsed = OldTA->parse(std::less<std::string>());\n\n  if (OldParsed == NewParsed) {\n    S.Diag(NewFD->getLocation(), diag::err_multiversion_duplicate);\n    S.Diag(OldFD->getLocation(), diag::note_previous_declaration);\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  for (const auto *FD : OldFD->redecls()) {\n    const auto *CurTA = FD->getAttr<TargetAttr>();\n    // We allow forward declarations before ANY multiversioning attributes, but\n    // nothing after the fact.\n    if (PreviousDeclsHaveMultiVersionAttribute(FD) &&\n        (!CurTA || CurTA->isInherited())) {\n      S.Diag(FD->getLocation(), diag::err_multiversion_required_in_redecl)\n          << 0;\n      S.Diag(NewFD->getLocation(), diag::note_multiversioning_caused_here);\n      NewFD->setInvalidDecl();\n      return true;\n    }\n  }\n\n  OldFD->setIsMultiVersion();\n  NewFD->setIsMultiVersion();\n  Redeclaration = false;\n  MergeTypeWithPrevious = false;\n  OldDecl = nullptr;\n  Previous.clear();\n  return false;\n}\n\n/// Check the validity of a new function declaration being added to an existing\n/// multiversioned declaration collection.\nstatic bool CheckMultiVersionAdditionalDecl(\n    Sema &S, FunctionDecl *OldFD, FunctionDecl *NewFD,\n    MultiVersionKind NewMVType, const TargetAttr *NewTA,\n    const CPUDispatchAttr *NewCPUDisp, const CPUSpecificAttr *NewCPUSpec,\n    bool &Redeclaration, NamedDecl *&OldDecl, bool &MergeTypeWithPrevious,\n    LookupResult &Previous) {\n\n  MultiVersionKind OldMVType = OldFD->getMultiVersionKind();\n  // Disallow mixing of multiversioning types.\n  if ((OldMVType == MultiVersionKind::Target &&\n       NewMVType != MultiVersionKind::Target) ||\n      (NewMVType == MultiVersionKind::Target &&\n       OldMVType != MultiVersionKind::Target)) {\n    S.Diag(NewFD->getLocation(), diag::err_multiversion_types_mixed);\n    S.Diag(OldFD->getLocation(), diag::note_previous_declaration);\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  ParsedTargetAttr NewParsed;\n  if (NewTA) {\n    NewParsed = NewTA->parse();\n    llvm::sort(NewParsed.Features);\n  }\n\n  bool UseMemberUsingDeclRules =\n      S.CurContext->isRecord() && !NewFD->getFriendObjectKind();\n\n  // Next, check ALL non-overloads to see if this is a redeclaration of a\n  // previous member of the MultiVersion set.\n  for (NamedDecl *ND : Previous) {\n    FunctionDecl *CurFD = ND->getAsFunction();\n    if (!CurFD)\n      continue;\n    if (S.IsOverload(NewFD, CurFD, UseMemberUsingDeclRules))\n      continue;\n\n    if (NewMVType == MultiVersionKind::Target) {\n      const auto *CurTA = CurFD->getAttr<TargetAttr>();\n      if (CurTA->getFeaturesStr() == NewTA->getFeaturesStr()) {\n        NewFD->setIsMultiVersion();\n        Redeclaration = true;\n        OldDecl = ND;\n        return false;\n      }\n\n      ParsedTargetAttr CurParsed = CurTA->parse(std::less<std::string>());\n      if (CurParsed == NewParsed) {\n        S.Diag(NewFD->getLocation(), diag::err_multiversion_duplicate);\n        S.Diag(CurFD->getLocation(), diag::note_previous_declaration);\n        NewFD->setInvalidDecl();\n        return true;\n      }\n    } else {\n      const auto *CurCPUSpec = CurFD->getAttr<CPUSpecificAttr>();\n      const auto *CurCPUDisp = CurFD->getAttr<CPUDispatchAttr>();\n      // Handle CPUDispatch/CPUSpecific versions.\n      // Only 1 CPUDispatch function is allowed, this will make it go through\n      // the redeclaration errors.\n      if (NewMVType == MultiVersionKind::CPUDispatch &&\n          CurFD->hasAttr<CPUDispatchAttr>()) {\n        if (CurCPUDisp->cpus_size() == NewCPUDisp->cpus_size() &&\n            std::equal(\n                CurCPUDisp->cpus_begin(), CurCPUDisp->cpus_end(),\n                NewCPUDisp->cpus_begin(),\n                [](const IdentifierInfo *Cur, const IdentifierInfo *New) {\n                  return Cur->getName() == New->getName();\n                })) {\n          NewFD->setIsMultiVersion();\n          Redeclaration = true;\n          OldDecl = ND;\n          return false;\n        }\n\n        // If the declarations don't match, this is an error condition.\n        S.Diag(NewFD->getLocation(), diag::err_cpu_dispatch_mismatch);\n        S.Diag(CurFD->getLocation(), diag::note_previous_declaration);\n        NewFD->setInvalidDecl();\n        return true;\n      }\n      if (NewMVType == MultiVersionKind::CPUSpecific && CurCPUSpec) {\n\n        if (CurCPUSpec->cpus_size() == NewCPUSpec->cpus_size() &&\n            std::equal(\n                CurCPUSpec->cpus_begin(), CurCPUSpec->cpus_end(),\n                NewCPUSpec->cpus_begin(),\n                [](const IdentifierInfo *Cur, const IdentifierInfo *New) {\n                  return Cur->getName() == New->getName();\n                })) {\n          NewFD->setIsMultiVersion();\n          Redeclaration = true;\n          OldDecl = ND;\n          return false;\n        }\n\n        // Only 1 version of CPUSpecific is allowed for each CPU.\n        for (const IdentifierInfo *CurII : CurCPUSpec->cpus()) {\n          for (const IdentifierInfo *NewII : NewCPUSpec->cpus()) {\n            if (CurII == NewII) {\n              S.Diag(NewFD->getLocation(), diag::err_cpu_specific_multiple_defs)\n                  << NewII;\n              S.Diag(CurFD->getLocation(), diag::note_previous_declaration);\n              NewFD->setInvalidDecl();\n              return true;\n            }\n          }\n        }\n      }\n      // If the two decls aren't the same MVType, there is no possible error\n      // condition.\n    }\n  }\n\n  // Else, this is simply a non-redecl case.  Checking the 'value' is only\n  // necessary in the Target case, since The CPUSpecific/Dispatch cases are\n  // handled in the attribute adding step.\n  if (NewMVType == MultiVersionKind::Target &&\n      CheckMultiVersionValue(S, NewFD)) {\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  if (CheckMultiVersionAdditionalRules(S, OldFD, NewFD,\n                                       !OldFD->isMultiVersion(), NewMVType)) {\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  // Permit forward declarations in the case where these two are compatible.\n  if (!OldFD->isMultiVersion()) {\n    OldFD->setIsMultiVersion();\n    NewFD->setIsMultiVersion();\n    Redeclaration = true;\n    OldDecl = OldFD;\n    return false;\n  }\n\n  NewFD->setIsMultiVersion();\n  Redeclaration = false;\n  MergeTypeWithPrevious = false;\n  OldDecl = nullptr;\n  Previous.clear();\n  return false;\n}\n\n\n/// Check the validity of a mulitversion function declaration.\n/// Also sets the multiversion'ness' of the function itself.\n///\n/// This sets NewFD->isInvalidDecl() to true if there was an error.\n///\n/// Returns true if there was an error, false otherwise.\nstatic bool CheckMultiVersionFunction(Sema &S, FunctionDecl *NewFD,\n                                      bool &Redeclaration, NamedDecl *&OldDecl,\n                                      bool &MergeTypeWithPrevious,\n                                      LookupResult &Previous) {\n  const auto *NewTA = NewFD->getAttr<TargetAttr>();\n  const auto *NewCPUDisp = NewFD->getAttr<CPUDispatchAttr>();\n  const auto *NewCPUSpec = NewFD->getAttr<CPUSpecificAttr>();\n\n  // Mixing Multiversioning types is prohibited.\n  if ((NewTA && NewCPUDisp) || (NewTA && NewCPUSpec) ||\n      (NewCPUDisp && NewCPUSpec)) {\n    S.Diag(NewFD->getLocation(), diag::err_multiversion_types_mixed);\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  MultiVersionKind  MVType = NewFD->getMultiVersionKind();\n\n  // Main isn't allowed to become a multiversion function, however it IS\n  // permitted to have 'main' be marked with the 'target' optimization hint.\n  if (NewFD->isMain()) {\n    if ((MVType == MultiVersionKind::Target && NewTA->isDefaultVersion()) ||\n        MVType == MultiVersionKind::CPUDispatch ||\n        MVType == MultiVersionKind::CPUSpecific) {\n      S.Diag(NewFD->getLocation(), diag::err_multiversion_not_allowed_on_main);\n      NewFD->setInvalidDecl();\n      return true;\n    }\n    return false;\n  }\n\n  if (!OldDecl || !OldDecl->getAsFunction() ||\n      OldDecl->getDeclContext()->getRedeclContext() !=\n          NewFD->getDeclContext()->getRedeclContext()) {\n    // If there's no previous declaration, AND this isn't attempting to cause\n    // multiversioning, this isn't an error condition.\n    if (MVType == MultiVersionKind::None)\n      return false;\n    return CheckMultiVersionFirstFunction(S, NewFD, MVType, NewTA);\n  }\n\n  FunctionDecl *OldFD = OldDecl->getAsFunction();\n\n  if (!OldFD->isMultiVersion() && MVType == MultiVersionKind::None)\n    return false;\n\n  if (OldFD->isMultiVersion() && MVType == MultiVersionKind::None) {\n    S.Diag(NewFD->getLocation(), diag::err_multiversion_required_in_redecl)\n        << (OldFD->getMultiVersionKind() != MultiVersionKind::Target);\n    NewFD->setInvalidDecl();\n    return true;\n  }\n\n  // Handle the target potentially causes multiversioning case.\n  if (!OldFD->isMultiVersion() && MVType == MultiVersionKind::Target)\n    return CheckTargetCausesMultiVersioning(S, OldFD, NewFD, NewTA,\n                                            Redeclaration, OldDecl,\n                                            MergeTypeWithPrevious, Previous);\n\n  // At this point, we have a multiversion function decl (in OldFD) AND an\n  // appropriate attribute in the current function decl.  Resolve that these are\n  // still compatible with previous declarations.\n  return CheckMultiVersionAdditionalDecl(\n      S, OldFD, NewFD, MVType, NewTA, NewCPUDisp, NewCPUSpec, Redeclaration,\n      OldDecl, MergeTypeWithPrevious, Previous);\n}\n\n/// Perform semantic checking of a new function declaration.\n///\n/// Performs semantic analysis of the new function declaration\n/// NewFD. This routine performs all semantic checking that does not\n/// require the actual declarator involved in the declaration, and is\n/// used both for the declaration of functions as they are parsed\n/// (called via ActOnDeclarator) and for the declaration of functions\n/// that have been instantiated via C++ template instantiation (called\n/// via InstantiateDecl).\n///\n/// \\param IsMemberSpecialization whether this new function declaration is\n/// a member specialization (that replaces any definition provided by the\n/// previous declaration).\n///\n/// This sets NewFD->isInvalidDecl() to true if there was an error.\n///\n/// \\returns true if the function declaration is a redeclaration.\nbool Sema::CheckFunctionDeclaration(Scope *S, FunctionDecl *NewFD,\n                                    LookupResult &Previous,\n                                    bool IsMemberSpecialization) {\n  assert(!NewFD->getReturnType()->isVariablyModifiedType() &&\n         \"Variably modified return types are not handled here\");\n\n  // Determine whether the type of this function should be merged with\n  // a previous visible declaration. This never happens for functions in C++,\n  // and always happens in C if the previous declaration was visible.\n  bool MergeTypeWithPrevious = !getLangOpts().CPlusPlus &&\n                               !Previous.isShadowed();\n\n  bool Redeclaration = false;\n  NamedDecl *OldDecl = nullptr;\n  bool MayNeedOverloadableChecks = false;\n\n  // Merge or overload the declaration with an existing declaration of\n  // the same name, if appropriate.\n  if (!Previous.empty()) {\n    // Determine whether NewFD is an overload of PrevDecl or\n    // a declaration that requires merging. If it's an overload,\n    // there's no more work to do here; we'll just add the new\n    // function to the scope.\n    if (!AllowOverloadingOfFunction(Previous, Context, NewFD)) {\n      NamedDecl *Candidate = Previous.getRepresentativeDecl();\n      if (shouldLinkPossiblyHiddenDecl(Candidate, NewFD)) {\n        Redeclaration = true;\n        OldDecl = Candidate;\n      }\n    } else {\n      MayNeedOverloadableChecks = true;\n      switch (CheckOverload(S, NewFD, Previous, OldDecl,\n                            /*NewIsUsingDecl*/ false)) {\n      case Ovl_Match:\n        Redeclaration = true;\n        break;\n\n      case Ovl_NonFunction:\n        Redeclaration = true;\n        break;\n\n      case Ovl_Overload:\n        Redeclaration = false;\n        break;\n      }\n    }\n  }\n\n  // Check for a previous extern \"C\" declaration with this name.\n  if (!Redeclaration &&\n      checkForConflictWithNonVisibleExternC(*this, NewFD, Previous)) {\n    if (!Previous.empty()) {\n      // This is an extern \"C\" declaration with the same name as a previous\n      // declaration, and thus redeclares that entity...\n      Redeclaration = true;\n      OldDecl = Previous.getFoundDecl();\n      MergeTypeWithPrevious = false;\n\n      // ... except in the presence of __attribute__((overloadable)).\n      if (OldDecl->hasAttr<OverloadableAttr>() ||\n          NewFD->hasAttr<OverloadableAttr>()) {\n        if (IsOverload(NewFD, cast<FunctionDecl>(OldDecl), false)) {\n          MayNeedOverloadableChecks = true;\n          Redeclaration = false;\n          OldDecl = nullptr;\n        }\n      }\n    }\n  }\n\n  if (CheckMultiVersionFunction(*this, NewFD, Redeclaration, OldDecl,\n                                MergeTypeWithPrevious, Previous))\n    return Redeclaration;\n\n  // PPC MMA non-pointer types are not allowed as function return types.\n  if (Context.getTargetInfo().getTriple().isPPC64() &&\n      CheckPPCMMAType(NewFD->getReturnType(), NewFD->getLocation())) {\n    NewFD->setInvalidDecl();\n  }\n\n  // C++11 [dcl.constexpr]p8:\n  //   A constexpr specifier for a non-static member function that is not\n  //   a constructor declares that member function to be const.\n  //\n  // This needs to be delayed until we know whether this is an out-of-line\n  // definition of a static member function.\n  //\n  // This rule is not present in C++1y, so we produce a backwards\n  // compatibility warning whenever it happens in C++11.\n  CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(NewFD);\n  if (!getLangOpts().CPlusPlus14 && MD && MD->isConstexpr() &&\n      !MD->isStatic() && !isa<CXXConstructorDecl>(MD) &&\n      !isa<CXXDestructorDecl>(MD) && !MD->getMethodQualifiers().hasConst()) {\n    CXXMethodDecl *OldMD = nullptr;\n    if (OldDecl)\n      OldMD = dyn_cast_or_null<CXXMethodDecl>(OldDecl->getAsFunction());\n    if (!OldMD || !OldMD->isStatic()) {\n      const FunctionProtoType *FPT =\n        MD->getType()->castAs<FunctionProtoType>();\n      FunctionProtoType::ExtProtoInfo EPI = FPT->getExtProtoInfo();\n      EPI.TypeQuals.addConst();\n      MD->setType(Context.getFunctionType(FPT->getReturnType(),\n                                          FPT->getParamTypes(), EPI));\n\n      // Warn that we did this, if we're not performing template instantiation.\n      // In that case, we'll have warned already when the template was defined.\n      if (!inTemplateInstantiation()) {\n        SourceLocation AddConstLoc;\n        if (FunctionTypeLoc FTL = MD->getTypeSourceInfo()->getTypeLoc()\n                .IgnoreParens().getAs<FunctionTypeLoc>())\n          AddConstLoc = getLocForEndOfToken(FTL.getRParenLoc());\n\n        Diag(MD->getLocation(), diag::warn_cxx14_compat_constexpr_not_const)\n          << FixItHint::CreateInsertion(AddConstLoc, \" const\");\n      }\n    }\n  }\n\n  if (Redeclaration) {\n    // NewFD and OldDecl represent declarations that need to be\n    // merged.\n    if (MergeFunctionDecl(NewFD, OldDecl, S, MergeTypeWithPrevious)) {\n      NewFD->setInvalidDecl();\n      return Redeclaration;\n    }\n\n    Previous.clear();\n    Previous.addDecl(OldDecl);\n\n    if (FunctionTemplateDecl *OldTemplateDecl =\n            dyn_cast<FunctionTemplateDecl>(OldDecl)) {\n      auto *OldFD = OldTemplateDecl->getTemplatedDecl();\n      FunctionTemplateDecl *NewTemplateDecl\n        = NewFD->getDescribedFunctionTemplate();\n      assert(NewTemplateDecl && \"Template/non-template mismatch\");\n\n      // The call to MergeFunctionDecl above may have created some state in\n      // NewTemplateDecl that needs to be merged with OldTemplateDecl before we\n      // can add it as a redeclaration.\n      NewTemplateDecl->mergePrevDecl(OldTemplateDecl);\n\n      NewFD->setPreviousDeclaration(OldFD);\n      if (NewFD->isCXXClassMember()) {\n        NewFD->setAccess(OldTemplateDecl->getAccess());\n        NewTemplateDecl->setAccess(OldTemplateDecl->getAccess());\n      }\n\n      // If this is an explicit specialization of a member that is a function\n      // template, mark it as a member specialization.\n      if (IsMemberSpecialization &&\n          NewTemplateDecl->getInstantiatedFromMemberTemplate()) {\n        NewTemplateDecl->setMemberSpecialization();\n        assert(OldTemplateDecl->isMemberSpecialization());\n        // Explicit specializations of a member template do not inherit deleted\n        // status from the parent member template that they are specializing.\n        if (OldFD->isDeleted()) {\n          // FIXME: This assert will not hold in the presence of modules.\n          assert(OldFD->getCanonicalDecl() == OldFD);\n          // FIXME: We need an update record for this AST mutation.\n          OldFD->setDeletedAsWritten(false);\n        }\n      }\n\n    } else {\n      if (shouldLinkDependentDeclWithPrevious(NewFD, OldDecl)) {\n        auto *OldFD = cast<FunctionDecl>(OldDecl);\n        // This needs to happen first so that 'inline' propagates.\n        NewFD->setPreviousDeclaration(OldFD);\n        if (NewFD->isCXXClassMember())\n          NewFD->setAccess(OldFD->getAccess());\n      }\n    }\n  } else if (!getLangOpts().CPlusPlus && MayNeedOverloadableChecks &&\n             !NewFD->getAttr<OverloadableAttr>()) {\n    assert((Previous.empty() ||\n            llvm::any_of(Previous,\n                         [](const NamedDecl *ND) {\n                           return ND->hasAttr<OverloadableAttr>();\n                         })) &&\n           \"Non-redecls shouldn't happen without overloadable present\");\n\n    auto OtherUnmarkedIter = llvm::find_if(Previous, [](const NamedDecl *ND) {\n      const auto *FD = dyn_cast<FunctionDecl>(ND);\n      return FD && !FD->hasAttr<OverloadableAttr>();\n    });\n\n    if (OtherUnmarkedIter != Previous.end()) {\n      Diag(NewFD->getLocation(),\n           diag::err_attribute_overloadable_multiple_unmarked_overloads);\n      Diag((*OtherUnmarkedIter)->getLocation(),\n           diag::note_attribute_overloadable_prev_overload)\n          << false;\n\n      NewFD->addAttr(OverloadableAttr::CreateImplicit(Context));\n    }\n  }\n\n  if (LangOpts.OpenMP)\n    ActOnFinishedFunctionDefinitionInOpenMPAssumeScope(NewFD);\n\n  // Semantic checking for this function declaration (in isolation).\n\n  if (getLangOpts().CPlusPlus) {\n    // C++-specific checks.\n    if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(NewFD)) {\n      CheckConstructor(Constructor);\n    } else if (CXXDestructorDecl *Destructor =\n                dyn_cast<CXXDestructorDecl>(NewFD)) {\n      CXXRecordDecl *Record = Destructor->getParent();\n      QualType ClassType = Context.getTypeDeclType(Record);\n\n      // FIXME: Shouldn't we be able to perform this check even when the class\n      // type is dependent? Both gcc and edg can handle that.\n      if (!ClassType->isDependentType()) {\n        DeclarationName Name\n          = Context.DeclarationNames.getCXXDestructorName(\n                                        Context.getCanonicalType(ClassType));\n        if (NewFD->getDeclName() != Name) {\n          Diag(NewFD->getLocation(), diag::err_destructor_name);\n          NewFD->setInvalidDecl();\n          return Redeclaration;\n        }\n      }\n    } else if (auto *Guide = dyn_cast<CXXDeductionGuideDecl>(NewFD)) {\n      if (auto *TD = Guide->getDescribedFunctionTemplate())\n        CheckDeductionGuideTemplate(TD);\n\n      // A deduction guide is not on the list of entities that can be\n      // explicitly specialized.\n      if (Guide->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)\n        Diag(Guide->getBeginLoc(), diag::err_deduction_guide_specialized)\n            << /*explicit specialization*/ 1;\n    }\n\n    // Find any virtual functions that this function overrides.\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(NewFD)) {\n      if (!Method->isFunctionTemplateSpecialization() &&\n          !Method->getDescribedFunctionTemplate() &&\n          Method->isCanonicalDecl()) {\n        AddOverriddenMethods(Method->getParent(), Method);\n      }\n      if (Method->isVirtual() && NewFD->getTrailingRequiresClause())\n        // C++2a [class.virtual]p6\n        // A virtual method shall not have a requires-clause.\n        Diag(NewFD->getTrailingRequiresClause()->getBeginLoc(),\n             diag::err_constrained_virtual_method);\n\n      if (Method->isStatic())\n        checkThisInStaticMemberFunctionType(Method);\n    }\n\n    if (CXXConversionDecl *Conversion = dyn_cast<CXXConversionDecl>(NewFD))\n      ActOnConversionDeclarator(Conversion);\n\n    // Extra checking for C++ overloaded operators (C++ [over.oper]).\n    if (NewFD->isOverloadedOperator() &&\n        CheckOverloadedOperatorDeclaration(NewFD)) {\n      NewFD->setInvalidDecl();\n      return Redeclaration;\n    }\n\n    // Extra checking for C++0x literal operators (C++0x [over.literal]).\n    if (NewFD->getLiteralIdentifier() &&\n        CheckLiteralOperatorDeclaration(NewFD)) {\n      NewFD->setInvalidDecl();\n      return Redeclaration;\n    }\n\n    // In C++, check default arguments now that we have merged decls. Unless\n    // the lexical context is the class, because in this case this is done\n    // during delayed parsing anyway.\n    if (!CurContext->isRecord())\n      CheckCXXDefaultArguments(NewFD);\n\n    // If this function declares a builtin function, check the type of this\n    // declaration against the expected type for the builtin.\n    if (unsigned BuiltinID = NewFD->getBuiltinID()) {\n      ASTContext::GetBuiltinTypeError Error;\n      LookupNecessaryTypesForBuiltin(S, BuiltinID);\n      QualType T = Context.GetBuiltinType(BuiltinID, Error);\n      // If the type of the builtin differs only in its exception\n      // specification, that's OK.\n      // FIXME: If the types do differ in this way, it would be better to\n      // retain the 'noexcept' form of the type.\n      if (!T.isNull() &&\n          !Context.hasSameFunctionTypeIgnoringExceptionSpec(T,\n                                                            NewFD->getType()))\n        // The type of this function differs from the type of the builtin,\n        // so forget about the builtin entirely.\n        Context.BuiltinInfo.forgetBuiltin(BuiltinID, Context.Idents);\n    }\n\n    // If this function is declared as being extern \"C\", then check to see if\n    // the function returns a UDT (class, struct, or union type) that is not C\n    // compatible, and if it does, warn the user.\n    // But, issue any diagnostic on the first declaration only.\n    if (Previous.empty() && NewFD->isExternC()) {\n      QualType R = NewFD->getReturnType();\n      if (R->isIncompleteType() && !R->isVoidType())\n        Diag(NewFD->getLocation(), diag::warn_return_value_udt_incomplete)\n            << NewFD << R;\n      else if (!R.isPODType(Context) && !R->isVoidType() &&\n               !R->isObjCObjectPointerType())\n        Diag(NewFD->getLocation(), diag::warn_return_value_udt) << NewFD << R;\n    }\n\n    // C++1z [dcl.fct]p6:\n    //   [...] whether the function has a non-throwing exception-specification\n    //   [is] part of the function type\n    //\n    // This results in an ABI break between C++14 and C++17 for functions whose\n    // declared type includes an exception-specification in a parameter or\n    // return type. (Exception specifications on the function itself are OK in\n    // most cases, and exception specifications are not permitted in most other\n    // contexts where they could make it into a mangling.)\n    if (!getLangOpts().CPlusPlus17 && !NewFD->getPrimaryTemplate()) {\n      auto HasNoexcept = [&](QualType T) -> bool {\n        // Strip off declarator chunks that could be between us and a function\n        // type. We don't need to look far, exception specifications are very\n        // restricted prior to C++17.\n        if (auto *RT = T->getAs<ReferenceType>())\n          T = RT->getPointeeType();\n        else if (T->isAnyPointerType())\n          T = T->getPointeeType();\n        else if (auto *MPT = T->getAs<MemberPointerType>())\n          T = MPT->getPointeeType();\n        if (auto *FPT = T->getAs<FunctionProtoType>())\n          if (FPT->isNothrow())\n            return true;\n        return false;\n      };\n\n      auto *FPT = NewFD->getType()->castAs<FunctionProtoType>();\n      bool AnyNoexcept = HasNoexcept(FPT->getReturnType());\n      for (QualType T : FPT->param_types())\n        AnyNoexcept |= HasNoexcept(T);\n      if (AnyNoexcept)\n        Diag(NewFD->getLocation(),\n             diag::warn_cxx17_compat_exception_spec_in_signature)\n            << NewFD;\n    }\n\n    if (!Redeclaration && LangOpts.CUDA)\n      checkCUDATargetOverload(NewFD, Previous);\n  }\n  return Redeclaration;\n}\n\nvoid Sema::CheckMain(FunctionDecl* FD, const DeclSpec& DS) {\n  // C++11 [basic.start.main]p3:\n  //   A program that [...] declares main to be inline, static or\n  //   constexpr is ill-formed.\n  // C11 6.7.4p4:  In a hosted environment, no function specifier(s) shall\n  //   appear in a declaration of main.\n  // static main is not an error under C99, but we should warn about it.\n  // We accept _Noreturn main as an extension.\n  if (FD->getStorageClass() == SC_Static)\n    Diag(DS.getStorageClassSpecLoc(), getLangOpts().CPlusPlus\n         ? diag::err_static_main : diag::warn_static_main)\n      << FixItHint::CreateRemoval(DS.getStorageClassSpecLoc());\n  if (FD->isInlineSpecified())\n    Diag(DS.getInlineSpecLoc(), diag::err_inline_main)\n      << FixItHint::CreateRemoval(DS.getInlineSpecLoc());\n  if (DS.isNoreturnSpecified()) {\n    SourceLocation NoreturnLoc = DS.getNoreturnSpecLoc();\n    SourceRange NoreturnRange(NoreturnLoc, getLocForEndOfToken(NoreturnLoc));\n    Diag(NoreturnLoc, diag::ext_noreturn_main);\n    Diag(NoreturnLoc, diag::note_main_remove_noreturn)\n      << FixItHint::CreateRemoval(NoreturnRange);\n  }\n  if (FD->isConstexpr()) {\n    Diag(DS.getConstexprSpecLoc(), diag::err_constexpr_main)\n        << FD->isConsteval()\n        << FixItHint::CreateRemoval(DS.getConstexprSpecLoc());\n    FD->setConstexprKind(ConstexprSpecKind::Unspecified);\n  }\n\n  if (getLangOpts().OpenCL) {\n    Diag(FD->getLocation(), diag::err_opencl_no_main)\n        << FD->hasAttr<OpenCLKernelAttr>();\n    FD->setInvalidDecl();\n    return;\n  }\n\n  QualType T = FD->getType();\n  assert(T->isFunctionType() && \"function decl is not of function type\");\n  const FunctionType* FT = T->castAs<FunctionType>();\n\n  // Set default calling convention for main()\n  if (FT->getCallConv() != CC_C) {\n    FT = Context.adjustFunctionType(FT, FT->getExtInfo().withCallingConv(CC_C));\n    FD->setType(QualType(FT, 0));\n    T = Context.getCanonicalType(FD->getType());\n  }\n\n  if (getLangOpts().GNUMode && !getLangOpts().CPlusPlus) {\n    // In C with GNU extensions we allow main() to have non-integer return\n    // type, but we should warn about the extension, and we disable the\n    // implicit-return-zero rule.\n\n    // GCC in C mode accepts qualified 'int'.\n    if (Context.hasSameUnqualifiedType(FT->getReturnType(), Context.IntTy))\n      FD->setHasImplicitReturnZero(true);\n    else {\n      Diag(FD->getTypeSpecStartLoc(), diag::ext_main_returns_nonint);\n      SourceRange RTRange = FD->getReturnTypeSourceRange();\n      if (RTRange.isValid())\n        Diag(RTRange.getBegin(), diag::note_main_change_return_type)\n            << FixItHint::CreateReplacement(RTRange, \"int\");\n    }\n  } else {\n    // In C and C++, main magically returns 0 if you fall off the end;\n    // set the flag which tells us that.\n    // This is C++ [basic.start.main]p5 and C99 5.1.2.2.3.\n\n    // All the standards say that main() should return 'int'.\n    if (Context.hasSameType(FT->getReturnType(), Context.IntTy))\n      FD->setHasImplicitReturnZero(true);\n    else {\n      // Otherwise, this is just a flat-out error.\n      SourceRange RTRange = FD->getReturnTypeSourceRange();\n      Diag(FD->getTypeSpecStartLoc(), diag::err_main_returns_nonint)\n          << (RTRange.isValid() ? FixItHint::CreateReplacement(RTRange, \"int\")\n                                : FixItHint());\n      FD->setInvalidDecl(true);\n    }\n  }\n\n  // Treat protoless main() as nullary.\n  if (isa<FunctionNoProtoType>(FT)) return;\n\n  const FunctionProtoType* FTP = cast<const FunctionProtoType>(FT);\n  unsigned nparams = FTP->getNumParams();\n  assert(FD->getNumParams() == nparams);\n\n  bool HasExtraParameters = (nparams > 3);\n\n  if (FTP->isVariadic()) {\n    Diag(FD->getLocation(), diag::ext_variadic_main);\n    // FIXME: if we had information about the location of the ellipsis, we\n    // could add a FixIt hint to remove it as a parameter.\n  }\n\n  // Darwin passes an undocumented fourth argument of type char**.  If\n  // other platforms start sprouting these, the logic below will start\n  // getting shifty.\n  if (nparams == 4 && Context.getTargetInfo().getTriple().isOSDarwin())\n    HasExtraParameters = false;\n\n  if (HasExtraParameters) {\n    Diag(FD->getLocation(), diag::err_main_surplus_args) << nparams;\n    FD->setInvalidDecl(true);\n    nparams = 3;\n  }\n\n  // FIXME: a lot of the following diagnostics would be improved\n  // if we had some location information about types.\n\n  QualType CharPP =\n    Context.getPointerType(Context.getPointerType(Context.CharTy));\n  QualType Expected[] = { Context.IntTy, CharPP, CharPP, CharPP };\n\n  for (unsigned i = 0; i < nparams; ++i) {\n    QualType AT = FTP->getParamType(i);\n\n    bool mismatch = true;\n\n    if (Context.hasSameUnqualifiedType(AT, Expected[i]))\n      mismatch = false;\n    else if (Expected[i] == CharPP) {\n      // As an extension, the following forms are okay:\n      //   char const **\n      //   char const * const *\n      //   char * const *\n\n      QualifierCollector qs;\n      const PointerType* PT;\n      if ((PT = qs.strip(AT)->getAs<PointerType>()) &&\n          (PT = qs.strip(PT->getPointeeType())->getAs<PointerType>()) &&\n          Context.hasSameType(QualType(qs.strip(PT->getPointeeType()), 0),\n                              Context.CharTy)) {\n        qs.removeConst();\n        mismatch = !qs.empty();\n      }\n    }\n\n    if (mismatch) {\n      Diag(FD->getLocation(), diag::err_main_arg_wrong) << i << Expected[i];\n      // TODO: suggest replacing given type with expected type\n      FD->setInvalidDecl(true);\n    }\n  }\n\n  if (nparams == 1 && !FD->isInvalidDecl()) {\n    Diag(FD->getLocation(), diag::warn_main_one_arg);\n  }\n\n  if (!FD->isInvalidDecl() && FD->getDescribedFunctionTemplate()) {\n    Diag(FD->getLocation(), diag::err_mainlike_template_decl) << FD;\n    FD->setInvalidDecl();\n  }\n}\n\nvoid Sema::CheckMSVCRTEntryPoint(FunctionDecl *FD) {\n  QualType T = FD->getType();\n  assert(T->isFunctionType() && \"function decl is not of function type\");\n  const FunctionType *FT = T->castAs<FunctionType>();\n\n  // Set an implicit return of 'zero' if the function can return some integral,\n  // enumeration, pointer or nullptr type.\n  if (FT->getReturnType()->isIntegralOrEnumerationType() ||\n      FT->getReturnType()->isAnyPointerType() ||\n      FT->getReturnType()->isNullPtrType())\n    // DllMain is exempt because a return value of zero means it failed.\n    if (FD->getName() != \"DllMain\")\n      FD->setHasImplicitReturnZero(true);\n\n  if (!FD->isInvalidDecl() && FD->getDescribedFunctionTemplate()) {\n    Diag(FD->getLocation(), diag::err_mainlike_template_decl) << FD;\n    FD->setInvalidDecl();\n  }\n}\n\nbool Sema::CheckForConstantInitializer(Expr *Init, QualType DclT) {\n  // FIXME: Need strict checking.  In C89, we need to check for\n  // any assignment, increment, decrement, function-calls, or\n  // commas outside of a sizeof.  In C99, it's the same list,\n  // except that the aforementioned are allowed in unevaluated\n  // expressions.  Everything else falls under the\n  // \"may accept other forms of constant expressions\" exception.\n  //\n  // Regular C++ code will not end up here (exceptions: language extensions,\n  // OpenCL C++ etc), so the constant expression rules there don't matter.\n  if (Init->isValueDependent()) {\n    assert(Init->containsErrors() &&\n           \"Dependent code should only occur in error-recovery path.\");\n    return true;\n  }\n  const Expr *Culprit;\n  if (Init->isConstantInitializer(Context, false, &Culprit))\n    return false;\n  Diag(Culprit->getExprLoc(), diag::err_init_element_not_constant)\n    << Culprit->getSourceRange();\n  return true;\n}\n\nnamespace {\n  // Visits an initialization expression to see if OrigDecl is evaluated in\n  // its own initialization and throws a warning if it does.\n  class SelfReferenceChecker\n      : public EvaluatedExprVisitor<SelfReferenceChecker> {\n    Sema &S;\n    Decl *OrigDecl;\n    bool isRecordType;\n    bool isPODType;\n    bool isReferenceType;\n\n    bool isInitList;\n    llvm::SmallVector<unsigned, 4> InitFieldIndex;\n\n  public:\n    typedef EvaluatedExprVisitor<SelfReferenceChecker> Inherited;\n\n    SelfReferenceChecker(Sema &S, Decl *OrigDecl) : Inherited(S.Context),\n                                                    S(S), OrigDecl(OrigDecl) {\n      isPODType = false;\n      isRecordType = false;\n      isReferenceType = false;\n      isInitList = false;\n      if (ValueDecl *VD = dyn_cast<ValueDecl>(OrigDecl)) {\n        isPODType = VD->getType().isPODType(S.Context);\n        isRecordType = VD->getType()->isRecordType();\n        isReferenceType = VD->getType()->isReferenceType();\n      }\n    }\n\n    // For most expressions, just call the visitor.  For initializer lists,\n    // track the index of the field being initialized since fields are\n    // initialized in order allowing use of previously initialized fields.\n    void CheckExpr(Expr *E) {\n      InitListExpr *InitList = dyn_cast<InitListExpr>(E);\n      if (!InitList) {\n        Visit(E);\n        return;\n      }\n\n      // Track and increment the index here.\n      isInitList = true;\n      InitFieldIndex.push_back(0);\n      for (auto Child : InitList->children()) {\n        CheckExpr(cast<Expr>(Child));\n        ++InitFieldIndex.back();\n      }\n      InitFieldIndex.pop_back();\n    }\n\n    // Returns true if MemberExpr is checked and no further checking is needed.\n    // Returns false if additional checking is required.\n    bool CheckInitListMemberExpr(MemberExpr *E, bool CheckReference) {\n      llvm::SmallVector<FieldDecl*, 4> Fields;\n      Expr *Base = E;\n      bool ReferenceField = false;\n\n      // Get the field members used.\n      while (MemberExpr *ME = dyn_cast<MemberExpr>(Base)) {\n        FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n        if (!FD)\n          return false;\n        Fields.push_back(FD);\n        if (FD->getType()->isReferenceType())\n          ReferenceField = true;\n        Base = ME->getBase()->IgnoreParenImpCasts();\n      }\n\n      // Keep checking only if the base Decl is the same.\n      DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Base);\n      if (!DRE || DRE->getDecl() != OrigDecl)\n        return false;\n\n      // A reference field can be bound to an unininitialized field.\n      if (CheckReference && !ReferenceField)\n        return true;\n\n      // Convert FieldDecls to their index number.\n      llvm::SmallVector<unsigned, 4> UsedFieldIndex;\n      for (const FieldDecl *I : llvm::reverse(Fields))\n        UsedFieldIndex.push_back(I->getFieldIndex());\n\n      // See if a warning is needed by checking the first difference in index\n      // numbers.  If field being used has index less than the field being\n      // initialized, then the use is safe.\n      for (auto UsedIter = UsedFieldIndex.begin(),\n                UsedEnd = UsedFieldIndex.end(),\n                OrigIter = InitFieldIndex.begin(),\n                OrigEnd = InitFieldIndex.end();\n           UsedIter != UsedEnd && OrigIter != OrigEnd; ++UsedIter, ++OrigIter) {\n        if (*UsedIter < *OrigIter)\n          return true;\n        if (*UsedIter > *OrigIter)\n          break;\n      }\n\n      // TODO: Add a different warning which will print the field names.\n      HandleDeclRefExpr(DRE);\n      return true;\n    }\n\n    // For most expressions, the cast is directly above the DeclRefExpr.\n    // For conditional operators, the cast can be outside the conditional\n    // operator if both expressions are DeclRefExpr's.\n    void HandleValue(Expr *E) {\n      E = E->IgnoreParens();\n      if (DeclRefExpr* DRE = dyn_cast<DeclRefExpr>(E)) {\n        HandleDeclRefExpr(DRE);\n        return;\n      }\n\n      if (ConditionalOperator *CO = dyn_cast<ConditionalOperator>(E)) {\n        Visit(CO->getCond());\n        HandleValue(CO->getTrueExpr());\n        HandleValue(CO->getFalseExpr());\n        return;\n      }\n\n      if (BinaryConditionalOperator *BCO =\n              dyn_cast<BinaryConditionalOperator>(E)) {\n        Visit(BCO->getCond());\n        HandleValue(BCO->getFalseExpr());\n        return;\n      }\n\n      if (OpaqueValueExpr *OVE = dyn_cast<OpaqueValueExpr>(E)) {\n        HandleValue(OVE->getSourceExpr());\n        return;\n      }\n\n      if (BinaryOperator *BO = dyn_cast<BinaryOperator>(E)) {\n        if (BO->getOpcode() == BO_Comma) {\n          Visit(BO->getLHS());\n          HandleValue(BO->getRHS());\n          return;\n        }\n      }\n\n      if (isa<MemberExpr>(E)) {\n        if (isInitList) {\n          if (CheckInitListMemberExpr(cast<MemberExpr>(E),\n                                      false /*CheckReference*/))\n            return;\n        }\n\n        Expr *Base = E->IgnoreParenImpCasts();\n        while (MemberExpr *ME = dyn_cast<MemberExpr>(Base)) {\n          // Check for static member variables and don't warn on them.\n          if (!isa<FieldDecl>(ME->getMemberDecl()))\n            return;\n          Base = ME->getBase()->IgnoreParenImpCasts();\n        }\n        if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Base))\n          HandleDeclRefExpr(DRE);\n        return;\n      }\n\n      Visit(E);\n    }\n\n    // Reference types not handled in HandleValue are handled here since all\n    // uses of references are bad, not just r-value uses.\n    void VisitDeclRefExpr(DeclRefExpr *E) {\n      if (isReferenceType)\n        HandleDeclRefExpr(E);\n    }\n\n    void VisitImplicitCastExpr(ImplicitCastExpr *E) {\n      if (E->getCastKind() == CK_LValueToRValue) {\n        HandleValue(E->getSubExpr());\n        return;\n      }\n\n      Inherited::VisitImplicitCastExpr(E);\n    }\n\n    void VisitMemberExpr(MemberExpr *E) {\n      if (isInitList) {\n        if (CheckInitListMemberExpr(E, true /*CheckReference*/))\n          return;\n      }\n\n      // Don't warn on arrays since they can be treated as pointers.\n      if (E->getType()->canDecayToPointerType()) return;\n\n      // Warn when a non-static method call is followed by non-static member\n      // field accesses, which is followed by a DeclRefExpr.\n      CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(E->getMemberDecl());\n      bool Warn = (MD && !MD->isStatic());\n      Expr *Base = E->getBase()->IgnoreParenImpCasts();\n      while (MemberExpr *ME = dyn_cast<MemberExpr>(Base)) {\n        if (!isa<FieldDecl>(ME->getMemberDecl()))\n          Warn = false;\n        Base = ME->getBase()->IgnoreParenImpCasts();\n      }\n\n      if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Base)) {\n        if (Warn)\n          HandleDeclRefExpr(DRE);\n        return;\n      }\n\n      // The base of a MemberExpr is not a MemberExpr or a DeclRefExpr.\n      // Visit that expression.\n      Visit(Base);\n    }\n\n    void VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {\n      Expr *Callee = E->getCallee();\n\n      if (isa<UnresolvedLookupExpr>(Callee))\n        return Inherited::VisitCXXOperatorCallExpr(E);\n\n      Visit(Callee);\n      for (auto Arg: E->arguments())\n        HandleValue(Arg->IgnoreParenImpCasts());\n    }\n\n    void VisitUnaryOperator(UnaryOperator *E) {\n      // For POD record types, addresses of its own members are well-defined.\n      if (E->getOpcode() == UO_AddrOf && isRecordType &&\n          isa<MemberExpr>(E->getSubExpr()->IgnoreParens())) {\n        if (!isPODType)\n          HandleValue(E->getSubExpr());\n        return;\n      }\n\n      if (E->isIncrementDecrementOp()) {\n        HandleValue(E->getSubExpr());\n        return;\n      }\n\n      Inherited::VisitUnaryOperator(E);\n    }\n\n    void VisitObjCMessageExpr(ObjCMessageExpr *E) {}\n\n    void VisitCXXConstructExpr(CXXConstructExpr *E) {\n      if (E->getConstructor()->isCopyConstructor()) {\n        Expr *ArgExpr = E->getArg(0);\n        if (InitListExpr *ILE = dyn_cast<InitListExpr>(ArgExpr))\n          if (ILE->getNumInits() == 1)\n            ArgExpr = ILE->getInit(0);\n        if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(ArgExpr))\n          if (ICE->getCastKind() == CK_NoOp)\n            ArgExpr = ICE->getSubExpr();\n        HandleValue(ArgExpr);\n        return;\n      }\n      Inherited::VisitCXXConstructExpr(E);\n    }\n\n    void VisitCallExpr(CallExpr *E) {\n      // Treat std::move as a use.\n      if (E->isCallToStdMove()) {\n        HandleValue(E->getArg(0));\n        return;\n      }\n\n      Inherited::VisitCallExpr(E);\n    }\n\n    void VisitBinaryOperator(BinaryOperator *E) {\n      if (E->isCompoundAssignmentOp()) {\n        HandleValue(E->getLHS());\n        Visit(E->getRHS());\n        return;\n      }\n\n      Inherited::VisitBinaryOperator(E);\n    }\n\n    // A custom visitor for BinaryConditionalOperator is needed because the\n    // regular visitor would check the condition and true expression separately\n    // but both point to the same place giving duplicate diagnostics.\n    void VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {\n      Visit(E->getCond());\n      Visit(E->getFalseExpr());\n    }\n\n    void HandleDeclRefExpr(DeclRefExpr *DRE) {\n      Decl* ReferenceDecl = DRE->getDecl();\n      if (OrigDecl != ReferenceDecl) return;\n      unsigned diag;\n      if (isReferenceType) {\n        diag = diag::warn_uninit_self_reference_in_reference_init;\n      } else if (cast<VarDecl>(OrigDecl)->isStaticLocal()) {\n        diag = diag::warn_static_self_reference_in_init;\n      } else if (isa<TranslationUnitDecl>(OrigDecl->getDeclContext()) ||\n                 isa<NamespaceDecl>(OrigDecl->getDeclContext()) ||\n                 DRE->getDecl()->getType()->isRecordType()) {\n        diag = diag::warn_uninit_self_reference_in_init;\n      } else {\n        // Local variables will be handled by the CFG analysis.\n        return;\n      }\n\n      S.DiagRuntimeBehavior(DRE->getBeginLoc(), DRE,\n                            S.PDiag(diag)\n                                << DRE->getDecl() << OrigDecl->getLocation()\n                                << DRE->getSourceRange());\n    }\n  };\n\n  /// CheckSelfReference - Warns if OrigDecl is used in expression E.\n  static void CheckSelfReference(Sema &S, Decl* OrigDecl, Expr *E,\n                                 bool DirectInit) {\n    // Parameters arguments are occassionially constructed with itself,\n    // for instance, in recursive functions.  Skip them.\n    if (isa<ParmVarDecl>(OrigDecl))\n      return;\n\n    E = E->IgnoreParens();\n\n    // Skip checking T a = a where T is not a record or reference type.\n    // Doing so is a way to silence uninitialized warnings.\n    if (!DirectInit && !cast<VarDecl>(OrigDecl)->getType()->isRecordType())\n      if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(E))\n        if (ICE->getCastKind() == CK_LValueToRValue)\n          if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(ICE->getSubExpr()))\n            if (DRE->getDecl() == OrigDecl)\n              return;\n\n    SelfReferenceChecker(S, OrigDecl).CheckExpr(E);\n  }\n} // end anonymous namespace\n\nnamespace {\n  // Simple wrapper to add the name of a variable or (if no variable is\n  // available) a DeclarationName into a diagnostic.\n  struct VarDeclOrName {\n    VarDecl *VDecl;\n    DeclarationName Name;\n\n    friend const Sema::SemaDiagnosticBuilder &\n    operator<<(const Sema::SemaDiagnosticBuilder &Diag, VarDeclOrName VN) {\n      return VN.VDecl ? Diag << VN.VDecl : Diag << VN.Name;\n    }\n  };\n} // end anonymous namespace\n\nQualType Sema::deduceVarTypeFromInitializer(VarDecl *VDecl,\n                                            DeclarationName Name, QualType Type,\n                                            TypeSourceInfo *TSI,\n                                            SourceRange Range, bool DirectInit,\n                                            Expr *Init) {\n  bool IsInitCapture = !VDecl;\n  assert((!VDecl || !VDecl->isInitCapture()) &&\n         \"init captures are expected to be deduced prior to initialization\");\n\n  VarDeclOrName VN{VDecl, Name};\n\n  DeducedType *Deduced = Type->getContainedDeducedType();\n  assert(Deduced && \"deduceVarTypeFromInitializer for non-deduced type\");\n\n  // C++11 [dcl.spec.auto]p3\n  if (!Init) {\n    assert(VDecl && \"no init for init capture deduction?\");\n\n    // Except for class argument deduction, and then for an initializing\n    // declaration only, i.e. no static at class scope or extern.\n    if (!isa<DeducedTemplateSpecializationType>(Deduced) ||\n        VDecl->hasExternalStorage() ||\n        VDecl->isStaticDataMember()) {\n      Diag(VDecl->getLocation(), diag::err_auto_var_requires_init)\n        << VDecl->getDeclName() << Type;\n      return QualType();\n    }\n  }\n\n  ArrayRef<Expr*> DeduceInits;\n  if (Init)\n    DeduceInits = Init;\n\n  if (DirectInit) {\n    if (auto *PL = dyn_cast_or_null<ParenListExpr>(Init))\n      DeduceInits = PL->exprs();\n  }\n\n  if (isa<DeducedTemplateSpecializationType>(Deduced)) {\n    assert(VDecl && \"non-auto type for init capture deduction?\");\n    InitializedEntity Entity = InitializedEntity::InitializeVariable(VDecl);\n    InitializationKind Kind = InitializationKind::CreateForInit(\n        VDecl->getLocation(), DirectInit, Init);\n    // FIXME: Initialization should not be taking a mutable list of inits.\n    SmallVector<Expr*, 8> InitsCopy(DeduceInits.begin(), DeduceInits.end());\n    return DeduceTemplateSpecializationFromInitializer(TSI, Entity, Kind,\n                                                       InitsCopy);\n  }\n\n  if (DirectInit) {\n    if (auto *IL = dyn_cast<InitListExpr>(Init))\n      DeduceInits = IL->inits();\n  }\n\n  // Deduction only works if we have exactly one source expression.\n  if (DeduceInits.empty()) {\n    // It isn't possible to write this directly, but it is possible to\n    // end up in this situation with \"auto x(some_pack...);\"\n    Diag(Init->getBeginLoc(), IsInitCapture\n                                  ? diag::err_init_capture_no_expression\n                                  : diag::err_auto_var_init_no_expression)\n        << VN << Type << Range;\n    return QualType();\n  }\n\n  if (DeduceInits.size() > 1) {\n    Diag(DeduceInits[1]->getBeginLoc(),\n         IsInitCapture ? diag::err_init_capture_multiple_expressions\n                       : diag::err_auto_var_init_multiple_expressions)\n        << VN << Type << Range;\n    return QualType();\n  }\n\n  Expr *DeduceInit = DeduceInits[0];\n  if (DirectInit && isa<InitListExpr>(DeduceInit)) {\n    Diag(Init->getBeginLoc(), IsInitCapture\n                                  ? diag::err_init_capture_paren_braces\n                                  : diag::err_auto_var_init_paren_braces)\n        << isa<InitListExpr>(Init) << VN << Type << Range;\n    return QualType();\n  }\n\n  // Expressions default to 'id' when we're in a debugger.\n  bool DefaultedAnyToId = false;\n  if (getLangOpts().DebuggerCastResultToId &&\n      Init->getType() == Context.UnknownAnyTy && !IsInitCapture) {\n    ExprResult Result = forceUnknownAnyToType(Init, Context.getObjCIdType());\n    if (Result.isInvalid()) {\n      return QualType();\n    }\n    Init = Result.get();\n    DefaultedAnyToId = true;\n  }\n\n  // C++ [dcl.decomp]p1:\n  //   If the assignment-expression [...] has array type A and no ref-qualifier\n  //   is present, e has type cv A\n  if (VDecl && isa<DecompositionDecl>(VDecl) &&\n      Context.hasSameUnqualifiedType(Type, Context.getAutoDeductType()) &&\n      DeduceInit->getType()->isConstantArrayType())\n    return Context.getQualifiedType(DeduceInit->getType(),\n                                    Type.getQualifiers());\n\n  QualType DeducedType;\n  if (DeduceAutoType(TSI, DeduceInit, DeducedType) == DAR_Failed) {\n    if (!IsInitCapture)\n      DiagnoseAutoDeductionFailure(VDecl, DeduceInit);\n    else if (isa<InitListExpr>(Init))\n      Diag(Range.getBegin(),\n           diag::err_init_capture_deduction_failure_from_init_list)\n          << VN\n          << (DeduceInit->getType().isNull() ? TSI->getType()\n                                             : DeduceInit->getType())\n          << DeduceInit->getSourceRange();\n    else\n      Diag(Range.getBegin(), diag::err_init_capture_deduction_failure)\n          << VN << TSI->getType()\n          << (DeduceInit->getType().isNull() ? TSI->getType()\n                                             : DeduceInit->getType())\n          << DeduceInit->getSourceRange();\n  }\n\n  // Warn if we deduced 'id'. 'auto' usually implies type-safety, but using\n  // 'id' instead of a specific object type prevents most of our usual\n  // checks.\n  // We only want to warn outside of template instantiations, though:\n  // inside a template, the 'id' could have come from a parameter.\n  if (!inTemplateInstantiation() && !DefaultedAnyToId && !IsInitCapture &&\n      !DeducedType.isNull() && DeducedType->isObjCIdType()) {\n    SourceLocation Loc = TSI->getTypeLoc().getBeginLoc();\n    Diag(Loc, diag::warn_auto_var_is_id) << VN << Range;\n  }\n\n  return DeducedType;\n}\n\nbool Sema::DeduceVariableDeclarationType(VarDecl *VDecl, bool DirectInit,\n                                         Expr *Init) {\n  assert(!Init || !Init->containsErrors());\n  QualType DeducedType = deduceVarTypeFromInitializer(\n      VDecl, VDecl->getDeclName(), VDecl->getType(), VDecl->getTypeSourceInfo(),\n      VDecl->getSourceRange(), DirectInit, Init);\n  if (DeducedType.isNull()) {\n    VDecl->setInvalidDecl();\n    return true;\n  }\n\n  VDecl->setType(DeducedType);\n  assert(VDecl->isLinkageValid());\n\n  // In ARC, infer lifetime.\n  if (getLangOpts().ObjCAutoRefCount && inferObjCARCLifetime(VDecl))\n    VDecl->setInvalidDecl();\n\n  if (getLangOpts().OpenCL)\n    deduceOpenCLAddressSpace(VDecl);\n\n  // If this is a redeclaration, check that the type we just deduced matches\n  // the previously declared type.\n  if (VarDecl *Old = VDecl->getPreviousDecl()) {\n    // We never need to merge the type, because we cannot form an incomplete\n    // array of auto, nor deduce such a type.\n    MergeVarDeclTypes(VDecl, Old, /*MergeTypeWithPrevious*/ false);\n  }\n\n  // Check the deduced type is valid for a variable declaration.\n  CheckVariableDeclarationType(VDecl);\n  return VDecl->isInvalidDecl();\n}\n\nvoid Sema::checkNonTrivialCUnionInInitializer(const Expr *Init,\n                                              SourceLocation Loc) {\n  if (auto *EWC = dyn_cast<ExprWithCleanups>(Init))\n    Init = EWC->getSubExpr();\n\n  if (auto *CE = dyn_cast<ConstantExpr>(Init))\n    Init = CE->getSubExpr();\n\n  QualType InitType = Init->getType();\n  assert((InitType.hasNonTrivialToPrimitiveDefaultInitializeCUnion() ||\n          InitType.hasNonTrivialToPrimitiveCopyCUnion()) &&\n         \"shouldn't be called if type doesn't have a non-trivial C struct\");\n  if (auto *ILE = dyn_cast<InitListExpr>(Init)) {\n    for (auto I : ILE->inits()) {\n      if (!I->getType().hasNonTrivialToPrimitiveDefaultInitializeCUnion() &&\n          !I->getType().hasNonTrivialToPrimitiveCopyCUnion())\n        continue;\n      SourceLocation SL = I->getExprLoc();\n      checkNonTrivialCUnionInInitializer(I, SL.isValid() ? SL : Loc);\n    }\n    return;\n  }\n\n  if (isa<ImplicitValueInitExpr>(Init)) {\n    if (InitType.hasNonTrivialToPrimitiveDefaultInitializeCUnion())\n      checkNonTrivialCUnion(InitType, Loc, NTCUC_DefaultInitializedObject,\n                            NTCUK_Init);\n  } else {\n    // Assume all other explicit initializers involving copying some existing\n    // object.\n    // TODO: ignore any explicit initializers where we can guarantee\n    // copy-elision.\n    if (InitType.hasNonTrivialToPrimitiveCopyCUnion())\n      checkNonTrivialCUnion(InitType, Loc, NTCUC_CopyInit, NTCUK_Copy);\n  }\n}\n\nnamespace {\n\nbool shouldIgnoreForRecordTriviality(const FieldDecl *FD) {\n  // Ignore unavailable fields. A field can be marked as unavailable explicitly\n  // in the source code or implicitly by the compiler if it is in a union\n  // defined in a system header and has non-trivial ObjC ownership\n  // qualifications. We don't want those fields to participate in determining\n  // whether the containing union is non-trivial.\n  return FD->hasAttr<UnavailableAttr>();\n}\n\nstruct DiagNonTrivalCUnionDefaultInitializeVisitor\n    : DefaultInitializedTypeVisitor<DiagNonTrivalCUnionDefaultInitializeVisitor,\n                                    void> {\n  using Super =\n      DefaultInitializedTypeVisitor<DiagNonTrivalCUnionDefaultInitializeVisitor,\n                                    void>;\n\n  DiagNonTrivalCUnionDefaultInitializeVisitor(\n      QualType OrigTy, SourceLocation OrigLoc,\n      Sema::NonTrivialCUnionContext UseContext, Sema &S)\n      : OrigTy(OrigTy), OrigLoc(OrigLoc), UseContext(UseContext), S(S) {}\n\n  void visitWithKind(QualType::PrimitiveDefaultInitializeKind PDIK, QualType QT,\n                     const FieldDecl *FD, bool InNonTrivialUnion) {\n    if (const auto *AT = S.Context.getAsArrayType(QT))\n      return this->asDerived().visit(S.Context.getBaseElementType(AT), FD,\n                                     InNonTrivialUnion);\n    return Super::visitWithKind(PDIK, QT, FD, InNonTrivialUnion);\n  }\n\n  void visitARCStrong(QualType QT, const FieldDecl *FD,\n                      bool InNonTrivialUnion) {\n    if (InNonTrivialUnion)\n      S.Diag(FD->getLocation(), diag::note_non_trivial_c_union)\n          << 1 << 0 << QT << FD->getName();\n  }\n\n  void visitARCWeak(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {\n    if (InNonTrivialUnion)\n      S.Diag(FD->getLocation(), diag::note_non_trivial_c_union)\n          << 1 << 0 << QT << FD->getName();\n  }\n\n  void visitStruct(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {\n    const RecordDecl *RD = QT->castAs<RecordType>()->getDecl();\n    if (RD->isUnion()) {\n      if (OrigLoc.isValid()) {\n        bool IsUnion = false;\n        if (auto *OrigRD = OrigTy->getAsRecordDecl())\n          IsUnion = OrigRD->isUnion();\n        S.Diag(OrigLoc, diag::err_non_trivial_c_union_in_invalid_context)\n            << 0 << OrigTy << IsUnion << UseContext;\n        // Reset OrigLoc so that this diagnostic is emitted only once.\n        OrigLoc = SourceLocation();\n      }\n      InNonTrivialUnion = true;\n    }\n\n    if (InNonTrivialUnion)\n      S.Diag(RD->getLocation(), diag::note_non_trivial_c_union)\n          << 0 << 0 << QT.getUnqualifiedType() << \"\";\n\n    for (const FieldDecl *FD : RD->fields())\n      if (!shouldIgnoreForRecordTriviality(FD))\n        asDerived().visit(FD->getType(), FD, InNonTrivialUnion);\n  }\n\n  void visitTrivial(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {}\n\n  // The non-trivial C union type or the struct/union type that contains a\n  // non-trivial C union.\n  QualType OrigTy;\n  SourceLocation OrigLoc;\n  Sema::NonTrivialCUnionContext UseContext;\n  Sema &S;\n};\n\nstruct DiagNonTrivalCUnionDestructedTypeVisitor\n    : DestructedTypeVisitor<DiagNonTrivalCUnionDestructedTypeVisitor, void> {\n  using Super =\n      DestructedTypeVisitor<DiagNonTrivalCUnionDestructedTypeVisitor, void>;\n\n  DiagNonTrivalCUnionDestructedTypeVisitor(\n      QualType OrigTy, SourceLocation OrigLoc,\n      Sema::NonTrivialCUnionContext UseContext, Sema &S)\n      : OrigTy(OrigTy), OrigLoc(OrigLoc), UseContext(UseContext), S(S) {}\n\n  void visitWithKind(QualType::DestructionKind DK, QualType QT,\n                     const FieldDecl *FD, bool InNonTrivialUnion) {\n    if (const auto *AT = S.Context.getAsArrayType(QT))\n      return this->asDerived().visit(S.Context.getBaseElementType(AT), FD,\n                                     InNonTrivialUnion);\n    return Super::visitWithKind(DK, QT, FD, InNonTrivialUnion);\n  }\n\n  void visitARCStrong(QualType QT, const FieldDecl *FD,\n                      bool InNonTrivialUnion) {\n    if (InNonTrivialUnion)\n      S.Diag(FD->getLocation(), diag::note_non_trivial_c_union)\n          << 1 << 1 << QT << FD->getName();\n  }\n\n  void visitARCWeak(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {\n    if (InNonTrivialUnion)\n      S.Diag(FD->getLocation(), diag::note_non_trivial_c_union)\n          << 1 << 1 << QT << FD->getName();\n  }\n\n  void visitStruct(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {\n    const RecordDecl *RD = QT->castAs<RecordType>()->getDecl();\n    if (RD->isUnion()) {\n      if (OrigLoc.isValid()) {\n        bool IsUnion = false;\n        if (auto *OrigRD = OrigTy->getAsRecordDecl())\n          IsUnion = OrigRD->isUnion();\n        S.Diag(OrigLoc, diag::err_non_trivial_c_union_in_invalid_context)\n            << 1 << OrigTy << IsUnion << UseContext;\n        // Reset OrigLoc so that this diagnostic is emitted only once.\n        OrigLoc = SourceLocation();\n      }\n      InNonTrivialUnion = true;\n    }\n\n    if (InNonTrivialUnion)\n      S.Diag(RD->getLocation(), diag::note_non_trivial_c_union)\n          << 0 << 1 << QT.getUnqualifiedType() << \"\";\n\n    for (const FieldDecl *FD : RD->fields())\n      if (!shouldIgnoreForRecordTriviality(FD))\n        asDerived().visit(FD->getType(), FD, InNonTrivialUnion);\n  }\n\n  void visitTrivial(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {}\n  void visitCXXDestructor(QualType QT, const FieldDecl *FD,\n                          bool InNonTrivialUnion) {}\n\n  // The non-trivial C union type or the struct/union type that contains a\n  // non-trivial C union.\n  QualType OrigTy;\n  SourceLocation OrigLoc;\n  Sema::NonTrivialCUnionContext UseContext;\n  Sema &S;\n};\n\nstruct DiagNonTrivalCUnionCopyVisitor\n    : CopiedTypeVisitor<DiagNonTrivalCUnionCopyVisitor, false, void> {\n  using Super = CopiedTypeVisitor<DiagNonTrivalCUnionCopyVisitor, false, void>;\n\n  DiagNonTrivalCUnionCopyVisitor(QualType OrigTy, SourceLocation OrigLoc,\n                                 Sema::NonTrivialCUnionContext UseContext,\n                                 Sema &S)\n      : OrigTy(OrigTy), OrigLoc(OrigLoc), UseContext(UseContext), S(S) {}\n\n  void visitWithKind(QualType::PrimitiveCopyKind PCK, QualType QT,\n                     const FieldDecl *FD, bool InNonTrivialUnion) {\n    if (const auto *AT = S.Context.getAsArrayType(QT))\n      return this->asDerived().visit(S.Context.getBaseElementType(AT), FD,\n                                     InNonTrivialUnion);\n    return Super::visitWithKind(PCK, QT, FD, InNonTrivialUnion);\n  }\n\n  void visitARCStrong(QualType QT, const FieldDecl *FD,\n                      bool InNonTrivialUnion) {\n    if (InNonTrivialUnion)\n      S.Diag(FD->getLocation(), diag::note_non_trivial_c_union)\n          << 1 << 2 << QT << FD->getName();\n  }\n\n  void visitARCWeak(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {\n    if (InNonTrivialUnion)\n      S.Diag(FD->getLocation(), diag::note_non_trivial_c_union)\n          << 1 << 2 << QT << FD->getName();\n  }\n\n  void visitStruct(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {\n    const RecordDecl *RD = QT->castAs<RecordType>()->getDecl();\n    if (RD->isUnion()) {\n      if (OrigLoc.isValid()) {\n        bool IsUnion = false;\n        if (auto *OrigRD = OrigTy->getAsRecordDecl())\n          IsUnion = OrigRD->isUnion();\n        S.Diag(OrigLoc, diag::err_non_trivial_c_union_in_invalid_context)\n            << 2 << OrigTy << IsUnion << UseContext;\n        // Reset OrigLoc so that this diagnostic is emitted only once.\n        OrigLoc = SourceLocation();\n      }\n      InNonTrivialUnion = true;\n    }\n\n    if (InNonTrivialUnion)\n      S.Diag(RD->getLocation(), diag::note_non_trivial_c_union)\n          << 0 << 2 << QT.getUnqualifiedType() << \"\";\n\n    for (const FieldDecl *FD : RD->fields())\n      if (!shouldIgnoreForRecordTriviality(FD))\n        asDerived().visit(FD->getType(), FD, InNonTrivialUnion);\n  }\n\n  void preVisit(QualType::PrimitiveCopyKind PCK, QualType QT,\n                const FieldDecl *FD, bool InNonTrivialUnion) {}\n  void visitTrivial(QualType QT, const FieldDecl *FD, bool InNonTrivialUnion) {}\n  void visitVolatileTrivial(QualType QT, const FieldDecl *FD,\n                            bool InNonTrivialUnion) {}\n\n  // The non-trivial C union type or the struct/union type that contains a\n  // non-trivial C union.\n  QualType OrigTy;\n  SourceLocation OrigLoc;\n  Sema::NonTrivialCUnionContext UseContext;\n  Sema &S;\n};\n\n} // namespace\n\nvoid Sema::checkNonTrivialCUnion(QualType QT, SourceLocation Loc,\n                                 NonTrivialCUnionContext UseContext,\n                                 unsigned NonTrivialKind) {\n  assert((QT.hasNonTrivialToPrimitiveDefaultInitializeCUnion() ||\n          QT.hasNonTrivialToPrimitiveDestructCUnion() ||\n          QT.hasNonTrivialToPrimitiveCopyCUnion()) &&\n         \"shouldn't be called if type doesn't have a non-trivial C union\");\n\n  if ((NonTrivialKind & NTCUK_Init) &&\n      QT.hasNonTrivialToPrimitiveDefaultInitializeCUnion())\n    DiagNonTrivalCUnionDefaultInitializeVisitor(QT, Loc, UseContext, *this)\n        .visit(QT, nullptr, false);\n  if ((NonTrivialKind & NTCUK_Destruct) &&\n      QT.hasNonTrivialToPrimitiveDestructCUnion())\n    DiagNonTrivalCUnionDestructedTypeVisitor(QT, Loc, UseContext, *this)\n        .visit(QT, nullptr, false);\n  if ((NonTrivialKind & NTCUK_Copy) && QT.hasNonTrivialToPrimitiveCopyCUnion())\n    DiagNonTrivalCUnionCopyVisitor(QT, Loc, UseContext, *this)\n        .visit(QT, nullptr, false);\n}\n\n/// AddInitializerToDecl - Adds the initializer Init to the\n/// declaration dcl. If DirectInit is true, this is C++ direct\n/// initialization rather than copy initialization.\nvoid Sema::AddInitializerToDecl(Decl *RealDecl, Expr *Init, bool DirectInit) {\n  // If there is no declaration, there was an error parsing it.  Just ignore\n  // the initializer.\n  if (!RealDecl || RealDecl->isInvalidDecl()) {\n    CorrectDelayedTyposInExpr(Init, dyn_cast_or_null<VarDecl>(RealDecl));\n    return;\n  }\n\n  if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(RealDecl)) {\n    // Pure-specifiers are handled in ActOnPureSpecifier.\n    Diag(Method->getLocation(), diag::err_member_function_initialization)\n      << Method->getDeclName() << Init->getSourceRange();\n    Method->setInvalidDecl();\n    return;\n  }\n\n  VarDecl *VDecl = dyn_cast<VarDecl>(RealDecl);\n  if (!VDecl) {\n    assert(!isa<FieldDecl>(RealDecl) && \"field init shouldn't get here\");\n    Diag(RealDecl->getLocation(), diag::err_illegal_initializer);\n    RealDecl->setInvalidDecl();\n    return;\n  }\n\n  // C++11 [decl.spec.auto]p6. Deduce the type which 'auto' stands in for.\n  if (VDecl->getType()->isUndeducedType()) {\n    // Attempt typo correction early so that the type of the init expression can\n    // be deduced based on the chosen correction if the original init contains a\n    // TypoExpr.\n    ExprResult Res = CorrectDelayedTyposInExpr(Init, VDecl);\n    if (!Res.isUsable()) {\n      // There are unresolved typos in Init, just drop them.\n      // FIXME: improve the recovery strategy to preserve the Init.\n      RealDecl->setInvalidDecl();\n      return;\n    }\n    if (Res.get()->containsErrors()) {\n      // Invalidate the decl as we don't know the type for recovery-expr yet.\n      RealDecl->setInvalidDecl();\n      VDecl->setInit(Res.get());\n      return;\n    }\n    Init = Res.get();\n\n    if (DeduceVariableDeclarationType(VDecl, DirectInit, Init))\n      return;\n  }\n\n  // dllimport cannot be used on variable definitions.\n  if (VDecl->hasAttr<DLLImportAttr>() && !VDecl->isStaticDataMember()) {\n    Diag(VDecl->getLocation(), diag::err_attribute_dllimport_data_definition);\n    VDecl->setInvalidDecl();\n    return;\n  }\n\n  if (VDecl->isLocalVarDecl() && VDecl->hasExternalStorage()) {\n    // C99 6.7.8p5. C++ has no such restriction, but that is a defect.\n    Diag(VDecl->getLocation(), diag::err_block_extern_cant_init);\n    VDecl->setInvalidDecl();\n    return;\n  }\n\n  if (!VDecl->getType()->isDependentType()) {\n    // A definition must end up with a complete type, which means it must be\n    // complete with the restriction that an array type might be completed by\n    // the initializer; note that later code assumes this restriction.\n    QualType BaseDeclType = VDecl->getType();\n    if (const ArrayType *Array = Context.getAsIncompleteArrayType(BaseDeclType))\n      BaseDeclType = Array->getElementType();\n    if (RequireCompleteType(VDecl->getLocation(), BaseDeclType,\n                            diag::err_typecheck_decl_incomplete_type)) {\n      RealDecl->setInvalidDecl();\n      return;\n    }\n\n    // The variable can not have an abstract class type.\n    if (RequireNonAbstractType(VDecl->getLocation(), VDecl->getType(),\n                               diag::err_abstract_type_in_decl,\n                               AbstractVariableType))\n      VDecl->setInvalidDecl();\n  }\n\n  // If adding the initializer will turn this declaration into a definition,\n  // and we already have a definition for this variable, diagnose or otherwise\n  // handle the situation.\n  VarDecl *Def;\n  if ((Def = VDecl->getDefinition()) && Def != VDecl &&\n      (!VDecl->isStaticDataMember() || VDecl->isOutOfLine()) &&\n      !VDecl->isThisDeclarationADemotedDefinition() &&\n      checkVarDeclRedefinition(Def, VDecl))\n    return;\n\n  if (getLangOpts().CPlusPlus) {\n    // C++ [class.static.data]p4\n    //   If a static data member is of const integral or const\n    //   enumeration type, its declaration in the class definition can\n    //   specify a constant-initializer which shall be an integral\n    //   constant expression (5.19). In that case, the member can appear\n    //   in integral constant expressions. The member shall still be\n    //   defined in a namespace scope if it is used in the program and the\n    //   namespace scope definition shall not contain an initializer.\n    //\n    // We already performed a redefinition check above, but for static\n    // data members we also need to check whether there was an in-class\n    // declaration with an initializer.\n    if (VDecl->isStaticDataMember() && VDecl->getCanonicalDecl()->hasInit()) {\n      Diag(Init->getExprLoc(), diag::err_static_data_member_reinitialization)\n          << VDecl->getDeclName();\n      Diag(VDecl->getCanonicalDecl()->getInit()->getExprLoc(),\n           diag::note_previous_initializer)\n          << 0;\n      return;\n    }\n\n    if (VDecl->hasLocalStorage())\n      setFunctionHasBranchProtectedScope();\n\n    if (DiagnoseUnexpandedParameterPack(Init, UPPC_Initializer)) {\n      VDecl->setInvalidDecl();\n      return;\n    }\n  }\n\n  // OpenCL 1.1 6.5.2: \"Variables allocated in the __local address space inside\n  // a kernel function cannot be initialized.\"\n  if (VDecl->getType().getAddressSpace() == LangAS::opencl_local) {\n    Diag(VDecl->getLocation(), diag::err_local_cant_init);\n    VDecl->setInvalidDecl();\n    return;\n  }\n\n  // The LoaderUninitialized attribute acts as a definition (of undef).\n  if (VDecl->hasAttr<LoaderUninitializedAttr>()) {\n    Diag(VDecl->getLocation(), diag::err_loader_uninitialized_cant_init);\n    VDecl->setInvalidDecl();\n    return;\n  }\n\n  // Get the decls type and save a reference for later, since\n  // CheckInitializerTypes may change it.\n  QualType DclT = VDecl->getType(), SavT = DclT;\n\n  // Expressions default to 'id' when we're in a debugger\n  // and we are assigning it to a variable of Objective-C pointer type.\n  if (getLangOpts().DebuggerCastResultToId && DclT->isObjCObjectPointerType() &&\n      Init->getType() == Context.UnknownAnyTy) {\n    ExprResult Result = forceUnknownAnyToType(Init, Context.getObjCIdType());\n    if (Result.isInvalid()) {\n      VDecl->setInvalidDecl();\n      return;\n    }\n    Init = Result.get();\n  }\n\n  // Perform the initialization.\n  ParenListExpr *CXXDirectInit = dyn_cast<ParenListExpr>(Init);\n  if (!VDecl->isInvalidDecl()) {\n    InitializedEntity Entity = InitializedEntity::InitializeVariable(VDecl);\n    InitializationKind Kind = InitializationKind::CreateForInit(\n        VDecl->getLocation(), DirectInit, Init);\n\n    MultiExprArg Args = Init;\n    if (CXXDirectInit)\n      Args = MultiExprArg(CXXDirectInit->getExprs(),\n                          CXXDirectInit->getNumExprs());\n\n    // Try to correct any TypoExprs in the initialization arguments.\n    for (size_t Idx = 0; Idx < Args.size(); ++Idx) {\n      ExprResult Res = CorrectDelayedTyposInExpr(\n          Args[Idx], VDecl, /*RecoverUncorrectedTypos=*/true,\n          [this, Entity, Kind](Expr *E) {\n            InitializationSequence Init(*this, Entity, Kind, MultiExprArg(E));\n            return Init.Failed() ? ExprError() : E;\n          });\n      if (Res.isInvalid()) {\n        VDecl->setInvalidDecl();\n      } else if (Res.get() != Args[Idx]) {\n        Args[Idx] = Res.get();\n      }\n    }\n    if (VDecl->isInvalidDecl())\n      return;\n\n    InitializationSequence InitSeq(*this, Entity, Kind, Args,\n                                   /*TopLevelOfInitList=*/false,\n                                   /*TreatUnavailableAsInvalid=*/false);\n    ExprResult Result = InitSeq.Perform(*this, Entity, Kind, Args, &DclT);\n    if (Result.isInvalid()) {\n      // If the provied initializer fails to initialize the var decl,\n      // we attach a recovery expr for better recovery.\n      auto RecoveryExpr =\n          CreateRecoveryExpr(Init->getBeginLoc(), Init->getEndLoc(), Args);\n      if (RecoveryExpr.get())\n        VDecl->setInit(RecoveryExpr.get());\n      return;\n    }\n\n    Init = Result.getAs<Expr>();\n  }\n\n  // Check for self-references within variable initializers.\n  // Variables declared within a function/method body (except for references)\n  // are handled by a dataflow analysis.\n  // This is undefined behavior in C++, but valid in C.\n  if (getLangOpts().CPlusPlus) {\n    if (!VDecl->hasLocalStorage() || VDecl->getType()->isRecordType() ||\n        VDecl->getType()->isReferenceType()) {\n      CheckSelfReference(*this, RealDecl, Init, DirectInit);\n    }\n  }\n\n  // If the type changed, it means we had an incomplete type that was\n  // completed by the initializer. For example:\n  //   int ary[] = { 1, 3, 5 };\n  // \"ary\" transitions from an IncompleteArrayType to a ConstantArrayType.\n  if (!VDecl->isInvalidDecl() && (DclT != SavT))\n    VDecl->setType(DclT);\n\n  if (!VDecl->isInvalidDecl()) {\n    checkUnsafeAssigns(VDecl->getLocation(), VDecl->getType(), Init);\n\n    if (VDecl->hasAttr<BlocksAttr>())\n      checkRetainCycles(VDecl, Init);\n\n    // It is safe to assign a weak reference into a strong variable.\n    // Although this code can still have problems:\n    //   id x = self.weakProp;\n    //   id y = self.weakProp;\n    // we do not warn to warn spuriously when 'x' and 'y' are on separate\n    // paths through the function. This should be revisited if\n    // -Wrepeated-use-of-weak is made flow-sensitive.\n    if (FunctionScopeInfo *FSI = getCurFunction())\n      if ((VDecl->getType().getObjCLifetime() == Qualifiers::OCL_Strong ||\n           VDecl->getType().isNonWeakInMRRWithObjCWeak(Context)) &&\n          !Diags.isIgnored(diag::warn_arc_repeated_use_of_weak,\n                           Init->getBeginLoc()))\n        FSI->markSafeWeakUse(Init);\n  }\n\n  // The initialization is usually a full-expression.\n  //\n  // FIXME: If this is a braced initialization of an aggregate, it is not\n  // an expression, and each individual field initializer is a separate\n  // full-expression. For instance, in:\n  //\n  //   struct Temp { ~Temp(); };\n  //   struct S { S(Temp); };\n  //   struct T { S a, b; } t = { Temp(), Temp() }\n  //\n  // we should destroy the first Temp before constructing the second.\n  ExprResult Result =\n      ActOnFinishFullExpr(Init, VDecl->getLocation(),\n                          /*DiscardedValue*/ false, VDecl->isConstexpr());\n  if (Result.isInvalid()) {\n    VDecl->setInvalidDecl();\n    return;\n  }\n  Init = Result.get();\n\n  // Attach the initializer to the decl.\n  VDecl->setInit(Init);\n\n  if (VDecl->isLocalVarDecl()) {\n    // Don't check the initializer if the declaration is malformed.\n    if (VDecl->isInvalidDecl()) {\n      // do nothing\n\n    // OpenCL v1.2 s6.5.3: __constant locals must be constant-initialized.\n    // This is true even in C++ for OpenCL.\n    } else if (VDecl->getType().getAddressSpace() == LangAS::opencl_constant) {\n      CheckForConstantInitializer(Init, DclT);\n\n    // Otherwise, C++ does not restrict the initializer.\n    } else if (getLangOpts().CPlusPlus) {\n      // do nothing\n\n    // C99 6.7.8p4: All the expressions in an initializer for an object that has\n    // static storage duration shall be constant expressions or string literals.\n    } else if (VDecl->getStorageClass() == SC_Static) {\n      CheckForConstantInitializer(Init, DclT);\n\n    // C89 is stricter than C99 for aggregate initializers.\n    // C89 6.5.7p3: All the expressions [...] in an initializer list\n    // for an object that has aggregate or union type shall be\n    // constant expressions.\n    } else if (!getLangOpts().C99 && VDecl->getType()->isAggregateType() &&\n               isa<InitListExpr>(Init)) {\n      const Expr *Culprit;\n      if (!Init->isConstantInitializer(Context, false, &Culprit)) {\n        Diag(Culprit->getExprLoc(),\n             diag::ext_aggregate_init_not_constant)\n          << Culprit->getSourceRange();\n      }\n    }\n\n    if (auto *E = dyn_cast<ExprWithCleanups>(Init))\n      if (auto *BE = dyn_cast<BlockExpr>(E->getSubExpr()->IgnoreParens()))\n        if (VDecl->hasLocalStorage())\n          BE->getBlockDecl()->setCanAvoidCopyToHeap();\n  } else if (VDecl->isStaticDataMember() && !VDecl->isInline() &&\n             VDecl->getLexicalDeclContext()->isRecord()) {\n    // This is an in-class initialization for a static data member, e.g.,\n    //\n    // struct S {\n    //   static const int value = 17;\n    // };\n\n    // C++ [class.mem]p4:\n    //   A member-declarator can contain a constant-initializer only\n    //   if it declares a static member (9.4) of const integral or\n    //   const enumeration type, see 9.4.2.\n    //\n    // C++11 [class.static.data]p3:\n    //   If a non-volatile non-inline const static data member is of integral\n    //   or enumeration type, its declaration in the class definition can\n    //   specify a brace-or-equal-initializer in which every initializer-clause\n    //   that is an assignment-expression is a constant expression. A static\n    //   data member of literal type can be declared in the class definition\n    //   with the constexpr specifier; if so, its declaration shall specify a\n    //   brace-or-equal-initializer in which every initializer-clause that is\n    //   an assignment-expression is a constant expression.\n\n    // Do nothing on dependent types.\n    if (DclT->isDependentType()) {\n\n    // Allow any 'static constexpr' members, whether or not they are of literal\n    // type. We separately check that every constexpr variable is of literal\n    // type.\n    } else if (VDecl->isConstexpr()) {\n\n    // Require constness.\n    } else if (!DclT.isConstQualified()) {\n      Diag(VDecl->getLocation(), diag::err_in_class_initializer_non_const)\n        << Init->getSourceRange();\n      VDecl->setInvalidDecl();\n\n    // We allow integer constant expressions in all cases.\n    } else if (DclT->isIntegralOrEnumerationType()) {\n      // Check whether the expression is a constant expression.\n      SourceLocation Loc;\n      if (getLangOpts().CPlusPlus11 && DclT.isVolatileQualified())\n        // In C++11, a non-constexpr const static data member with an\n        // in-class initializer cannot be volatile.\n        Diag(VDecl->getLocation(), diag::err_in_class_initializer_volatile);\n      else if (Init->isValueDependent())\n        ; // Nothing to check.\n      else if (Init->isIntegerConstantExpr(Context, &Loc))\n        ; // Ok, it's an ICE!\n      else if (Init->getType()->isScopedEnumeralType() &&\n               Init->isCXX11ConstantExpr(Context))\n        ; // Ok, it is a scoped-enum constant expression.\n      else if (Init->isEvaluatable(Context)) {\n        // If we can constant fold the initializer through heroics, accept it,\n        // but report this as a use of an extension for -pedantic.\n        Diag(Loc, diag::ext_in_class_initializer_non_constant)\n          << Init->getSourceRange();\n      } else {\n        // Otherwise, this is some crazy unknown case.  Report the issue at the\n        // location provided by the isIntegerConstantExpr failed check.\n        Diag(Loc, diag::err_in_class_initializer_non_constant)\n          << Init->getSourceRange();\n        VDecl->setInvalidDecl();\n      }\n\n    // We allow foldable floating-point constants as an extension.\n    } else if (DclT->isFloatingType()) { // also permits complex, which is ok\n      // In C++98, this is a GNU extension. In C++11, it is not, but we support\n      // it anyway and provide a fixit to add the 'constexpr'.\n      if (getLangOpts().CPlusPlus11) {\n        Diag(VDecl->getLocation(),\n             diag::ext_in_class_initializer_float_type_cxx11)\n            << DclT << Init->getSourceRange();\n        Diag(VDecl->getBeginLoc(),\n             diag::note_in_class_initializer_float_type_cxx11)\n            << FixItHint::CreateInsertion(VDecl->getBeginLoc(), \"constexpr \");\n      } else {\n        Diag(VDecl->getLocation(), diag::ext_in_class_initializer_float_type)\n          << DclT << Init->getSourceRange();\n\n        if (!Init->isValueDependent() && !Init->isEvaluatable(Context)) {\n          Diag(Init->getExprLoc(), diag::err_in_class_initializer_non_constant)\n            << Init->getSourceRange();\n          VDecl->setInvalidDecl();\n        }\n      }\n\n    // Suggest adding 'constexpr' in C++11 for literal types.\n    } else if (getLangOpts().CPlusPlus11 && DclT->isLiteralType(Context)) {\n      Diag(VDecl->getLocation(), diag::err_in_class_initializer_literal_type)\n          << DclT << Init->getSourceRange()\n          << FixItHint::CreateInsertion(VDecl->getBeginLoc(), \"constexpr \");\n      VDecl->setConstexpr(true);\n\n    } else {\n      Diag(VDecl->getLocation(), diag::err_in_class_initializer_bad_type)\n        << DclT << Init->getSourceRange();\n      VDecl->setInvalidDecl();\n    }\n  } else if (VDecl->isFileVarDecl()) {\n    // In C, extern is typically used to avoid tentative definitions when\n    // declaring variables in headers, but adding an intializer makes it a\n    // definition. This is somewhat confusing, so GCC and Clang both warn on it.\n    // In C++, extern is often used to give implictly static const variables\n    // external linkage, so don't warn in that case. If selectany is present,\n    // this might be header code intended for C and C++ inclusion, so apply the\n    // C++ rules.\n    if (VDecl->getStorageClass() == SC_Extern &&\n        ((!getLangOpts().CPlusPlus && !VDecl->hasAttr<SelectAnyAttr>()) ||\n         !Context.getBaseElementType(VDecl->getType()).isConstQualified()) &&\n        !(getLangOpts().CPlusPlus && VDecl->isExternC()) &&\n        !isTemplateInstantiation(VDecl->getTemplateSpecializationKind()))\n      Diag(VDecl->getLocation(), diag::warn_extern_init);\n\n    // In Microsoft C++ mode, a const variable defined in namespace scope has\n    // external linkage by default if the variable is declared with\n    // __declspec(dllexport).\n    if (Context.getTargetInfo().getCXXABI().isMicrosoft() &&\n        getLangOpts().CPlusPlus && VDecl->getType().isConstQualified() &&\n        VDecl->hasAttr<DLLExportAttr>() && VDecl->getDefinition())\n      VDecl->setStorageClass(SC_Extern);\n\n    // C99 6.7.8p4. All file scoped initializers need to be constant.\n    if (!getLangOpts().CPlusPlus && !VDecl->isInvalidDecl())\n      CheckForConstantInitializer(Init, DclT);\n  }\n\n  QualType InitType = Init->getType();\n  if (!InitType.isNull() &&\n      (InitType.hasNonTrivialToPrimitiveDefaultInitializeCUnion() ||\n       InitType.hasNonTrivialToPrimitiveCopyCUnion()))\n    checkNonTrivialCUnionInInitializer(Init, Init->getExprLoc());\n\n  // We will represent direct-initialization similarly to copy-initialization:\n  //    int x(1);  -as-> int x = 1;\n  //    ClassType x(a,b,c); -as-> ClassType x = ClassType(a,b,c);\n  //\n  // Clients that want to distinguish between the two forms, can check for\n  // direct initializer using VarDecl::getInitStyle().\n  // A major benefit is that clients that don't particularly care about which\n  // exactly form was it (like the CodeGen) can handle both cases without\n  // special case code.\n\n  // C++ 8.5p11:\n  // The form of initialization (using parentheses or '=') is generally\n  // insignificant, but does matter when the entity being initialized has a\n  // class type.\n  if (CXXDirectInit) {\n    assert(DirectInit && \"Call-style initializer must be direct init.\");\n    VDecl->setInitStyle(VarDecl::CallInit);\n  } else if (DirectInit) {\n    // This must be list-initialization. No other way is direct-initialization.\n    VDecl->setInitStyle(VarDecl::ListInit);\n  }\n\n  if (LangOpts.OpenMP && VDecl->isFileVarDecl())\n    DeclsToCheckForDeferredDiags.push_back(VDecl);\n  CheckCompleteVariableDeclaration(VDecl);\n}\n\n/// ActOnInitializerError - Given that there was an error parsing an\n/// initializer for the given declaration, try to return to some form\n/// of sanity.\nvoid Sema::ActOnInitializerError(Decl *D) {\n  // Our main concern here is re-establishing invariants like \"a\n  // variable's type is either dependent or complete\".\n  if (!D || D->isInvalidDecl()) return;\n\n  VarDecl *VD = dyn_cast<VarDecl>(D);\n  if (!VD) return;\n\n  // Bindings are not usable if we can't make sense of the initializer.\n  if (auto *DD = dyn_cast<DecompositionDecl>(D))\n    for (auto *BD : DD->bindings())\n      BD->setInvalidDecl();\n\n  // Auto types are meaningless if we can't make sense of the initializer.\n  if (VD->getType()->isUndeducedType()) {\n    D->setInvalidDecl();\n    return;\n  }\n\n  QualType Ty = VD->getType();\n  if (Ty->isDependentType()) return;\n\n  // Require a complete type.\n  if (RequireCompleteType(VD->getLocation(),\n                          Context.getBaseElementType(Ty),\n                          diag::err_typecheck_decl_incomplete_type)) {\n    VD->setInvalidDecl();\n    return;\n  }\n\n  // Require a non-abstract type.\n  if (RequireNonAbstractType(VD->getLocation(), Ty,\n                             diag::err_abstract_type_in_decl,\n                             AbstractVariableType)) {\n    VD->setInvalidDecl();\n    return;\n  }\n\n  // Don't bother complaining about constructors or destructors,\n  // though.\n}\n\nvoid Sema::ActOnUninitializedDecl(Decl *RealDecl) {\n  // If there is no declaration, there was an error parsing it. Just ignore it.\n  if (!RealDecl)\n    return;\n\n  if (VarDecl *Var = dyn_cast<VarDecl>(RealDecl)) {\n    QualType Type = Var->getType();\n\n    // C++1z [dcl.dcl]p1 grammar implies that an initializer is mandatory.\n    if (isa<DecompositionDecl>(RealDecl)) {\n      Diag(Var->getLocation(), diag::err_decomp_decl_requires_init) << Var;\n      Var->setInvalidDecl();\n      return;\n    }\n\n    if (Type->isUndeducedType() &&\n        DeduceVariableDeclarationType(Var, false, nullptr))\n      return;\n\n    // C++11 [class.static.data]p3: A static data member can be declared with\n    // the constexpr specifier; if so, its declaration shall specify\n    // a brace-or-equal-initializer.\n    // C++11 [dcl.constexpr]p1: The constexpr specifier shall be applied only to\n    // the definition of a variable [...] or the declaration of a static data\n    // member.\n    if (Var->isConstexpr() && !Var->isThisDeclarationADefinition() &&\n        !Var->isThisDeclarationADemotedDefinition()) {\n      if (Var->isStaticDataMember()) {\n        // C++1z removes the relevant rule; the in-class declaration is always\n        // a definition there.\n        if (!getLangOpts().CPlusPlus17 &&\n            !Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n          Diag(Var->getLocation(),\n               diag::err_constexpr_static_mem_var_requires_init)\n              << Var;\n          Var->setInvalidDecl();\n          return;\n        }\n      } else {\n        Diag(Var->getLocation(), diag::err_invalid_constexpr_var_decl);\n        Var->setInvalidDecl();\n        return;\n      }\n    }\n\n    // OpenCL v1.1 s6.5.3: variables declared in the constant address space must\n    // be initialized.\n    if (!Var->isInvalidDecl() &&\n        Var->getType().getAddressSpace() == LangAS::opencl_constant &&\n        Var->getStorageClass() != SC_Extern && !Var->getInit()) {\n      Diag(Var->getLocation(), diag::err_opencl_constant_no_init);\n      Var->setInvalidDecl();\n      return;\n    }\n\n    if (!Var->isInvalidDecl() && RealDecl->hasAttr<LoaderUninitializedAttr>()) {\n      if (Var->getStorageClass() == SC_Extern) {\n        Diag(Var->getLocation(), diag::err_loader_uninitialized_extern_decl)\n            << Var;\n        Var->setInvalidDecl();\n        return;\n      }\n      if (RequireCompleteType(Var->getLocation(), Var->getType(),\n                              diag::err_typecheck_decl_incomplete_type)) {\n        Var->setInvalidDecl();\n        return;\n      }\n      if (CXXRecordDecl *RD = Var->getType()->getAsCXXRecordDecl()) {\n        if (!RD->hasTrivialDefaultConstructor()) {\n          Diag(Var->getLocation(), diag::err_loader_uninitialized_trivial_ctor);\n          Var->setInvalidDecl();\n          return;\n        }\n      }\n    }\n\n    VarDecl::DefinitionKind DefKind = Var->isThisDeclarationADefinition();\n    if (!Var->isInvalidDecl() && DefKind != VarDecl::DeclarationOnly &&\n        Var->getType().hasNonTrivialToPrimitiveDefaultInitializeCUnion())\n      checkNonTrivialCUnion(Var->getType(), Var->getLocation(),\n                            NTCUC_DefaultInitializedObject, NTCUK_Init);\n\n\n    switch (DefKind) {\n    case VarDecl::Definition:\n      if (!Var->isStaticDataMember() || !Var->getAnyInitializer())\n        break;\n\n      // We have an out-of-line definition of a static data member\n      // that has an in-class initializer, so we type-check this like\n      // a declaration.\n      //\n      LLVM_FALLTHROUGH;\n\n    case VarDecl::DeclarationOnly:\n      // It's only a declaration.\n\n      // Block scope. C99 6.7p7: If an identifier for an object is\n      // declared with no linkage (C99 6.2.2p6), the type for the\n      // object shall be complete.\n      if (!Type->isDependentType() && Var->isLocalVarDecl() &&\n          !Var->hasLinkage() && !Var->isInvalidDecl() &&\n          RequireCompleteType(Var->getLocation(), Type,\n                              diag::err_typecheck_decl_incomplete_type))\n        Var->setInvalidDecl();\n\n      // Make sure that the type is not abstract.\n      if (!Type->isDependentType() && !Var->isInvalidDecl() &&\n          RequireNonAbstractType(Var->getLocation(), Type,\n                                 diag::err_abstract_type_in_decl,\n                                 AbstractVariableType))\n        Var->setInvalidDecl();\n      if (!Type->isDependentType() && !Var->isInvalidDecl() &&\n          Var->getStorageClass() == SC_PrivateExtern) {\n        Diag(Var->getLocation(), diag::warn_private_extern);\n        Diag(Var->getLocation(), diag::note_private_extern);\n      }\n\n      if (Context.getTargetInfo().allowDebugInfoForExternalVar() &&\n          !Var->isInvalidDecl() && !getLangOpts().CPlusPlus)\n        ExternalDeclarations.push_back(Var);\n\n      return;\n\n    case VarDecl::TentativeDefinition:\n      // File scope. C99 6.9.2p2: A declaration of an identifier for an\n      // object that has file scope without an initializer, and without a\n      // storage-class specifier or with the storage-class specifier \"static\",\n      // constitutes a tentative definition. Note: A tentative definition with\n      // external linkage is valid (C99 6.2.2p5).\n      if (!Var->isInvalidDecl()) {\n        if (const IncompleteArrayType *ArrayT\n                                    = Context.getAsIncompleteArrayType(Type)) {\n          if (RequireCompleteSizedType(\n                  Var->getLocation(), ArrayT->getElementType(),\n                  diag::err_array_incomplete_or_sizeless_type))\n            Var->setInvalidDecl();\n        } else if (Var->getStorageClass() == SC_Static) {\n          // C99 6.9.2p3: If the declaration of an identifier for an object is\n          // a tentative definition and has internal linkage (C99 6.2.2p3), the\n          // declared type shall not be an incomplete type.\n          // NOTE: code such as the following\n          //     static struct s;\n          //     struct s { int a; };\n          // is accepted by gcc. Hence here we issue a warning instead of\n          // an error and we do not invalidate the static declaration.\n          // NOTE: to avoid multiple warnings, only check the first declaration.\n          if (Var->isFirstDecl())\n            RequireCompleteType(Var->getLocation(), Type,\n                                diag::ext_typecheck_decl_incomplete_type);\n        }\n      }\n\n      // Record the tentative definition; we're done.\n      if (!Var->isInvalidDecl())\n        TentativeDefinitions.push_back(Var);\n      return;\n    }\n\n    // Provide a specific diagnostic for uninitialized variable\n    // definitions with incomplete array type.\n    if (Type->isIncompleteArrayType()) {\n      Diag(Var->getLocation(),\n           diag::err_typecheck_incomplete_array_needs_initializer);\n      Var->setInvalidDecl();\n      return;\n    }\n\n    // Provide a specific diagnostic for uninitialized variable\n    // definitions with reference type.\n    if (Type->isReferenceType()) {\n      Diag(Var->getLocation(), diag::err_reference_var_requires_init)\n          << Var << SourceRange(Var->getLocation(), Var->getLocation());\n      Var->setInvalidDecl();\n      return;\n    }\n\n    // Do not attempt to type-check the default initializer for a\n    // variable with dependent type.\n    if (Type->isDependentType())\n      return;\n\n    if (Var->isInvalidDecl())\n      return;\n\n    if (!Var->hasAttr<AliasAttr>()) {\n      if (RequireCompleteType(Var->getLocation(),\n                              Context.getBaseElementType(Type),\n                              diag::err_typecheck_decl_incomplete_type)) {\n        Var->setInvalidDecl();\n        return;\n      }\n    } else {\n      return;\n    }\n\n    // The variable can not have an abstract class type.\n    if (RequireNonAbstractType(Var->getLocation(), Type,\n                               diag::err_abstract_type_in_decl,\n                               AbstractVariableType)) {\n      Var->setInvalidDecl();\n      return;\n    }\n\n    // Check for jumps past the implicit initializer.  C++0x\n    // clarifies that this applies to a \"variable with automatic\n    // storage duration\", not a \"local variable\".\n    // C++11 [stmt.dcl]p3\n    //   A program that jumps from a point where a variable with automatic\n    //   storage duration is not in scope to a point where it is in scope is\n    //   ill-formed unless the variable has scalar type, class type with a\n    //   trivial default constructor and a trivial destructor, a cv-qualified\n    //   version of one of these types, or an array of one of the preceding\n    //   types and is declared without an initializer.\n    if (getLangOpts().CPlusPlus && Var->hasLocalStorage()) {\n      if (const RecordType *Record\n            = Context.getBaseElementType(Type)->getAs<RecordType>()) {\n        CXXRecordDecl *CXXRecord = cast<CXXRecordDecl>(Record->getDecl());\n        // Mark the function (if we're in one) for further checking even if the\n        // looser rules of C++11 do not require such checks, so that we can\n        // diagnose incompatibilities with C++98.\n        if (!CXXRecord->isPOD())\n          setFunctionHasBranchProtectedScope();\n      }\n    }\n    // In OpenCL, we can't initialize objects in the __local address space,\n    // even implicitly, so don't synthesize an implicit initializer.\n    if (getLangOpts().OpenCL &&\n        Var->getType().getAddressSpace() == LangAS::opencl_local)\n      return;\n    // C++03 [dcl.init]p9:\n    //   If no initializer is specified for an object, and the\n    //   object is of (possibly cv-qualified) non-POD class type (or\n    //   array thereof), the object shall be default-initialized; if\n    //   the object is of const-qualified type, the underlying class\n    //   type shall have a user-declared default\n    //   constructor. Otherwise, if no initializer is specified for\n    //   a non- static object, the object and its subobjects, if\n    //   any, have an indeterminate initial value); if the object\n    //   or any of its subobjects are of const-qualified type, the\n    //   program is ill-formed.\n    // C++0x [dcl.init]p11:\n    //   If no initializer is specified for an object, the object is\n    //   default-initialized; [...].\n    InitializedEntity Entity = InitializedEntity::InitializeVariable(Var);\n    InitializationKind Kind\n      = InitializationKind::CreateDefault(Var->getLocation());\n\n    InitializationSequence InitSeq(*this, Entity, Kind, None);\n    ExprResult Init = InitSeq.Perform(*this, Entity, Kind, None);\n\n    if (Init.get()) {\n      Var->setInit(MaybeCreateExprWithCleanups(Init.get()));\n      // This is important for template substitution.\n      Var->setInitStyle(VarDecl::CallInit);\n    } else if (Init.isInvalid()) {\n      // If default-init fails, attach a recovery-expr initializer to track\n      // that initialization was attempted and failed.\n      auto RecoveryExpr =\n          CreateRecoveryExpr(Var->getLocation(), Var->getLocation(), {});\n      if (RecoveryExpr.get())\n        Var->setInit(RecoveryExpr.get());\n    }\n\n    CheckCompleteVariableDeclaration(Var);\n  }\n}\n\nvoid Sema::ActOnCXXForRangeDecl(Decl *D) {\n  // If there is no declaration, there was an error parsing it. Ignore it.\n  if (!D)\n    return;\n\n  VarDecl *VD = dyn_cast<VarDecl>(D);\n  if (!VD) {\n    Diag(D->getLocation(), diag::err_for_range_decl_must_be_var);\n    D->setInvalidDecl();\n    return;\n  }\n\n  VD->setCXXForRangeDecl(true);\n\n  // for-range-declaration cannot be given a storage class specifier.\n  int Error = -1;\n  switch (VD->getStorageClass()) {\n  case SC_None:\n    break;\n  case SC_Extern:\n    Error = 0;\n    break;\n  case SC_Static:\n    Error = 1;\n    break;\n  case SC_PrivateExtern:\n    Error = 2;\n    break;\n  case SC_Auto:\n    Error = 3;\n    break;\n  case SC_Register:\n    Error = 4;\n    break;\n  }\n\n  // for-range-declaration cannot be given a storage class specifier con't.\n  switch (VD->getTSCSpec()) {\n  case TSCS_thread_local:\n    Error = 6;\n    break;\n  case TSCS___thread:\n  case TSCS__Thread_local:\n  case TSCS_unspecified:\n    break;\n  }\n\n  if (Error != -1) {\n    Diag(VD->getOuterLocStart(), diag::err_for_range_storage_class)\n        << VD << Error;\n    D->setInvalidDecl();\n  }\n}\n\nStmtResult\nSema::ActOnCXXForRangeIdentifier(Scope *S, SourceLocation IdentLoc,\n                                 IdentifierInfo *Ident,\n                                 ParsedAttributes &Attrs,\n                                 SourceLocation AttrEnd) {\n  // C++1y [stmt.iter]p1:\n  //   A range-based for statement of the form\n  //      for ( for-range-identifier : for-range-initializer ) statement\n  //   is equivalent to\n  //      for ( auto&& for-range-identifier : for-range-initializer ) statement\n  DeclSpec DS(Attrs.getPool().getFactory());\n\n  const char *PrevSpec;\n  unsigned DiagID;\n  DS.SetTypeSpecType(DeclSpec::TST_auto, IdentLoc, PrevSpec, DiagID,\n                     getPrintingPolicy());\n\n  Declarator D(DS, DeclaratorContext::ForInit);\n  D.SetIdentifier(Ident, IdentLoc);\n  D.takeAttributes(Attrs, AttrEnd);\n\n  D.AddTypeInfo(DeclaratorChunk::getReference(0, IdentLoc, /*lvalue*/ false),\n                IdentLoc);\n  Decl *Var = ActOnDeclarator(S, D);\n  cast<VarDecl>(Var)->setCXXForRangeDecl(true);\n  FinalizeDeclaration(Var);\n  return ActOnDeclStmt(FinalizeDeclaratorGroup(S, DS, Var), IdentLoc,\n                       AttrEnd.isValid() ? AttrEnd : IdentLoc);\n}\n\nvoid Sema::CheckCompleteVariableDeclaration(VarDecl *var) {\n  if (var->isInvalidDecl()) return;\n\n  if (getLangOpts().OpenCL) {\n    // OpenCL v2.0 s6.12.5 - Every block variable declaration must have an\n    // initialiser\n    if (var->getTypeSourceInfo()->getType()->isBlockPointerType() &&\n        !var->hasInit()) {\n      Diag(var->getLocation(), diag::err_opencl_invalid_block_declaration)\n          << 1 /*Init*/;\n      var->setInvalidDecl();\n      return;\n    }\n  }\n\n  // In Objective-C, don't allow jumps past the implicit initialization of a\n  // local retaining variable.\n  if (getLangOpts().ObjC &&\n      var->hasLocalStorage()) {\n    switch (var->getType().getObjCLifetime()) {\n    case Qualifiers::OCL_None:\n    case Qualifiers::OCL_ExplicitNone:\n    case Qualifiers::OCL_Autoreleasing:\n      break;\n\n    case Qualifiers::OCL_Weak:\n    case Qualifiers::OCL_Strong:\n      setFunctionHasBranchProtectedScope();\n      break;\n    }\n  }\n\n  if (var->hasLocalStorage() &&\n      var->getType().isDestructedType() == QualType::DK_nontrivial_c_struct)\n    setFunctionHasBranchProtectedScope();\n\n  // Warn about externally-visible variables being defined without a\n  // prior declaration.  We only want to do this for global\n  // declarations, but we also specifically need to avoid doing it for\n  // class members because the linkage of an anonymous class can\n  // change if it's later given a typedef name.\n  if (var->isThisDeclarationADefinition() &&\n      var->getDeclContext()->getRedeclContext()->isFileContext() &&\n      var->isExternallyVisible() && var->hasLinkage() &&\n      !var->isInline() && !var->getDescribedVarTemplate() &&\n      !isa<VarTemplatePartialSpecializationDecl>(var) &&\n      !isTemplateInstantiation(var->getTemplateSpecializationKind()) &&\n      !getDiagnostics().isIgnored(diag::warn_missing_variable_declarations,\n                                  var->getLocation())) {\n    // Find a previous declaration that's not a definition.\n    VarDecl *prev = var->getPreviousDecl();\n    while (prev && prev->isThisDeclarationADefinition())\n      prev = prev->getPreviousDecl();\n\n    if (!prev) {\n      Diag(var->getLocation(), diag::warn_missing_variable_declarations) << var;\n      Diag(var->getTypeSpecStartLoc(), diag::note_static_for_internal_linkage)\n          << /* variable */ 0;\n    }\n  }\n\n  // Cache the result of checking for constant initialization.\n  Optional<bool> CacheHasConstInit;\n  const Expr *CacheCulprit = nullptr;\n  auto checkConstInit = [&]() mutable {\n    if (!CacheHasConstInit)\n      CacheHasConstInit = var->getInit()->isConstantInitializer(\n            Context, var->getType()->isReferenceType(), &CacheCulprit);\n    return *CacheHasConstInit;\n  };\n\n  if (var->getTLSKind() == VarDecl::TLS_Static) {\n    if (var->getType().isDestructedType()) {\n      // GNU C++98 edits for __thread, [basic.start.term]p3:\n      //   The type of an object with thread storage duration shall not\n      //   have a non-trivial destructor.\n      Diag(var->getLocation(), diag::err_thread_nontrivial_dtor);\n      if (getLangOpts().CPlusPlus11)\n        Diag(var->getLocation(), diag::note_use_thread_local);\n    } else if (getLangOpts().CPlusPlus && var->hasInit()) {\n      if (!checkConstInit()) {\n        // GNU C++98 edits for __thread, [basic.start.init]p4:\n        //   An object of thread storage duration shall not require dynamic\n        //   initialization.\n        // FIXME: Need strict checking here.\n        Diag(CacheCulprit->getExprLoc(), diag::err_thread_dynamic_init)\n          << CacheCulprit->getSourceRange();\n        if (getLangOpts().CPlusPlus11)\n          Diag(var->getLocation(), diag::note_use_thread_local);\n      }\n    }\n  }\n\n  // Apply section attributes and pragmas to global variables.\n  bool GlobalStorage = var->hasGlobalStorage();\n  if (GlobalStorage && var->isThisDeclarationADefinition() &&\n      !inTemplateInstantiation()) {\n    PragmaStack<StringLiteral *> *Stack = nullptr;\n    int SectionFlags = ASTContext::PSF_Read;\n    if (var->getType().isConstQualified())\n      Stack = &ConstSegStack;\n    else if (!var->getInit()) {\n      Stack = &BSSSegStack;\n      SectionFlags |= ASTContext::PSF_Write;\n    } else {\n      Stack = &DataSegStack;\n      SectionFlags |= ASTContext::PSF_Write;\n    }\n    if (const SectionAttr *SA = var->getAttr<SectionAttr>()) {\n      if (SA->getSyntax() == AttributeCommonInfo::AS_Declspec)\n        SectionFlags |= ASTContext::PSF_Implicit;\n      UnifySection(SA->getName(), SectionFlags, var);\n    } else if (Stack->CurrentValue) {\n      SectionFlags |= ASTContext::PSF_Implicit;\n      auto SectionName = Stack->CurrentValue->getString();\n      var->addAttr(SectionAttr::CreateImplicit(\n          Context, SectionName, Stack->CurrentPragmaLocation,\n          AttributeCommonInfo::AS_Pragma, SectionAttr::Declspec_allocate));\n      if (UnifySection(SectionName, SectionFlags, var))\n        var->dropAttr<SectionAttr>();\n    }\n\n    // Apply the init_seg attribute if this has an initializer.  If the\n    // initializer turns out to not be dynamic, we'll end up ignoring this\n    // attribute.\n    if (CurInitSeg && var->getInit())\n      var->addAttr(InitSegAttr::CreateImplicit(Context, CurInitSeg->getString(),\n                                               CurInitSegLoc,\n                                               AttributeCommonInfo::AS_Pragma));\n  }\n\n  if (!var->getType()->isStructureType() && var->hasInit() &&\n      isa<InitListExpr>(var->getInit())) {\n    const auto *ILE = cast<InitListExpr>(var->getInit());\n    unsigned NumInits = ILE->getNumInits();\n    if (NumInits > 2)\n      for (unsigned I = 0; I < NumInits; ++I) {\n        const auto *Init = ILE->getInit(I);\n        if (!Init)\n          break;\n        const auto *SL = dyn_cast<StringLiteral>(Init->IgnoreImpCasts());\n        if (!SL)\n          break;\n\n        unsigned NumConcat = SL->getNumConcatenated();\n        // Diagnose missing comma in string array initialization.\n        // Do not warn when all the elements in the initializer are concatenated\n        // together. Do not warn for macros too.\n        if (NumConcat == 2 && !SL->getBeginLoc().isMacroID()) {\n          bool OnlyOneMissingComma = true;\n          for (unsigned J = I + 1; J < NumInits; ++J) {\n            const auto *Init = ILE->getInit(J);\n            if (!Init)\n              break;\n            const auto *SLJ = dyn_cast<StringLiteral>(Init->IgnoreImpCasts());\n            if (!SLJ || SLJ->getNumConcatenated() > 1) {\n              OnlyOneMissingComma = false;\n              break;\n            }\n          }\n\n          if (OnlyOneMissingComma) {\n            SmallVector<FixItHint, 1> Hints;\n            for (unsigned i = 0; i < NumConcat - 1; ++i)\n              Hints.push_back(FixItHint::CreateInsertion(\n                  PP.getLocForEndOfToken(SL->getStrTokenLoc(i)), \",\"));\n\n            Diag(SL->getStrTokenLoc(1),\n                 diag::warn_concatenated_literal_array_init)\n                << Hints;\n            Diag(SL->getBeginLoc(),\n                 diag::note_concatenated_string_literal_silence);\n          }\n          // In any case, stop now.\n          break;\n        }\n      }\n  }\n\n  // All the following checks are C++ only.\n  if (!getLangOpts().CPlusPlus) {\n    // If this variable must be emitted, add it as an initializer for the\n    // current module.\n    if (Context.DeclMustBeEmitted(var) && !ModuleScopes.empty())\n      Context.addModuleInitializer(ModuleScopes.back().Module, var);\n    return;\n  }\n\n  QualType type = var->getType();\n\n  if (var->hasAttr<BlocksAttr>())\n    getCurFunction()->addByrefBlockVar(var);\n\n  Expr *Init = var->getInit();\n  bool IsGlobal = GlobalStorage && !var->isStaticLocal();\n  QualType baseType = Context.getBaseElementType(type);\n\n  // Check whether the initializer is sufficiently constant.\n  if (!type->isDependentType() && Init && !Init->isValueDependent() &&\n      (GlobalStorage || var->isConstexpr() ||\n       var->mightBeUsableInConstantExpressions(Context))) {\n    // If this variable might have a constant initializer or might be usable in\n    // constant expressions, check whether or not it actually is now.  We can't\n    // do this lazily, because the result might depend on things that change\n    // later, such as which constexpr functions happen to be defined.\n    SmallVector<PartialDiagnosticAt, 8> Notes;\n    bool HasConstInit;\n    if (!getLangOpts().CPlusPlus11) {\n      // Prior to C++11, in contexts where a constant initializer is required,\n      // the set of valid constant initializers is described by syntactic rules\n      // in [expr.const]p2-6.\n      // FIXME: Stricter checking for these rules would be useful for constinit /\n      // -Wglobal-constructors.\n      HasConstInit = checkConstInit();\n\n      // Compute and cache the constant value, and remember that we have a\n      // constant initializer.\n      if (HasConstInit) {\n        (void)var->checkForConstantInitialization(Notes);\n        Notes.clear();\n      } else if (CacheCulprit) {\n        Notes.emplace_back(CacheCulprit->getExprLoc(),\n                           PDiag(diag::note_invalid_subexpr_in_const_expr));\n        Notes.back().second << CacheCulprit->getSourceRange();\n      }\n    } else {\n      // Evaluate the initializer to see if it's a constant initializer.\n      HasConstInit = var->checkForConstantInitialization(Notes);\n    }\n\n    if (HasConstInit) {\n      // FIXME: Consider replacing the initializer with a ConstantExpr.\n    } else if (var->isConstexpr()) {\n      SourceLocation DiagLoc = var->getLocation();\n      // If the note doesn't add any useful information other than a source\n      // location, fold it into the primary diagnostic.\n      if (Notes.size() == 1 && Notes[0].second.getDiagID() ==\n                                   diag::note_invalid_subexpr_in_const_expr) {\n        DiagLoc = Notes[0].first;\n        Notes.clear();\n      }\n      Diag(DiagLoc, diag::err_constexpr_var_requires_const_init)\n          << var << Init->getSourceRange();\n      for (unsigned I = 0, N = Notes.size(); I != N; ++I)\n        Diag(Notes[I].first, Notes[I].second);\n    } else if (GlobalStorage && var->hasAttr<ConstInitAttr>()) {\n      auto *Attr = var->getAttr<ConstInitAttr>();\n      Diag(var->getLocation(), diag::err_require_constant_init_failed)\n          << Init->getSourceRange();\n      Diag(Attr->getLocation(), diag::note_declared_required_constant_init_here)\n          << Attr->getRange() << Attr->isConstinit();\n      for (auto &it : Notes)\n        Diag(it.first, it.second);\n    } else if (IsGlobal &&\n               !getDiagnostics().isIgnored(diag::warn_global_constructor,\n                                           var->getLocation())) {\n      // Warn about globals which don't have a constant initializer.  Don't\n      // warn about globals with a non-trivial destructor because we already\n      // warned about them.\n      CXXRecordDecl *RD = baseType->getAsCXXRecordDecl();\n      if (!(RD && !RD->hasTrivialDestructor())) {\n        // checkConstInit() here permits trivial default initialization even in\n        // C++11 onwards, where such an initializer is not a constant initializer\n        // but nonetheless doesn't require a global constructor.\n        if (!checkConstInit())\n          Diag(var->getLocation(), diag::warn_global_constructor)\n              << Init->getSourceRange();\n      }\n    }\n  }\n\n  // Require the destructor.\n  if (!type->isDependentType())\n    if (const RecordType *recordType = baseType->getAs<RecordType>())\n      FinalizeVarWithDestructor(var, recordType);\n\n  // If this variable must be emitted, add it as an initializer for the current\n  // module.\n  if (Context.DeclMustBeEmitted(var) && !ModuleScopes.empty())\n    Context.addModuleInitializer(ModuleScopes.back().Module, var);\n\n  // Build the bindings if this is a structured binding declaration.\n  if (auto *DD = dyn_cast<DecompositionDecl>(var))\n    CheckCompleteDecompositionDeclaration(DD);\n}\n\n/// Determines if a variable's alignment is dependent.\nstatic bool hasDependentAlignment(VarDecl *VD) {\n  if (VD->getType()->isDependentType())\n    return true;\n  for (auto *I : VD->specific_attrs<AlignedAttr>())\n    if (I->isAlignmentDependent())\n      return true;\n  return false;\n}\n\n/// Check if VD needs to be dllexport/dllimport due to being in a\n/// dllexport/import function.\nvoid Sema::CheckStaticLocalForDllExport(VarDecl *VD) {\n  assert(VD->isStaticLocal());\n\n  auto *FD = dyn_cast_or_null<FunctionDecl>(VD->getParentFunctionOrMethod());\n\n  // Find outermost function when VD is in lambda function.\n  while (FD && !getDLLAttr(FD) &&\n         !FD->hasAttr<DLLExportStaticLocalAttr>() &&\n         !FD->hasAttr<DLLImportStaticLocalAttr>()) {\n    FD = dyn_cast_or_null<FunctionDecl>(FD->getParentFunctionOrMethod());\n  }\n\n  if (!FD)\n    return;\n\n  // Static locals inherit dll attributes from their function.\n  if (Attr *A = getDLLAttr(FD)) {\n    auto *NewAttr = cast<InheritableAttr>(A->clone(getASTContext()));\n    NewAttr->setInherited(true);\n    VD->addAttr(NewAttr);\n  } else if (Attr *A = FD->getAttr<DLLExportStaticLocalAttr>()) {\n    auto *NewAttr = DLLExportAttr::CreateImplicit(getASTContext(), *A);\n    NewAttr->setInherited(true);\n    VD->addAttr(NewAttr);\n\n    // Export this function to enforce exporting this static variable even\n    // if it is not used in this compilation unit.\n    if (!FD->hasAttr<DLLExportAttr>())\n      FD->addAttr(NewAttr);\n\n  } else if (Attr *A = FD->getAttr<DLLImportStaticLocalAttr>()) {\n    auto *NewAttr = DLLImportAttr::CreateImplicit(getASTContext(), *A);\n    NewAttr->setInherited(true);\n    VD->addAttr(NewAttr);\n  }\n}\n\n/// FinalizeDeclaration - called by ParseDeclarationAfterDeclarator to perform\n/// any semantic actions necessary after any initializer has been attached.\nvoid Sema::FinalizeDeclaration(Decl *ThisDecl) {\n  // Note that we are no longer parsing the initializer for this declaration.\n  ParsingInitForAutoVars.erase(ThisDecl);\n\n  VarDecl *VD = dyn_cast_or_null<VarDecl>(ThisDecl);\n  if (!VD)\n    return;\n\n  // Apply an implicit SectionAttr if '#pragma clang section bss|data|rodata' is active\n  if (VD->hasGlobalStorage() && VD->isThisDeclarationADefinition() &&\n      !inTemplateInstantiation() && !VD->hasAttr<SectionAttr>()) {\n    if (PragmaClangBSSSection.Valid)\n      VD->addAttr(PragmaClangBSSSectionAttr::CreateImplicit(\n          Context, PragmaClangBSSSection.SectionName,\n          PragmaClangBSSSection.PragmaLocation,\n          AttributeCommonInfo::AS_Pragma));\n    if (PragmaClangDataSection.Valid)\n      VD->addAttr(PragmaClangDataSectionAttr::CreateImplicit(\n          Context, PragmaClangDataSection.SectionName,\n          PragmaClangDataSection.PragmaLocation,\n          AttributeCommonInfo::AS_Pragma));\n    if (PragmaClangRodataSection.Valid)\n      VD->addAttr(PragmaClangRodataSectionAttr::CreateImplicit(\n          Context, PragmaClangRodataSection.SectionName,\n          PragmaClangRodataSection.PragmaLocation,\n          AttributeCommonInfo::AS_Pragma));\n    if (PragmaClangRelroSection.Valid)\n      VD->addAttr(PragmaClangRelroSectionAttr::CreateImplicit(\n          Context, PragmaClangRelroSection.SectionName,\n          PragmaClangRelroSection.PragmaLocation,\n          AttributeCommonInfo::AS_Pragma));\n  }\n\n  if (auto *DD = dyn_cast<DecompositionDecl>(ThisDecl)) {\n    for (auto *BD : DD->bindings()) {\n      FinalizeDeclaration(BD);\n    }\n  }\n\n  checkAttributesAfterMerging(*this, *VD);\n\n  // Perform TLS alignment check here after attributes attached to the variable\n  // which may affect the alignment have been processed. Only perform the check\n  // if the target has a maximum TLS alignment (zero means no constraints).\n  if (unsigned MaxAlign = Context.getTargetInfo().getMaxTLSAlign()) {\n    // Protect the check so that it's not performed on dependent types and\n    // dependent alignments (we can't determine the alignment in that case).\n    if (VD->getTLSKind() && !hasDependentAlignment(VD) &&\n        !VD->isInvalidDecl()) {\n      CharUnits MaxAlignChars = Context.toCharUnitsFromBits(MaxAlign);\n      if (Context.getDeclAlign(VD) > MaxAlignChars) {\n        Diag(VD->getLocation(), diag::err_tls_var_aligned_over_maximum)\n          << (unsigned)Context.getDeclAlign(VD).getQuantity() << VD\n          << (unsigned)MaxAlignChars.getQuantity();\n      }\n    }\n  }\n\n  if (VD->isStaticLocal())\n    CheckStaticLocalForDllExport(VD);\n\n  // Perform check for initializers of device-side global variables.\n  // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA\n  // 7.5). We must also apply the same checks to all __shared__\n  // variables whether they are local or not. CUDA also allows\n  // constant initializers for __constant__ and __device__ variables.\n  if (getLangOpts().CUDA)\n    checkAllowedCUDAInitializer(VD);\n\n  // Grab the dllimport or dllexport attribute off of the VarDecl.\n  const InheritableAttr *DLLAttr = getDLLAttr(VD);\n\n  // Imported static data members cannot be defined out-of-line.\n  if (const auto *IA = dyn_cast_or_null<DLLImportAttr>(DLLAttr)) {\n    if (VD->isStaticDataMember() && VD->isOutOfLine() &&\n        VD->isThisDeclarationADefinition()) {\n      // We allow definitions of dllimport class template static data members\n      // with a warning.\n      CXXRecordDecl *Context =\n        cast<CXXRecordDecl>(VD->getFirstDecl()->getDeclContext());\n      bool IsClassTemplateMember =\n          isa<ClassTemplatePartialSpecializationDecl>(Context) ||\n          Context->getDescribedClassTemplate();\n\n      Diag(VD->getLocation(),\n           IsClassTemplateMember\n               ? diag::warn_attribute_dllimport_static_field_definition\n               : diag::err_attribute_dllimport_static_field_definition);\n      Diag(IA->getLocation(), diag::note_attribute);\n      if (!IsClassTemplateMember)\n        VD->setInvalidDecl();\n    }\n  }\n\n  // dllimport/dllexport variables cannot be thread local, their TLS index\n  // isn't exported with the variable.\n  if (DLLAttr && VD->getTLSKind()) {\n    auto *F = dyn_cast_or_null<FunctionDecl>(VD->getParentFunctionOrMethod());\n    if (F && getDLLAttr(F)) {\n      assert(VD->isStaticLocal());\n      // But if this is a static local in a dlimport/dllexport function, the\n      // function will never be inlined, which means the var would never be\n      // imported, so having it marked import/export is safe.\n    } else {\n      Diag(VD->getLocation(), diag::err_attribute_dll_thread_local) << VD\n                                                                    << DLLAttr;\n      VD->setInvalidDecl();\n    }\n  }\n\n  if (UsedAttr *Attr = VD->getAttr<UsedAttr>()) {\n    if (!Attr->isInherited() && !VD->isThisDeclarationADefinition()) {\n      Diag(Attr->getLocation(), diag::warn_attribute_ignored_on_non_definition)\n          << Attr;\n      VD->dropAttr<UsedAttr>();\n    }\n  }\n  if (RetainAttr *Attr = VD->getAttr<RetainAttr>()) {\n    if (!Attr->isInherited() && !VD->isThisDeclarationADefinition()) {\n      Diag(Attr->getLocation(), diag::warn_attribute_ignored_on_non_definition)\n          << Attr;\n      VD->dropAttr<RetainAttr>();\n    }\n  }\n\n  const DeclContext *DC = VD->getDeclContext();\n  // If there's a #pragma GCC visibility in scope, and this isn't a class\n  // member, set the visibility of this variable.\n  if (DC->getRedeclContext()->isFileContext() && VD->isExternallyVisible())\n    AddPushedVisibilityAttribute(VD);\n\n  // FIXME: Warn on unused var template partial specializations.\n  if (VD->isFileVarDecl() && !isa<VarTemplatePartialSpecializationDecl>(VD))\n    MarkUnusedFileScopedDecl(VD);\n\n  // Now we have parsed the initializer and can update the table of magic\n  // tag values.\n  if (!VD->hasAttr<TypeTagForDatatypeAttr>() ||\n      !VD->getType()->isIntegralOrEnumerationType())\n    return;\n\n  for (const auto *I : ThisDecl->specific_attrs<TypeTagForDatatypeAttr>()) {\n    const Expr *MagicValueExpr = VD->getInit();\n    if (!MagicValueExpr) {\n      continue;\n    }\n    Optional<llvm::APSInt> MagicValueInt;\n    if (!(MagicValueInt = MagicValueExpr->getIntegerConstantExpr(Context))) {\n      Diag(I->getRange().getBegin(),\n           diag::err_type_tag_for_datatype_not_ice)\n        << LangOpts.CPlusPlus << MagicValueExpr->getSourceRange();\n      continue;\n    }\n    if (MagicValueInt->getActiveBits() > 64) {\n      Diag(I->getRange().getBegin(),\n           diag::err_type_tag_for_datatype_too_large)\n        << LangOpts.CPlusPlus << MagicValueExpr->getSourceRange();\n      continue;\n    }\n    uint64_t MagicValue = MagicValueInt->getZExtValue();\n    RegisterTypeTagForDatatype(I->getArgumentKind(),\n                               MagicValue,\n                               I->getMatchingCType(),\n                               I->getLayoutCompatible(),\n                               I->getMustBeNull());\n  }\n}\n\nstatic bool hasDeducedAuto(DeclaratorDecl *DD) {\n  auto *VD = dyn_cast<VarDecl>(DD);\n  return VD && !VD->getType()->hasAutoForTrailingReturnType();\n}\n\nSema::DeclGroupPtrTy Sema::FinalizeDeclaratorGroup(Scope *S, const DeclSpec &DS,\n                                                   ArrayRef<Decl *> Group) {\n  SmallVector<Decl*, 8> Decls;\n\n  if (DS.isTypeSpecOwned())\n    Decls.push_back(DS.getRepAsDecl());\n\n  DeclaratorDecl *FirstDeclaratorInGroup = nullptr;\n  DecompositionDecl *FirstDecompDeclaratorInGroup = nullptr;\n  bool DiagnosedMultipleDecomps = false;\n  DeclaratorDecl *FirstNonDeducedAutoInGroup = nullptr;\n  bool DiagnosedNonDeducedAuto = false;\n\n  for (unsigned i = 0, e = Group.size(); i != e; ++i) {\n    if (Decl *D = Group[i]) {\n      // For declarators, there are some additional syntactic-ish checks we need\n      // to perform.\n      if (auto *DD = dyn_cast<DeclaratorDecl>(D)) {\n        if (!FirstDeclaratorInGroup)\n          FirstDeclaratorInGroup = DD;\n        if (!FirstDecompDeclaratorInGroup)\n          FirstDecompDeclaratorInGroup = dyn_cast<DecompositionDecl>(D);\n        if (!FirstNonDeducedAutoInGroup && DS.hasAutoTypeSpec() &&\n            !hasDeducedAuto(DD))\n          FirstNonDeducedAutoInGroup = DD;\n\n        if (FirstDeclaratorInGroup != DD) {\n          // A decomposition declaration cannot be combined with any other\n          // declaration in the same group.\n          if (FirstDecompDeclaratorInGroup && !DiagnosedMultipleDecomps) {\n            Diag(FirstDecompDeclaratorInGroup->getLocation(),\n                 diag::err_decomp_decl_not_alone)\n                << FirstDeclaratorInGroup->getSourceRange()\n                << DD->getSourceRange();\n            DiagnosedMultipleDecomps = true;\n          }\n\n          // A declarator that uses 'auto' in any way other than to declare a\n          // variable with a deduced type cannot be combined with any other\n          // declarator in the same group.\n          if (FirstNonDeducedAutoInGroup && !DiagnosedNonDeducedAuto) {\n            Diag(FirstNonDeducedAutoInGroup->getLocation(),\n                 diag::err_auto_non_deduced_not_alone)\n                << FirstNonDeducedAutoInGroup->getType()\n                       ->hasAutoForTrailingReturnType()\n                << FirstDeclaratorInGroup->getSourceRange()\n                << DD->getSourceRange();\n            DiagnosedNonDeducedAuto = true;\n          }\n        }\n      }\n\n      Decls.push_back(D);\n    }\n  }\n\n  if (DeclSpec::isDeclRep(DS.getTypeSpecType())) {\n    if (TagDecl *Tag = dyn_cast_or_null<TagDecl>(DS.getRepAsDecl())) {\n      handleTagNumbering(Tag, S);\n      if (FirstDeclaratorInGroup && !Tag->hasNameForLinkage() &&\n          getLangOpts().CPlusPlus)\n        Context.addDeclaratorForUnnamedTagDecl(Tag, FirstDeclaratorInGroup);\n    }\n  }\n\n  return BuildDeclaratorGroup(Decls);\n}\n\n/// BuildDeclaratorGroup - convert a list of declarations into a declaration\n/// group, performing any necessary semantic checking.\nSema::DeclGroupPtrTy\nSema::BuildDeclaratorGroup(MutableArrayRef<Decl *> Group) {\n  // C++14 [dcl.spec.auto]p7: (DR1347)\n  //   If the type that replaces the placeholder type is not the same in each\n  //   deduction, the program is ill-formed.\n  if (Group.size() > 1) {\n    QualType Deduced;\n    VarDecl *DeducedDecl = nullptr;\n    for (unsigned i = 0, e = Group.size(); i != e; ++i) {\n      VarDecl *D = dyn_cast<VarDecl>(Group[i]);\n      if (!D || D->isInvalidDecl())\n        break;\n      DeducedType *DT = D->getType()->getContainedDeducedType();\n      if (!DT || DT->getDeducedType().isNull())\n        continue;\n      if (Deduced.isNull()) {\n        Deduced = DT->getDeducedType();\n        DeducedDecl = D;\n      } else if (!Context.hasSameType(DT->getDeducedType(), Deduced)) {\n        auto *AT = dyn_cast<AutoType>(DT);\n        auto Dia = Diag(D->getTypeSourceInfo()->getTypeLoc().getBeginLoc(),\n                        diag::err_auto_different_deductions)\n                   << (AT ? (unsigned)AT->getKeyword() : 3) << Deduced\n                   << DeducedDecl->getDeclName() << DT->getDeducedType()\n                   << D->getDeclName();\n        if (DeducedDecl->hasInit())\n          Dia << DeducedDecl->getInit()->getSourceRange();\n        if (D->getInit())\n          Dia << D->getInit()->getSourceRange();\n        D->setInvalidDecl();\n        break;\n      }\n    }\n  }\n\n  ActOnDocumentableDecls(Group);\n\n  return DeclGroupPtrTy::make(\n      DeclGroupRef::Create(Context, Group.data(), Group.size()));\n}\n\nvoid Sema::ActOnDocumentableDecl(Decl *D) {\n  ActOnDocumentableDecls(D);\n}\n\nvoid Sema::ActOnDocumentableDecls(ArrayRef<Decl *> Group) {\n  // Don't parse the comment if Doxygen diagnostics are ignored.\n  if (Group.empty() || !Group[0])\n    return;\n\n  if (Diags.isIgnored(diag::warn_doc_param_not_found,\n                      Group[0]->getLocation()) &&\n      Diags.isIgnored(diag::warn_unknown_comment_command_name,\n                      Group[0]->getLocation()))\n    return;\n\n  if (Group.size() >= 2) {\n    // This is a decl group.  Normally it will contain only declarations\n    // produced from declarator list.  But in case we have any definitions or\n    // additional declaration references:\n    //   'typedef struct S {} S;'\n    //   'typedef struct S *S;'\n    //   'struct S *pS;'\n    // FinalizeDeclaratorGroup adds these as separate declarations.\n    Decl *MaybeTagDecl = Group[0];\n    if (MaybeTagDecl && isa<TagDecl>(MaybeTagDecl)) {\n      Group = Group.slice(1);\n    }\n  }\n\n  // FIMXE: We assume every Decl in the group is in the same file.\n  // This is false when preprocessor constructs the group from decls in\n  // different files (e. g. macros or #include).\n  Context.attachCommentsToJustParsedDecls(Group, &getPreprocessor());\n}\n\n/// Common checks for a parameter-declaration that should apply to both function\n/// parameters and non-type template parameters.\nvoid Sema::CheckFunctionOrTemplateParamDeclarator(Scope *S, Declarator &D) {\n  // Check that there are no default arguments inside the type of this\n  // parameter.\n  if (getLangOpts().CPlusPlus)\n    CheckExtraCXXDefaultArguments(D);\n\n  // Parameter declarators cannot be qualified (C++ [dcl.meaning]p1).\n  if (D.getCXXScopeSpec().isSet()) {\n    Diag(D.getIdentifierLoc(), diag::err_qualified_param_declarator)\n      << D.getCXXScopeSpec().getRange();\n  }\n\n  // [dcl.meaning]p1: An unqualified-id occurring in a declarator-id shall be a\n  // simple identifier except [...irrelevant cases...].\n  switch (D.getName().getKind()) {\n  case UnqualifiedIdKind::IK_Identifier:\n    break;\n\n  case UnqualifiedIdKind::IK_OperatorFunctionId:\n  case UnqualifiedIdKind::IK_ConversionFunctionId:\n  case UnqualifiedIdKind::IK_LiteralOperatorId:\n  case UnqualifiedIdKind::IK_ConstructorName:\n  case UnqualifiedIdKind::IK_DestructorName:\n  case UnqualifiedIdKind::IK_ImplicitSelfParam:\n  case UnqualifiedIdKind::IK_DeductionGuideName:\n    Diag(D.getIdentifierLoc(), diag::err_bad_parameter_name)\n      << GetNameForDeclarator(D).getName();\n    break;\n\n  case UnqualifiedIdKind::IK_TemplateId:\n  case UnqualifiedIdKind::IK_ConstructorTemplateId:\n    // GetNameForDeclarator would not produce a useful name in this case.\n    Diag(D.getIdentifierLoc(), diag::err_bad_parameter_name_template_id);\n    break;\n  }\n}\n\n/// ActOnParamDeclarator - Called from Parser::ParseFunctionDeclarator()\n/// to introduce parameters into function prototype scope.\nDecl *Sema::ActOnParamDeclarator(Scope *S, Declarator &D) {\n  const DeclSpec &DS = D.getDeclSpec();\n\n  // Verify C99 6.7.5.3p2: The only SCS allowed is 'register'.\n\n  // C++03 [dcl.stc]p2 also permits 'auto'.\n  StorageClass SC = SC_None;\n  if (DS.getStorageClassSpec() == DeclSpec::SCS_register) {\n    SC = SC_Register;\n    // In C++11, the 'register' storage class specifier is deprecated.\n    // In C++17, it is not allowed, but we tolerate it as an extension.\n    if (getLangOpts().CPlusPlus11) {\n      Diag(DS.getStorageClassSpecLoc(),\n           getLangOpts().CPlusPlus17 ? diag::ext_register_storage_class\n                                     : diag::warn_deprecated_register)\n        << FixItHint::CreateRemoval(DS.getStorageClassSpecLoc());\n    }\n  } else if (getLangOpts().CPlusPlus &&\n             DS.getStorageClassSpec() == DeclSpec::SCS_auto) {\n    SC = SC_Auto;\n  } else if (DS.getStorageClassSpec() != DeclSpec::SCS_unspecified) {\n    Diag(DS.getStorageClassSpecLoc(),\n         diag::err_invalid_storage_class_in_func_decl);\n    D.getMutableDeclSpec().ClearStorageClassSpecs();\n  }\n\n  if (DeclSpec::TSCS TSCS = DS.getThreadStorageClassSpec())\n    Diag(DS.getThreadStorageClassSpecLoc(), diag::err_invalid_thread)\n      << DeclSpec::getSpecifierName(TSCS);\n  if (DS.isInlineSpecified())\n    Diag(DS.getInlineSpecLoc(), diag::err_inline_non_function)\n        << getLangOpts().CPlusPlus17;\n  if (DS.hasConstexprSpecifier())\n    Diag(DS.getConstexprSpecLoc(), diag::err_invalid_constexpr)\n        << 0 << static_cast<int>(D.getDeclSpec().getConstexprSpecifier());\n\n  DiagnoseFunctionSpecifiers(DS);\n\n  CheckFunctionOrTemplateParamDeclarator(S, D);\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType parmDeclType = TInfo->getType();\n\n  // Check for redeclaration of parameters, e.g. int foo(int x, int x);\n  IdentifierInfo *II = D.getIdentifier();\n  if (II) {\n    LookupResult R(*this, II, D.getIdentifierLoc(), LookupOrdinaryName,\n                   ForVisibleRedeclaration);\n    LookupName(R, S);\n    if (R.isSingleResult()) {\n      NamedDecl *PrevDecl = R.getFoundDecl();\n      if (PrevDecl->isTemplateParameter()) {\n        // Maybe we will complain about the shadowed template parameter.\n        DiagnoseTemplateParameterShadow(D.getIdentifierLoc(), PrevDecl);\n        // Just pretend that we didn't see the previous declaration.\n        PrevDecl = nullptr;\n      } else if (S->isDeclScope(PrevDecl)) {\n        Diag(D.getIdentifierLoc(), diag::err_param_redefinition) << II;\n        Diag(PrevDecl->getLocation(), diag::note_previous_declaration);\n\n        // Recover by removing the name\n        II = nullptr;\n        D.SetIdentifier(nullptr, D.getIdentifierLoc());\n        D.setInvalidType(true);\n      }\n    }\n  }\n\n  // Temporarily put parameter variables in the translation unit, not\n  // the enclosing context.  This prevents them from accidentally\n  // looking like class members in C++.\n  ParmVarDecl *New =\n      CheckParameter(Context.getTranslationUnitDecl(), D.getBeginLoc(),\n                     D.getIdentifierLoc(), II, parmDeclType, TInfo, SC);\n\n  if (D.isInvalidType())\n    New->setInvalidDecl();\n\n  assert(S->isFunctionPrototypeScope());\n  assert(S->getFunctionPrototypeDepth() >= 1);\n  New->setScopeInfo(S->getFunctionPrototypeDepth() - 1,\n                    S->getNextFunctionPrototypeIndex());\n\n  // Add the parameter declaration into this scope.\n  S->AddDecl(New);\n  if (II)\n    IdResolver.AddDecl(New);\n\n  ProcessDeclAttributes(S, New, D);\n\n  if (D.getDeclSpec().isModulePrivateSpecified())\n    Diag(New->getLocation(), diag::err_module_private_local)\n        << 1 << New << SourceRange(D.getDeclSpec().getModulePrivateSpecLoc())\n        << FixItHint::CreateRemoval(D.getDeclSpec().getModulePrivateSpecLoc());\n\n  if (New->hasAttr<BlocksAttr>()) {\n    Diag(New->getLocation(), diag::err_block_on_nonlocal);\n  }\n\n  if (getLangOpts().OpenCL)\n    deduceOpenCLAddressSpace(New);\n\n  return New;\n}\n\n/// Synthesizes a variable for a parameter arising from a\n/// typedef.\nParmVarDecl *Sema::BuildParmVarDeclForTypedef(DeclContext *DC,\n                                              SourceLocation Loc,\n                                              QualType T) {\n  /* FIXME: setting StartLoc == Loc.\n     Would it be worth to modify callers so as to provide proper source\n     location for the unnamed parameters, embedding the parameter's type? */\n  ParmVarDecl *Param = ParmVarDecl::Create(Context, DC, Loc, Loc, nullptr,\n                                T, Context.getTrivialTypeSourceInfo(T, Loc),\n                                           SC_None, nullptr);\n  Param->setImplicit();\n  return Param;\n}\n\nvoid Sema::DiagnoseUnusedParameters(ArrayRef<ParmVarDecl *> Parameters) {\n  // Don't diagnose unused-parameter errors in template instantiations; we\n  // will already have done so in the template itself.\n  if (inTemplateInstantiation())\n    return;\n\n  for (const ParmVarDecl *Parameter : Parameters) {\n    if (!Parameter->isReferenced() && Parameter->getDeclName() &&\n        !Parameter->hasAttr<UnusedAttr>()) {\n      Diag(Parameter->getLocation(), diag::warn_unused_parameter)\n        << Parameter->getDeclName();\n    }\n  }\n}\n\nvoid Sema::DiagnoseSizeOfParametersAndReturnValue(\n    ArrayRef<ParmVarDecl *> Parameters, QualType ReturnTy, NamedDecl *D) {\n  if (LangOpts.NumLargeByValueCopy == 0) // No check.\n    return;\n\n  // Warn if the return value is pass-by-value and larger than the specified\n  // threshold.\n  if (!ReturnTy->isDependentType() && ReturnTy.isPODType(Context)) {\n    unsigned Size = Context.getTypeSizeInChars(ReturnTy).getQuantity();\n    if (Size > LangOpts.NumLargeByValueCopy)\n      Diag(D->getLocation(), diag::warn_return_value_size) << D << Size;\n  }\n\n  // Warn if any parameter is pass-by-value and larger than the specified\n  // threshold.\n  for (const ParmVarDecl *Parameter : Parameters) {\n    QualType T = Parameter->getType();\n    if (T->isDependentType() || !T.isPODType(Context))\n      continue;\n    unsigned Size = Context.getTypeSizeInChars(T).getQuantity();\n    if (Size > LangOpts.NumLargeByValueCopy)\n      Diag(Parameter->getLocation(), diag::warn_parameter_size)\n          << Parameter << Size;\n  }\n}\n\nParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,\n                                  SourceLocation NameLoc, IdentifierInfo *Name,\n                                  QualType T, TypeSourceInfo *TSInfo,\n                                  StorageClass SC) {\n  // In ARC, infer a lifetime qualifier for appropriate parameter types.\n  if (getLangOpts().ObjCAutoRefCount &&\n      T.getObjCLifetime() == Qualifiers::OCL_None &&\n      T->isObjCLifetimeType()) {\n\n    Qualifiers::ObjCLifetime lifetime;\n\n    // Special cases for arrays:\n    //   - if it's const, use __unsafe_unretained\n    //   - otherwise, it's an error\n    if (T->isArrayType()) {\n      if (!T.isConstQualified()) {\n        if (DelayedDiagnostics.shouldDelayDiagnostics())\n          DelayedDiagnostics.add(\n              sema::DelayedDiagnostic::makeForbiddenType(\n              NameLoc, diag::err_arc_array_param_no_ownership, T, false));\n        else\n          Diag(NameLoc, diag::err_arc_array_param_no_ownership)\n              << TSInfo->getTypeLoc().getSourceRange();\n      }\n      lifetime = Qualifiers::OCL_ExplicitNone;\n    } else {\n      lifetime = T->getObjCARCImplicitLifetime();\n    }\n    T = Context.getLifetimeQualifiedType(T, lifetime);\n  }\n\n  ParmVarDecl *New = ParmVarDecl::Create(Context, DC, StartLoc, NameLoc, Name,\n                                         Context.getAdjustedParameterType(T),\n                                         TSInfo, SC, nullptr);\n\n  // Make a note if we created a new pack in the scope of a lambda, so that\n  // we know that references to that pack must also be expanded within the\n  // lambda scope.\n  if (New->isParameterPack())\n    if (auto *LSI = getEnclosingLambda())\n      LSI->LocalPacks.push_back(New);\n\n  if (New->getType().hasNonTrivialToPrimitiveDestructCUnion() ||\n      New->getType().hasNonTrivialToPrimitiveCopyCUnion())\n    checkNonTrivialCUnion(New->getType(), New->getLocation(),\n                          NTCUC_FunctionParam, NTCUK_Destruct|NTCUK_Copy);\n\n  // Parameters can not be abstract class types.\n  // For record types, this is done by the AbstractClassUsageDiagnoser once\n  // the class has been completely parsed.\n  if (!CurContext->isRecord() &&\n      RequireNonAbstractType(NameLoc, T, diag::err_abstract_type_in_decl,\n                             AbstractParamType))\n    New->setInvalidDecl();\n\n  // Parameter declarators cannot be interface types. All ObjC objects are\n  // passed by reference.\n  if (T->isObjCObjectType()) {\n    SourceLocation TypeEndLoc =\n        getLocForEndOfToken(TSInfo->getTypeLoc().getEndLoc());\n    Diag(NameLoc,\n         diag::err_object_cannot_be_passed_returned_by_value) << 1 << T\n      << FixItHint::CreateInsertion(TypeEndLoc, \"*\");\n    T = Context.getObjCObjectPointerType(T);\n    New->setType(T);\n  }\n\n  // ISO/IEC TR 18037 S6.7.3: \"The type of an object with automatic storage\n  // duration shall not be qualified by an address-space qualifier.\"\n  // Since all parameters have automatic store duration, they can not have\n  // an address space.\n  if (T.getAddressSpace() != LangAS::Default &&\n      // OpenCL allows function arguments declared to be an array of a type\n      // to be qualified with an address space.\n      !(getLangOpts().OpenCL &&\n        (T->isArrayType() || T.getAddressSpace() == LangAS::opencl_private))) {\n    Diag(NameLoc, diag::err_arg_with_address_space);\n    New->setInvalidDecl();\n  }\n\n  // PPC MMA non-pointer types are not allowed as function argument types.\n  if (Context.getTargetInfo().getTriple().isPPC64() &&\n      CheckPPCMMAType(New->getOriginalType(), New->getLocation())) {\n    New->setInvalidDecl();\n  }\n\n  return New;\n}\n\nvoid Sema::ActOnFinishKNRParamDeclarations(Scope *S, Declarator &D,\n                                           SourceLocation LocAfterDecls) {\n  DeclaratorChunk::FunctionTypeInfo &FTI = D.getFunctionTypeInfo();\n\n  // Verify 6.9.1p6: 'every identifier in the identifier list shall be declared'\n  // for a K&R function.\n  if (!FTI.hasPrototype) {\n    for (int i = FTI.NumParams; i != 0; /* decrement in loop */) {\n      --i;\n      if (FTI.Params[i].Param == nullptr) {\n        SmallString<256> Code;\n        llvm::raw_svector_ostream(Code)\n            << \"  int \" << FTI.Params[i].Ident->getName() << \";\\n\";\n        Diag(FTI.Params[i].IdentLoc, diag::ext_param_not_declared)\n            << FTI.Params[i].Ident\n            << FixItHint::CreateInsertion(LocAfterDecls, Code);\n\n        // Implicitly declare the argument as type 'int' for lack of a better\n        // type.\n        AttributeFactory attrs;\n        DeclSpec DS(attrs);\n        const char* PrevSpec; // unused\n        unsigned DiagID; // unused\n        DS.SetTypeSpecType(DeclSpec::TST_int, FTI.Params[i].IdentLoc, PrevSpec,\n                           DiagID, Context.getPrintingPolicy());\n        // Use the identifier location for the type source range.\n        DS.SetRangeStart(FTI.Params[i].IdentLoc);\n        DS.SetRangeEnd(FTI.Params[i].IdentLoc);\n        Declarator ParamD(DS, DeclaratorContext::KNRTypeList);\n        ParamD.SetIdentifier(FTI.Params[i].Ident, FTI.Params[i].IdentLoc);\n        FTI.Params[i].Param = ActOnParamDeclarator(S, ParamD);\n      }\n    }\n  }\n}\n\nDecl *\nSema::ActOnStartOfFunctionDef(Scope *FnBodyScope, Declarator &D,\n                              MultiTemplateParamsArg TemplateParameterLists,\n                              SkipBodyInfo *SkipBody) {\n  assert(getCurFunctionDecl() == nullptr && \"Function parsing confused\");\n  assert(D.isFunctionDeclarator() && \"Not a function declarator!\");\n  Scope *ParentScope = FnBodyScope->getParent();\n\n  // Check if we are in an `omp begin/end declare variant` scope. If we are, and\n  // we define a non-templated function definition, we will create a declaration\n  // instead (=BaseFD), and emit the definition with a mangled name afterwards.\n  // The base function declaration will have the equivalent of an `omp declare\n  // variant` annotation which specifies the mangled definition as a\n  // specialization function under the OpenMP context defined as part of the\n  // `omp begin declare variant`.\n  SmallVector<FunctionDecl *, 4> Bases;\n  if (LangOpts.OpenMP && isInOpenMPDeclareVariantScope())\n    ActOnStartOfFunctionDefinitionInOpenMPDeclareVariantScope(\n        ParentScope, D, TemplateParameterLists, Bases);\n\n  D.setFunctionDefinitionKind(FunctionDefinitionKind::Definition);\n  Decl *DP = HandleDeclarator(ParentScope, D, TemplateParameterLists);\n  Decl *Dcl = ActOnStartOfFunctionDef(FnBodyScope, DP, SkipBody);\n\n  if (!Bases.empty())\n    ActOnFinishedFunctionDefinitionInOpenMPDeclareVariantScope(Dcl, Bases);\n\n  return Dcl;\n}\n\nvoid Sema::ActOnFinishInlineFunctionDef(FunctionDecl *D) {\n  Consumer.HandleInlineFunctionDefinition(D);\n}\n\nstatic bool\nShouldWarnAboutMissingPrototype(const FunctionDecl *FD,\n                                const FunctionDecl *&PossiblePrototype) {\n  // Don't warn about invalid declarations.\n  if (FD->isInvalidDecl())\n    return false;\n\n  // Or declarations that aren't global.\n  if (!FD->isGlobal())\n    return false;\n\n  // Don't warn about C++ member functions.\n  if (isa<CXXMethodDecl>(FD))\n    return false;\n\n  // Don't warn about 'main'.\n  if (isa<TranslationUnitDecl>(FD->getDeclContext()->getRedeclContext()))\n    if (IdentifierInfo *II = FD->getIdentifier())\n      if (II->isStr(\"main\") || II->isStr(\"efi_main\"))\n        return false;\n\n  // Don't warn about inline functions.\n  if (FD->isInlined())\n    return false;\n\n  // Don't warn about function templates.\n  if (FD->getDescribedFunctionTemplate())\n    return false;\n\n  // Don't warn about function template specializations.\n  if (FD->isFunctionTemplateSpecialization())\n    return false;\n\n  // Don't warn for OpenCL kernels.\n  if (FD->hasAttr<OpenCLKernelAttr>())\n    return false;\n\n  // Don't warn on explicitly deleted functions.\n  if (FD->isDeleted())\n    return false;\n\n  for (const FunctionDecl *Prev = FD->getPreviousDecl();\n       Prev; Prev = Prev->getPreviousDecl()) {\n    // Ignore any declarations that occur in function or method\n    // scope, because they aren't visible from the header.\n    if (Prev->getLexicalDeclContext()->isFunctionOrMethod())\n      continue;\n\n    PossiblePrototype = Prev;\n    return Prev->getType()->isFunctionNoProtoType();\n  }\n\n  return true;\n}\n\nvoid\nSema::CheckForFunctionRedefinition(FunctionDecl *FD,\n                                   const FunctionDecl *EffectiveDefinition,\n                                   SkipBodyInfo *SkipBody) {\n  const FunctionDecl *Definition = EffectiveDefinition;\n  if (!Definition &&\n      !FD->isDefined(Definition, /*CheckForPendingFriendDefinition*/ true))\n    return;\n\n  if (Definition->getFriendObjectKind() != Decl::FOK_None) {\n    if (FunctionDecl *OrigDef = Definition->getInstantiatedFromMemberFunction()) {\n      if (FunctionDecl *OrigFD = FD->getInstantiatedFromMemberFunction()) {\n        // A merged copy of the same function, instantiated as a member of\n        // the same class, is OK.\n        if (declaresSameEntity(OrigFD, OrigDef) &&\n            declaresSameEntity(cast<Decl>(Definition->getLexicalDeclContext()),\n                               cast<Decl>(FD->getLexicalDeclContext())))\n          return;\n      }\n    }\n  }\n\n  if (canRedefineFunction(Definition, getLangOpts()))\n    return;\n\n  // Don't emit an error when this is redefinition of a typo-corrected\n  // definition.\n  if (TypoCorrectedFunctionDefinitions.count(Definition))\n    return;\n\n  // If we don't have a visible definition of the function, and it's inline or\n  // a template, skip the new definition.\n  if (SkipBody && !hasVisibleDefinition(Definition) &&\n      (Definition->getFormalLinkage() == InternalLinkage ||\n       Definition->isInlined() ||\n       Definition->getDescribedFunctionTemplate() ||\n       Definition->getNumTemplateParameterLists())) {\n    SkipBody->ShouldSkip = true;\n    SkipBody->Previous = const_cast<FunctionDecl*>(Definition);\n    if (auto *TD = Definition->getDescribedFunctionTemplate())\n      makeMergedDefinitionVisible(TD);\n    makeMergedDefinitionVisible(const_cast<FunctionDecl*>(Definition));\n    return;\n  }\n\n  if (getLangOpts().GNUMode && Definition->isInlineSpecified() &&\n      Definition->getStorageClass() == SC_Extern)\n    Diag(FD->getLocation(), diag::err_redefinition_extern_inline)\n        << FD << getLangOpts().CPlusPlus;\n  else\n    Diag(FD->getLocation(), diag::err_redefinition) << FD;\n\n  Diag(Definition->getLocation(), diag::note_previous_definition);\n  FD->setInvalidDecl();\n}\n\nstatic void RebuildLambdaScopeInfo(CXXMethodDecl *CallOperator,\n                                   Sema &S) {\n  CXXRecordDecl *const LambdaClass = CallOperator->getParent();\n\n  LambdaScopeInfo *LSI = S.PushLambdaScope();\n  LSI->CallOperator = CallOperator;\n  LSI->Lambda = LambdaClass;\n  LSI->ReturnType = CallOperator->getReturnType();\n  const LambdaCaptureDefault LCD = LambdaClass->getLambdaCaptureDefault();\n\n  if (LCD == LCD_None)\n    LSI->ImpCaptureStyle = CapturingScopeInfo::ImpCap_None;\n  else if (LCD == LCD_ByCopy)\n    LSI->ImpCaptureStyle = CapturingScopeInfo::ImpCap_LambdaByval;\n  else if (LCD == LCD_ByRef)\n    LSI->ImpCaptureStyle = CapturingScopeInfo::ImpCap_LambdaByref;\n  DeclarationNameInfo DNI = CallOperator->getNameInfo();\n\n  LSI->IntroducerRange = DNI.getCXXOperatorNameRange();\n  LSI->Mutable = !CallOperator->isConst();\n\n  // Add the captures to the LSI so they can be noted as already\n  // captured within tryCaptureVar.\n  auto I = LambdaClass->field_begin();\n  for (const auto &C : LambdaClass->captures()) {\n    if (C.capturesVariable()) {\n      VarDecl *VD = C.getCapturedVar();\n      if (VD->isInitCapture())\n        S.CurrentInstantiationScope->InstantiatedLocal(VD, VD);\n      const bool ByRef = C.getCaptureKind() == LCK_ByRef;\n      LSI->addCapture(VD, /*IsBlock*/false, ByRef,\n          /*RefersToEnclosingVariableOrCapture*/true, C.getLocation(),\n          /*EllipsisLoc*/C.isPackExpansion()\n                         ? C.getEllipsisLoc() : SourceLocation(),\n          I->getType(), /*Invalid*/false);\n\n    } else if (C.capturesThis()) {\n      LSI->addThisCapture(/*Nested*/ false, C.getLocation(), I->getType(),\n                          C.getCaptureKind() == LCK_StarThis);\n    } else {\n      LSI->addVLATypeCapture(C.getLocation(), I->getCapturedVLAType(),\n                             I->getType());\n    }\n    ++I;\n  }\n}\n\nDecl *Sema::ActOnStartOfFunctionDef(Scope *FnBodyScope, Decl *D,\n                                    SkipBodyInfo *SkipBody) {\n  if (!D) {\n    // Parsing the function declaration failed in some way. Push on a fake scope\n    // anyway so we can try to parse the function body.\n    PushFunctionScope();\n    PushExpressionEvaluationContext(ExprEvalContexts.back().Context);\n    return D;\n  }\n\n  FunctionDecl *FD = nullptr;\n\n  if (FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D))\n    FD = FunTmpl->getTemplatedDecl();\n  else\n    FD = cast<FunctionDecl>(D);\n\n  // Do not push if it is a lambda because one is already pushed when building\n  // the lambda in ActOnStartOfLambdaDefinition().\n  if (!isLambdaCallOperator(FD))\n    PushExpressionEvaluationContext(\n        FD->isConsteval() ? ExpressionEvaluationContext::ConstantEvaluated\n                          : ExprEvalContexts.back().Context);\n\n  // Check for defining attributes before the check for redefinition.\n  if (const auto *Attr = FD->getAttr<AliasAttr>()) {\n    Diag(Attr->getLocation(), diag::err_alias_is_definition) << FD << 0;\n    FD->dropAttr<AliasAttr>();\n    FD->setInvalidDecl();\n  }\n  if (const auto *Attr = FD->getAttr<IFuncAttr>()) {\n    Diag(Attr->getLocation(), diag::err_alias_is_definition) << FD << 1;\n    FD->dropAttr<IFuncAttr>();\n    FD->setInvalidDecl();\n  }\n\n  if (auto *Ctor = dyn_cast<CXXConstructorDecl>(FD)) {\n    if (Ctor->getTemplateSpecializationKind() == TSK_ExplicitSpecialization &&\n        Ctor->isDefaultConstructor() &&\n        Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n      // If this is an MS ABI dllexport default constructor, instantiate any\n      // default arguments.\n      InstantiateDefaultCtorDefaultArgs(Ctor);\n    }\n  }\n\n  // See if this is a redefinition. If 'will have body' (or similar) is already\n  // set, then these checks were already performed when it was set.\n  if (!FD->willHaveBody() && !FD->isLateTemplateParsed() &&\n      !FD->isThisDeclarationInstantiatedFromAFriendDefinition()) {\n    CheckForFunctionRedefinition(FD, nullptr, SkipBody);\n\n    // If we're skipping the body, we're done. Don't enter the scope.\n    if (SkipBody && SkipBody->ShouldSkip)\n      return D;\n  }\n\n  // Mark this function as \"will have a body eventually\".  This lets users to\n  // call e.g. isInlineDefinitionExternallyVisible while we're still parsing\n  // this function.\n  FD->setWillHaveBody();\n\n  // If we are instantiating a generic lambda call operator, push\n  // a LambdaScopeInfo onto the function stack.  But use the information\n  // that's already been calculated (ActOnLambdaExpr) to prime the current\n  // LambdaScopeInfo.\n  // When the template operator is being specialized, the LambdaScopeInfo,\n  // has to be properly restored so that tryCaptureVariable doesn't try\n  // and capture any new variables. In addition when calculating potential\n  // captures during transformation of nested lambdas, it is necessary to\n  // have the LSI properly restored.\n  if (isGenericLambdaCallOperatorSpecialization(FD)) {\n    assert(inTemplateInstantiation() &&\n           \"There should be an active template instantiation on the stack \"\n           \"when instantiating a generic lambda!\");\n    RebuildLambdaScopeInfo(cast<CXXMethodDecl>(D), *this);\n  } else {\n    // Enter a new function scope\n    PushFunctionScope();\n  }\n\n  // Builtin functions cannot be defined.\n  if (unsigned BuiltinID = FD->getBuiltinID()) {\n    if (!Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID) &&\n        !Context.BuiltinInfo.isPredefinedRuntimeFunction(BuiltinID)) {\n      Diag(FD->getLocation(), diag::err_builtin_definition) << FD;\n      FD->setInvalidDecl();\n    }\n  }\n\n  // The return type of a function definition must be complete\n  // (C99 6.9.1p3, C++ [dcl.fct]p6).\n  QualType ResultType = FD->getReturnType();\n  if (!ResultType->isDependentType() && !ResultType->isVoidType() &&\n      !FD->isInvalidDecl() &&\n      RequireCompleteType(FD->getLocation(), ResultType,\n                          diag::err_func_def_incomplete_result))\n    FD->setInvalidDecl();\n\n  if (FnBodyScope)\n    PushDeclContext(FnBodyScope, FD);\n\n  // Check the validity of our function parameters\n  CheckParmsForFunctionDef(FD->parameters(),\n                           /*CheckParameterNames=*/true);\n\n  // Add non-parameter declarations already in the function to the current\n  // scope.\n  if (FnBodyScope) {\n    for (Decl *NPD : FD->decls()) {\n      auto *NonParmDecl = dyn_cast<NamedDecl>(NPD);\n      if (!NonParmDecl)\n        continue;\n      assert(!isa<ParmVarDecl>(NonParmDecl) &&\n             \"parameters should not be in newly created FD yet\");\n\n      // If the decl has a name, make it accessible in the current scope.\n      if (NonParmDecl->getDeclName())\n        PushOnScopeChains(NonParmDecl, FnBodyScope, /*AddToContext=*/false);\n\n      // Similarly, dive into enums and fish their constants out, making them\n      // accessible in this scope.\n      if (auto *ED = dyn_cast<EnumDecl>(NonParmDecl)) {\n        for (auto *EI : ED->enumerators())\n          PushOnScopeChains(EI, FnBodyScope, /*AddToContext=*/false);\n      }\n    }\n  }\n\n  // Introduce our parameters into the function scope\n  for (auto Param : FD->parameters()) {\n    Param->setOwningFunction(FD);\n\n    // If this has an identifier, add it to the scope stack.\n    if (Param->getIdentifier() && FnBodyScope) {\n      CheckShadow(FnBodyScope, Param);\n\n      PushOnScopeChains(Param, FnBodyScope);\n    }\n  }\n\n  // Ensure that the function's exception specification is instantiated.\n  if (const FunctionProtoType *FPT = FD->getType()->getAs<FunctionProtoType>())\n    ResolveExceptionSpec(D->getLocation(), FPT);\n\n  // dllimport cannot be applied to non-inline function definitions.\n  if (FD->hasAttr<DLLImportAttr>() && !FD->isInlined() &&\n      !FD->isTemplateInstantiation()) {\n    assert(!FD->hasAttr<DLLExportAttr>());\n    Diag(FD->getLocation(), diag::err_attribute_dllimport_function_definition);\n    FD->setInvalidDecl();\n    return D;\n  }\n  // We want to attach documentation to original Decl (which might be\n  // a function template).\n  ActOnDocumentableDecl(D);\n  if (getCurLexicalContext()->isObjCContainer() &&\n      getCurLexicalContext()->getDeclKind() != Decl::ObjCCategoryImpl &&\n      getCurLexicalContext()->getDeclKind() != Decl::ObjCImplementation)\n    Diag(FD->getLocation(), diag::warn_function_def_in_objc_container);\n\n  return D;\n}\n\n/// Given the set of return statements within a function body,\n/// compute the variables that are subject to the named return value\n/// optimization.\n///\n/// Each of the variables that is subject to the named return value\n/// optimization will be marked as NRVO variables in the AST, and any\n/// return statement that has a marked NRVO variable as its NRVO candidate can\n/// use the named return value optimization.\n///\n/// This function applies a very simplistic algorithm for NRVO: if every return\n/// statement in the scope of a variable has the same NRVO candidate, that\n/// candidate is an NRVO variable.\nvoid Sema::computeNRVO(Stmt *Body, FunctionScopeInfo *Scope) {\n  ReturnStmt **Returns = Scope->Returns.data();\n\n  for (unsigned I = 0, E = Scope->Returns.size(); I != E; ++I) {\n    if (const VarDecl *NRVOCandidate = Returns[I]->getNRVOCandidate()) {\n      if (!NRVOCandidate->isNRVOVariable())\n        Returns[I]->setNRVOCandidate(nullptr);\n    }\n  }\n}\n\nbool Sema::canDelayFunctionBody(const Declarator &D) {\n  // We can't delay parsing the body of a constexpr function template (yet).\n  if (D.getDeclSpec().hasConstexprSpecifier())\n    return false;\n\n  // We can't delay parsing the body of a function template with a deduced\n  // return type (yet).\n  if (D.getDeclSpec().hasAutoTypeSpec()) {\n    // If the placeholder introduces a non-deduced trailing return type,\n    // we can still delay parsing it.\n    if (D.getNumTypeObjects()) {\n      const auto &Outer = D.getTypeObject(D.getNumTypeObjects() - 1);\n      if (Outer.Kind == DeclaratorChunk::Function &&\n          Outer.Fun.hasTrailingReturnType()) {\n        QualType Ty = GetTypeFromParser(Outer.Fun.getTrailingReturnType());\n        return Ty.isNull() || !Ty->isUndeducedType();\n      }\n    }\n    return false;\n  }\n\n  return true;\n}\n\nbool Sema::canSkipFunctionBody(Decl *D) {\n  // We cannot skip the body of a function (or function template) which is\n  // constexpr, since we may need to evaluate its body in order to parse the\n  // rest of the file.\n  // We cannot skip the body of a function with an undeduced return type,\n  // because any callers of that function need to know the type.\n  if (const FunctionDecl *FD = D->getAsFunction()) {\n    if (FD->isConstexpr())\n      return false;\n    // We can't simply call Type::isUndeducedType here, because inside template\n    // auto can be deduced to a dependent type, which is not considered\n    // \"undeduced\".\n    if (FD->getReturnType()->getContainedDeducedType())\n      return false;\n  }\n  return Consumer.shouldSkipFunctionBody(D);\n}\n\nDecl *Sema::ActOnSkippedFunctionBody(Decl *Decl) {\n  if (!Decl)\n    return nullptr;\n  if (FunctionDecl *FD = Decl->getAsFunction())\n    FD->setHasSkippedBody();\n  else if (ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(Decl))\n    MD->setHasSkippedBody();\n  return Decl;\n}\n\nDecl *Sema::ActOnFinishFunctionBody(Decl *D, Stmt *BodyArg) {\n  return ActOnFinishFunctionBody(D, BodyArg, false);\n}\n\n/// RAII object that pops an ExpressionEvaluationContext when exiting a function\n/// body.\nclass ExitFunctionBodyRAII {\npublic:\n  ExitFunctionBodyRAII(Sema &S, bool IsLambda) : S(S), IsLambda(IsLambda) {}\n  ~ExitFunctionBodyRAII() {\n    if (!IsLambda)\n      S.PopExpressionEvaluationContext();\n  }\n\nprivate:\n  Sema &S;\n  bool IsLambda = false;\n};\n\nstatic void diagnoseImplicitlyRetainedSelf(Sema &S) {\n  llvm::DenseMap<const BlockDecl *, bool> EscapeInfo;\n\n  auto IsOrNestedInEscapingBlock = [&](const BlockDecl *BD) {\n    if (EscapeInfo.count(BD))\n      return EscapeInfo[BD];\n\n    bool R = false;\n    const BlockDecl *CurBD = BD;\n\n    do {\n      R = !CurBD->doesNotEscape();\n      if (R)\n        break;\n      CurBD = CurBD->getParent()->getInnermostBlockDecl();\n    } while (CurBD);\n\n    return EscapeInfo[BD] = R;\n  };\n\n  // If the location where 'self' is implicitly retained is inside a escaping\n  // block, emit a diagnostic.\n  for (const std::pair<SourceLocation, const BlockDecl *> &P :\n       S.ImplicitlyRetainedSelfLocs)\n    if (IsOrNestedInEscapingBlock(P.second))\n      S.Diag(P.first, diag::warn_implicitly_retains_self)\n          << FixItHint::CreateInsertion(P.first, \"self->\");\n}\n\nDecl *Sema::ActOnFinishFunctionBody(Decl *dcl, Stmt *Body,\n                                    bool IsInstantiation) {\n  FunctionScopeInfo *FSI = getCurFunction();\n  FunctionDecl *FD = dcl ? dcl->getAsFunction() : nullptr;\n\n  if (FSI->UsesFPIntrin && !FD->hasAttr<StrictFPAttr>())\n    FD->addAttr(StrictFPAttr::CreateImplicit(Context));\n\n  sema::AnalysisBasedWarnings::Policy WP = AnalysisWarnings.getDefaultPolicy();\n  sema::AnalysisBasedWarnings::Policy *ActivePolicy = nullptr;\n\n  if (getLangOpts().Coroutines && FSI->isCoroutine())\n    CheckCompletedCoroutineBody(FD, Body);\n\n  // Do not call PopExpressionEvaluationContext() if it is a lambda because one\n  // is already popped when finishing the lambda in BuildLambdaExpr(). This is\n  // meant to pop the context added in ActOnStartOfFunctionDef().\n  ExitFunctionBodyRAII ExitRAII(*this, isLambdaCallOperator(FD));\n\n  if (FD) {\n    FD->setBody(Body);\n    FD->setWillHaveBody(false);\n\n    if (getLangOpts().CPlusPlus14) {\n      if (!FD->isInvalidDecl() && Body && !FD->isDependentContext() &&\n          FD->getReturnType()->isUndeducedType()) {\n        // If the function has a deduced result type but contains no 'return'\n        // statements, the result type as written must be exactly 'auto', and\n        // the deduced result type is 'void'.\n        if (!FD->getReturnType()->getAs<AutoType>()) {\n          Diag(dcl->getLocation(), diag::err_auto_fn_no_return_but_not_auto)\n              << FD->getReturnType();\n          FD->setInvalidDecl();\n        } else {\n          // Substitute 'void' for the 'auto' in the type.\n          TypeLoc ResultType = getReturnTypeLoc(FD);\n          Context.adjustDeducedFunctionResultType(\n              FD, SubstAutoType(ResultType.getType(), Context.VoidTy));\n        }\n      }\n    } else if (getLangOpts().CPlusPlus11 && isLambdaCallOperator(FD)) {\n      // In C++11, we don't use 'auto' deduction rules for lambda call\n      // operators because we don't support return type deduction.\n      auto *LSI = getCurLambda();\n      if (LSI->HasImplicitReturnType) {\n        deduceClosureReturnType(*LSI);\n\n        // C++11 [expr.prim.lambda]p4:\n        //   [...] if there are no return statements in the compound-statement\n        //   [the deduced type is] the type void\n        QualType RetType =\n            LSI->ReturnType.isNull() ? Context.VoidTy : LSI->ReturnType;\n\n        // Update the return type to the deduced type.\n        const auto *Proto = FD->getType()->castAs<FunctionProtoType>();\n        FD->setType(Context.getFunctionType(RetType, Proto->getParamTypes(),\n                                            Proto->getExtProtoInfo()));\n      }\n    }\n\n    // If the function implicitly returns zero (like 'main') or is naked,\n    // don't complain about missing return statements.\n    if (FD->hasImplicitReturnZero() || FD->hasAttr<NakedAttr>())\n      WP.disableCheckFallThrough();\n\n    // MSVC permits the use of pure specifier (=0) on function definition,\n    // defined at class scope, warn about this non-standard construct.\n    if (getLangOpts().MicrosoftExt && FD->isPure() && !FD->isOutOfLine())\n      Diag(FD->getLocation(), diag::ext_pure_function_definition);\n\n    if (!FD->isInvalidDecl()) {\n      // Don't diagnose unused parameters of defaulted or deleted functions.\n      if (!FD->isDeleted() && !FD->isDefaulted() && !FD->hasSkippedBody())\n        DiagnoseUnusedParameters(FD->parameters());\n      DiagnoseSizeOfParametersAndReturnValue(FD->parameters(),\n                                             FD->getReturnType(), FD);\n\n      // If this is a structor, we need a vtable.\n      if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(FD))\n        MarkVTableUsed(FD->getLocation(), Constructor->getParent());\n      else if (CXXDestructorDecl *Destructor = dyn_cast<CXXDestructorDecl>(FD))\n        MarkVTableUsed(FD->getLocation(), Destructor->getParent());\n\n      // Try to apply the named return value optimization. We have to check\n      // if we can do this here because lambdas keep return statements around\n      // to deduce an implicit return type.\n      if (FD->getReturnType()->isRecordType() &&\n          (!getLangOpts().CPlusPlus || !FD->isDependentContext()))\n        computeNRVO(Body, FSI);\n    }\n\n    // GNU warning -Wmissing-prototypes:\n    //   Warn if a global function is defined without a previous\n    //   prototype declaration. This warning is issued even if the\n    //   definition itself provides a prototype. The aim is to detect\n    //   global functions that fail to be declared in header files.\n    const FunctionDecl *PossiblePrototype = nullptr;\n    if (ShouldWarnAboutMissingPrototype(FD, PossiblePrototype)) {\n      Diag(FD->getLocation(), diag::warn_missing_prototype) << FD;\n\n      if (PossiblePrototype) {\n        // We found a declaration that is not a prototype,\n        // but that could be a zero-parameter prototype\n        if (TypeSourceInfo *TI = PossiblePrototype->getTypeSourceInfo()) {\n          TypeLoc TL = TI->getTypeLoc();\n          if (FunctionNoProtoTypeLoc FTL = TL.getAs<FunctionNoProtoTypeLoc>())\n            Diag(PossiblePrototype->getLocation(),\n                 diag::note_declaration_not_a_prototype)\n                << (FD->getNumParams() != 0)\n                << (FD->getNumParams() == 0\n                        ? FixItHint::CreateInsertion(FTL.getRParenLoc(), \"void\")\n                        : FixItHint{});\n        }\n      } else {\n        // Returns true if the token beginning at this Loc is `const`.\n        auto isLocAtConst = [&](SourceLocation Loc, const SourceManager &SM,\n                                const LangOptions &LangOpts) {\n          std::pair<FileID, unsigned> LocInfo = SM.getDecomposedLoc(Loc);\n          if (LocInfo.first.isInvalid())\n            return false;\n\n          bool Invalid = false;\n          StringRef Buffer = SM.getBufferData(LocInfo.first, &Invalid);\n          if (Invalid)\n            return false;\n\n          if (LocInfo.second > Buffer.size())\n            return false;\n\n          const char *LexStart = Buffer.data() + LocInfo.second;\n          StringRef StartTok(LexStart, Buffer.size() - LocInfo.second);\n\n          return StartTok.consume_front(\"const\") &&\n                 (StartTok.empty() || isWhitespace(StartTok[0]) ||\n                  StartTok.startswith(\"/*\") || StartTok.startswith(\"//\"));\n        };\n\n        auto findBeginLoc = [&]() {\n          // If the return type has `const` qualifier, we want to insert\n          // `static` before `const` (and not before the typename).\n          if ((FD->getReturnType()->isAnyPointerType() &&\n               FD->getReturnType()->getPointeeType().isConstQualified()) ||\n              FD->getReturnType().isConstQualified()) {\n            // But only do this if we can determine where the `const` is.\n\n            if (isLocAtConst(FD->getBeginLoc(), getSourceManager(),\n                             getLangOpts()))\n\n              return FD->getBeginLoc();\n          }\n          return FD->getTypeSpecStartLoc();\n        };\n        Diag(FD->getTypeSpecStartLoc(), diag::note_static_for_internal_linkage)\n            << /* function */ 1\n            << (FD->getStorageClass() == SC_None\n                    ? FixItHint::CreateInsertion(findBeginLoc(), \"static \")\n                    : FixItHint{});\n      }\n\n      // GNU warning -Wstrict-prototypes\n      //   Warn if K&R function is defined without a previous declaration.\n      //   This warning is issued only if the definition itself does not provide\n      //   a prototype. Only K&R definitions do not provide a prototype.\n      if (!FD->hasWrittenPrototype()) {\n        TypeSourceInfo *TI = FD->getTypeSourceInfo();\n        TypeLoc TL = TI->getTypeLoc();\n        FunctionTypeLoc FTL = TL.getAsAdjusted<FunctionTypeLoc>();\n        Diag(FTL.getLParenLoc(), diag::warn_strict_prototypes) << 2;\n      }\n    }\n\n    // Warn on CPUDispatch with an actual body.\n    if (FD->isMultiVersion() && FD->hasAttr<CPUDispatchAttr>() && Body)\n      if (const auto *CmpndBody = dyn_cast<CompoundStmt>(Body))\n        if (!CmpndBody->body_empty())\n          Diag(CmpndBody->body_front()->getBeginLoc(),\n               diag::warn_dispatch_body_ignored);\n\n    if (auto *MD = dyn_cast<CXXMethodDecl>(FD)) {\n      const CXXMethodDecl *KeyFunction;\n      if (MD->isOutOfLine() && (MD = MD->getCanonicalDecl()) &&\n          MD->isVirtual() &&\n          (KeyFunction = Context.getCurrentKeyFunction(MD->getParent())) &&\n          MD == KeyFunction->getCanonicalDecl()) {\n        // Update the key-function state if necessary for this ABI.\n        if (FD->isInlined() &&\n            !Context.getTargetInfo().getCXXABI().canKeyFunctionBeInline()) {\n          Context.setNonKeyFunction(MD);\n\n          // If the newly-chosen key function is already defined, then we\n          // need to mark the vtable as used retroactively.\n          KeyFunction = Context.getCurrentKeyFunction(MD->getParent());\n          const FunctionDecl *Definition;\n          if (KeyFunction && KeyFunction->isDefined(Definition))\n            MarkVTableUsed(Definition->getLocation(), MD->getParent(), true);\n        } else {\n          // We just defined they key function; mark the vtable as used.\n          MarkVTableUsed(FD->getLocation(), MD->getParent(), true);\n        }\n      }\n    }\n\n    assert((FD == getCurFunctionDecl() || getCurLambda()->CallOperator == FD) &&\n           \"Function parsing confused\");\n  } else if (ObjCMethodDecl *MD = dyn_cast_or_null<ObjCMethodDecl>(dcl)) {\n    assert(MD == getCurMethodDecl() && \"Method parsing confused\");\n    MD->setBody(Body);\n    if (!MD->isInvalidDecl()) {\n      DiagnoseSizeOfParametersAndReturnValue(MD->parameters(),\n                                             MD->getReturnType(), MD);\n\n      if (Body)\n        computeNRVO(Body, FSI);\n    }\n    if (FSI->ObjCShouldCallSuper) {\n      Diag(MD->getEndLoc(), diag::warn_objc_missing_super_call)\n          << MD->getSelector().getAsString();\n      FSI->ObjCShouldCallSuper = false;\n    }\n    if (FSI->ObjCWarnForNoDesignatedInitChain) {\n      const ObjCMethodDecl *InitMethod = nullptr;\n      bool isDesignated =\n          MD->isDesignatedInitializerForTheInterface(&InitMethod);\n      assert(isDesignated && InitMethod);\n      (void)isDesignated;\n\n      auto superIsNSObject = [&](const ObjCMethodDecl *MD) {\n        auto IFace = MD->getClassInterface();\n        if (!IFace)\n          return false;\n        auto SuperD = IFace->getSuperClass();\n        if (!SuperD)\n          return false;\n        return SuperD->getIdentifier() ==\n            NSAPIObj->getNSClassId(NSAPI::ClassId_NSObject);\n      };\n      // Don't issue this warning for unavailable inits or direct subclasses\n      // of NSObject.\n      if (!MD->isUnavailable() && !superIsNSObject(MD)) {\n        Diag(MD->getLocation(),\n             diag::warn_objc_designated_init_missing_super_call);\n        Diag(InitMethod->getLocation(),\n             diag::note_objc_designated_init_marked_here);\n      }\n      FSI->ObjCWarnForNoDesignatedInitChain = false;\n    }\n    if (FSI->ObjCWarnForNoInitDelegation) {\n      // Don't issue this warning for unavaialable inits.\n      if (!MD->isUnavailable())\n        Diag(MD->getLocation(),\n             diag::warn_objc_secondary_init_missing_init_call);\n      FSI->ObjCWarnForNoInitDelegation = false;\n    }\n\n    diagnoseImplicitlyRetainedSelf(*this);\n  } else {\n    // Parsing the function declaration failed in some way. Pop the fake scope\n    // we pushed on.\n    PopFunctionScopeInfo(ActivePolicy, dcl);\n    return nullptr;\n  }\n\n  if (Body && FSI->HasPotentialAvailabilityViolations)\n    DiagnoseUnguardedAvailabilityViolations(dcl);\n\n  assert(!FSI->ObjCShouldCallSuper &&\n         \"This should only be set for ObjC methods, which should have been \"\n         \"handled in the block above.\");\n\n  // Verify and clean out per-function state.\n  if (Body && (!FD || !FD->isDefaulted())) {\n    // C++ constructors that have function-try-blocks can't have return\n    // statements in the handlers of that block. (C++ [except.handle]p14)\n    // Verify this.\n    if (FD && isa<CXXConstructorDecl>(FD) && isa<CXXTryStmt>(Body))\n      DiagnoseReturnInConstructorExceptionHandler(cast<CXXTryStmt>(Body));\n\n    // Verify that gotos and switch cases don't jump into scopes illegally.\n    if (FSI->NeedsScopeChecking() &&\n        !PP.isCodeCompletionEnabled())\n      DiagnoseInvalidJumps(Body);\n\n    if (CXXDestructorDecl *Destructor = dyn_cast<CXXDestructorDecl>(dcl)) {\n      if (!Destructor->getParent()->isDependentType())\n        CheckDestructor(Destructor);\n\n      MarkBaseAndMemberDestructorsReferenced(Destructor->getLocation(),\n                                             Destructor->getParent());\n    }\n\n    // If any errors have occurred, clear out any temporaries that may have\n    // been leftover. This ensures that these temporaries won't be picked up for\n    // deletion in some later function.\n    if (hasUncompilableErrorOccurred() ||\n        getDiagnostics().getSuppressAllDiagnostics()) {\n      DiscardCleanupsInEvaluationContext();\n    }\n    if (!hasUncompilableErrorOccurred() &&\n        !isa<FunctionTemplateDecl>(dcl)) {\n      // Since the body is valid, issue any analysis-based warnings that are\n      // enabled.\n      ActivePolicy = &WP;\n    }\n\n    if (!IsInstantiation && FD && FD->isConstexpr() && !FD->isInvalidDecl() &&\n        !CheckConstexprFunctionDefinition(FD, CheckConstexprKind::Diagnose))\n      FD->setInvalidDecl();\n\n    if (FD && FD->hasAttr<NakedAttr>()) {\n      for (const Stmt *S : Body->children()) {\n        // Allow local register variables without initializer as they don't\n        // require prologue.\n        bool RegisterVariables = false;\n        if (auto *DS = dyn_cast<DeclStmt>(S)) {\n          for (const auto *Decl : DS->decls()) {\n            if (const auto *Var = dyn_cast<VarDecl>(Decl)) {\n              RegisterVariables =\n                  Var->hasAttr<AsmLabelAttr>() && !Var->hasInit();\n              if (!RegisterVariables)\n                break;\n            }\n          }\n        }\n        if (RegisterVariables)\n          continue;\n        if (!isa<AsmStmt>(S) && !isa<NullStmt>(S)) {\n          Diag(S->getBeginLoc(), diag::err_non_asm_stmt_in_naked_function);\n          Diag(FD->getAttr<NakedAttr>()->getLocation(), diag::note_attribute);\n          FD->setInvalidDecl();\n          break;\n        }\n      }\n    }\n\n    assert(ExprCleanupObjects.size() ==\n               ExprEvalContexts.back().NumCleanupObjects &&\n           \"Leftover temporaries in function\");\n    assert(!Cleanup.exprNeedsCleanups() && \"Unaccounted cleanups in function\");\n    assert(MaybeODRUseExprs.empty() &&\n           \"Leftover expressions for odr-use checking\");\n  }\n\n  if (!IsInstantiation)\n    PopDeclContext();\n\n  PopFunctionScopeInfo(ActivePolicy, dcl);\n  // If any errors have occurred, clear out any temporaries that may have\n  // been leftover. This ensures that these temporaries won't be picked up for\n  // deletion in some later function.\n  if (hasUncompilableErrorOccurred()) {\n    DiscardCleanupsInEvaluationContext();\n  }\n\n  if (FD && (LangOpts.OpenMP || LangOpts.CUDA || LangOpts.SYCLIsDevice)) {\n    auto ES = getEmissionStatus(FD);\n    if (ES == Sema::FunctionEmissionStatus::Emitted ||\n        ES == Sema::FunctionEmissionStatus::Unknown)\n      DeclsToCheckForDeferredDiags.push_back(FD);\n  }\n\n  return dcl;\n}\n\n/// When we finish delayed parsing of an attribute, we must attach it to the\n/// relevant Decl.\nvoid Sema::ActOnFinishDelayedAttribute(Scope *S, Decl *D,\n                                       ParsedAttributes &Attrs) {\n  // Always attach attributes to the underlying decl.\n  if (TemplateDecl *TD = dyn_cast<TemplateDecl>(D))\n    D = TD->getTemplatedDecl();\n  ProcessDeclAttributeList(S, D, Attrs);\n\n  if (CXXMethodDecl *Method = dyn_cast_or_null<CXXMethodDecl>(D))\n    if (Method->isStatic())\n      checkThisInStaticMemberFunctionAttributes(Method);\n}\n\n/// ImplicitlyDefineFunction - An undeclared identifier was used in a function\n/// call, forming a call to an implicitly defined function (per C99 6.5.1p2).\nNamedDecl *Sema::ImplicitlyDefineFunction(SourceLocation Loc,\n                                          IdentifierInfo &II, Scope *S) {\n  // Find the scope in which the identifier is injected and the corresponding\n  // DeclContext.\n  // FIXME: C89 does not say what happens if there is no enclosing block scope.\n  // In that case, we inject the declaration into the translation unit scope\n  // instead.\n  Scope *BlockScope = S;\n  while (!BlockScope->isCompoundStmtScope() && BlockScope->getParent())\n    BlockScope = BlockScope->getParent();\n\n  Scope *ContextScope = BlockScope;\n  while (!ContextScope->getEntity())\n    ContextScope = ContextScope->getParent();\n  ContextRAII SavedContext(*this, ContextScope->getEntity());\n\n  // Before we produce a declaration for an implicitly defined\n  // function, see whether there was a locally-scoped declaration of\n  // this name as a function or variable. If so, use that\n  // (non-visible) declaration, and complain about it.\n  NamedDecl *ExternCPrev = findLocallyScopedExternCDecl(&II);\n  if (ExternCPrev) {\n    // We still need to inject the function into the enclosing block scope so\n    // that later (non-call) uses can see it.\n    PushOnScopeChains(ExternCPrev, BlockScope, /*AddToContext*/false);\n\n    // C89 footnote 38:\n    //   If in fact it is not defined as having type \"function returning int\",\n    //   the behavior is undefined.\n    if (!isa<FunctionDecl>(ExternCPrev) ||\n        !Context.typesAreCompatible(\n            cast<FunctionDecl>(ExternCPrev)->getType(),\n            Context.getFunctionNoProtoType(Context.IntTy))) {\n      Diag(Loc, diag::ext_use_out_of_scope_declaration)\n          << ExternCPrev << !getLangOpts().C99;\n      Diag(ExternCPrev->getLocation(), diag::note_previous_declaration);\n      return ExternCPrev;\n    }\n  }\n\n  // Extension in C99.  Legal in C90, but warn about it.\n  unsigned diag_id;\n  if (II.getName().startswith(\"__builtin_\"))\n    diag_id = diag::warn_builtin_unknown;\n  // OpenCL v2.0 s6.9.u - Implicit function declaration is not supported.\n  else if (getLangOpts().OpenCL)\n    diag_id = diag::err_opencl_implicit_function_decl;\n  else if (getLangOpts().C99)\n    diag_id = diag::ext_implicit_function_decl;\n  else\n    diag_id = diag::warn_implicit_function_decl;\n  Diag(Loc, diag_id) << &II;\n\n  // If we found a prior declaration of this function, don't bother building\n  // another one. We've already pushed that one into scope, so there's nothing\n  // more to do.\n  if (ExternCPrev)\n    return ExternCPrev;\n\n  // Because typo correction is expensive, only do it if the implicit\n  // function declaration is going to be treated as an error.\n  if (Diags.getDiagnosticLevel(diag_id, Loc) >= DiagnosticsEngine::Error) {\n    TypoCorrection Corrected;\n    DeclFilterCCC<FunctionDecl> CCC{};\n    if (S && (Corrected =\n                  CorrectTypo(DeclarationNameInfo(&II, Loc), LookupOrdinaryName,\n                              S, nullptr, CCC, CTK_NonError)))\n      diagnoseTypo(Corrected, PDiag(diag::note_function_suggestion),\n                   /*ErrorRecovery*/false);\n  }\n\n  // Set a Declarator for the implicit definition: int foo();\n  const char *Dummy;\n  AttributeFactory attrFactory;\n  DeclSpec DS(attrFactory);\n  unsigned DiagID;\n  bool Error = DS.SetTypeSpecType(DeclSpec::TST_int, Loc, Dummy, DiagID,\n                                  Context.getPrintingPolicy());\n  (void)Error; // Silence warning.\n  assert(!Error && \"Error setting up implicit decl!\");\n  SourceLocation NoLoc;\n  Declarator D(DS, DeclaratorContext::Block);\n  D.AddTypeInfo(DeclaratorChunk::getFunction(/*HasProto=*/false,\n                                             /*IsAmbiguous=*/false,\n                                             /*LParenLoc=*/NoLoc,\n                                             /*Params=*/nullptr,\n                                             /*NumParams=*/0,\n                                             /*EllipsisLoc=*/NoLoc,\n                                             /*RParenLoc=*/NoLoc,\n                                             /*RefQualifierIsLvalueRef=*/true,\n                                             /*RefQualifierLoc=*/NoLoc,\n                                             /*MutableLoc=*/NoLoc, EST_None,\n                                             /*ESpecRange=*/SourceRange(),\n                                             /*Exceptions=*/nullptr,\n                                             /*ExceptionRanges=*/nullptr,\n                                             /*NumExceptions=*/0,\n                                             /*NoexceptExpr=*/nullptr,\n                                             /*ExceptionSpecTokens=*/nullptr,\n                                             /*DeclsInPrototype=*/None, Loc,\n                                             Loc, D),\n                std::move(DS.getAttributes()), SourceLocation());\n  D.SetIdentifier(&II, Loc);\n\n  // Insert this function into the enclosing block scope.\n  FunctionDecl *FD = cast<FunctionDecl>(ActOnDeclarator(BlockScope, D));\n  FD->setImplicit();\n\n  AddKnownFunctionAttributes(FD);\n\n  return FD;\n}\n\n/// If this function is a C++ replaceable global allocation function\n/// (C++2a [basic.stc.dynamic.allocation], C++2a [new.delete]),\n/// adds any function attributes that we know a priori based on the standard.\n///\n/// We need to check for duplicate attributes both here and where user-written\n/// attributes are applied to declarations.\nvoid Sema::AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(\n    FunctionDecl *FD) {\n  if (FD->isInvalidDecl())\n    return;\n\n  if (FD->getDeclName().getCXXOverloadedOperator() != OO_New &&\n      FD->getDeclName().getCXXOverloadedOperator() != OO_Array_New)\n    return;\n\n  Optional<unsigned> AlignmentParam;\n  bool IsNothrow = false;\n  if (!FD->isReplaceableGlobalAllocationFunction(&AlignmentParam, &IsNothrow))\n    return;\n\n  // C++2a [basic.stc.dynamic.allocation]p4:\n  //   An allocation function that has a non-throwing exception specification\n  //   indicates failure by returning a null pointer value. Any other allocation\n  //   function never returns a null pointer value and indicates failure only by\n  //   throwing an exception [...]\n  if (!IsNothrow && !FD->hasAttr<ReturnsNonNullAttr>())\n    FD->addAttr(ReturnsNonNullAttr::CreateImplicit(Context, FD->getLocation()));\n\n  // C++2a [basic.stc.dynamic.allocation]p2:\n  //   An allocation function attempts to allocate the requested amount of\n  //   storage. [...] If the request succeeds, the value returned by a\n  //   replaceable allocation function is a [...] pointer value p0 different\n  //   from any previously returned value p1 [...]\n  //\n  // However, this particular information is being added in codegen,\n  // because there is an opt-out switch for it (-fno-assume-sane-operator-new)\n\n  // C++2a [basic.stc.dynamic.allocation]p2:\n  //   An allocation function attempts to allocate the requested amount of\n  //   storage. If it is successful, it returns the address of the start of a\n  //   block of storage whose length in bytes is at least as large as the\n  //   requested size.\n  if (!FD->hasAttr<AllocSizeAttr>()) {\n    FD->addAttr(AllocSizeAttr::CreateImplicit(\n        Context, /*ElemSizeParam=*/ParamIdx(1, FD),\n        /*NumElemsParam=*/ParamIdx(), FD->getLocation()));\n  }\n\n  // C++2a [basic.stc.dynamic.allocation]p3:\n  //   For an allocation function [...], the pointer returned on a successful\n  //   call shall represent the address of storage that is aligned as follows:\n  //   (3.1) If the allocation function takes an argument of type\n  //         std\u200b::\u200balign_\u00adval_\u00adt, the storage will have the alignment\n  //         specified by the value of this argument.\n  if (AlignmentParam.hasValue() && !FD->hasAttr<AllocAlignAttr>()) {\n    FD->addAttr(AllocAlignAttr::CreateImplicit(\n        Context, ParamIdx(AlignmentParam.getValue(), FD), FD->getLocation()));\n  }\n\n  // FIXME:\n  // C++2a [basic.stc.dynamic.allocation]p3:\n  //   For an allocation function [...], the pointer returned on a successful\n  //   call shall represent the address of storage that is aligned as follows:\n  //   (3.2) Otherwise, if the allocation function is named operator new[],\n  //         the storage is aligned for any object that does not have\n  //         new-extended alignment ([basic.align]) and is no larger than the\n  //         requested size.\n  //   (3.3) Otherwise, the storage is aligned for any object that does not\n  //         have new-extended alignment and is of the requested size.\n}\n\n/// Adds any function attributes that we know a priori based on\n/// the declaration of this function.\n///\n/// These attributes can apply both to implicitly-declared builtins\n/// (like __builtin___printf_chk) or to library-declared functions\n/// like NSLog or printf.\n///\n/// We need to check for duplicate attributes both here and where user-written\n/// attributes are applied to declarations.\nvoid Sema::AddKnownFunctionAttributes(FunctionDecl *FD) {\n  if (FD->isInvalidDecl())\n    return;\n\n  // If this is a built-in function, map its builtin attributes to\n  // actual attributes.\n  if (unsigned BuiltinID = FD->getBuiltinID()) {\n    // Handle printf-formatting attributes.\n    unsigned FormatIdx;\n    bool HasVAListArg;\n    if (Context.BuiltinInfo.isPrintfLike(BuiltinID, FormatIdx, HasVAListArg)) {\n      if (!FD->hasAttr<FormatAttr>()) {\n        const char *fmt = \"printf\";\n        unsigned int NumParams = FD->getNumParams();\n        if (FormatIdx < NumParams && // NumParams may be 0 (e.g. vfprintf)\n            FD->getParamDecl(FormatIdx)->getType()->isObjCObjectPointerType())\n          fmt = \"NSString\";\n        FD->addAttr(FormatAttr::CreateImplicit(Context,\n                                               &Context.Idents.get(fmt),\n                                               FormatIdx+1,\n                                               HasVAListArg ? 0 : FormatIdx+2,\n                                               FD->getLocation()));\n      }\n    }\n    if (Context.BuiltinInfo.isScanfLike(BuiltinID, FormatIdx,\n                                             HasVAListArg)) {\n     if (!FD->hasAttr<FormatAttr>())\n       FD->addAttr(FormatAttr::CreateImplicit(Context,\n                                              &Context.Idents.get(\"scanf\"),\n                                              FormatIdx+1,\n                                              HasVAListArg ? 0 : FormatIdx+2,\n                                              FD->getLocation()));\n    }\n\n    // Handle automatically recognized callbacks.\n    SmallVector<int, 4> Encoding;\n    if (!FD->hasAttr<CallbackAttr>() &&\n        Context.BuiltinInfo.performsCallback(BuiltinID, Encoding))\n      FD->addAttr(CallbackAttr::CreateImplicit(\n          Context, Encoding.data(), Encoding.size(), FD->getLocation()));\n\n    // Mark const if we don't care about errno and that is the only thing\n    // preventing the function from being const. This allows IRgen to use LLVM\n    // intrinsics for such functions.\n    if (!getLangOpts().MathErrno && !FD->hasAttr<ConstAttr>() &&\n        Context.BuiltinInfo.isConstWithoutErrno(BuiltinID))\n      FD->addAttr(ConstAttr::CreateImplicit(Context, FD->getLocation()));\n\n    // We make \"fma\" on some platforms const because we know it does not set\n    // errno in those environments even though it could set errno based on the\n    // C standard.\n    const llvm::Triple &Trip = Context.getTargetInfo().getTriple();\n    if ((Trip.isGNUEnvironment() || Trip.isAndroid() || Trip.isOSMSVCRT()) &&\n        !FD->hasAttr<ConstAttr>()) {\n      switch (BuiltinID) {\n      case Builtin::BI__builtin_fma:\n      case Builtin::BI__builtin_fmaf:\n      case Builtin::BI__builtin_fmal:\n      case Builtin::BIfma:\n      case Builtin::BIfmaf:\n      case Builtin::BIfmal:\n        FD->addAttr(ConstAttr::CreateImplicit(Context, FD->getLocation()));\n        break;\n      default:\n        break;\n      }\n    }\n\n    if (Context.BuiltinInfo.isReturnsTwice(BuiltinID) &&\n        !FD->hasAttr<ReturnsTwiceAttr>())\n      FD->addAttr(ReturnsTwiceAttr::CreateImplicit(Context,\n                                         FD->getLocation()));\n    if (Context.BuiltinInfo.isNoThrow(BuiltinID) && !FD->hasAttr<NoThrowAttr>())\n      FD->addAttr(NoThrowAttr::CreateImplicit(Context, FD->getLocation()));\n    if (Context.BuiltinInfo.isPure(BuiltinID) && !FD->hasAttr<PureAttr>())\n      FD->addAttr(PureAttr::CreateImplicit(Context, FD->getLocation()));\n    if (Context.BuiltinInfo.isConst(BuiltinID) && !FD->hasAttr<ConstAttr>())\n      FD->addAttr(ConstAttr::CreateImplicit(Context, FD->getLocation()));\n    if (getLangOpts().CUDA && Context.BuiltinInfo.isTSBuiltin(BuiltinID) &&\n        !FD->hasAttr<CUDADeviceAttr>() && !FD->hasAttr<CUDAHostAttr>()) {\n      // Add the appropriate attribute, depending on the CUDA compilation mode\n      // and which target the builtin belongs to. For example, during host\n      // compilation, aux builtins are __device__, while the rest are __host__.\n      if (getLangOpts().CUDAIsDevice !=\n          Context.BuiltinInfo.isAuxBuiltinID(BuiltinID))\n        FD->addAttr(CUDADeviceAttr::CreateImplicit(Context, FD->getLocation()));\n      else\n        FD->addAttr(CUDAHostAttr::CreateImplicit(Context, FD->getLocation()));\n    }\n  }\n\n  AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(FD);\n\n  // If C++ exceptions are enabled but we are told extern \"C\" functions cannot\n  // throw, add an implicit nothrow attribute to any extern \"C\" function we come\n  // across.\n  if (getLangOpts().CXXExceptions && getLangOpts().ExternCNoUnwind &&\n      FD->isExternC() && !FD->hasAttr<NoThrowAttr>()) {\n    const auto *FPT = FD->getType()->getAs<FunctionProtoType>();\n    if (!FPT || FPT->getExceptionSpecType() == EST_None)\n      FD->addAttr(NoThrowAttr::CreateImplicit(Context, FD->getLocation()));\n  }\n\n  IdentifierInfo *Name = FD->getIdentifier();\n  if (!Name)\n    return;\n  if ((!getLangOpts().CPlusPlus &&\n       FD->getDeclContext()->isTranslationUnit()) ||\n      (isa<LinkageSpecDecl>(FD->getDeclContext()) &&\n       cast<LinkageSpecDecl>(FD->getDeclContext())->getLanguage() ==\n       LinkageSpecDecl::lang_c)) {\n    // Okay: this could be a libc/libm/Objective-C function we know\n    // about.\n  } else\n    return;\n\n  if (Name->isStr(\"asprintf\") || Name->isStr(\"vasprintf\")) {\n    // FIXME: asprintf and vasprintf aren't C99 functions. Should they be\n    // target-specific builtins, perhaps?\n    if (!FD->hasAttr<FormatAttr>())\n      FD->addAttr(FormatAttr::CreateImplicit(Context,\n                                             &Context.Idents.get(\"printf\"), 2,\n                                             Name->isStr(\"vasprintf\") ? 0 : 3,\n                                             FD->getLocation()));\n  }\n\n  if (Name->isStr(\"__CFStringMakeConstantString\")) {\n    // We already have a __builtin___CFStringMakeConstantString,\n    // but builds that use -fno-constant-cfstrings don't go through that.\n    if (!FD->hasAttr<FormatArgAttr>())\n      FD->addAttr(FormatArgAttr::CreateImplicit(Context, ParamIdx(1, FD),\n                                                FD->getLocation()));\n  }\n}\n\nTypedefDecl *Sema::ParseTypedefDecl(Scope *S, Declarator &D, QualType T,\n                                    TypeSourceInfo *TInfo) {\n  assert(D.getIdentifier() && \"Wrong callback for declspec without declarator\");\n  assert(!T.isNull() && \"GetTypeForDeclarator() returned null type\");\n\n  if (!TInfo) {\n    assert(D.isInvalidType() && \"no declarator info for valid type\");\n    TInfo = Context.getTrivialTypeSourceInfo(T);\n  }\n\n  // Scope manipulation handled by caller.\n  TypedefDecl *NewTD =\n      TypedefDecl::Create(Context, CurContext, D.getBeginLoc(),\n                          D.getIdentifierLoc(), D.getIdentifier(), TInfo);\n\n  // Bail out immediately if we have an invalid declaration.\n  if (D.isInvalidType()) {\n    NewTD->setInvalidDecl();\n    return NewTD;\n  }\n\n  if (D.getDeclSpec().isModulePrivateSpecified()) {\n    if (CurContext->isFunctionOrMethod())\n      Diag(NewTD->getLocation(), diag::err_module_private_local)\n          << 2 << NewTD\n          << SourceRange(D.getDeclSpec().getModulePrivateSpecLoc())\n          << FixItHint::CreateRemoval(\n                 D.getDeclSpec().getModulePrivateSpecLoc());\n    else\n      NewTD->setModulePrivate();\n  }\n\n  // C++ [dcl.typedef]p8:\n  //   If the typedef declaration defines an unnamed class (or\n  //   enum), the first typedef-name declared by the declaration\n  //   to be that class type (or enum type) is used to denote the\n  //   class type (or enum type) for linkage purposes only.\n  // We need to check whether the type was declared in the declaration.\n  switch (D.getDeclSpec().getTypeSpecType()) {\n  case TST_enum:\n  case TST_struct:\n  case TST_interface:\n  case TST_union:\n  case TST_class: {\n    TagDecl *tagFromDeclSpec = cast<TagDecl>(D.getDeclSpec().getRepAsDecl());\n    setTagNameForLinkagePurposes(tagFromDeclSpec, NewTD);\n    break;\n  }\n\n  default:\n    break;\n  }\n\n  return NewTD;\n}\n\n/// Check that this is a valid underlying type for an enum declaration.\nbool Sema::CheckEnumUnderlyingType(TypeSourceInfo *TI) {\n  SourceLocation UnderlyingLoc = TI->getTypeLoc().getBeginLoc();\n  QualType T = TI->getType();\n\n  if (T->isDependentType())\n    return false;\n\n  // This doesn't use 'isIntegralType' despite the error message mentioning\n  // integral type because isIntegralType would also allow enum types in C.\n  if (const BuiltinType *BT = T->getAs<BuiltinType>())\n    if (BT->isInteger())\n      return false;\n\n  if (T->isExtIntType())\n    return false;\n\n  return Diag(UnderlyingLoc, diag::err_enum_invalid_underlying) << T;\n}\n\n/// Check whether this is a valid redeclaration of a previous enumeration.\n/// \\return true if the redeclaration was invalid.\nbool Sema::CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,\n                                  QualType EnumUnderlyingTy, bool IsFixed,\n                                  const EnumDecl *Prev) {\n  if (IsScoped != Prev->isScoped()) {\n    Diag(EnumLoc, diag::err_enum_redeclare_scoped_mismatch)\n      << Prev->isScoped();\n    Diag(Prev->getLocation(), diag::note_previous_declaration);\n    return true;\n  }\n\n  if (IsFixed && Prev->isFixed()) {\n    if (!EnumUnderlyingTy->isDependentType() &&\n        !Prev->getIntegerType()->isDependentType() &&\n        !Context.hasSameUnqualifiedType(EnumUnderlyingTy,\n                                        Prev->getIntegerType())) {\n      // TODO: Highlight the underlying type of the redeclaration.\n      Diag(EnumLoc, diag::err_enum_redeclare_type_mismatch)\n        << EnumUnderlyingTy << Prev->getIntegerType();\n      Diag(Prev->getLocation(), diag::note_previous_declaration)\n          << Prev->getIntegerTypeRange();\n      return true;\n    }\n  } else if (IsFixed != Prev->isFixed()) {\n    Diag(EnumLoc, diag::err_enum_redeclare_fixed_mismatch)\n      << Prev->isFixed();\n    Diag(Prev->getLocation(), diag::note_previous_declaration);\n    return true;\n  }\n\n  return false;\n}\n\n/// Get diagnostic %select index for tag kind for\n/// redeclaration diagnostic message.\n/// WARNING: Indexes apply to particular diagnostics only!\n///\n/// \\returns diagnostic %select index.\nstatic unsigned getRedeclDiagFromTagKind(TagTypeKind Tag) {\n  switch (Tag) {\n  case TTK_Struct: return 0;\n  case TTK_Interface: return 1;\n  case TTK_Class:  return 2;\n  default: llvm_unreachable(\"Invalid tag kind for redecl diagnostic!\");\n  }\n}\n\n/// Determine if tag kind is a class-key compatible with\n/// class for redeclaration (class, struct, or __interface).\n///\n/// \\returns true iff the tag kind is compatible.\nstatic bool isClassCompatTagKind(TagTypeKind Tag)\n{\n  return Tag == TTK_Struct || Tag == TTK_Class || Tag == TTK_Interface;\n}\n\nSema::NonTagKind Sema::getNonTagTypeDeclKind(const Decl *PrevDecl,\n                                             TagTypeKind TTK) {\n  if (isa<TypedefDecl>(PrevDecl))\n    return NTK_Typedef;\n  else if (isa<TypeAliasDecl>(PrevDecl))\n    return NTK_TypeAlias;\n  else if (isa<ClassTemplateDecl>(PrevDecl))\n    return NTK_Template;\n  else if (isa<TypeAliasTemplateDecl>(PrevDecl))\n    return NTK_TypeAliasTemplate;\n  else if (isa<TemplateTemplateParmDecl>(PrevDecl))\n    return NTK_TemplateTemplateArgument;\n  switch (TTK) {\n  case TTK_Struct:\n  case TTK_Interface:\n  case TTK_Class:\n    return getLangOpts().CPlusPlus ? NTK_NonClass : NTK_NonStruct;\n  case TTK_Union:\n    return NTK_NonUnion;\n  case TTK_Enum:\n    return NTK_NonEnum;\n  }\n  llvm_unreachable(\"invalid TTK\");\n}\n\n/// Determine whether a tag with a given kind is acceptable\n/// as a redeclaration of the given tag declaration.\n///\n/// \\returns true if the new tag kind is acceptable, false otherwise.\nbool Sema::isAcceptableTagRedeclaration(const TagDecl *Previous,\n                                        TagTypeKind NewTag, bool isDefinition,\n                                        SourceLocation NewTagLoc,\n                                        const IdentifierInfo *Name) {\n  // C++ [dcl.type.elab]p3:\n  //   The class-key or enum keyword present in the\n  //   elaborated-type-specifier shall agree in kind with the\n  //   declaration to which the name in the elaborated-type-specifier\n  //   refers. This rule also applies to the form of\n  //   elaborated-type-specifier that declares a class-name or\n  //   friend class since it can be construed as referring to the\n  //   definition of the class. Thus, in any\n  //   elaborated-type-specifier, the enum keyword shall be used to\n  //   refer to an enumeration (7.2), the union class-key shall be\n  //   used to refer to a union (clause 9), and either the class or\n  //   struct class-key shall be used to refer to a class (clause 9)\n  //   declared using the class or struct class-key.\n  TagTypeKind OldTag = Previous->getTagKind();\n  if (OldTag != NewTag &&\n      !(isClassCompatTagKind(OldTag) && isClassCompatTagKind(NewTag)))\n    return false;\n\n  // Tags are compatible, but we might still want to warn on mismatched tags.\n  // Non-class tags can't be mismatched at this point.\n  if (!isClassCompatTagKind(NewTag))\n    return true;\n\n  // Declarations for which -Wmismatched-tags is disabled are entirely ignored\n  // by our warning analysis. We don't want to warn about mismatches with (eg)\n  // declarations in system headers that are designed to be specialized, but if\n  // a user asks us to warn, we should warn if their code contains mismatched\n  // declarations.\n  auto IsIgnoredLoc = [&](SourceLocation Loc) {\n    return getDiagnostics().isIgnored(diag::warn_struct_class_tag_mismatch,\n                                      Loc);\n  };\n  if (IsIgnoredLoc(NewTagLoc))\n    return true;\n\n  auto IsIgnored = [&](const TagDecl *Tag) {\n    return IsIgnoredLoc(Tag->getLocation());\n  };\n  while (IsIgnored(Previous)) {\n    Previous = Previous->getPreviousDecl();\n    if (!Previous)\n      return true;\n    OldTag = Previous->getTagKind();\n  }\n\n  bool isTemplate = false;\n  if (const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(Previous))\n    isTemplate = Record->getDescribedClassTemplate();\n\n  if (inTemplateInstantiation()) {\n    if (OldTag != NewTag) {\n      // In a template instantiation, do not offer fix-its for tag mismatches\n      // since they usually mess up the template instead of fixing the problem.\n      Diag(NewTagLoc, diag::warn_struct_class_tag_mismatch)\n        << getRedeclDiagFromTagKind(NewTag) << isTemplate << Name\n        << getRedeclDiagFromTagKind(OldTag);\n      // FIXME: Note previous location?\n    }\n    return true;\n  }\n\n  if (isDefinition) {\n    // On definitions, check all previous tags and issue a fix-it for each\n    // one that doesn't match the current tag.\n    if (Previous->getDefinition()) {\n      // Don't suggest fix-its for redefinitions.\n      return true;\n    }\n\n    bool previousMismatch = false;\n    for (const TagDecl *I : Previous->redecls()) {\n      if (I->getTagKind() != NewTag) {\n        // Ignore previous declarations for which the warning was disabled.\n        if (IsIgnored(I))\n          continue;\n\n        if (!previousMismatch) {\n          previousMismatch = true;\n          Diag(NewTagLoc, diag::warn_struct_class_previous_tag_mismatch)\n            << getRedeclDiagFromTagKind(NewTag) << isTemplate << Name\n            << getRedeclDiagFromTagKind(I->getTagKind());\n        }\n        Diag(I->getInnerLocStart(), diag::note_struct_class_suggestion)\n          << getRedeclDiagFromTagKind(NewTag)\n          << FixItHint::CreateReplacement(I->getInnerLocStart(),\n               TypeWithKeyword::getTagTypeKindName(NewTag));\n      }\n    }\n    return true;\n  }\n\n  // Identify the prevailing tag kind: this is the kind of the definition (if\n  // there is a non-ignored definition), or otherwise the kind of the prior\n  // (non-ignored) declaration.\n  const TagDecl *PrevDef = Previous->getDefinition();\n  if (PrevDef && IsIgnored(PrevDef))\n    PrevDef = nullptr;\n  const TagDecl *Redecl = PrevDef ? PrevDef : Previous;\n  if (Redecl->getTagKind() != NewTag) {\n    Diag(NewTagLoc, diag::warn_struct_class_tag_mismatch)\n      << getRedeclDiagFromTagKind(NewTag) << isTemplate << Name\n      << getRedeclDiagFromTagKind(OldTag);\n    Diag(Redecl->getLocation(), diag::note_previous_use);\n\n    // If there is a previous definition, suggest a fix-it.\n    if (PrevDef) {\n      Diag(NewTagLoc, diag::note_struct_class_suggestion)\n        << getRedeclDiagFromTagKind(Redecl->getTagKind())\n        << FixItHint::CreateReplacement(SourceRange(NewTagLoc),\n             TypeWithKeyword::getTagTypeKindName(Redecl->getTagKind()));\n    }\n  }\n\n  return true;\n}\n\n/// Add a minimal nested name specifier fixit hint to allow lookup of a tag name\n/// from an outer enclosing namespace or file scope inside a friend declaration.\n/// This should provide the commented out code in the following snippet:\n///   namespace N {\n///     struct X;\n///     namespace M {\n///       struct Y { friend struct /*N::*/ X; };\n///     }\n///   }\nstatic FixItHint createFriendTagNNSFixIt(Sema &SemaRef, NamedDecl *ND, Scope *S,\n                                         SourceLocation NameLoc) {\n  // While the decl is in a namespace, do repeated lookup of that name and see\n  // if we get the same namespace back.  If we do not, continue until\n  // translation unit scope, at which point we have a fully qualified NNS.\n  SmallVector<IdentifierInfo *, 4> Namespaces;\n  DeclContext *DC = ND->getDeclContext()->getRedeclContext();\n  for (; !DC->isTranslationUnit(); DC = DC->getParent()) {\n    // This tag should be declared in a namespace, which can only be enclosed by\n    // other namespaces.  Bail if there's an anonymous namespace in the chain.\n    NamespaceDecl *Namespace = dyn_cast<NamespaceDecl>(DC);\n    if (!Namespace || Namespace->isAnonymousNamespace())\n      return FixItHint();\n    IdentifierInfo *II = Namespace->getIdentifier();\n    Namespaces.push_back(II);\n    NamedDecl *Lookup = SemaRef.LookupSingleName(\n        S, II, NameLoc, Sema::LookupNestedNameSpecifierName);\n    if (Lookup == Namespace)\n      break;\n  }\n\n  // Once we have all the namespaces, reverse them to go outermost first, and\n  // build an NNS.\n  SmallString<64> Insertion;\n  llvm::raw_svector_ostream OS(Insertion);\n  if (DC->isTranslationUnit())\n    OS << \"::\";\n  std::reverse(Namespaces.begin(), Namespaces.end());\n  for (auto *II : Namespaces)\n    OS << II->getName() << \"::\";\n  return FixItHint::CreateInsertion(NameLoc, Insertion);\n}\n\n/// Determine whether a tag originally declared in context \\p OldDC can\n/// be redeclared with an unqualified name in \\p NewDC (assuming name lookup\n/// found a declaration in \\p OldDC as a previous decl, perhaps through a\n/// using-declaration).\nstatic bool isAcceptableTagRedeclContext(Sema &S, DeclContext *OldDC,\n                                         DeclContext *NewDC) {\n  OldDC = OldDC->getRedeclContext();\n  NewDC = NewDC->getRedeclContext();\n\n  if (OldDC->Equals(NewDC))\n    return true;\n\n  // In MSVC mode, we allow a redeclaration if the contexts are related (either\n  // encloses the other).\n  if (S.getLangOpts().MSVCCompat &&\n      (OldDC->Encloses(NewDC) || NewDC->Encloses(OldDC)))\n    return true;\n\n  return false;\n}\n\n/// This is invoked when we see 'struct foo' or 'struct {'.  In the\n/// former case, Name will be non-null.  In the later case, Name will be null.\n/// TagSpec indicates what kind of tag this is. TUK indicates whether this is a\n/// reference/declaration/definition of a tag.\n///\n/// \\param IsTypeSpecifier \\c true if this is a type-specifier (or\n/// trailing-type-specifier) other than one in an alias-declaration.\n///\n/// \\param SkipBody If non-null, will be set to indicate if the caller should\n/// skip the definition of this tag and treat it as if it were a declaration.\nDecl *Sema::ActOnTag(Scope *S, unsigned TagSpec, TagUseKind TUK,\n                     SourceLocation KWLoc, CXXScopeSpec &SS,\n                     IdentifierInfo *Name, SourceLocation NameLoc,\n                     const ParsedAttributesView &Attrs, AccessSpecifier AS,\n                     SourceLocation ModulePrivateLoc,\n                     MultiTemplateParamsArg TemplateParameterLists,\n                     bool &OwnedDecl, bool &IsDependent,\n                     SourceLocation ScopedEnumKWLoc,\n                     bool ScopedEnumUsesClassTag, TypeResult UnderlyingType,\n                     bool IsTypeSpecifier, bool IsTemplateParamOrArg,\n                     SkipBodyInfo *SkipBody) {\n  // If this is not a definition, it must have a name.\n  IdentifierInfo *OrigName = Name;\n  assert((Name != nullptr || TUK == TUK_Definition) &&\n         \"Nameless record must be a definition!\");\n  assert(TemplateParameterLists.size() == 0 || TUK != TUK_Reference);\n\n  OwnedDecl = false;\n  TagTypeKind Kind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n  bool ScopedEnum = ScopedEnumKWLoc.isValid();\n\n  // FIXME: Check member specializations more carefully.\n  bool isMemberSpecialization = false;\n  bool Invalid = false;\n\n  // We only need to do this matching if we have template parameters\n  // or a scope specifier, which also conveniently avoids this work\n  // for non-C++ cases.\n  if (TemplateParameterLists.size() > 0 ||\n      (SS.isNotEmpty() && TUK != TUK_Reference)) {\n    if (TemplateParameterList *TemplateParams =\n            MatchTemplateParametersToScopeSpecifier(\n                KWLoc, NameLoc, SS, nullptr, TemplateParameterLists,\n                TUK == TUK_Friend, isMemberSpecialization, Invalid)) {\n      if (Kind == TTK_Enum) {\n        Diag(KWLoc, diag::err_enum_template);\n        return nullptr;\n      }\n\n      if (TemplateParams->size() > 0) {\n        // This is a declaration or definition of a class template (which may\n        // be a member of another template).\n\n        if (Invalid)\n          return nullptr;\n\n        OwnedDecl = false;\n        DeclResult Result = CheckClassTemplate(\n            S, TagSpec, TUK, KWLoc, SS, Name, NameLoc, Attrs, TemplateParams,\n            AS, ModulePrivateLoc,\n            /*FriendLoc*/ SourceLocation(), TemplateParameterLists.size() - 1,\n            TemplateParameterLists.data(), SkipBody);\n        return Result.get();\n      } else {\n        // The \"template<>\" header is extraneous.\n        Diag(TemplateParams->getTemplateLoc(), diag::err_template_tag_noparams)\n          << TypeWithKeyword::getTagTypeKindName(Kind) << Name;\n        isMemberSpecialization = true;\n      }\n    }\n\n    if (!TemplateParameterLists.empty() && isMemberSpecialization &&\n        CheckTemplateDeclScope(S, TemplateParameterLists.back()))\n      return nullptr;\n  }\n\n  // Figure out the underlying type if this a enum declaration. We need to do\n  // this early, because it's needed to detect if this is an incompatible\n  // redeclaration.\n  llvm::PointerUnion<const Type*, TypeSourceInfo*> EnumUnderlying;\n  bool IsFixed = !UnderlyingType.isUnset() || ScopedEnum;\n\n  if (Kind == TTK_Enum) {\n    if (UnderlyingType.isInvalid() || (!UnderlyingType.get() && ScopedEnum)) {\n      // No underlying type explicitly specified, or we failed to parse the\n      // type, default to int.\n      EnumUnderlying = Context.IntTy.getTypePtr();\n    } else if (UnderlyingType.get()) {\n      // C++0x 7.2p2: The type-specifier-seq of an enum-base shall name an\n      // integral type; any cv-qualification is ignored.\n      TypeSourceInfo *TI = nullptr;\n      GetTypeFromParser(UnderlyingType.get(), &TI);\n      EnumUnderlying = TI;\n\n      if (CheckEnumUnderlyingType(TI))\n        // Recover by falling back to int.\n        EnumUnderlying = Context.IntTy.getTypePtr();\n\n      if (DiagnoseUnexpandedParameterPack(TI->getTypeLoc().getBeginLoc(), TI,\n                                          UPPC_FixedUnderlyingType))\n        EnumUnderlying = Context.IntTy.getTypePtr();\n\n    } else if (Context.getTargetInfo().getTriple().isWindowsMSVCEnvironment()) {\n      // For MSVC ABI compatibility, unfixed enums must use an underlying type\n      // of 'int'. However, if this is an unfixed forward declaration, don't set\n      // the underlying type unless the user enables -fms-compatibility. This\n      // makes unfixed forward declared enums incomplete and is more conforming.\n      if (TUK == TUK_Definition || getLangOpts().MSVCCompat)\n        EnumUnderlying = Context.IntTy.getTypePtr();\n    }\n  }\n\n  DeclContext *SearchDC = CurContext;\n  DeclContext *DC = CurContext;\n  bool isStdBadAlloc = false;\n  bool isStdAlignValT = false;\n\n  RedeclarationKind Redecl = forRedeclarationInCurContext();\n  if (TUK == TUK_Friend || TUK == TUK_Reference)\n    Redecl = NotForRedeclaration;\n\n  /// Create a new tag decl in C/ObjC. Since the ODR-like semantics for ObjC/C\n  /// implemented asks for structural equivalence checking, the returned decl\n  /// here is passed back to the parser, allowing the tag body to be parsed.\n  auto createTagFromNewDecl = [&]() -> TagDecl * {\n    assert(!getLangOpts().CPlusPlus && \"not meant for C++ usage\");\n    // If there is an identifier, use the location of the identifier as the\n    // location of the decl, otherwise use the location of the struct/union\n    // keyword.\n    SourceLocation Loc = NameLoc.isValid() ? NameLoc : KWLoc;\n    TagDecl *New = nullptr;\n\n    if (Kind == TTK_Enum) {\n      New = EnumDecl::Create(Context, SearchDC, KWLoc, Loc, Name, nullptr,\n                             ScopedEnum, ScopedEnumUsesClassTag, IsFixed);\n      // If this is an undefined enum, bail.\n      if (TUK != TUK_Definition && !Invalid)\n        return nullptr;\n      if (EnumUnderlying) {\n        EnumDecl *ED = cast<EnumDecl>(New);\n        if (TypeSourceInfo *TI = EnumUnderlying.dyn_cast<TypeSourceInfo *>())\n          ED->setIntegerTypeSourceInfo(TI);\n        else\n          ED->setIntegerType(QualType(EnumUnderlying.get<const Type *>(), 0));\n        ED->setPromotionType(ED->getIntegerType());\n      }\n    } else { // struct/union\n      New = RecordDecl::Create(Context, Kind, SearchDC, KWLoc, Loc, Name,\n                               nullptr);\n    }\n\n    if (RecordDecl *RD = dyn_cast<RecordDecl>(New)) {\n      // Add alignment attributes if necessary; these attributes are checked\n      // when the ASTContext lays out the structure.\n      //\n      // It is important for implementing the correct semantics that this\n      // happen here (in ActOnTag). The #pragma pack stack is\n      // maintained as a result of parser callbacks which can occur at\n      // many points during the parsing of a struct declaration (because\n      // the #pragma tokens are effectively skipped over during the\n      // parsing of the struct).\n      if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip)) {\n        AddAlignmentAttributesForRecord(RD);\n        AddMsStructLayoutForRecord(RD);\n      }\n    }\n    New->setLexicalDeclContext(CurContext);\n    return New;\n  };\n\n  LookupResult Previous(*this, Name, NameLoc, LookupTagName, Redecl);\n  if (Name && SS.isNotEmpty()) {\n    // We have a nested-name tag ('struct foo::bar').\n\n    // Check for invalid 'foo::'.\n    if (SS.isInvalid()) {\n      Name = nullptr;\n      goto CreateNewDecl;\n    }\n\n    // If this is a friend or a reference to a class in a dependent\n    // context, don't try to make a decl for it.\n    if (TUK == TUK_Friend || TUK == TUK_Reference) {\n      DC = computeDeclContext(SS, false);\n      if (!DC) {\n        IsDependent = true;\n        return nullptr;\n      }\n    } else {\n      DC = computeDeclContext(SS, true);\n      if (!DC) {\n        Diag(SS.getRange().getBegin(), diag::err_dependent_nested_name_spec)\n          << SS.getRange();\n        return nullptr;\n      }\n    }\n\n    if (RequireCompleteDeclContext(SS, DC))\n      return nullptr;\n\n    SearchDC = DC;\n    // Look-up name inside 'foo::'.\n    LookupQualifiedName(Previous, DC);\n\n    if (Previous.isAmbiguous())\n      return nullptr;\n\n    if (Previous.empty()) {\n      // Name lookup did not find anything. However, if the\n      // nested-name-specifier refers to the current instantiation,\n      // and that current instantiation has any dependent base\n      // classes, we might find something at instantiation time: treat\n      // this as a dependent elaborated-type-specifier.\n      // But this only makes any sense for reference-like lookups.\n      if (Previous.wasNotFoundInCurrentInstantiation() &&\n          (TUK == TUK_Reference || TUK == TUK_Friend)) {\n        IsDependent = true;\n        return nullptr;\n      }\n\n      // A tag 'foo::bar' must already exist.\n      Diag(NameLoc, diag::err_not_tag_in_scope)\n        << Kind << Name << DC << SS.getRange();\n      Name = nullptr;\n      Invalid = true;\n      goto CreateNewDecl;\n    }\n  } else if (Name) {\n    // C++14 [class.mem]p14:\n    //   If T is the name of a class, then each of the following shall have a\n    //   name different from T:\n    //    -- every member of class T that is itself a type\n    if (TUK != TUK_Reference && TUK != TUK_Friend &&\n        DiagnoseClassNameShadow(SearchDC, DeclarationNameInfo(Name, NameLoc)))\n      return nullptr;\n\n    // If this is a named struct, check to see if there was a previous forward\n    // declaration or definition.\n    // FIXME: We're looking into outer scopes here, even when we\n    // shouldn't be. Doing so can result in ambiguities that we\n    // shouldn't be diagnosing.\n    LookupName(Previous, S);\n\n    // When declaring or defining a tag, ignore ambiguities introduced\n    // by types using'ed into this scope.\n    if (Previous.isAmbiguous() &&\n        (TUK == TUK_Definition || TUK == TUK_Declaration)) {\n      LookupResult::Filter F = Previous.makeFilter();\n      while (F.hasNext()) {\n        NamedDecl *ND = F.next();\n        if (!ND->getDeclContext()->getRedeclContext()->Equals(\n                SearchDC->getRedeclContext()))\n          F.erase();\n      }\n      F.done();\n    }\n\n    // C++11 [namespace.memdef]p3:\n    //   If the name in a friend declaration is neither qualified nor\n    //   a template-id and the declaration is a function or an\n    //   elaborated-type-specifier, the lookup to determine whether\n    //   the entity has been previously declared shall not consider\n    //   any scopes outside the innermost enclosing namespace.\n    //\n    // MSVC doesn't implement the above rule for types, so a friend tag\n    // declaration may be a redeclaration of a type declared in an enclosing\n    // scope.  They do implement this rule for friend functions.\n    //\n    // Does it matter that this should be by scope instead of by\n    // semantic context?\n    if (!Previous.empty() && TUK == TUK_Friend) {\n      DeclContext *EnclosingNS = SearchDC->getEnclosingNamespaceContext();\n      LookupResult::Filter F = Previous.makeFilter();\n      bool FriendSawTagOutsideEnclosingNamespace = false;\n      while (F.hasNext()) {\n        NamedDecl *ND = F.next();\n        DeclContext *DC = ND->getDeclContext()->getRedeclContext();\n        if (DC->isFileContext() &&\n            !EnclosingNS->Encloses(ND->getDeclContext())) {\n          if (getLangOpts().MSVCCompat)\n            FriendSawTagOutsideEnclosingNamespace = true;\n          else\n            F.erase();\n        }\n      }\n      F.done();\n\n      // Diagnose this MSVC extension in the easy case where lookup would have\n      // unambiguously found something outside the enclosing namespace.\n      if (Previous.isSingleResult() && FriendSawTagOutsideEnclosingNamespace) {\n        NamedDecl *ND = Previous.getFoundDecl();\n        Diag(NameLoc, diag::ext_friend_tag_redecl_outside_namespace)\n            << createFriendTagNNSFixIt(*this, ND, S, NameLoc);\n      }\n    }\n\n    // Note:  there used to be some attempt at recovery here.\n    if (Previous.isAmbiguous())\n      return nullptr;\n\n    if (!getLangOpts().CPlusPlus && TUK != TUK_Reference) {\n      // FIXME: This makes sure that we ignore the contexts associated\n      // with C structs, unions, and enums when looking for a matching\n      // tag declaration or definition. See the similar lookup tweak\n      // in Sema::LookupName; is there a better way to deal with this?\n      while (isa<RecordDecl>(SearchDC) || isa<EnumDecl>(SearchDC))\n        SearchDC = SearchDC->getParent();\n    }\n  }\n\n  if (Previous.isSingleResult() &&\n      Previous.getFoundDecl()->isTemplateParameter()) {\n    // Maybe we will complain about the shadowed template parameter.\n    DiagnoseTemplateParameterShadow(NameLoc, Previous.getFoundDecl());\n    // Just pretend that we didn't see the previous declaration.\n    Previous.clear();\n  }\n\n  if (getLangOpts().CPlusPlus && Name && DC && StdNamespace &&\n      DC->Equals(getStdNamespace())) {\n    if (Name->isStr(\"bad_alloc\")) {\n      // This is a declaration of or a reference to \"std::bad_alloc\".\n      isStdBadAlloc = true;\n\n      // If std::bad_alloc has been implicitly declared (but made invisible to\n      // name lookup), fill in this implicit declaration as the previous\n      // declaration, so that the declarations get chained appropriately.\n      if (Previous.empty() && StdBadAlloc)\n        Previous.addDecl(getStdBadAlloc());\n    } else if (Name->isStr(\"align_val_t\")) {\n      isStdAlignValT = true;\n      if (Previous.empty() && StdAlignValT)\n        Previous.addDecl(getStdAlignValT());\n    }\n  }\n\n  // If we didn't find a previous declaration, and this is a reference\n  // (or friend reference), move to the correct scope.  In C++, we\n  // also need to do a redeclaration lookup there, just in case\n  // there's a shadow friend decl.\n  if (Name && Previous.empty() &&\n      (TUK == TUK_Reference || TUK == TUK_Friend || IsTemplateParamOrArg)) {\n    if (Invalid) goto CreateNewDecl;\n    assert(SS.isEmpty());\n\n    if (TUK == TUK_Reference || IsTemplateParamOrArg) {\n      // C++ [basic.scope.pdecl]p5:\n      //   -- for an elaborated-type-specifier of the form\n      //\n      //          class-key identifier\n      //\n      //      if the elaborated-type-specifier is used in the\n      //      decl-specifier-seq or parameter-declaration-clause of a\n      //      function defined in namespace scope, the identifier is\n      //      declared as a class-name in the namespace that contains\n      //      the declaration; otherwise, except as a friend\n      //      declaration, the identifier is declared in the smallest\n      //      non-class, non-function-prototype scope that contains the\n      //      declaration.\n      //\n      // C99 6.7.2.3p8 has a similar (but not identical!) provision for\n      // C structs and unions.\n      //\n      // It is an error in C++ to declare (rather than define) an enum\n      // type, including via an elaborated type specifier.  We'll\n      // diagnose that later; for now, declare the enum in the same\n      // scope as we would have picked for any other tag type.\n      //\n      // GNU C also supports this behavior as part of its incomplete\n      // enum types extension, while GNU C++ does not.\n      //\n      // Find the context where we'll be declaring the tag.\n      // FIXME: We would like to maintain the current DeclContext as the\n      // lexical context,\n      SearchDC = getTagInjectionContext(SearchDC);\n\n      // Find the scope where we'll be declaring the tag.\n      S = getTagInjectionScope(S, getLangOpts());\n    } else {\n      assert(TUK == TUK_Friend);\n      // C++ [namespace.memdef]p3:\n      //   If a friend declaration in a non-local class first declares a\n      //   class or function, the friend class or function is a member of\n      //   the innermost enclosing namespace.\n      SearchDC = SearchDC->getEnclosingNamespaceContext();\n    }\n\n    // In C++, we need to do a redeclaration lookup to properly\n    // diagnose some problems.\n    // FIXME: redeclaration lookup is also used (with and without C++) to find a\n    // hidden declaration so that we don't get ambiguity errors when using a\n    // type declared by an elaborated-type-specifier.  In C that is not correct\n    // and we should instead merge compatible types found by lookup.\n    if (getLangOpts().CPlusPlus) {\n      // FIXME: This can perform qualified lookups into function contexts,\n      // which are meaningless.\n      Previous.setRedeclarationKind(forRedeclarationInCurContext());\n      LookupQualifiedName(Previous, SearchDC);\n    } else {\n      Previous.setRedeclarationKind(forRedeclarationInCurContext());\n      LookupName(Previous, S);\n    }\n  }\n\n  // If we have a known previous declaration to use, then use it.\n  if (Previous.empty() && SkipBody && SkipBody->Previous)\n    Previous.addDecl(SkipBody->Previous);\n\n  if (!Previous.empty()) {\n    NamedDecl *PrevDecl = Previous.getFoundDecl();\n    NamedDecl *DirectPrevDecl = Previous.getRepresentativeDecl();\n\n    // It's okay to have a tag decl in the same scope as a typedef\n    // which hides a tag decl in the same scope.  Finding this\n    // insanity with a redeclaration lookup can only actually happen\n    // in C++.\n    //\n    // This is also okay for elaborated-type-specifiers, which is\n    // technically forbidden by the current standard but which is\n    // okay according to the likely resolution of an open issue;\n    // see http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#407\n    if (getLangOpts().CPlusPlus) {\n      if (TypedefNameDecl *TD = dyn_cast<TypedefNameDecl>(PrevDecl)) {\n        if (const TagType *TT = TD->getUnderlyingType()->getAs<TagType>()) {\n          TagDecl *Tag = TT->getDecl();\n          if (Tag->getDeclName() == Name &&\n              Tag->getDeclContext()->getRedeclContext()\n                          ->Equals(TD->getDeclContext()->getRedeclContext())) {\n            PrevDecl = Tag;\n            Previous.clear();\n            Previous.addDecl(Tag);\n            Previous.resolveKind();\n          }\n        }\n      }\n    }\n\n    // If this is a redeclaration of a using shadow declaration, it must\n    // declare a tag in the same context. In MSVC mode, we allow a\n    // redefinition if either context is within the other.\n    if (auto *Shadow = dyn_cast<UsingShadowDecl>(DirectPrevDecl)) {\n      auto *OldTag = dyn_cast<TagDecl>(PrevDecl);\n      if (SS.isEmpty() && TUK != TUK_Reference && TUK != TUK_Friend &&\n          isDeclInScope(Shadow, SearchDC, S, isMemberSpecialization) &&\n          !(OldTag && isAcceptableTagRedeclContext(\n                          *this, OldTag->getDeclContext(), SearchDC))) {\n        Diag(KWLoc, diag::err_using_decl_conflict_reverse);\n        Diag(Shadow->getTargetDecl()->getLocation(),\n             diag::note_using_decl_target);\n        Diag(Shadow->getUsingDecl()->getLocation(), diag::note_using_decl)\n            << 0;\n        // Recover by ignoring the old declaration.\n        Previous.clear();\n        goto CreateNewDecl;\n      }\n    }\n\n    if (TagDecl *PrevTagDecl = dyn_cast<TagDecl>(PrevDecl)) {\n      // If this is a use of a previous tag, or if the tag is already declared\n      // in the same scope (so that the definition/declaration completes or\n      // rementions the tag), reuse the decl.\n      if (TUK == TUK_Reference || TUK == TUK_Friend ||\n          isDeclInScope(DirectPrevDecl, SearchDC, S,\n                        SS.isNotEmpty() || isMemberSpecialization)) {\n        // Make sure that this wasn't declared as an enum and now used as a\n        // struct or something similar.\n        if (!isAcceptableTagRedeclaration(PrevTagDecl, Kind,\n                                          TUK == TUK_Definition, KWLoc,\n                                          Name)) {\n          bool SafeToContinue\n            = (PrevTagDecl->getTagKind() != TTK_Enum &&\n               Kind != TTK_Enum);\n          if (SafeToContinue)\n            Diag(KWLoc, diag::err_use_with_wrong_tag)\n              << Name\n              << FixItHint::CreateReplacement(SourceRange(KWLoc),\n                                              PrevTagDecl->getKindName());\n          else\n            Diag(KWLoc, diag::err_use_with_wrong_tag) << Name;\n          Diag(PrevTagDecl->getLocation(), diag::note_previous_use);\n\n          if (SafeToContinue)\n            Kind = PrevTagDecl->getTagKind();\n          else {\n            // Recover by making this an anonymous redefinition.\n            Name = nullptr;\n            Previous.clear();\n            Invalid = true;\n          }\n        }\n\n        if (Kind == TTK_Enum && PrevTagDecl->getTagKind() == TTK_Enum) {\n          const EnumDecl *PrevEnum = cast<EnumDecl>(PrevTagDecl);\n          if (TUK == TUK_Reference || TUK == TUK_Friend)\n            return PrevTagDecl;\n\n          QualType EnumUnderlyingTy;\n          if (TypeSourceInfo *TI = EnumUnderlying.dyn_cast<TypeSourceInfo*>())\n            EnumUnderlyingTy = TI->getType().getUnqualifiedType();\n          else if (const Type *T = EnumUnderlying.dyn_cast<const Type*>())\n            EnumUnderlyingTy = QualType(T, 0);\n\n          // All conflicts with previous declarations are recovered by\n          // returning the previous declaration, unless this is a definition,\n          // in which case we want the caller to bail out.\n          if (CheckEnumRedeclaration(NameLoc.isValid() ? NameLoc : KWLoc,\n                                     ScopedEnum, EnumUnderlyingTy,\n                                     IsFixed, PrevEnum))\n            return TUK == TUK_Declaration ? PrevTagDecl : nullptr;\n        }\n\n        // C++11 [class.mem]p1:\n        //   A member shall not be declared twice in the member-specification,\n        //   except that a nested class or member class template can be declared\n        //   and then later defined.\n        if (TUK == TUK_Declaration && PrevDecl->isCXXClassMember() &&\n            S->isDeclScope(PrevDecl)) {\n          Diag(NameLoc, diag::ext_member_redeclared);\n          Diag(PrevTagDecl->getLocation(), diag::note_previous_declaration);\n        }\n\n        if (!Invalid) {\n          // If this is a use, just return the declaration we found, unless\n          // we have attributes.\n          if (TUK == TUK_Reference || TUK == TUK_Friend) {\n            if (!Attrs.empty()) {\n              // FIXME: Diagnose these attributes. For now, we create a new\n              // declaration to hold them.\n            } else if (TUK == TUK_Reference &&\n                       (PrevTagDecl->getFriendObjectKind() ==\n                            Decl::FOK_Undeclared ||\n                        PrevDecl->getOwningModule() != getCurrentModule()) &&\n                       SS.isEmpty()) {\n              // This declaration is a reference to an existing entity, but\n              // has different visibility from that entity: it either makes\n              // a friend visible or it makes a type visible in a new module.\n              // In either case, create a new declaration. We only do this if\n              // the declaration would have meant the same thing if no prior\n              // declaration were found, that is, if it was found in the same\n              // scope where we would have injected a declaration.\n              if (!getTagInjectionContext(CurContext)->getRedeclContext()\n                       ->Equals(PrevDecl->getDeclContext()->getRedeclContext()))\n                return PrevTagDecl;\n              // This is in the injected scope, create a new declaration in\n              // that scope.\n              S = getTagInjectionScope(S, getLangOpts());\n            } else {\n              return PrevTagDecl;\n            }\n          }\n\n          // Diagnose attempts to redefine a tag.\n          if (TUK == TUK_Definition) {\n            if (NamedDecl *Def = PrevTagDecl->getDefinition()) {\n              // If we're defining a specialization and the previous definition\n              // is from an implicit instantiation, don't emit an error\n              // here; we'll catch this in the general case below.\n              bool IsExplicitSpecializationAfterInstantiation = false;\n              if (isMemberSpecialization) {\n                if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(Def))\n                  IsExplicitSpecializationAfterInstantiation =\n                    RD->getTemplateSpecializationKind() !=\n                    TSK_ExplicitSpecialization;\n                else if (EnumDecl *ED = dyn_cast<EnumDecl>(Def))\n                  IsExplicitSpecializationAfterInstantiation =\n                    ED->getTemplateSpecializationKind() !=\n                    TSK_ExplicitSpecialization;\n              }\n\n              // Note that clang allows ODR-like semantics for ObjC/C, i.e., do\n              // not keep more that one definition around (merge them). However,\n              // ensure the decl passes the structural compatibility check in\n              // C11 6.2.7/1 (or 6.1.2.6/1 in C89).\n              NamedDecl *Hidden = nullptr;\n              if (SkipBody && !hasVisibleDefinition(Def, &Hidden)) {\n                // There is a definition of this tag, but it is not visible. We\n                // explicitly make use of C++'s one definition rule here, and\n                // assume that this definition is identical to the hidden one\n                // we already have. Make the existing definition visible and\n                // use it in place of this one.\n                if (!getLangOpts().CPlusPlus) {\n                  // Postpone making the old definition visible until after we\n                  // complete parsing the new one and do the structural\n                  // comparison.\n                  SkipBody->CheckSameAsPrevious = true;\n                  SkipBody->New = createTagFromNewDecl();\n                  SkipBody->Previous = Def;\n                  return Def;\n                } else {\n                  SkipBody->ShouldSkip = true;\n                  SkipBody->Previous = Def;\n                  makeMergedDefinitionVisible(Hidden);\n                  // Carry on and handle it like a normal definition. We'll\n                  // skip starting the definitiion later.\n                }\n              } else if (!IsExplicitSpecializationAfterInstantiation) {\n                // A redeclaration in function prototype scope in C isn't\n                // visible elsewhere, so merely issue a warning.\n                if (!getLangOpts().CPlusPlus && S->containedInPrototypeScope())\n                  Diag(NameLoc, diag::warn_redefinition_in_param_list) << Name;\n                else\n                  Diag(NameLoc, diag::err_redefinition) << Name;\n                notePreviousDefinition(Def,\n                                       NameLoc.isValid() ? NameLoc : KWLoc);\n                // If this is a redefinition, recover by making this\n                // struct be anonymous, which will make any later\n                // references get the previous definition.\n                Name = nullptr;\n                Previous.clear();\n                Invalid = true;\n              }\n            } else {\n              // If the type is currently being defined, complain\n              // about a nested redefinition.\n              auto *TD = Context.getTagDeclType(PrevTagDecl)->getAsTagDecl();\n              if (TD->isBeingDefined()) {\n                Diag(NameLoc, diag::err_nested_redefinition) << Name;\n                Diag(PrevTagDecl->getLocation(),\n                     diag::note_previous_definition);\n                Name = nullptr;\n                Previous.clear();\n                Invalid = true;\n              }\n            }\n\n            // Okay, this is definition of a previously declared or referenced\n            // tag. We're going to create a new Decl for it.\n          }\n\n          // Okay, we're going to make a redeclaration.  If this is some kind\n          // of reference, make sure we build the redeclaration in the same DC\n          // as the original, and ignore the current access specifier.\n          if (TUK == TUK_Friend || TUK == TUK_Reference) {\n            SearchDC = PrevTagDecl->getDeclContext();\n            AS = AS_none;\n          }\n        }\n        // If we get here we have (another) forward declaration or we\n        // have a definition.  Just create a new decl.\n\n      } else {\n        // If we get here, this is a definition of a new tag type in a nested\n        // scope, e.g. \"struct foo; void bar() { struct foo; }\", just create a\n        // new decl/type.  We set PrevDecl to NULL so that the entities\n        // have distinct types.\n        Previous.clear();\n      }\n      // If we get here, we're going to create a new Decl. If PrevDecl\n      // is non-NULL, it's a definition of the tag declared by\n      // PrevDecl. If it's NULL, we have a new definition.\n\n    // Otherwise, PrevDecl is not a tag, but was found with tag\n    // lookup.  This is only actually possible in C++, where a few\n    // things like templates still live in the tag namespace.\n    } else {\n      // Use a better diagnostic if an elaborated-type-specifier\n      // found the wrong kind of type on the first\n      // (non-redeclaration) lookup.\n      if ((TUK == TUK_Reference || TUK == TUK_Friend) &&\n          !Previous.isForRedeclaration()) {\n        NonTagKind NTK = getNonTagTypeDeclKind(PrevDecl, Kind);\n        Diag(NameLoc, diag::err_tag_reference_non_tag) << PrevDecl << NTK\n                                                       << Kind;\n        Diag(PrevDecl->getLocation(), diag::note_declared_at);\n        Invalid = true;\n\n      // Otherwise, only diagnose if the declaration is in scope.\n      } else if (!isDeclInScope(DirectPrevDecl, SearchDC, S,\n                                SS.isNotEmpty() || isMemberSpecialization)) {\n        // do nothing\n\n      // Diagnose implicit declarations introduced by elaborated types.\n      } else if (TUK == TUK_Reference || TUK == TUK_Friend) {\n        NonTagKind NTK = getNonTagTypeDeclKind(PrevDecl, Kind);\n        Diag(NameLoc, diag::err_tag_reference_conflict) << NTK;\n        Diag(PrevDecl->getLocation(), diag::note_previous_decl) << PrevDecl;\n        Invalid = true;\n\n      // Otherwise it's a declaration.  Call out a particularly common\n      // case here.\n      } else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(PrevDecl)) {\n        unsigned Kind = 0;\n        if (isa<TypeAliasDecl>(PrevDecl)) Kind = 1;\n        Diag(NameLoc, diag::err_tag_definition_of_typedef)\n          << Name << Kind << TND->getUnderlyingType();\n        Diag(PrevDecl->getLocation(), diag::note_previous_decl) << PrevDecl;\n        Invalid = true;\n\n      // Otherwise, diagnose.\n      } else {\n        // The tag name clashes with something else in the target scope,\n        // issue an error and recover by making this tag be anonymous.\n        Diag(NameLoc, diag::err_redefinition_different_kind) << Name;\n        notePreviousDefinition(PrevDecl, NameLoc);\n        Name = nullptr;\n        Invalid = true;\n      }\n\n      // The existing declaration isn't relevant to us; we're in a\n      // new scope, so clear out the previous declaration.\n      Previous.clear();\n    }\n  }\n\nCreateNewDecl:\n\n  TagDecl *PrevDecl = nullptr;\n  if (Previous.isSingleResult())\n    PrevDecl = cast<TagDecl>(Previous.getFoundDecl());\n\n  // If there is an identifier, use the location of the identifier as the\n  // location of the decl, otherwise use the location of the struct/union\n  // keyword.\n  SourceLocation Loc = NameLoc.isValid() ? NameLoc : KWLoc;\n\n  // Otherwise, create a new declaration. If there is a previous\n  // declaration of the same entity, the two will be linked via\n  // PrevDecl.\n  TagDecl *New;\n\n  if (Kind == TTK_Enum) {\n    // FIXME: Tag decls should be chained to any simultaneous vardecls, e.g.:\n    // enum X { A, B, C } D;    D should chain to X.\n    New = EnumDecl::Create(Context, SearchDC, KWLoc, Loc, Name,\n                           cast_or_null<EnumDecl>(PrevDecl), ScopedEnum,\n                           ScopedEnumUsesClassTag, IsFixed);\n\n    if (isStdAlignValT && (!StdAlignValT || getStdAlignValT()->isImplicit()))\n      StdAlignValT = cast<EnumDecl>(New);\n\n    // If this is an undefined enum, warn.\n    if (TUK != TUK_Definition && !Invalid) {\n      TagDecl *Def;\n      if (IsFixed && cast<EnumDecl>(New)->isFixed()) {\n        // C++0x: 7.2p2: opaque-enum-declaration.\n        // Conflicts are diagnosed above. Do nothing.\n      }\n      else if (PrevDecl && (Def = cast<EnumDecl>(PrevDecl)->getDefinition())) {\n        Diag(Loc, diag::ext_forward_ref_enum_def)\n          << New;\n        Diag(Def->getLocation(), diag::note_previous_definition);\n      } else {\n        unsigned DiagID = diag::ext_forward_ref_enum;\n        if (getLangOpts().MSVCCompat)\n          DiagID = diag::ext_ms_forward_ref_enum;\n        else if (getLangOpts().CPlusPlus)\n          DiagID = diag::err_forward_ref_enum;\n        Diag(Loc, DiagID);\n      }\n    }\n\n    if (EnumUnderlying) {\n      EnumDecl *ED = cast<EnumDecl>(New);\n      if (TypeSourceInfo *TI = EnumUnderlying.dyn_cast<TypeSourceInfo*>())\n        ED->setIntegerTypeSourceInfo(TI);\n      else\n        ED->setIntegerType(QualType(EnumUnderlying.get<const Type*>(), 0));\n      ED->setPromotionType(ED->getIntegerType());\n      assert(ED->isComplete() && \"enum with type should be complete\");\n    }\n  } else {\n    // struct/union/class\n\n    // FIXME: Tag decls should be chained to any simultaneous vardecls, e.g.:\n    // struct X { int A; } D;    D should chain to X.\n    if (getLangOpts().CPlusPlus) {\n      // FIXME: Look for a way to use RecordDecl for simple structs.\n      New = CXXRecordDecl::Create(Context, Kind, SearchDC, KWLoc, Loc, Name,\n                                  cast_or_null<CXXRecordDecl>(PrevDecl));\n\n      if (isStdBadAlloc && (!StdBadAlloc || getStdBadAlloc()->isImplicit()))\n        StdBadAlloc = cast<CXXRecordDecl>(New);\n    } else\n      New = RecordDecl::Create(Context, Kind, SearchDC, KWLoc, Loc, Name,\n                               cast_or_null<RecordDecl>(PrevDecl));\n  }\n\n  // C++11 [dcl.type]p3:\n  //   A type-specifier-seq shall not define a class or enumeration [...].\n  if (getLangOpts().CPlusPlus && (IsTypeSpecifier || IsTemplateParamOrArg) &&\n      TUK == TUK_Definition) {\n    Diag(New->getLocation(), diag::err_type_defined_in_type_specifier)\n      << Context.getTagDeclType(New);\n    Invalid = true;\n  }\n\n  if (!Invalid && getLangOpts().CPlusPlus && TUK == TUK_Definition &&\n      DC->getDeclKind() == Decl::Enum) {\n    Diag(New->getLocation(), diag::err_type_defined_in_enum)\n      << Context.getTagDeclType(New);\n    Invalid = true;\n  }\n\n  // Maybe add qualifier info.\n  if (SS.isNotEmpty()) {\n    if (SS.isSet()) {\n      // If this is either a declaration or a definition, check the\n      // nested-name-specifier against the current context.\n      if ((TUK == TUK_Definition || TUK == TUK_Declaration) &&\n          diagnoseQualifiedDeclaration(SS, DC, OrigName, Loc,\n                                       isMemberSpecialization))\n        Invalid = true;\n\n      New->setQualifierInfo(SS.getWithLocInContext(Context));\n      if (TemplateParameterLists.size() > 0) {\n        New->setTemplateParameterListsInfo(Context, TemplateParameterLists);\n      }\n    }\n    else\n      Invalid = true;\n  }\n\n  if (RecordDecl *RD = dyn_cast<RecordDecl>(New)) {\n    // Add alignment attributes if necessary; these attributes are checked when\n    // the ASTContext lays out the structure.\n    //\n    // It is important for implementing the correct semantics that this\n    // happen here (in ActOnTag). The #pragma pack stack is\n    // maintained as a result of parser callbacks which can occur at\n    // many points during the parsing of a struct declaration (because\n    // the #pragma tokens are effectively skipped over during the\n    // parsing of the struct).\n    if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip)) {\n      AddAlignmentAttributesForRecord(RD);\n      AddMsStructLayoutForRecord(RD);\n    }\n  }\n\n  if (ModulePrivateLoc.isValid()) {\n    if (isMemberSpecialization)\n      Diag(New->getLocation(), diag::err_module_private_specialization)\n        << 2\n        << FixItHint::CreateRemoval(ModulePrivateLoc);\n    // __module_private__ does not apply to local classes. However, we only\n    // diagnose this as an error when the declaration specifiers are\n    // freestanding. Here, we just ignore the __module_private__.\n    else if (!SearchDC->isFunctionOrMethod())\n      New->setModulePrivate();\n  }\n\n  // If this is a specialization of a member class (of a class template),\n  // check the specialization.\n  if (isMemberSpecialization && CheckMemberSpecialization(New, Previous))\n    Invalid = true;\n\n  // If we're declaring or defining a tag in function prototype scope in C,\n  // note that this type can only be used within the function and add it to\n  // the list of decls to inject into the function definition scope.\n  if ((Name || Kind == TTK_Enum) &&\n      getNonFieldDeclScope(S)->isFunctionPrototypeScope()) {\n    if (getLangOpts().CPlusPlus) {\n      // C++ [dcl.fct]p6:\n      //   Types shall not be defined in return or parameter types.\n      if (TUK == TUK_Definition && !IsTypeSpecifier) {\n        Diag(Loc, diag::err_type_defined_in_param_type)\n            << Name;\n        Invalid = true;\n      }\n    } else if (!PrevDecl) {\n      Diag(Loc, diag::warn_decl_in_param_list) << Context.getTagDeclType(New);\n    }\n  }\n\n  if (Invalid)\n    New->setInvalidDecl();\n\n  // Set the lexical context. If the tag has a C++ scope specifier, the\n  // lexical context will be different from the semantic context.\n  New->setLexicalDeclContext(CurContext);\n\n  // Mark this as a friend decl if applicable.\n  // In Microsoft mode, a friend declaration also acts as a forward\n  // declaration so we always pass true to setObjectOfFriendDecl to make\n  // the tag name visible.\n  if (TUK == TUK_Friend)\n    New->setObjectOfFriendDecl(getLangOpts().MSVCCompat);\n\n  // Set the access specifier.\n  if (!Invalid && SearchDC->isRecord())\n    SetMemberAccessSpecifier(New, PrevDecl, AS);\n\n  if (PrevDecl)\n    CheckRedeclarationModuleOwnership(New, PrevDecl);\n\n  if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip))\n    New->startDefinition();\n\n  ProcessDeclAttributeList(S, New, Attrs);\n  AddPragmaAttributes(S, New);\n\n  // If this has an identifier, add it to the scope stack.\n  if (TUK == TUK_Friend) {\n    // We might be replacing an existing declaration in the lookup tables;\n    // if so, borrow its access specifier.\n    if (PrevDecl)\n      New->setAccess(PrevDecl->getAccess());\n\n    DeclContext *DC = New->getDeclContext()->getRedeclContext();\n    DC->makeDeclVisibleInContext(New);\n    if (Name) // can be null along some error paths\n      if (Scope *EnclosingScope = getScopeForDeclContext(S, DC))\n        PushOnScopeChains(New, EnclosingScope, /* AddToContext = */ false);\n  } else if (Name) {\n    S = getNonFieldDeclScope(S);\n    PushOnScopeChains(New, S, true);\n  } else {\n    CurContext->addDecl(New);\n  }\n\n  // If this is the C FILE type, notify the AST context.\n  if (IdentifierInfo *II = New->getIdentifier())\n    if (!New->isInvalidDecl() &&\n        New->getDeclContext()->getRedeclContext()->isTranslationUnit() &&\n        II->isStr(\"FILE\"))\n      Context.setFILEDecl(New);\n\n  if (PrevDecl)\n    mergeDeclAttributes(New, PrevDecl);\n\n  if (auto *CXXRD = dyn_cast<CXXRecordDecl>(New))\n    inferGslOwnerPointerAttribute(CXXRD);\n\n  // If there's a #pragma GCC visibility in scope, set the visibility of this\n  // record.\n  AddPushedVisibilityAttribute(New);\n\n  if (isMemberSpecialization && !New->isInvalidDecl())\n    CompleteMemberSpecialization(New, Previous);\n\n  OwnedDecl = true;\n  // In C++, don't return an invalid declaration. We can't recover well from\n  // the cases where we make the type anonymous.\n  if (Invalid && getLangOpts().CPlusPlus) {\n    if (New->isBeingDefined())\n      if (auto RD = dyn_cast<RecordDecl>(New))\n        RD->completeDefinition();\n    return nullptr;\n  } else if (SkipBody && SkipBody->ShouldSkip) {\n    return SkipBody->Previous;\n  } else {\n    return New;\n  }\n}\n\nvoid Sema::ActOnTagStartDefinition(Scope *S, Decl *TagD) {\n  AdjustDeclIfTemplate(TagD);\n  TagDecl *Tag = cast<TagDecl>(TagD);\n\n  // Enter the tag context.\n  PushDeclContext(S, Tag);\n\n  ActOnDocumentableDecl(TagD);\n\n  // If there's a #pragma GCC visibility in scope, set the visibility of this\n  // record.\n  AddPushedVisibilityAttribute(Tag);\n}\n\nbool Sema::ActOnDuplicateDefinition(DeclSpec &DS, Decl *Prev,\n                                    SkipBodyInfo &SkipBody) {\n  if (!hasStructuralCompatLayout(Prev, SkipBody.New))\n    return false;\n\n  // Make the previous decl visible.\n  makeMergedDefinitionVisible(SkipBody.Previous);\n  return true;\n}\n\nDecl *Sema::ActOnObjCContainerStartDefinition(Decl *IDecl) {\n  assert(isa<ObjCContainerDecl>(IDecl) &&\n         \"ActOnObjCContainerStartDefinition - Not ObjCContainerDecl\");\n  DeclContext *OCD = cast<DeclContext>(IDecl);\n  assert(OCD->getLexicalParent() == CurContext &&\n      \"The next DeclContext should be lexically contained in the current one.\");\n  CurContext = OCD;\n  return IDecl;\n}\n\nvoid Sema::ActOnStartCXXMemberDeclarations(Scope *S, Decl *TagD,\n                                           SourceLocation FinalLoc,\n                                           bool IsFinalSpelledSealed,\n                                           SourceLocation LBraceLoc) {\n  AdjustDeclIfTemplate(TagD);\n  CXXRecordDecl *Record = cast<CXXRecordDecl>(TagD);\n\n  FieldCollector->StartClass();\n\n  if (!Record->getIdentifier())\n    return;\n\n  if (FinalLoc.isValid())\n    Record->addAttr(FinalAttr::Create(\n        Context, FinalLoc, AttributeCommonInfo::AS_Keyword,\n        static_cast<FinalAttr::Spelling>(IsFinalSpelledSealed)));\n\n  // C++ [class]p2:\n  //   [...] The class-name is also inserted into the scope of the\n  //   class itself; this is known as the injected-class-name. For\n  //   purposes of access checking, the injected-class-name is treated\n  //   as if it were a public member name.\n  CXXRecordDecl *InjectedClassName = CXXRecordDecl::Create(\n      Context, Record->getTagKind(), CurContext, Record->getBeginLoc(),\n      Record->getLocation(), Record->getIdentifier(),\n      /*PrevDecl=*/nullptr,\n      /*DelayTypeCreation=*/true);\n  Context.getTypeDeclType(InjectedClassName, Record);\n  InjectedClassName->setImplicit();\n  InjectedClassName->setAccess(AS_public);\n  if (ClassTemplateDecl *Template = Record->getDescribedClassTemplate())\n      InjectedClassName->setDescribedClassTemplate(Template);\n  PushOnScopeChains(InjectedClassName, S);\n  assert(InjectedClassName->isInjectedClassName() &&\n         \"Broken injected-class-name\");\n}\n\nvoid Sema::ActOnTagFinishDefinition(Scope *S, Decl *TagD,\n                                    SourceRange BraceRange) {\n  AdjustDeclIfTemplate(TagD);\n  TagDecl *Tag = cast<TagDecl>(TagD);\n  Tag->setBraceRange(BraceRange);\n\n  // Make sure we \"complete\" the definition even it is invalid.\n  if (Tag->isBeingDefined()) {\n    assert(Tag->isInvalidDecl() && \"We should already have completed it\");\n    if (RecordDecl *RD = dyn_cast<RecordDecl>(Tag))\n      RD->completeDefinition();\n  }\n\n  if (isa<CXXRecordDecl>(Tag)) {\n    FieldCollector->FinishClass();\n  }\n\n  // Exit this scope of this tag's definition.\n  PopDeclContext();\n\n  if (getCurLexicalContext()->isObjCContainer() &&\n      Tag->getDeclContext()->isFileContext())\n    Tag->setTopLevelDeclInObjCContainer();\n\n  // Notify the consumer that we've defined a tag.\n  if (!Tag->isInvalidDecl())\n    Consumer.HandleTagDeclDefinition(Tag);\n}\n\nvoid Sema::ActOnObjCContainerFinishDefinition() {\n  // Exit this scope of this interface definition.\n  PopDeclContext();\n}\n\nvoid Sema::ActOnObjCTemporaryExitContainerContext(DeclContext *DC) {\n  assert(DC == CurContext && \"Mismatch of container contexts\");\n  OriginalLexicalContext = DC;\n  ActOnObjCContainerFinishDefinition();\n}\n\nvoid Sema::ActOnObjCReenterContainerContext(DeclContext *DC) {\n  ActOnObjCContainerStartDefinition(cast<Decl>(DC));\n  OriginalLexicalContext = nullptr;\n}\n\nvoid Sema::ActOnTagDefinitionError(Scope *S, Decl *TagD) {\n  AdjustDeclIfTemplate(TagD);\n  TagDecl *Tag = cast<TagDecl>(TagD);\n  Tag->setInvalidDecl();\n\n  // Make sure we \"complete\" the definition even it is invalid.\n  if (Tag->isBeingDefined()) {\n    if (RecordDecl *RD = dyn_cast<RecordDecl>(Tag))\n      RD->completeDefinition();\n  }\n\n  // We're undoing ActOnTagStartDefinition here, not\n  // ActOnStartCXXMemberDeclarations, so we don't have to mess with\n  // the FieldCollector.\n\n  PopDeclContext();\n}\n\n// Note that FieldName may be null for anonymous bitfields.\nExprResult Sema::VerifyBitField(SourceLocation FieldLoc,\n                                IdentifierInfo *FieldName,\n                                QualType FieldTy, bool IsMsStruct,\n                                Expr *BitWidth, bool *ZeroWidth) {\n  assert(BitWidth);\n  if (BitWidth->containsErrors())\n    return ExprError();\n\n  // Default to true; that shouldn't confuse checks for emptiness\n  if (ZeroWidth)\n    *ZeroWidth = true;\n\n  // C99 6.7.2.1p4 - verify the field type.\n  // C++ 9.6p3: A bit-field shall have integral or enumeration type.\n  if (!FieldTy->isDependentType() && !FieldTy->isIntegralOrEnumerationType()) {\n    // Handle incomplete and sizeless types with a specific error.\n    if (RequireCompleteSizedType(FieldLoc, FieldTy,\n                                 diag::err_field_incomplete_or_sizeless))\n      return ExprError();\n    if (FieldName)\n      return Diag(FieldLoc, diag::err_not_integral_type_bitfield)\n        << FieldName << FieldTy << BitWidth->getSourceRange();\n    return Diag(FieldLoc, diag::err_not_integral_type_anon_bitfield)\n      << FieldTy << BitWidth->getSourceRange();\n  } else if (DiagnoseUnexpandedParameterPack(const_cast<Expr *>(BitWidth),\n                                             UPPC_BitFieldWidth))\n    return ExprError();\n\n  // If the bit-width is type- or value-dependent, don't try to check\n  // it now.\n  if (BitWidth->isValueDependent() || BitWidth->isTypeDependent())\n    return BitWidth;\n\n  llvm::APSInt Value;\n  ExprResult ICE = VerifyIntegerConstantExpression(BitWidth, &Value, AllowFold);\n  if (ICE.isInvalid())\n    return ICE;\n  BitWidth = ICE.get();\n\n  if (Value != 0 && ZeroWidth)\n    *ZeroWidth = false;\n\n  // Zero-width bitfield is ok for anonymous field.\n  if (Value == 0 && FieldName)\n    return Diag(FieldLoc, diag::err_bitfield_has_zero_width) << FieldName;\n\n  if (Value.isSigned() && Value.isNegative()) {\n    if (FieldName)\n      return Diag(FieldLoc, diag::err_bitfield_has_negative_width)\n               << FieldName << Value.toString(10);\n    return Diag(FieldLoc, diag::err_anon_bitfield_has_negative_width)\n      << Value.toString(10);\n  }\n\n  // The size of the bit-field must not exceed our maximum permitted object\n  // size.\n  if (Value.getActiveBits() > ConstantArrayType::getMaxSizeBits(Context)) {\n    return Diag(FieldLoc, diag::err_bitfield_too_wide)\n           << !FieldName << FieldName << Value.toString(10);\n  }\n\n  if (!FieldTy->isDependentType()) {\n    uint64_t TypeStorageSize = Context.getTypeSize(FieldTy);\n    uint64_t TypeWidth = Context.getIntWidth(FieldTy);\n    bool BitfieldIsOverwide = Value.ugt(TypeWidth);\n\n    // Over-wide bitfields are an error in C or when using the MSVC bitfield\n    // ABI.\n    bool CStdConstraintViolation =\n        BitfieldIsOverwide && !getLangOpts().CPlusPlus;\n    bool MSBitfieldViolation =\n        Value.ugt(TypeStorageSize) &&\n        (IsMsStruct || Context.getTargetInfo().getCXXABI().isMicrosoft());\n    if (CStdConstraintViolation || MSBitfieldViolation) {\n      unsigned DiagWidth =\n          CStdConstraintViolation ? TypeWidth : TypeStorageSize;\n      if (FieldName)\n        return Diag(FieldLoc, diag::err_bitfield_width_exceeds_type_width)\n               << FieldName << Value.toString(10)\n               << !CStdConstraintViolation << DiagWidth;\n\n      return Diag(FieldLoc, diag::err_anon_bitfield_width_exceeds_type_width)\n             << Value.toString(10) << !CStdConstraintViolation\n             << DiagWidth;\n    }\n\n    // Warn on types where the user might conceivably expect to get all\n    // specified bits as value bits: that's all integral types other than\n    // 'bool'.\n    if (BitfieldIsOverwide && !FieldTy->isBooleanType() && FieldName) {\n      Diag(FieldLoc, diag::warn_bitfield_width_exceeds_type_width)\n          << FieldName << Value.toString(10)\n          << (unsigned)TypeWidth;\n    }\n  }\n\n  return BitWidth;\n}\n\n/// ActOnField - Each field of a C struct/union is passed into this in order\n/// to create a FieldDecl object for it.\nDecl *Sema::ActOnField(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                       Declarator &D, Expr *BitfieldWidth) {\n  FieldDecl *Res = HandleField(S, cast_or_null<RecordDecl>(TagD),\n                               DeclStart, D, static_cast<Expr*>(BitfieldWidth),\n                               /*InitStyle=*/ICIS_NoInit, AS_public);\n  return Res;\n}\n\n/// HandleField - Analyze a field of a C struct or a C++ data member.\n///\nFieldDecl *Sema::HandleField(Scope *S, RecordDecl *Record,\n                             SourceLocation DeclStart,\n                             Declarator &D, Expr *BitWidth,\n                             InClassInitStyle InitStyle,\n                             AccessSpecifier AS) {\n  if (D.isDecompositionDeclarator()) {\n    const DecompositionDeclarator &Decomp = D.getDecompositionDeclarator();\n    Diag(Decomp.getLSquareLoc(), diag::err_decomp_decl_context)\n      << Decomp.getSourceRange();\n    return nullptr;\n  }\n\n  IdentifierInfo *II = D.getIdentifier();\n  SourceLocation Loc = DeclStart;\n  if (II) Loc = D.getIdentifierLoc();\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType T = TInfo->getType();\n  if (getLangOpts().CPlusPlus) {\n    CheckExtraCXXDefaultArguments(D);\n\n    if (DiagnoseUnexpandedParameterPack(D.getIdentifierLoc(), TInfo,\n                                        UPPC_DataMemberType)) {\n      D.setInvalidType();\n      T = Context.IntTy;\n      TInfo = Context.getTrivialTypeSourceInfo(T, Loc);\n    }\n  }\n\n  DiagnoseFunctionSpecifiers(D.getDeclSpec());\n\n  if (D.getDeclSpec().isInlineSpecified())\n    Diag(D.getDeclSpec().getInlineSpecLoc(), diag::err_inline_non_function)\n        << getLangOpts().CPlusPlus17;\n  if (DeclSpec::TSCS TSCS = D.getDeclSpec().getThreadStorageClassSpec())\n    Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n         diag::err_invalid_thread)\n      << DeclSpec::getSpecifierName(TSCS);\n\n  // Check to see if this name was declared as a member previously\n  NamedDecl *PrevDecl = nullptr;\n  LookupResult Previous(*this, II, Loc, LookupMemberName,\n                        ForVisibleRedeclaration);\n  LookupName(Previous, S);\n  switch (Previous.getResultKind()) {\n    case LookupResult::Found:\n    case LookupResult::FoundUnresolvedValue:\n      PrevDecl = Previous.getAsSingle<NamedDecl>();\n      break;\n\n    case LookupResult::FoundOverloaded:\n      PrevDecl = Previous.getRepresentativeDecl();\n      break;\n\n    case LookupResult::NotFound:\n    case LookupResult::NotFoundInCurrentInstantiation:\n    case LookupResult::Ambiguous:\n      break;\n  }\n  Previous.suppressDiagnostics();\n\n  if (PrevDecl && PrevDecl->isTemplateParameter()) {\n    // Maybe we will complain about the shadowed template parameter.\n    DiagnoseTemplateParameterShadow(D.getIdentifierLoc(), PrevDecl);\n    // Just pretend that we didn't see the previous declaration.\n    PrevDecl = nullptr;\n  }\n\n  if (PrevDecl && !isDeclInScope(PrevDecl, Record, S))\n    PrevDecl = nullptr;\n\n  bool Mutable\n    = (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_mutable);\n  SourceLocation TSSL = D.getBeginLoc();\n  FieldDecl *NewFD\n    = CheckFieldDecl(II, T, TInfo, Record, Loc, Mutable, BitWidth, InitStyle,\n                     TSSL, AS, PrevDecl, &D);\n\n  if (NewFD->isInvalidDecl())\n    Record->setInvalidDecl();\n\n  if (D.getDeclSpec().isModulePrivateSpecified())\n    NewFD->setModulePrivate();\n\n  if (NewFD->isInvalidDecl() && PrevDecl) {\n    // Don't introduce NewFD into scope; there's already something\n    // with the same name in the same scope.\n  } else if (II) {\n    PushOnScopeChains(NewFD, S);\n  } else\n    Record->addDecl(NewFD);\n\n  return NewFD;\n}\n\n/// Build a new FieldDecl and check its well-formedness.\n///\n/// This routine builds a new FieldDecl given the fields name, type,\n/// record, etc. \\p PrevDecl should refer to any previous declaration\n/// with the same name and in the same scope as the field to be\n/// created.\n///\n/// \\returns a new FieldDecl.\n///\n/// \\todo The Declarator argument is a hack. It will be removed once\nFieldDecl *Sema::CheckFieldDecl(DeclarationName Name, QualType T,\n                                TypeSourceInfo *TInfo,\n                                RecordDecl *Record, SourceLocation Loc,\n                                bool Mutable, Expr *BitWidth,\n                                InClassInitStyle InitStyle,\n                                SourceLocation TSSL,\n                                AccessSpecifier AS, NamedDecl *PrevDecl,\n                                Declarator *D) {\n  IdentifierInfo *II = Name.getAsIdentifierInfo();\n  bool InvalidDecl = false;\n  if (D) InvalidDecl = D->isInvalidType();\n\n  // If we receive a broken type, recover by assuming 'int' and\n  // marking this declaration as invalid.\n  if (T.isNull() || T->containsErrors()) {\n    InvalidDecl = true;\n    T = Context.IntTy;\n  }\n\n  QualType EltTy = Context.getBaseElementType(T);\n  if (!EltTy->isDependentType() && !EltTy->containsErrors()) {\n    if (RequireCompleteSizedType(Loc, EltTy,\n                                 diag::err_field_incomplete_or_sizeless)) {\n      // Fields of incomplete type force their record to be invalid.\n      Record->setInvalidDecl();\n      InvalidDecl = true;\n    } else {\n      NamedDecl *Def;\n      EltTy->isIncompleteType(&Def);\n      if (Def && Def->isInvalidDecl()) {\n        Record->setInvalidDecl();\n        InvalidDecl = true;\n      }\n    }\n  }\n\n  // TR 18037 does not allow fields to be declared with address space\n  if (T.hasAddressSpace() || T->isDependentAddressSpaceType() ||\n      T->getBaseElementTypeUnsafe()->isDependentAddressSpaceType()) {\n    Diag(Loc, diag::err_field_with_address_space);\n    Record->setInvalidDecl();\n    InvalidDecl = true;\n  }\n\n  if (LangOpts.OpenCL) {\n    // OpenCL v1.2 s6.9b,r & OpenCL v2.0 s6.12.5 - The following types cannot be\n    // used as structure or union field: image, sampler, event or block types.\n    if (T->isEventT() || T->isImageType() || T->isSamplerT() ||\n        T->isBlockPointerType()) {\n      Diag(Loc, diag::err_opencl_type_struct_or_union_field) << T;\n      Record->setInvalidDecl();\n      InvalidDecl = true;\n    }\n    // OpenCL v1.2 s6.9.c: bitfields are not supported.\n    if (BitWidth) {\n      Diag(Loc, diag::err_opencl_bitfields);\n      InvalidDecl = true;\n    }\n  }\n\n  // Anonymous bit-fields cannot be cv-qualified (CWG 2229).\n  if (!InvalidDecl && getLangOpts().CPlusPlus && !II && BitWidth &&\n      T.hasQualifiers()) {\n    InvalidDecl = true;\n    Diag(Loc, diag::err_anon_bitfield_qualifiers);\n  }\n\n  // C99 6.7.2.1p8: A member of a structure or union may have any type other\n  // than a variably modified type.\n  if (!InvalidDecl && T->isVariablyModifiedType()) {\n    if (!tryToFixVariablyModifiedVarType(\n            *this, TInfo, T, Loc, diag::err_typecheck_field_variable_size))\n      InvalidDecl = true;\n  }\n\n  // Fields can not have abstract class types\n  if (!InvalidDecl && RequireNonAbstractType(Loc, T,\n                                             diag::err_abstract_type_in_decl,\n                                             AbstractFieldType))\n    InvalidDecl = true;\n\n  bool ZeroWidth = false;\n  if (InvalidDecl)\n    BitWidth = nullptr;\n  // If this is declared as a bit-field, check the bit-field.\n  if (BitWidth) {\n    BitWidth = VerifyBitField(Loc, II, T, Record->isMsStruct(Context), BitWidth,\n                              &ZeroWidth).get();\n    if (!BitWidth) {\n      InvalidDecl = true;\n      BitWidth = nullptr;\n      ZeroWidth = false;\n    }\n  }\n\n  // Check that 'mutable' is consistent with the type of the declaration.\n  if (!InvalidDecl && Mutable) {\n    unsigned DiagID = 0;\n    if (T->isReferenceType())\n      DiagID = getLangOpts().MSVCCompat ? diag::ext_mutable_reference\n                                        : diag::err_mutable_reference;\n    else if (T.isConstQualified())\n      DiagID = diag::err_mutable_const;\n\n    if (DiagID) {\n      SourceLocation ErrLoc = Loc;\n      if (D && D->getDeclSpec().getStorageClassSpecLoc().isValid())\n        ErrLoc = D->getDeclSpec().getStorageClassSpecLoc();\n      Diag(ErrLoc, DiagID);\n      if (DiagID != diag::ext_mutable_reference) {\n        Mutable = false;\n        InvalidDecl = true;\n      }\n    }\n  }\n\n  // C++11 [class.union]p8 (DR1460):\n  //   At most one variant member of a union may have a\n  //   brace-or-equal-initializer.\n  if (InitStyle != ICIS_NoInit)\n    checkDuplicateDefaultInit(*this, cast<CXXRecordDecl>(Record), Loc);\n\n  FieldDecl *NewFD = FieldDecl::Create(Context, Record, TSSL, Loc, II, T, TInfo,\n                                       BitWidth, Mutable, InitStyle);\n  if (InvalidDecl)\n    NewFD->setInvalidDecl();\n\n  if (PrevDecl && !isa<TagDecl>(PrevDecl)) {\n    Diag(Loc, diag::err_duplicate_member) << II;\n    Diag(PrevDecl->getLocation(), diag::note_previous_declaration);\n    NewFD->setInvalidDecl();\n  }\n\n  if (!InvalidDecl && getLangOpts().CPlusPlus) {\n    if (Record->isUnion()) {\n      if (const RecordType *RT = EltTy->getAs<RecordType>()) {\n        CXXRecordDecl* RDecl = cast<CXXRecordDecl>(RT->getDecl());\n        if (RDecl->getDefinition()) {\n          // C++ [class.union]p1: An object of a class with a non-trivial\n          // constructor, a non-trivial copy constructor, a non-trivial\n          // destructor, or a non-trivial copy assignment operator\n          // cannot be a member of a union, nor can an array of such\n          // objects.\n          if (CheckNontrivialField(NewFD))\n            NewFD->setInvalidDecl();\n        }\n      }\n\n      // C++ [class.union]p1: If a union contains a member of reference type,\n      // the program is ill-formed, except when compiling with MSVC extensions\n      // enabled.\n      if (EltTy->isReferenceType()) {\n        Diag(NewFD->getLocation(), getLangOpts().MicrosoftExt ?\n                                    diag::ext_union_member_of_reference_type :\n                                    diag::err_union_member_of_reference_type)\n          << NewFD->getDeclName() << EltTy;\n        if (!getLangOpts().MicrosoftExt)\n          NewFD->setInvalidDecl();\n      }\n    }\n  }\n\n  // FIXME: We need to pass in the attributes given an AST\n  // representation, not a parser representation.\n  if (D) {\n    // FIXME: The current scope is almost... but not entirely... correct here.\n    ProcessDeclAttributes(getCurScope(), NewFD, *D);\n\n    if (NewFD->hasAttrs())\n      CheckAlignasUnderalignment(NewFD);\n  }\n\n  // In auto-retain/release, infer strong retension for fields of\n  // retainable type.\n  if (getLangOpts().ObjCAutoRefCount && inferObjCARCLifetime(NewFD))\n    NewFD->setInvalidDecl();\n\n  if (T.isObjCGCWeak())\n    Diag(Loc, diag::warn_attribute_weak_on_field);\n\n  // PPC MMA non-pointer types are not allowed as field types.\n  if (Context.getTargetInfo().getTriple().isPPC64() &&\n      CheckPPCMMAType(T, NewFD->getLocation()))\n    NewFD->setInvalidDecl();\n\n  NewFD->setAccess(AS);\n  return NewFD;\n}\n\nbool Sema::CheckNontrivialField(FieldDecl *FD) {\n  assert(FD);\n  assert(getLangOpts().CPlusPlus && \"valid check only for C++\");\n\n  if (FD->isInvalidDecl() || FD->getType()->isDependentType())\n    return false;\n\n  QualType EltTy = Context.getBaseElementType(FD->getType());\n  if (const RecordType *RT = EltTy->getAs<RecordType>()) {\n    CXXRecordDecl *RDecl = cast<CXXRecordDecl>(RT->getDecl());\n    if (RDecl->getDefinition()) {\n      // We check for copy constructors before constructors\n      // because otherwise we'll never get complaints about\n      // copy constructors.\n\n      CXXSpecialMember member = CXXInvalid;\n      // We're required to check for any non-trivial constructors. Since the\n      // implicit default constructor is suppressed if there are any\n      // user-declared constructors, we just need to check that there is a\n      // trivial default constructor and a trivial copy constructor. (We don't\n      // worry about move constructors here, since this is a C++98 check.)\n      if (RDecl->hasNonTrivialCopyConstructor())\n        member = CXXCopyConstructor;\n      else if (!RDecl->hasTrivialDefaultConstructor())\n        member = CXXDefaultConstructor;\n      else if (RDecl->hasNonTrivialCopyAssignment())\n        member = CXXCopyAssignment;\n      else if (RDecl->hasNonTrivialDestructor())\n        member = CXXDestructor;\n\n      if (member != CXXInvalid) {\n        if (!getLangOpts().CPlusPlus11 &&\n            getLangOpts().ObjCAutoRefCount && RDecl->hasObjectMember()) {\n          // Objective-C++ ARC: it is an error to have a non-trivial field of\n          // a union. However, system headers in Objective-C programs\n          // occasionally have Objective-C lifetime objects within unions,\n          // and rather than cause the program to fail, we make those\n          // members unavailable.\n          SourceLocation Loc = FD->getLocation();\n          if (getSourceManager().isInSystemHeader(Loc)) {\n            if (!FD->hasAttr<UnavailableAttr>())\n              FD->addAttr(UnavailableAttr::CreateImplicit(Context, \"\",\n                            UnavailableAttr::IR_ARCFieldWithOwnership, Loc));\n            return false;\n          }\n        }\n\n        Diag(FD->getLocation(), getLangOpts().CPlusPlus11 ?\n               diag::warn_cxx98_compat_nontrivial_union_or_anon_struct_member :\n               diag::err_illegal_union_or_anon_struct_member)\n          << FD->getParent()->isUnion() << FD->getDeclName() << member;\n        DiagnoseNontrivial(RDecl, member);\n        return !getLangOpts().CPlusPlus11;\n      }\n    }\n  }\n\n  return false;\n}\n\n/// TranslateIvarVisibility - Translate visibility from a token ID to an\n///  AST enum value.\nstatic ObjCIvarDecl::AccessControl\nTranslateIvarVisibility(tok::ObjCKeywordKind ivarVisibility) {\n  switch (ivarVisibility) {\n  default: llvm_unreachable(\"Unknown visitibility kind\");\n  case tok::objc_private: return ObjCIvarDecl::Private;\n  case tok::objc_public: return ObjCIvarDecl::Public;\n  case tok::objc_protected: return ObjCIvarDecl::Protected;\n  case tok::objc_package: return ObjCIvarDecl::Package;\n  }\n}\n\n/// ActOnIvar - Each ivar field of an objective-c class is passed into this\n/// in order to create an IvarDecl object for it.\nDecl *Sema::ActOnIvar(Scope *S,\n                                SourceLocation DeclStart,\n                                Declarator &D, Expr *BitfieldWidth,\n                                tok::ObjCKeywordKind Visibility) {\n\n  IdentifierInfo *II = D.getIdentifier();\n  Expr *BitWidth = (Expr*)BitfieldWidth;\n  SourceLocation Loc = DeclStart;\n  if (II) Loc = D.getIdentifierLoc();\n\n  // FIXME: Unnamed fields can be handled in various different ways, for\n  // example, unnamed unions inject all members into the struct namespace!\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType T = TInfo->getType();\n\n  if (BitWidth) {\n    // 6.7.2.1p3, 6.7.2.1p4\n    BitWidth = VerifyBitField(Loc, II, T, /*IsMsStruct*/false, BitWidth).get();\n    if (!BitWidth)\n      D.setInvalidType();\n  } else {\n    // Not a bitfield.\n\n    // validate II.\n\n  }\n  if (T->isReferenceType()) {\n    Diag(Loc, diag::err_ivar_reference_type);\n    D.setInvalidType();\n  }\n  // C99 6.7.2.1p8: A member of a structure or union may have any type other\n  // than a variably modified type.\n  else if (T->isVariablyModifiedType()) {\n    if (!tryToFixVariablyModifiedVarType(\n            *this, TInfo, T, Loc, diag::err_typecheck_ivar_variable_size))\n      D.setInvalidType();\n  }\n\n  // Get the visibility (access control) for this ivar.\n  ObjCIvarDecl::AccessControl ac =\n    Visibility != tok::objc_not_keyword ? TranslateIvarVisibility(Visibility)\n                                        : ObjCIvarDecl::None;\n  // Must set ivar's DeclContext to its enclosing interface.\n  ObjCContainerDecl *EnclosingDecl = cast<ObjCContainerDecl>(CurContext);\n  if (!EnclosingDecl || EnclosingDecl->isInvalidDecl())\n    return nullptr;\n  ObjCContainerDecl *EnclosingContext;\n  if (ObjCImplementationDecl *IMPDecl =\n      dyn_cast<ObjCImplementationDecl>(EnclosingDecl)) {\n    if (LangOpts.ObjCRuntime.isFragile()) {\n    // Case of ivar declared in an implementation. Context is that of its class.\n      EnclosingContext = IMPDecl->getClassInterface();\n      assert(EnclosingContext && \"Implementation has no class interface!\");\n    }\n    else\n      EnclosingContext = EnclosingDecl;\n  } else {\n    if (ObjCCategoryDecl *CDecl =\n        dyn_cast<ObjCCategoryDecl>(EnclosingDecl)) {\n      if (LangOpts.ObjCRuntime.isFragile() || !CDecl->IsClassExtension()) {\n        Diag(Loc, diag::err_misplaced_ivar) << CDecl->IsClassExtension();\n        return nullptr;\n      }\n    }\n    EnclosingContext = EnclosingDecl;\n  }\n\n  // Construct the decl.\n  ObjCIvarDecl *NewID = ObjCIvarDecl::Create(Context, EnclosingContext,\n                                             DeclStart, Loc, II, T,\n                                             TInfo, ac, (Expr *)BitfieldWidth);\n\n  if (II) {\n    NamedDecl *PrevDecl = LookupSingleName(S, II, Loc, LookupMemberName,\n                                           ForVisibleRedeclaration);\n    if (PrevDecl && isDeclInScope(PrevDecl, EnclosingContext, S)\n        && !isa<TagDecl>(PrevDecl)) {\n      Diag(Loc, diag::err_duplicate_member) << II;\n      Diag(PrevDecl->getLocation(), diag::note_previous_declaration);\n      NewID->setInvalidDecl();\n    }\n  }\n\n  // Process attributes attached to the ivar.\n  ProcessDeclAttributes(S, NewID, D);\n\n  if (D.isInvalidType())\n    NewID->setInvalidDecl();\n\n  // In ARC, infer 'retaining' for ivars of retainable type.\n  if (getLangOpts().ObjCAutoRefCount && inferObjCARCLifetime(NewID))\n    NewID->setInvalidDecl();\n\n  if (D.getDeclSpec().isModulePrivateSpecified())\n    NewID->setModulePrivate();\n\n  if (II) {\n    // FIXME: When interfaces are DeclContexts, we'll need to add\n    // these to the interface.\n    S->AddDecl(NewID);\n    IdResolver.AddDecl(NewID);\n  }\n\n  if (LangOpts.ObjCRuntime.isNonFragile() &&\n      !NewID->isInvalidDecl() && isa<ObjCInterfaceDecl>(EnclosingDecl))\n    Diag(Loc, diag::warn_ivars_in_interface);\n\n  return NewID;\n}\n\n/// ActOnLastBitfield - This routine handles synthesized bitfields rules for\n/// class and class extensions. For every class \\@interface and class\n/// extension \\@interface, if the last ivar is a bitfield of any type,\n/// then add an implicit `char :0` ivar to the end of that interface.\nvoid Sema::ActOnLastBitfield(SourceLocation DeclLoc,\n                             SmallVectorImpl<Decl *> &AllIvarDecls) {\n  if (LangOpts.ObjCRuntime.isFragile() || AllIvarDecls.empty())\n    return;\n\n  Decl *ivarDecl = AllIvarDecls[AllIvarDecls.size()-1];\n  ObjCIvarDecl *Ivar = cast<ObjCIvarDecl>(ivarDecl);\n\n  if (!Ivar->isBitField() || Ivar->isZeroLengthBitField(Context))\n    return;\n  ObjCInterfaceDecl *ID = dyn_cast<ObjCInterfaceDecl>(CurContext);\n  if (!ID) {\n    if (ObjCCategoryDecl *CD = dyn_cast<ObjCCategoryDecl>(CurContext)) {\n      if (!CD->IsClassExtension())\n        return;\n    }\n    // No need to add this to end of @implementation.\n    else\n      return;\n  }\n  // All conditions are met. Add a new bitfield to the tail end of ivars.\n  llvm::APInt Zero(Context.getTypeSize(Context.IntTy), 0);\n  Expr * BW = IntegerLiteral::Create(Context, Zero, Context.IntTy, DeclLoc);\n\n  Ivar = ObjCIvarDecl::Create(Context, cast<ObjCContainerDecl>(CurContext),\n                              DeclLoc, DeclLoc, nullptr,\n                              Context.CharTy,\n                              Context.getTrivialTypeSourceInfo(Context.CharTy,\n                                                               DeclLoc),\n                              ObjCIvarDecl::Private, BW,\n                              true);\n  AllIvarDecls.push_back(Ivar);\n}\n\nvoid Sema::ActOnFields(Scope *S, SourceLocation RecLoc, Decl *EnclosingDecl,\n                       ArrayRef<Decl *> Fields, SourceLocation LBrac,\n                       SourceLocation RBrac,\n                       const ParsedAttributesView &Attrs) {\n  assert(EnclosingDecl && \"missing record or interface decl\");\n\n  // If this is an Objective-C @implementation or category and we have\n  // new fields here we should reset the layout of the interface since\n  // it will now change.\n  if (!Fields.empty() && isa<ObjCContainerDecl>(EnclosingDecl)) {\n    ObjCContainerDecl *DC = cast<ObjCContainerDecl>(EnclosingDecl);\n    switch (DC->getKind()) {\n    default: break;\n    case Decl::ObjCCategory:\n      Context.ResetObjCLayout(cast<ObjCCategoryDecl>(DC)->getClassInterface());\n      break;\n    case Decl::ObjCImplementation:\n      Context.\n        ResetObjCLayout(cast<ObjCImplementationDecl>(DC)->getClassInterface());\n      break;\n    }\n  }\n\n  RecordDecl *Record = dyn_cast<RecordDecl>(EnclosingDecl);\n  CXXRecordDecl *CXXRecord = dyn_cast<CXXRecordDecl>(EnclosingDecl);\n\n  // Start counting up the number of named members; make sure to include\n  // members of anonymous structs and unions in the total.\n  unsigned NumNamedMembers = 0;\n  if (Record) {\n    for (const auto *I : Record->decls()) {\n      if (const auto *IFD = dyn_cast<IndirectFieldDecl>(I))\n        if (IFD->getDeclName())\n          ++NumNamedMembers;\n    }\n  }\n\n  // Verify that all the fields are okay.\n  SmallVector<FieldDecl*, 32> RecFields;\n\n  for (ArrayRef<Decl *>::iterator i = Fields.begin(), end = Fields.end();\n       i != end; ++i) {\n    FieldDecl *FD = cast<FieldDecl>(*i);\n\n    // Get the type for the field.\n    const Type *FDTy = FD->getType().getTypePtr();\n\n    if (!FD->isAnonymousStructOrUnion()) {\n      // Remember all fields written by the user.\n      RecFields.push_back(FD);\n    }\n\n    // If the field is already invalid for some reason, don't emit more\n    // diagnostics about it.\n    if (FD->isInvalidDecl()) {\n      EnclosingDecl->setInvalidDecl();\n      continue;\n    }\n\n    // C99 6.7.2.1p2:\n    //   A structure or union shall not contain a member with\n    //   incomplete or function type (hence, a structure shall not\n    //   contain an instance of itself, but may contain a pointer to\n    //   an instance of itself), except that the last member of a\n    //   structure with more than one named member may have incomplete\n    //   array type; such a structure (and any union containing,\n    //   possibly recursively, a member that is such a structure)\n    //   shall not be a member of a structure or an element of an\n    //   array.\n    bool IsLastField = (i + 1 == Fields.end());\n    if (FDTy->isFunctionType()) {\n      // Field declared as a function.\n      Diag(FD->getLocation(), diag::err_field_declared_as_function)\n        << FD->getDeclName();\n      FD->setInvalidDecl();\n      EnclosingDecl->setInvalidDecl();\n      continue;\n    } else if (FDTy->isIncompleteArrayType() &&\n               (Record || isa<ObjCContainerDecl>(EnclosingDecl))) {\n      if (Record) {\n        // Flexible array member.\n        // Microsoft and g++ is more permissive regarding flexible array.\n        // It will accept flexible array in union and also\n        // as the sole element of a struct/class.\n        unsigned DiagID = 0;\n        if (!Record->isUnion() && !IsLastField) {\n          Diag(FD->getLocation(), diag::err_flexible_array_not_at_end)\n            << FD->getDeclName() << FD->getType() << Record->getTagKind();\n          Diag((*(i + 1))->getLocation(), diag::note_next_field_declaration);\n          FD->setInvalidDecl();\n          EnclosingDecl->setInvalidDecl();\n          continue;\n        } else if (Record->isUnion())\n          DiagID = getLangOpts().MicrosoftExt\n                       ? diag::ext_flexible_array_union_ms\n                       : getLangOpts().CPlusPlus\n                             ? diag::ext_flexible_array_union_gnu\n                             : diag::err_flexible_array_union;\n        else if (NumNamedMembers < 1)\n          DiagID = getLangOpts().MicrosoftExt\n                       ? diag::ext_flexible_array_empty_aggregate_ms\n                       : getLangOpts().CPlusPlus\n                             ? diag::ext_flexible_array_empty_aggregate_gnu\n                             : diag::err_flexible_array_empty_aggregate;\n\n        if (DiagID)\n          Diag(FD->getLocation(), DiagID) << FD->getDeclName()\n                                          << Record->getTagKind();\n        // While the layout of types that contain virtual bases is not specified\n        // by the C++ standard, both the Itanium and Microsoft C++ ABIs place\n        // virtual bases after the derived members.  This would make a flexible\n        // array member declared at the end of an object not adjacent to the end\n        // of the type.\n        if (CXXRecord && CXXRecord->getNumVBases() != 0)\n          Diag(FD->getLocation(), diag::err_flexible_array_virtual_base)\n              << FD->getDeclName() << Record->getTagKind();\n        if (!getLangOpts().C99)\n          Diag(FD->getLocation(), diag::ext_c99_flexible_array_member)\n            << FD->getDeclName() << Record->getTagKind();\n\n        // If the element type has a non-trivial destructor, we would not\n        // implicitly destroy the elements, so disallow it for now.\n        //\n        // FIXME: GCC allows this. We should probably either implicitly delete\n        // the destructor of the containing class, or just allow this.\n        QualType BaseElem = Context.getBaseElementType(FD->getType());\n        if (!BaseElem->isDependentType() && BaseElem.isDestructedType()) {\n          Diag(FD->getLocation(), diag::err_flexible_array_has_nontrivial_dtor)\n            << FD->getDeclName() << FD->getType();\n          FD->setInvalidDecl();\n          EnclosingDecl->setInvalidDecl();\n          continue;\n        }\n        // Okay, we have a legal flexible array member at the end of the struct.\n        Record->setHasFlexibleArrayMember(true);\n      } else {\n        // In ObjCContainerDecl ivars with incomplete array type are accepted,\n        // unless they are followed by another ivar. That check is done\n        // elsewhere, after synthesized ivars are known.\n      }\n    } else if (!FDTy->isDependentType() &&\n               RequireCompleteSizedType(\n                   FD->getLocation(), FD->getType(),\n                   diag::err_field_incomplete_or_sizeless)) {\n      // Incomplete type\n      FD->setInvalidDecl();\n      EnclosingDecl->setInvalidDecl();\n      continue;\n    } else if (const RecordType *FDTTy = FDTy->getAs<RecordType>()) {\n      if (Record && FDTTy->getDecl()->hasFlexibleArrayMember()) {\n        // A type which contains a flexible array member is considered to be a\n        // flexible array member.\n        Record->setHasFlexibleArrayMember(true);\n        if (!Record->isUnion()) {\n          // If this is a struct/class and this is not the last element, reject\n          // it.  Note that GCC supports variable sized arrays in the middle of\n          // structures.\n          if (!IsLastField)\n            Diag(FD->getLocation(), diag::ext_variable_sized_type_in_struct)\n              << FD->getDeclName() << FD->getType();\n          else {\n            // We support flexible arrays at the end of structs in\n            // other structs as an extension.\n            Diag(FD->getLocation(), diag::ext_flexible_array_in_struct)\n              << FD->getDeclName();\n          }\n        }\n      }\n      if (isa<ObjCContainerDecl>(EnclosingDecl) &&\n          RequireNonAbstractType(FD->getLocation(), FD->getType(),\n                                 diag::err_abstract_type_in_decl,\n                                 AbstractIvarType)) {\n        // Ivars can not have abstract class types\n        FD->setInvalidDecl();\n      }\n      if (Record && FDTTy->getDecl()->hasObjectMember())\n        Record->setHasObjectMember(true);\n      if (Record && FDTTy->getDecl()->hasVolatileMember())\n        Record->setHasVolatileMember(true);\n    } else if (FDTy->isObjCObjectType()) {\n      /// A field cannot be an Objective-c object\n      Diag(FD->getLocation(), diag::err_statically_allocated_object)\n        << FixItHint::CreateInsertion(FD->getLocation(), \"*\");\n      QualType T = Context.getObjCObjectPointerType(FD->getType());\n      FD->setType(T);\n    } else if (Record && Record->isUnion() &&\n               FD->getType().hasNonTrivialObjCLifetime() &&\n               getSourceManager().isInSystemHeader(FD->getLocation()) &&\n               !getLangOpts().CPlusPlus && !FD->hasAttr<UnavailableAttr>() &&\n               (FD->getType().getObjCLifetime() != Qualifiers::OCL_Strong ||\n                !Context.hasDirectOwnershipQualifier(FD->getType()))) {\n      // For backward compatibility, fields of C unions declared in system\n      // headers that have non-trivial ObjC ownership qualifications are marked\n      // as unavailable unless the qualifier is explicit and __strong. This can\n      // break ABI compatibility between programs compiled with ARC and MRR, but\n      // is a better option than rejecting programs using those unions under\n      // ARC.\n      FD->addAttr(UnavailableAttr::CreateImplicit(\n          Context, \"\", UnavailableAttr::IR_ARCFieldWithOwnership,\n          FD->getLocation()));\n    } else if (getLangOpts().ObjC &&\n               getLangOpts().getGC() != LangOptions::NonGC && Record &&\n               !Record->hasObjectMember()) {\n      if (FD->getType()->isObjCObjectPointerType() ||\n          FD->getType().isObjCGCStrong())\n        Record->setHasObjectMember(true);\n      else if (Context.getAsArrayType(FD->getType())) {\n        QualType BaseType = Context.getBaseElementType(FD->getType());\n        if (BaseType->isRecordType() &&\n            BaseType->castAs<RecordType>()->getDecl()->hasObjectMember())\n          Record->setHasObjectMember(true);\n        else if (BaseType->isObjCObjectPointerType() ||\n                 BaseType.isObjCGCStrong())\n               Record->setHasObjectMember(true);\n      }\n    }\n\n    if (Record && !getLangOpts().CPlusPlus &&\n        !shouldIgnoreForRecordTriviality(FD)) {\n      QualType FT = FD->getType();\n      if (FT.isNonTrivialToPrimitiveDefaultInitialize()) {\n        Record->setNonTrivialToPrimitiveDefaultInitialize(true);\n        if (FT.hasNonTrivialToPrimitiveDefaultInitializeCUnion() ||\n            Record->isUnion())\n          Record->setHasNonTrivialToPrimitiveDefaultInitializeCUnion(true);\n      }\n      QualType::PrimitiveCopyKind PCK = FT.isNonTrivialToPrimitiveCopy();\n      if (PCK != QualType::PCK_Trivial && PCK != QualType::PCK_VolatileTrivial) {\n        Record->setNonTrivialToPrimitiveCopy(true);\n        if (FT.hasNonTrivialToPrimitiveCopyCUnion() || Record->isUnion())\n          Record->setHasNonTrivialToPrimitiveCopyCUnion(true);\n      }\n      if (FT.isDestructedType()) {\n        Record->setNonTrivialToPrimitiveDestroy(true);\n        Record->setParamDestroyedInCallee(true);\n        if (FT.hasNonTrivialToPrimitiveDestructCUnion() || Record->isUnion())\n          Record->setHasNonTrivialToPrimitiveDestructCUnion(true);\n      }\n\n      if (const auto *RT = FT->getAs<RecordType>()) {\n        if (RT->getDecl()->getArgPassingRestrictions() ==\n            RecordDecl::APK_CanNeverPassInRegs)\n          Record->setArgPassingRestrictions(RecordDecl::APK_CanNeverPassInRegs);\n      } else if (FT.getQualifiers().getObjCLifetime() == Qualifiers::OCL_Weak)\n        Record->setArgPassingRestrictions(RecordDecl::APK_CanNeverPassInRegs);\n    }\n\n    if (Record && FD->getType().isVolatileQualified())\n      Record->setHasVolatileMember(true);\n    // Keep track of the number of named members.\n    if (FD->getIdentifier())\n      ++NumNamedMembers;\n  }\n\n  // Okay, we successfully defined 'Record'.\n  if (Record) {\n    bool Completed = false;\n    if (CXXRecord) {\n      if (!CXXRecord->isInvalidDecl()) {\n        // Set access bits correctly on the directly-declared conversions.\n        for (CXXRecordDecl::conversion_iterator\n               I = CXXRecord->conversion_begin(),\n               E = CXXRecord->conversion_end(); I != E; ++I)\n          I.setAccess((*I)->getAccess());\n      }\n\n      // Add any implicitly-declared members to this class.\n      AddImplicitlyDeclaredMembersToClass(CXXRecord);\n\n      if (!CXXRecord->isDependentType()) {\n        if (!CXXRecord->isInvalidDecl()) {\n          // If we have virtual base classes, we may end up finding multiple\n          // final overriders for a given virtual function. Check for this\n          // problem now.\n          if (CXXRecord->getNumVBases()) {\n            CXXFinalOverriderMap FinalOverriders;\n            CXXRecord->getFinalOverriders(FinalOverriders);\n\n            for (CXXFinalOverriderMap::iterator M = FinalOverriders.begin(),\n                                             MEnd = FinalOverriders.end();\n                 M != MEnd; ++M) {\n              for (OverridingMethods::iterator SO = M->second.begin(),\n                                            SOEnd = M->second.end();\n                   SO != SOEnd; ++SO) {\n                assert(SO->second.size() > 0 &&\n                       \"Virtual function without overriding functions?\");\n                if (SO->second.size() == 1)\n                  continue;\n\n                // C++ [class.virtual]p2:\n                //   In a derived class, if a virtual member function of a base\n                //   class subobject has more than one final overrider the\n                //   program is ill-formed.\n                Diag(Record->getLocation(), diag::err_multiple_final_overriders)\n                  << (const NamedDecl *)M->first << Record;\n                Diag(M->first->getLocation(),\n                     diag::note_overridden_virtual_function);\n                for (OverridingMethods::overriding_iterator\n                          OM = SO->second.begin(),\n                       OMEnd = SO->second.end();\n                     OM != OMEnd; ++OM)\n                  Diag(OM->Method->getLocation(), diag::note_final_overrider)\n                    << (const NamedDecl *)M->first << OM->Method->getParent();\n\n                Record->setInvalidDecl();\n              }\n            }\n            CXXRecord->completeDefinition(&FinalOverriders);\n            Completed = true;\n          }\n        }\n      }\n    }\n\n    if (!Completed)\n      Record->completeDefinition();\n\n    // Handle attributes before checking the layout.\n    ProcessDeclAttributeList(S, Record, Attrs);\n\n    // We may have deferred checking for a deleted destructor. Check now.\n    if (CXXRecord) {\n      auto *Dtor = CXXRecord->getDestructor();\n      if (Dtor && Dtor->isImplicit() &&\n          ShouldDeleteSpecialMember(Dtor, CXXDestructor)) {\n        CXXRecord->setImplicitDestructorIsDeleted();\n        SetDeclDeleted(Dtor, CXXRecord->getLocation());\n      }\n    }\n\n    if (Record->hasAttrs()) {\n      CheckAlignasUnderalignment(Record);\n\n      if (const MSInheritanceAttr *IA = Record->getAttr<MSInheritanceAttr>())\n        checkMSInheritanceAttrOnDefinition(cast<CXXRecordDecl>(Record),\n                                           IA->getRange(), IA->getBestCase(),\n                                           IA->getInheritanceModel());\n    }\n\n    // Check if the structure/union declaration is a type that can have zero\n    // size in C. For C this is a language extension, for C++ it may cause\n    // compatibility problems.\n    bool CheckForZeroSize;\n    if (!getLangOpts().CPlusPlus) {\n      CheckForZeroSize = true;\n    } else {\n      // For C++ filter out types that cannot be referenced in C code.\n      CXXRecordDecl *CXXRecord = cast<CXXRecordDecl>(Record);\n      CheckForZeroSize =\n          CXXRecord->getLexicalDeclContext()->isExternCContext() &&\n          !CXXRecord->isDependentType() && !inTemplateInstantiation() &&\n          CXXRecord->isCLike();\n    }\n    if (CheckForZeroSize) {\n      bool ZeroSize = true;\n      bool IsEmpty = true;\n      unsigned NonBitFields = 0;\n      for (RecordDecl::field_iterator I = Record->field_begin(),\n                                      E = Record->field_end();\n           (NonBitFields == 0 || ZeroSize) && I != E; ++I) {\n        IsEmpty = false;\n        if (I->isUnnamedBitfield()) {\n          if (!I->isZeroLengthBitField(Context))\n            ZeroSize = false;\n        } else {\n          ++NonBitFields;\n          QualType FieldType = I->getType();\n          if (FieldType->isIncompleteType() ||\n              !Context.getTypeSizeInChars(FieldType).isZero())\n            ZeroSize = false;\n        }\n      }\n\n      // Empty structs are an extension in C (C99 6.7.2.1p7). They are\n      // allowed in C++, but warn if its declaration is inside\n      // extern \"C\" block.\n      if (ZeroSize) {\n        Diag(RecLoc, getLangOpts().CPlusPlus ?\n                         diag::warn_zero_size_struct_union_in_extern_c :\n                         diag::warn_zero_size_struct_union_compat)\n          << IsEmpty << Record->isUnion() << (NonBitFields > 1);\n      }\n\n      // Structs without named members are extension in C (C99 6.7.2.1p7),\n      // but are accepted by GCC.\n      if (NonBitFields == 0 && !getLangOpts().CPlusPlus) {\n        Diag(RecLoc, IsEmpty ? diag::ext_empty_struct_union :\n                               diag::ext_no_named_members_in_struct_union)\n          << Record->isUnion();\n      }\n    }\n  } else {\n    ObjCIvarDecl **ClsFields =\n      reinterpret_cast<ObjCIvarDecl**>(RecFields.data());\n    if (ObjCInterfaceDecl *ID = dyn_cast<ObjCInterfaceDecl>(EnclosingDecl)) {\n      ID->setEndOfDefinitionLoc(RBrac);\n      // Add ivar's to class's DeclContext.\n      for (unsigned i = 0, e = RecFields.size(); i != e; ++i) {\n        ClsFields[i]->setLexicalDeclContext(ID);\n        ID->addDecl(ClsFields[i]);\n      }\n      // Must enforce the rule that ivars in the base classes may not be\n      // duplicates.\n      if (ID->getSuperClass())\n        DiagnoseDuplicateIvars(ID, ID->getSuperClass());\n    } else if (ObjCImplementationDecl *IMPDecl =\n                  dyn_cast<ObjCImplementationDecl>(EnclosingDecl)) {\n      assert(IMPDecl && \"ActOnFields - missing ObjCImplementationDecl\");\n      for (unsigned I = 0, N = RecFields.size(); I != N; ++I)\n        // Ivar declared in @implementation never belongs to the implementation.\n        // Only it is in implementation's lexical context.\n        ClsFields[I]->setLexicalDeclContext(IMPDecl);\n      CheckImplementationIvars(IMPDecl, ClsFields, RecFields.size(), RBrac);\n      IMPDecl->setIvarLBraceLoc(LBrac);\n      IMPDecl->setIvarRBraceLoc(RBrac);\n    } else if (ObjCCategoryDecl *CDecl =\n                dyn_cast<ObjCCategoryDecl>(EnclosingDecl)) {\n      // case of ivars in class extension; all other cases have been\n      // reported as errors elsewhere.\n      // FIXME. Class extension does not have a LocEnd field.\n      // CDecl->setLocEnd(RBrac);\n      // Add ivar's to class extension's DeclContext.\n      // Diagnose redeclaration of private ivars.\n      ObjCInterfaceDecl *IDecl = CDecl->getClassInterface();\n      for (unsigned i = 0, e = RecFields.size(); i != e; ++i) {\n        if (IDecl) {\n          if (const ObjCIvarDecl *ClsIvar =\n              IDecl->getIvarDecl(ClsFields[i]->getIdentifier())) {\n            Diag(ClsFields[i]->getLocation(),\n                 diag::err_duplicate_ivar_declaration);\n            Diag(ClsIvar->getLocation(), diag::note_previous_definition);\n            continue;\n          }\n          for (const auto *Ext : IDecl->known_extensions()) {\n            if (const ObjCIvarDecl *ClsExtIvar\n                  = Ext->getIvarDecl(ClsFields[i]->getIdentifier())) {\n              Diag(ClsFields[i]->getLocation(),\n                   diag::err_duplicate_ivar_declaration);\n              Diag(ClsExtIvar->getLocation(), diag::note_previous_definition);\n              continue;\n            }\n          }\n        }\n        ClsFields[i]->setLexicalDeclContext(CDecl);\n        CDecl->addDecl(ClsFields[i]);\n      }\n      CDecl->setIvarLBraceLoc(LBrac);\n      CDecl->setIvarRBraceLoc(RBrac);\n    }\n  }\n}\n\n/// Determine whether the given integral value is representable within\n/// the given type T.\nstatic bool isRepresentableIntegerValue(ASTContext &Context,\n                                        llvm::APSInt &Value,\n                                        QualType T) {\n  assert((T->isIntegralType(Context) || T->isEnumeralType()) &&\n         \"Integral type required!\");\n  unsigned BitWidth = Context.getIntWidth(T);\n\n  if (Value.isUnsigned() || Value.isNonNegative()) {\n    if (T->isSignedIntegerOrEnumerationType())\n      --BitWidth;\n    return Value.getActiveBits() <= BitWidth;\n  }\n  return Value.getMinSignedBits() <= BitWidth;\n}\n\n// Given an integral type, return the next larger integral type\n// (or a NULL type of no such type exists).\nstatic QualType getNextLargerIntegralType(ASTContext &Context, QualType T) {\n  // FIXME: Int128/UInt128 support, which also needs to be introduced into\n  // enum checking below.\n  assert((T->isIntegralType(Context) ||\n         T->isEnumeralType()) && \"Integral type required!\");\n  const unsigned NumTypes = 4;\n  QualType SignedIntegralTypes[NumTypes] = {\n    Context.ShortTy, Context.IntTy, Context.LongTy, Context.LongLongTy\n  };\n  QualType UnsignedIntegralTypes[NumTypes] = {\n    Context.UnsignedShortTy, Context.UnsignedIntTy, Context.UnsignedLongTy,\n    Context.UnsignedLongLongTy\n  };\n\n  unsigned BitWidth = Context.getTypeSize(T);\n  QualType *Types = T->isSignedIntegerOrEnumerationType()? SignedIntegralTypes\n                                                        : UnsignedIntegralTypes;\n  for (unsigned I = 0; I != NumTypes; ++I)\n    if (Context.getTypeSize(Types[I]) > BitWidth)\n      return Types[I];\n\n  return QualType();\n}\n\nEnumConstantDecl *Sema::CheckEnumConstant(EnumDecl *Enum,\n                                          EnumConstantDecl *LastEnumConst,\n                                          SourceLocation IdLoc,\n                                          IdentifierInfo *Id,\n                                          Expr *Val) {\n  unsigned IntWidth = Context.getTargetInfo().getIntWidth();\n  llvm::APSInt EnumVal(IntWidth);\n  QualType EltTy;\n\n  if (Val && DiagnoseUnexpandedParameterPack(Val, UPPC_EnumeratorValue))\n    Val = nullptr;\n\n  if (Val)\n    Val = DefaultLvalueConversion(Val).get();\n\n  if (Val) {\n    if (Enum->isDependentType() || Val->isTypeDependent())\n      EltTy = Context.DependentTy;\n    else {\n      // FIXME: We don't allow folding in C++11 mode for an enum with a fixed\n      // underlying type, but do allow it in all other contexts.\n      if (getLangOpts().CPlusPlus11 && Enum->isFixed()) {\n        // C++11 [dcl.enum]p5: If the underlying type is fixed, [...] the\n        // constant-expression in the enumerator-definition shall be a converted\n        // constant expression of the underlying type.\n        EltTy = Enum->getIntegerType();\n        ExprResult Converted =\n          CheckConvertedConstantExpression(Val, EltTy, EnumVal,\n                                           CCEK_Enumerator);\n        if (Converted.isInvalid())\n          Val = nullptr;\n        else\n          Val = Converted.get();\n      } else if (!Val->isValueDependent() &&\n                 !(Val =\n                       VerifyIntegerConstantExpression(Val, &EnumVal, AllowFold)\n                           .get())) {\n        // C99 6.7.2.2p2: Make sure we have an integer constant expression.\n      } else {\n        if (Enum->isComplete()) {\n          EltTy = Enum->getIntegerType();\n\n          // In Obj-C and Microsoft mode, require the enumeration value to be\n          // representable in the underlying type of the enumeration. In C++11,\n          // we perform a non-narrowing conversion as part of converted constant\n          // expression checking.\n          if (!isRepresentableIntegerValue(Context, EnumVal, EltTy)) {\n            if (Context.getTargetInfo()\n                    .getTriple()\n                    .isWindowsMSVCEnvironment()) {\n              Diag(IdLoc, diag::ext_enumerator_too_large) << EltTy;\n            } else {\n              Diag(IdLoc, diag::err_enumerator_too_large) << EltTy;\n            }\n          }\n\n          // Cast to the underlying type.\n          Val = ImpCastExprToType(Val, EltTy,\n                                  EltTy->isBooleanType() ? CK_IntegralToBoolean\n                                                         : CK_IntegralCast)\n                    .get();\n        } else if (getLangOpts().CPlusPlus) {\n          // C++11 [dcl.enum]p5:\n          //   If the underlying type is not fixed, the type of each enumerator\n          //   is the type of its initializing value:\n          //     - If an initializer is specified for an enumerator, the\n          //       initializing value has the same type as the expression.\n          EltTy = Val->getType();\n        } else {\n          // C99 6.7.2.2p2:\n          //   The expression that defines the value of an enumeration constant\n          //   shall be an integer constant expression that has a value\n          //   representable as an int.\n\n          // Complain if the value is not representable in an int.\n          if (!isRepresentableIntegerValue(Context, EnumVal, Context.IntTy))\n            Diag(IdLoc, diag::ext_enum_value_not_int)\n              << EnumVal.toString(10) << Val->getSourceRange()\n              << (EnumVal.isUnsigned() || EnumVal.isNonNegative());\n          else if (!Context.hasSameType(Val->getType(), Context.IntTy)) {\n            // Force the type of the expression to 'int'.\n            Val = ImpCastExprToType(Val, Context.IntTy, CK_IntegralCast).get();\n          }\n          EltTy = Val->getType();\n        }\n      }\n    }\n  }\n\n  if (!Val) {\n    if (Enum->isDependentType())\n      EltTy = Context.DependentTy;\n    else if (!LastEnumConst) {\n      // C++0x [dcl.enum]p5:\n      //   If the underlying type is not fixed, the type of each enumerator\n      //   is the type of its initializing value:\n      //     - If no initializer is specified for the first enumerator, the\n      //       initializing value has an unspecified integral type.\n      //\n      // GCC uses 'int' for its unspecified integral type, as does\n      // C99 6.7.2.2p3.\n      if (Enum->isFixed()) {\n        EltTy = Enum->getIntegerType();\n      }\n      else {\n        EltTy = Context.IntTy;\n      }\n    } else {\n      // Assign the last value + 1.\n      EnumVal = LastEnumConst->getInitVal();\n      ++EnumVal;\n      EltTy = LastEnumConst->getType();\n\n      // Check for overflow on increment.\n      if (EnumVal < LastEnumConst->getInitVal()) {\n        // C++0x [dcl.enum]p5:\n        //   If the underlying type is not fixed, the type of each enumerator\n        //   is the type of its initializing value:\n        //\n        //     - Otherwise the type of the initializing value is the same as\n        //       the type of the initializing value of the preceding enumerator\n        //       unless the incremented value is not representable in that type,\n        //       in which case the type is an unspecified integral type\n        //       sufficient to contain the incremented value. If no such type\n        //       exists, the program is ill-formed.\n        QualType T = getNextLargerIntegralType(Context, EltTy);\n        if (T.isNull() || Enum->isFixed()) {\n          // There is no integral type larger enough to represent this\n          // value. Complain, then allow the value to wrap around.\n          EnumVal = LastEnumConst->getInitVal();\n          EnumVal = EnumVal.zext(EnumVal.getBitWidth() * 2);\n          ++EnumVal;\n          if (Enum->isFixed())\n            // When the underlying type is fixed, this is ill-formed.\n            Diag(IdLoc, diag::err_enumerator_wrapped)\n              << EnumVal.toString(10)\n              << EltTy;\n          else\n            Diag(IdLoc, diag::ext_enumerator_increment_too_large)\n              << EnumVal.toString(10);\n        } else {\n          EltTy = T;\n        }\n\n        // Retrieve the last enumerator's value, extent that type to the\n        // type that is supposed to be large enough to represent the incremented\n        // value, then increment.\n        EnumVal = LastEnumConst->getInitVal();\n        EnumVal.setIsSigned(EltTy->isSignedIntegerOrEnumerationType());\n        EnumVal = EnumVal.zextOrTrunc(Context.getIntWidth(EltTy));\n        ++EnumVal;\n\n        // If we're not in C++, diagnose the overflow of enumerator values,\n        // which in C99 means that the enumerator value is not representable in\n        // an int (C99 6.7.2.2p2). However, we support GCC's extension that\n        // permits enumerator values that are representable in some larger\n        // integral type.\n        if (!getLangOpts().CPlusPlus && !T.isNull())\n          Diag(IdLoc, diag::warn_enum_value_overflow);\n      } else if (!getLangOpts().CPlusPlus &&\n                 !isRepresentableIntegerValue(Context, EnumVal, EltTy)) {\n        // Enforce C99 6.7.2.2p2 even when we compute the next value.\n        Diag(IdLoc, diag::ext_enum_value_not_int)\n          << EnumVal.toString(10) << 1;\n      }\n    }\n  }\n\n  if (!EltTy->isDependentType()) {\n    // Make the enumerator value match the signedness and size of the\n    // enumerator's type.\n    EnumVal = EnumVal.extOrTrunc(Context.getIntWidth(EltTy));\n    EnumVal.setIsSigned(EltTy->isSignedIntegerOrEnumerationType());\n  }\n\n  return EnumConstantDecl::Create(Context, Enum, IdLoc, Id, EltTy,\n                                  Val, EnumVal);\n}\n\nSema::SkipBodyInfo Sema::shouldSkipAnonEnumBody(Scope *S, IdentifierInfo *II,\n                                                SourceLocation IILoc) {\n  if (!(getLangOpts().Modules || getLangOpts().ModulesLocalVisibility) ||\n      !getLangOpts().CPlusPlus)\n    return SkipBodyInfo();\n\n  // We have an anonymous enum definition. Look up the first enumerator to\n  // determine if we should merge the definition with an existing one and\n  // skip the body.\n  NamedDecl *PrevDecl = LookupSingleName(S, II, IILoc, LookupOrdinaryName,\n                                         forRedeclarationInCurContext());\n  auto *PrevECD = dyn_cast_or_null<EnumConstantDecl>(PrevDecl);\n  if (!PrevECD)\n    return SkipBodyInfo();\n\n  EnumDecl *PrevED = cast<EnumDecl>(PrevECD->getDeclContext());\n  NamedDecl *Hidden;\n  if (!PrevED->getDeclName() && !hasVisibleDefinition(PrevED, &Hidden)) {\n    SkipBodyInfo Skip;\n    Skip.Previous = Hidden;\n    return Skip;\n  }\n\n  return SkipBodyInfo();\n}\n\nDecl *Sema::ActOnEnumConstant(Scope *S, Decl *theEnumDecl, Decl *lastEnumConst,\n                              SourceLocation IdLoc, IdentifierInfo *Id,\n                              const ParsedAttributesView &Attrs,\n                              SourceLocation EqualLoc, Expr *Val) {\n  EnumDecl *TheEnumDecl = cast<EnumDecl>(theEnumDecl);\n  EnumConstantDecl *LastEnumConst =\n    cast_or_null<EnumConstantDecl>(lastEnumConst);\n\n  // The scope passed in may not be a decl scope.  Zip up the scope tree until\n  // we find one that is.\n  S = getNonFieldDeclScope(S);\n\n  // Verify that there isn't already something declared with this name in this\n  // scope.\n  LookupResult R(*this, Id, IdLoc, LookupOrdinaryName, ForVisibleRedeclaration);\n  LookupName(R, S);\n  NamedDecl *PrevDecl = R.getAsSingle<NamedDecl>();\n\n  if (PrevDecl && PrevDecl->isTemplateParameter()) {\n    // Maybe we will complain about the shadowed template parameter.\n    DiagnoseTemplateParameterShadow(IdLoc, PrevDecl);\n    // Just pretend that we didn't see the previous declaration.\n    PrevDecl = nullptr;\n  }\n\n  // C++ [class.mem]p15:\n  // If T is the name of a class, then each of the following shall have a name\n  // different from T:\n  // - every enumerator of every member of class T that is an unscoped\n  // enumerated type\n  if (getLangOpts().CPlusPlus && !TheEnumDecl->isScoped())\n    DiagnoseClassNameShadow(TheEnumDecl->getDeclContext(),\n                            DeclarationNameInfo(Id, IdLoc));\n\n  EnumConstantDecl *New =\n    CheckEnumConstant(TheEnumDecl, LastEnumConst, IdLoc, Id, Val);\n  if (!New)\n    return nullptr;\n\n  if (PrevDecl) {\n    if (!TheEnumDecl->isScoped() && isa<ValueDecl>(PrevDecl)) {\n      // Check for other kinds of shadowing not already handled.\n      CheckShadow(New, PrevDecl, R);\n    }\n\n    // When in C++, we may get a TagDecl with the same name; in this case the\n    // enum constant will 'hide' the tag.\n    assert((getLangOpts().CPlusPlus || !isa<TagDecl>(PrevDecl)) &&\n           \"Received TagDecl when not in C++!\");\n    if (!isa<TagDecl>(PrevDecl) && isDeclInScope(PrevDecl, CurContext, S)) {\n      if (isa<EnumConstantDecl>(PrevDecl))\n        Diag(IdLoc, diag::err_redefinition_of_enumerator) << Id;\n      else\n        Diag(IdLoc, diag::err_redefinition) << Id;\n      notePreviousDefinition(PrevDecl, IdLoc);\n      return nullptr;\n    }\n  }\n\n  // Process attributes.\n  ProcessDeclAttributeList(S, New, Attrs);\n  AddPragmaAttributes(S, New);\n\n  // Register this decl in the current scope stack.\n  New->setAccess(TheEnumDecl->getAccess());\n  PushOnScopeChains(New, S);\n\n  ActOnDocumentableDecl(New);\n\n  return New;\n}\n\n// Returns true when the enum initial expression does not trigger the\n// duplicate enum warning.  A few common cases are exempted as follows:\n// Element2 = Element1\n// Element2 = Element1 + 1\n// Element2 = Element1 - 1\n// Where Element2 and Element1 are from the same enum.\nstatic bool ValidDuplicateEnum(EnumConstantDecl *ECD, EnumDecl *Enum) {\n  Expr *InitExpr = ECD->getInitExpr();\n  if (!InitExpr)\n    return true;\n  InitExpr = InitExpr->IgnoreImpCasts();\n\n  if (BinaryOperator *BO = dyn_cast<BinaryOperator>(InitExpr)) {\n    if (!BO->isAdditiveOp())\n      return true;\n    IntegerLiteral *IL = dyn_cast<IntegerLiteral>(BO->getRHS());\n    if (!IL)\n      return true;\n    if (IL->getValue() != 1)\n      return true;\n\n    InitExpr = BO->getLHS();\n  }\n\n  // This checks if the elements are from the same enum.\n  DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(InitExpr);\n  if (!DRE)\n    return true;\n\n  EnumConstantDecl *EnumConstant = dyn_cast<EnumConstantDecl>(DRE->getDecl());\n  if (!EnumConstant)\n    return true;\n\n  if (cast<EnumDecl>(TagDecl::castFromDeclContext(ECD->getDeclContext())) !=\n      Enum)\n    return true;\n\n  return false;\n}\n\n// Emits a warning when an element is implicitly set a value that\n// a previous element has already been set to.\nstatic void CheckForDuplicateEnumValues(Sema &S, ArrayRef<Decl *> Elements,\n                                        EnumDecl *Enum, QualType EnumType) {\n  // Avoid anonymous enums\n  if (!Enum->getIdentifier())\n    return;\n\n  // Only check for small enums.\n  if (Enum->getNumPositiveBits() > 63 || Enum->getNumNegativeBits() > 64)\n    return;\n\n  if (S.Diags.isIgnored(diag::warn_duplicate_enum_values, Enum->getLocation()))\n    return;\n\n  typedef SmallVector<EnumConstantDecl *, 3> ECDVector;\n  typedef SmallVector<std::unique_ptr<ECDVector>, 3> DuplicatesVector;\n\n  typedef llvm::PointerUnion<EnumConstantDecl*, ECDVector*> DeclOrVector;\n\n  // DenseMaps cannot contain the all ones int64_t value, so use unordered_map.\n  typedef std::unordered_map<int64_t, DeclOrVector> ValueToVectorMap;\n\n  // Use int64_t as a key to avoid needing special handling for map keys.\n  auto EnumConstantToKey = [](const EnumConstantDecl *D) {\n    llvm::APSInt Val = D->getInitVal();\n    return Val.isSigned() ? Val.getSExtValue() : Val.getZExtValue();\n  };\n\n  DuplicatesVector DupVector;\n  ValueToVectorMap EnumMap;\n\n  // Populate the EnumMap with all values represented by enum constants without\n  // an initializer.\n  for (auto *Element : Elements) {\n    EnumConstantDecl *ECD = cast_or_null<EnumConstantDecl>(Element);\n\n    // Null EnumConstantDecl means a previous diagnostic has been emitted for\n    // this constant.  Skip this enum since it may be ill-formed.\n    if (!ECD) {\n      return;\n    }\n\n    // Constants with initalizers are handled in the next loop.\n    if (ECD->getInitExpr())\n      continue;\n\n    // Duplicate values are handled in the next loop.\n    EnumMap.insert({EnumConstantToKey(ECD), ECD});\n  }\n\n  if (EnumMap.size() == 0)\n    return;\n\n  // Create vectors for any values that has duplicates.\n  for (auto *Element : Elements) {\n    // The last loop returned if any constant was null.\n    EnumConstantDecl *ECD = cast<EnumConstantDecl>(Element);\n    if (!ValidDuplicateEnum(ECD, Enum))\n      continue;\n\n    auto Iter = EnumMap.find(EnumConstantToKey(ECD));\n    if (Iter == EnumMap.end())\n      continue;\n\n    DeclOrVector& Entry = Iter->second;\n    if (EnumConstantDecl *D = Entry.dyn_cast<EnumConstantDecl*>()) {\n      // Ensure constants are different.\n      if (D == ECD)\n        continue;\n\n      // Create new vector and push values onto it.\n      auto Vec = std::make_unique<ECDVector>();\n      Vec->push_back(D);\n      Vec->push_back(ECD);\n\n      // Update entry to point to the duplicates vector.\n      Entry = Vec.get();\n\n      // Store the vector somewhere we can consult later for quick emission of\n      // diagnostics.\n      DupVector.emplace_back(std::move(Vec));\n      continue;\n    }\n\n    ECDVector *Vec = Entry.get<ECDVector*>();\n    // Make sure constants are not added more than once.\n    if (*Vec->begin() == ECD)\n      continue;\n\n    Vec->push_back(ECD);\n  }\n\n  // Emit diagnostics.\n  for (const auto &Vec : DupVector) {\n    assert(Vec->size() > 1 && \"ECDVector should have at least 2 elements.\");\n\n    // Emit warning for one enum constant.\n    auto *FirstECD = Vec->front();\n    S.Diag(FirstECD->getLocation(), diag::warn_duplicate_enum_values)\n      << FirstECD << FirstECD->getInitVal().toString(10)\n      << FirstECD->getSourceRange();\n\n    // Emit one note for each of the remaining enum constants with\n    // the same value.\n    for (auto *ECD : llvm::make_range(Vec->begin() + 1, Vec->end()))\n      S.Diag(ECD->getLocation(), diag::note_duplicate_element)\n        << ECD << ECD->getInitVal().toString(10)\n        << ECD->getSourceRange();\n  }\n}\n\nbool Sema::IsValueInFlagEnum(const EnumDecl *ED, const llvm::APInt &Val,\n                             bool AllowMask) const {\n  assert(ED->isClosedFlag() && \"looking for value in non-flag or open enum\");\n  assert(ED->isCompleteDefinition() && \"expected enum definition\");\n\n  auto R = FlagBitsCache.insert(std::make_pair(ED, llvm::APInt()));\n  llvm::APInt &FlagBits = R.first->second;\n\n  if (R.second) {\n    for (auto *E : ED->enumerators()) {\n      const auto &EVal = E->getInitVal();\n      // Only single-bit enumerators introduce new flag values.\n      if (EVal.isPowerOf2())\n        FlagBits = FlagBits.zextOrSelf(EVal.getBitWidth()) | EVal;\n    }\n  }\n\n  // A value is in a flag enum if either its bits are a subset of the enum's\n  // flag bits (the first condition) or we are allowing masks and the same is\n  // true of its complement (the second condition). When masks are allowed, we\n  // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.\n  //\n  // While it's true that any value could be used as a mask, the assumption is\n  // that a mask will have all of the insignificant bits set. Anything else is\n  // likely a logic error.\n  llvm::APInt FlagMask = ~FlagBits.zextOrTrunc(Val.getBitWidth());\n  return !(FlagMask & Val) || (AllowMask && !(FlagMask & ~Val));\n}\n\nvoid Sema::ActOnEnumBody(SourceLocation EnumLoc, SourceRange BraceRange,\n                         Decl *EnumDeclX, ArrayRef<Decl *> Elements, Scope *S,\n                         const ParsedAttributesView &Attrs) {\n  EnumDecl *Enum = cast<EnumDecl>(EnumDeclX);\n  QualType EnumType = Context.getTypeDeclType(Enum);\n\n  ProcessDeclAttributeList(S, Enum, Attrs);\n\n  if (Enum->isDependentType()) {\n    for (unsigned i = 0, e = Elements.size(); i != e; ++i) {\n      EnumConstantDecl *ECD =\n        cast_or_null<EnumConstantDecl>(Elements[i]);\n      if (!ECD) continue;\n\n      ECD->setType(EnumType);\n    }\n\n    Enum->completeDefinition(Context.DependentTy, Context.DependentTy, 0, 0);\n    return;\n  }\n\n  // TODO: If the result value doesn't fit in an int, it must be a long or long\n  // long value.  ISO C does not support this, but GCC does as an extension,\n  // emit a warning.\n  unsigned IntWidth = Context.getTargetInfo().getIntWidth();\n  unsigned CharWidth = Context.getTargetInfo().getCharWidth();\n  unsigned ShortWidth = Context.getTargetInfo().getShortWidth();\n\n  // Verify that all the values are okay, compute the size of the values, and\n  // reverse the list.\n  unsigned NumNegativeBits = 0;\n  unsigned NumPositiveBits = 0;\n\n  // Keep track of whether all elements have type int.\n  bool AllElementsInt = true;\n\n  for (unsigned i = 0, e = Elements.size(); i != e; ++i) {\n    EnumConstantDecl *ECD =\n      cast_or_null<EnumConstantDecl>(Elements[i]);\n    if (!ECD) continue;  // Already issued a diagnostic.\n\n    const llvm::APSInt &InitVal = ECD->getInitVal();\n\n    // Keep track of the size of positive and negative values.\n    if (InitVal.isUnsigned() || InitVal.isNonNegative())\n      NumPositiveBits = std::max(NumPositiveBits,\n                                 (unsigned)InitVal.getActiveBits());\n    else\n      NumNegativeBits = std::max(NumNegativeBits,\n                                 (unsigned)InitVal.getMinSignedBits());\n\n    // Keep track of whether every enum element has type int (very common).\n    if (AllElementsInt)\n      AllElementsInt = ECD->getType() == Context.IntTy;\n  }\n\n  // Figure out the type that should be used for this enum.\n  QualType BestType;\n  unsigned BestWidth;\n\n  // C++0x N3000 [conv.prom]p3:\n  //   An rvalue of an unscoped enumeration type whose underlying\n  //   type is not fixed can be converted to an rvalue of the first\n  //   of the following types that can represent all the values of\n  //   the enumeration: int, unsigned int, long int, unsigned long\n  //   int, long long int, or unsigned long long int.\n  // C99 6.4.4.3p2:\n  //   An identifier declared as an enumeration constant has type int.\n  // The C99 rule is modified by a gcc extension\n  QualType BestPromotionType;\n\n  bool Packed = Enum->hasAttr<PackedAttr>();\n  // -fshort-enums is the equivalent to specifying the packed attribute on all\n  // enum definitions.\n  if (LangOpts.ShortEnums)\n    Packed = true;\n\n  // If the enum already has a type because it is fixed or dictated by the\n  // target, promote that type instead of analyzing the enumerators.\n  if (Enum->isComplete()) {\n    BestType = Enum->getIntegerType();\n    if (BestType->isPromotableIntegerType())\n      BestPromotionType = Context.getPromotedIntegerType(BestType);\n    else\n      BestPromotionType = BestType;\n\n    BestWidth = Context.getIntWidth(BestType);\n  }\n  else if (NumNegativeBits) {\n    // If there is a negative value, figure out the smallest integer type (of\n    // int/long/longlong) that fits.\n    // If it's packed, check also if it fits a char or a short.\n    if (Packed && NumNegativeBits <= CharWidth && NumPositiveBits < CharWidth) {\n      BestType = Context.SignedCharTy;\n      BestWidth = CharWidth;\n    } else if (Packed && NumNegativeBits <= ShortWidth &&\n               NumPositiveBits < ShortWidth) {\n      BestType = Context.ShortTy;\n      BestWidth = ShortWidth;\n    } else if (NumNegativeBits <= IntWidth && NumPositiveBits < IntWidth) {\n      BestType = Context.IntTy;\n      BestWidth = IntWidth;\n    } else {\n      BestWidth = Context.getTargetInfo().getLongWidth();\n\n      if (NumNegativeBits <= BestWidth && NumPositiveBits < BestWidth) {\n        BestType = Context.LongTy;\n      } else {\n        BestWidth = Context.getTargetInfo().getLongLongWidth();\n\n        if (NumNegativeBits > BestWidth || NumPositiveBits >= BestWidth)\n          Diag(Enum->getLocation(), diag::ext_enum_too_large);\n        BestType = Context.LongLongTy;\n      }\n    }\n    BestPromotionType = (BestWidth <= IntWidth ? Context.IntTy : BestType);\n  } else {\n    // If there is no negative value, figure out the smallest type that fits\n    // all of the enumerator values.\n    // If it's packed, check also if it fits a char or a short.\n    if (Packed && NumPositiveBits <= CharWidth) {\n      BestType = Context.UnsignedCharTy;\n      BestPromotionType = Context.IntTy;\n      BestWidth = CharWidth;\n    } else if (Packed && NumPositiveBits <= ShortWidth) {\n      BestType = Context.UnsignedShortTy;\n      BestPromotionType = Context.IntTy;\n      BestWidth = ShortWidth;\n    } else if (NumPositiveBits <= IntWidth) {\n      BestType = Context.UnsignedIntTy;\n      BestWidth = IntWidth;\n      BestPromotionType\n        = (NumPositiveBits == BestWidth || !getLangOpts().CPlusPlus)\n                           ? Context.UnsignedIntTy : Context.IntTy;\n    } else if (NumPositiveBits <=\n               (BestWidth = Context.getTargetInfo().getLongWidth())) {\n      BestType = Context.UnsignedLongTy;\n      BestPromotionType\n        = (NumPositiveBits == BestWidth || !getLangOpts().CPlusPlus)\n                           ? Context.UnsignedLongTy : Context.LongTy;\n    } else {\n      BestWidth = Context.getTargetInfo().getLongLongWidth();\n      assert(NumPositiveBits <= BestWidth &&\n             \"How could an initializer get larger than ULL?\");\n      BestType = Context.UnsignedLongLongTy;\n      BestPromotionType\n        = (NumPositiveBits == BestWidth || !getLangOpts().CPlusPlus)\n                           ? Context.UnsignedLongLongTy : Context.LongLongTy;\n    }\n  }\n\n  // Loop over all of the enumerator constants, changing their types to match\n  // the type of the enum if needed.\n  for (auto *D : Elements) {\n    auto *ECD = cast_or_null<EnumConstantDecl>(D);\n    if (!ECD) continue;  // Already issued a diagnostic.\n\n    // Standard C says the enumerators have int type, but we allow, as an\n    // extension, the enumerators to be larger than int size.  If each\n    // enumerator value fits in an int, type it as an int, otherwise type it the\n    // same as the enumerator decl itself.  This means that in \"enum { X = 1U }\"\n    // that X has type 'int', not 'unsigned'.\n\n    // Determine whether the value fits into an int.\n    llvm::APSInt InitVal = ECD->getInitVal();\n\n    // If it fits into an integer type, force it.  Otherwise force it to match\n    // the enum decl type.\n    QualType NewTy;\n    unsigned NewWidth;\n    bool NewSign;\n    if (!getLangOpts().CPlusPlus &&\n        !Enum->isFixed() &&\n        isRepresentableIntegerValue(Context, InitVal, Context.IntTy)) {\n      NewTy = Context.IntTy;\n      NewWidth = IntWidth;\n      NewSign = true;\n    } else if (ECD->getType() == BestType) {\n      // Already the right type!\n      if (getLangOpts().CPlusPlus)\n        // C++ [dcl.enum]p4: Following the closing brace of an\n        // enum-specifier, each enumerator has the type of its\n        // enumeration.\n        ECD->setType(EnumType);\n      continue;\n    } else {\n      NewTy = BestType;\n      NewWidth = BestWidth;\n      NewSign = BestType->isSignedIntegerOrEnumerationType();\n    }\n\n    // Adjust the APSInt value.\n    InitVal = InitVal.extOrTrunc(NewWidth);\n    InitVal.setIsSigned(NewSign);\n    ECD->setInitVal(InitVal);\n\n    // Adjust the Expr initializer and type.\n    if (ECD->getInitExpr() &&\n        !Context.hasSameType(NewTy, ECD->getInitExpr()->getType()))\n      ECD->setInitExpr(ImplicitCastExpr::Create(\n          Context, NewTy, CK_IntegralCast, ECD->getInitExpr(),\n          /*base paths*/ nullptr, VK_RValue, FPOptionsOverride()));\n    if (getLangOpts().CPlusPlus)\n      // C++ [dcl.enum]p4: Following the closing brace of an\n      // enum-specifier, each enumerator has the type of its\n      // enumeration.\n      ECD->setType(EnumType);\n    else\n      ECD->setType(NewTy);\n  }\n\n  Enum->completeDefinition(BestType, BestPromotionType,\n                           NumPositiveBits, NumNegativeBits);\n\n  CheckForDuplicateEnumValues(*this, Elements, Enum, EnumType);\n\n  if (Enum->isClosedFlag()) {\n    for (Decl *D : Elements) {\n      EnumConstantDecl *ECD = cast_or_null<EnumConstantDecl>(D);\n      if (!ECD) continue;  // Already issued a diagnostic.\n\n      llvm::APSInt InitVal = ECD->getInitVal();\n      if (InitVal != 0 && !InitVal.isPowerOf2() &&\n          !IsValueInFlagEnum(Enum, InitVal, true))\n        Diag(ECD->getLocation(), diag::warn_flag_enum_constant_out_of_range)\n          << ECD << Enum;\n    }\n  }\n\n  // Now that the enum type is defined, ensure it's not been underaligned.\n  if (Enum->hasAttrs())\n    CheckAlignasUnderalignment(Enum);\n}\n\nDecl *Sema::ActOnFileScopeAsmDecl(Expr *expr,\n                                  SourceLocation StartLoc,\n                                  SourceLocation EndLoc) {\n  StringLiteral *AsmString = cast<StringLiteral>(expr);\n\n  FileScopeAsmDecl *New = FileScopeAsmDecl::Create(Context, CurContext,\n                                                   AsmString, StartLoc,\n                                                   EndLoc);\n  CurContext->addDecl(New);\n  return New;\n}\n\nvoid Sema::ActOnPragmaRedefineExtname(IdentifierInfo* Name,\n                                      IdentifierInfo* AliasName,\n                                      SourceLocation PragmaLoc,\n                                      SourceLocation NameLoc,\n                                      SourceLocation AliasNameLoc) {\n  NamedDecl *PrevDecl = LookupSingleName(TUScope, Name, NameLoc,\n                                         LookupOrdinaryName);\n  AttributeCommonInfo Info(AliasName, SourceRange(AliasNameLoc),\n                           AttributeCommonInfo::AS_Pragma);\n  AsmLabelAttr *Attr = AsmLabelAttr::CreateImplicit(\n      Context, AliasName->getName(), /*LiteralLabel=*/true, Info);\n\n  // If a declaration that:\n  // 1) declares a function or a variable\n  // 2) has external linkage\n  // already exists, add a label attribute to it.\n  if (PrevDecl && (isa<FunctionDecl>(PrevDecl) || isa<VarDecl>(PrevDecl))) {\n    if (isDeclExternC(PrevDecl))\n      PrevDecl->addAttr(Attr);\n    else\n      Diag(PrevDecl->getLocation(), diag::warn_redefine_extname_not_applied)\n          << /*Variable*/(isa<FunctionDecl>(PrevDecl) ? 0 : 1) << PrevDecl;\n  // Otherwise, add a label atttibute to ExtnameUndeclaredIdentifiers.\n  } else\n    (void)ExtnameUndeclaredIdentifiers.insert(std::make_pair(Name, Attr));\n}\n\nvoid Sema::ActOnPragmaWeakID(IdentifierInfo* Name,\n                             SourceLocation PragmaLoc,\n                             SourceLocation NameLoc) {\n  Decl *PrevDecl = LookupSingleName(TUScope, Name, NameLoc, LookupOrdinaryName);\n\n  if (PrevDecl) {\n    PrevDecl->addAttr(WeakAttr::CreateImplicit(Context, PragmaLoc, AttributeCommonInfo::AS_Pragma));\n  } else {\n    (void)WeakUndeclaredIdentifiers.insert(\n      std::pair<IdentifierInfo*,WeakInfo>\n        (Name, WeakInfo((IdentifierInfo*)nullptr, NameLoc)));\n  }\n}\n\nvoid Sema::ActOnPragmaWeakAlias(IdentifierInfo* Name,\n                                IdentifierInfo* AliasName,\n                                SourceLocation PragmaLoc,\n                                SourceLocation NameLoc,\n                                SourceLocation AliasNameLoc) {\n  Decl *PrevDecl = LookupSingleName(TUScope, AliasName, AliasNameLoc,\n                                    LookupOrdinaryName);\n  WeakInfo W = WeakInfo(Name, NameLoc);\n\n  if (PrevDecl && (isa<FunctionDecl>(PrevDecl) || isa<VarDecl>(PrevDecl))) {\n    if (!PrevDecl->hasAttr<AliasAttr>())\n      if (NamedDecl *ND = dyn_cast<NamedDecl>(PrevDecl))\n        DeclApplyPragmaWeak(TUScope, ND, W);\n  } else {\n    (void)WeakUndeclaredIdentifiers.insert(\n      std::pair<IdentifierInfo*,WeakInfo>(AliasName, W));\n  }\n}\n\nDecl *Sema::getObjCDeclContext() const {\n  return (dyn_cast_or_null<ObjCContainerDecl>(CurContext));\n}\n\nSema::FunctionEmissionStatus Sema::getEmissionStatus(FunctionDecl *FD,\n                                                     bool Final) {\n  assert(FD && \"Expected non-null FunctionDecl\");\n\n  // SYCL functions can be template, so we check if they have appropriate\n  // attribute prior to checking if it is a template.\n  if (LangOpts.SYCLIsDevice && FD->hasAttr<SYCLKernelAttr>())\n    return FunctionEmissionStatus::Emitted;\n\n  // Templates are emitted when they're instantiated.\n  if (FD->isDependentContext())\n    return FunctionEmissionStatus::TemplateDiscarded;\n\n  // Check whether this function is an externally visible definition.\n  auto IsEmittedForExternalSymbol = [this, FD]() {\n    // We have to check the GVA linkage of the function's *definition* -- if we\n    // only have a declaration, we don't know whether or not the function will\n    // be emitted, because (say) the definition could include \"inline\".\n    FunctionDecl *Def = FD->getDefinition();\n\n    return Def && !isDiscardableGVALinkage(\n                      getASTContext().GetGVALinkageForFunction(Def));\n  };\n\n  if (LangOpts.OpenMPIsDevice) {\n    // In OpenMP device mode we will not emit host only functions, or functions\n    // we don't need due to their linkage.\n    Optional<OMPDeclareTargetDeclAttr::DevTypeTy> DevTy =\n        OMPDeclareTargetDeclAttr::getDeviceType(FD->getCanonicalDecl());\n    // DevTy may be changed later by\n    //  #pragma omp declare target to(*) device_type(*).\n    // Therefore DevTyhaving no value does not imply host. The emission status\n    // will be checked again at the end of compilation unit with Final = true.\n    if (DevTy.hasValue())\n      if (*DevTy == OMPDeclareTargetDeclAttr::DT_Host)\n        return FunctionEmissionStatus::OMPDiscarded;\n    // If we have an explicit value for the device type, or we are in a target\n    // declare context, we need to emit all extern and used symbols.\n    if (isInOpenMPDeclareTargetContext() || DevTy.hasValue())\n      if (IsEmittedForExternalSymbol())\n        return FunctionEmissionStatus::Emitted;\n    // Device mode only emits what it must, if it wasn't tagged yet and needed,\n    // we'll omit it.\n    if (Final)\n      return FunctionEmissionStatus::OMPDiscarded;\n  } else if (LangOpts.OpenMP > 45) {\n    // In OpenMP host compilation prior to 5.0 everything was an emitted host\n    // function. In 5.0, no_host was introduced which might cause a function to\n    // be ommitted.\n    Optional<OMPDeclareTargetDeclAttr::DevTypeTy> DevTy =\n        OMPDeclareTargetDeclAttr::getDeviceType(FD->getCanonicalDecl());\n    if (DevTy.hasValue())\n      if (*DevTy == OMPDeclareTargetDeclAttr::DT_NoHost)\n        return FunctionEmissionStatus::OMPDiscarded;\n  }\n\n  if (Final && LangOpts.OpenMP && !LangOpts.CUDA)\n    return FunctionEmissionStatus::Emitted;\n\n  if (LangOpts.CUDA) {\n    // When compiling for device, host functions are never emitted.  Similarly,\n    // when compiling for host, device and global functions are never emitted.\n    // (Technically, we do emit a host-side stub for global functions, but this\n    // doesn't count for our purposes here.)\n    Sema::CUDAFunctionTarget T = IdentifyCUDATarget(FD);\n    if (LangOpts.CUDAIsDevice && T == Sema::CFT_Host)\n      return FunctionEmissionStatus::CUDADiscarded;\n    if (!LangOpts.CUDAIsDevice &&\n        (T == Sema::CFT_Device || T == Sema::CFT_Global))\n      return FunctionEmissionStatus::CUDADiscarded;\n\n    if (IsEmittedForExternalSymbol())\n      return FunctionEmissionStatus::Emitted;\n  }\n\n  // Otherwise, the function is known-emitted if it's in our set of\n  // known-emitted functions.\n  return FunctionEmissionStatus::Unknown;\n}\n\nbool Sema::shouldIgnoreInHostDeviceCheck(FunctionDecl *Callee) {\n  // Host-side references to a __global__ function refer to the stub, so the\n  // function itself is never emitted and therefore should not be marked.\n  // If we have host fn calls kernel fn calls host+device, the HD function\n  // does not get instantiated on the host. We model this by omitting at the\n  // call to the kernel from the callgraph. This ensures that, when compiling\n  // for host, only HD functions actually called from the host get marked as\n  // known-emitted.\n  return LangOpts.CUDA && !LangOpts.CUDAIsDevice &&\n         IdentifyCUDATarget(Callee) == CFT_Global;\n}\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 20, "line": 3154}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "7768f23fca65271163a9726b330ffee3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 20, "line": 3154}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "e7b2f82c9eadfd99293a38956d62212e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 20, "line": 3194}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "4ad5f9bf157c89ad1fb23d788c40952a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 20, "line": 3194}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "a8f22d16c2e2c383a32d369f969bec6c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 20, "line": 14294}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "8f01df6bcdc5a01ca7e01fa95dcd8a03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 20, "line": 14294}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "669f49412f2da40ba5c100ca441f37d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 17915}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "f93c120b8d6dc7fcc53395974c3c86d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 17915}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDecl.cpp", "reportHash": "ef250d9a1067ee336cf05f12e37aa942", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
