<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "content": "/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\\\n|*                                                                            *|\n|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|\n|* Exceptions.                                                                *|\n|* See https://llvm.org/LICENSE.txt for license information.                  *|\n|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|\n|*                                                                            *|\n|*===----------------------------------------------------------------------===*|\n|*                                                                            *|\n|* This header provides a public interface to a Clang library for extracting  *|\n|* high-level symbol information from source files without exposing the full  *|\n|* Clang C++ API.                                                             *|\n|*                                                                            *|\n\\*===----------------------------------------------------------------------===*/\n\n#ifndef LLVM_CLANG_C_INDEX_H\n#define LLVM_CLANG_C_INDEX_H\n\n#include <time.h>\n\n#include \"clang-c/BuildSystem.h\"\n#include \"clang-c/CXErrorCode.h\"\n#include \"clang-c/CXString.h\"\n#include \"clang-c/ExternC.h\"\n#include \"clang-c/Platform.h\"\n\n/**\n * The version constants for the libclang API.\n * CINDEX_VERSION_MINOR should increase when there are API additions.\n * CINDEX_VERSION_MAJOR is intended for \"major\" source/ABI breaking changes.\n *\n * The policy about the libclang API was always to keep it source and ABI\n * compatible, thus CINDEX_VERSION_MAJOR is expected to remain stable.\n */\n#define CINDEX_VERSION_MAJOR 0\n#define CINDEX_VERSION_MINOR 61\n\n#define CINDEX_VERSION_ENCODE(major, minor) (((major)*10000) + ((minor)*1))\n\n#define CINDEX_VERSION                                                         \\\n  CINDEX_VERSION_ENCODE(CINDEX_VERSION_MAJOR, CINDEX_VERSION_MINOR)\n\n#define CINDEX_VERSION_STRINGIZE_(major, minor) #major \".\" #minor\n#define CINDEX_VERSION_STRINGIZE(major, minor)                                 \\\n  CINDEX_VERSION_STRINGIZE_(major, minor)\n\n#define CINDEX_VERSION_STRING                                                  \\\n  CINDEX_VERSION_STRINGIZE(CINDEX_VERSION_MAJOR, CINDEX_VERSION_MINOR)\n\nLLVM_CLANG_C_EXTERN_C_BEGIN\n\n/** \\defgroup CINDEX libclang: C Interface to Clang\n *\n * The C Interface to Clang provides a relatively small API that exposes\n * facilities for parsing source code into an abstract syntax tree (AST),\n * loading already-parsed ASTs, traversing the AST, associating\n * physical source locations with elements within the AST, and other\n * facilities that support Clang-based development tools.\n *\n * This C interface to Clang will never provide all of the information\n * representation stored in Clang's C++ AST, nor should it: the intent is to\n * maintain an API that is relatively stable from one release to the next,\n * providing only the basic functionality needed to support development tools.\n *\n * To avoid namespace pollution, data types are prefixed with \"CX\" and\n * functions are prefixed with \"clang_\".\n *\n * @{\n */\n\n/**\n * An \"index\" that consists of a set of translation units that would\n * typically be linked together into an executable or library.\n */\ntypedef void *CXIndex;\n\n/**\n * An opaque type representing target information for a given translation\n * unit.\n */\ntypedef struct CXTargetInfoImpl *CXTargetInfo;\n\n/**\n * A single translation unit, which resides in an index.\n */\ntypedef struct CXTranslationUnitImpl *CXTranslationUnit;\n\n/**\n * Opaque pointer representing client data that will be passed through\n * to various callbacks and visitors.\n */\ntypedef void *CXClientData;\n\n/**\n * Provides the contents of a file that has not yet been saved to disk.\n *\n * Each CXUnsavedFile instance provides the name of a file on the\n * system along with the current contents of that file that have not\n * yet been saved to disk.\n */\nstruct CXUnsavedFile {\n  /**\n   * The file whose contents have not yet been saved.\n   *\n   * This file must already exist in the file system.\n   */\n  const char *Filename;\n\n  /**\n   * A buffer containing the unsaved contents of this file.\n   */\n  const char *Contents;\n\n  /**\n   * The length of the unsaved contents of this buffer.\n   */\n  unsigned long Length;\n};\n\n/**\n * Describes the availability of a particular entity, which indicates\n * whether the use of this entity will result in a warning or error due to\n * it being deprecated or unavailable.\n */\nenum CXAvailabilityKind {\n  /**\n   * The entity is available.\n   */\n  CXAvailability_Available,\n  /**\n   * The entity is available, but has been deprecated (and its use is\n   * not recommended).\n   */\n  CXAvailability_Deprecated,\n  /**\n   * The entity is not available; any use of it will be an error.\n   */\n  CXAvailability_NotAvailable,\n  /**\n   * The entity is available, but not accessible; any use of it will be\n   * an error.\n   */\n  CXAvailability_NotAccessible\n};\n\n/**\n * Describes a version number of the form major.minor.subminor.\n */\ntypedef struct CXVersion {\n  /**\n   * The major version number, e.g., the '10' in '10.7.3'. A negative\n   * value indicates that there is no version number at all.\n   */\n  int Major;\n  /**\n   * The minor version number, e.g., the '7' in '10.7.3'. This value\n   * will be negative if no minor version number was provided, e.g., for\n   * version '10'.\n   */\n  int Minor;\n  /**\n   * The subminor version number, e.g., the '3' in '10.7.3'. This value\n   * will be negative if no minor or subminor version number was provided,\n   * e.g., in version '10' or '10.7'.\n   */\n  int Subminor;\n} CXVersion;\n\n/**\n * Describes the exception specification of a cursor.\n *\n * A negative value indicates that the cursor is not a function declaration.\n */\nenum CXCursor_ExceptionSpecificationKind {\n  /**\n   * The cursor has no exception specification.\n   */\n  CXCursor_ExceptionSpecificationKind_None,\n\n  /**\n   * The cursor has exception specification throw()\n   */\n  CXCursor_ExceptionSpecificationKind_DynamicNone,\n\n  /**\n   * The cursor has exception specification throw(T1, T2)\n   */\n  CXCursor_ExceptionSpecificationKind_Dynamic,\n\n  /**\n   * The cursor has exception specification throw(...).\n   */\n  CXCursor_ExceptionSpecificationKind_MSAny,\n\n  /**\n   * The cursor has exception specification basic noexcept.\n   */\n  CXCursor_ExceptionSpecificationKind_BasicNoexcept,\n\n  /**\n   * The cursor has exception specification computed noexcept.\n   */\n  CXCursor_ExceptionSpecificationKind_ComputedNoexcept,\n\n  /**\n   * The exception specification has not yet been evaluated.\n   */\n  CXCursor_ExceptionSpecificationKind_Unevaluated,\n\n  /**\n   * The exception specification has not yet been instantiated.\n   */\n  CXCursor_ExceptionSpecificationKind_Uninstantiated,\n\n  /**\n   * The exception specification has not been parsed yet.\n   */\n  CXCursor_ExceptionSpecificationKind_Unparsed,\n\n  /**\n   * The cursor has a __declspec(nothrow) exception specification.\n   */\n  CXCursor_ExceptionSpecificationKind_NoThrow\n};\n\n/**\n * Provides a shared context for creating translation units.\n *\n * It provides two options:\n *\n * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of \"local\"\n * declarations (when loading any new translation units). A \"local\" declaration\n * is one that belongs in the translation unit itself and not in a precompiled\n * header that was used by the translation unit. If zero, all declarations\n * will be enumerated.\n *\n * Here is an example:\n *\n * \\code\n *   // excludeDeclsFromPCH = 1, displayDiagnostics=1\n *   Idx = clang_createIndex(1, 1);\n *\n *   // IndexTest.pch was produced with the following command:\n *   // \"clang -x c IndexTest.h -emit-ast -o IndexTest.pch\"\n *   TU = clang_createTranslationUnit(Idx, \"IndexTest.pch\");\n *\n *   // This will load all the symbols from 'IndexTest.pch'\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n *\n *   // This will load all the symbols from 'IndexTest.c', excluding symbols\n *   // from 'IndexTest.pch'.\n *   char *args[] = { \"-Xclang\", \"-include-pch=IndexTest.pch\" };\n *   TU = clang_createTranslationUnitFromSourceFile(Idx, \"IndexTest.c\", 2, args,\n *                                                  0, 0);\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n * \\endcode\n *\n * This process of creating the 'pch', loading it separately, and using it (via\n * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks\n * (which gives the indexer the same performance benefit as the compiler).\n */\nCINDEX_LINKAGE CXIndex clang_createIndex(int excludeDeclarationsFromPCH,\n                                         int displayDiagnostics);\n\n/**\n * Destroy the given index.\n *\n * The index must not be destroyed until all of the translation units created\n * within that index have been destroyed.\n */\nCINDEX_LINKAGE void clang_disposeIndex(CXIndex index);\n\ntypedef enum {\n  /**\n   * Used to indicate that no special CXIndex options are needed.\n   */\n  CXGlobalOpt_None = 0x0,\n\n  /**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 0x1,\n\n  /**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForEditing = 0x2,\n\n  /**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForAll =\n      CXGlobalOpt_ThreadBackgroundPriorityForIndexing |\n      CXGlobalOpt_ThreadBackgroundPriorityForEditing\n\n} CXGlobalOptFlags;\n\n/**\n * Sets general options associated with a CXIndex.\n *\n * For example:\n * \\code\n * CXIndex idx = ...;\n * clang_CXIndex_setGlobalOptions(idx,\n *     clang_CXIndex_getGlobalOptions(idx) |\n *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n * \\endcode\n *\n * \\param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.\n */\nCINDEX_LINKAGE void clang_CXIndex_setGlobalOptions(CXIndex, unsigned options);\n\n/**\n * Gets the general options associated with a CXIndex.\n *\n * \\returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that\n * are associated with the given CXIndex object.\n */\nCINDEX_LINKAGE unsigned clang_CXIndex_getGlobalOptions(CXIndex);\n\n/**\n * Sets the invocation emission path option in a CXIndex.\n *\n * The invocation emission path specifies a path which will contain log\n * files for certain libclang invocations. A null value (default) implies that\n * libclang invocations are not logged..\n */\nCINDEX_LINKAGE void\nclang_CXIndex_setInvocationEmissionPathOption(CXIndex, const char *Path);\n\n/**\n * \\defgroup CINDEX_FILES File manipulation routines\n *\n * @{\n */\n\n/**\n * A particular source file that is part of a translation unit.\n */\ntypedef void *CXFile;\n\n/**\n * Retrieve the complete file and path name of the given file.\n */\nCINDEX_LINKAGE CXString clang_getFileName(CXFile SFile);\n\n/**\n * Retrieve the last modification time of the given file.\n */\nCINDEX_LINKAGE time_t clang_getFileTime(CXFile SFile);\n\n/**\n * Uniquely identifies a CXFile, that refers to the same underlying file,\n * across an indexing session.\n */\ntypedef struct {\n  unsigned long long data[3];\n} CXFileUniqueID;\n\n/**\n * Retrieve the unique ID for the given \\c file.\n *\n * \\param file the file to get the ID for.\n * \\param outID stores the returned CXFileUniqueID.\n * \\returns If there was a failure getting the unique ID, returns non-zero,\n * otherwise returns 0.\n */\nCINDEX_LINKAGE int clang_getFileUniqueID(CXFile file, CXFileUniqueID *outID);\n\n/**\n * Determine whether the given header is guarded against\n * multiple inclusions, either with the conventional\n * \\#ifndef/\\#define/\\#endif macro guards or with \\#pragma once.\n */\nCINDEX_LINKAGE unsigned clang_isFileMultipleIncludeGuarded(CXTranslationUnit tu,\n                                                           CXFile file);\n\n/**\n * Retrieve a file handle within the given translation unit.\n *\n * \\param tu the translation unit\n *\n * \\param file_name the name of the file.\n *\n * \\returns the file handle for the named file in the translation unit \\p tu,\n * or a NULL file handle if the file was not a part of this translation unit.\n */\nCINDEX_LINKAGE CXFile clang_getFile(CXTranslationUnit tu,\n                                    const char *file_name);\n\n/**\n * Retrieve the buffer associated with the given file.\n *\n * \\param tu the translation unit\n *\n * \\param file the file for which to retrieve the buffer.\n *\n * \\param size [out] if non-NULL, will be set to the size of the buffer.\n *\n * \\returns a pointer to the buffer in memory that holds the contents of\n * \\p file, or a NULL pointer when the file is not loaded.\n */\nCINDEX_LINKAGE const char *clang_getFileContents(CXTranslationUnit tu,\n                                                 CXFile file, size_t *size);\n\n/**\n * Returns non-zero if the \\c file1 and \\c file2 point to the same file,\n * or they are both NULL.\n */\nCINDEX_LINKAGE int clang_File_isEqual(CXFile file1, CXFile file2);\n\n/**\n * Returns the real path name of \\c file.\n *\n * An empty string may be returned. Use \\c clang_getFileName() in that case.\n */\nCINDEX_LINKAGE CXString clang_File_tryGetRealPathName(CXFile file);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_LOCATIONS Physical source locations\n *\n * Clang represents physical source locations in its abstract syntax tree in\n * great detail, with file, line, and column information for the majority of\n * the tokens parsed in the source code. These data types and functions are\n * used to represent source location information, either for a particular\n * point in the program or for a range of points in the program, and extract\n * specific location information from those data types.\n *\n * @{\n */\n\n/**\n * Identifies a specific source location within a translation\n * unit.\n *\n * Use clang_getExpansionLocation() or clang_getSpellingLocation()\n * to map a source location to a particular file, line, and column.\n */\ntypedef struct {\n  const void *ptr_data[2];\n  unsigned int_data;\n} CXSourceLocation;\n\n/**\n * Identifies a half-open character range in the source code.\n *\n * Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the\n * starting and end locations from a source range, respectively.\n */\ntypedef struct {\n  const void *ptr_data[2];\n  unsigned begin_int_data;\n  unsigned end_int_data;\n} CXSourceRange;\n\n/**\n * Retrieve a NULL (invalid) source location.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getNullLocation(void);\n\n/**\n * Determine whether two source locations, which must refer into\n * the same translation unit, refer to exactly the same point in the source\n * code.\n *\n * \\returns non-zero if the source locations refer to the same location, zero\n * if they refer to different locations.\n */\nCINDEX_LINKAGE unsigned clang_equalLocations(CXSourceLocation loc1,\n                                             CXSourceLocation loc2);\n\n/**\n * Retrieves the source location associated with a given file/line/column\n * in a particular translation unit.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getLocation(CXTranslationUnit tu,\n                                                  CXFile file, unsigned line,\n                                                  unsigned column);\n/**\n * Retrieves the source location associated with a given character offset\n * in a particular translation unit.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu,\n                                                           CXFile file,\n                                                           unsigned offset);\n\n/**\n * Returns non-zero if the given source location is in a system header.\n */\nCINDEX_LINKAGE int clang_Location_isInSystemHeader(CXSourceLocation location);\n\n/**\n * Returns non-zero if the given source location is in the main file of\n * the corresponding translation unit.\n */\nCINDEX_LINKAGE int clang_Location_isFromMainFile(CXSourceLocation location);\n\n/**\n * Retrieve a NULL (invalid) source range.\n */\nCINDEX_LINKAGE CXSourceRange clang_getNullRange(void);\n\n/**\n * Retrieve a source range given the beginning and ending source\n * locations.\n */\nCINDEX_LINKAGE CXSourceRange clang_getRange(CXSourceLocation begin,\n                                            CXSourceLocation end);\n\n/**\n * Determine whether two ranges are equivalent.\n *\n * \\returns non-zero if the ranges are the same, zero if they differ.\n */\nCINDEX_LINKAGE unsigned clang_equalRanges(CXSourceRange range1,\n                                          CXSourceRange range2);\n\n/**\n * Returns non-zero if \\p range is null.\n */\nCINDEX_LINKAGE int clang_Range_isNull(CXSourceRange range);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getExpansionLocation(CXSourceLocation location,\n                                               CXFile *file, unsigned *line,\n                                               unsigned *column,\n                                               unsigned *offset);\n\n/**\n * Retrieve the file, line and column represented by the given source\n * location, as specified in a # line directive.\n *\n * Example: given the following source code in a file somefile.c\n *\n * \\code\n * #123 \"dummy.c\" 1\n *\n * static int func(void)\n * {\n *     return 0;\n * }\n * \\endcode\n *\n * the location information returned by this function would be\n *\n * File: dummy.c Line: 124 Column: 12\n *\n * whereas clang_getExpansionLocation would have returned\n *\n * File: somefile.c Line: 3 Column: 12\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param filename [out] if non-NULL, will be set to the filename of the\n * source location. Note that filenames returned will be for \"virtual\" files,\n * which don't necessarily exist on the machine running clang - e.g. when\n * parsing preprocessed output obtained from a different environment. If\n * a non-NULL value is passed in, remember to dispose of the returned value\n * using \\c clang_disposeString() once you've finished with it. For an invalid\n * source location, an empty string is returned.\n *\n * \\param line [out] if non-NULL, will be set to the line number of the\n * source location. For an invalid source location, zero is returned.\n *\n * \\param column [out] if non-NULL, will be set to the column number of the\n * source location. For an invalid source location, zero is returned.\n */\nCINDEX_LINKAGE void clang_getPresumedLocation(CXSourceLocation location,\n                                              CXString *filename,\n                                              unsigned *line, unsigned *column);\n\n/**\n * Legacy API to retrieve the file, line, column, and offset represented\n * by the given source location.\n *\n * This interface has been replaced by the newer interface\n * #clang_getExpansionLocation(). See that interface's documentation for\n * details.\n */\nCINDEX_LINKAGE void clang_getInstantiationLocation(CXSourceLocation location,\n                                                   CXFile *file, unsigned *line,\n                                                   unsigned *column,\n                                                   unsigned *offset);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro instantiation, return where the\n * location was originally spelled in the source file.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getSpellingLocation(CXSourceLocation location,\n                                              CXFile *file, unsigned *line,\n                                              unsigned *column,\n                                              unsigned *offset);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, return where the macro was\n * expanded or where the macro argument was written, if the location points at\n * a macro argument.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getFileLocation(CXSourceLocation location,\n                                          CXFile *file, unsigned *line,\n                                          unsigned *column, unsigned *offset);\n\n/**\n * Retrieve a source location representing the first character within a\n * source range.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getRangeStart(CXSourceRange range);\n\n/**\n * Retrieve a source location representing the last character within a\n * source range.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getRangeEnd(CXSourceRange range);\n\n/**\n * Identifies an array of ranges.\n */\ntypedef struct {\n  /** The number of ranges in the \\c ranges array. */\n  unsigned count;\n  /**\n   * An array of \\c CXSourceRanges.\n   */\n  CXSourceRange *ranges;\n} CXSourceRangeList;\n\n/**\n * Retrieve all ranges that were skipped by the preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */\nCINDEX_LINKAGE CXSourceRangeList *clang_getSkippedRanges(CXTranslationUnit tu,\n                                                         CXFile file);\n\n/**\n * Retrieve all ranges from all files that were skipped by the\n * preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */\nCINDEX_LINKAGE CXSourceRangeList *\nclang_getAllSkippedRanges(CXTranslationUnit tu);\n\n/**\n * Destroy the given \\c CXSourceRangeList.\n */\nCINDEX_LINKAGE void clang_disposeSourceRangeList(CXSourceRangeList *ranges);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_DIAG Diagnostic reporting\n *\n * @{\n */\n\n/**\n * Describes the severity of a particular diagnostic.\n */\nenum CXDiagnosticSeverity {\n  /**\n   * A diagnostic that has been suppressed, e.g., by a command-line\n   * option.\n   */\n  CXDiagnostic_Ignored = 0,\n\n  /**\n   * This diagnostic is a note that should be attached to the\n   * previous (non-note) diagnostic.\n   */\n  CXDiagnostic_Note = 1,\n\n  /**\n   * This diagnostic indicates suspicious code that may not be\n   * wrong.\n   */\n  CXDiagnostic_Warning = 2,\n\n  /**\n   * This diagnostic indicates that the code is ill-formed.\n   */\n  CXDiagnostic_Error = 3,\n\n  /**\n   * This diagnostic indicates that the code is ill-formed such\n   * that future parser recovery is unlikely to produce useful\n   * results.\n   */\n  CXDiagnostic_Fatal = 4\n};\n\n/**\n * A single diagnostic, containing the diagnostic's severity,\n * location, text, source ranges, and fix-it hints.\n */\ntypedef void *CXDiagnostic;\n\n/**\n * A group of CXDiagnostics.\n */\ntypedef void *CXDiagnosticSet;\n\n/**\n * Determine the number of diagnostics in a CXDiagnosticSet.\n */\nCINDEX_LINKAGE unsigned clang_getNumDiagnosticsInSet(CXDiagnosticSet Diags);\n\n/**\n * Retrieve a diagnostic associated with the given CXDiagnosticSet.\n *\n * \\param Diags the CXDiagnosticSet to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE CXDiagnostic clang_getDiagnosticInSet(CXDiagnosticSet Diags,\n                                                     unsigned Index);\n\n/**\n * Describes the kind of error that occurred (if any) in a call to\n * \\c clang_loadDiagnostics.\n */\nenum CXLoadDiag_Error {\n  /**\n   * Indicates that no error occurred.\n   */\n  CXLoadDiag_None = 0,\n\n  /**\n   * Indicates that an unknown error occurred while attempting to\n   * deserialize diagnostics.\n   */\n  CXLoadDiag_Unknown = 1,\n\n  /**\n   * Indicates that the file containing the serialized diagnostics\n   * could not be opened.\n   */\n  CXLoadDiag_CannotLoad = 2,\n\n  /**\n   * Indicates that the serialized diagnostics file is invalid or\n   * corrupt.\n   */\n  CXLoadDiag_InvalidFile = 3\n};\n\n/**\n * Deserialize a set of diagnostics from a Clang diagnostics bitcode\n * file.\n *\n * \\param file The name of the file to deserialize.\n * \\param error A pointer to a enum value recording if there was a problem\n *        deserializing the diagnostics.\n * \\param errorString A pointer to a CXString for recording the error string\n *        if the file was not successfully loaded.\n *\n * \\returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These\n * diagnostics should be released using clang_disposeDiagnosticSet().\n */\nCINDEX_LINKAGE CXDiagnosticSet clang_loadDiagnostics(\n    const char *file, enum CXLoadDiag_Error *error, CXString *errorString);\n\n/**\n * Release a CXDiagnosticSet and all of its contained diagnostics.\n */\nCINDEX_LINKAGE void clang_disposeDiagnosticSet(CXDiagnosticSet Diags);\n\n/**\n * Retrieve the child diagnostics of a CXDiagnostic.\n *\n * This CXDiagnosticSet does not need to be released by\n * clang_disposeDiagnosticSet.\n */\nCINDEX_LINKAGE CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D);\n\n/**\n * Determine the number of diagnostics produced for the given\n * translation unit.\n */\nCINDEX_LINKAGE unsigned clang_getNumDiagnostics(CXTranslationUnit Unit);\n\n/**\n * Retrieve a diagnostic associated with the given translation unit.\n *\n * \\param Unit the translation unit to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit,\n                                                unsigned Index);\n\n/**\n * Retrieve the complete set of diagnostics associated with a\n *        translation unit.\n *\n * \\param Unit the translation unit to query.\n */\nCINDEX_LINKAGE CXDiagnosticSet\nclang_getDiagnosticSetFromTU(CXTranslationUnit Unit);\n\n/**\n * Destroy a diagnostic.\n */\nCINDEX_LINKAGE void clang_disposeDiagnostic(CXDiagnostic Diagnostic);\n\n/**\n * Options to control the display of diagnostics.\n *\n * The values in this enum are meant to be combined to customize the\n * behavior of \\c clang_formatDiagnostic().\n */\nenum CXDiagnosticDisplayOptions {\n  /**\n   * Display the source-location information where the\n   * diagnostic was located.\n   *\n   * When set, diagnostics will be prefixed by the file, line, and\n   * (optionally) column to which the diagnostic refers. For example,\n   *\n   * \\code\n   * test.c:28: warning: extra tokens at end of #endif directive\n   * \\endcode\n   *\n   * This option corresponds to the clang flag \\c -fshow-source-location.\n   */\n  CXDiagnostic_DisplaySourceLocation = 0x01,\n\n  /**\n   * If displaying the source-location information of the\n   * diagnostic, also include the column number.\n   *\n   * This option corresponds to the clang flag \\c -fshow-column.\n   */\n  CXDiagnostic_DisplayColumn = 0x02,\n\n  /**\n   * If displaying the source-location information of the\n   * diagnostic, also include information about source ranges in a\n   * machine-parsable format.\n   *\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-print-source-range-info.\n   */\n  CXDiagnostic_DisplaySourceRanges = 0x04,\n\n  /**\n   * Display the option name associated with this diagnostic, if any.\n   *\n   * The option name displayed (e.g., -Wconversion) will be placed in brackets\n   * after the diagnostic text. This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-option.\n   */\n  CXDiagnostic_DisplayOption = 0x08,\n\n  /**\n   * Display the category number associated with this diagnostic, if any.\n   *\n   * The category number is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=id.\n   */\n  CXDiagnostic_DisplayCategoryId = 0x10,\n\n  /**\n   * Display the category name associated with this diagnostic, if any.\n   *\n   * The category name is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=name.\n   */\n  CXDiagnostic_DisplayCategoryName = 0x20\n};\n\n/**\n * Format the given diagnostic in a manner that is suitable for display.\n *\n * This routine will format the given diagnostic to a string, rendering\n * the diagnostic according to the various options given. The\n * \\c clang_defaultDiagnosticDisplayOptions() function returns the set of\n * options that most closely mimics the behavior of the clang compiler.\n *\n * \\param Diagnostic The diagnostic to print.\n *\n * \\param Options A set of options that control the diagnostic display,\n * created by combining \\c CXDiagnosticDisplayOptions values.\n *\n * \\returns A new string containing for formatted diagnostic.\n */\nCINDEX_LINKAGE CXString clang_formatDiagnostic(CXDiagnostic Diagnostic,\n                                               unsigned Options);\n\n/**\n * Retrieve the set of display options most similar to the\n * default behavior of the clang compiler.\n *\n * \\returns A set of display options suitable for use with \\c\n * clang_formatDiagnostic().\n */\nCINDEX_LINKAGE unsigned clang_defaultDiagnosticDisplayOptions(void);\n\n/**\n * Determine the severity of the given diagnostic.\n */\nCINDEX_LINKAGE enum CXDiagnosticSeverity\n    clang_getDiagnosticSeverity(CXDiagnostic);\n\n/**\n * Retrieve the source location of the given diagnostic.\n *\n * This location is where Clang would print the caret ('^') when\n * displaying the diagnostic on the command line.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic);\n\n/**\n * Retrieve the text of the given diagnostic.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticSpelling(CXDiagnostic);\n\n/**\n * Retrieve the name of the command-line option that enabled this\n * diagnostic.\n *\n * \\param Diag The diagnostic to be queried.\n *\n * \\param Disable If non-NULL, will be set to the option that disables this\n * diagnostic (if any).\n *\n * \\returns A string that contains the command-line option used to enable this\n * warning, such as \"-Wconversion\" or \"-pedantic\".\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticOption(CXDiagnostic Diag,\n                                                  CXString *Disable);\n\n/**\n * Retrieve the category number for this diagnostic.\n *\n * Diagnostics can be categorized into groups along with other, related\n * diagnostics (e.g., diagnostics under the same warning flag). This routine\n * retrieves the category number for the given diagnostic.\n *\n * \\returns The number of the category that contains this diagnostic, or zero\n * if this diagnostic is uncategorized.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticCategory(CXDiagnostic);\n\n/**\n * Retrieve the name of a particular diagnostic category.  This\n *  is now deprecated.  Use clang_getDiagnosticCategoryText()\n *  instead.\n *\n * \\param Category A diagnostic category number, as returned by\n * \\c clang_getDiagnosticCategory().\n *\n * \\returns The name of the given diagnostic category.\n */\nCINDEX_DEPRECATED CINDEX_LINKAGE CXString\nclang_getDiagnosticCategoryName(unsigned Category);\n\n/**\n * Retrieve the diagnostic category text for a given diagnostic.\n *\n * \\returns The text of the given diagnostic category.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticCategoryText(CXDiagnostic);\n\n/**\n * Determine the number of source ranges associated with the given\n * diagnostic.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticNumRanges(CXDiagnostic);\n\n/**\n * Retrieve a source range associated with the diagnostic.\n *\n * A diagnostic's source ranges highlight important elements in the source\n * code. On the command line, Clang displays source ranges by\n * underlining them with '~' characters.\n *\n * \\param Diagnostic the diagnostic whose range is being extracted.\n *\n * \\param Range the zero-based index specifying which range to\n *\n * \\returns the requested source range.\n */\nCINDEX_LINKAGE CXSourceRange clang_getDiagnosticRange(CXDiagnostic Diagnostic,\n                                                      unsigned Range);\n\n/**\n * Determine the number of fix-it hints associated with the\n * given diagnostic.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diagnostic);\n\n/**\n * Retrieve the replacement information for a given fix-it.\n *\n * Fix-its are described in terms of a source range whose contents\n * should be replaced by a string. This approach generalizes over\n * three kinds of operations: removal of source code (the range covers\n * the code to be removed and the replacement string is empty),\n * replacement of source code (the range covers the code to be\n * replaced and the replacement string provides the new code), and\n * insertion (both the start and end of the range point at the\n * insertion location, and the replacement string provides the text to\n * insert).\n *\n * \\param Diagnostic The diagnostic whose fix-its are being queried.\n *\n * \\param FixIt The zero-based index of the fix-it.\n *\n * \\param ReplacementRange The source range whose contents will be\n * replaced with the returned replacement string. Note that source\n * ranges are half-open ranges [a, b), so the source code should be\n * replaced from a and up to (but not including) b.\n *\n * \\returns A string containing text that should be replace the source\n * code indicated by the \\c ReplacementRange.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticFixIt(\n    CXDiagnostic Diagnostic, unsigned FixIt, CXSourceRange *ReplacementRange);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_TRANSLATION_UNIT Translation unit manipulation\n *\n * The routines in this group provide the ability to create and destroy\n * translation units from files, either by parsing the contents of the files or\n * by reading in a serialized representation of a translation unit.\n *\n * @{\n */\n\n/**\n * Get the original translation unit source file name.\n */\nCINDEX_LINKAGE CXString\nclang_getTranslationUnitSpelling(CXTranslationUnit CTUnit);\n\n/**\n * Return the CXTranslationUnit for a given source file and the provided\n * command line arguments one would pass to the compiler.\n *\n * Note: The 'source_filename' argument is optional.  If the caller provides a\n * NULL pointer, the name of the source file is expected to reside in the\n * specified command line arguments.\n *\n * Note: When encountered in 'clang_command_line_args', the following options\n * are ignored:\n *\n *   '-c'\n *   '-emit-ast'\n *   '-fsyntax-only'\n *   '-o \\<output file>'  (both '-o' and '\\<output file>' are ignored)\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\p clang_command_line_args.\n *\n * \\param num_clang_command_line_args The number of command-line arguments in\n * \\p clang_command_line_args.\n *\n * \\param clang_command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for code completion, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_createTranslationUnitFromSourceFile(\n    CXIndex CIdx, const char *source_filename, int num_clang_command_line_args,\n    const char *const *clang_command_line_args, unsigned num_unsaved_files,\n    struct CXUnsavedFile *unsaved_files);\n\n/**\n * Same as \\c clang_createTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */\nCINDEX_LINKAGE CXTranslationUnit\nclang_createTranslationUnit(CXIndex CIdx, const char *ast_filename);\n\n/**\n * Create a translation unit from an AST file (\\c -emit-ast).\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_createTranslationUnit2(CXIndex CIdx, const char *ast_filename,\n                             CXTranslationUnit *out_TU);\n\n/**\n * Flags that control the creation of translation units.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * constructing the translation unit.\n */\nenum CXTranslationUnit_Flags {\n  /**\n   * Used to indicate that no special translation-unit options are\n   * needed.\n   */\n  CXTranslationUnit_None = 0x0,\n\n  /**\n   * Used to indicate that the parser should construct a \"detailed\"\n   * preprocessing record, including all macro definitions and instantiations.\n   *\n   * Constructing a detailed preprocessing record requires more memory\n   * and time to parse, since the information contained in the record\n   * is usually not retained. However, it can be useful for\n   * applications that require more detailed information about the\n   * behavior of the preprocessor.\n   */\n  CXTranslationUnit_DetailedPreprocessingRecord = 0x01,\n\n  /**\n   * Used to indicate that the translation unit is incomplete.\n   *\n   * When a translation unit is considered \"incomplete\", semantic\n   * analysis that is typically performed at the end of the\n   * translation unit will be suppressed. For example, this suppresses\n   * the completion of tentative declarations in C and of\n   * instantiation of implicitly-instantiation function templates in\n   * C++. This option is typically used when parsing a header with the\n   * intent of producing a precompiled header.\n   */\n  CXTranslationUnit_Incomplete = 0x02,\n\n  /**\n   * Used to indicate that the translation unit should be built with an\n   * implicit precompiled header for the preamble.\n   *\n   * An implicit precompiled header is used as an optimization when a\n   * particular translation unit is likely to be reparsed many times\n   * when the sources aren't changing that often. In this case, an\n   * implicit precompiled header will be built containing all of the\n   * initial includes at the top of the main file (what we refer to as\n   * the \"preamble\" of the file). In subsequent parses, if the\n   * preamble or the files in it have not changed, \\c\n   * clang_reparseTranslationUnit() will re-use the implicit\n   * precompiled header to improve parsing performance.\n   */\n  CXTranslationUnit_PrecompiledPreamble = 0x04,\n\n  /**\n   * Used to indicate that the translation unit should cache some\n   * code-completion results with each reparse of the source file.\n   *\n   * Caching of code-completion results is a performance optimization that\n   * introduces some overhead to reparsing but improves the performance of\n   * code-completion operations.\n   */\n  CXTranslationUnit_CacheCompletionResults = 0x08,\n\n  /**\n   * Used to indicate that the translation unit will be serialized with\n   * \\c clang_saveTranslationUnit.\n   *\n   * This option is typically used when parsing a header with the intent of\n   * producing a precompiled header.\n   */\n  CXTranslationUnit_ForSerialization = 0x10,\n\n  /**\n   * DEPRECATED: Enabled chained precompiled preambles in C++.\n   *\n   * Note: this is a *temporary* option that is available only while\n   * we are testing C++ precompiled preamble support. It is deprecated.\n   */\n  CXTranslationUnit_CXXChainedPCH = 0x20,\n\n  /**\n   * Used to indicate that function/method bodies should be skipped while\n   * parsing.\n   *\n   * This option can be used to search for declarations/definitions while\n   * ignoring the usages.\n   */\n  CXTranslationUnit_SkipFunctionBodies = 0x40,\n\n  /**\n   * Used to indicate that brief documentation comments should be\n   * included into the set of code completions returned from this translation\n   * unit.\n   */\n  CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 0x80,\n\n  /**\n   * Used to indicate that the precompiled preamble should be created on\n   * the first parse. Otherwise it will be created on the first reparse. This\n   * trades runtime on the first parse (serializing the preamble takes time) for\n   * reduced runtime on the second parse (can now reuse the preamble).\n   */\n  CXTranslationUnit_CreatePreambleOnFirstParse = 0x100,\n\n  /**\n   * Do not stop processing when fatal errors are encountered.\n   *\n   * When fatal errors are encountered while parsing a translation unit,\n   * semantic analysis is typically stopped early when compiling code. A common\n   * source for fatal errors are unresolvable include files. For the\n   * purposes of an IDE, this is undesirable behavior and as much information\n   * as possible should be reported. Use this flag to enable this behavior.\n   */\n  CXTranslationUnit_KeepGoing = 0x200,\n\n  /**\n   * Sets the preprocessor in a mode for parsing a single file only.\n   */\n  CXTranslationUnit_SingleFileParse = 0x400,\n\n  /**\n   * Used in combination with CXTranslationUnit_SkipFunctionBodies to\n   * constrain the skipping of function bodies to the preamble.\n   *\n   * The function bodies of the main file are not skipped.\n   */\n  CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 0x800,\n\n  /**\n   * Used to indicate that attributed types should be included in CXType.\n   */\n  CXTranslationUnit_IncludeAttributedTypes = 0x1000,\n\n  /**\n   * Used to indicate that implicit attributes should be visited.\n   */\n  CXTranslationUnit_VisitImplicitAttributes = 0x2000,\n\n  /**\n   * Used to indicate that non-errors from included files should be ignored.\n   *\n   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from\n   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for\n   * the case where these warnings are not of interest, as for an IDE for\n   * example, which typically shows only the diagnostics in the main file.\n   */\n  CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 0x4000,\n\n  /**\n   * Tells the preprocessor not to skip excluded conditional blocks.\n   */\n  CXTranslationUnit_RetainExcludedConditionalBlocks = 0x8000\n};\n\n/**\n * Returns the set of flags that is suitable for parsing a translation\n * unit that is being edited.\n *\n * The set of flags returned provide options for \\c clang_parseTranslationUnit()\n * to indicate that the translation unit is likely to be reparsed many times,\n * either explicitly (via \\c clang_reparseTranslationUnit()) or implicitly\n * (e.g., by code completion (\\c clang_codeCompletionAt())). The returned flag\n * set contains an unspecified set of optimizations (e.g., the precompiled\n * preamble) geared toward improving the performance of these routines. The\n * set of optimizations enabled may change from one version to the next.\n */\nCINDEX_LINKAGE unsigned clang_defaultEditingTranslationUnitOptions(void);\n\n/**\n * Same as \\c clang_parseTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_parseTranslationUnit(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options);\n\n/**\n * Parse the given source file and the translation unit corresponding\n * to that file.\n *\n * This routine is the main entry point for the Clang C API, providing the\n * ability to parse a source file into a translation unit that can then be\n * queried by other functions in the API. This routine accepts a set of\n * command-line arguments so that the compilation can be configured in the same\n * way that the compiler is configured on the command line.\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\c command_line_args.\n *\n * \\param command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_command_line_args The number of command-line arguments in\n * \\c command_line_args.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is managed but not its compilation. This should be a bitwise OR of the\n * CXTranslationUnit_XXX flags.\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit, describing the parsed code and containing any\n * diagnostics produced by the compiler.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */\nCINDEX_LINKAGE enum CXErrorCode clang_parseTranslationUnit2(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU);\n\n/**\n * Same as clang_parseTranslationUnit2 but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */\nCINDEX_LINKAGE enum CXErrorCode clang_parseTranslationUnit2FullArgv(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU);\n\n/**\n * Flags that control how translation units are saved.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * saving the translation unit.\n */\nenum CXSaveTranslationUnit_Flags {\n  /**\n   * Used to indicate that no special saving options are needed.\n   */\n  CXSaveTranslationUnit_None = 0x0\n};\n\n/**\n * Returns the set of flags that is suitable for saving a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_saveTranslationUnit() by default. The returned flag\n * set contains an unspecified set of options that save translation units with\n * the most commonly-requested data.\n */\nCINDEX_LINKAGE unsigned clang_defaultSaveOptions(CXTranslationUnit TU);\n\n/**\n * Describes the kind of error that occurred (if any) in a call to\n * \\c clang_saveTranslationUnit().\n */\nenum CXSaveError {\n  /**\n   * Indicates that no error occurred while saving a translation unit.\n   */\n  CXSaveError_None = 0,\n\n  /**\n   * Indicates that an unknown error occurred while attempting to save\n   * the file.\n   *\n   * This error typically indicates that file I/O failed when attempting to\n   * write the file.\n   */\n  CXSaveError_Unknown = 1,\n\n  /**\n   * Indicates that errors during translation prevented this attempt\n   * to save the translation unit.\n   *\n   * Errors that prevent the translation unit from being saved can be\n   * extracted using \\c clang_getNumDiagnostics() and \\c clang_getDiagnostic().\n   */\n  CXSaveError_TranslationErrors = 2,\n\n  /**\n   * Indicates that the translation unit to be saved was somehow\n   * invalid (e.g., NULL).\n   */\n  CXSaveError_InvalidTU = 3\n};\n\n/**\n * Saves a translation unit into a serialized representation of\n * that translation unit on disk.\n *\n * Any translation unit that was parsed without error can be saved\n * into a file. The translation unit can then be deserialized into a\n * new \\c CXTranslationUnit with \\c clang_createTranslationUnit() or,\n * if it is an incomplete translation unit that corresponds to a\n * header, used as a precompiled header when parsing other translation\n * units.\n *\n * \\param TU The translation unit to save.\n *\n * \\param FileName The file to which the translation unit will be saved.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is saved. This should be a bitwise OR of the\n * CXSaveTranslationUnit_XXX flags.\n *\n * \\returns A value that will match one of the enumerators of the CXSaveError\n * enumeration. Zero (CXSaveError_None) indicates that the translation unit was\n * saved successfully, while a non-zero value indicates that a problem occurred.\n */\nCINDEX_LINKAGE int clang_saveTranslationUnit(CXTranslationUnit TU,\n                                             const char *FileName,\n                                             unsigned options);\n\n/**\n * Suspend a translation unit in order to free memory associated with it.\n *\n * A suspended translation unit uses significantly less memory but on the other\n * side does not support any other calls than \\c clang_reparseTranslationUnit\n * to resume it or \\c clang_disposeTranslationUnit to dispose it completely.\n */\nCINDEX_LINKAGE unsigned clang_suspendTranslationUnit(CXTranslationUnit);\n\n/**\n * Destroy the specified CXTranslationUnit object.\n */\nCINDEX_LINKAGE void clang_disposeTranslationUnit(CXTranslationUnit);\n\n/**\n * Flags that control the reparsing of translation units.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * reparsing the translation unit.\n */\nenum CXReparse_Flags {\n  /**\n   * Used to indicate that no special reparsing options are needed.\n   */\n  CXReparse_None = 0x0\n};\n\n/**\n * Returns the set of flags that is suitable for reparsing a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_reparseTranslationUnit() by default. The returned flag\n * set contains an unspecified set of optimizations geared toward common uses\n * of reparsing. The set of optimizations enabled may change from one version\n * to the next.\n */\nCINDEX_LINKAGE unsigned clang_defaultReparseOptions(CXTranslationUnit TU);\n\n/**\n * Reparse the source files that produced this translation unit.\n *\n * This routine can be used to re-parse the source files that originally\n * created the given translation unit, for example because those source files\n * have changed (either on disk or as passed via \\p unsaved_files). The\n * source code will be reparsed with the same command-line options as it\n * was originally parsed.\n *\n * Reparsing a translation unit invalidates all cursors and source locations\n * that refer into that translation unit. This makes reparsing a translation\n * unit semantically equivalent to destroying the translation unit and then\n * creating a new translation unit with the same command-line arguments.\n * However, it may be more efficient to reparse a translation\n * unit using this routine.\n *\n * \\param TU The translation unit whose contents will be re-parsed. The\n * translation unit must originally have been built with\n * \\c clang_createTranslationUnitFromSourceFile().\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files The files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param options A bitset of options composed of the flags in CXReparse_Flags.\n * The function \\c clang_defaultReparseOptions() produces a default set of\n * options recommended for most uses, based on the translation unit.\n *\n * \\returns 0 if the sources could be reparsed.  A non-zero error code will be\n * returned if reparsing was impossible, such that the translation unit is\n * invalid. In such cases, the only valid call for \\c TU is\n * \\c clang_disposeTranslationUnit(TU).  The error codes returned by this\n * routine are described by the \\c CXErrorCode enum.\n */\nCINDEX_LINKAGE int\nclang_reparseTranslationUnit(CXTranslationUnit TU, unsigned num_unsaved_files,\n                             struct CXUnsavedFile *unsaved_files,\n                             unsigned options);\n\n/**\n * Categorizes how memory is being used by a translation unit.\n */\nenum CXTUResourceUsageKind {\n  CXTUResourceUsage_AST = 1,\n  CXTUResourceUsage_Identifiers = 2,\n  CXTUResourceUsage_Selectors = 3,\n  CXTUResourceUsage_GlobalCompletionResults = 4,\n  CXTUResourceUsage_SourceManagerContentCache = 5,\n  CXTUResourceUsage_AST_SideTables = 6,\n  CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7,\n  CXTUResourceUsage_SourceManager_Membuffer_MMap = 8,\n  CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9,\n  CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10,\n  CXTUResourceUsage_Preprocessor = 11,\n  CXTUResourceUsage_PreprocessingRecord = 12,\n  CXTUResourceUsage_SourceManager_DataStructures = 13,\n  CXTUResourceUsage_Preprocessor_HeaderSearch = 14,\n  CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = CXTUResourceUsage_AST,\n  CXTUResourceUsage_MEMORY_IN_BYTES_END =\n      CXTUResourceUsage_Preprocessor_HeaderSearch,\n\n  CXTUResourceUsage_First = CXTUResourceUsage_AST,\n  CXTUResourceUsage_Last = CXTUResourceUsage_Preprocessor_HeaderSearch\n};\n\n/**\n * Returns the human-readable null-terminated C string that represents\n *  the name of the memory category.  This string should never be freed.\n */\nCINDEX_LINKAGE\nconst char *clang_getTUResourceUsageName(enum CXTUResourceUsageKind kind);\n\ntypedef struct CXTUResourceUsageEntry {\n  /* The memory usage category. */\n  enum CXTUResourceUsageKind kind;\n  /* Amount of resources used.\n      The units will depend on the resource kind. */\n  unsigned long amount;\n} CXTUResourceUsageEntry;\n\n/**\n * The memory usage of a CXTranslationUnit, broken into categories.\n */\ntypedef struct CXTUResourceUsage {\n  /* Private data member, used for queries. */\n  void *data;\n\n  /* The number of entries in the 'entries' array. */\n  unsigned numEntries;\n\n  /* An array of key-value pairs, representing the breakdown of memory\n            usage. */\n  CXTUResourceUsageEntry *entries;\n\n} CXTUResourceUsage;\n\n/**\n * Return the memory usage of a translation unit.  This object\n *  should be released with clang_disposeCXTUResourceUsage().\n */\nCINDEX_LINKAGE CXTUResourceUsage\nclang_getCXTUResourceUsage(CXTranslationUnit TU);\n\nCINDEX_LINKAGE void clang_disposeCXTUResourceUsage(CXTUResourceUsage usage);\n\n/**\n * Get target information for this translation unit.\n *\n * The CXTargetInfo object cannot outlive the CXTranslationUnit object.\n */\nCINDEX_LINKAGE CXTargetInfo\nclang_getTranslationUnitTargetInfo(CXTranslationUnit CTUnit);\n\n/**\n * Destroy the CXTargetInfo object.\n */\nCINDEX_LINKAGE void clang_TargetInfo_dispose(CXTargetInfo Info);\n\n/**\n * Get the normalized target triple as a string.\n *\n * Returns the empty string in case of any error.\n */\nCINDEX_LINKAGE CXString clang_TargetInfo_getTriple(CXTargetInfo Info);\n\n/**\n * Get the pointer width of the target in bits.\n *\n * Returns -1 in case of error.\n */\nCINDEX_LINKAGE int clang_TargetInfo_getPointerWidth(CXTargetInfo Info);\n\n/**\n * @}\n */\n\n/**\n * Describes the kind of entity that a cursor refers to.\n */\nenum CXCursorKind {\n  /* Declarations */\n  /**\n   * A declaration whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed declarations have the same operations as any other kind\n   * of declaration; one can extract their location information,\n   * spelling, find their definitions, etc. However, the specific kind\n   * of the declaration is not reported.\n   */\n  CXCursor_UnexposedDecl = 1,\n  /** A C or C++ struct. */\n  CXCursor_StructDecl = 2,\n  /** A C or C++ union. */\n  CXCursor_UnionDecl = 3,\n  /** A C++ class. */\n  CXCursor_ClassDecl = 4,\n  /** An enumeration. */\n  CXCursor_EnumDecl = 5,\n  /**\n   * A field (in C) or non-static data member (in C++) in a\n   * struct, union, or C++ class.\n   */\n  CXCursor_FieldDecl = 6,\n  /** An enumerator constant. */\n  CXCursor_EnumConstantDecl = 7,\n  /** A function. */\n  CXCursor_FunctionDecl = 8,\n  /** A variable. */\n  CXCursor_VarDecl = 9,\n  /** A function or method parameter. */\n  CXCursor_ParmDecl = 10,\n  /** An Objective-C \\@interface. */\n  CXCursor_ObjCInterfaceDecl = 11,\n  /** An Objective-C \\@interface for a category. */\n  CXCursor_ObjCCategoryDecl = 12,\n  /** An Objective-C \\@protocol declaration. */\n  CXCursor_ObjCProtocolDecl = 13,\n  /** An Objective-C \\@property declaration. */\n  CXCursor_ObjCPropertyDecl = 14,\n  /** An Objective-C instance variable. */\n  CXCursor_ObjCIvarDecl = 15,\n  /** An Objective-C instance method. */\n  CXCursor_ObjCInstanceMethodDecl = 16,\n  /** An Objective-C class method. */\n  CXCursor_ObjCClassMethodDecl = 17,\n  /** An Objective-C \\@implementation. */\n  CXCursor_ObjCImplementationDecl = 18,\n  /** An Objective-C \\@implementation for a category. */\n  CXCursor_ObjCCategoryImplDecl = 19,\n  /** A typedef. */\n  CXCursor_TypedefDecl = 20,\n  /** A C++ class method. */\n  CXCursor_CXXMethod = 21,\n  /** A C++ namespace. */\n  CXCursor_Namespace = 22,\n  /** A linkage specification, e.g. 'extern \"C\"'. */\n  CXCursor_LinkageSpec = 23,\n  /** A C++ constructor. */\n  CXCursor_Constructor = 24,\n  /** A C++ destructor. */\n  CXCursor_Destructor = 25,\n  /** A C++ conversion function. */\n  CXCursor_ConversionFunction = 26,\n  /** A C++ template type parameter. */\n  CXCursor_TemplateTypeParameter = 27,\n  /** A C++ non-type template parameter. */\n  CXCursor_NonTypeTemplateParameter = 28,\n  /** A C++ template template parameter. */\n  CXCursor_TemplateTemplateParameter = 29,\n  /** A C++ function template. */\n  CXCursor_FunctionTemplate = 30,\n  /** A C++ class template. */\n  CXCursor_ClassTemplate = 31,\n  /** A C++ class template partial specialization. */\n  CXCursor_ClassTemplatePartialSpecialization = 32,\n  /** A C++ namespace alias declaration. */\n  CXCursor_NamespaceAlias = 33,\n  /** A C++ using directive. */\n  CXCursor_UsingDirective = 34,\n  /** A C++ using declaration. */\n  CXCursor_UsingDeclaration = 35,\n  /** A C++ alias declaration */\n  CXCursor_TypeAliasDecl = 36,\n  /** An Objective-C \\@synthesize definition. */\n  CXCursor_ObjCSynthesizeDecl = 37,\n  /** An Objective-C \\@dynamic definition. */\n  CXCursor_ObjCDynamicDecl = 38,\n  /** An access specifier. */\n  CXCursor_CXXAccessSpecifier = 39,\n\n  CXCursor_FirstDecl = CXCursor_UnexposedDecl,\n  CXCursor_LastDecl = CXCursor_CXXAccessSpecifier,\n\n  /* References */\n  CXCursor_FirstRef = 40, /* Decl references */\n  CXCursor_ObjCSuperClassRef = 40,\n  CXCursor_ObjCProtocolRef = 41,\n  CXCursor_ObjCClassRef = 42,\n  /**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */\n  CXCursor_TypeRef = 43,\n  CXCursor_CXXBaseSpecifier = 44,\n  /**\n   * A reference to a class template, function template, template\n   * template parameter, or class template partial specialization.\n   */\n  CXCursor_TemplateRef = 45,\n  /**\n   * A reference to a namespace or namespace alias.\n   */\n  CXCursor_NamespaceRef = 46,\n  /**\n   * A reference to a member of a struct, union, or class that occurs in\n   * some non-expression context, e.g., a designated initializer.\n   */\n  CXCursor_MemberRef = 47,\n  /**\n   * A reference to a labeled statement.\n   *\n   * This cursor kind is used to describe the jump to \"start_over\" in the\n   * goto statement in the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   *\n   *     goto start_over;\n   * \\endcode\n   *\n   * A label reference cursor refers to a label statement.\n   */\n  CXCursor_LabelRef = 48,\n\n  /**\n   * A reference to a set of overloaded functions or function templates\n   * that has not yet been resolved to a specific function or function template.\n   *\n   * An overloaded declaration reference cursor occurs in C++ templates where\n   * a dependent name refers to a function. For example:\n   *\n   * \\code\n   * template<typename T> void swap(T&, T&);\n   *\n   * struct X { ... };\n   * void swap(X&, X&);\n   *\n   * template<typename T>\n   * void reverse(T* first, T* last) {\n   *   while (first < last - 1) {\n   *     swap(*first, *--last);\n   *     ++first;\n   *   }\n   * }\n   *\n   * struct Y { };\n   * void swap(Y&, Y&);\n   * \\endcode\n   *\n   * Here, the identifier \"swap\" is associated with an overloaded declaration\n   * reference. In the template definition, \"swap\" refers to either of the two\n   * \"swap\" functions declared above, so both results will be available. At\n   * instantiation time, \"swap\" may also refer to other functions found via\n   * argument-dependent lookup (e.g., the \"swap\" function at the end of the\n   * example).\n   *\n   * The functions \\c clang_getNumOverloadedDecls() and\n   * \\c clang_getOverloadedDecl() can be used to retrieve the definitions\n   * referenced by this cursor.\n   */\n  CXCursor_OverloadedDeclRef = 49,\n\n  /**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */\n  CXCursor_VariableRef = 50,\n\n  CXCursor_LastRef = CXCursor_VariableRef,\n\n  /* Error conditions */\n  CXCursor_FirstInvalid = 70,\n  CXCursor_InvalidFile = 70,\n  CXCursor_NoDeclFound = 71,\n  CXCursor_NotImplemented = 72,\n  CXCursor_InvalidCode = 73,\n  CXCursor_LastInvalid = CXCursor_InvalidCode,\n\n  /* Expressions */\n  CXCursor_FirstExpr = 100,\n\n  /**\n   * An expression whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed expressions have the same operations as any other kind\n   * of expression; one can extract their location information,\n   * spelling, children, etc. However, the specific kind of the\n   * expression is not reported.\n   */\n  CXCursor_UnexposedExpr = 100,\n\n  /**\n   * An expression that refers to some value declaration, such\n   * as a function, variable, or enumerator.\n   */\n  CXCursor_DeclRefExpr = 101,\n\n  /**\n   * An expression that refers to a member of a struct, union,\n   * class, Objective-C class, etc.\n   */\n  CXCursor_MemberRefExpr = 102,\n\n  /** An expression that calls a function. */\n  CXCursor_CallExpr = 103,\n\n  /** An expression that sends a message to an Objective-C\n   object or class. */\n  CXCursor_ObjCMessageExpr = 104,\n\n  /** An expression that represents a block literal. */\n  CXCursor_BlockExpr = 105,\n\n  /** An integer literal.\n   */\n  CXCursor_IntegerLiteral = 106,\n\n  /** A floating point number literal.\n   */\n  CXCursor_FloatingLiteral = 107,\n\n  /** An imaginary number literal.\n   */\n  CXCursor_ImaginaryLiteral = 108,\n\n  /** A string literal.\n   */\n  CXCursor_StringLiteral = 109,\n\n  /** A character literal.\n   */\n  CXCursor_CharacterLiteral = 110,\n\n  /** A parenthesized expression, e.g. \"(1)\".\n   *\n   * This AST node is only formed if full location information is requested.\n   */\n  CXCursor_ParenExpr = 111,\n\n  /** This represents the unary-expression's (except sizeof and\n   * alignof).\n   */\n  CXCursor_UnaryOperator = 112,\n\n  /** [C99 6.5.2.1] Array Subscripting.\n   */\n  CXCursor_ArraySubscriptExpr = 113,\n\n  /** A builtin binary operation expression such as \"x + y\" or\n   * \"x <= y\".\n   */\n  CXCursor_BinaryOperator = 114,\n\n  /** Compound assignment such as \"+=\".\n   */\n  CXCursor_CompoundAssignOperator = 115,\n\n  /** The ?: ternary operator.\n   */\n  CXCursor_ConditionalOperator = 116,\n\n  /** An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n   * (C++ [expr.cast]), which uses the syntax (Type)expr.\n   *\n   * For example: (int)f.\n   */\n  CXCursor_CStyleCastExpr = 117,\n\n  /** [C99 6.5.2.5]\n   */\n  CXCursor_CompoundLiteralExpr = 118,\n\n  /** Describes an C or C++ initializer list.\n   */\n  CXCursor_InitListExpr = 119,\n\n  /** The GNU address of label extension, representing &&label.\n   */\n  CXCursor_AddrLabelExpr = 120,\n\n  /** This is the GNU Statement Expression extension: ({int X=4; X;})\n   */\n  CXCursor_StmtExpr = 121,\n\n  /** Represents a C11 generic selection.\n   */\n  CXCursor_GenericSelectionExpr = 122,\n\n  /** Implements the GNU __null extension, which is a name for a null\n   * pointer constant that has integral type (e.g., int or long) and is the same\n   * size and alignment as a pointer.\n   *\n   * The __null extension is typically only used by system headers, which define\n   * NULL as __null in C++ rather than using 0 (which is an integer that may not\n   * match the size of a pointer).\n   */\n  CXCursor_GNUNullExpr = 123,\n\n  /** C++'s static_cast<> expression.\n   */\n  CXCursor_CXXStaticCastExpr = 124,\n\n  /** C++'s dynamic_cast<> expression.\n   */\n  CXCursor_CXXDynamicCastExpr = 125,\n\n  /** C++'s reinterpret_cast<> expression.\n   */\n  CXCursor_CXXReinterpretCastExpr = 126,\n\n  /** C++'s const_cast<> expression.\n   */\n  CXCursor_CXXConstCastExpr = 127,\n\n  /** Represents an explicit C++ type conversion that uses \"functional\"\n   * notion (C++ [expr.type.conv]).\n   *\n   * Example:\n   * \\code\n   *   x = int(0.5);\n   * \\endcode\n   */\n  CXCursor_CXXFunctionalCastExpr = 128,\n\n  /** A C++ typeid expression (C++ [expr.typeid]).\n   */\n  CXCursor_CXXTypeidExpr = 129,\n\n  /** [C++ 2.13.5] C++ Boolean Literal.\n   */\n  CXCursor_CXXBoolLiteralExpr = 130,\n\n  /** [C++0x 2.14.7] C++ Pointer Literal.\n   */\n  CXCursor_CXXNullPtrLiteralExpr = 131,\n\n  /** Represents the \"this\" expression in C++\n   */\n  CXCursor_CXXThisExpr = 132,\n\n  /** [C++ 15] C++ Throw Expression.\n   *\n   * This handles 'throw' and 'throw' assignment-expression. When\n   * assignment-expression isn't present, Op will be null.\n   */\n  CXCursor_CXXThrowExpr = 133,\n\n  /** A new expression for memory allocation and constructor calls, e.g:\n   * \"new CXXNewExpr(foo)\".\n   */\n  CXCursor_CXXNewExpr = 134,\n\n  /** A delete expression for memory deallocation and destructor calls,\n   * e.g. \"delete[] pArray\".\n   */\n  CXCursor_CXXDeleteExpr = 135,\n\n  /** A unary expression. (noexcept, sizeof, or other traits)\n   */\n  CXCursor_UnaryExpr = 136,\n\n  /** An Objective-C string literal i.e. @\"foo\".\n   */\n  CXCursor_ObjCStringLiteral = 137,\n\n  /** An Objective-C \\@encode expression.\n   */\n  CXCursor_ObjCEncodeExpr = 138,\n\n  /** An Objective-C \\@selector expression.\n   */\n  CXCursor_ObjCSelectorExpr = 139,\n\n  /** An Objective-C \\@protocol expression.\n   */\n  CXCursor_ObjCProtocolExpr = 140,\n\n  /** An Objective-C \"bridged\" cast expression, which casts between\n   * Objective-C pointers and C pointers, transferring ownership in the process.\n   *\n   * \\code\n   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n   * \\endcode\n   */\n  CXCursor_ObjCBridgedCastExpr = 141,\n\n  /** Represents a C++0x pack expansion that produces a sequence of\n   * expressions.\n   *\n   * A pack expansion expression contains a pattern (which itself is an\n   * expression) followed by an ellipsis. For example:\n   *\n   * \\code\n   * template<typename F, typename ...Types>\n   * void forward(F f, Types &&...args) {\n   *  f(static_cast<Types&&>(args)...);\n   * }\n   * \\endcode\n   */\n  CXCursor_PackExpansionExpr = 142,\n\n  /** Represents an expression that computes the length of a parameter\n   * pack.\n   *\n   * \\code\n   * template<typename ...Types>\n   * struct count {\n   *   static const unsigned value = sizeof...(Types);\n   * };\n   * \\endcode\n   */\n  CXCursor_SizeOfPackExpr = 143,\n\n  /* Represents a C++ lambda expression that produces a local function\n   * object.\n   *\n   * \\code\n   * void abssort(float *x, unsigned N) {\n   *   std::sort(x, x + N,\n   *             [](float a, float b) {\n   *               return std::abs(a) < std::abs(b);\n   *             });\n   * }\n   * \\endcode\n   */\n  CXCursor_LambdaExpr = 144,\n\n  /** Objective-c Boolean Literal.\n   */\n  CXCursor_ObjCBoolLiteralExpr = 145,\n\n  /** Represents the \"self\" expression in an Objective-C method.\n   */\n  CXCursor_ObjCSelfExpr = 146,\n\n  /** OpenMP 5.0 [2.1.5, Array Section].\n   */\n  CXCursor_OMPArraySectionExpr = 147,\n\n  /** Represents an @available(...) check.\n   */\n  CXCursor_ObjCAvailabilityCheckExpr = 148,\n\n  /**\n   * Fixed point literal\n   */\n  CXCursor_FixedPointLiteral = 149,\n\n  /** OpenMP 5.0 [2.1.4, Array Shaping].\n   */\n  CXCursor_OMPArrayShapingExpr = 150,\n\n  /**\n   * OpenMP 5.0 [2.1.6 Iterators]\n   */\n  CXCursor_OMPIteratorExpr = 151,\n\n  /** OpenCL's addrspace_cast<> expression.\n   */\n  CXCursor_CXXAddrspaceCastExpr = 152,\n\n  CXCursor_LastExpr = CXCursor_CXXAddrspaceCastExpr,\n\n  /* Statements */\n  CXCursor_FirstStmt = 200,\n  /**\n   * A statement whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed statements have the same operations as any other kind of\n   * statement; one can extract their location information, spelling,\n   * children, etc. However, the specific kind of the statement is not\n   * reported.\n   */\n  CXCursor_UnexposedStmt = 200,\n\n  /** A labelled statement in a function.\n   *\n   * This cursor kind is used to describe the \"start_over:\" label statement in\n   * the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   * \\endcode\n   *\n   */\n  CXCursor_LabelStmt = 201,\n\n  /** A group of statements like { stmt stmt }.\n   *\n   * This cursor kind is used to describe compound statements, e.g. function\n   * bodies.\n   */\n  CXCursor_CompoundStmt = 202,\n\n  /** A case statement.\n   */\n  CXCursor_CaseStmt = 203,\n\n  /** A default statement.\n   */\n  CXCursor_DefaultStmt = 204,\n\n  /** An if statement\n   */\n  CXCursor_IfStmt = 205,\n\n  /** A switch statement.\n   */\n  CXCursor_SwitchStmt = 206,\n\n  /** A while statement.\n   */\n  CXCursor_WhileStmt = 207,\n\n  /** A do statement.\n   */\n  CXCursor_DoStmt = 208,\n\n  /** A for statement.\n   */\n  CXCursor_ForStmt = 209,\n\n  /** A goto statement.\n   */\n  CXCursor_GotoStmt = 210,\n\n  /** An indirect goto statement.\n   */\n  CXCursor_IndirectGotoStmt = 211,\n\n  /** A continue statement.\n   */\n  CXCursor_ContinueStmt = 212,\n\n  /** A break statement.\n   */\n  CXCursor_BreakStmt = 213,\n\n  /** A return statement.\n   */\n  CXCursor_ReturnStmt = 214,\n\n  /** A GCC inline assembly statement extension.\n   */\n  CXCursor_GCCAsmStmt = 215,\n  CXCursor_AsmStmt = CXCursor_GCCAsmStmt,\n\n  /** Objective-C's overall \\@try-\\@catch-\\@finally statement.\n   */\n  CXCursor_ObjCAtTryStmt = 216,\n\n  /** Objective-C's \\@catch statement.\n   */\n  CXCursor_ObjCAtCatchStmt = 217,\n\n  /** Objective-C's \\@finally statement.\n   */\n  CXCursor_ObjCAtFinallyStmt = 218,\n\n  /** Objective-C's \\@throw statement.\n   */\n  CXCursor_ObjCAtThrowStmt = 219,\n\n  /** Objective-C's \\@synchronized statement.\n   */\n  CXCursor_ObjCAtSynchronizedStmt = 220,\n\n  /** Objective-C's autorelease pool statement.\n   */\n  CXCursor_ObjCAutoreleasePoolStmt = 221,\n\n  /** Objective-C's collection statement.\n   */\n  CXCursor_ObjCForCollectionStmt = 222,\n\n  /** C++'s catch statement.\n   */\n  CXCursor_CXXCatchStmt = 223,\n\n  /** C++'s try statement.\n   */\n  CXCursor_CXXTryStmt = 224,\n\n  /** C++'s for (* : *) statement.\n   */\n  CXCursor_CXXForRangeStmt = 225,\n\n  /** Windows Structured Exception Handling's try statement.\n   */\n  CXCursor_SEHTryStmt = 226,\n\n  /** Windows Structured Exception Handling's except statement.\n   */\n  CXCursor_SEHExceptStmt = 227,\n\n  /** Windows Structured Exception Handling's finally statement.\n   */\n  CXCursor_SEHFinallyStmt = 228,\n\n  /** A MS inline assembly statement extension.\n   */\n  CXCursor_MSAsmStmt = 229,\n\n  /** The null statement \";\": C99 6.8.3p3.\n   *\n   * This cursor kind is used to describe the null statement.\n   */\n  CXCursor_NullStmt = 230,\n\n  /** Adaptor class for mixing declarations with statements and\n   * expressions.\n   */\n  CXCursor_DeclStmt = 231,\n\n  /** OpenMP parallel directive.\n   */\n  CXCursor_OMPParallelDirective = 232,\n\n  /** OpenMP SIMD directive.\n   */\n  CXCursor_OMPSimdDirective = 233,\n\n  /** OpenMP for directive.\n   */\n  CXCursor_OMPForDirective = 234,\n\n  /** OpenMP sections directive.\n   */\n  CXCursor_OMPSectionsDirective = 235,\n\n  /** OpenMP section directive.\n   */\n  CXCursor_OMPSectionDirective = 236,\n\n  /** OpenMP single directive.\n   */\n  CXCursor_OMPSingleDirective = 237,\n\n  /** OpenMP parallel for directive.\n   */\n  CXCursor_OMPParallelForDirective = 238,\n\n  /** OpenMP parallel sections directive.\n   */\n  CXCursor_OMPParallelSectionsDirective = 239,\n\n  /** OpenMP task directive.\n   */\n  CXCursor_OMPTaskDirective = 240,\n\n  /** OpenMP master directive.\n   */\n  CXCursor_OMPMasterDirective = 241,\n\n  /** OpenMP critical directive.\n   */\n  CXCursor_OMPCriticalDirective = 242,\n\n  /** OpenMP taskyield directive.\n   */\n  CXCursor_OMPTaskyieldDirective = 243,\n\n  /** OpenMP barrier directive.\n   */\n  CXCursor_OMPBarrierDirective = 244,\n\n  /** OpenMP taskwait directive.\n   */\n  CXCursor_OMPTaskwaitDirective = 245,\n\n  /** OpenMP flush directive.\n   */\n  CXCursor_OMPFlushDirective = 246,\n\n  /** Windows Structured Exception Handling's leave statement.\n   */\n  CXCursor_SEHLeaveStmt = 247,\n\n  /** OpenMP ordered directive.\n   */\n  CXCursor_OMPOrderedDirective = 248,\n\n  /** OpenMP atomic directive.\n   */\n  CXCursor_OMPAtomicDirective = 249,\n\n  /** OpenMP for SIMD directive.\n   */\n  CXCursor_OMPForSimdDirective = 250,\n\n  /** OpenMP parallel for SIMD directive.\n   */\n  CXCursor_OMPParallelForSimdDirective = 251,\n\n  /** OpenMP target directive.\n   */\n  CXCursor_OMPTargetDirective = 252,\n\n  /** OpenMP teams directive.\n   */\n  CXCursor_OMPTeamsDirective = 253,\n\n  /** OpenMP taskgroup directive.\n   */\n  CXCursor_OMPTaskgroupDirective = 254,\n\n  /** OpenMP cancellation point directive.\n   */\n  CXCursor_OMPCancellationPointDirective = 255,\n\n  /** OpenMP cancel directive.\n   */\n  CXCursor_OMPCancelDirective = 256,\n\n  /** OpenMP target data directive.\n   */\n  CXCursor_OMPTargetDataDirective = 257,\n\n  /** OpenMP taskloop directive.\n   */\n  CXCursor_OMPTaskLoopDirective = 258,\n\n  /** OpenMP taskloop simd directive.\n   */\n  CXCursor_OMPTaskLoopSimdDirective = 259,\n\n  /** OpenMP distribute directive.\n   */\n  CXCursor_OMPDistributeDirective = 260,\n\n  /** OpenMP target enter data directive.\n   */\n  CXCursor_OMPTargetEnterDataDirective = 261,\n\n  /** OpenMP target exit data directive.\n   */\n  CXCursor_OMPTargetExitDataDirective = 262,\n\n  /** OpenMP target parallel directive.\n   */\n  CXCursor_OMPTargetParallelDirective = 263,\n\n  /** OpenMP target parallel for directive.\n   */\n  CXCursor_OMPTargetParallelForDirective = 264,\n\n  /** OpenMP target update directive.\n   */\n  CXCursor_OMPTargetUpdateDirective = 265,\n\n  /** OpenMP distribute parallel for directive.\n   */\n  CXCursor_OMPDistributeParallelForDirective = 266,\n\n  /** OpenMP distribute parallel for simd directive.\n   */\n  CXCursor_OMPDistributeParallelForSimdDirective = 267,\n\n  /** OpenMP distribute simd directive.\n   */\n  CXCursor_OMPDistributeSimdDirective = 268,\n\n  /** OpenMP target parallel for simd directive.\n   */\n  CXCursor_OMPTargetParallelForSimdDirective = 269,\n\n  /** OpenMP target simd directive.\n   */\n  CXCursor_OMPTargetSimdDirective = 270,\n\n  /** OpenMP teams distribute directive.\n   */\n  CXCursor_OMPTeamsDistributeDirective = 271,\n\n  /** OpenMP teams distribute simd directive.\n   */\n  CXCursor_OMPTeamsDistributeSimdDirective = 272,\n\n  /** OpenMP teams distribute parallel for simd directive.\n   */\n  CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273,\n\n  /** OpenMP teams distribute parallel for directive.\n   */\n  CXCursor_OMPTeamsDistributeParallelForDirective = 274,\n\n  /** OpenMP target teams directive.\n   */\n  CXCursor_OMPTargetTeamsDirective = 275,\n\n  /** OpenMP target teams distribute directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeDirective = 276,\n\n  /** OpenMP target teams distribute parallel for directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277,\n\n  /** OpenMP target teams distribute parallel for simd directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 278,\n\n  /** OpenMP target teams distribute simd directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeSimdDirective = 279,\n\n  /** C++2a std::bit_cast expression.\n   */\n  CXCursor_BuiltinBitCastExpr = 280,\n\n  /** OpenMP master taskloop directive.\n   */\n  CXCursor_OMPMasterTaskLoopDirective = 281,\n\n  /** OpenMP parallel master taskloop directive.\n   */\n  CXCursor_OMPParallelMasterTaskLoopDirective = 282,\n\n  /** OpenMP master taskloop simd directive.\n   */\n  CXCursor_OMPMasterTaskLoopSimdDirective = 283,\n\n  /** OpenMP parallel master taskloop simd directive.\n   */\n  CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284,\n\n  /** OpenMP parallel master directive.\n   */\n  CXCursor_OMPParallelMasterDirective = 285,\n\n  /** OpenMP depobj directive.\n   */\n  CXCursor_OMPDepobjDirective = 286,\n\n  /** OpenMP scan directive.\n   */\n  CXCursor_OMPScanDirective = 287,\n\n  /** OpenMP tile directive.\n   */\n  CXCursor_OMPTileDirective = 288,\n\n  /** OpenMP canonical loop.\n   */\n  CXCursor_OMPCanonicalLoop = 289,\n\n  CXCursor_LastStmt = CXCursor_OMPCanonicalLoop,\n\n  /**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */\n  CXCursor_TranslationUnit = 300,\n\n  /* Attributes */\n  CXCursor_FirstAttr = 400,\n  /**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */\n  CXCursor_UnexposedAttr = 400,\n\n  CXCursor_IBActionAttr = 401,\n  CXCursor_IBOutletAttr = 402,\n  CXCursor_IBOutletCollectionAttr = 403,\n  CXCursor_CXXFinalAttr = 404,\n  CXCursor_CXXOverrideAttr = 405,\n  CXCursor_AnnotateAttr = 406,\n  CXCursor_AsmLabelAttr = 407,\n  CXCursor_PackedAttr = 408,\n  CXCursor_PureAttr = 409,\n  CXCursor_ConstAttr = 410,\n  CXCursor_NoDuplicateAttr = 411,\n  CXCursor_CUDAConstantAttr = 412,\n  CXCursor_CUDADeviceAttr = 413,\n  CXCursor_CUDAGlobalAttr = 414,\n  CXCursor_CUDAHostAttr = 415,\n  CXCursor_CUDASharedAttr = 416,\n  CXCursor_VisibilityAttr = 417,\n  CXCursor_DLLExport = 418,\n  CXCursor_DLLImport = 419,\n  CXCursor_NSReturnsRetained = 420,\n  CXCursor_NSReturnsNotRetained = 421,\n  CXCursor_NSReturnsAutoreleased = 422,\n  CXCursor_NSConsumesSelf = 423,\n  CXCursor_NSConsumed = 424,\n  CXCursor_ObjCException = 425,\n  CXCursor_ObjCNSObject = 426,\n  CXCursor_ObjCIndependentClass = 427,\n  CXCursor_ObjCPreciseLifetime = 428,\n  CXCursor_ObjCReturnsInnerPointer = 429,\n  CXCursor_ObjCRequiresSuper = 430,\n  CXCursor_ObjCRootClass = 431,\n  CXCursor_ObjCSubclassingRestricted = 432,\n  CXCursor_ObjCExplicitProtocolImpl = 433,\n  CXCursor_ObjCDesignatedInitializer = 434,\n  CXCursor_ObjCRuntimeVisible = 435,\n  CXCursor_ObjCBoxable = 436,\n  CXCursor_FlagEnum = 437,\n  CXCursor_ConvergentAttr = 438,\n  CXCursor_WarnUnusedAttr = 439,\n  CXCursor_WarnUnusedResultAttr = 440,\n  CXCursor_AlignedAttr = 441,\n  CXCursor_LastAttr = CXCursor_AlignedAttr,\n\n  /* Preprocessing */\n  CXCursor_PreprocessingDirective = 500,\n  CXCursor_MacroDefinition = 501,\n  CXCursor_MacroExpansion = 502,\n  CXCursor_MacroInstantiation = CXCursor_MacroExpansion,\n  CXCursor_InclusionDirective = 503,\n  CXCursor_FirstPreprocessing = CXCursor_PreprocessingDirective,\n  CXCursor_LastPreprocessing = CXCursor_InclusionDirective,\n\n  /* Extra Declarations */\n  /**\n   * A module import declaration.\n   */\n  CXCursor_ModuleImportDecl = 600,\n  CXCursor_TypeAliasTemplateDecl = 601,\n  /**\n   * A static_assert or _Static_assert node\n   */\n  CXCursor_StaticAssert = 602,\n  /**\n   * a friend declaration.\n   */\n  CXCursor_FriendDecl = 603,\n  CXCursor_FirstExtraDecl = CXCursor_ModuleImportDecl,\n  CXCursor_LastExtraDecl = CXCursor_FriendDecl,\n\n  /**\n   * A code completion overload candidate.\n   */\n  CXCursor_OverloadCandidate = 700\n};\n\n/**\n * A cursor representing some element in the abstract syntax tree for\n * a translation unit.\n *\n * The cursor abstraction unifies the different kinds of entities in a\n * program--declaration, statements, expressions, references to declarations,\n * etc.--under a single \"cursor\" abstraction with a common set of operations.\n * Common operation for a cursor include: getting the physical location in\n * a source file where the cursor points, getting the name associated with a\n * cursor, and retrieving cursors for any child nodes of a particular cursor.\n *\n * Cursors can be produced in two specific ways.\n * clang_getTranslationUnitCursor() produces a cursor for a translation unit,\n * from which one can use clang_visitChildren() to explore the rest of the\n * translation unit. clang_getCursor() maps from a physical source location\n * to the entity that resides at that location, allowing one to map from the\n * source code into the AST.\n */\ntypedef struct {\n  enum CXCursorKind kind;\n  int xdata;\n  const void *data[3];\n} CXCursor;\n\n/**\n * \\defgroup CINDEX_CURSOR_MANIP Cursor manipulations\n *\n * @{\n */\n\n/**\n * Retrieve the NULL cursor, which represents no entity.\n */\nCINDEX_LINKAGE CXCursor clang_getNullCursor(void);\n\n/**\n * Retrieve the cursor that represents the given translation unit.\n *\n * The translation unit cursor can be used to start traversing the\n * various declarations within the given translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getTranslationUnitCursor(CXTranslationUnit);\n\n/**\n * Determine whether two cursors are equivalent.\n */\nCINDEX_LINKAGE unsigned clang_equalCursors(CXCursor, CXCursor);\n\n/**\n * Returns non-zero if \\p cursor is null.\n */\nCINDEX_LINKAGE int clang_Cursor_isNull(CXCursor cursor);\n\n/**\n * Compute a hash value for the given cursor.\n */\nCINDEX_LINKAGE unsigned clang_hashCursor(CXCursor);\n\n/**\n * Retrieve the kind of the given cursor.\n */\nCINDEX_LINKAGE enum CXCursorKind clang_getCursorKind(CXCursor);\n\n/**\n * Determine whether the given cursor kind represents a declaration.\n */\nCINDEX_LINKAGE unsigned clang_isDeclaration(enum CXCursorKind);\n\n/**\n * Determine whether the given declaration is invalid.\n *\n * A declaration is invalid if it could not be parsed successfully.\n *\n * \\returns non-zero if the cursor represents a declaration and it is\n * invalid, otherwise NULL.\n */\nCINDEX_LINKAGE unsigned clang_isInvalidDeclaration(CXCursor);\n\n/**\n * Determine whether the given cursor kind represents a simple\n * reference.\n *\n * Note that other kinds of cursors (such as expressions) can also refer to\n * other cursors. Use clang_getCursorReferenced() to determine whether a\n * particular cursor refers to another entity.\n */\nCINDEX_LINKAGE unsigned clang_isReference(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents an expression.\n */\nCINDEX_LINKAGE unsigned clang_isExpression(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents a statement.\n */\nCINDEX_LINKAGE unsigned clang_isStatement(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents an attribute.\n */\nCINDEX_LINKAGE unsigned clang_isAttribute(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor has any attributes.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_hasAttrs(CXCursor C);\n\n/**\n * Determine whether the given cursor kind represents an invalid\n * cursor.\n */\nCINDEX_LINKAGE unsigned clang_isInvalid(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents a translation\n * unit.\n */\nCINDEX_LINKAGE unsigned clang_isTranslationUnit(enum CXCursorKind);\n\n/***\n * Determine whether the given cursor represents a preprocessing\n * element, such as a preprocessor directive or macro instantiation.\n */\nCINDEX_LINKAGE unsigned clang_isPreprocessing(enum CXCursorKind);\n\n/***\n * Determine whether the given cursor represents a currently\n *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n */\nCINDEX_LINKAGE unsigned clang_isUnexposed(enum CXCursorKind);\n\n/**\n * Describe the linkage of the entity referred to by a cursor.\n */\nenum CXLinkageKind {\n  /** This value indicates that no linkage information is available\n   * for a provided CXCursor. */\n  CXLinkage_Invalid,\n  /**\n   * This is the linkage for variables, parameters, and so on that\n   *  have automatic storage.  This covers normal (non-extern) local variables.\n   */\n  CXLinkage_NoLinkage,\n  /** This is the linkage for static variables and static functions. */\n  CXLinkage_Internal,\n  /** This is the linkage for entities with external linkage that live\n   * in C++ anonymous namespaces.*/\n  CXLinkage_UniqueExternal,\n  /** This is the linkage for entities with true, external linkage. */\n  CXLinkage_External\n};\n\n/**\n * Determine the linkage of the entity referred to by a given cursor.\n */\nCINDEX_LINKAGE enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor);\n\nenum CXVisibilityKind {\n  /** This value indicates that no visibility information is available\n   * for a provided CXCursor. */\n  CXVisibility_Invalid,\n\n  /** Symbol not seen by the linker. */\n  CXVisibility_Hidden,\n  /** Symbol seen by the linker but resolves to a symbol inside this object. */\n  CXVisibility_Protected,\n  /** Symbol seen by the linker and acts like a normal symbol. */\n  CXVisibility_Default\n};\n\n/**\n * Describe the visibility of the entity referred to by a cursor.\n *\n * This returns the default visibility if not explicitly specified by\n * a visibility attribute. The default visibility may be changed by\n * commandline arguments.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The visibility of the cursor.\n */\nCINDEX_LINKAGE enum CXVisibilityKind clang_getCursorVisibility(CXCursor cursor);\n\n/**\n * Determine the availability of the entity that this cursor refers to,\n * taking the current target platform into account.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The availability of the cursor.\n */\nCINDEX_LINKAGE enum CXAvailabilityKind\nclang_getCursorAvailability(CXCursor cursor);\n\n/**\n * Describes the availability of a given entity on a particular platform, e.g.,\n * a particular class might only be available on Mac OS 10.7 or newer.\n */\ntypedef struct CXPlatformAvailability {\n  /**\n   * A string that describes the platform for which this structure\n   * provides availability information.\n   *\n   * Possible values are \"ios\" or \"macos\".\n   */\n  CXString Platform;\n  /**\n   * The version number in which this entity was introduced.\n   */\n  CXVersion Introduced;\n  /**\n   * The version number in which this entity was deprecated (but is\n   * still available).\n   */\n  CXVersion Deprecated;\n  /**\n   * The version number in which this entity was obsoleted, and therefore\n   * is no longer available.\n   */\n  CXVersion Obsoleted;\n  /**\n   * Whether the entity is unconditionally unavailable on this platform.\n   */\n  int Unavailable;\n  /**\n   * An optional message to provide to a user of this API, e.g., to\n   * suggest replacement APIs.\n   */\n  CXString Message;\n} CXPlatformAvailability;\n\n/**\n * Determine the availability of the entity that this cursor refers to\n * on any platforms for which availability information is known.\n *\n * \\param cursor The cursor to query.\n *\n * \\param always_deprecated If non-NULL, will be set to indicate whether the\n * entity is deprecated on all platforms.\n *\n * \\param deprecated_message If non-NULL, will be set to the message text\n * provided along with the unconditional deprecation of this entity. The client\n * is responsible for deallocating this string.\n *\n * \\param always_unavailable If non-NULL, will be set to indicate whether the\n * entity is unavailable on all platforms.\n *\n * \\param unavailable_message If non-NULL, will be set to the message text\n * provided along with the unconditional unavailability of this entity. The\n * client is responsible for deallocating this string.\n *\n * \\param availability If non-NULL, an array of CXPlatformAvailability instances\n * that will be populated with platform availability information, up to either\n * the number of platforms for which availability information is available (as\n * returned by this function) or \\c availability_size, whichever is smaller.\n *\n * \\param availability_size The number of elements available in the\n * \\c availability array.\n *\n * \\returns The number of platforms (N) for which availability information is\n * available (which is unrelated to \\c availability_size).\n *\n * Note that the client is responsible for calling\n * \\c clang_disposeCXPlatformAvailability to free each of the\n * platform-availability structures returned. There are\n * \\c min(N, availability_size) such structures.\n */\nCINDEX_LINKAGE int clang_getCursorPlatformAvailability(\n    CXCursor cursor, int *always_deprecated, CXString *deprecated_message,\n    int *always_unavailable, CXString *unavailable_message,\n    CXPlatformAvailability *availability, int availability_size);\n\n/**\n * Free the memory associated with a \\c CXPlatformAvailability structure.\n */\nCINDEX_LINKAGE void\nclang_disposeCXPlatformAvailability(CXPlatformAvailability *availability);\n\n/**\n * If cursor refers to a variable declaration and it has initializer returns\n * cursor referring to the initializer otherwise return null cursor.\n */\nCINDEX_LINKAGE CXCursor clang_Cursor_getVarDeclInitializer(CXCursor cursor);\n\n/**\n * If cursor refers to a variable declaration that has global storage returns 1.\n * If cursor refers to a variable declaration that doesn't have global storage\n * returns 0. Otherwise returns -1.\n */\nCINDEX_LINKAGE int clang_Cursor_hasVarDeclGlobalStorage(CXCursor cursor);\n\n/**\n * If cursor refers to a variable declaration that has external storage\n * returns 1. If cursor refers to a variable declaration that doesn't have\n * external storage returns 0. Otherwise returns -1.\n */\nCINDEX_LINKAGE int clang_Cursor_hasVarDeclExternalStorage(CXCursor cursor);\n\n/**\n * Describe the \"language\" of the entity referred to by a cursor.\n */\nenum CXLanguageKind {\n  CXLanguage_Invalid = 0,\n  CXLanguage_C,\n  CXLanguage_ObjC,\n  CXLanguage_CPlusPlus\n};\n\n/**\n * Determine the \"language\" of the entity referred to by a given cursor.\n */\nCINDEX_LINKAGE enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor);\n\n/**\n * Describe the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */\nenum CXTLSKind { CXTLS_None = 0, CXTLS_Dynamic, CXTLS_Static };\n\n/**\n * Determine the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */\nCINDEX_LINKAGE enum CXTLSKind clang_getCursorTLSKind(CXCursor cursor);\n\n/**\n * Returns the translation unit that a cursor originated from.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor);\n\n/**\n * A fast container representing a set of CXCursors.\n */\ntypedef struct CXCursorSetImpl *CXCursorSet;\n\n/**\n * Creates an empty CXCursorSet.\n */\nCINDEX_LINKAGE CXCursorSet clang_createCXCursorSet(void);\n\n/**\n * Disposes a CXCursorSet and releases its associated memory.\n */\nCINDEX_LINKAGE void clang_disposeCXCursorSet(CXCursorSet cset);\n\n/**\n * Queries a CXCursorSet to see if it contains a specific CXCursor.\n *\n * \\returns non-zero if the set contains the specified cursor.\n */\nCINDEX_LINKAGE unsigned clang_CXCursorSet_contains(CXCursorSet cset,\n                                                   CXCursor cursor);\n\n/**\n * Inserts a CXCursor into a CXCursorSet.\n *\n * \\returns zero if the CXCursor was already in the set, and non-zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_CXCursorSet_insert(CXCursorSet cset,\n                                                 CXCursor cursor);\n\n/**\n * Determine the semantic parent of the given cursor.\n *\n * The semantic parent of a cursor is the cursor that semantically contains\n * the given \\p cursor. For many declarations, the lexical and semantic parents\n * are equivalent (the lexical parent is returned by\n * \\c clang_getCursorLexicalParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For global declarations, the semantic parent is the translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorSemanticParent(CXCursor cursor);\n\n/**\n * Determine the lexical parent of the given cursor.\n *\n * The lexical parent of a cursor is the cursor in which the given \\p cursor\n * was actually written. For many declarations, the lexical and semantic parents\n * are equivalent (the semantic parent is returned by\n * \\c clang_getCursorSemanticParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For declarations written in the global scope, the lexical parent is\n * the translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorLexicalParent(CXCursor cursor);\n\n/**\n * Determine the set of methods that are overridden by the given\n * method.\n *\n * In both Objective-C and C++, a method (aka virtual member function,\n * in C++) can override a virtual method in a base class. For\n * Objective-C, a method is said to override any method in the class's\n * base class, its protocols, or its categories' protocols, that has the same\n * selector and is of the same kind (class or instance).\n * If no such method exists, the search continues to the class's superclass,\n * its protocols, and its categories, and so on. A method from an Objective-C\n * implementation is considered to override the same methods as its\n * corresponding method in the interface.\n *\n * For C++, a virtual member function overrides any virtual member\n * function with the same signature that occurs in its base\n * classes. With multiple inheritance, a virtual member function can\n * override several virtual member functions coming from different\n * base classes.\n *\n * In all cases, this function determines the immediate overridden\n * method, rather than all of the overridden methods. For example, if\n * a method is originally declared in a class A, then overridden in B\n * (which in inherits from A) and also in C (which inherited from B),\n * then the only overridden method returned from this function when\n * invoked on C's method will be B's method. The client may then\n * invoke this function again, given the previously-found overridden\n * methods, to map out the complete method-override set.\n *\n * \\param cursor A cursor representing an Objective-C or C++\n * method. This routine will compute the set of methods that this\n * method overrides.\n *\n * \\param overridden A pointer whose pointee will be replaced with a\n * pointer to an array of cursors, representing the set of overridden\n * methods. If there are no overridden methods, the pointee will be\n * set to NULL. The pointee must be freed via a call to\n * \\c clang_disposeOverriddenCursors().\n *\n * \\param num_overridden A pointer to the number of overridden\n * functions, will be set to the number of overridden functions in the\n * array pointed to by \\p overridden.\n */\nCINDEX_LINKAGE void clang_getOverriddenCursors(CXCursor cursor,\n                                               CXCursor **overridden,\n                                               unsigned *num_overridden);\n\n/**\n * Free the set of overridden cursors returned by \\c\n * clang_getOverriddenCursors().\n */\nCINDEX_LINKAGE void clang_disposeOverriddenCursors(CXCursor *overridden);\n\n/**\n * Retrieve the file that is included by the given inclusion directive\n * cursor.\n */\nCINDEX_LINKAGE CXFile clang_getIncludedFile(CXCursor cursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_SOURCE Mapping between cursors and source code\n *\n * Cursors represent a location within the Abstract Syntax Tree (AST). These\n * routines help map between cursors and the physical locations where the\n * described entities occur in the source code. The mapping is provided in\n * both directions, so one can map from source code to the AST and back.\n *\n * @{\n */\n\n/**\n * Map a source location to the cursor that describes the entity at that\n * location in the source code.\n *\n * clang_getCursor() maps an arbitrary source location within a translation\n * unit down to the most specific cursor that describes the entity at that\n * location. For example, given an expression \\c x + y, invoking\n * clang_getCursor() with a source location pointing to \"x\" will return the\n * cursor for \"x\"; similarly for \"y\". If the cursor points anywhere between\n * \"x\" or \"y\" (e.g., on the + or the whitespace around it), clang_getCursor()\n * will return a cursor referring to the \"+\" expression.\n *\n * \\returns a cursor representing the entity at the given source location, or\n * a NULL cursor if no such entity can be found.\n */\nCINDEX_LINKAGE CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation);\n\n/**\n * Retrieve the physical location of the source constructor referenced\n * by the given cursor.\n *\n * The location of a declaration is typically the location of the name of that\n * declaration, where the name of that declaration would occur if it is\n * unnamed, or some keyword that introduces that particular declaration.\n * The location of a reference is where that reference occurs within the\n * source code.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getCursorLocation(CXCursor);\n\n/**\n * Retrieve the physical extent of the source construct referenced by\n * the given cursor.\n *\n * The extent of a cursor starts with the file/line/column pointing at the\n * first character within the source construct that the cursor refers to and\n * ends with the last character within that source construct. For a\n * declaration, the extent covers the declaration itself. For a reference,\n * the extent covers the location of the reference (e.g., where the referenced\n * entity was actually used).\n */\nCINDEX_LINKAGE CXSourceRange clang_getCursorExtent(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_TYPES Type information for CXCursors\n *\n * @{\n */\n\n/**\n * Describes the kind of type\n */\nenum CXTypeKind {\n  /**\n   * Represents an invalid type (e.g., where no type is available).\n   */\n  CXType_Invalid = 0,\n\n  /**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */\n  CXType_Unexposed = 1,\n\n  /* Builtin types */\n  CXType_Void = 2,\n  CXType_Bool = 3,\n  CXType_Char_U = 4,\n  CXType_UChar = 5,\n  CXType_Char16 = 6,\n  CXType_Char32 = 7,\n  CXType_UShort = 8,\n  CXType_UInt = 9,\n  CXType_ULong = 10,\n  CXType_ULongLong = 11,\n  CXType_UInt128 = 12,\n  CXType_Char_S = 13,\n  CXType_SChar = 14,\n  CXType_WChar = 15,\n  CXType_Short = 16,\n  CXType_Int = 17,\n  CXType_Long = 18,\n  CXType_LongLong = 19,\n  CXType_Int128 = 20,\n  CXType_Float = 21,\n  CXType_Double = 22,\n  CXType_LongDouble = 23,\n  CXType_NullPtr = 24,\n  CXType_Overload = 25,\n  CXType_Dependent = 26,\n  CXType_ObjCId = 27,\n  CXType_ObjCClass = 28,\n  CXType_ObjCSel = 29,\n  CXType_Float128 = 30,\n  CXType_Half = 31,\n  CXType_Float16 = 32,\n  CXType_ShortAccum = 33,\n  CXType_Accum = 34,\n  CXType_LongAccum = 35,\n  CXType_UShortAccum = 36,\n  CXType_UAccum = 37,\n  CXType_ULongAccum = 38,\n  CXType_BFloat16 = 39,\n  CXType_FirstBuiltin = CXType_Void,\n  CXType_LastBuiltin = CXType_BFloat16,\n\n  CXType_Complex = 100,\n  CXType_Pointer = 101,\n  CXType_BlockPointer = 102,\n  CXType_LValueReference = 103,\n  CXType_RValueReference = 104,\n  CXType_Record = 105,\n  CXType_Enum = 106,\n  CXType_Typedef = 107,\n  CXType_ObjCInterface = 108,\n  CXType_ObjCObjectPointer = 109,\n  CXType_FunctionNoProto = 110,\n  CXType_FunctionProto = 111,\n  CXType_ConstantArray = 112,\n  CXType_Vector = 113,\n  CXType_IncompleteArray = 114,\n  CXType_VariableArray = 115,\n  CXType_DependentSizedArray = 116,\n  CXType_MemberPointer = 117,\n  CXType_Auto = 118,\n\n  /**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */\n  CXType_Elaborated = 119,\n\n  /* OpenCL PipeType. */\n  CXType_Pipe = 120,\n\n  /* OpenCL builtin types. */\n  CXType_OCLImage1dRO = 121,\n  CXType_OCLImage1dArrayRO = 122,\n  CXType_OCLImage1dBufferRO = 123,\n  CXType_OCLImage2dRO = 124,\n  CXType_OCLImage2dArrayRO = 125,\n  CXType_OCLImage2dDepthRO = 126,\n  CXType_OCLImage2dArrayDepthRO = 127,\n  CXType_OCLImage2dMSAARO = 128,\n  CXType_OCLImage2dArrayMSAARO = 129,\n  CXType_OCLImage2dMSAADepthRO = 130,\n  CXType_OCLImage2dArrayMSAADepthRO = 131,\n  CXType_OCLImage3dRO = 132,\n  CXType_OCLImage1dWO = 133,\n  CXType_OCLImage1dArrayWO = 134,\n  CXType_OCLImage1dBufferWO = 135,\n  CXType_OCLImage2dWO = 136,\n  CXType_OCLImage2dArrayWO = 137,\n  CXType_OCLImage2dDepthWO = 138,\n  CXType_OCLImage2dArrayDepthWO = 139,\n  CXType_OCLImage2dMSAAWO = 140,\n  CXType_OCLImage2dArrayMSAAWO = 141,\n  CXType_OCLImage2dMSAADepthWO = 142,\n  CXType_OCLImage2dArrayMSAADepthWO = 143,\n  CXType_OCLImage3dWO = 144,\n  CXType_OCLImage1dRW = 145,\n  CXType_OCLImage1dArrayRW = 146,\n  CXType_OCLImage1dBufferRW = 147,\n  CXType_OCLImage2dRW = 148,\n  CXType_OCLImage2dArrayRW = 149,\n  CXType_OCLImage2dDepthRW = 150,\n  CXType_OCLImage2dArrayDepthRW = 151,\n  CXType_OCLImage2dMSAARW = 152,\n  CXType_OCLImage2dArrayMSAARW = 153,\n  CXType_OCLImage2dMSAADepthRW = 154,\n  CXType_OCLImage2dArrayMSAADepthRW = 155,\n  CXType_OCLImage3dRW = 156,\n  CXType_OCLSampler = 157,\n  CXType_OCLEvent = 158,\n  CXType_OCLQueue = 159,\n  CXType_OCLReserveID = 160,\n\n  CXType_ObjCObject = 161,\n  CXType_ObjCTypeParam = 162,\n  CXType_Attributed = 163,\n\n  CXType_OCLIntelSubgroupAVCMcePayload = 164,\n  CXType_OCLIntelSubgroupAVCImePayload = 165,\n  CXType_OCLIntelSubgroupAVCRefPayload = 166,\n  CXType_OCLIntelSubgroupAVCSicPayload = 167,\n  CXType_OCLIntelSubgroupAVCMceResult = 168,\n  CXType_OCLIntelSubgroupAVCImeResult = 169,\n  CXType_OCLIntelSubgroupAVCRefResult = 170,\n  CXType_OCLIntelSubgroupAVCSicResult = 171,\n  CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172,\n  CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173,\n  CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174,\n\n  CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175,\n\n  CXType_ExtVector = 176,\n  CXType_Atomic = 177\n};\n\n/**\n * Describes the calling convention of a function type\n */\nenum CXCallingConv {\n  CXCallingConv_Default = 0,\n  CXCallingConv_C = 1,\n  CXCallingConv_X86StdCall = 2,\n  CXCallingConv_X86FastCall = 3,\n  CXCallingConv_X86ThisCall = 4,\n  CXCallingConv_X86Pascal = 5,\n  CXCallingConv_AAPCS = 6,\n  CXCallingConv_AAPCS_VFP = 7,\n  CXCallingConv_X86RegCall = 8,\n  CXCallingConv_IntelOclBicc = 9,\n  CXCallingConv_Win64 = 10,\n  /* Alias for compatibility with older versions of API. */\n  CXCallingConv_X86_64Win64 = CXCallingConv_Win64,\n  CXCallingConv_X86_64SysV = 11,\n  CXCallingConv_X86VectorCall = 12,\n  CXCallingConv_Swift = 13,\n  CXCallingConv_PreserveMost = 14,\n  CXCallingConv_PreserveAll = 15,\n  CXCallingConv_AArch64VectorCall = 16,\n\n  CXCallingConv_Invalid = 100,\n  CXCallingConv_Unexposed = 200\n};\n\n/**\n * The type of an element in the abstract syntax tree.\n *\n */\ntypedef struct {\n  enum CXTypeKind kind;\n  void *data[2];\n} CXType;\n\n/**\n * Retrieve the type of a CXCursor (if any).\n */\nCINDEX_LINKAGE CXType clang_getCursorType(CXCursor C);\n\n/**\n * Pretty-print the underlying type using the rules of the\n * language of the translation unit from which it came.\n *\n * If the type is invalid, an empty string is returned.\n */\nCINDEX_LINKAGE CXString clang_getTypeSpelling(CXType CT);\n\n/**\n * Retrieve the underlying type of a typedef declaration.\n *\n * If the cursor does not reference a typedef declaration, an invalid type is\n * returned.\n */\nCINDEX_LINKAGE CXType clang_getTypedefDeclUnderlyingType(CXCursor C);\n\n/**\n * Retrieve the integer type of an enum declaration.\n *\n * If the cursor does not reference an enum declaration, an invalid type is\n * returned.\n */\nCINDEX_LINKAGE CXType clang_getEnumDeclIntegerType(CXCursor C);\n\n/**\n * Retrieve the integer value of an enum constant declaration as a signed\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, LLONG_MIN is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */\nCINDEX_LINKAGE long long clang_getEnumConstantDeclValue(CXCursor C);\n\n/**\n * Retrieve the integer value of an enum constant declaration as an unsigned\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, ULLONG_MAX is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */\nCINDEX_LINKAGE unsigned long long\nclang_getEnumConstantDeclUnsignedValue(CXCursor C);\n\n/**\n * Retrieve the bit width of a bit field declaration as an integer.\n *\n * If a cursor that is not a bit field declaration is passed in, -1 is returned.\n */\nCINDEX_LINKAGE int clang_getFieldDeclBitWidth(CXCursor C);\n\n/**\n * Retrieve the number of non-variadic arguments associated with a given\n * cursor.\n *\n * The number of arguments can be determined for calls as well as for\n * declarations of functions or methods. For other cursors -1 is returned.\n */\nCINDEX_LINKAGE int clang_Cursor_getNumArguments(CXCursor C);\n\n/**\n * Retrieve the argument cursor of a function or method.\n *\n * The argument cursor can be determined for calls as well as for declarations\n * of functions or methods. For other cursors and for invalid indices, an\n * invalid cursor is returned.\n */\nCINDEX_LINKAGE CXCursor clang_Cursor_getArgument(CXCursor C, unsigned i);\n\n/**\n * Describes the kind of a template argument.\n *\n * See the definition of llvm::clang::TemplateArgument::ArgKind for full\n * element descriptions.\n */\nenum CXTemplateArgumentKind {\n  CXTemplateArgumentKind_Null,\n  CXTemplateArgumentKind_Type,\n  CXTemplateArgumentKind_Declaration,\n  CXTemplateArgumentKind_NullPtr,\n  CXTemplateArgumentKind_Integral,\n  CXTemplateArgumentKind_Template,\n  CXTemplateArgumentKind_TemplateExpansion,\n  CXTemplateArgumentKind_Expression,\n  CXTemplateArgumentKind_Pack,\n  /* Indicates an error case, preventing the kind from being deduced. */\n  CXTemplateArgumentKind_Invalid\n};\n\n/**\n *Returns the number of template args of a function decl representing a\n * template specialization.\n *\n * If the argument cursor cannot be converted into a template function\n * declaration, -1 is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * The value 3 would be returned from this call.\n */\nCINDEX_LINKAGE int clang_Cursor_getNumTemplateArguments(CXCursor C);\n\n/**\n * Retrieve the kind of the I'th template argument of the CXCursor C.\n *\n * If the argument CXCursor does not represent a FunctionDecl, an invalid\n * template argument kind is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,\n * respectively.\n */\nCINDEX_LINKAGE enum CXTemplateArgumentKind\nclang_Cursor_getTemplateArgumentKind(CXCursor C, unsigned I);\n\n/**\n * Retrieve a CXType representing the type of a TemplateArgument of a\n *  function decl representing a template specialization.\n *\n * If the argument CXCursor does not represent a FunctionDecl whose I'th\n * template argument has a kind of CXTemplateArgKind_Integral, an invalid type\n * is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 0, \"float\", will be returned.\n * Invalid types will be returned for I == 1 or 2.\n */\nCINDEX_LINKAGE CXType clang_Cursor_getTemplateArgumentType(CXCursor C,\n                                                           unsigned I);\n\n/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as a signed long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 1 or 2, -7 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */\nCINDEX_LINKAGE long long clang_Cursor_getTemplateArgumentValue(CXCursor C,\n                                                               unsigned I);\n\n/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as an unsigned long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, 2147483649, true>();\n *\n * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */\nCINDEX_LINKAGE unsigned long long\nclang_Cursor_getTemplateArgumentUnsignedValue(CXCursor C, unsigned I);\n\n/**\n * Determine whether two CXTypes represent the same type.\n *\n * \\returns non-zero if the CXTypes represent the same type and\n *          zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_equalTypes(CXType A, CXType B);\n\n/**\n * Return the canonical type for a CXType.\n *\n * Clang's type system explicitly models typedefs and all the ways\n * a specific type can be represented.  The canonical type is the underlying\n * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n * for 'int', the canonical type for 'T' would be 'int'.\n */\nCINDEX_LINKAGE CXType clang_getCanonicalType(CXType T);\n\n/**\n * Determine whether a CXType has the \"const\" qualifier set,\n * without looking through typedefs that may have added \"const\" at a\n * different level.\n */\nCINDEX_LINKAGE unsigned clang_isConstQualifiedType(CXType T);\n\n/**\n * Determine whether a  CXCursor that is a macro, is\n * function like.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isMacroFunctionLike(CXCursor C);\n\n/**\n * Determine whether a  CXCursor that is a macro, is a\n * builtin one.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isMacroBuiltin(CXCursor C);\n\n/**\n * Determine whether a  CXCursor that is a function declaration, is an\n * inline declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isFunctionInlined(CXCursor C);\n\n/**\n * Determine whether a CXType has the \"volatile\" qualifier set,\n * without looking through typedefs that may have added \"volatile\" at\n * a different level.\n */\nCINDEX_LINKAGE unsigned clang_isVolatileQualifiedType(CXType T);\n\n/**\n * Determine whether a CXType has the \"restrict\" qualifier set,\n * without looking through typedefs that may have added \"restrict\" at a\n * different level.\n */\nCINDEX_LINKAGE unsigned clang_isRestrictQualifiedType(CXType T);\n\n/**\n * Returns the address space of the given type.\n */\nCINDEX_LINKAGE unsigned clang_getAddressSpace(CXType T);\n\n/**\n * Returns the typedef name of the given type.\n */\nCINDEX_LINKAGE CXString clang_getTypedefName(CXType CT);\n\n/**\n * For pointer types, returns the type of the pointee.\n */\nCINDEX_LINKAGE CXType clang_getPointeeType(CXType T);\n\n/**\n * Return the cursor for the declaration of the given type.\n */\nCINDEX_LINKAGE CXCursor clang_getTypeDeclaration(CXType T);\n\n/**\n * Returns the Objective-C type encoding for the specified declaration.\n */\nCINDEX_LINKAGE CXString clang_getDeclObjCTypeEncoding(CXCursor C);\n\n/**\n * Returns the Objective-C type encoding for the specified CXType.\n */\nCINDEX_LINKAGE CXString clang_Type_getObjCEncoding(CXType type);\n\n/**\n * Retrieve the spelling of a given CXTypeKind.\n */\nCINDEX_LINKAGE CXString clang_getTypeKindSpelling(enum CXTypeKind K);\n\n/**\n * Retrieve the calling convention associated with a function type.\n *\n * If a non-function type is passed in, CXCallingConv_Invalid is returned.\n */\nCINDEX_LINKAGE enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T);\n\n/**\n * Retrieve the return type associated with a function type.\n *\n * If a non-function type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getResultType(CXType T);\n\n/**\n * Retrieve the exception specification type associated with a function type.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * If a non-function type is passed in, an error code of -1 is returned.\n */\nCINDEX_LINKAGE int clang_getExceptionSpecificationType(CXType T);\n\n/**\n * Retrieve the number of non-variadic parameters associated with a\n * function type.\n *\n * If a non-function type is passed in, -1 is returned.\n */\nCINDEX_LINKAGE int clang_getNumArgTypes(CXType T);\n\n/**\n * Retrieve the type of a parameter of a function type.\n *\n * If a non-function type is passed in or the function does not have enough\n * parameters, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getArgType(CXType T, unsigned i);\n\n/**\n * Retrieves the base type of the ObjCObjectType.\n *\n * If the type is not an ObjC object, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getObjCObjectBaseType(CXType T);\n\n/**\n * Retrieve the number of protocol references associated with an ObjC object/id.\n *\n * If the type is not an ObjC object, 0 is returned.\n */\nCINDEX_LINKAGE unsigned clang_Type_getNumObjCProtocolRefs(CXType T);\n\n/**\n * Retrieve the decl for a protocol reference for an ObjC object/id.\n *\n * If the type is not an ObjC object or there are not enough protocol\n * references, an invalid cursor is returned.\n */\nCINDEX_LINKAGE CXCursor clang_Type_getObjCProtocolDecl(CXType T, unsigned i);\n\n/**\n * Retrieve the number of type arguments associated with an ObjC object.\n *\n * If the type is not an ObjC object, 0 is returned.\n */\nCINDEX_LINKAGE unsigned clang_Type_getNumObjCTypeArgs(CXType T);\n\n/**\n * Retrieve a type argument associated with an ObjC object.\n *\n * If the type is not an ObjC or the index is not valid,\n * an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getObjCTypeArg(CXType T, unsigned i);\n\n/**\n * Return 1 if the CXType is a variadic function type, and 0 otherwise.\n */\nCINDEX_LINKAGE unsigned clang_isFunctionTypeVariadic(CXType T);\n\n/**\n * Retrieve the return type associated with a given cursor.\n *\n * This only returns a valid type if the cursor refers to a function or method.\n */\nCINDEX_LINKAGE CXType clang_getCursorResultType(CXCursor C);\n\n/**\n * Retrieve the exception specification type associated with a given cursor.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * This only returns a valid result if the cursor refers to a function or\n * method.\n */\nCINDEX_LINKAGE int clang_getCursorExceptionSpecificationType(CXCursor C);\n\n/**\n * Return 1 if the CXType is a POD (plain old data) type, and 0\n *  otherwise.\n */\nCINDEX_LINKAGE unsigned clang_isPODType(CXType T);\n\n/**\n * Return the element type of an array, complex, or vector type.\n *\n * If a type is passed in that is not an array, complex, or vector type,\n * an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getElementType(CXType T);\n\n/**\n * Return the number of elements of an array or vector type.\n *\n * If a type is passed in that is not an array or vector type,\n * -1 is returned.\n */\nCINDEX_LINKAGE long long clang_getNumElements(CXType T);\n\n/**\n * Return the element type of an array type.\n *\n * If a non-array type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getArrayElementType(CXType T);\n\n/**\n * Return the array size of a constant array.\n *\n * If a non-array type is passed in, -1 is returned.\n */\nCINDEX_LINKAGE long long clang_getArraySize(CXType T);\n\n/**\n * Retrieve the type named by the qualified-id.\n *\n * If a non-elaborated type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getNamedType(CXType T);\n\n/**\n * Determine if a typedef is 'transparent' tag.\n *\n * A typedef is considered 'transparent' if it shares a name and spelling\n * location with its underlying tag type, as is the case with the NS_ENUM macro.\n *\n * \\returns non-zero if transparent and zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_Type_isTransparentTagTypedef(CXType T);\n\nenum CXTypeNullabilityKind {\n  /**\n   * Values of this type can never be null.\n   */\n  CXTypeNullability_NonNull = 0,\n  /**\n   * Values of this type can be null.\n   */\n  CXTypeNullability_Nullable = 1,\n  /**\n   * Whether values of this type can be null is (explicitly)\n   * unspecified. This captures a (fairly rare) case where we\n   * can't conclude anything about the nullability of the type even\n   * though it has been considered.\n   */\n  CXTypeNullability_Unspecified = 2,\n  /**\n   * Nullability is not applicable to this type.\n   */\n  CXTypeNullability_Invalid = 3,\n\n  /**\n   * Generally behaves like Nullable, except when used in a block parameter that\n   * was imported into a swift async method. There, swift will assume that the\n   * parameter can get null even if no error occured. _Nullable parameters are\n   * assumed to only get null on error.\n   */\n  CXTypeNullability_NullableResult = 4\n};\n\n/**\n * Retrieve the nullability kind of a pointer type.\n */\nCINDEX_LINKAGE enum CXTypeNullabilityKind clang_Type_getNullability(CXType T);\n\n/**\n * List the possible error codes for \\c clang_Type_getSizeOf,\n *   \\c clang_Type_getAlignOf, \\c clang_Type_getOffsetOf and\n *   \\c clang_Cursor_getOffsetOf.\n *\n * A value of this enumeration type can be returned if the target type is not\n * a valid argument to sizeof, alignof or offsetof.\n */\nenum CXTypeLayoutError {\n  /**\n   * Type is of kind CXType_Invalid.\n   */\n  CXTypeLayoutError_Invalid = -1,\n  /**\n   * The type is an incomplete Type.\n   */\n  CXTypeLayoutError_Incomplete = -2,\n  /**\n   * The type is a dependent Type.\n   */\n  CXTypeLayoutError_Dependent = -3,\n  /**\n   * The type is not a constant size type.\n   */\n  CXTypeLayoutError_NotConstantSize = -4,\n  /**\n   * The Field name is not valid for this record.\n   */\n  CXTypeLayoutError_InvalidFieldName = -5,\n  /**\n   * The type is undeduced.\n   */\n  CXTypeLayoutError_Undeduced = -6\n};\n\n/**\n * Return the alignment of a type in bytes as per C++[expr.alignof]\n *   standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n * If the type declaration is not a constant size type,\n *   CXTypeLayoutError_NotConstantSize is returned.\n */\nCINDEX_LINKAGE long long clang_Type_getAlignOf(CXType T);\n\n/**\n * Return the class type of an member pointer type.\n *\n * If a non-member-pointer type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getClassType(CXType T);\n\n/**\n * Return the size of a type in bytes as per C++[expr.sizeof] standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n */\nCINDEX_LINKAGE long long clang_Type_getSizeOf(CXType T);\n\n/**\n * Return the offset of a field named S in a record of type T in bits\n *   as it would be returned by __offsetof__ as per C++11[18.2p4]\n *\n * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid\n *   is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */\nCINDEX_LINKAGE long long clang_Type_getOffsetOf(CXType T, const char *S);\n\n/**\n * Return the type that was modified by this attributed type.\n *\n * If the type is not an attributed type, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getModifiedType(CXType T);\n\n/**\n * Gets the type contained by this atomic type.\n *\n * If a non-atomic type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getValueType(CXType CT);\n\n/**\n * Return the offset of the field represented by the Cursor.\n *\n * If the cursor is not a field declaration, -1 is returned.\n * If the cursor semantic parent is not a record field declaration,\n *   CXTypeLayoutError_Invalid is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */\nCINDEX_LINKAGE long long clang_Cursor_getOffsetOfField(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an anonymous\n * tag or namespace\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isAnonymous(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an anonymous record\n * declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isAnonymousRecordDecl(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an inline namespace\n * declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isInlineNamespace(CXCursor C);\n\nenum CXRefQualifierKind {\n  /** No ref-qualifier was provided. */\n  CXRefQualifier_None = 0,\n  /** An lvalue ref-qualifier was provided (\\c &). */\n  CXRefQualifier_LValue,\n  /** An rvalue ref-qualifier was provided (\\c &&). */\n  CXRefQualifier_RValue\n};\n\n/**\n * Returns the number of template arguments for given template\n * specialization, or -1 if type \\c T is not a template specialization.\n */\nCINDEX_LINKAGE int clang_Type_getNumTemplateArguments(CXType T);\n\n/**\n * Returns the type template argument of a template class specialization\n * at given index.\n *\n * This function only returns template type arguments and does not handle\n * template template arguments or variadic packs.\n */\nCINDEX_LINKAGE CXType clang_Type_getTemplateArgumentAsType(CXType T,\n                                                           unsigned i);\n\n/**\n * Retrieve the ref-qualifier kind of a function or method.\n *\n * The ref-qualifier is returned for C++ functions or methods. For other types\n * or non-C++ declarations, CXRefQualifier_None is returned.\n */\nCINDEX_LINKAGE enum CXRefQualifierKind clang_Type_getCXXRefQualifier(CXType T);\n\n/**\n * Returns non-zero if the cursor specifies a Record member that is a\n *   bitfield.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isBitField(CXCursor C);\n\n/**\n * Returns 1 if the base class specified by the cursor with kind\n *   CX_CXXBaseSpecifier is virtual.\n */\nCINDEX_LINKAGE unsigned clang_isVirtualBase(CXCursor);\n\n/**\n * Represents the C++ access control level to a base class for a\n * cursor with kind CX_CXXBaseSpecifier.\n */\nenum CX_CXXAccessSpecifier {\n  CX_CXXInvalidAccessSpecifier,\n  CX_CXXPublic,\n  CX_CXXProtected,\n  CX_CXXPrivate\n};\n\n/**\n * Returns the access control level for the referenced object.\n *\n * If the cursor refers to a C++ declaration, its access control level within\n * its parent scope is returned. Otherwise, if the cursor refers to a base\n * specifier or access specifier, the specifier itself is returned.\n */\nCINDEX_LINKAGE enum CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor);\n\n/**\n * Represents the storage classes as declared in the source. CX_SC_Invalid\n * was added for the case that the passed cursor in not a declaration.\n */\nenum CX_StorageClass {\n  CX_SC_Invalid,\n  CX_SC_None,\n  CX_SC_Extern,\n  CX_SC_Static,\n  CX_SC_PrivateExtern,\n  CX_SC_OpenCLWorkGroupLocal,\n  CX_SC_Auto,\n  CX_SC_Register\n};\n\n/**\n * Returns the storage class for a function or variable declaration.\n *\n * If the passed in Cursor is not a function or variable declaration,\n * CX_SC_Invalid is returned else the storage class.\n */\nCINDEX_LINKAGE enum CX_StorageClass clang_Cursor_getStorageClass(CXCursor);\n\n/**\n * Determine the number of overloaded declarations referenced by a\n * \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\returns The number of overloaded declarations referenced by \\c cursor. If it\n * is not a \\c CXCursor_OverloadedDeclRef cursor, returns 0.\n */\nCINDEX_LINKAGE unsigned clang_getNumOverloadedDecls(CXCursor cursor);\n\n/**\n * Retrieve a cursor for one of the overloaded declarations referenced\n * by a \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\param index The zero-based index into the set of overloaded declarations in\n * the cursor.\n *\n * \\returns A cursor representing the declaration referenced by the given\n * \\c cursor at the specified \\c index. If the cursor does not have an\n * associated set of overloaded declarations, or if the index is out of bounds,\n * returns \\c clang_getNullCursor();\n */\nCINDEX_LINKAGE CXCursor clang_getOverloadedDecl(CXCursor cursor,\n                                                unsigned index);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_ATTRIBUTES Information for attributes\n *\n * @{\n */\n\n/**\n * For cursors representing an iboutletcollection attribute,\n *  this function returns the collection element type.\n *\n */\nCINDEX_LINKAGE CXType clang_getIBOutletCollectionType(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_TRAVERSAL Traversing the AST with cursors\n *\n * These routines provide the ability to traverse the abstract syntax tree\n * using cursors.\n *\n * @{\n */\n\n/**\n * Describes how the traversal of the children of a particular\n * cursor should proceed after visiting a particular child cursor.\n *\n * A value of this enumeration type should be returned by each\n * \\c CXCursorVisitor to indicate how clang_visitChildren() proceed.\n */\nenum CXChildVisitResult {\n  /**\n   * Terminates the cursor traversal.\n   */\n  CXChildVisit_Break,\n  /**\n   * Continues the cursor traversal with the next sibling of\n   * the cursor just visited, without visiting its children.\n   */\n  CXChildVisit_Continue,\n  /**\n   * Recursively traverse the children of this cursor, using\n   * the same visitor and client data.\n   */\n  CXChildVisit_Recurse\n};\n\n/**\n * Visitor invoked for each cursor found by a traversal.\n *\n * This visitor function will be invoked for each cursor found by\n * clang_visitCursorChildren(). Its first argument is the cursor being\n * visited, its second argument is the parent visitor for that cursor,\n * and its third argument is the client data provided to\n * clang_visitCursorChildren().\n *\n * The visitor should return one of the \\c CXChildVisitResult values\n * to direct clang_visitCursorChildren().\n */\ntypedef enum CXChildVisitResult (*CXCursorVisitor)(CXCursor cursor,\n                                                   CXCursor parent,\n                                                   CXClientData client_data);\n\n/**\n * Visit the children of a particular cursor.\n *\n * This function visits all the direct children of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited child. The traversal may be recursive, if the visitor returns\n * \\c CXChildVisit_Recurse. The traversal may also be ended prematurely, if\n * the visitor returns \\c CXChildVisit_Break.\n *\n * \\param parent the cursor whose child may be visited. All kinds of\n * cursors can be visited, including invalid cursors (which, by\n * definition, have no children).\n *\n * \\param visitor the visitor function that will be invoked for each\n * child of \\p parent.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXChildVisit_Break.\n */\nCINDEX_LINKAGE unsigned clang_visitChildren(CXCursor parent,\n                                            CXCursorVisitor visitor,\n                                            CXClientData client_data);\n#ifdef __has_feature\n#if __has_feature(blocks)\n/**\n * Visitor invoked for each cursor found by a traversal.\n *\n * This visitor block will be invoked for each cursor found by\n * clang_visitChildrenWithBlock(). Its first argument is the cursor being\n * visited, its second argument is the parent visitor for that cursor.\n *\n * The visitor should return one of the \\c CXChildVisitResult values\n * to direct clang_visitChildrenWithBlock().\n */\ntypedef enum CXChildVisitResult (^CXCursorVisitorBlock)(CXCursor cursor,\n                                                        CXCursor parent);\n\n/**\n * Visits the children of a cursor using the specified block.  Behaves\n * identically to clang_visitChildren() in all other respects.\n */\nCINDEX_LINKAGE unsigned\nclang_visitChildrenWithBlock(CXCursor parent, CXCursorVisitorBlock block);\n#endif\n#endif\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_XREF Cross-referencing in the AST\n *\n * These routines provide the ability to determine references within and\n * across translation units, by providing the names of the entities referenced\n * by cursors, follow reference cursors to the declarations they reference,\n * and associate declarations with their definitions.\n *\n * @{\n */\n\n/**\n * Retrieve a Unified Symbol Resolution (USR) for the entity referenced\n * by the given cursor.\n *\n * A Unified Symbol Resolution (USR) is a string that identifies a particular\n * entity (function, class, variable, etc.) within a program. USRs can be\n * compared across translation units to determine, e.g., when references in\n * one translation refer to an entity defined in another translation unit.\n */\nCINDEX_LINKAGE CXString clang_getCursorUSR(CXCursor);\n\n/**\n * Construct a USR for a specified Objective-C class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCClass(const char *class_name);\n\n/**\n * Construct a USR for a specified Objective-C category.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCCategory(\n    const char *class_name, const char *category_name);\n\n/**\n * Construct a USR for a specified Objective-C protocol.\n */\nCINDEX_LINKAGE CXString\nclang_constructUSR_ObjCProtocol(const char *protocol_name);\n\n/**\n * Construct a USR for a specified Objective-C instance variable and\n *   the USR for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCIvar(const char *name,\n                                                    CXString classUSR);\n\n/**\n * Construct a USR for a specified Objective-C method and\n *   the USR for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCMethod(const char *name,\n                                                      unsigned isInstanceMethod,\n                                                      CXString classUSR);\n\n/**\n * Construct a USR for a specified Objective-C property and the USR\n *  for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCProperty(const char *property,\n                                                        CXString classUSR);\n\n/**\n * Retrieve a name for the entity referenced by this cursor.\n */\nCINDEX_LINKAGE CXString clang_getCursorSpelling(CXCursor);\n\n/**\n * Retrieve a range for a piece that forms the cursors spelling name.\n * Most of the times there is only one range for the complete spelling but for\n * Objective-C methods and Objective-C message expressions, there are multiple\n * pieces for each selector identifier.\n *\n * \\param pieceIndex the index of the spelling name piece. If this is greater\n * than the actual number of pieces, it will return a NULL (invalid) range.\n *\n * \\param options Reserved.\n */\nCINDEX_LINKAGE CXSourceRange clang_Cursor_getSpellingNameRange(\n    CXCursor, unsigned pieceIndex, unsigned options);\n\n/**\n * Opaque pointer representing a policy that controls pretty printing\n * for \\c clang_getCursorPrettyPrinted.\n */\ntypedef void *CXPrintingPolicy;\n\n/**\n * Properties for the printing policy.\n *\n * See \\c clang::PrintingPolicy for more information.\n */\nenum CXPrintingPolicyProperty {\n  CXPrintingPolicy_Indentation,\n  CXPrintingPolicy_SuppressSpecifiers,\n  CXPrintingPolicy_SuppressTagKeyword,\n  CXPrintingPolicy_IncludeTagDefinition,\n  CXPrintingPolicy_SuppressScope,\n  CXPrintingPolicy_SuppressUnwrittenScope,\n  CXPrintingPolicy_SuppressInitializers,\n  CXPrintingPolicy_ConstantArraySizeAsWritten,\n  CXPrintingPolicy_AnonymousTagLocations,\n  CXPrintingPolicy_SuppressStrongLifetime,\n  CXPrintingPolicy_SuppressLifetimeQualifiers,\n  CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors,\n  CXPrintingPolicy_Bool,\n  CXPrintingPolicy_Restrict,\n  CXPrintingPolicy_Alignof,\n  CXPrintingPolicy_UnderscoreAlignof,\n  CXPrintingPolicy_UseVoidForZeroParams,\n  CXPrintingPolicy_TerseOutput,\n  CXPrintingPolicy_PolishForDeclaration,\n  CXPrintingPolicy_Half,\n  CXPrintingPolicy_MSWChar,\n  CXPrintingPolicy_IncludeNewlines,\n  CXPrintingPolicy_MSVCFormatting,\n  CXPrintingPolicy_ConstantsAsWritten,\n  CXPrintingPolicy_SuppressImplicitBase,\n  CXPrintingPolicy_FullyQualifiedName,\n\n  CXPrintingPolicy_LastProperty = CXPrintingPolicy_FullyQualifiedName\n};\n\n/**\n * Get a property value for the given printing policy.\n */\nCINDEX_LINKAGE unsigned\nclang_PrintingPolicy_getProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property);\n\n/**\n * Set a property value for the given printing policy.\n */\nCINDEX_LINKAGE void\nclang_PrintingPolicy_setProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property,\n                                 unsigned Value);\n\n/**\n * Retrieve the default policy for the cursor.\n *\n * The policy should be released after use with \\c\n * clang_PrintingPolicy_dispose.\n */\nCINDEX_LINKAGE CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor);\n\n/**\n * Release a printing policy.\n */\nCINDEX_LINKAGE void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy);\n\n/**\n * Pretty print declarations.\n *\n * \\param Cursor The cursor representing a declaration.\n *\n * \\param Policy The policy to control the entities being printed. If\n * NULL, a default policy is used.\n *\n * \\returns The pretty printed declaration or the empty string for\n * other cursors.\n */\nCINDEX_LINKAGE CXString clang_getCursorPrettyPrinted(CXCursor Cursor,\n                                                     CXPrintingPolicy Policy);\n\n/**\n * Retrieve the display name for the entity referenced by this cursor.\n *\n * The display name contains extra information that helps identify the cursor,\n * such as the parameters of a function or template or the arguments of a\n * class template specialization.\n */\nCINDEX_LINKAGE CXString clang_getCursorDisplayName(CXCursor);\n\n/** For a cursor that is a reference, retrieve a cursor representing the\n * entity that it references.\n *\n * Reference cursors refer to other entities in the AST. For example, an\n * Objective-C superclass reference cursor refers to an Objective-C class.\n * This function produces the cursor for the Objective-C class from the\n * cursor for the superclass reference. If the input cursor is a declaration or\n * definition, it returns that declaration or definition unchanged.\n * Otherwise, returns the NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorReferenced(CXCursor);\n\n/**\n *  For a cursor that is either a reference to or a declaration\n *  of some entity, retrieve a cursor that describes the definition of\n *  that entity.\n *\n *  Some entities can be declared multiple times within a translation\n *  unit, but only one of those declarations can also be a\n *  definition. For example, given:\n *\n *  \\code\n *  int f(int, int);\n *  int g(int x, int y) { return f(x, y); }\n *  int f(int a, int b) { return a + b; }\n *  int f(int, int);\n *  \\endcode\n *\n *  there are three declarations of the function \"f\", but only the\n *  second one is a definition. The clang_getCursorDefinition()\n *  function will take any cursor pointing to a declaration of \"f\"\n *  (the first or fourth lines of the example) or a cursor referenced\n *  that uses \"f\" (the call to \"f' inside \"g\") and will return a\n *  declaration cursor pointing to the definition (the second \"f\"\n *  declaration).\n *\n *  If given a cursor for which there is no corresponding definition,\n *  e.g., because there is no definition of that entity within this\n *  translation unit, returns a NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorDefinition(CXCursor);\n\n/**\n * Determine whether the declaration pointed to by this cursor\n * is also a definition of that entity.\n */\nCINDEX_LINKAGE unsigned clang_isCursorDefinition(CXCursor);\n\n/**\n * Retrieve the canonical cursor corresponding to the given cursor.\n *\n * In the C family of languages, many kinds of entities can be declared several\n * times within a single translation unit. For example, a structure type can\n * be forward-declared (possibly multiple times) and later defined:\n *\n * \\code\n * struct X;\n * struct X;\n * struct X {\n *   int member;\n * };\n * \\endcode\n *\n * The declarations and the definition of \\c X are represented by three\n * different cursors, all of which are declarations of the same underlying\n * entity. One of these cursor is considered the \"canonical\" cursor, which\n * is effectively the representative for the underlying entity. One can\n * determine if two cursors are declarations of the same underlying entity by\n * comparing their canonical cursors.\n *\n * \\returns The canonical cursor for the entity referred to by the given cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCanonicalCursor(CXCursor);\n\n/**\n * If the cursor points to a selector identifier in an Objective-C\n * method or message expression, this returns the selector index.\n *\n * After getting a cursor with #clang_getCursor, this can be called to\n * determine if the location points to a selector identifier.\n *\n * \\returns The selector index if the cursor is an Objective-C method or message\n * expression and the cursor is pointing to a selector identifier, or -1\n * otherwise.\n */\nCINDEX_LINKAGE int clang_Cursor_getObjCSelectorIndex(CXCursor);\n\n/**\n * Given a cursor pointing to a C++ method call or an Objective-C\n * message, returns non-zero if the method/message is \"dynamic\", meaning:\n *\n * For a C++ method: the call is virtual.\n * For an Objective-C message: the receiver is an object instance, not 'super'\n * or a specific class.\n *\n * If the method/message is \"static\" or the cursor does not point to a\n * method/message, it will return zero.\n */\nCINDEX_LINKAGE int clang_Cursor_isDynamicCall(CXCursor C);\n\n/**\n * Given a cursor pointing to an Objective-C message or property\n * reference, or C++ method call, returns the CXType of the receiver.\n */\nCINDEX_LINKAGE CXType clang_Cursor_getReceiverType(CXCursor C);\n\n/**\n * Property attributes for a \\c CXCursor_ObjCPropertyDecl.\n */\ntypedef enum {\n  CXObjCPropertyAttr_noattr = 0x00,\n  CXObjCPropertyAttr_readonly = 0x01,\n  CXObjCPropertyAttr_getter = 0x02,\n  CXObjCPropertyAttr_assign = 0x04,\n  CXObjCPropertyAttr_readwrite = 0x08,\n  CXObjCPropertyAttr_retain = 0x10,\n  CXObjCPropertyAttr_copy = 0x20,\n  CXObjCPropertyAttr_nonatomic = 0x40,\n  CXObjCPropertyAttr_setter = 0x80,\n  CXObjCPropertyAttr_atomic = 0x100,\n  CXObjCPropertyAttr_weak = 0x200,\n  CXObjCPropertyAttr_strong = 0x400,\n  CXObjCPropertyAttr_unsafe_unretained = 0x800,\n  CXObjCPropertyAttr_class = 0x1000\n} CXObjCPropertyAttrKind;\n\n/**\n * Given a cursor that represents a property declaration, return the\n * associated property attributes. The bits are formed from\n * \\c CXObjCPropertyAttrKind.\n *\n * \\param reserved Reserved for future use, pass 0.\n */\nCINDEX_LINKAGE unsigned\nclang_Cursor_getObjCPropertyAttributes(CXCursor C, unsigned reserved);\n\n/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the getter.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getObjCPropertyGetterName(CXCursor C);\n\n/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the setter, if any.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getObjCPropertySetterName(CXCursor C);\n\n/**\n * 'Qualifiers' written next to the return and parameter types in\n * Objective-C method declarations.\n */\ntypedef enum {\n  CXObjCDeclQualifier_None = 0x0,\n  CXObjCDeclQualifier_In = 0x1,\n  CXObjCDeclQualifier_Inout = 0x2,\n  CXObjCDeclQualifier_Out = 0x4,\n  CXObjCDeclQualifier_Bycopy = 0x8,\n  CXObjCDeclQualifier_Byref = 0x10,\n  CXObjCDeclQualifier_Oneway = 0x20\n} CXObjCDeclQualifierKind;\n\n/**\n * Given a cursor that represents an Objective-C method or parameter\n * declaration, return the associated Objective-C qualifiers for the return\n * type or the parameter respectively. The bits are formed from\n * CXObjCDeclQualifierKind.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_getObjCDeclQualifiers(CXCursor C);\n\n/**\n * Given a cursor that represents an Objective-C method or property\n * declaration, return non-zero if the declaration was affected by \"\\@optional\".\n * Returns zero if the cursor is not such a declaration or it is \"\\@required\".\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isObjCOptional(CXCursor C);\n\n/**\n * Returns non-zero if the given cursor is a variadic function or method.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isVariadic(CXCursor C);\n\n/**\n * Returns non-zero if the given cursor points to a symbol marked with\n * external_source_symbol attribute.\n *\n * \\param language If non-NULL, and the attribute is present, will be set to\n * the 'language' string from the attribute.\n *\n * \\param definedIn If non-NULL, and the attribute is present, will be set to\n * the 'definedIn' string from the attribute.\n *\n * \\param isGenerated If non-NULL, and the attribute is present, will be set to\n * non-zero if the 'generated_declaration' is set in the attribute.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isExternalSymbol(CXCursor C,\n                                                      CXString *language,\n                                                      CXString *definedIn,\n                                                      unsigned *isGenerated);\n\n/**\n * Given a cursor that represents a declaration, return the associated\n * comment's source range.  The range may include multiple consecutive comments\n * with whitespace in between.\n */\nCINDEX_LINKAGE CXSourceRange clang_Cursor_getCommentRange(CXCursor C);\n\n/**\n * Given a cursor that represents a declaration, return the associated\n * comment text, including comment markers.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getRawCommentText(CXCursor C);\n\n/**\n * Given a cursor that represents a documentable entity (e.g.,\n * declaration), return the associated \\paragraph; otherwise return the\n * first paragraph.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getBriefCommentText(CXCursor C);\n\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_MANGLE Name Mangling API Functions\n *\n * @{\n */\n\n/**\n * Retrieve the CXString representing the mangled name of the cursor.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getMangling(CXCursor);\n\n/**\n * Retrieve the CXStrings representing the mangled symbols of the C++\n * constructor or destructor at the cursor.\n */\nCINDEX_LINKAGE CXStringSet *clang_Cursor_getCXXManglings(CXCursor);\n\n/**\n * Retrieve the CXStrings representing the mangled symbols of the ObjC\n * class interface or implementation at the cursor.\n */\nCINDEX_LINKAGE CXStringSet *clang_Cursor_getObjCManglings(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_MODULE Module introspection\n *\n * The functions in this group provide access to information about modules.\n *\n * @{\n */\n\ntypedef void *CXModule;\n\n/**\n * Given a CXCursor_ModuleImportDecl cursor, return the associated module.\n */\nCINDEX_LINKAGE CXModule clang_Cursor_getModule(CXCursor C);\n\n/**\n * Given a CXFile header file, return the module that contains it, if one\n * exists.\n */\nCINDEX_LINKAGE CXModule clang_getModuleForFile(CXTranslationUnit, CXFile);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the module file where the provided module object came from.\n */\nCINDEX_LINKAGE CXFile clang_Module_getASTFile(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the parent of a sub-module or NULL if the given module is top-level,\n * e.g. for 'std.vector' it will return the 'std' module.\n */\nCINDEX_LINKAGE CXModule clang_Module_getParent(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the name of the module, e.g. for the 'std.vector' sub-module it\n * will return \"vector\".\n */\nCINDEX_LINKAGE CXString clang_Module_getName(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the full name of the module, e.g. \"std.vector\".\n */\nCINDEX_LINKAGE CXString clang_Module_getFullName(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns non-zero if the module is a system one.\n */\nCINDEX_LINKAGE int clang_Module_isSystem(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the number of top level headers associated with this module.\n */\nCINDEX_LINKAGE unsigned clang_Module_getNumTopLevelHeaders(CXTranslationUnit,\n                                                           CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\param Index top level header index (zero-based).\n *\n * \\returns the specified top level header associated with the module.\n */\nCINDEX_LINKAGE\nCXFile clang_Module_getTopLevelHeader(CXTranslationUnit, CXModule Module,\n                                      unsigned Index);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CPP C++ AST introspection\n *\n * The routines in this group provide access information in the ASTs specific\n * to C++ language features.\n *\n * @{\n */\n\n/**\n * Determine if a C++ constructor is a converting constructor.\n */\nCINDEX_LINKAGE unsigned\nclang_CXXConstructor_isConvertingConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is a copy constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isCopyConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is the default constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isDefaultConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is a move constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isMoveConstructor(CXCursor C);\n\n/**\n * Determine if a C++ field is declared 'mutable'.\n */\nCINDEX_LINKAGE unsigned clang_CXXField_isMutable(CXCursor C);\n\n/**\n * Determine if a C++ method is declared '= default'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isDefaulted(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * pure virtual.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isPureVirtual(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * declared 'static'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isStatic(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * explicitly declared 'virtual' or if it overrides a virtual method from\n * one of the base classes.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isVirtual(CXCursor C);\n\n/**\n * Determine if a C++ record is abstract, i.e. whether a class or struct\n * has a pure virtual member function.\n */\nCINDEX_LINKAGE unsigned clang_CXXRecord_isAbstract(CXCursor C);\n\n/**\n * Determine if an enum declaration refers to a scoped enum.\n */\nCINDEX_LINKAGE unsigned clang_EnumDecl_isScoped(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * declared 'const'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isConst(CXCursor C);\n\n/**\n * Given a cursor that represents a template, determine\n * the cursor kind of the specializations would be generated by instantiating\n * the template.\n *\n * This routine can be used to determine what flavor of function template,\n * class template, or class template partial specialization is stored in the\n * cursor. For example, it can describe whether a class template cursor is\n * declared with \"struct\", \"class\" or \"union\".\n *\n * \\param C The cursor to query. This cursor should represent a template\n * declaration.\n *\n * \\returns The cursor kind of the specializations that would be generated\n * by instantiating the template \\p C. If \\p C is not a template, returns\n * \\c CXCursor_NoDeclFound.\n */\nCINDEX_LINKAGE enum CXCursorKind clang_getTemplateCursorKind(CXCursor C);\n\n/**\n * Given a cursor that may represent a specialization or instantiation\n * of a template, retrieve the cursor that represents the template that it\n * specializes or from which it was instantiated.\n *\n * This routine determines the template involved both for explicit\n * specializations of templates and for implicit instantiations of the template,\n * both of which are referred to as \"specializations\". For a class template\n * specialization (e.g., \\c std::vector<bool>), this routine will return\n * either the primary template (\\c std::vector) or, if the specialization was\n * instantiated from a class template partial specialization, the class template\n * partial specialization. For a class template partial specialization and a\n * function template specialization (including instantiations), this\n * this routine will return the specialized template.\n *\n * For members of a class template (e.g., member functions, member classes, or\n * static data members), returns the specialized or instantiated member.\n * Although not strictly \"templates\" in the C++ language, members of class\n * templates have the same notions of specializations and instantiations that\n * templates do, so this routine treats them similarly.\n *\n * \\param C A cursor that may be a specialization of a template or a member\n * of a template.\n *\n * \\returns If the given cursor is a specialization or instantiation of a\n * template or a member thereof, the template or member that it specializes or\n * from which it was instantiated. Otherwise, returns a NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getSpecializedCursorTemplate(CXCursor C);\n\n/**\n * Given a cursor that references something else, return the source range\n * covering that reference.\n *\n * \\param C A cursor pointing to a member reference, a declaration reference, or\n * an operator call.\n * \\param NameFlags A bitset with three independent flags:\n * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and\n * CXNameRange_WantSinglePiece.\n * \\param PieceIndex For contiguous names or when passing the flag\n * CXNameRange_WantSinglePiece, only one piece with index 0 is\n * available. When the CXNameRange_WantSinglePiece flag is not passed for a\n * non-contiguous names, this index can be used to retrieve the individual\n * pieces of the name. See also CXNameRange_WantSinglePiece.\n *\n * \\returns The piece of the name pointed to by the given cursor. If there is no\n * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.\n */\nCINDEX_LINKAGE CXSourceRange clang_getCursorReferenceNameRange(\n    CXCursor C, unsigned NameFlags, unsigned PieceIndex);\n\nenum CXNameRefFlags {\n  /**\n   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the\n   * range.\n   */\n  CXNameRange_WantQualifier = 0x1,\n\n  /**\n   * Include the explicit template arguments, e.g. \\<int> in x.f<int>,\n   * in the range.\n   */\n  CXNameRange_WantTemplateArgs = 0x2,\n\n  /**\n   * If the name is non-contiguous, return the full spanning range.\n   *\n   * Non-contiguous names occur in Objective-C when a selector with two or more\n   * parameters is used, or in C++ when using an operator:\n   * \\code\n   * [object doSomething:here withValue:there]; // Objective-C\n   * return some_vector[1]; // C++\n   * \\endcode\n   */\n  CXNameRange_WantSinglePiece = 0x4\n};\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_LEX Token extraction and manipulation\n *\n * The routines in this group provide access to the tokens within a\n * translation unit, along with a semantic mapping of those tokens to\n * their corresponding cursors.\n *\n * @{\n */\n\n/**\n * Describes a kind of token.\n */\ntypedef enum CXTokenKind {\n  /**\n   * A token that contains some kind of punctuation.\n   */\n  CXToken_Punctuation,\n\n  /**\n   * A language keyword.\n   */\n  CXToken_Keyword,\n\n  /**\n   * An identifier (that is not a keyword).\n   */\n  CXToken_Identifier,\n\n  /**\n   * A numeric, string, or character literal.\n   */\n  CXToken_Literal,\n\n  /**\n   * A comment.\n   */\n  CXToken_Comment\n} CXTokenKind;\n\n/**\n * Describes a single preprocessing token.\n */\ntypedef struct {\n  unsigned int_data[4];\n  void *ptr_data;\n} CXToken;\n\n/**\n * Get the raw lexical token starting with the given location.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Location the source location with which the token starts.\n *\n * \\returns The token starting with the given location or NULL if no such token\n * exist. The returned pointer must be freed with clang_disposeTokens before the\n * translation unit is destroyed.\n */\nCINDEX_LINKAGE CXToken *clang_getToken(CXTranslationUnit TU,\n                                       CXSourceLocation Location);\n\n/**\n * Determine the kind of the given token.\n */\nCINDEX_LINKAGE CXTokenKind clang_getTokenKind(CXToken);\n\n/**\n * Determine the spelling of the given token.\n *\n * The spelling of a token is the textual representation of that token, e.g.,\n * the text of an identifier or keyword.\n */\nCINDEX_LINKAGE CXString clang_getTokenSpelling(CXTranslationUnit, CXToken);\n\n/**\n * Retrieve the source location of the given token.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getTokenLocation(CXTranslationUnit,\n                                                       CXToken);\n\n/**\n * Retrieve a source range that covers the given token.\n */\nCINDEX_LINKAGE CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken);\n\n/**\n * Tokenize the source code described by the given range into raw\n * lexical tokens.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Range the source range in which text should be tokenized. All of the\n * tokens produced by tokenization will fall within this source range,\n *\n * \\param Tokens this pointer will be set to point to the array of tokens\n * that occur within the given source range. The returned pointer must be\n * freed with clang_disposeTokens() before the translation unit is destroyed.\n *\n * \\param NumTokens will be set to the number of tokens in the \\c *Tokens\n * array.\n *\n */\nCINDEX_LINKAGE void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range,\n                                   CXToken **Tokens, unsigned *NumTokens);\n\n/**\n * Annotate the given set of tokens by providing cursors for each token\n * that can be mapped to a specific entity within the abstract syntax tree.\n *\n * This token-annotation routine is equivalent to invoking\n * clang_getCursor() for the source locations of each of the\n * tokens. The cursors provided are filtered, so that only those\n * cursors that have a direct correspondence to the token are\n * accepted. For example, given a function call \\c f(x),\n * clang_getCursor() would provide the following cursors:\n *\n *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.\n *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.\n *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.\n *\n * Only the first and last of these cursors will occur within the\n * annotate, since the tokens \"f\" and \"x' directly refer to a function\n * and a variable, respectively, but the parentheses are just a small\n * part of the full syntax of the function call expression, which is\n * not provided as an annotation.\n *\n * \\param TU the translation unit that owns the given tokens.\n *\n * \\param Tokens the set of tokens to annotate.\n *\n * \\param NumTokens the number of tokens in \\p Tokens.\n *\n * \\param Cursors an array of \\p NumTokens cursors, whose contents will be\n * replaced with the cursors corresponding to each token.\n */\nCINDEX_LINKAGE void clang_annotateTokens(CXTranslationUnit TU, CXToken *Tokens,\n                                         unsigned NumTokens, CXCursor *Cursors);\n\n/**\n * Free the given set of tokens.\n */\nCINDEX_LINKAGE void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens,\n                                        unsigned NumTokens);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_DEBUG Debugging facilities\n *\n * These routines are used for testing and debugging, only, and should not\n * be relied upon.\n *\n * @{\n */\n\n/* for debug/testing */\nCINDEX_LINKAGE CXString clang_getCursorKindSpelling(enum CXCursorKind Kind);\nCINDEX_LINKAGE void clang_getDefinitionSpellingAndExtent(\n    CXCursor, const char **startBuf, const char **endBuf, unsigned *startLine,\n    unsigned *startColumn, unsigned *endLine, unsigned *endColumn);\nCINDEX_LINKAGE void clang_enableStackTraces(void);\nCINDEX_LINKAGE void clang_executeOnThread(void (*fn)(void *), void *user_data,\n                                          unsigned stack_size);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CODE_COMPLET Code completion\n *\n * Code completion involves taking an (incomplete) source file, along with\n * knowledge of where the user is actively editing that file, and suggesting\n * syntactically- and semantically-valid constructs that the user might want to\n * use at that particular point in the source code. These data structures and\n * routines provide support for code completion.\n *\n * @{\n */\n\n/**\n * A semantic string that describes a code-completion result.\n *\n * A semantic string that describes the formatting of a code-completion\n * result as a single \"template\" of text that should be inserted into the\n * source buffer when a particular code-completion result is selected.\n * Each semantic string is made up of some number of \"chunks\", each of which\n * contains some text along with a description of what that text means, e.g.,\n * the name of the entity being referenced, whether the text chunk is part of\n * the template, or whether it is a \"placeholder\" that the user should replace\n * with actual code,of a specific kind. See \\c CXCompletionChunkKind for a\n * description of the different kinds of chunks.\n */\ntypedef void *CXCompletionString;\n\n/**\n * A single result of code completion.\n */\ntypedef struct {\n  /**\n   * The kind of entity that this completion refers to.\n   *\n   * The cursor kind will be a macro, keyword, or a declaration (one of the\n   * *Decl cursor kinds), describing the entity that the completion is\n   * referring to.\n   *\n   * \\todo In the future, we would like to provide a full cursor, to allow\n   * the client to extract additional information from declaration.\n   */\n  enum CXCursorKind CursorKind;\n\n  /**\n   * The code-completion string that describes how to insert this\n   * code-completion result into the editing buffer.\n   */\n  CXCompletionString CompletionString;\n} CXCompletionResult;\n\n/**\n * Describes a single piece of text within a code-completion string.\n *\n * Each \"chunk\" within a code-completion string (\\c CXCompletionString) is\n * either a piece of text with a specific \"kind\" that describes how that text\n * should be interpreted by the client or is another completion string.\n */\nenum CXCompletionChunkKind {\n  /**\n   * A code-completion string that describes \"optional\" text that\n   * could be a part of the template (but is not required).\n   *\n   * The Optional chunk is the only kind of chunk that has a code-completion\n   * string for its representation, which is accessible via\n   * \\c clang_getCompletionChunkCompletionString(). The code-completion string\n   * describes an additional part of the template that is completely optional.\n   * For example, optional chunks can be used to describe the placeholders for\n   * arguments that match up with defaulted function parameters, e.g. given:\n   *\n   * \\code\n   * void f(int x, float y = 3.14, double z = 2.71828);\n   * \\endcode\n   *\n   * The code-completion string for this function would contain:\n   *   - a TypedText chunk for \"f\".\n   *   - a LeftParen chunk for \"(\".\n   *   - a Placeholder chunk for \"int x\"\n   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,\n   *       - a Comma chunk for \",\"\n   *       - a Placeholder chunk for \"float y\"\n   *       - an Optional chunk containing the last defaulted argument:\n   *           - a Comma chunk for \",\"\n   *           - a Placeholder chunk for \"double z\"\n   *   - a RightParen chunk for \")\"\n   *\n   * There are many ways to handle Optional chunks. Two simple approaches are:\n   *   - Completely ignore optional chunks, in which case the template for the\n   *     function \"f\" would only include the first parameter (\"int x\").\n   *   - Fully expand all optional chunks, in which case the template for the\n   *     function \"f\" would have all of the parameters.\n   */\n  CXCompletionChunk_Optional,\n  /**\n   * Text that a user would be expected to type to get this\n   * code-completion result.\n   *\n   * There will be exactly one \"typed text\" chunk in a semantic string, which\n   * will typically provide the spelling of a keyword or the name of a\n   * declaration that could be used at the current code point. Clients are\n   * expected to filter the code-completion results based on the text in this\n   * chunk.\n   */\n  CXCompletionChunk_TypedText,\n  /**\n   * Text that should be inserted as part of a code-completion result.\n   *\n   * A \"text\" chunk represents text that is part of the template to be\n   * inserted into user code should this particular code-completion result\n   * be selected.\n   */\n  CXCompletionChunk_Text,\n  /**\n   * Placeholder text that should be replaced by the user.\n   *\n   * A \"placeholder\" chunk marks a place where the user should insert text\n   * into the code-completion template. For example, placeholders might mark\n   * the function parameters for a function declaration, to indicate that the\n   * user should provide arguments for each of those parameters. The actual\n   * text in a placeholder is a suggestion for the text to display before\n   * the user replaces the placeholder with real code.\n   */\n  CXCompletionChunk_Placeholder,\n  /**\n   * Informative text that should be displayed but never inserted as\n   * part of the template.\n   *\n   * An \"informative\" chunk contains annotations that can be displayed to\n   * help the user decide whether a particular code-completion result is the\n   * right option, but which is not part of the actual template to be inserted\n   * by code completion.\n   */\n  CXCompletionChunk_Informative,\n  /**\n   * Text that describes the current parameter when code-completion is\n   * referring to function call, message send, or template specialization.\n   *\n   * A \"current parameter\" chunk occurs when code-completion is providing\n   * information about a parameter corresponding to the argument at the\n   * code-completion point. For example, given a function\n   *\n   * \\code\n   * int add(int x, int y);\n   * \\endcode\n   *\n   * and the source code \\c add(, where the code-completion point is after the\n   * \"(\", the code-completion string will contain a \"current parameter\" chunk\n   * for \"int x\", indicating that the current argument will initialize that\n   * parameter. After typing further, to \\c add(17, (where the code-completion\n   * point is after the \",\"), the code-completion string will contain a\n   * \"current parameter\" chunk to \"int y\".\n   */\n  CXCompletionChunk_CurrentParameter,\n  /**\n   * A left parenthesis ('('), used to initiate a function call or\n   * signal the beginning of a function parameter list.\n   */\n  CXCompletionChunk_LeftParen,\n  /**\n   * A right parenthesis (')'), used to finish a function call or\n   * signal the end of a function parameter list.\n   */\n  CXCompletionChunk_RightParen,\n  /**\n   * A left bracket ('[').\n   */\n  CXCompletionChunk_LeftBracket,\n  /**\n   * A right bracket (']').\n   */\n  CXCompletionChunk_RightBracket,\n  /**\n   * A left brace ('{').\n   */\n  CXCompletionChunk_LeftBrace,\n  /**\n   * A right brace ('}').\n   */\n  CXCompletionChunk_RightBrace,\n  /**\n   * A left angle bracket ('<').\n   */\n  CXCompletionChunk_LeftAngle,\n  /**\n   * A right angle bracket ('>').\n   */\n  CXCompletionChunk_RightAngle,\n  /**\n   * A comma separator (',').\n   */\n  CXCompletionChunk_Comma,\n  /**\n   * Text that specifies the result type of a given result.\n   *\n   * This special kind of informative chunk is not meant to be inserted into\n   * the text buffer. Rather, it is meant to illustrate the type that an\n   * expression using the given completion string would have.\n   */\n  CXCompletionChunk_ResultType,\n  /**\n   * A colon (':').\n   */\n  CXCompletionChunk_Colon,\n  /**\n   * A semicolon (';').\n   */\n  CXCompletionChunk_SemiColon,\n  /**\n   * An '=' sign.\n   */\n  CXCompletionChunk_Equal,\n  /**\n   * Horizontal space (' ').\n   */\n  CXCompletionChunk_HorizontalSpace,\n  /**\n   * Vertical space ('\\\\n'), after which it is generally a good idea to\n   * perform indentation.\n   */\n  CXCompletionChunk_VerticalSpace\n};\n\n/**\n * Determine the kind of a particular chunk within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the kind of the chunk at the index \\c chunk_number.\n */\nCINDEX_LINKAGE enum CXCompletionChunkKind\nclang_getCompletionChunkKind(CXCompletionString completion_string,\n                             unsigned chunk_number);\n\n/**\n * Retrieve the text associated with a particular chunk within a\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the text associated with the chunk at index \\c chunk_number.\n */\nCINDEX_LINKAGE CXString clang_getCompletionChunkText(\n    CXCompletionString completion_string, unsigned chunk_number);\n\n/**\n * Retrieve the completion string associated with a particular chunk\n * within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the completion string associated with the chunk at index\n * \\c chunk_number.\n */\nCINDEX_LINKAGE CXCompletionString clang_getCompletionChunkCompletionString(\n    CXCompletionString completion_string, unsigned chunk_number);\n\n/**\n * Retrieve the number of chunks in the given code-completion string.\n */\nCINDEX_LINKAGE unsigned\nclang_getNumCompletionChunks(CXCompletionString completion_string);\n\n/**\n * Determine the priority of this code completion.\n *\n * The priority of a code completion indicates how likely it is that this\n * particular completion is the completion that the user will select. The\n * priority is selected by various internal heuristics.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The priority of this completion string. Smaller values indicate\n * higher-priority (more likely) completions.\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionPriority(CXCompletionString completion_string);\n\n/**\n * Determine the availability of the entity that this code-completion\n * string refers to.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The availability of the completion string.\n */\nCINDEX_LINKAGE enum CXAvailabilityKind\nclang_getCompletionAvailability(CXCompletionString completion_string);\n\n/**\n * Retrieve the number of annotations associated with the given\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\returns the number of annotations associated with the given completion\n * string.\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionNumAnnotations(CXCompletionString completion_string);\n\n/**\n * Retrieve the annotation associated with the given completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param annotation_number the 0-based index of the annotation of the\n * completion string.\n *\n * \\returns annotation string associated with the completion at index\n * \\c annotation_number, or a NULL string if that annotation is not available.\n */\nCINDEX_LINKAGE CXString clang_getCompletionAnnotation(\n    CXCompletionString completion_string, unsigned annotation_number);\n\n/**\n * Retrieve the parent context of the given completion string.\n *\n * The parent context of a completion string is the semantic parent of\n * the declaration (if any) that the code completion represents. For example,\n * a code completion for an Objective-C method would have the method's class\n * or protocol as its context.\n *\n * \\param completion_string The code completion string whose parent is\n * being queried.\n *\n * \\param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.\n *\n * \\returns The name of the completion parent, e.g., \"NSObject\" if\n * the completion string represents a method in the NSObject class.\n */\nCINDEX_LINKAGE CXString clang_getCompletionParent(\n    CXCompletionString completion_string, enum CXCursorKind *kind);\n\n/**\n * Retrieve the brief documentation comment attached to the declaration\n * that corresponds to the given completion string.\n */\nCINDEX_LINKAGE CXString\nclang_getCompletionBriefComment(CXCompletionString completion_string);\n\n/**\n * Retrieve a completion string for an arbitrary declaration or macro\n * definition cursor.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns A non-context-sensitive completion string for declaration and macro\n * definition cursors, or NULL for other kinds of cursors.\n */\nCINDEX_LINKAGE CXCompletionString\nclang_getCursorCompletionString(CXCursor cursor);\n\n/**\n * Contains the results of code-completion.\n *\n * This data structure contains the results of code completion, as\n * produced by \\c clang_codeCompleteAt(). Its contents must be freed by\n * \\c clang_disposeCodeCompleteResults.\n */\ntypedef struct {\n  /**\n   * The code-completion results.\n   */\n  CXCompletionResult *Results;\n\n  /**\n   * The number of code-completion results stored in the\n   * \\c Results array.\n   */\n  unsigned NumResults;\n} CXCodeCompleteResults;\n\n/**\n * Retrieve the number of fix-its for the given completion index.\n *\n * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts\n * option was set.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\return The number of fix-its which must be applied before the completion at\n * completion_index can be applied\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionNumFixIts(CXCodeCompleteResults *results,\n                             unsigned completion_index);\n\n/**\n * Fix-its that *must* be applied before inserting the text for the\n * corresponding completion.\n *\n * By default, clang_codeCompleteAt() only returns completions with empty\n * fix-its. Extra completions with non-empty fix-its should be explicitly\n * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.\n *\n * For the clients to be able to compute position of the cursor after applying\n * fix-its, the following conditions are guaranteed to hold for\n * replacement_range of the stored fix-its:\n *  - Ranges in the fix-its are guaranteed to never contain the completion\n *  point (or identifier under completion point, if any) inside them, except\n *  at the start or at the end of the range.\n *  - If a fix-it range starts or ends with completion point (or starts or\n *  ends after the identifier under completion point), it will contain at\n *  least one character. It allows to unambiguously recompute completion\n *  point after applying the fix-it.\n *\n * The intuition is that provided fix-its change code around the identifier we\n * complete, but are not allowed to touch the identifier itself or the\n * completion point. One example of completions with corrections are the ones\n * replacing '.' with '->' and vice versa:\n *\n * std::unique_ptr<std::vector<int>> vec_ptr;\n * In 'vec_ptr.^', one of the completions is 'push_back', it requires\n * replacing '.' with '->'.\n * In 'vec_ptr->^', one of the completions is 'release', it requires\n * replacing '->' with '.'.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\param fixit_index The index of the fix-it for the completion at\n * completion_index\n *\n * \\param replacement_range The fix-it range that must be replaced before the\n * completion at completion_index can be applied\n *\n * \\returns The fix-it string that must replace the code at replacement_range\n * before the completion at completion_index can be applied\n */\nCINDEX_LINKAGE CXString clang_getCompletionFixIt(\n    CXCodeCompleteResults *results, unsigned completion_index,\n    unsigned fixit_index, CXSourceRange *replacement_range);\n\n/**\n * Flags that can be passed to \\c clang_codeCompleteAt() to\n * modify its behavior.\n *\n * The enumerators in this enumeration can be bitwise-OR'd together to\n * provide multiple options to \\c clang_codeCompleteAt().\n */\nenum CXCodeComplete_Flags {\n  /**\n   * Whether to include macros within the set of code\n   * completions returned.\n   */\n  CXCodeComplete_IncludeMacros = 0x01,\n\n  /**\n   * Whether to include code patterns for language constructs\n   * within the set of code completions, e.g., for loops.\n   */\n  CXCodeComplete_IncludeCodePatterns = 0x02,\n\n  /**\n   * Whether to include brief documentation within the set of code\n   * completions returned.\n   */\n  CXCodeComplete_IncludeBriefComments = 0x04,\n\n  /**\n   * Whether to speed up completion by omitting top- or namespace-level entities\n   * defined in the preamble. There's no guarantee any particular entity is\n   * omitted. This may be useful if the headers are indexed externally.\n   */\n  CXCodeComplete_SkipPreamble = 0x08,\n\n  /**\n   * Whether to include completions with small\n   * fix-its, e.g. change '.' to '->' on member access, etc.\n   */\n  CXCodeComplete_IncludeCompletionsWithFixIts = 0x10\n};\n\n/**\n * Bits that represent the context under which completion is occurring.\n *\n * The enumerators in this enumeration may be bitwise-OR'd together if multiple\n * contexts are occurring simultaneously.\n */\nenum CXCompletionContext {\n  /**\n   * The context for completions is unexposed, as only Clang results\n   * should be included. (This is equivalent to having no context bits set.)\n   */\n  CXCompletionContext_Unexposed = 0,\n\n  /**\n   * Completions for any possible type should be included in the results.\n   */\n  CXCompletionContext_AnyType = 1 << 0,\n\n  /**\n   * Completions for any possible value (variables, function calls, etc.)\n   * should be included in the results.\n   */\n  CXCompletionContext_AnyValue = 1 << 1,\n  /**\n   * Completions for values that resolve to an Objective-C object should\n   * be included in the results.\n   */\n  CXCompletionContext_ObjCObjectValue = 1 << 2,\n  /**\n   * Completions for values that resolve to an Objective-C selector\n   * should be included in the results.\n   */\n  CXCompletionContext_ObjCSelectorValue = 1 << 3,\n  /**\n   * Completions for values that resolve to a C++ class type should be\n   * included in the results.\n   */\n  CXCompletionContext_CXXClassTypeValue = 1 << 4,\n\n  /**\n   * Completions for fields of the member being accessed using the dot\n   * operator should be included in the results.\n   */\n  CXCompletionContext_DotMemberAccess = 1 << 5,\n  /**\n   * Completions for fields of the member being accessed using the arrow\n   * operator should be included in the results.\n   */\n  CXCompletionContext_ArrowMemberAccess = 1 << 6,\n  /**\n   * Completions for properties of the Objective-C object being accessed\n   * using the dot operator should be included in the results.\n   */\n  CXCompletionContext_ObjCPropertyAccess = 1 << 7,\n\n  /**\n   * Completions for enum tags should be included in the results.\n   */\n  CXCompletionContext_EnumTag = 1 << 8,\n  /**\n   * Completions for union tags should be included in the results.\n   */\n  CXCompletionContext_UnionTag = 1 << 9,\n  /**\n   * Completions for struct tags should be included in the results.\n   */\n  CXCompletionContext_StructTag = 1 << 10,\n\n  /**\n   * Completions for C++ class names should be included in the results.\n   */\n  CXCompletionContext_ClassTag = 1 << 11,\n  /**\n   * Completions for C++ namespaces and namespace aliases should be\n   * included in the results.\n   */\n  CXCompletionContext_Namespace = 1 << 12,\n  /**\n   * Completions for C++ nested name specifiers should be included in\n   * the results.\n   */\n  CXCompletionContext_NestedNameSpecifier = 1 << 13,\n\n  /**\n   * Completions for Objective-C interfaces (classes) should be included\n   * in the results.\n   */\n  CXCompletionContext_ObjCInterface = 1 << 14,\n  /**\n   * Completions for Objective-C protocols should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCProtocol = 1 << 15,\n  /**\n   * Completions for Objective-C categories should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCCategory = 1 << 16,\n  /**\n   * Completions for Objective-C instance messages should be included\n   * in the results.\n   */\n  CXCompletionContext_ObjCInstanceMessage = 1 << 17,\n  /**\n   * Completions for Objective-C class messages should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCClassMessage = 1 << 18,\n  /**\n   * Completions for Objective-C selector names should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCSelectorName = 1 << 19,\n\n  /**\n   * Completions for preprocessor macro names should be included in\n   * the results.\n   */\n  CXCompletionContext_MacroName = 1 << 20,\n\n  /**\n   * Natural language completions should be included in the results.\n   */\n  CXCompletionContext_NaturalLanguage = 1 << 21,\n\n  /**\n   * #include file completions should be included in the results.\n   */\n  CXCompletionContext_IncludedFile = 1 << 22,\n\n  /**\n   * The current context is unknown, so set all contexts.\n   */\n  CXCompletionContext_Unknown = ((1 << 23) - 1)\n};\n\n/**\n * Returns a default set of code-completion options that can be\n * passed to\\c clang_codeCompleteAt().\n */\nCINDEX_LINKAGE unsigned clang_defaultCodeCompleteOptions(void);\n\n/**\n * Perform code completion at a given location in a translation unit.\n *\n * This function performs code completion at a particular file, line, and\n * column within source code, providing results that suggest potential\n * code snippets based on the context of the completion. The basic model\n * for code completion is that Clang will parse a complete source file,\n * performing syntax checking up to the location where code-completion has\n * been requested. At that point, a special code-completion token is passed\n * to the parser, which recognizes this token and determines, based on the\n * current location in the C/Objective-C/C++ grammar and the state of\n * semantic analysis, what completions to provide. These completions are\n * returned via a new \\c CXCodeCompleteResults structure.\n *\n * Code completion itself is meant to be triggered by the client when the\n * user types punctuation characters or whitespace, at which point the\n * code-completion location will coincide with the cursor. For example, if \\c p\n * is a pointer, code-completion might be triggered after the \"-\" and then\n * after the \">\" in \\c p->. When the code-completion location is after the \">\",\n * the completion results will provide, e.g., the members of the struct that\n * \"p\" points to. The client is responsible for placing the cursor at the\n * beginning of the token currently being typed, then filtering the results\n * based on the contents of the token. For example, when code-completing for\n * the expression \\c p->get, the client should provide the location just after\n * the \">\" (e.g., pointing at the \"g\") to this code-completion hook. Then, the\n * client can filter the results based on the current token text (\"get\"), only\n * showing those results that start with \"get\". The intent of this interface\n * is to separate the relatively high-latency acquisition of code-completion\n * results from the filtering of results on a per-character basis, which must\n * have a lower latency.\n *\n * \\param TU The translation unit in which code-completion should\n * occur. The source files for this translation unit need not be\n * completely up-to-date (and the contents of those source files may\n * be overridden via \\p unsaved_files). Cursors referring into the\n * translation unit may be invalidated by this invocation.\n *\n * \\param complete_filename The name of the source file where code\n * completion should be performed. This filename may be any file\n * included in the translation unit.\n *\n * \\param complete_line The line at which code-completion should occur.\n *\n * \\param complete_column The column at which code-completion should occur.\n * Note that the column should point just after the syntactic construct that\n * initiated code completion, and not in the middle of a lexical token.\n *\n * \\param unsaved_files the Files that have not yet been saved to disk\n * but may be required for parsing or code completion, including the\n * contents of those files.  The contents and name of these files (as\n * specified by CXUnsavedFile) are copied when necessary, so the\n * client only needs to guarantee their validity until the call to\n * this function returns.\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options Extra options that control the behavior of code\n * completion, expressed as a bitwise OR of the enumerators of the\n * CXCodeComplete_Flags enumeration. The\n * \\c clang_defaultCodeCompleteOptions() function returns a default set\n * of code-completion options.\n *\n * \\returns If successful, a new \\c CXCodeCompleteResults structure\n * containing code-completion results, which should eventually be\n * freed with \\c clang_disposeCodeCompleteResults(). If code\n * completion fails, returns NULL.\n */\nCINDEX_LINKAGE\nCXCodeCompleteResults *\nclang_codeCompleteAt(CXTranslationUnit TU, const char *complete_filename,\n                     unsigned complete_line, unsigned complete_column,\n                     struct CXUnsavedFile *unsaved_files,\n                     unsigned num_unsaved_files, unsigned options);\n\n/**\n * Sort the code-completion results in case-insensitive alphabetical\n * order.\n *\n * \\param Results The set of results to sort.\n * \\param NumResults The number of results in \\p Results.\n */\nCINDEX_LINKAGE\nvoid clang_sortCodeCompletionResults(CXCompletionResult *Results,\n                                     unsigned NumResults);\n\n/**\n * Free the given set of code-completion results.\n */\nCINDEX_LINKAGE\nvoid clang_disposeCodeCompleteResults(CXCodeCompleteResults *Results);\n\n/**\n * Determine the number of diagnostics produced prior to the\n * location where code completion was performed.\n */\nCINDEX_LINKAGE\nunsigned clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults *Results);\n\n/**\n * Retrieve a diagnostic associated with the given code completion.\n *\n * \\param Results the code completion results to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE\nCXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults *Results,\n                                             unsigned Index);\n\n/**\n * Determines what completions are appropriate for the context\n * the given code completion.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the kinds of completions that are appropriate for use\n * along with the given code completion results.\n */\nCINDEX_LINKAGE\nunsigned long long\nclang_codeCompleteGetContexts(CXCodeCompleteResults *Results);\n\n/**\n * Returns the cursor kind for the container for the current code\n * completion context. The container is only guaranteed to be set for\n * contexts where a container exists (i.e. member accesses or Objective-C\n * message sends); if there is not a container, this function will return\n * CXCursor_InvalidCode.\n *\n * \\param Results the code completion results to query\n *\n * \\param IsIncomplete on return, this value will be false if Clang has complete\n * information about the container. If Clang does not have complete\n * information, this value will be true.\n *\n * \\returns the container kind, or CXCursor_InvalidCode if there is not a\n * container\n */\nCINDEX_LINKAGE\nenum CXCursorKind\nclang_codeCompleteGetContainerKind(CXCodeCompleteResults *Results,\n                                   unsigned *IsIncomplete);\n\n/**\n * Returns the USR for the container for the current code completion\n * context. If there is not a container for the current context, this\n * function will return the empty string.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the USR for the container\n */\nCINDEX_LINKAGE\nCXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults *Results);\n\n/**\n * Returns the currently-entered selector for an Objective-C message\n * send, formatted like \"initWithFoo:bar:\". Only guaranteed to return a\n * non-empty string for CXCompletionContext_ObjCInstanceMessage and\n * CXCompletionContext_ObjCClassMessage.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the selector (or partial selector) that has been entered thus far\n * for an Objective-C message send.\n */\nCINDEX_LINKAGE\nCXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults *Results);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_MISC Miscellaneous utility functions\n *\n * @{\n */\n\n/**\n * Return a version string, suitable for showing to a user, but not\n *        intended to be parsed (the format is not guaranteed to be stable).\n */\nCINDEX_LINKAGE CXString clang_getClangVersion(void);\n\n/**\n * Enable/disable crash recovery.\n *\n * \\param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero\n *        value enables crash recovery, while 0 disables it.\n */\nCINDEX_LINKAGE void clang_toggleCrashRecovery(unsigned isEnabled);\n\n/**\n * Visitor invoked for each file in a translation unit\n *        (used with clang_getInclusions()).\n *\n * This visitor function will be invoked by clang_getInclusions() for each\n * file included (either at the top-level or by \\#include directives) within\n * a translation unit.  The first argument is the file being included, and\n * the second and third arguments provide the inclusion stack.  The\n * array is sorted in order of immediate inclusion.  For example,\n * the first element refers to the location that included 'included_file'.\n */\ntypedef void (*CXInclusionVisitor)(CXFile included_file,\n                                   CXSourceLocation *inclusion_stack,\n                                   unsigned include_len,\n                                   CXClientData client_data);\n\n/**\n * Visit the set of preprocessor inclusions in a translation unit.\n *   The visitor function is called with the provided data for every included\n *   file.  This does not include headers included by the PCH file (unless one\n *   is inspecting the inclusions in the PCH file itself).\n */\nCINDEX_LINKAGE void clang_getInclusions(CXTranslationUnit tu,\n                                        CXInclusionVisitor visitor,\n                                        CXClientData client_data);\n\ntypedef enum {\n  CXEval_Int = 1,\n  CXEval_Float = 2,\n  CXEval_ObjCStrLiteral = 3,\n  CXEval_StrLiteral = 4,\n  CXEval_CFStr = 5,\n  CXEval_Other = 6,\n\n  CXEval_UnExposed = 0\n\n} CXEvalResultKind;\n\n/**\n * Evaluation result of a cursor\n */\ntypedef void *CXEvalResult;\n\n/**\n * If cursor is a statement declaration tries to evaluate the\n * statement and if its variable, tries to evaluate its initializer,\n * into its corresponding type.\n * If it's an expression, tries to evaluate the expression.\n */\nCINDEX_LINKAGE CXEvalResult clang_Cursor_Evaluate(CXCursor C);\n\n/**\n * Returns the kind of the evaluated result.\n */\nCINDEX_LINKAGE CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E);\n\n/**\n * Returns the evaluation result as integer if the\n * kind is Int.\n */\nCINDEX_LINKAGE int clang_EvalResult_getAsInt(CXEvalResult E);\n\n/**\n * Returns the evaluation result as a long long integer if the\n * kind is Int. This prevents overflows that may happen if the result is\n * returned with clang_EvalResult_getAsInt.\n */\nCINDEX_LINKAGE long long clang_EvalResult_getAsLongLong(CXEvalResult E);\n\n/**\n * Returns a non-zero value if the kind is Int and the evaluation\n * result resulted in an unsigned integer.\n */\nCINDEX_LINKAGE unsigned clang_EvalResult_isUnsignedInt(CXEvalResult E);\n\n/**\n * Returns the evaluation result as an unsigned integer if\n * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.\n */\nCINDEX_LINKAGE unsigned long long\nclang_EvalResult_getAsUnsigned(CXEvalResult E);\n\n/**\n * Returns the evaluation result as double if the\n * kind is double.\n */\nCINDEX_LINKAGE double clang_EvalResult_getAsDouble(CXEvalResult E);\n\n/**\n * Returns the evaluation result as a constant string if the\n * kind is other than Int or float. User must not free this pointer,\n * instead call clang_EvalResult_dispose on the CXEvalResult returned\n * by clang_Cursor_Evaluate.\n */\nCINDEX_LINKAGE const char *clang_EvalResult_getAsStr(CXEvalResult E);\n\n/**\n * Disposes the created Eval memory.\n */\nCINDEX_LINKAGE void clang_EvalResult_dispose(CXEvalResult E);\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_REMAPPING Remapping functions\n *\n * @{\n */\n\n/**\n * A remapping of original source files and their translated files.\n */\ntypedef void *CXRemapping;\n\n/**\n * Retrieve a remapping.\n *\n * \\param path the path that contains metadata about remappings.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */\nCINDEX_LINKAGE CXRemapping clang_getRemappings(const char *path);\n\n/**\n * Retrieve a remapping.\n *\n * \\param filePaths pointer to an array of file paths containing remapping info.\n *\n * \\param numFiles number of file paths.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */\nCINDEX_LINKAGE\nCXRemapping clang_getRemappingsFromFileList(const char **filePaths,\n                                            unsigned numFiles);\n\n/**\n * Determine the number of remappings.\n */\nCINDEX_LINKAGE unsigned clang_remap_getNumFiles(CXRemapping);\n\n/**\n * Get the original and the associated filename from the remapping.\n *\n * \\param original If non-NULL, will be set to the original filename.\n *\n * \\param transformed If non-NULL, will be set to the filename that the original\n * is associated with.\n */\nCINDEX_LINKAGE void clang_remap_getFilenames(CXRemapping, unsigned index,\n                                             CXString *original,\n                                             CXString *transformed);\n\n/**\n * Dispose the remapping.\n */\nCINDEX_LINKAGE void clang_remap_dispose(CXRemapping);\n\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_HIGH Higher level API functions\n *\n * @{\n */\n\nenum CXVisitorResult { CXVisit_Break, CXVisit_Continue };\n\ntypedef struct CXCursorAndRangeVisitor {\n  void *context;\n  enum CXVisitorResult (*visit)(void *context, CXCursor, CXSourceRange);\n} CXCursorAndRangeVisitor;\n\ntypedef enum {\n  /**\n   * Function returned successfully.\n   */\n  CXResult_Success = 0,\n  /**\n   * One of the parameters was invalid for the function.\n   */\n  CXResult_Invalid = 1,\n  /**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */\n  CXResult_VisitBreak = 2\n\n} CXResult;\n\n/**\n * Find references of a declaration in a specific file.\n *\n * \\param cursor pointing to a declaration or a reference of one.\n *\n * \\param file to search for references.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each reference found.\n * The CXSourceRange will point inside the file; if the reference is inside\n * a macro (and not a macro argument) the CXSourceRange will be invalid.\n *\n * \\returns one of the CXResult enumerators.\n */\nCINDEX_LINKAGE CXResult clang_findReferencesInFile(\n    CXCursor cursor, CXFile file, CXCursorAndRangeVisitor visitor);\n\n/**\n * Find #import/#include directives in a specific file.\n *\n * \\param TU translation unit containing the file to query.\n *\n * \\param file to search for #import/#include directives.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each directive found.\n *\n * \\returns one of the CXResult enumerators.\n */\nCINDEX_LINKAGE CXResult clang_findIncludesInFile(\n    CXTranslationUnit TU, CXFile file, CXCursorAndRangeVisitor visitor);\n\n#ifdef __has_feature\n#if __has_feature(blocks)\n\ntypedef enum CXVisitorResult (^CXCursorAndRangeVisitorBlock)(CXCursor,\n                                                             CXSourceRange);\n\nCINDEX_LINKAGE\nCXResult clang_findReferencesInFileWithBlock(CXCursor, CXFile,\n                                             CXCursorAndRangeVisitorBlock);\n\nCINDEX_LINKAGE\nCXResult clang_findIncludesInFileWithBlock(CXTranslationUnit, CXFile,\n                                           CXCursorAndRangeVisitorBlock);\n\n#endif\n#endif\n\n/**\n * The client's data object that is associated with a CXFile.\n */\ntypedef void *CXIdxClientFile;\n\n/**\n * The client's data object that is associated with a semantic entity.\n */\ntypedef void *CXIdxClientEntity;\n\n/**\n * The client's data object that is associated with a semantic container\n * of entities.\n */\ntypedef void *CXIdxClientContainer;\n\n/**\n * The client's data object that is associated with an AST file (PCH\n * or module).\n */\ntypedef void *CXIdxClientASTFile;\n\n/**\n * Source location passed to index callbacks.\n */\ntypedef struct {\n  void *ptr_data[2];\n  unsigned int_data;\n} CXIdxLoc;\n\n/**\n * Data for ppIncludedFile callback.\n */\ntypedef struct {\n  /**\n   * Location of '#' in the \\#include/\\#import directive.\n   */\n  CXIdxLoc hashLoc;\n  /**\n   * Filename as written in the \\#include/\\#import directive.\n   */\n  const char *filename;\n  /**\n   * The actual file that the \\#include/\\#import directive resolved to.\n   */\n  CXFile file;\n  int isImport;\n  int isAngled;\n  /**\n   * Non-zero if the directive was automatically turned into a module\n   * import.\n   */\n  int isModuleImport;\n} CXIdxIncludedFileInfo;\n\n/**\n * Data for IndexerCallbacks#importedASTFile.\n */\ntypedef struct {\n  /**\n   * Top level AST file containing the imported PCH, module or submodule.\n   */\n  CXFile file;\n  /**\n   * The imported module or NULL if the AST file is a PCH.\n   */\n  CXModule module;\n  /**\n   * Location where the file is imported. Applicable only for modules.\n   */\n  CXIdxLoc loc;\n  /**\n   * Non-zero if an inclusion directive was automatically turned into\n   * a module import. Applicable only for modules.\n   */\n  int isImplicit;\n\n} CXIdxImportedASTFileInfo;\n\ntypedef enum {\n  CXIdxEntity_Unexposed = 0,\n  CXIdxEntity_Typedef = 1,\n  CXIdxEntity_Function = 2,\n  CXIdxEntity_Variable = 3,\n  CXIdxEntity_Field = 4,\n  CXIdxEntity_EnumConstant = 5,\n\n  CXIdxEntity_ObjCClass = 6,\n  CXIdxEntity_ObjCProtocol = 7,\n  CXIdxEntity_ObjCCategory = 8,\n\n  CXIdxEntity_ObjCInstanceMethod = 9,\n  CXIdxEntity_ObjCClassMethod = 10,\n  CXIdxEntity_ObjCProperty = 11,\n  CXIdxEntity_ObjCIvar = 12,\n\n  CXIdxEntity_Enum = 13,\n  CXIdxEntity_Struct = 14,\n  CXIdxEntity_Union = 15,\n\n  CXIdxEntity_CXXClass = 16,\n  CXIdxEntity_CXXNamespace = 17,\n  CXIdxEntity_CXXNamespaceAlias = 18,\n  CXIdxEntity_CXXStaticVariable = 19,\n  CXIdxEntity_CXXStaticMethod = 20,\n  CXIdxEntity_CXXInstanceMethod = 21,\n  CXIdxEntity_CXXConstructor = 22,\n  CXIdxEntity_CXXDestructor = 23,\n  CXIdxEntity_CXXConversionFunction = 24,\n  CXIdxEntity_CXXTypeAlias = 25,\n  CXIdxEntity_CXXInterface = 26\n\n} CXIdxEntityKind;\n\ntypedef enum {\n  CXIdxEntityLang_None = 0,\n  CXIdxEntityLang_C = 1,\n  CXIdxEntityLang_ObjC = 2,\n  CXIdxEntityLang_CXX = 3,\n  CXIdxEntityLang_Swift = 4\n} CXIdxEntityLanguage;\n\n/**\n * Extra C++ template information for an entity. This can apply to:\n * CXIdxEntity_Function\n * CXIdxEntity_CXXClass\n * CXIdxEntity_CXXStaticMethod\n * CXIdxEntity_CXXInstanceMethod\n * CXIdxEntity_CXXConstructor\n * CXIdxEntity_CXXConversionFunction\n * CXIdxEntity_CXXTypeAlias\n */\ntypedef enum {\n  CXIdxEntity_NonTemplate = 0,\n  CXIdxEntity_Template = 1,\n  CXIdxEntity_TemplatePartialSpecialization = 2,\n  CXIdxEntity_TemplateSpecialization = 3\n} CXIdxEntityCXXTemplateKind;\n\ntypedef enum {\n  CXIdxAttr_Unexposed = 0,\n  CXIdxAttr_IBAction = 1,\n  CXIdxAttr_IBOutlet = 2,\n  CXIdxAttr_IBOutletCollection = 3\n} CXIdxAttrKind;\n\ntypedef struct {\n  CXIdxAttrKind kind;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxAttrInfo;\n\ntypedef struct {\n  CXIdxEntityKind kind;\n  CXIdxEntityCXXTemplateKind templateKind;\n  CXIdxEntityLanguage lang;\n  const char *name;\n  const char *USR;\n  CXCursor cursor;\n  const CXIdxAttrInfo *const *attributes;\n  unsigned numAttributes;\n} CXIdxEntityInfo;\n\ntypedef struct {\n  CXCursor cursor;\n} CXIdxContainerInfo;\n\ntypedef struct {\n  const CXIdxAttrInfo *attrInfo;\n  const CXIdxEntityInfo *objcClass;\n  CXCursor classCursor;\n  CXIdxLoc classLoc;\n} CXIdxIBOutletCollectionAttrInfo;\n\ntypedef enum { CXIdxDeclFlag_Skipped = 0x1 } CXIdxDeclInfoFlags;\n\ntypedef struct {\n  const CXIdxEntityInfo *entityInfo;\n  CXCursor cursor;\n  CXIdxLoc loc;\n  const CXIdxContainerInfo *semanticContainer;\n  /**\n   * Generally same as #semanticContainer but can be different in\n   * cases like out-of-line C++ member functions.\n   */\n  const CXIdxContainerInfo *lexicalContainer;\n  int isRedeclaration;\n  int isDefinition;\n  int isContainer;\n  const CXIdxContainerInfo *declAsContainer;\n  /**\n   * Whether the declaration exists in code or was created implicitly\n   * by the compiler, e.g. implicit Objective-C methods for properties.\n   */\n  int isImplicit;\n  const CXIdxAttrInfo *const *attributes;\n  unsigned numAttributes;\n\n  unsigned flags;\n\n} CXIdxDeclInfo;\n\ntypedef enum {\n  CXIdxObjCContainer_ForwardRef = 0,\n  CXIdxObjCContainer_Interface = 1,\n  CXIdxObjCContainer_Implementation = 2\n} CXIdxObjCContainerKind;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  CXIdxObjCContainerKind kind;\n} CXIdxObjCContainerDeclInfo;\n\ntypedef struct {\n  const CXIdxEntityInfo *base;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxBaseClassInfo;\n\ntypedef struct {\n  const CXIdxEntityInfo *protocol;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxObjCProtocolRefInfo;\n\ntypedef struct {\n  const CXIdxObjCProtocolRefInfo *const *protocols;\n  unsigned numProtocols;\n} CXIdxObjCProtocolRefListInfo;\n\ntypedef struct {\n  const CXIdxObjCContainerDeclInfo *containerInfo;\n  const CXIdxBaseClassInfo *superInfo;\n  const CXIdxObjCProtocolRefListInfo *protocols;\n} CXIdxObjCInterfaceDeclInfo;\n\ntypedef struct {\n  const CXIdxObjCContainerDeclInfo *containerInfo;\n  const CXIdxEntityInfo *objcClass;\n  CXCursor classCursor;\n  CXIdxLoc classLoc;\n  const CXIdxObjCProtocolRefListInfo *protocols;\n} CXIdxObjCCategoryDeclInfo;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  const CXIdxEntityInfo *getter;\n  const CXIdxEntityInfo *setter;\n} CXIdxObjCPropertyDeclInfo;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  const CXIdxBaseClassInfo *const *bases;\n  unsigned numBases;\n} CXIdxCXXClassDeclInfo;\n\n/**\n * Data for IndexerCallbacks#indexEntityReference.\n *\n * This may be deprecated in a future version as this duplicates\n * the \\c CXSymbolRole_Implicit bit in \\c CXSymbolRole.\n */\ntypedef enum {\n  /**\n   * The entity is referenced directly in user's code.\n   */\n  CXIdxEntityRef_Direct = 1,\n  /**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */\n  CXIdxEntityRef_Implicit = 2\n} CXIdxEntityRefKind;\n\n/**\n * Roles that are attributed to symbol occurrences.\n *\n * Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with\n * higher bits zeroed. These high bits may be exposed in the future.\n */\ntypedef enum {\n  CXSymbolRole_None = 0,\n  CXSymbolRole_Declaration = 1 << 0,\n  CXSymbolRole_Definition = 1 << 1,\n  CXSymbolRole_Reference = 1 << 2,\n  CXSymbolRole_Read = 1 << 3,\n  CXSymbolRole_Write = 1 << 4,\n  CXSymbolRole_Call = 1 << 5,\n  CXSymbolRole_Dynamic = 1 << 6,\n  CXSymbolRole_AddressOf = 1 << 7,\n  CXSymbolRole_Implicit = 1 << 8\n} CXSymbolRole;\n\n/**\n * Data for IndexerCallbacks#indexEntityReference.\n */\ntypedef struct {\n  CXIdxEntityRefKind kind;\n  /**\n   * Reference cursor.\n   */\n  CXCursor cursor;\n  CXIdxLoc loc;\n  /**\n   * The entity that gets referenced.\n   */\n  const CXIdxEntityInfo *referencedEntity;\n  /**\n   * Immediate \"parent\" of the reference. For example:\n   *\n   * \\code\n   * Foo *var;\n   * \\endcode\n   *\n   * The parent of reference of type 'Foo' is the variable 'var'.\n   * For references inside statement bodies of functions/methods,\n   * the parentEntity will be the function/method.\n   */\n  const CXIdxEntityInfo *parentEntity;\n  /**\n   * Lexical container context of the reference.\n   */\n  const CXIdxContainerInfo *container;\n  /**\n   * Sets of symbol roles of the reference.\n   */\n  CXSymbolRole role;\n} CXIdxEntityRefInfo;\n\n/**\n * A group of callbacks used by #clang_indexSourceFile and\n * #clang_indexTranslationUnit.\n */\ntypedef struct {\n  /**\n   * Called periodically to check whether indexing should be aborted.\n   * Should return 0 to continue, and non-zero to abort.\n   */\n  int (*abortQuery)(CXClientData client_data, void *reserved);\n\n  /**\n   * Called at the end of indexing; passes the complete diagnostic set.\n   */\n  void (*diagnostic)(CXClientData client_data, CXDiagnosticSet, void *reserved);\n\n  CXIdxClientFile (*enteredMainFile)(CXClientData client_data, CXFile mainFile,\n                                     void *reserved);\n\n  /**\n   * Called when a file gets \\#included/\\#imported.\n   */\n  CXIdxClientFile (*ppIncludedFile)(CXClientData client_data,\n                                    const CXIdxIncludedFileInfo *);\n\n  /**\n   * Called when a AST file (PCH or module) gets imported.\n   *\n   * AST files will not get indexed (there will not be callbacks to index all\n   * the entities in an AST file). The recommended action is that, if the AST\n   * file is not already indexed, to initiate a new indexing job specific to\n   * the AST file.\n   */\n  CXIdxClientASTFile (*importedASTFile)(CXClientData client_data,\n                                        const CXIdxImportedASTFileInfo *);\n\n  /**\n   * Called at the beginning of indexing a translation unit.\n   */\n  CXIdxClientContainer (*startedTranslationUnit)(CXClientData client_data,\n                                                 void *reserved);\n\n  void (*indexDeclaration)(CXClientData client_data, const CXIdxDeclInfo *);\n\n  /**\n   * Called to index a reference of an entity.\n   */\n  void (*indexEntityReference)(CXClientData client_data,\n                               const CXIdxEntityRefInfo *);\n\n} IndexerCallbacks;\n\nCINDEX_LINKAGE int clang_index_isEntityObjCContainerKind(CXIdxEntityKind);\nCINDEX_LINKAGE const CXIdxObjCContainerDeclInfo *\nclang_index_getObjCContainerDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCInterfaceDeclInfo *\nclang_index_getObjCInterfaceDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE\nconst CXIdxObjCCategoryDeclInfo *\nclang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCProtocolRefListInfo *\nclang_index_getObjCProtocolRefListInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCPropertyDeclInfo *\nclang_index_getObjCPropertyDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxIBOutletCollectionAttrInfo *\nclang_index_getIBOutletCollectionAttrInfo(const CXIdxAttrInfo *);\n\nCINDEX_LINKAGE const CXIdxCXXClassDeclInfo *\nclang_index_getCXXClassDeclInfo(const CXIdxDeclInfo *);\n\n/**\n * For retrieving a custom CXIdxClientContainer attached to a\n * container.\n */\nCINDEX_LINKAGE CXIdxClientContainer\nclang_index_getClientContainer(const CXIdxContainerInfo *);\n\n/**\n * For setting a custom CXIdxClientContainer attached to a\n * container.\n */\nCINDEX_LINKAGE void clang_index_setClientContainer(const CXIdxContainerInfo *,\n                                                   CXIdxClientContainer);\n\n/**\n * For retrieving a custom CXIdxClientEntity attached to an entity.\n */\nCINDEX_LINKAGE CXIdxClientEntity\nclang_index_getClientEntity(const CXIdxEntityInfo *);\n\n/**\n * For setting a custom CXIdxClientEntity attached to an entity.\n */\nCINDEX_LINKAGE void clang_index_setClientEntity(const CXIdxEntityInfo *,\n                                                CXIdxClientEntity);\n\n/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n */\ntypedef void *CXIndexAction;\n\n/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n *\n * \\param CIdx The index object with which the index action will be associated.\n */\nCINDEX_LINKAGE CXIndexAction clang_IndexAction_create(CXIndex CIdx);\n\n/**\n * Destroy the given index action.\n *\n * The index action must not be destroyed until all of the translation units\n * created within that index action have been destroyed.\n */\nCINDEX_LINKAGE void clang_IndexAction_dispose(CXIndexAction);\n\ntypedef enum {\n  /**\n   * Used to indicate that no special indexing options are needed.\n   */\n  CXIndexOpt_None = 0x0,\n\n  /**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */\n  CXIndexOpt_SuppressRedundantRefs = 0x1,\n\n  /**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */\n  CXIndexOpt_IndexFunctionLocalSymbols = 0x2,\n\n  /**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */\n  CXIndexOpt_IndexImplicitTemplateInstantiations = 0x4,\n\n  /**\n   * Suppress all compiler warnings when parsing for indexing.\n   */\n  CXIndexOpt_SuppressWarnings = 0x8,\n\n  /**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */\n  CXIndexOpt_SkipParsedBodiesInSession = 0x10\n\n} CXIndexOptFlags;\n\n/**\n * Index the given source file and the translation unit corresponding\n * to that file via callbacks implemented through #IndexerCallbacks.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the invoked callbacks.\n *\n * \\param index_callbacks Pointer to indexing callbacks that the client\n * implements.\n *\n * \\param index_callbacks_size Size of #IndexerCallbacks structure that gets\n * passed in index_callbacks.\n *\n * \\param index_options A bitmask of options that affects how indexing is\n * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.\n *\n * \\param[out] out_TU pointer to store a \\c CXTranslationUnit that can be\n * reused after indexing is finished. Set to \\c NULL if you do not require it.\n *\n * \\returns 0 on success or if there were errors from which the compiler could\n * recover.  If there is a failure from which there is no recovery, returns\n * a non-zero \\c CXErrorCode.\n *\n * The rest of the parameters are the same as #clang_parseTranslationUnit.\n */\nCINDEX_LINKAGE int clang_indexSourceFile(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options,\n    const char *source_filename, const char *const *command_line_args,\n    int num_command_line_args, struct CXUnsavedFile *unsaved_files,\n    unsigned num_unsaved_files, CXTranslationUnit *out_TU, unsigned TU_options);\n\n/**\n * Same as clang_indexSourceFile but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */\nCINDEX_LINKAGE int clang_indexSourceFileFullArgv(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options,\n    const char *source_filename, const char *const *command_line_args,\n    int num_command_line_args, struct CXUnsavedFile *unsaved_files,\n    unsigned num_unsaved_files, CXTranslationUnit *out_TU, unsigned TU_options);\n\n/**\n * Index the given translation unit via callbacks implemented through\n * #IndexerCallbacks.\n *\n * The order of callback invocations is not guaranteed to be the same as\n * when indexing a source file. The high level order will be:\n *\n *   -Preprocessor callbacks invocations\n *   -Declaration/reference callbacks invocations\n *   -Diagnostic callback invocations\n *\n * The parameters are the same as #clang_indexSourceFile.\n *\n * \\returns If there is a failure from which there is no recovery, returns\n * non-zero, otherwise returns 0.\n */\nCINDEX_LINKAGE int clang_indexTranslationUnit(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options, CXTranslationUnit);\n\n/**\n * Retrieve the CXIdxFile, file, line, column, and offset represented by\n * the given CXIdxLoc.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion and if it refers into a macro argument\n * retrieves the location of the argument.\n */\nCINDEX_LINKAGE void clang_indexLoc_getFileLocation(CXIdxLoc loc,\n                                                   CXIdxClientFile *indexFile,\n                                                   CXFile *file, unsigned *line,\n                                                   unsigned *column,\n                                                   unsigned *offset);\n\n/**\n * Retrieve the CXSourceLocation represented by the given CXIdxLoc.\n */\nCINDEX_LINKAGE\nCXSourceLocation clang_indexLoc_getCXSourceLocation(CXIdxLoc loc);\n\n/**\n * Visitor invoked for each field found by a traversal.\n *\n * This visitor function will be invoked for each field found by\n * \\c clang_Type_visitFields. Its first argument is the cursor being\n * visited, its second argument is the client data provided to\n * \\c clang_Type_visitFields.\n *\n * The visitor should return one of the \\c CXVisitorResult values\n * to direct \\c clang_Type_visitFields.\n */\ntypedef enum CXVisitorResult (*CXFieldVisitor)(CXCursor C,\n                                               CXClientData client_data);\n\n/**\n * Visit the fields of a particular type.\n *\n * This function visits all the direct fields of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited field. The traversal may be ended prematurely, if\n * the visitor returns \\c CXFieldVisit_Break.\n *\n * \\param T the record type whose field may be visited.\n *\n * \\param visitor the visitor function that will be invoked for each\n * field of \\p T.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXFieldVisit_Break.\n */\nCINDEX_LINKAGE unsigned clang_Type_visitFields(CXType T, CXFieldVisitor visitor,\n                                               CXClientData client_data);\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\nLLVM_CLANG_C_EXTERN_C_END\n\n#endif\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "content": "//===- unittests/libclang/LibclangTest.cpp --- libclang tests -------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang-c/Index.h\"\n#include \"clang-c/Rewrite.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"gtest/gtest.h\"\n#include \"TestUtils.h\"\n#include <fstream>\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#define DEBUG_TYPE \"libclang-test\"\n\nTEST(libclang, clang_parseTranslationUnit2_InvalidArgs) {\n  EXPECT_EQ(CXError_InvalidArguments,\n            clang_parseTranslationUnit2(nullptr, nullptr, nullptr, 0, nullptr,\n                                        0, 0, nullptr));\n}\n\nTEST(libclang, clang_createTranslationUnit_InvalidArgs) {\n  EXPECT_EQ(nullptr, clang_createTranslationUnit(nullptr, nullptr));\n}\n\nTEST(libclang, clang_createTranslationUnit2_InvalidArgs) {\n  EXPECT_EQ(CXError_InvalidArguments,\n            clang_createTranslationUnit2(nullptr, nullptr, nullptr));\n\n  CXTranslationUnit TU = reinterpret_cast<CXTranslationUnit>(1);\n  EXPECT_EQ(CXError_InvalidArguments,\n            clang_createTranslationUnit2(nullptr, nullptr, &TU));\n  EXPECT_EQ(nullptr, TU);\n}\n\nnamespace {\nstruct TestVFO {\n  const char *Contents;\n  CXVirtualFileOverlay VFO;\n\n  TestVFO(const char *Contents) : Contents(Contents) {\n    VFO = clang_VirtualFileOverlay_create(0);\n  }\n\n  void map(const char *VPath, const char *RPath) {\n    CXErrorCode Err = clang_VirtualFileOverlay_addFileMapping(VFO, VPath, RPath);\n    EXPECT_EQ(Err, CXError_Success);\n  }\n\n  void mapError(const char *VPath, const char *RPath, CXErrorCode ExpErr) {\n    CXErrorCode Err = clang_VirtualFileOverlay_addFileMapping(VFO, VPath, RPath);\n    EXPECT_EQ(Err, ExpErr);\n  }\n\n  ~TestVFO() {\n    if (Contents) {\n      char *BufPtr;\n      unsigned BufSize;\n      clang_VirtualFileOverlay_writeToBuffer(VFO, 0, &BufPtr, &BufSize);\n      std::string BufStr(BufPtr, BufSize);\n      EXPECT_STREQ(Contents, BufStr.c_str());\n      clang_free(BufPtr);\n    }\n    clang_VirtualFileOverlay_dispose(VFO);\n  }\n};\n}\n\nTEST(libclang, VirtualFileOverlay_Basic) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/virtual\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/path/virtual/foo.h\", \"/real/foo.h\");\n}\n\nTEST(libclang, VirtualFileOverlay_Unicode) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/\\\\u266B\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"\\\\u2602.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/\\\\u2602.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/path/\u266b/\u2602.h\", \"/real/\u2602.h\");\n}\n\nTEST(libclang, VirtualFileOverlay_InvalidArgs) {\n  TestVFO T(nullptr);\n  T.mapError(\"/path/./virtual/../foo.h\", \"/real/foo.h\",\n             CXError_InvalidArguments);\n}\n\nTEST(libclang, VirtualFileOverlay_RemapDirectories) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/another/dir\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo2.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo2.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    },\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/virtual/dir\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo1.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo1.h\\\"\\n\"\n      \"        },\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo3.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo3.h\\\"\\n\"\n      \"        },\\n\"\n      \"        {\\n\"\n      \"          'type': 'directory',\\n\"\n      \"          'name': \\\"in/subdir\\\",\\n\"\n      \"          'contents': [\\n\"\n      \"            {\\n\"\n      \"              'type': 'file',\\n\"\n      \"              'name': \\\"foo4.h\\\",\\n\"\n      \"              'external-contents': \\\"/real/foo4.h\\\"\\n\"\n      \"            }\\n\"\n      \"          ]\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/path/virtual/dir/foo1.h\", \"/real/foo1.h\");\n  T.map(\"/another/dir/foo2.h\", \"/real/foo2.h\");\n  T.map(\"/path/virtual/dir/foo3.h\", \"/real/foo3.h\");\n  T.map(\"/path/virtual/dir/in/subdir/foo4.h\", \"/real/foo4.h\");\n}\n\nTEST(libclang, VirtualFileOverlay_CaseInsensitive) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'case-sensitive': 'false',\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/virtual\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/path/virtual/foo.h\", \"/real/foo.h\");\n  clang_VirtualFileOverlay_setCaseSensitivity(T.VFO, false);\n}\n\nTEST(libclang, VirtualFileOverlay_SharedPrefix) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/foo\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"bar\\\",\\n\"\n      \"          'external-contents': \\\"/real/bar\\\"\\n\"\n      \"        },\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"bar.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/bar.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    },\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/foobar\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"baz.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/baz.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    },\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foobarbaz.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foobarbaz.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/path/foo/bar.h\", \"/real/bar.h\");\n  T.map(\"/path/foo/bar\", \"/real/bar\");\n  T.map(\"/path/foobar/baz.h\", \"/real/baz.h\");\n  T.map(\"/path/foobarbaz.h\", \"/real/foobarbaz.h\");\n}\n\nTEST(libclang, VirtualFileOverlay_AdjacentDirectory) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/dir1\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo.h\\\"\\n\"\n      \"        },\\n\"\n      \"        {\\n\"\n      \"          'type': 'directory',\\n\"\n      \"          'name': \\\"subdir\\\",\\n\"\n      \"          'contents': [\\n\"\n      \"            {\\n\"\n      \"              'type': 'file',\\n\"\n      \"              'name': \\\"bar.h\\\",\\n\"\n      \"              'external-contents': \\\"/real/bar.h\\\"\\n\"\n      \"            }\\n\"\n      \"          ]\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    },\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/path/dir2\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"baz.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/baz.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/path/dir1/foo.h\", \"/real/foo.h\");\n  T.map(\"/path/dir1/subdir/bar.h\", \"/real/bar.h\");\n  T.map(\"/path/dir2/baz.h\", \"/real/baz.h\");\n}\n\nTEST(libclang, VirtualFileOverlay_TopLevel) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"    {\\n\"\n      \"      'type': 'directory',\\n\"\n      \"      'name': \\\"/\\\",\\n\"\n      \"      'contents': [\\n\"\n      \"        {\\n\"\n      \"          'type': 'file',\\n\"\n      \"          'name': \\\"foo.h\\\",\\n\"\n      \"          'external-contents': \\\"/real/foo.h\\\"\\n\"\n      \"        }\\n\"\n      \"      ]\\n\"\n      \"    }\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n  T.map(\"/foo.h\", \"/real/foo.h\");\n}\n\nTEST(libclang, VirtualFileOverlay_Empty) {\n  const char *contents =\n      \"{\\n\"\n      \"  'version': 0,\\n\"\n      \"  'roots': [\\n\"\n      \"  ]\\n\"\n      \"}\\n\";\n  TestVFO T(contents);\n}\n\nTEST(libclang, ModuleMapDescriptor) {\n  const char *Contents =\n    \"framework module TestFrame {\\n\"\n    \"  umbrella header \\\"TestFrame.h\\\"\\n\"\n    \"\\n\"\n    \"  export *\\n\"\n    \"  module * { export * }\\n\"\n    \"}\\n\";\n\n  CXModuleMapDescriptor MMD = clang_ModuleMapDescriptor_create(0);\n\n  clang_ModuleMapDescriptor_setFrameworkModuleName(MMD, \"TestFrame\");\n  clang_ModuleMapDescriptor_setUmbrellaHeader(MMD, \"TestFrame.h\");\n\n  char *BufPtr;\n  unsigned BufSize;\n  clang_ModuleMapDescriptor_writeToBuffer(MMD, 0, &BufPtr, &BufSize);\n  std::string BufStr(BufPtr, BufSize);\n  EXPECT_STREQ(Contents, BufStr.c_str());\n  clang_free(BufPtr);\n  clang_ModuleMapDescriptor_dispose(MMD);\n}\n\nTEST_F(LibclangParseTest, AllSkippedRanges) {\n  std::string Header = \"header.h\", Main = \"main.cpp\";\n  WriteFile(Header,\n    \"#ifdef MANGOS\\n\"\n    \"printf(\\\"mmm\\\");\\n\"\n    \"#endif\");\n  WriteFile(Main,\n    \"#include \\\"header.h\\\"\\n\"\n    \"#ifdef KIWIS\\n\"\n    \"printf(\\\"mmm!!\\\");\\n\"\n    \"#endif\");\n\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0,\n                                       nullptr, 0, TUFlags);\n\n  CXSourceRangeList *Ranges = clang_getAllSkippedRanges(ClangTU);\n  EXPECT_EQ(2U, Ranges->count);\n  \n  CXSourceLocation cxl;\n  unsigned line;\n  cxl = clang_getRangeStart(Ranges->ranges[0]);\n  clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n  EXPECT_EQ(1U, line);\n  cxl = clang_getRangeEnd(Ranges->ranges[0]);\n  clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n  EXPECT_EQ(3U, line);\n\n  cxl = clang_getRangeStart(Ranges->ranges[1]);\n  clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n  EXPECT_EQ(2U, line);\n  cxl = clang_getRangeEnd(Ranges->ranges[1]);\n  clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n  EXPECT_EQ(4U, line);\n\n  clang_disposeSourceRangeList(Ranges);\n}\n\nTEST_F(LibclangParseTest, EvaluateChildExpression) {\n  std::string Main = \"main.m\";\n  WriteFile(Main, \"#define kFOO @\\\"foo\\\"\\n\"\n                  \"void foobar(void) {\\n\"\n                  \" {kFOO;}\\n\"\n                  \"}\\n\");\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0, nullptr,\n                                       0, TUFlags);\n\n  CXCursor C = clang_getTranslationUnitCursor(ClangTU);\n  clang_visitChildren(\n      C,\n      [](CXCursor cursor, CXCursor parent,\n         CXClientData client_data) -> CXChildVisitResult {\n        if (clang_getCursorKind(cursor) == CXCursor_FunctionDecl) {\n          int numberedStmt = 0;\n          clang_visitChildren(\n              cursor,\n              [](CXCursor cursor, CXCursor parent,\n                 CXClientData client_data) -> CXChildVisitResult {\n                int &numberedStmt = *((int *)client_data);\n                if (clang_getCursorKind(cursor) == CXCursor_CompoundStmt) {\n                  if (numberedStmt) {\n                    CXEvalResult RE = clang_Cursor_Evaluate(cursor);\n                    EXPECT_NE(RE, nullptr);\n                    EXPECT_EQ(clang_EvalResult_getKind(RE),\n                              CXEval_ObjCStrLiteral);\n                    clang_EvalResult_dispose(RE);\n                    return CXChildVisit_Break;\n                  }\n                  numberedStmt++;\n                }\n                return CXChildVisit_Recurse;\n              },\n              &numberedStmt);\n          EXPECT_EQ(numberedStmt, 1);\n        }\n        return CXChildVisit_Continue;\n      },\n      nullptr);\n}\n\nclass LibclangReparseTest : public LibclangParseTest {\npublic:\n  void DisplayDiagnostics() {\n    unsigned NumDiagnostics = clang_getNumDiagnostics(ClangTU);\n    for (unsigned i = 0; i < NumDiagnostics; ++i) {\n      auto Diag = clang_getDiagnostic(ClangTU, i);\n      LLVM_DEBUG(llvm::dbgs()\n                 << clang_getCString(clang_formatDiagnostic(\n                        Diag, clang_defaultDiagnosticDisplayOptions()))\n                 << \"\\n\");\n      clang_disposeDiagnostic(Diag);\n    }\n  }\n  bool ReparseTU(unsigned num_unsaved_files, CXUnsavedFile* unsaved_files) {\n    if (clang_reparseTranslationUnit(ClangTU, num_unsaved_files, unsaved_files,\n                                     clang_defaultReparseOptions(ClangTU))) {\n      LLVM_DEBUG(llvm::dbgs() << \"Reparse failed\\n\");\n      return false;\n    }\n    DisplayDiagnostics();\n    return true;\n  }\n};\n\nTEST_F(LibclangReparseTest, FileName) {\n  std::string CppName = \"main.cpp\";\n  WriteFile(CppName, \"int main() {}\");\n  ClangTU = clang_parseTranslationUnit(Index, CppName.c_str(), nullptr, 0,\n                                       nullptr, 0, TUFlags);\n  CXFile cxf = clang_getFile(ClangTU, CppName.c_str());\n\n  CXString cxname = clang_getFileName(cxf);\n  ASSERT_STREQ(clang_getCString(cxname), CppName.c_str());\n  clang_disposeString(cxname);\n\n  cxname = clang_File_tryGetRealPathName(cxf);\n  ASSERT_TRUE(llvm::StringRef(clang_getCString(cxname)).endswith(\"main.cpp\"));\n  clang_disposeString(cxname);\n}\n\nTEST_F(LibclangReparseTest, Reparse) {\n  const char *HeaderTop = \"#ifndef H\\n#define H\\nstruct Foo { int bar;\";\n  const char *HeaderBottom = \"\\n};\\n#endif\\n\";\n  const char *CppFile = \"#include \\\"HeaderFile.h\\\"\\nint main() {\"\n                         \" Foo foo; foo.bar = 7; foo.baz = 8; }\\n\";\n  std::string HeaderName = \"HeaderFile.h\";\n  std::string CppName = \"CppFile.cpp\";\n  WriteFile(CppName, CppFile);\n  WriteFile(HeaderName, std::string(HeaderTop) + HeaderBottom);\n\n  ClangTU = clang_parseTranslationUnit(Index, CppName.c_str(), nullptr, 0,\n                                       nullptr, 0, TUFlags);\n  EXPECT_EQ(1U, clang_getNumDiagnostics(ClangTU));\n  DisplayDiagnostics();\n\n  // Immedaitely reparse.\n  ASSERT_TRUE(ReparseTU(0, nullptr /* No unsaved files. */));\n  EXPECT_EQ(1U, clang_getNumDiagnostics(ClangTU));\n\n  std::string NewHeaderContents =\n      std::string(HeaderTop) + \"int baz;\" + HeaderBottom;\n  WriteFile(HeaderName, NewHeaderContents);\n\n  // Reparse after fix.\n  ASSERT_TRUE(ReparseTU(0, nullptr /* No unsaved files. */));\n  EXPECT_EQ(0U, clang_getNumDiagnostics(ClangTU));\n}\n\nTEST_F(LibclangReparseTest, ReparseWithModule) {\n  const char *HeaderTop = \"#ifndef H\\n#define H\\nstruct Foo { int bar;\";\n  const char *HeaderBottom = \"\\n};\\n#endif\\n\";\n  const char *MFile = \"#include \\\"HeaderFile.h\\\"\\nint main() {\"\n                         \" struct Foo foo; foo.bar = 7; foo.baz = 8; }\\n\";\n  const char *ModFile = \"module A { header \\\"HeaderFile.h\\\" }\\n\";\n  std::string HeaderName = \"HeaderFile.h\";\n  std::string MName = \"MFile.m\";\n  std::string ModName = \"module.modulemap\";\n  WriteFile(MName, MFile);\n  WriteFile(HeaderName, std::string(HeaderTop) + HeaderBottom);\n  WriteFile(ModName, ModFile);\n\n  std::string ModulesCache = std::string(\"-fmodules-cache-path=\") + TestDir;\n  const char *Args[] = { \"-fmodules\", ModulesCache.c_str(),\n                         \"-I\", TestDir.c_str() };\n  int NumArgs = sizeof(Args) / sizeof(Args[0]);\n  ClangTU = clang_parseTranslationUnit(Index, MName.c_str(), Args, NumArgs,\n                                       nullptr, 0, TUFlags);\n  EXPECT_EQ(1U, clang_getNumDiagnostics(ClangTU));\n  DisplayDiagnostics();\n\n  // Immedaitely reparse.\n  ASSERT_TRUE(ReparseTU(0, nullptr /* No unsaved files. */));\n  EXPECT_EQ(1U, clang_getNumDiagnostics(ClangTU));\n\n  std::string NewHeaderContents =\n      std::string(HeaderTop) + \"int baz;\" + HeaderBottom;\n  WriteFile(HeaderName, NewHeaderContents);\n\n  // Reparse after fix.\n  ASSERT_TRUE(ReparseTU(0, nullptr /* No unsaved files. */));\n  EXPECT_EQ(0U, clang_getNumDiagnostics(ClangTU));\n}\n\nTEST_F(LibclangReparseTest, clang_parseTranslationUnit2FullArgv) {\n  // Provide a fake GCC 99.9.9 standard library that always overrides any local\n  // GCC installation.\n  std::string EmptyFiles[] = {\"lib/gcc/arm-linux-gnueabi/99.9.9/crtbegin.o\",\n                              \"include/arm-linux-gnueabi/.keep\",\n                              \"include/c++/99.9.9/vector\"};\n\n  for (auto &Name : EmptyFiles)\n    WriteFile(Name, \"\\n\");\n\n  std::string Filename = \"test.cc\";\n  WriteFile(Filename, \"#include <vector>\\n\");\n\n  std::string Clang = \"bin/clang\";\n  WriteFile(Clang, \"\");\n\n  const char *Argv[] = {Clang.c_str(), \"-target\", \"arm-linux-gnueabi\",\n                        \"-stdlib=libstdc++\", \"--gcc-toolchain=\"};\n\n  EXPECT_EQ(CXError_Success,\n            clang_parseTranslationUnit2FullArgv(Index, Filename.c_str(), Argv,\n                                                sizeof(Argv) / sizeof(Argv[0]),\n                                                nullptr, 0, TUFlags, &ClangTU));\n  EXPECT_EQ(0U, clang_getNumDiagnostics(ClangTU));\n  DisplayDiagnostics();\n}\n\nclass LibclangPrintingPolicyTest : public LibclangParseTest {\npublic:\n  CXPrintingPolicy Policy = nullptr;\n\n  void SetUp() override {\n    LibclangParseTest::SetUp();\n    std::string File = \"file.cpp\";\n    WriteFile(File, \"int i;\\n\");\n    ClangTU = clang_parseTranslationUnit(Index, File.c_str(), nullptr, 0,\n                                         nullptr, 0, TUFlags);\n    CXCursor TUCursor = clang_getTranslationUnitCursor(ClangTU);\n    Policy = clang_getCursorPrintingPolicy(TUCursor);\n  }\n  void TearDown() override {\n    clang_PrintingPolicy_dispose(Policy);\n    LibclangParseTest::TearDown();\n  }\n};\n\nTEST_F(LibclangPrintingPolicyTest, SetAndGetProperties) {\n  for (unsigned Value = 0; Value < 2; ++Value) {\n    for (int I = 0; I < CXPrintingPolicy_LastProperty; ++I) {\n      auto Property = static_cast<enum CXPrintingPolicyProperty>(I);\n\n      clang_PrintingPolicy_setProperty(Policy, Property, Value);\n      EXPECT_EQ(Value, clang_PrintingPolicy_getProperty(Policy, Property));\n    }\n  }\n}\n\nTEST_F(LibclangReparseTest, PreprocessorSkippedRanges) {\n  std::string Header = \"header.h\", Main = \"main.cpp\";\n  WriteFile(Header,\n    \"#ifdef MANGOS\\n\"\n    \"printf(\\\"mmm\\\");\\n\"\n    \"#endif\");\n  WriteFile(Main,\n    \"#include \\\"header.h\\\"\\n\"\n    \"#ifdef GUAVA\\n\"\n    \"#endif\\n\"\n    \"#ifdef KIWIS\\n\"\n    \"printf(\\\"mmm!!\\\");\\n\"\n    \"#endif\");\n\n  for (int i = 0; i != 3; ++i) {\n    unsigned flags = TUFlags | CXTranslationUnit_PrecompiledPreamble;\n    if (i == 2)\n      flags |= CXTranslationUnit_CreatePreambleOnFirstParse;\n\n    if (i != 0)\n       clang_disposeTranslationUnit(ClangTU);  // dispose from previous iter\n\n    // parse once\n    ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0,\n                                         nullptr, 0, flags);\n    if (i != 0) {\n      // reparse\n      ASSERT_TRUE(ReparseTU(0, nullptr /* No unsaved files. */));\n    }\n\n    // Check all ranges are there\n    CXSourceRangeList *Ranges = clang_getAllSkippedRanges(ClangTU);\n    EXPECT_EQ(3U, Ranges->count);\n\n    CXSourceLocation cxl;\n    unsigned line;\n    cxl = clang_getRangeStart(Ranges->ranges[0]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(1U, line);\n    cxl = clang_getRangeEnd(Ranges->ranges[0]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(3U, line);\n\n    cxl = clang_getRangeStart(Ranges->ranges[1]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(2U, line);\n    cxl = clang_getRangeEnd(Ranges->ranges[1]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(3U, line);\n\n    cxl = clang_getRangeStart(Ranges->ranges[2]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(4U, line);\n    cxl = clang_getRangeEnd(Ranges->ranges[2]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(6U, line);\n\n    clang_disposeSourceRangeList(Ranges);\n\n    // Check obtaining ranges by each file works\n    CXFile cxf = clang_getFile(ClangTU, Header.c_str());\n    Ranges = clang_getSkippedRanges(ClangTU, cxf);\n    EXPECT_EQ(1U, Ranges->count);\n    cxl = clang_getRangeStart(Ranges->ranges[0]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(1U, line);\n    clang_disposeSourceRangeList(Ranges);\n\n    cxf = clang_getFile(ClangTU, Main.c_str());\n    Ranges = clang_getSkippedRanges(ClangTU, cxf);\n    EXPECT_EQ(2U, Ranges->count);\n    cxl = clang_getRangeStart(Ranges->ranges[0]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(2U, line);\n    cxl = clang_getRangeStart(Ranges->ranges[1]);\n    clang_getSpellingLocation(cxl, nullptr, &line, nullptr, nullptr);\n    EXPECT_EQ(4U, line);\n    clang_disposeSourceRangeList(Ranges);\n  }\n}\n\nclass LibclangSerializationTest : public LibclangParseTest {\npublic:\n  bool SaveAndLoadTU(const std::string &Filename) {\n    unsigned options = clang_defaultSaveOptions(ClangTU);\n    if (clang_saveTranslationUnit(ClangTU, Filename.c_str(), options) !=\n        CXSaveError_None) {\n      LLVM_DEBUG(llvm::dbgs() << \"Saving failed\\n\");\n      return false;\n    }\n\n    clang_disposeTranslationUnit(ClangTU);\n\n    ClangTU = clang_createTranslationUnit(Index, Filename.c_str());\n\n    if (!ClangTU) {\n      LLVM_DEBUG(llvm::dbgs() << \"Loading failed\\n\");\n      return false;\n    }\n\n    return true;\n  }\n};\n\nTEST_F(LibclangSerializationTest, TokenKindsAreCorrectAfterLoading) {\n  // Ensure that \"class\" is recognized as a keyword token after serializing\n  // and reloading the AST, as it is not a keyword for the default LangOptions.\n  std::string HeaderName = \"test.h\";\n  WriteFile(HeaderName, \"enum class Something {};\");\n\n  const char *Argv[] = {\"-xc++-header\", \"-std=c++11\"};\n\n  ClangTU = clang_parseTranslationUnit(Index, HeaderName.c_str(), Argv,\n                                       sizeof(Argv) / sizeof(Argv[0]), nullptr,\n                                       0, TUFlags);\n\n  auto CheckTokenKinds = [=]() {\n    CXSourceRange Range =\n        clang_getCursorExtent(clang_getTranslationUnitCursor(ClangTU));\n\n    CXToken *Tokens;\n    unsigned int NumTokens;\n    clang_tokenize(ClangTU, Range, &Tokens, &NumTokens);\n\n    ASSERT_EQ(6u, NumTokens);\n    EXPECT_EQ(CXToken_Keyword, clang_getTokenKind(Tokens[0]));\n    EXPECT_EQ(CXToken_Keyword, clang_getTokenKind(Tokens[1]));\n    EXPECT_EQ(CXToken_Identifier, clang_getTokenKind(Tokens[2]));\n    EXPECT_EQ(CXToken_Punctuation, clang_getTokenKind(Tokens[3]));\n    EXPECT_EQ(CXToken_Punctuation, clang_getTokenKind(Tokens[4]));\n    EXPECT_EQ(CXToken_Punctuation, clang_getTokenKind(Tokens[5]));\n\n    clang_disposeTokens(ClangTU, Tokens, NumTokens);\n  };\n\n  CheckTokenKinds();\n\n  std::string ASTName = \"test.ast\";\n  WriteFile(ASTName, \"\");\n\n  ASSERT_TRUE(SaveAndLoadTU(ASTName));\n\n  CheckTokenKinds();\n}\n\nTEST_F(LibclangParseTest, clang_getVarDeclInitializer) {\n  std::string Main = \"main.cpp\";\n  WriteFile(Main, \"int foo() { return 5; }; const int a = foo();\");\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0, nullptr,\n                                       0, TUFlags);\n\n  CXCursor C = clang_getTranslationUnitCursor(ClangTU);\n  clang_visitChildren(\n      C,\n      [](CXCursor cursor, CXCursor parent,\n         CXClientData client_data) -> CXChildVisitResult {\n        if (clang_getCursorKind(cursor) == CXCursor_VarDecl) {\n          const CXCursor Initializer = clang_Cursor_getVarDeclInitializer(cursor);\n          EXPECT_FALSE(clang_Cursor_isNull(Initializer));\n          CXString Spelling = clang_getCursorSpelling(Initializer);\n          const char* const SpellingCSstr = clang_getCString(Spelling);\n          EXPECT_TRUE(SpellingCSstr);\n          EXPECT_EQ(std::string(SpellingCSstr), std::string(\"foo\"));\n          clang_disposeString(Spelling);\n          return CXChildVisit_Break;\n        }\n        return CXChildVisit_Continue;\n      },\n      nullptr);\n}\n\nTEST_F(LibclangParseTest, clang_hasVarDeclGlobalStorageFalse) {\n  std::string Main = \"main.cpp\";\n  WriteFile(Main, \"void foo() { int a; }\");\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0, nullptr,\n                                       0, TUFlags);\n\n  CXCursor C = clang_getTranslationUnitCursor(ClangTU);\n  clang_visitChildren(\n      C,\n      [](CXCursor cursor, CXCursor parent,\n         CXClientData client_data) -> CXChildVisitResult {\n        if (clang_getCursorKind(cursor) == CXCursor_VarDecl) {\n          EXPECT_FALSE(clang_Cursor_hasVarDeclGlobalStorage(cursor));\n          return CXChildVisit_Break;\n        }\n        return CXChildVisit_Continue;\n      },\n      nullptr);\n}\n\nTEST_F(LibclangParseTest, clang_Cursor_hasVarDeclGlobalStorageTrue) {\n  std::string Main = \"main.cpp\";\n  WriteFile(Main, \"int a;\");\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0, nullptr,\n                                       0, TUFlags);\n\n  CXCursor C = clang_getTranslationUnitCursor(ClangTU);\n  clang_visitChildren(\n      C,\n      [](CXCursor cursor, CXCursor parent,\n         CXClientData client_data) -> CXChildVisitResult {\n        if (clang_getCursorKind(cursor) == CXCursor_VarDecl) {\n          EXPECT_TRUE(clang_Cursor_hasVarDeclGlobalStorage(cursor));\n          return CXChildVisit_Break;\n        }\n        return CXChildVisit_Continue;\n      },\n      nullptr);\n}\n\nTEST_F(LibclangParseTest, clang_Cursor_hasVarDeclExternalStorageFalse) {\n  std::string Main = \"main.cpp\";\n  WriteFile(Main, \"int a;\");\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0, nullptr,\n                                       0, TUFlags);\n\n  CXCursor C = clang_getTranslationUnitCursor(ClangTU);\n  clang_visitChildren(\n      C,\n      [](CXCursor cursor, CXCursor parent,\n         CXClientData client_data) -> CXChildVisitResult {\n        if (clang_getCursorKind(cursor) == CXCursor_VarDecl) {\n          EXPECT_FALSE(clang_Cursor_hasVarDeclExternalStorage(cursor));\n          return CXChildVisit_Break;\n        }\n        return CXChildVisit_Continue;\n      },\n      nullptr);\n}\n\nTEST_F(LibclangParseTest, clang_Cursor_hasVarDeclExternalStorageTrue) {\n  std::string Main = \"main.cpp\";\n  WriteFile(Main, \"extern int a;\");\n  ClangTU = clang_parseTranslationUnit(Index, Main.c_str(), nullptr, 0, nullptr,\n                                       0, TUFlags);\n\n  CXCursor C = clang_getTranslationUnitCursor(ClangTU);\n  clang_visitChildren(\n      C,\n      [](CXCursor cursor, CXCursor parent,\n         CXClientData client_data) -> CXChildVisitResult {\n        if (clang_getCursorKind(cursor) == CXCursor_VarDecl) {\n          EXPECT_TRUE(clang_Cursor_hasVarDeclExternalStorage(cursor));\n          return CXChildVisit_Break;\n        }\n        return CXChildVisit_Continue;\n      },\n      nullptr);\n}\nclass LibclangRewriteTest : public LibclangParseTest {\npublic:\n  CXRewriter Rew = nullptr;\n  std::string Filename;\n  CXFile File = nullptr;\n\n  void SetUp() override {\n    LibclangParseTest::SetUp();\n    Filename = \"file.cpp\";\n    WriteFile(Filename, \"int main() { return 0; }\");\n    ClangTU = clang_parseTranslationUnit(Index, Filename.c_str(), nullptr, 0,\n                                         nullptr, 0, TUFlags);\n    Rew = clang_CXRewriter_create(ClangTU);\n    File = clang_getFile(ClangTU, Filename.c_str());\n  }\n  void TearDown() override {\n    clang_CXRewriter_dispose(Rew);\n    LibclangParseTest::TearDown();\n  }\n};\n\nstatic std::string getFileContent(const std::string& Filename) {\n  std::ifstream RewrittenFile(Filename);\n  std::string RewrittenFileContent;\n  std::string Line;\n  while (std::getline(RewrittenFile, Line)) {\n    if (RewrittenFileContent.empty())\n      RewrittenFileContent = Line;\n    else {\n      RewrittenFileContent += \"\\n\" + Line;\n    }\n  }\n  return RewrittenFileContent;\n}\n\nTEST_F(LibclangRewriteTest, RewriteReplace) {\n  CXSourceLocation B = clang_getLocation(ClangTU, File, 1, 5);\n  CXSourceLocation E = clang_getLocation(ClangTU, File, 1, 9);\n  CXSourceRange Rng\t= clang_getRange(B, E);\n\n  clang_CXRewriter_replaceText(Rew, Rng, \"MAIN\");\n\n  ASSERT_EQ(clang_CXRewriter_overwriteChangedFiles(Rew), 0);\n  EXPECT_EQ(getFileContent(Filename), \"int MAIN() { return 0; }\");\n}\n\nTEST_F(LibclangRewriteTest, RewriteReplaceShorter) {\n  CXSourceLocation B = clang_getLocation(ClangTU, File, 1, 5);\n  CXSourceLocation E = clang_getLocation(ClangTU, File, 1, 9);\n  CXSourceRange Rng\t= clang_getRange(B, E);\n\n  clang_CXRewriter_replaceText(Rew, Rng, \"foo\");\n\n  ASSERT_EQ(clang_CXRewriter_overwriteChangedFiles(Rew), 0);\n  EXPECT_EQ(getFileContent(Filename), \"int foo() { return 0; }\");\n}\n\nTEST_F(LibclangRewriteTest, RewriteReplaceLonger) {\n  CXSourceLocation B = clang_getLocation(ClangTU, File, 1, 5);\n  CXSourceLocation E = clang_getLocation(ClangTU, File, 1, 9);\n  CXSourceRange Rng\t= clang_getRange(B, E);\n\n  clang_CXRewriter_replaceText(Rew, Rng, \"patatino\");\n\n  ASSERT_EQ(clang_CXRewriter_overwriteChangedFiles(Rew), 0);\n  EXPECT_EQ(getFileContent(Filename), \"int patatino() { return 0; }\");\n}\n\nTEST_F(LibclangRewriteTest, RewriteInsert) {\n  CXSourceLocation Loc = clang_getLocation(ClangTU, File, 1, 5);\n\n  clang_CXRewriter_insertTextBefore(Rew, Loc, \"ro\");\n\n  ASSERT_EQ(clang_CXRewriter_overwriteChangedFiles(Rew), 0);\n  EXPECT_EQ(getFileContent(Filename), \"int romain() { return 0; }\");\n}\n\nTEST_F(LibclangRewriteTest, RewriteRemove) {\n  CXSourceLocation B = clang_getLocation(ClangTU, File, 1, 5);\n  CXSourceLocation E = clang_getLocation(ClangTU, File, 1, 9);\n  CXSourceRange Rng\t= clang_getRange(B, E);\n\n  clang_CXRewriter_removeText(Rew, Rng);\n\n  ASSERT_EQ(clang_CXRewriter_overwriteChangedFiles(Rew), 0);\n  EXPECT_EQ(getFileContent(Filename), \"int () { return 0; }\");\n}\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/TestUtils.h", "content": "//===- unittests/libclang/TestUtils.h -------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TEST_TESTUTILS_H\n#define LLVM_CLANG_TEST_TESTUTILS_H\n\n#include \"clang-c/Index.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include \"gtest/gtest.h\"\n\nclass LibclangParseTest : public ::testing::Test {\n  std::set<std::string> Files;\n  typedef std::unique_ptr<std::string> fixed_addr_string;\n  std::map<fixed_addr_string, fixed_addr_string> UnsavedFileContents;\npublic:\n  std::string TestDir;\n  CXIndex Index;\n  CXTranslationUnit ClangTU;\n  unsigned TUFlags;\n  std::vector<CXUnsavedFile> UnsavedFiles;\n\n  void SetUp() override {\n    llvm::SmallString<256> Dir;\n    ASSERT_FALSE(llvm::sys::fs::createUniqueDirectory(\"libclang-test\", Dir));\n    TestDir = std::string(Dir.str());\n    TUFlags = CXTranslationUnit_DetailedPreprocessingRecord |\n      clang_defaultEditingTranslationUnitOptions();\n    Index = clang_createIndex(0, 0);\n    ClangTU = nullptr;\n  }\n  void TearDown() override {\n    clang_disposeTranslationUnit(ClangTU);\n    clang_disposeIndex(Index);\n    for (const std::string &Path : Files)\n      llvm::sys::fs::remove(Path);\n    llvm::sys::fs::remove(TestDir);\n  }\n  void WriteFile(std::string &Filename, const std::string &Contents) {\n    if (!llvm::sys::path::is_absolute(Filename)) {\n      llvm::SmallString<256> Path(TestDir);\n      llvm::sys::path::append(Path, Filename);\n      Filename = std::string(Path.str());\n      Files.insert(Filename);\n    }\n    llvm::sys::fs::create_directories(llvm::sys::path::parent_path(Filename));\n    std::ofstream OS(Filename);\n    OS << Contents;\n    assert(OS.good());\n  }\n  void MapUnsavedFile(std::string Filename, const std::string &Contents) {\n    if (!llvm::sys::path::is_absolute(Filename)) {\n      llvm::SmallString<256> Path(TestDir);\n      llvm::sys::path::append(Path, Filename);\n      Filename = std::string(Path.str());\n    }\n    auto it = UnsavedFileContents.insert(std::make_pair(\n        fixed_addr_string(new std::string(Filename)),\n        fixed_addr_string(new std::string(Contents))));\n    UnsavedFiles.push_back({\n        it.first->first->c_str(),   // filename\n        it.first->second->c_str(),  // contents\n        it.first->second->size()    // length\n    });\n  }\n  template<typename F>\n  void Traverse(const F &TraversalFunctor) {\n    CXCursor TuCursor = clang_getTranslationUnitCursor(ClangTU);\n    std::reference_wrapper<const F> FunctorRef = std::cref(TraversalFunctor);\n    clang_visitChildren(TuCursor,\n        &TraverseStateless<std::reference_wrapper<const F>>,\n        &FunctorRef);\n  }\nprivate:\n  template<typename TState>\n  static CXChildVisitResult TraverseStateless(CXCursor cx, CXCursor parent,\n      CXClientData data) {\n    TState *State = static_cast<TState*>(data);\n    return State->get()(cx, parent);\n  }\n};\n\n#endif // LLVM_CLANG_TEST_TESTUTILS_H"}}, "reports": [{"events": [{"location": {"col": 8, "file": 1, "line": 101}, "message": "destructor '~CXUnsavedFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "4ec33ef96dc09a1f16fc46b8023b7eb4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 101}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "55631633bb717edbe7ca8a240f5a3bc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 101}, "message": "move constructor 'CXUnsavedFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "7e6a2b0c6d4d661ffe904e9a2fb7e523", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 456}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "13ebd9ffb248a80925706deabf0fdadb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 456}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "8011917724cded33cf7ced5a29e9d749", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 25}, "message": "destructor '~libclang_clang_parseTranslationUnit2_InvalidArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "5c4b0d9057e59afb4e099c9b97905b9d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 31}, "message": "destructor '~libclang_clang_createTranslationUnit_InvalidArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "a509ab205e23be438f9d0fe716197eb2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 35}, "message": "destructor '~libclang_clang_createTranslationUnit2_InvalidArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "9ae1ecfb7198072031d20f2839e757e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 78}, "message": "destructor '~libclang_VirtualFileOverlay_Basic_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "3d5cfb2ea6a544c227df7c4cdeb098bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 100}, "message": "destructor '~libclang_VirtualFileOverlay_Unicode_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "8fcb27b7e9c20aeecb26117fa9f88e0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 122}, "message": "destructor '~libclang_VirtualFileOverlay_InvalidArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "c3e879aa0e6b13be2da79525981ae65e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 128}, "message": "destructor '~libclang_VirtualFileOverlay_RemapDirectories_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "fb45c235ddaf6e9056cb98d4ea9f1614", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 180}, "message": "destructor '~libclang_VirtualFileOverlay_CaseInsensitive_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "2d1125409d1b638a48734043aa2cd3e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 204}, "message": "destructor '~libclang_VirtualFileOverlay_SharedPrefix_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "d7314af8e1c145065add23b4cc235542", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 256}, "message": "destructor '~libclang_VirtualFileOverlay_AdjacentDirectory_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "5b64bf219c35cd8cd228dfe244135ba7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 302}, "message": "destructor '~libclang_VirtualFileOverlay_TopLevel_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "43fbcb021fc9f18fd98aa3ed7b1ba0d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 324}, "message": "destructor '~libclang_VirtualFileOverlay_Empty_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "4948764099c49c62ed7ea73c36b6c69a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 3, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 334}, "message": "destructor '~libclang_ModuleMapDescriptor_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "1b9c567c57d91f04c984e1b1dde3ebc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 357}, "message": "destructor '~LibclangParseTest_AllSkippedRanges_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "051f0e58ef340f71d5076c397cad387d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 394}, "message": "destructor '~LibclangParseTest_EvaluateChildExpression_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "00b21c0cd61b99b72e3a3dadced1172b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 406}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "82fba415b37e23bf39d01e61cd9e5759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 412}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "36e9d9fe98063aa4e0979fdd6eac2c5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 436}, "message": "destructor '~LibclangReparseTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "2d1c0e1fbfe4618a61ca59ac2fe3e996", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 460}, "message": "destructor '~LibclangReparseTest_FileName_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "98b44f6f901b58ca9fa1a9b8db4fb0c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 476}, "message": "destructor '~LibclangReparseTest_Reparse_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "58b69aae7c5667364db1f19a46069858", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 504}, "message": "destructor '~LibclangReparseTest_ReparseWithModule_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "7bccbce523ca74e45a59ee4840f946b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 539}, "message": "destructor '~LibclangReparseTest_clang_parseTranslationUnit2FullArgv_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "71afd2a6e89537a321af2c1aa8e5b625", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 566}, "message": "destructor '~LibclangPrintingPolicyTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "90549f19bd8f9e04b4144589c3353082", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 585}, "message": "destructor '~LibclangPrintingPolicyTest_SetAndGetProperties_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "00eec66c7f2a6f7f502a352c7dfa4993", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 596}, "message": "destructor '~LibclangReparseTest_PreprocessorSkippedRanges_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "35c00b1be34e03c6f599e12a7cd5eb64", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 677}, "message": "destructor '~LibclangSerializationTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "a84ce5438aa4ad7bad951eb4917d26dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 700}, "message": "destructor '~LibclangSerializationTest_TokenKindsAreCorrectAfterLoading_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "a93bf2e2ceaac1d8fa32fad46934931a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 2, "line": 712}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "be96fa2c430805d5085b405e792bb066", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 2, "line": 712}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "d48cff2bfc6607238bb1a75ac382c543", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 741}, "message": "destructor '~LibclangParseTest_clang_getVarDeclInitializer_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "468cc6510e0bb834e4bef4f55a71b03e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 750}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "82fba415b37e23bf39d01e61cd9e5759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 767}, "message": "destructor '~LibclangParseTest_clang_hasVarDeclGlobalStorageFalse_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "f9582a612bbd4b78602d75c264517c03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 776}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "82fba415b37e23bf39d01e61cd9e5759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 787}, "message": "destructor '~LibclangParseTest_clang_Cursor_hasVarDeclGlobalStorageTrue_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "19fddf17e3c27ce3108bc7e0e07604d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 796}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "82fba415b37e23bf39d01e61cd9e5759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 807}, "message": "destructor '~LibclangParseTest_clang_Cursor_hasVarDeclExternalStorageFalse_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "6638cbab6f5ac09266c89532010e65c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 816}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "82fba415b37e23bf39d01e61cd9e5759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 827}, "message": "destructor '~LibclangParseTest_clang_Cursor_hasVarDeclExternalStorageTrue_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "f0a3c0ffec7b6c220b99858d95f3a47a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 836}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "82fba415b37e23bf39d01e61cd9e5759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 846}, "message": "destructor '~LibclangRewriteTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "c2236d40fa2786135c9b61e0b505c852", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 881}, "message": "destructor '~LibclangRewriteTest_RewriteReplace_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "44bd4c20ead0a07eb3ac33f8494a53e7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 892}, "message": "destructor '~LibclangRewriteTest_RewriteReplaceShorter_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "752301577586d5fe1293a764686237d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 903}, "message": "destructor '~LibclangRewriteTest_RewriteReplaceLonger_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "e47dcd3aecc817d68d2d7e1c8d31fe27", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 914}, "message": "destructor '~LibclangRewriteTest_RewriteInsert_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "f8c77305cf4741869ce9861de45049a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 4, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 4, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 2, "line": 923}, "message": "destructor '~LibclangRewriteTest_RewriteRemove_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/LibclangTest.cpp", "reportHash": "f2e43eaea07e7b3ccd24cfae4ddf9f13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 23}, "message": "destructor '~LibclangParseTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/libclang/TestUtils.h", "reportHash": "91b50fac2af6735f5bd828260bce52d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
