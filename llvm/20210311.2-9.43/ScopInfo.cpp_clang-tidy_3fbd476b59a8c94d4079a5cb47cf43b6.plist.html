<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetection.h", "content": "//===- ScopDetection.h - Detect Scops ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Detect the maximal Scops of a function.\n//\n// A static control part (Scop) is a subgraph of the control flow graph (CFG)\n// that only has statically known control flow and can therefore be described\n// within the polyhedral model.\n//\n// Every Scop fulfills these restrictions:\n//\n// * It is a single entry single exit region\n//\n// * Only affine linear bounds in the loops\n//\n// Every natural loop in a Scop must have a number of loop iterations that can\n// be described as an affine linear function in surrounding loop iterators or\n// parameters. (A parameter is a scalar that does not change its value during\n// execution of the Scop).\n//\n// * Only comparisons of affine linear expressions in conditions\n//\n// * All loops and conditions perfectly nested\n//\n// The control flow needs to be structured such that it could be written using\n// just 'for' and 'if' statements, without the need for any 'goto', 'break' or\n// 'continue'.\n//\n// * Side effect free functions call\n//\n// Only function calls and intrinsics that do not have side effects are allowed\n// (readnone).\n//\n// The Scop detection finds the largest Scops by checking if the largest\n// region is a Scop. If this is not the case, its canonical subregions are\n// checked until a region is a Scop. It is now tried to extend this Scop by\n// creating a larger non canonical region.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SCOPDETECTION_H\n#define POLLY_SCOPDETECTION_H\n\n#include \"polly/ScopDetectionDiagnostic.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"llvm/Analysis/AliasSetTracker.h\"\n#include \"llvm/Analysis/RegionInfo.h\"\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/Pass.h\"\n#include <set>\n\nnamespace llvm {\nclass AAResults;\n\nvoid initializeScopDetectionWrapperPassPass(PassRegistry &);\n} // namespace llvm\n\nnamespace polly {\nusing llvm::AAResults;\nusing llvm::AliasSetTracker;\nusing llvm::AnalysisInfoMixin;\nusing llvm::AnalysisKey;\nusing llvm::AnalysisUsage;\nusing llvm::BranchInst;\nusing llvm::CallInst;\nusing llvm::DenseMap;\nusing llvm::DominatorTree;\nusing llvm::Function;\nusing llvm::FunctionAnalysisManager;\nusing llvm::FunctionPass;\nusing llvm::IntrinsicInst;\nusing llvm::LoopInfo;\nusing llvm::Module;\nusing llvm::OptimizationRemarkEmitter;\nusing llvm::PassInfoMixin;\nusing llvm::PreservedAnalyses;\nusing llvm::RegionInfo;\nusing llvm::ScalarEvolution;\nusing llvm::SCEVUnknown;\nusing llvm::SetVector;\nusing llvm::SmallSetVector;\nusing llvm::SmallVectorImpl;\nusing llvm::StringRef;\nusing llvm::SwitchInst;\n\nusing ParamSetType = std::set<const SCEV *>;\n\n// Description of the shape of an array.\nstruct ArrayShape {\n  // Base pointer identifying all accesses to this array.\n  const SCEVUnknown *BasePointer;\n\n  // Sizes of each delinearized dimension.\n  SmallVector<const SCEV *, 4> DelinearizedSizes;\n\n  ArrayShape(const SCEVUnknown *B) : BasePointer(B) {}\n};\n\nstruct MemAcc {\n  const Instruction *Insn;\n\n  // A pointer to the shape description of the array.\n  std::shared_ptr<ArrayShape> Shape;\n\n  // Subscripts computed by delinearization.\n  SmallVector<const SCEV *, 4> DelinearizedSubscripts;\n\n  MemAcc(const Instruction *I, std::shared_ptr<ArrayShape> S)\n      : Insn(I), Shape(S) {}\n};\n\nusing MapInsnToMemAcc = std::map<const Instruction *, MemAcc>;\nusing PairInstSCEV = std::pair<const Instruction *, const SCEV *>;\nusing AFs = std::vector<PairInstSCEV>;\nusing BaseToAFs = std::map<const SCEVUnknown *, AFs>;\nusing BaseToElSize = std::map<const SCEVUnknown *, const SCEV *>;\n\nextern bool PollyTrackFailures;\nextern bool PollyDelinearize;\nextern bool PollyUseRuntimeAliasChecks;\nextern bool PollyProcessUnprofitable;\nextern bool PollyInvariantLoadHoisting;\nextern bool PollyAllowUnsignedOperations;\nextern bool PollyAllowFullFunction;\n\n/// A function attribute which will cause Polly to skip the function\nextern StringRef PollySkipFnAttr;\n\n//===----------------------------------------------------------------------===//\n/// Pass to detect the maximal static control parts (Scops) of a\n/// function.\nclass ScopDetection {\npublic:\n  using RegionSet = SetVector<const Region *>;\n\n  // Remember the valid regions\n  RegionSet ValidRegions;\n\n  /// Context variables for SCoP detection.\n  struct DetectionContext {\n    Region &CurRegion;   // The region to check.\n    AliasSetTracker AST; // The AliasSetTracker to hold the alias information.\n    bool Verifying;      // If we are in the verification phase?\n\n    /// Container to remember rejection reasons for this region.\n    RejectLog Log;\n\n    /// Map a base pointer to all access functions accessing it.\n    ///\n    /// This map is indexed by the base pointer. Each element of the map\n    /// is a list of memory accesses that reference this base pointer.\n    BaseToAFs Accesses;\n\n    /// The set of base pointers with non-affine accesses.\n    ///\n    /// This set contains all base pointers and the locations where they are\n    /// used for memory accesses that can not be detected as affine accesses.\n    llvm::SetVector<std::pair<const SCEVUnknown *, Loop *>> NonAffineAccesses;\n    BaseToElSize ElementSize;\n\n    /// The region has at least one load instruction.\n    bool hasLoads = false;\n\n    /// The region has at least one store instruction.\n    bool hasStores = false;\n\n    /// Flag to indicate the region has at least one unknown access.\n    bool HasUnknownAccess = false;\n\n    /// The set of non-affine subregions in the region we analyze.\n    RegionSet NonAffineSubRegionSet;\n\n    /// The set of loops contained in non-affine regions.\n    BoxedLoopsSetTy BoxedLoopsSet;\n\n    /// Loads that need to be invariant during execution.\n    InvariantLoadsSetTy RequiredILS;\n\n    /// Map to memory access description for the corresponding LLVM\n    ///        instructions.\n    MapInsnToMemAcc InsnToMemAcc;\n\n    /// Initialize a DetectionContext from scratch.\n    DetectionContext(Region &R, AAResults &AA, bool Verify)\n        : CurRegion(R), AST(AA), Verifying(Verify), Log(&R) {}\n  };\n\n  /// Helper data structure to collect statistics about loop counts.\n  struct LoopStats {\n    int NumLoops;\n    int MaxDepth;\n  };\n\n  int NextScopID = 0;\n  int getNextID() { return NextScopID++; }\n\nprivate:\n  //===--------------------------------------------------------------------===//\n\n  /// Analyses used\n  //@{\n  const DominatorTree &DT;\n  ScalarEvolution &SE;\n  LoopInfo &LI;\n  RegionInfo &RI;\n  AAResults &AA;\n  //@}\n\n  /// Map to remember detection contexts for all regions.\n  using DetectionContextMapTy =\n      DenseMap<BBPair, std::unique_ptr<DetectionContext>>;\n  mutable DetectionContextMapTy DetectionContextMap;\n\n  /// Remove cached results for @p R.\n  void removeCachedResults(const Region &R);\n\n  /// Remove cached results for the children of @p R recursively.\n  void removeCachedResultsRecursively(const Region &R);\n\n  /// Check if @p S0 and @p S1 do contain multiple possibly aliasing pointers.\n  ///\n  /// @param S0    A expression to check.\n  /// @param S1    Another expression to check or nullptr.\n  /// @param Scope The loop/scope the expressions are checked in.\n  ///\n  /// @returns True, if multiple possibly aliasing pointers are used in @p S0\n  ///          (and @p S1 if given).\n  bool involvesMultiplePtrs(const SCEV *S0, const SCEV *S1, Loop *Scope) const;\n\n  /// Add the region @p AR as over approximated sub-region in @p Context.\n  ///\n  /// @param AR      The non-affine subregion.\n  /// @param Context The current detection context.\n  ///\n  /// @returns True if the subregion can be over approximated, false otherwise.\n  bool addOverApproximatedRegion(Region *AR, DetectionContext &Context) const;\n\n  /// Find for a given base pointer terms that hint towards dimension\n  ///        sizes of a multi-dimensional array.\n  ///\n  /// @param Context      The current detection context.\n  /// @param BasePointer  A base pointer indicating the virtual array we are\n  ///                     interested in.\n  SmallVector<const SCEV *, 4>\n  getDelinearizationTerms(DetectionContext &Context,\n                          const SCEVUnknown *BasePointer) const;\n\n  /// Check if the dimension size of a delinearized array is valid.\n  ///\n  /// @param Context     The current detection context.\n  /// @param Sizes       The sizes of the different array dimensions.\n  /// @param BasePointer The base pointer we are interested in.\n  /// @param Scope       The location where @p BasePointer is being used.\n  /// @returns True if one or more array sizes could be derived - meaning: we\n  ///          see this array as multi-dimensional.\n  bool hasValidArraySizes(DetectionContext &Context,\n                          SmallVectorImpl<const SCEV *> &Sizes,\n                          const SCEVUnknown *BasePointer, Loop *Scope) const;\n\n  /// Derive access functions for a given base pointer.\n  ///\n  /// @param Context     The current detection context.\n  /// @param Sizes       The sizes of the different array dimensions.\n  /// @param BasePointer The base pointer of all the array for which to compute\n  ///                    access functions.\n  /// @param Shape       The shape that describes the derived array sizes and\n  ///                    which should be filled with newly computed access\n  ///                    functions.\n  /// @returns True if a set of affine access functions could be derived.\n  bool computeAccessFunctions(DetectionContext &Context,\n                              const SCEVUnknown *BasePointer,\n                              std::shared_ptr<ArrayShape> Shape) const;\n\n  /// Check if all accesses to a given BasePointer are affine.\n  ///\n  /// @param Context     The current detection context.\n  /// @param BasePointer the base pointer we are interested in.\n  /// @param Scope       The location where @p BasePointer is being used.\n  /// @param True if consistent (multi-dimensional) array accesses could be\n  ///        derived for this array.\n  bool hasBaseAffineAccesses(DetectionContext &Context,\n                             const SCEVUnknown *BasePointer, Loop *Scope) const;\n\n  // Delinearize all non affine memory accesses and return false when there\n  // exists a non affine memory access that cannot be delinearized. Return true\n  // when all array accesses are affine after delinearization.\n  bool hasAffineMemoryAccesses(DetectionContext &Context) const;\n\n  // Try to expand the region R. If R can be expanded return the expanded\n  // region, NULL otherwise.\n  Region *expandRegion(Region &R);\n\n  /// Find the Scops in this region tree.\n  ///\n  /// @param The region tree to scan for scops.\n  void findScops(Region &R);\n\n  /// Check if all basic block in the region are valid.\n  ///\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if all blocks in R are valid, false otherwise.\n  bool allBlocksValid(DetectionContext &Context) const;\n\n  /// Check if a region has sufficient compute instructions.\n  ///\n  /// This function checks if a region has a non-trivial number of instructions\n  /// in each loop. This can be used as an indicator whether a loop is worth\n  /// optimizing.\n  ///\n  /// @param Context  The context of scop detection.\n  /// @param NumLoops The number of loops in the region.\n  ///\n  /// @return True if region is has sufficient compute instructions,\n  ///         false otherwise.\n  bool hasSufficientCompute(DetectionContext &Context,\n                            int NumAffineLoops) const;\n\n  /// Check if the unique affine loop might be amendable to distribution.\n  ///\n  /// This function checks if the number of non-trivial blocks in the unique\n  /// affine loop in Context.CurRegion is at least two, thus if the loop might\n  /// be amendable to distribution.\n  ///\n  /// @param Context  The context of scop detection.\n  ///\n  /// @return True only if the affine loop might be amendable to distributable.\n  bool hasPossiblyDistributableLoop(DetectionContext &Context) const;\n\n  /// Check if a region is profitable to optimize.\n  ///\n  /// Regions that are unlikely to expose interesting optimization opportunities\n  /// are called 'unprofitable' and may be skipped during scop detection.\n  ///\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if region is profitable to optimize, false otherwise.\n  bool isProfitableRegion(DetectionContext &Context) const;\n\n  /// Check if a region is a Scop.\n  ///\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if R is a Scop, false otherwise.\n  bool isValidRegion(DetectionContext &Context) const;\n\n  /// Check if an intrinsic call can be part of a Scop.\n  ///\n  /// @param II      The intrinsic call instruction to check.\n  /// @param Context The current detection context.\n  ///\n  /// @return True if the call instruction is valid, false otherwise.\n  bool isValidIntrinsicInst(IntrinsicInst &II, DetectionContext &Context) const;\n\n  /// Check if a call instruction can be part of a Scop.\n  ///\n  /// @param CI      The call instruction to check.\n  /// @param Context The current detection context.\n  ///\n  /// @return True if the call instruction is valid, false otherwise.\n  bool isValidCallInst(CallInst &CI, DetectionContext &Context) const;\n\n  /// Check if the given loads could be invariant and can be hoisted.\n  ///\n  /// If true is returned the loads are added to the required invariant loads\n  /// contained in the @p Context.\n  ///\n  /// @param RequiredILS The loads to check.\n  /// @param Context     The current detection context.\n  ///\n  /// @return True if all loads can be assumed invariant.\n  bool onlyValidRequiredInvariantLoads(InvariantLoadsSetTy &RequiredILS,\n                                       DetectionContext &Context) const;\n\n  /// Check if a value is invariant in the region Reg.\n  ///\n  /// @param Val Value to check for invariance.\n  /// @param Reg The region to consider for the invariance of Val.\n  /// @param Ctx The current detection context.\n  ///\n  /// @return True if the value represented by Val is invariant in the region\n  ///         identified by Reg.\n  bool isInvariant(Value &Val, const Region &Reg, DetectionContext &Ctx) const;\n\n  /// Check if the memory access caused by @p Inst is valid.\n  ///\n  /// @param Inst    The access instruction.\n  /// @param AF      The access function.\n  /// @param BP      The access base pointer.\n  /// @param Context The current detection context.\n  bool isValidAccess(Instruction *Inst, const SCEV *AF, const SCEVUnknown *BP,\n                     DetectionContext &Context) const;\n\n  /// Check if a memory access can be part of a Scop.\n  ///\n  /// @param Inst The instruction accessing the memory.\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if the memory access is valid, false otherwise.\n  bool isValidMemoryAccess(MemAccInst Inst, DetectionContext &Context) const;\n\n  /// Check if an instruction has any non trivial scalar dependencies as part of\n  /// a Scop.\n  ///\n  /// @param Inst The instruction to check.\n  /// @param RefRegion The region in respect to which we check the access\n  ///                  function.\n  ///\n  /// @return True if the instruction has scalar dependences, false otherwise.\n  bool hasScalarDependency(Instruction &Inst, Region &RefRegion) const;\n\n  /// Check if an instruction can be part of a Scop.\n  ///\n  /// @param Inst The instruction to check.\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if the instruction is valid, false otherwise.\n  bool isValidInstruction(Instruction &Inst, DetectionContext &Context) const;\n\n  /// Check if the switch @p SI with condition @p Condition is valid.\n  ///\n  /// @param BB           The block to check.\n  /// @param SI           The switch to check.\n  /// @param Condition    The switch condition.\n  /// @param IsLoopBranch Flag to indicate the branch is a loop exit/latch.\n  /// @param Context      The context of scop detection.\n  ///\n  /// @return True if the branch @p BI is valid.\n  bool isValidSwitch(BasicBlock &BB, SwitchInst *SI, Value *Condition,\n                     bool IsLoopBranch, DetectionContext &Context) const;\n\n  /// Check if the branch @p BI with condition @p Condition is valid.\n  ///\n  /// @param BB           The block to check.\n  /// @param BI           The branch to check.\n  /// @param Condition    The branch condition.\n  /// @param IsLoopBranch Flag to indicate the branch is a loop exit/latch.\n  /// @param Context      The context of scop detection.\n  ///\n  /// @return True if the branch @p BI is valid.\n  bool isValidBranch(BasicBlock &BB, BranchInst *BI, Value *Condition,\n                     bool IsLoopBranch, DetectionContext &Context) const;\n\n  /// Check if the SCEV @p S is affine in the current @p Context.\n  ///\n  /// This will also use a heuristic to decide if we want to require loads to be\n  /// invariant to make the expression affine or if we want to treat is as\n  /// non-affine.\n  ///\n  /// @param S           The expression to be checked.\n  /// @param Scope       The loop nest in which @p S is used.\n  /// @param Context     The context of scop detection.\n  bool isAffine(const SCEV *S, Loop *Scope, DetectionContext &Context) const;\n\n  /// Check if the control flow in a basic block is valid.\n  ///\n  /// This function checks if a certain basic block is terminated by a\n  /// Terminator instruction we can handle or, if this is not the case,\n  /// registers this basic block as the start of a non-affine region.\n  ///\n  /// This function optionally allows unreachable statements.\n  ///\n  /// @param BB               The BB to check the control flow.\n  /// @param IsLoopBranch     Flag to indicate the branch is a loop exit/latch.\n  //  @param AllowUnreachable Allow unreachable statements.\n  /// @param Context          The context of scop detection.\n  ///\n  /// @return True if the BB contains only valid control flow.\n  bool isValidCFG(BasicBlock &BB, bool IsLoopBranch, bool AllowUnreachable,\n                  DetectionContext &Context) const;\n\n  /// Is a loop valid with respect to a given region.\n  ///\n  /// @param L The loop to check.\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if the loop is valid in the region.\n  bool isValidLoop(Loop *L, DetectionContext &Context) const;\n\n  /// Count the number of loops and the maximal loop depth in @p L.\n  ///\n  /// @param L The loop to check.\n  /// @param SE The scalar evolution analysis.\n  /// @param MinProfitableTrips The minimum number of trip counts from which\n  ///                           a loop is assumed to be profitable and\n  ///                           consequently is counted.\n  /// returns A tuple of number of loops and their maximal depth.\n  static ScopDetection::LoopStats\n  countBeneficialSubLoops(Loop *L, ScalarEvolution &SE,\n                          unsigned MinProfitableTrips);\n\n  /// Check if the function @p F is marked as invalid.\n  ///\n  /// @note An OpenMP subfunction will be marked as invalid.\n  bool isValidFunction(Function &F);\n\n  /// Can ISL compute the trip count of a loop.\n  ///\n  /// @param L The loop to check.\n  /// @param Context The context of scop detection.\n  ///\n  /// @return True if ISL can compute the trip count of the loop.\n  bool canUseISLTripCount(Loop *L, DetectionContext &Context) const;\n\n  /// Print the locations of all detected scops.\n  void printLocations(Function &F);\n\n  /// Check if a region is reducible or not.\n  ///\n  /// @param Region The region to check.\n  /// @param DbgLoc Parameter to save the location of instruction that\n  ///               causes irregular control flow if the region is irreducible.\n  ///\n  /// @return True if R is reducible, false otherwise.\n  bool isReducibleRegion(Region &R, DebugLoc &DbgLoc) const;\n\n  /// Track diagnostics for invalid scops.\n  ///\n  /// @param Context The context of scop detection.\n  /// @param Assert Throw an assert in verify mode or not.\n  /// @param Args Argument list that gets passed to the constructor of RR.\n  template <class RR, typename... Args>\n  inline bool invalid(DetectionContext &Context, bool Assert,\n                      Args &&...Arguments) const;\n\npublic:\n  ScopDetection(Function &F, const DominatorTree &DT, ScalarEvolution &SE,\n                LoopInfo &LI, RegionInfo &RI, AAResults &AA,\n                OptimizationRemarkEmitter &ORE);\n\n  /// Get the RegionInfo stored in this pass.\n  ///\n  /// This was added to give the DOT printer easy access to this information.\n  RegionInfo *getRI() const { return &RI; }\n\n  /// Get the LoopInfo stored in this pass.\n  LoopInfo *getLI() const { return &LI; }\n\n  /// Is the region is the maximum region of a Scop?\n  ///\n  /// @param R The Region to test if it is maximum.\n  /// @param Verify Rerun the scop detection to verify SCoP was not invalidated\n  ///               meanwhile. Do not use if the region's DetectionContect is\n  ///               referenced by a Scop that is still to be processed.\n  ///\n  /// @return Return true if R is the maximum Region in a Scop, false otherwise.\n  bool isMaxRegionInScop(const Region &R, bool Verify = true) const;\n\n  /// Return the detection context for @p R, nullptr if @p R was invalid.\n  DetectionContext *getDetectionContext(const Region *R) const;\n\n  /// Return the set of rejection causes for @p R.\n  const RejectLog *lookupRejectionLog(const Region *R) const;\n\n  /// Return true if @p SubR is a non-affine subregion in @p ScopR.\n  bool isNonAffineSubRegion(const Region *SubR, const Region *ScopR) const;\n\n  /// Get a message why a region is invalid\n  ///\n  /// @param R The region for which we get the error message\n  ///\n  /// @return The error or \"\" if no error appeared.\n  std::string regionIsInvalidBecause(const Region *R) const;\n\n  /// @name Maximum Region In Scops Iterators\n  ///\n  /// These iterators iterator over all maximum region in Scops of this\n  /// function.\n  //@{\n  using iterator = RegionSet::iterator;\n  using const_iterator = RegionSet::const_iterator;\n\n  iterator begin() { return ValidRegions.begin(); }\n  iterator end() { return ValidRegions.end(); }\n\n  const_iterator begin() const { return ValidRegions.begin(); }\n  const_iterator end() const { return ValidRegions.end(); }\n  //@}\n\n  /// Emit rejection remarks for all rejected regions.\n  ///\n  /// @param F The function to emit remarks for.\n  void emitMissedRemarks(const Function &F);\n\n  /// Mark the function as invalid so we will not extract any scop from\n  ///        the function.\n  ///\n  /// @param F The function to mark as invalid.\n  static void markFunctionAsInvalid(Function *F);\n\n  /// Verify if all valid Regions in this Function are still valid\n  /// after some transformations.\n  void verifyAnalysis() const;\n\n  /// Verify if R is still a valid part of Scop after some transformations.\n  ///\n  /// @param R The Region to verify.\n  void verifyRegion(const Region &R) const;\n\n  /// Count the number of loops and the maximal loop depth in @p R.\n  ///\n  /// @param R The region to check\n  /// @param SE The scalar evolution analysis.\n  /// @param MinProfitableTrips The minimum number of trip counts from which\n  ///                           a loop is assumed to be profitable and\n  ///                           consequently is counted.\n  /// returns A tuple of number of loops and their maximal depth.\n  static ScopDetection::LoopStats\n  countBeneficialLoops(Region *R, ScalarEvolution &SE, LoopInfo &LI,\n                       unsigned MinProfitableTrips);\n\nprivate:\n  /// OptimizationRemarkEmitter object used to emit diagnostic remarks\n  OptimizationRemarkEmitter &ORE;\n};\n\nstruct ScopAnalysis : public AnalysisInfoMixin<ScopAnalysis> {\n  static AnalysisKey Key;\n\n  using Result = ScopDetection;\n\n  ScopAnalysis();\n\n  Result run(Function &F, FunctionAnalysisManager &FAM);\n};\n\nstruct ScopAnalysisPrinterPass : public PassInfoMixin<ScopAnalysisPrinterPass> {\n  ScopAnalysisPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM);\n\n  raw_ostream &OS;\n};\n\nstruct ScopDetectionWrapperPass : public FunctionPass {\n  static char ID;\n  std::unique_ptr<ScopDetection> Result;\n\n  ScopDetectionWrapperPass();\n\n  /// @name FunctionPass interface\n  //@{\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n  void releaseMemory() override;\n  bool runOnFunction(Function &F) override;\n  void print(raw_ostream &OS, const Module *) const override;\n  //@}\n\n  ScopDetection &getSD() { return *Result; }\n  const ScopDetection &getSD() const { return *Result; }\n};\n} // namespace polly\n\n#endif // POLLY_SCOPDETECTION_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopInfo.h", "content": "//===- polly/ScopInfo.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Store the polyhedral model representation of a static control flow region,\n// also called SCoP (Static Control Part).\n//\n// This representation is shared among several tools in the polyhedral\n// community, which are e.g. CLooG, Pluto, Loopo, Graphite.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SCOPINFO_H\n#define POLLY_SCOPINFO_H\n\n#include \"polly/ScopDetection.h\"\n#include \"polly/Support/SCEVAffinator.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/Analysis/RegionPass.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Pass.h\"\n#include \"isl/isl-noexceptions.h\"\n#include <cassert>\n#include <cstddef>\n#include <forward_list>\n\nnamespace llvm {\nvoid initializeScopInfoRegionPassPass(PassRegistry &);\nvoid initializeScopInfoWrapperPassPass(PassRegistry &);\n} // end namespace llvm\n\nnamespace polly {\nusing llvm::AnalysisInfoMixin;\nusing llvm::ArrayRef;\nusing llvm::AssertingVH;\nusing llvm::AssumptionCache;\nusing llvm::cast;\nusing llvm::DataLayout;\nusing llvm::DenseMap;\nusing llvm::DenseSet;\nusing llvm::function_ref;\nusing llvm::isa;\nusing llvm::iterator_range;\nusing llvm::LoadInst;\nusing llvm::make_range;\nusing llvm::MapVector;\nusing llvm::MemIntrinsic;\nusing llvm::Optional;\nusing llvm::PassInfoMixin;\nusing llvm::PHINode;\nusing llvm::RegionNode;\nusing llvm::RegionPass;\nusing llvm::RGPassManager;\nusing llvm::SetVector;\nusing llvm::SmallPtrSetImpl;\nusing llvm::SmallVector;\nusing llvm::SmallVectorImpl;\nusing llvm::StringMap;\nusing llvm::Type;\nusing llvm::Use;\nusing llvm::Value;\nusing llvm::ValueToValueMap;\n\nclass MemoryAccess;\n\n//===---------------------------------------------------------------------===//\n\nextern bool UseInstructionNames;\n\n// The maximal number of basic sets we allow during domain construction to\n// be created. More complex scops will result in very high compile time and\n// are also unlikely to result in good code.\nextern int const MaxDisjunctsInDomain;\n\n/// The different memory kinds used in Polly.\n///\n/// We distinguish between arrays and various scalar memory objects. We use\n/// the term ``array'' to describe memory objects that consist of a set of\n/// individual data elements arranged in a multi-dimensional grid. A scalar\n/// memory object describes an individual data element and is used to model\n/// the definition and uses of llvm::Values.\n///\n/// The polyhedral model does traditionally not reason about SSA values. To\n/// reason about llvm::Values we model them \"as if\" they were zero-dimensional\n/// memory objects, even though they were not actually allocated in (main)\n/// memory.  Memory for such objects is only alloca[ed] at CodeGeneration\n/// time. To relate the memory slots used during code generation with the\n/// llvm::Values they belong to the new names for these corresponding stack\n/// slots are derived by appending suffixes (currently \".s2a\" and \".phiops\")\n/// to the name of the original llvm::Value. To describe how def/uses are\n/// modeled exactly we use these suffixes here as well.\n///\n/// There are currently four different kinds of memory objects:\nenum class MemoryKind {\n  /// MemoryKind::Array: Models a one or multi-dimensional array\n  ///\n  /// A memory object that can be described by a multi-dimensional array.\n  /// Memory objects of this type are used to model actual multi-dimensional\n  /// arrays as they exist in LLVM-IR, but they are also used to describe\n  /// other objects:\n  ///   - A single data element allocated on the stack using 'alloca' is\n  ///     modeled as a one-dimensional, single-element array.\n  ///   - A single data element allocated as a global variable is modeled as\n  ///     one-dimensional, single-element array.\n  ///   - Certain multi-dimensional arrays with variable size, which in\n  ///     LLVM-IR are commonly expressed as a single-dimensional access with a\n  ///     complicated access function, are modeled as multi-dimensional\n  ///     memory objects (grep for \"delinearization\").\n  Array,\n\n  /// MemoryKind::Value: Models an llvm::Value\n  ///\n  /// Memory objects of type MemoryKind::Value are used to model the data flow\n  /// induced by llvm::Values. For each llvm::Value that is used across\n  /// BasicBlocks, one ScopArrayInfo object is created. A single memory WRITE\n  /// stores the llvm::Value at its definition into the memory object and at\n  /// each use of the llvm::Value (ignoring trivial intra-block uses) a\n  /// corresponding READ is added. For instance, the use/def chain of a\n  /// llvm::Value %V depicted below\n  ///              ______________________\n  ///              |DefBB:              |\n  ///              |  %V = float op ... |\n  ///              ----------------------\n  ///               |                  |\n  /// _________________               _________________\n  /// |UseBB1:        |               |UseBB2:        |\n  /// |  use float %V |               |  use float %V |\n  /// -----------------               -----------------\n  ///\n  /// is modeled as if the following memory accesses occurred:\n  ///\n  ///                        __________________________\n  ///                        |entry:                  |\n  ///                        |  %V.s2a = alloca float |\n  ///                        --------------------------\n  ///                                     |\n  ///                    ___________________________________\n  ///                    |DefBB:                           |\n  ///                    |  store %float %V, float* %V.s2a |\n  ///                    -----------------------------------\n  ///                           |                   |\n  /// ____________________________________ ___________________________________\n  /// |UseBB1:                           | |UseBB2:                          |\n  /// |  %V.reload1 = load float* %V.s2a | |  %V.reload2 = load float* %V.s2a|\n  /// |  use float %V.reload1            | |  use float %V.reload2           |\n  /// ------------------------------------ -----------------------------------\n  ///\n  Value,\n\n  /// MemoryKind::PHI: Models PHI nodes within the SCoP\n  ///\n  /// Besides the MemoryKind::Value memory object used to model the normal\n  /// llvm::Value dependences described above, PHI nodes require an additional\n  /// memory object of type MemoryKind::PHI to describe the forwarding of values\n  /// to\n  /// the PHI node.\n  ///\n  /// As an example, a PHIInst instructions\n  ///\n  /// %PHI = phi float [ %Val1, %IncomingBlock1 ], [ %Val2, %IncomingBlock2 ]\n  ///\n  /// is modeled as if the accesses occurred this way:\n  ///\n  ///                    _______________________________\n  ///                    |entry:                       |\n  ///                    |  %PHI.phiops = alloca float |\n  ///                    -------------------------------\n  ///                           |              |\n  /// __________________________________  __________________________________\n  /// |IncomingBlock1:                 |  |IncomingBlock2:                 |\n  /// |  ...                           |  |  ...                           |\n  /// |  store float %Val1 %PHI.phiops |  |  store float %Val2 %PHI.phiops |\n  /// |  br label % JoinBlock          |  |  br label %JoinBlock           |\n  /// ----------------------------------  ----------------------------------\n  ///                             \\            /\n  ///                              \\          /\n  ///               _________________________________________\n  ///               |JoinBlock:                             |\n  ///               |  %PHI = load float, float* PHI.phiops |\n  ///               -----------------------------------------\n  ///\n  /// Note that there can also be a scalar write access for %PHI if used in a\n  /// different BasicBlock, i.e. there can be a memory object %PHI.phiops as\n  /// well as a memory object %PHI.s2a.\n  PHI,\n\n  /// MemoryKind::ExitPHI: Models PHI nodes in the SCoP's exit block\n  ///\n  /// For PHI nodes in the Scop's exit block a special memory object kind is\n  /// used. The modeling used is identical to MemoryKind::PHI, with the\n  /// exception\n  /// that there are no READs from these memory objects. The PHINode's\n  /// llvm::Value is treated as a value escaping the SCoP. WRITE accesses\n  /// write directly to the escaping value's \".s2a\" alloca.\n  ExitPHI\n};\n\n/// Maps from a loop to the affine function expressing its backedge taken count.\n/// The backedge taken count already enough to express iteration domain as we\n/// only allow loops with canonical induction variable.\n/// A canonical induction variable is:\n/// an integer recurrence that starts at 0 and increments by one each time\n/// through the loop.\nusing LoopBoundMapType = std::map<const Loop *, const SCEV *>;\n\nusing AccFuncVector = std::vector<std::unique_ptr<MemoryAccess>>;\n\n/// A class to store information about arrays in the SCoP.\n///\n/// Objects are accessible via the ScoP, MemoryAccess or the id associated with\n/// the MemoryAccess access function.\n///\nclass ScopArrayInfo {\npublic:\n  /// Construct a ScopArrayInfo object.\n  ///\n  /// @param BasePtr        The array base pointer.\n  /// @param ElementType    The type of the elements stored in the array.\n  /// @param IslCtx         The isl context used to create the base pointer id.\n  /// @param DimensionSizes A vector containing the size of each dimension.\n  /// @param Kind           The kind of the array object.\n  /// @param DL             The data layout of the module.\n  /// @param S              The scop this array object belongs to.\n  /// @param BaseName       The optional name of this memory reference.\n  ScopArrayInfo(Value *BasePtr, Type *ElementType, isl::ctx IslCtx,\n                ArrayRef<const SCEV *> DimensionSizes, MemoryKind Kind,\n                const DataLayout &DL, Scop *S, const char *BaseName = nullptr);\n\n  /// Destructor to free the isl id of the base pointer.\n  ~ScopArrayInfo();\n\n  ///  Update the element type of the ScopArrayInfo object.\n  ///\n  ///  Memory accesses referencing this ScopArrayInfo object may use\n  ///  different element sizes. This function ensures the canonical element type\n  ///  stored is small enough to model accesses to the current element type as\n  ///  well as to @p NewElementType.\n  ///\n  ///  @param NewElementType An element type that is used to access this array.\n  void updateElementType(Type *NewElementType);\n\n  ///  Update the sizes of the ScopArrayInfo object.\n  ///\n  ///  A ScopArrayInfo object may be created without all outer dimensions being\n  ///  available. This function is called when new memory accesses are added for\n  ///  this ScopArrayInfo object. It verifies that sizes are compatible and adds\n  ///  additional outer array dimensions, if needed.\n  ///\n  ///  @param Sizes       A vector of array sizes where the rightmost array\n  ///                     sizes need to match the innermost array sizes already\n  ///                     defined in SAI.\n  ///  @param CheckConsistency Update sizes, even if new sizes are inconsistent\n  ///                          with old sizes\n  bool updateSizes(ArrayRef<const SCEV *> Sizes, bool CheckConsistency = true);\n\n  /// Make the ScopArrayInfo model a Fortran array.\n  /// It receives the Fortran array descriptor and stores this.\n  /// It also adds a piecewise expression for the outermost dimension\n  /// since this information is available for Fortran arrays at runtime.\n  void applyAndSetFAD(Value *FAD);\n\n  /// Get the FortranArrayDescriptor corresponding to this array if it exists,\n  /// nullptr otherwise.\n  Value *getFortranArrayDescriptor() const { return this->FAD; }\n\n  /// Set the base pointer to @p BP.\n  void setBasePtr(Value *BP) { BasePtr = BP; }\n\n  /// Return the base pointer.\n  Value *getBasePtr() const { return BasePtr; }\n\n  // Set IsOnHeap to the value in parameter.\n  void setIsOnHeap(bool value) { IsOnHeap = value; }\n\n  /// For indirect accesses return the origin SAI of the BP, else null.\n  const ScopArrayInfo *getBasePtrOriginSAI() const { return BasePtrOriginSAI; }\n\n  /// The set of derived indirect SAIs for this origin SAI.\n  const SmallSetVector<ScopArrayInfo *, 2> &getDerivedSAIs() const {\n    return DerivedSAIs;\n  }\n\n  /// Return the number of dimensions.\n  unsigned getNumberOfDimensions() const {\n    if (Kind == MemoryKind::PHI || Kind == MemoryKind::ExitPHI ||\n        Kind == MemoryKind::Value)\n      return 0;\n    return DimensionSizes.size();\n  }\n\n  /// Return the size of dimension @p dim as SCEV*.\n  //\n  //  Scalars do not have array dimensions and the first dimension of\n  //  a (possibly multi-dimensional) array also does not carry any size\n  //  information, in case the array is not newly created.\n  const SCEV *getDimensionSize(unsigned Dim) const {\n    assert(Dim < getNumberOfDimensions() && \"Invalid dimension\");\n    return DimensionSizes[Dim];\n  }\n\n  /// Return the size of dimension @p dim as isl::pw_aff.\n  //\n  //  Scalars do not have array dimensions and the first dimension of\n  //  a (possibly multi-dimensional) array also does not carry any size\n  //  information, in case the array is not newly created.\n  isl::pw_aff getDimensionSizePw(unsigned Dim) const {\n    assert(Dim < getNumberOfDimensions() && \"Invalid dimension\");\n    return DimensionSizesPw[Dim];\n  }\n\n  /// Get the canonical element type of this array.\n  ///\n  /// @returns The canonical element type of this array.\n  Type *getElementType() const { return ElementType; }\n\n  /// Get element size in bytes.\n  int getElemSizeInBytes() const;\n\n  /// Get the name of this memory reference.\n  std::string getName() const;\n\n  /// Return the isl id for the base pointer.\n  isl::id getBasePtrId() const;\n\n  /// Return what kind of memory this represents.\n  MemoryKind getKind() const { return Kind; }\n\n  /// Is this array info modeling an llvm::Value?\n  bool isValueKind() const { return Kind == MemoryKind::Value; }\n\n  /// Is this array info modeling special PHI node memory?\n  ///\n  /// During code generation of PHI nodes, there is a need for two kinds of\n  /// virtual storage. The normal one as it is used for all scalar dependences,\n  /// where the result of the PHI node is stored and later loaded from as well\n  /// as a second one where the incoming values of the PHI nodes are stored\n  /// into and reloaded when the PHI is executed. As both memories use the\n  /// original PHI node as virtual base pointer, we have this additional\n  /// attribute to distinguish the PHI node specific array modeling from the\n  /// normal scalar array modeling.\n  bool isPHIKind() const { return Kind == MemoryKind::PHI; }\n\n  /// Is this array info modeling an MemoryKind::ExitPHI?\n  bool isExitPHIKind() const { return Kind == MemoryKind::ExitPHI; }\n\n  /// Is this array info modeling an array?\n  bool isArrayKind() const { return Kind == MemoryKind::Array; }\n\n  /// Is this array allocated on heap\n  ///\n  /// This property is only relevant if the array is allocated by Polly instead\n  /// of pre-existing. If false, it is allocated using alloca instead malloca.\n  bool isOnHeap() const { return IsOnHeap; }\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  /// Dump a readable representation to stderr.\n  void dump() const;\n#endif\n\n  /// Print a readable representation to @p OS.\n  ///\n  /// @param SizeAsPwAff Print the size as isl::pw_aff\n  void print(raw_ostream &OS, bool SizeAsPwAff = false) const;\n\n  /// Access the ScopArrayInfo associated with an access function.\n  static const ScopArrayInfo *getFromAccessFunction(isl::pw_multi_aff PMA);\n\n  /// Access the ScopArrayInfo associated with an isl Id.\n  static const ScopArrayInfo *getFromId(isl::id Id);\n\n  /// Get the space of this array access.\n  isl::space getSpace() const;\n\n  /// If the array is read only\n  bool isReadOnly();\n\n  /// Verify that @p Array is compatible to this ScopArrayInfo.\n  ///\n  /// Two arrays are compatible if their dimensionality, the sizes of their\n  /// dimensions, and their element sizes match.\n  ///\n  /// @param Array The array to compare against.\n  ///\n  /// @returns True, if the arrays are compatible, False otherwise.\n  bool isCompatibleWith(const ScopArrayInfo *Array) const;\n\nprivate:\n  void addDerivedSAI(ScopArrayInfo *DerivedSAI) {\n    DerivedSAIs.insert(DerivedSAI);\n  }\n\n  /// For indirect accesses this is the SAI of the BP origin.\n  const ScopArrayInfo *BasePtrOriginSAI;\n\n  /// For origin SAIs the set of derived indirect SAIs.\n  SmallSetVector<ScopArrayInfo *, 2> DerivedSAIs;\n\n  /// The base pointer.\n  AssertingVH<Value> BasePtr;\n\n  /// The canonical element type of this array.\n  ///\n  /// The canonical element type describes the minimal accessible element in\n  /// this array. Not all elements accessed, need to be of the very same type,\n  /// but the allocation size of the type of the elements loaded/stored from/to\n  /// this array needs to be a multiple of the allocation size of the canonical\n  /// type.\n  Type *ElementType;\n\n  /// The isl id for the base pointer.\n  isl::id Id;\n\n  /// True if the newly allocated array is on heap.\n  bool IsOnHeap = false;\n\n  /// The sizes of each dimension as SCEV*.\n  SmallVector<const SCEV *, 4> DimensionSizes;\n\n  /// The sizes of each dimension as isl::pw_aff.\n  SmallVector<isl::pw_aff, 4> DimensionSizesPw;\n\n  /// The type of this scop array info object.\n  ///\n  /// We distinguish between SCALAR, PHI and ARRAY objects.\n  MemoryKind Kind;\n\n  /// The data layout of the module.\n  const DataLayout &DL;\n\n  /// The scop this SAI object belongs to.\n  Scop &S;\n\n  /// If this array models a Fortran array, then this points\n  /// to the Fortran array descriptor.\n  Value *FAD = nullptr;\n};\n\n/// Represent memory accesses in statements.\nclass MemoryAccess {\n  friend class Scop;\n  friend class ScopStmt;\n  friend class ScopBuilder;\n\npublic:\n  /// The access type of a memory access\n  ///\n  /// There are three kind of access types:\n  ///\n  /// * A read access\n  ///\n  /// A certain set of memory locations are read and may be used for internal\n  /// calculations.\n  ///\n  /// * A must-write access\n  ///\n  /// A certain set of memory locations is definitely written. The old value is\n  /// replaced by a newly calculated value. The old value is not read or used at\n  /// all.\n  ///\n  /// * A may-write access\n  ///\n  /// A certain set of memory locations may be written. The memory location may\n  /// contain a new value if there is actually a write or the old value may\n  /// remain, if no write happens.\n  enum AccessType {\n    READ = 0x1,\n    MUST_WRITE = 0x2,\n    MAY_WRITE = 0x3,\n  };\n\n  /// Reduction access type\n  ///\n  /// Commutative and associative binary operations suitable for reductions\n  enum ReductionType {\n    RT_NONE, ///< Indicate no reduction at all\n    RT_ADD,  ///< Addition\n    RT_MUL,  ///< Multiplication\n    RT_BOR,  ///< Bitwise Or\n    RT_BXOR, ///< Bitwise XOr\n    RT_BAND, ///< Bitwise And\n  };\n\n  using SubscriptsTy = SmallVector<const SCEV *, 4>;\n\nprivate:\n  /// A unique identifier for this memory access.\n  ///\n  /// The identifier is unique between all memory accesses belonging to the same\n  /// scop statement.\n  isl::id Id;\n\n  /// What is modeled by this MemoryAccess.\n  /// @see MemoryKind\n  MemoryKind Kind;\n\n  /// Whether it a reading or writing access, and if writing, whether it\n  /// is conditional (MAY_WRITE).\n  enum AccessType AccType;\n\n  /// Reduction type for reduction like accesses, RT_NONE otherwise\n  ///\n  /// An access is reduction like if it is part of a load-store chain in which\n  /// both access the same memory location (use the same LLVM-IR value\n  /// as pointer reference). Furthermore, between the load and the store there\n  /// is exactly one binary operator which is known to be associative and\n  /// commutative.\n  ///\n  /// TODO:\n  ///\n  /// We can later lift the constraint that the same LLVM-IR value defines the\n  /// memory location to handle scops such as the following:\n  ///\n  ///    for i\n  ///      for j\n  ///        sum[i+j] = sum[i] + 3;\n  ///\n  /// Here not all iterations access the same memory location, but iterations\n  /// for which j = 0 holds do. After lifting the equality check in ScopBuilder,\n  /// subsequent transformations do not only need check if a statement is\n  /// reduction like, but they also need to verify that that the reduction\n  /// property is only exploited for statement instances that load from and\n  /// store to the same data location. Doing so at dependence analysis time\n  /// could allow us to handle the above example.\n  ReductionType RedType = RT_NONE;\n\n  /// Parent ScopStmt of this access.\n  ScopStmt *Statement;\n\n  /// The domain under which this access is not modeled precisely.\n  ///\n  /// The invalid domain for an access describes all parameter combinations\n  /// under which the statement looks to be executed but is in fact not because\n  /// some assumption/restriction makes the access invalid.\n  isl::set InvalidDomain;\n\n  // Properties describing the accessed array.\n  // TODO: It might be possible to move them to ScopArrayInfo.\n  // @{\n\n  /// The base address (e.g., A for A[i+j]).\n  ///\n  /// The #BaseAddr of a memory access of kind MemoryKind::Array is the base\n  /// pointer of the memory access.\n  /// The #BaseAddr of a memory access of kind MemoryKind::PHI or\n  /// MemoryKind::ExitPHI is the PHI node itself.\n  /// The #BaseAddr of a memory access of kind MemoryKind::Value is the\n  /// instruction defining the value.\n  AssertingVH<Value> BaseAddr;\n\n  /// Type a single array element wrt. this access.\n  Type *ElementType;\n\n  /// Size of each dimension of the accessed array.\n  SmallVector<const SCEV *, 4> Sizes;\n  // @}\n\n  // Properties describing the accessed element.\n  // @{\n\n  /// The access instruction of this memory access.\n  ///\n  /// For memory accesses of kind MemoryKind::Array the access instruction is\n  /// the Load or Store instruction performing the access.\n  ///\n  /// For memory accesses of kind MemoryKind::PHI or MemoryKind::ExitPHI the\n  /// access instruction of a load access is the PHI instruction. The access\n  /// instruction of a PHI-store is the incoming's block's terminator\n  /// instruction.\n  ///\n  /// For memory accesses of kind MemoryKind::Value the access instruction of a\n  /// load access is nullptr because generally there can be multiple\n  /// instructions in the statement using the same llvm::Value. The access\n  /// instruction of a write access is the instruction that defines the\n  /// llvm::Value.\n  Instruction *AccessInstruction = nullptr;\n\n  /// Incoming block and value of a PHINode.\n  SmallVector<std::pair<BasicBlock *, Value *>, 4> Incoming;\n\n  /// The value associated with this memory access.\n  ///\n  ///  - For array memory accesses (MemoryKind::Array) it is the loaded result\n  ///    or the stored value. If the access instruction is a memory intrinsic it\n  ///    the access value is also the memory intrinsic.\n  ///  - For accesses of kind MemoryKind::Value it is the access instruction\n  ///    itself.\n  ///  - For accesses of kind MemoryKind::PHI or MemoryKind::ExitPHI it is the\n  ///    PHI node itself (for both, READ and WRITE accesses).\n  ///\n  AssertingVH<Value> AccessValue;\n\n  /// Are all the subscripts affine expression?\n  bool IsAffine = true;\n\n  /// Subscript expression for each dimension.\n  SubscriptsTy Subscripts;\n\n  /// Relation from statement instances to the accessed array elements.\n  ///\n  /// In the common case this relation is a function that maps a set of loop\n  /// indices to the memory address from which a value is loaded/stored:\n  ///\n  ///      for i\n  ///        for j\n  ///    S:     A[i + 3 j] = ...\n  ///\n  ///    => { S[i,j] -> A[i + 3j] }\n  ///\n  /// In case the exact access function is not known, the access relation may\n  /// also be a one to all mapping { S[i,j] -> A[o] } describing that any\n  /// element accessible through A might be accessed.\n  ///\n  /// In case of an access to a larger element belonging to an array that also\n  /// contains smaller elements, the access relation models the larger access\n  /// with multiple smaller accesses of the size of the minimal array element\n  /// type:\n  ///\n  ///      short *A;\n  ///\n  ///      for i\n  ///    S:     A[i] = *((double*)&A[4 * i]);\n  ///\n  ///    => { S[i] -> A[i]; S[i] -> A[o] : 4i <= o <= 4i + 3 }\n  isl::map AccessRelation;\n\n  /// Updated access relation read from JSCOP file.\n  isl::map NewAccessRelation;\n\n  /// Fortran arrays whose sizes are not statically known are stored in terms\n  /// of a descriptor struct. This maintains a raw pointer to the memory,\n  /// along with auxiliary fields with information such as dimensions.\n  /// We hold a reference to the descriptor corresponding to a MemoryAccess\n  /// into a Fortran array. FAD for \"Fortran Array Descriptor\"\n  AssertingVH<Value> FAD;\n  // @}\n\n  isl::basic_map createBasicAccessMap(ScopStmt *Statement);\n\n  isl::set assumeNoOutOfBound();\n\n  /// Compute bounds on an over approximated  access relation.\n  ///\n  /// @param ElementSize The size of one element accessed.\n  void computeBoundsOnAccessRelation(unsigned ElementSize);\n\n  /// Get the original access function as read from IR.\n  isl::map getOriginalAccessRelation() const;\n\n  /// Return the space in which the access relation lives in.\n  isl::space getOriginalAccessRelationSpace() const;\n\n  /// Get the new access function imported or set by a pass\n  isl::map getNewAccessRelation() const;\n\n  /// Fold the memory access to consider parametric offsets\n  ///\n  /// To recover memory accesses with array size parameters in the subscript\n  /// expression we post-process the delinearization results.\n  ///\n  /// We would normally recover from an access A[exp0(i) * N + exp1(i)] into an\n  /// array A[][N] the 2D access A[exp0(i)][exp1(i)]. However, another valid\n  /// delinearization is A[exp0(i) - 1][exp1(i) + N] which - depending on the\n  /// range of exp1(i) - may be preferable. Specifically, for cases where we\n  /// know exp1(i) is negative, we want to choose the latter expression.\n  ///\n  /// As we commonly do not have any information about the range of exp1(i),\n  /// we do not choose one of the two options, but instead create a piecewise\n  /// access function that adds the (-1, N) offsets as soon as exp1(i) becomes\n  /// negative. For a 2D array such an access function is created by applying\n  /// the piecewise map:\n  ///\n  /// [i,j] -> [i, j] :      j >= 0\n  /// [i,j] -> [i-1, j+N] :  j <  0\n  ///\n  /// We can generalize this mapping to arbitrary dimensions by applying this\n  /// piecewise mapping pairwise from the rightmost to the leftmost access\n  /// dimension. It would also be possible to cover a wider range by introducing\n  /// more cases and adding multiple of Ns to these cases. However, this has\n  /// not yet been necessary.\n  /// The introduction of different cases necessarily complicates the memory\n  /// access function, but cases that can be statically proven to not happen\n  /// will be eliminated later on.\n  void foldAccessRelation();\n\n  /// Create the access relation for the underlying memory intrinsic.\n  void buildMemIntrinsicAccessRelation();\n\n  /// Assemble the access relation from all available information.\n  ///\n  /// In particular, used the information passes in the constructor and the\n  /// parent ScopStmt set by setStatment().\n  ///\n  /// @param SAI Info object for the accessed array.\n  void buildAccessRelation(const ScopArrayInfo *SAI);\n\n  /// Carry index overflows of dimensions with constant size to the next higher\n  /// dimension.\n  ///\n  /// For dimensions that have constant size, modulo the index by the size and\n  /// add up the carry (floored division) to the next higher dimension. This is\n  /// how overflow is defined in row-major order.\n  /// It happens e.g. when ScalarEvolution computes the offset to the base\n  /// pointer and would algebraically sum up all lower dimensions' indices of\n  /// constant size.\n  ///\n  /// Example:\n  ///   float (*A)[4];\n  ///   A[1][6] -> A[2][2]\n  void wrapConstantDimensions();\n\npublic:\n  /// Create a new MemoryAccess.\n  ///\n  /// @param Stmt       The parent statement.\n  /// @param AccessInst The instruction doing the access.\n  /// @param BaseAddr   The accessed array's address.\n  /// @param ElemType   The type of the accessed array elements.\n  /// @param AccType    Whether read or write access.\n  /// @param IsAffine   Whether the subscripts are affine expressions.\n  /// @param Kind       The kind of memory accessed.\n  /// @param Subscripts Subscript expressions\n  /// @param Sizes      Dimension lengths of the accessed array.\n  MemoryAccess(ScopStmt *Stmt, Instruction *AccessInst, AccessType AccType,\n               Value *BaseAddress, Type *ElemType, bool Affine,\n               ArrayRef<const SCEV *> Subscripts, ArrayRef<const SCEV *> Sizes,\n               Value *AccessValue, MemoryKind Kind);\n\n  /// Create a new MemoryAccess that corresponds to @p AccRel.\n  ///\n  /// Along with @p Stmt and @p AccType it uses information about dimension\n  /// lengths of the accessed array, the type of the accessed array elements,\n  /// the name of the accessed array that is derived from the object accessible\n  /// via @p AccRel.\n  ///\n  /// @param Stmt       The parent statement.\n  /// @param AccType    Whether read or write access.\n  /// @param AccRel     The access relation that describes the memory access.\n  MemoryAccess(ScopStmt *Stmt, AccessType AccType, isl::map AccRel);\n\n  MemoryAccess(const MemoryAccess &) = delete;\n  MemoryAccess &operator=(const MemoryAccess &) = delete;\n  ~MemoryAccess();\n\n  /// Add a new incoming block/value pairs for this PHI/ExitPHI access.\n  ///\n  /// @param IncomingBlock The PHI's incoming block.\n  /// @param IncomingValue The value when reaching the PHI from the @p\n  ///                      IncomingBlock.\n  void addIncoming(BasicBlock *IncomingBlock, Value *IncomingValue) {\n    assert(!isRead());\n    assert(isAnyPHIKind());\n    Incoming.emplace_back(std::make_pair(IncomingBlock, IncomingValue));\n  }\n\n  /// Return the list of possible PHI/ExitPHI values.\n  ///\n  /// After code generation moves some PHIs around during region simplification,\n  /// we cannot reliably locate the original PHI node and its incoming values\n  /// anymore. For this reason we remember these explicitly for all PHI-kind\n  /// accesses.\n  ArrayRef<std::pair<BasicBlock *, Value *>> getIncoming() const {\n    assert(isAnyPHIKind());\n    return Incoming;\n  }\n\n  /// Get the type of a memory access.\n  enum AccessType getType() { return AccType; }\n\n  /// Is this a reduction like access?\n  bool isReductionLike() const { return RedType != RT_NONE; }\n\n  /// Is this a read memory access?\n  bool isRead() const { return AccType == MemoryAccess::READ; }\n\n  /// Is this a must-write memory access?\n  bool isMustWrite() const { return AccType == MemoryAccess::MUST_WRITE; }\n\n  /// Is this a may-write memory access?\n  bool isMayWrite() const { return AccType == MemoryAccess::MAY_WRITE; }\n\n  /// Is this a write memory access?\n  bool isWrite() const { return isMustWrite() || isMayWrite(); }\n\n  /// Is this a memory intrinsic access (memcpy, memset, memmove)?\n  bool isMemoryIntrinsic() const {\n    return isa<MemIntrinsic>(getAccessInstruction());\n  }\n\n  /// Check if a new access relation was imported or set by a pass.\n  bool hasNewAccessRelation() const { return !NewAccessRelation.is_null(); }\n\n  /// Return the newest access relation of this access.\n  ///\n  /// There are two possibilities:\n  ///   1) The original access relation read from the LLVM-IR.\n  ///   2) A new access relation imported from a json file or set by another\n  ///      pass (e.g., for privatization).\n  ///\n  /// As 2) is by construction \"newer\" than 1) we return the new access\n  /// relation if present.\n  ///\n  isl::map getLatestAccessRelation() const {\n    return hasNewAccessRelation() ? getNewAccessRelation()\n                                  : getOriginalAccessRelation();\n  }\n\n  /// Old name of getLatestAccessRelation().\n  isl::map getAccessRelation() const { return getLatestAccessRelation(); }\n\n  /// Get an isl map describing the memory address accessed.\n  ///\n  /// In most cases the memory address accessed is well described by the access\n  /// relation obtained with getAccessRelation. However, in case of arrays\n  /// accessed with types of different size the access relation maps one access\n  /// to multiple smaller address locations. This method returns an isl map that\n  /// relates each dynamic statement instance to the unique memory location\n  /// that is loaded from / stored to.\n  ///\n  /// For an access relation { S[i] -> A[o] : 4i <= o <= 4i + 3 } this method\n  /// will return the address function { S[i] -> A[4i] }.\n  ///\n  /// @returns The address function for this memory access.\n  isl::map getAddressFunction() const;\n\n  /// Return the access relation after the schedule was applied.\n  isl::pw_multi_aff\n  applyScheduleToAccessRelation(isl::union_map Schedule) const;\n\n  /// Get an isl string representing the access function read from IR.\n  std::string getOriginalAccessRelationStr() const;\n\n  /// Get an isl string representing a new access function, if available.\n  std::string getNewAccessRelationStr() const;\n\n  /// Get an isl string representing the latest access relation.\n  std::string getAccessRelationStr() const;\n\n  /// Get the original base address of this access (e.g. A for A[i+j]) when\n  /// detected.\n  ///\n  /// This address may differ from the base address referenced by the original\n  /// ScopArrayInfo to which this array belongs, as this memory access may\n  /// have been canonicalized to a ScopArrayInfo which has a different but\n  /// identically-valued base pointer in case invariant load hoisting is\n  /// enabled.\n  Value *getOriginalBaseAddr() const { return BaseAddr; }\n\n  /// Get the detection-time base array isl::id for this access.\n  isl::id getOriginalArrayId() const;\n\n  /// Get the base array isl::id for this access, modifiable through\n  /// setNewAccessRelation().\n  isl::id getLatestArrayId() const;\n\n  /// Old name of getOriginalArrayId().\n  isl::id getArrayId() const { return getOriginalArrayId(); }\n\n  /// Get the detection-time ScopArrayInfo object for the base address.\n  const ScopArrayInfo *getOriginalScopArrayInfo() const;\n\n  /// Get the ScopArrayInfo object for the base address, or the one set\n  /// by setNewAccessRelation().\n  const ScopArrayInfo *getLatestScopArrayInfo() const;\n\n  /// Legacy name of getOriginalScopArrayInfo().\n  const ScopArrayInfo *getScopArrayInfo() const {\n    return getOriginalScopArrayInfo();\n  }\n\n  /// Return a string representation of the access's reduction type.\n  const std::string getReductionOperatorStr() const;\n\n  /// Return a string representation of the reduction type @p RT.\n  static const std::string getReductionOperatorStr(ReductionType RT);\n\n  /// Return the element type of the accessed array wrt. this access.\n  Type *getElementType() const { return ElementType; }\n\n  /// Return the access value of this memory access.\n  Value *getAccessValue() const { return AccessValue; }\n\n  /// Return llvm::Value that is stored by this access, if available.\n  ///\n  /// PHI nodes may not have a unique value available that is stored, as in\n  /// case of region statements one out of possibly several llvm::Values\n  /// might be stored. In this case nullptr is returned.\n  Value *tryGetValueStored() {\n    assert(isWrite() && \"Only write statement store values\");\n    if (isAnyPHIKind()) {\n      if (Incoming.size() == 1)\n        return Incoming[0].second;\n      return nullptr;\n    }\n    return AccessValue;\n  }\n\n  /// Return the access instruction of this memory access.\n  Instruction *getAccessInstruction() const { return AccessInstruction; }\n\n  ///  Return an iterator range containing the subscripts.\n  iterator_range<SubscriptsTy::const_iterator> subscripts() const {\n    return make_range(Subscripts.begin(), Subscripts.end());\n  }\n\n  /// Return the number of access function subscript.\n  unsigned getNumSubscripts() const { return Subscripts.size(); }\n\n  /// Return the access function subscript in the dimension @p Dim.\n  const SCEV *getSubscript(unsigned Dim) const { return Subscripts[Dim]; }\n\n  /// Compute the isl representation for the SCEV @p E wrt. this access.\n  ///\n  /// Note that this function will also adjust the invalid context accordingly.\n  isl::pw_aff getPwAff(const SCEV *E);\n\n  /// Get the invalid domain for this access.\n  isl::set getInvalidDomain() const { return InvalidDomain; }\n\n  /// Get the invalid context for this access.\n  isl::set getInvalidContext() const { return getInvalidDomain().params(); }\n\n  /// Get the stride of this memory access in the specified Schedule. Schedule\n  /// is a map from the statement to a schedule where the innermost dimension is\n  /// the dimension of the innermost loop containing the statement.\n  isl::set getStride(isl::map Schedule) const;\n\n  /// Get the FortranArrayDescriptor corresponding to this memory access if\n  /// it exists, and nullptr otherwise.\n  Value *getFortranArrayDescriptor() const { return this->FAD; }\n\n  /// Is the stride of the access equal to a certain width? Schedule is a map\n  /// from the statement to a schedule where the innermost dimension is the\n  /// dimension of the innermost loop containing the statement.\n  bool isStrideX(isl::map Schedule, int StrideWidth) const;\n\n  /// Is consecutive memory accessed for a given statement instance set?\n  /// Schedule is a map from the statement to a schedule where the innermost\n  /// dimension is the dimension of the innermost loop containing the\n  /// statement.\n  bool isStrideOne(isl::map Schedule) const;\n\n  /// Is always the same memory accessed for a given statement instance set?\n  /// Schedule is a map from the statement to a schedule where the innermost\n  /// dimension is the dimension of the innermost loop containing the\n  /// statement.\n  bool isStrideZero(isl::map Schedule) const;\n\n  /// Return the kind when this access was first detected.\n  MemoryKind getOriginalKind() const {\n    assert(!getOriginalScopArrayInfo() /* not yet initialized */ ||\n           getOriginalScopArrayInfo()->getKind() == Kind);\n    return Kind;\n  }\n\n  /// Return the kind considering a potential setNewAccessRelation.\n  MemoryKind getLatestKind() const {\n    return getLatestScopArrayInfo()->getKind();\n  }\n\n  /// Whether this is an access of an explicit load or store in the IR.\n  bool isOriginalArrayKind() const {\n    return getOriginalKind() == MemoryKind::Array;\n  }\n\n  /// Whether storage memory is either an custom .s2a/.phiops alloca\n  /// (false) or an existing pointer into an array (true).\n  bool isLatestArrayKind() const {\n    return getLatestKind() == MemoryKind::Array;\n  }\n\n  /// Old name of isOriginalArrayKind.\n  bool isArrayKind() const { return isOriginalArrayKind(); }\n\n  /// Whether this access is an array to a scalar memory object, without\n  /// considering changes by setNewAccessRelation.\n  ///\n  /// Scalar accesses are accesses to MemoryKind::Value, MemoryKind::PHI or\n  /// MemoryKind::ExitPHI.\n  bool isOriginalScalarKind() const {\n    return getOriginalKind() != MemoryKind::Array;\n  }\n\n  /// Whether this access is an array to a scalar memory object, also\n  /// considering changes by setNewAccessRelation.\n  bool isLatestScalarKind() const {\n    return getLatestKind() != MemoryKind::Array;\n  }\n\n  /// Old name of isOriginalScalarKind.\n  bool isScalarKind() const { return isOriginalScalarKind(); }\n\n  /// Was this MemoryAccess detected as a scalar dependences?\n  bool isOriginalValueKind() const {\n    return getOriginalKind() == MemoryKind::Value;\n  }\n\n  /// Is this MemoryAccess currently modeling scalar dependences?\n  bool isLatestValueKind() const {\n    return getLatestKind() == MemoryKind::Value;\n  }\n\n  /// Old name of isOriginalValueKind().\n  bool isValueKind() const { return isOriginalValueKind(); }\n\n  /// Was this MemoryAccess detected as a special PHI node access?\n  bool isOriginalPHIKind() const {\n    return getOriginalKind() == MemoryKind::PHI;\n  }\n\n  /// Is this MemoryAccess modeling special PHI node accesses, also\n  /// considering a potential change by setNewAccessRelation?\n  bool isLatestPHIKind() const { return getLatestKind() == MemoryKind::PHI; }\n\n  /// Old name of isOriginalPHIKind.\n  bool isPHIKind() const { return isOriginalPHIKind(); }\n\n  /// Was this MemoryAccess detected as the accesses of a PHI node in the\n  /// SCoP's exit block?\n  bool isOriginalExitPHIKind() const {\n    return getOriginalKind() == MemoryKind::ExitPHI;\n  }\n\n  /// Is this MemoryAccess modeling the accesses of a PHI node in the\n  /// SCoP's exit block? Can be changed to an array access using\n  /// setNewAccessRelation().\n  bool isLatestExitPHIKind() const {\n    return getLatestKind() == MemoryKind::ExitPHI;\n  }\n\n  /// Old name of isOriginalExitPHIKind().\n  bool isExitPHIKind() const { return isOriginalExitPHIKind(); }\n\n  /// Was this access detected as one of the two PHI types?\n  bool isOriginalAnyPHIKind() const {\n    return isOriginalPHIKind() || isOriginalExitPHIKind();\n  }\n\n  /// Does this access originate from one of the two PHI types? Can be\n  /// changed to an array access using setNewAccessRelation().\n  bool isLatestAnyPHIKind() const {\n    return isLatestPHIKind() || isLatestExitPHIKind();\n  }\n\n  /// Old name of isOriginalAnyPHIKind().\n  bool isAnyPHIKind() const { return isOriginalAnyPHIKind(); }\n\n  /// Get the statement that contains this memory access.\n  ScopStmt *getStatement() const { return Statement; }\n\n  /// Get the reduction type of this access\n  ReductionType getReductionType() const { return RedType; }\n\n  /// Set the array descriptor corresponding to the Array on which the\n  /// memory access is performed.\n  void setFortranArrayDescriptor(Value *FAD);\n\n  /// Update the original access relation.\n  ///\n  /// We need to update the original access relation during scop construction,\n  /// when unifying the memory accesses that access the same scop array info\n  /// object. After the scop has been constructed, the original access relation\n  /// should not be changed any more. Instead setNewAccessRelation should\n  /// be called.\n  void setAccessRelation(isl::map AccessRelation);\n\n  /// Set the updated access relation read from JSCOP file.\n  void setNewAccessRelation(isl::map NewAccessRelation);\n\n  /// Return whether the MemoryyAccess is a partial access. That is, the access\n  /// is not executed in some instances of the parent statement's domain.\n  bool isLatestPartialAccess() const;\n\n  /// Mark this a reduction like access\n  void markAsReductionLike(ReductionType RT) { RedType = RT; }\n\n  /// Align the parameters in the access relation to the scop context\n  void realignParams();\n\n  /// Update the dimensionality of the memory access.\n  ///\n  /// During scop construction some memory accesses may not be constructed with\n  /// their full dimensionality, but outer dimensions may have been omitted if\n  /// they took the value 'zero'. By updating the dimensionality of the\n  /// statement we add additional zero-valued dimensions to match the\n  /// dimensionality of the ScopArrayInfo object that belongs to this memory\n  /// access.\n  void updateDimensionality();\n\n  /// Get identifier for the memory access.\n  ///\n  /// This identifier is unique for all accesses that belong to the same scop\n  /// statement.\n  isl::id getId() const;\n\n  /// Print the MemoryAccess.\n  ///\n  /// @param OS The output stream the MemoryAccess is printed to.\n  void print(raw_ostream &OS) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  /// Print the MemoryAccess to stderr.\n  void dump() const;\n#endif\n\n  /// Is the memory access affine?\n  bool isAffine() const { return IsAffine; }\n};\n\nraw_ostream &operator<<(raw_ostream &OS, MemoryAccess::ReductionType RT);\n\n/// Ordered list type to hold accesses.\nusing MemoryAccessList = std::forward_list<MemoryAccess *>;\n\n/// Helper structure for invariant memory accesses.\nstruct InvariantAccess {\n  /// The memory access that is (partially) invariant.\n  MemoryAccess *MA;\n\n  /// The context under which the access is not invariant.\n  isl::set NonHoistableCtx;\n};\n\n/// Ordered container type to hold invariant accesses.\nusing InvariantAccessesTy = SmallVector<InvariantAccess, 8>;\n\n/// Type for equivalent invariant accesses and their domain context.\nstruct InvariantEquivClassTy {\n  /// The pointer that identifies this equivalence class\n  const SCEV *IdentifyingPointer;\n\n  /// Memory accesses now treated invariant\n  ///\n  /// These memory accesses access the pointer location that identifies\n  /// this equivalence class. They are treated as invariant and hoisted during\n  /// code generation.\n  MemoryAccessList InvariantAccesses;\n\n  /// The execution context under which the memory location is accessed\n  ///\n  /// It is the union of the execution domains of the memory accesses in the\n  /// InvariantAccesses list.\n  isl::set ExecutionContext;\n\n  /// The type of the invariant access\n  ///\n  /// It is used to differentiate between differently typed invariant loads from\n  /// the same location.\n  Type *AccessType;\n};\n\n/// Type for invariant accesses equivalence classes.\nusing InvariantEquivClassesTy = SmallVector<InvariantEquivClassTy, 8>;\n\n/// Statement of the Scop\n///\n/// A Scop statement represents an instruction in the Scop.\n///\n/// It is further described by its iteration domain, its schedule and its data\n/// accesses.\n/// At the moment every statement represents a single basic block of LLVM-IR.\nclass ScopStmt {\n  friend class ScopBuilder;\n\npublic:\n  /// Create the ScopStmt from a BasicBlock.\n  ScopStmt(Scop &parent, BasicBlock &bb, StringRef Name, Loop *SurroundingLoop,\n           std::vector<Instruction *> Instructions);\n\n  /// Create an overapproximating ScopStmt for the region @p R.\n  ///\n  /// @param EntryBlockInstructions The list of instructions that belong to the\n  ///                               entry block of the region statement.\n  ///                               Instructions are only tracked for entry\n  ///                               blocks for now. We currently do not allow\n  ///                               to modify the instructions of blocks later\n  ///                               in the region statement.\n  ScopStmt(Scop &parent, Region &R, StringRef Name, Loop *SurroundingLoop,\n           std::vector<Instruction *> EntryBlockInstructions);\n\n  /// Create a copy statement.\n  ///\n  /// @param Stmt       The parent statement.\n  /// @param SourceRel  The source location.\n  /// @param TargetRel  The target location.\n  /// @param Domain     The original domain under which the copy statement would\n  ///                   be executed.\n  ScopStmt(Scop &parent, isl::map SourceRel, isl::map TargetRel,\n           isl::set Domain);\n\n  ScopStmt(const ScopStmt &) = delete;\n  const ScopStmt &operator=(const ScopStmt &) = delete;\n  ~ScopStmt();\n\nprivate:\n  /// Polyhedral description\n  //@{\n\n  /// The Scop containing this ScopStmt.\n  Scop &Parent;\n\n  /// The domain under which this statement is not modeled precisely.\n  ///\n  /// The invalid domain for a statement describes all parameter combinations\n  /// under which the statement looks to be executed but is in fact not because\n  /// some assumption/restriction makes the statement/scop invalid.\n  isl::set InvalidDomain;\n\n  /// The iteration domain describes the set of iterations for which this\n  /// statement is executed.\n  ///\n  /// Example:\n  ///     for (i = 0; i < 100 + b; ++i)\n  ///       for (j = 0; j < i; ++j)\n  ///         S(i,j);\n  ///\n  /// 'S' is executed for different values of i and j. A vector of all\n  /// induction variables around S (i, j) is called iteration vector.\n  /// The domain describes the set of possible iteration vectors.\n  ///\n  /// In this case it is:\n  ///\n  ///     Domain: 0 <= i <= 100 + b\n  ///             0 <= j <= i\n  ///\n  /// A pair of statement and iteration vector (S, (5,3)) is called statement\n  /// instance.\n  isl::set Domain;\n\n  /// The memory accesses of this statement.\n  ///\n  /// The only side effects of a statement are its memory accesses.\n  using MemoryAccessVec = llvm::SmallVector<MemoryAccess *, 8>;\n  MemoryAccessVec MemAccs;\n\n  /// Mapping from instructions to (scalar) memory accesses.\n  DenseMap<const Instruction *, MemoryAccessList> InstructionToAccess;\n\n  /// The set of values defined elsewhere required in this ScopStmt and\n  ///        their MemoryKind::Value READ MemoryAccesses.\n  DenseMap<Value *, MemoryAccess *> ValueReads;\n\n  /// The set of values defined in this ScopStmt that are required\n  ///        elsewhere, mapped to their MemoryKind::Value WRITE MemoryAccesses.\n  DenseMap<Instruction *, MemoryAccess *> ValueWrites;\n\n  /// Map from PHI nodes to its incoming value when coming from this\n  ///        statement.\n  ///\n  /// Non-affine subregions can have multiple exiting blocks that are incoming\n  /// blocks of the PHI nodes. This map ensures that there is only one write\n  /// operation for the complete subregion. A PHI selecting the relevant value\n  /// will be inserted.\n  DenseMap<PHINode *, MemoryAccess *> PHIWrites;\n\n  /// Map from PHI nodes to its read access in this statement.\n  DenseMap<PHINode *, MemoryAccess *> PHIReads;\n\n  //@}\n\n  /// A SCoP statement represents either a basic block (affine/precise case) or\n  /// a whole region (non-affine case).\n  ///\n  /// Only one of the following two members will therefore be set and indicate\n  /// which kind of statement this is.\n  ///\n  ///{\n\n  /// The BasicBlock represented by this statement (in the affine case).\n  BasicBlock *BB = nullptr;\n\n  /// The region represented by this statement (in the non-affine case).\n  Region *R = nullptr;\n\n  ///}\n\n  /// The isl AST build for the new generated AST.\n  isl::ast_build Build;\n\n  SmallVector<Loop *, 4> NestLoops;\n\n  std::string BaseName;\n\n  /// The closest loop that contains this statement.\n  Loop *SurroundingLoop;\n\n  /// Vector for Instructions in this statement.\n  std::vector<Instruction *> Instructions;\n\n  /// Remove @p MA from dictionaries pointing to them.\n  void removeAccessData(MemoryAccess *MA);\n\npublic:\n  /// Get an isl_ctx pointer.\n  isl::ctx getIslCtx() const;\n\n  /// Get the iteration domain of this ScopStmt.\n  ///\n  /// @return The iteration domain of this ScopStmt.\n  isl::set getDomain() const;\n\n  /// Get the space of the iteration domain\n  ///\n  /// @return The space of the iteration domain\n  isl::space getDomainSpace() const;\n\n  /// Get the id of the iteration domain space\n  ///\n  /// @return The id of the iteration domain space\n  isl::id getDomainId() const;\n\n  /// Get an isl string representing this domain.\n  std::string getDomainStr() const;\n\n  /// Get the schedule function of this ScopStmt.\n  ///\n  /// @return The schedule function of this ScopStmt, if it does not contain\n  /// extension nodes, and nullptr, otherwise.\n  isl::map getSchedule() const;\n\n  /// Get an isl string representing this schedule.\n  ///\n  /// @return An isl string representing this schedule, if it does not contain\n  /// extension nodes, and an empty string, otherwise.\n  std::string getScheduleStr() const;\n\n  /// Get the invalid domain for this statement.\n  isl::set getInvalidDomain() const { return InvalidDomain; }\n\n  /// Get the invalid context for this statement.\n  isl::set getInvalidContext() const { return getInvalidDomain().params(); }\n\n  /// Set the invalid context for this statement to @p ID.\n  void setInvalidDomain(isl::set ID);\n\n  /// Get the BasicBlock represented by this ScopStmt (if any).\n  ///\n  /// @return The BasicBlock represented by this ScopStmt, or null if the\n  ///         statement represents a region.\n  BasicBlock *getBasicBlock() const { return BB; }\n\n  /// Return true if this statement represents a single basic block.\n  bool isBlockStmt() const { return BB != nullptr; }\n\n  /// Return true if this is a copy statement.\n  bool isCopyStmt() const { return BB == nullptr && R == nullptr; }\n\n  /// Get the region represented by this ScopStmt (if any).\n  ///\n  /// @return The region represented by this ScopStmt, or null if the statement\n  ///         represents a basic block.\n  Region *getRegion() const { return R; }\n\n  /// Return true if this statement represents a whole region.\n  bool isRegionStmt() const { return R != nullptr; }\n\n  /// Return a BasicBlock from this statement.\n  ///\n  /// For block statements, it returns the BasicBlock itself. For subregion\n  /// statements, return its entry block.\n  BasicBlock *getEntryBlock() const;\n\n  /// Return whether @p L is boxed within this statement.\n  bool contains(const Loop *L) const {\n    // Block statements never contain loops.\n    if (isBlockStmt())\n      return false;\n\n    return getRegion()->contains(L);\n  }\n\n  /// Return whether this statement represents @p BB.\n  bool represents(BasicBlock *BB) const {\n    if (isCopyStmt())\n      return false;\n    if (isBlockStmt())\n      return BB == getBasicBlock();\n    return getRegion()->contains(BB);\n  }\n\n  /// Return whether this statement contains @p Inst.\n  bool contains(Instruction *Inst) const {\n    if (!Inst)\n      return false;\n    if (isBlockStmt())\n      return std::find(Instructions.begin(), Instructions.end(), Inst) !=\n             Instructions.end();\n    return represents(Inst->getParent());\n  }\n\n  /// Return the closest innermost loop that contains this statement, but is not\n  /// contained in it.\n  ///\n  /// For block statement, this is just the loop that contains the block. Region\n  /// statements can contain boxed loops, so getting the loop of one of the\n  /// region's BBs might return such an inner loop. For instance, the region's\n  /// entry could be a header of a loop, but the region might extend to BBs\n  /// after the loop exit. Similarly, the region might only contain parts of the\n  /// loop body and still include the loop header.\n  ///\n  /// Most of the time the surrounding loop is the top element of #NestLoops,\n  /// except when it is empty. In that case it return the loop that the whole\n  /// SCoP is contained in. That can be nullptr if there is no such loop.\n  Loop *getSurroundingLoop() const {\n    assert(!isCopyStmt() &&\n           \"No surrounding loop for artificially created statements\");\n    return SurroundingLoop;\n  }\n\n  /// Return true if this statement does not contain any accesses.\n  bool isEmpty() const { return MemAccs.empty(); }\n\n  /// Find all array accesses for @p Inst.\n  ///\n  /// @param Inst The instruction accessing an array.\n  ///\n  /// @return A list of array accesses (MemoryKind::Array) accessed by @p Inst.\n  ///         If there is no such access, it returns nullptr.\n  const MemoryAccessList *\n  lookupArrayAccessesFor(const Instruction *Inst) const {\n    auto It = InstructionToAccess.find(Inst);\n    if (It == InstructionToAccess.end())\n      return nullptr;\n    if (It->second.empty())\n      return nullptr;\n    return &It->second;\n  }\n\n  /// Return the only array access for @p Inst, if existing.\n  ///\n  /// @param Inst The instruction for which to look up the access.\n  /// @returns The unique array memory access related to Inst or nullptr if\n  ///          no array access exists\n  MemoryAccess *getArrayAccessOrNULLFor(const Instruction *Inst) const {\n    auto It = InstructionToAccess.find(Inst);\n    if (It == InstructionToAccess.end())\n      return nullptr;\n\n    MemoryAccess *ArrayAccess = nullptr;\n\n    for (auto Access : It->getSecond()) {\n      if (!Access->isArrayKind())\n        continue;\n\n      assert(!ArrayAccess && \"More then one array access for instruction\");\n\n      ArrayAccess = Access;\n    }\n\n    return ArrayAccess;\n  }\n\n  /// Return the only array access for @p Inst.\n  ///\n  /// @param Inst The instruction for which to look up the access.\n  /// @returns The unique array memory access related to Inst.\n  MemoryAccess &getArrayAccessFor(const Instruction *Inst) const {\n    MemoryAccess *ArrayAccess = getArrayAccessOrNULLFor(Inst);\n\n    assert(ArrayAccess && \"No array access found for instruction!\");\n    return *ArrayAccess;\n  }\n\n  /// Return the MemoryAccess that writes the value of an instruction\n  ///        defined in this statement, or nullptr if not existing, respectively\n  ///        not yet added.\n  MemoryAccess *lookupValueWriteOf(Instruction *Inst) const {\n    assert((isRegionStmt() && R->contains(Inst)) ||\n           (!isRegionStmt() && Inst->getParent() == BB));\n    return ValueWrites.lookup(Inst);\n  }\n\n  /// Return the MemoryAccess that reloads a value, or nullptr if not\n  ///        existing, respectively not yet added.\n  MemoryAccess *lookupValueReadOf(Value *Inst) const {\n    return ValueReads.lookup(Inst);\n  }\n\n  /// Return the MemoryAccess that loads a PHINode value, or nullptr if not\n  /// existing, respectively not yet added.\n  MemoryAccess *lookupPHIReadOf(PHINode *PHI) const {\n    return PHIReads.lookup(PHI);\n  }\n\n  /// Return the PHI write MemoryAccess for the incoming values from any\n  ///        basic block in this ScopStmt, or nullptr if not existing,\n  ///        respectively not yet added.\n  MemoryAccess *lookupPHIWriteOf(PHINode *PHI) const {\n    assert(isBlockStmt() || R->getExit() == PHI->getParent());\n    return PHIWrites.lookup(PHI);\n  }\n\n  /// Return the input access of the value, or null if no such MemoryAccess\n  /// exists.\n  ///\n  /// The input access is the MemoryAccess that makes an inter-statement value\n  /// available in this statement by reading it at the start of this statement.\n  /// This can be a MemoryKind::Value if defined in another statement or a\n  /// MemoryKind::PHI if the value is a PHINode in this statement.\n  MemoryAccess *lookupInputAccessOf(Value *Val) const {\n    if (isa<PHINode>(Val))\n      if (auto InputMA = lookupPHIReadOf(cast<PHINode>(Val))) {\n        assert(!lookupValueReadOf(Val) && \"input accesses must be unique; a \"\n                                          \"statement cannot read a .s2a and \"\n                                          \".phiops simultaneously\");\n        return InputMA;\n      }\n\n    if (auto *InputMA = lookupValueReadOf(Val))\n      return InputMA;\n\n    return nullptr;\n  }\n\n  /// Add @p Access to this statement's list of accesses.\n  ///\n  /// @param Access  The access to add.\n  /// @param Prepend If true, will add @p Access before all other instructions\n  ///                (instead of appending it).\n  void addAccess(MemoryAccess *Access, bool Preprend = false);\n\n  /// Remove a MemoryAccess from this statement.\n  ///\n  /// Note that scalar accesses that are caused by MA will\n  /// be eliminated too.\n  void removeMemoryAccess(MemoryAccess *MA);\n\n  /// Remove @p MA from this statement.\n  ///\n  /// In contrast to removeMemoryAccess(), no other access will be eliminated.\n  ///\n  /// @param MA            The MemoryAccess to be removed.\n  /// @param AfterHoisting If true, also remove from data access lists.\n  ///                      These lists are filled during\n  ///                      ScopBuilder::buildAccessRelations. Therefore, if this\n  ///                      method is called before buildAccessRelations, false\n  ///                      must be passed.\n  void removeSingleMemoryAccess(MemoryAccess *MA, bool AfterHoisting = true);\n\n  using iterator = MemoryAccessVec::iterator;\n  using const_iterator = MemoryAccessVec::const_iterator;\n\n  iterator begin() { return MemAccs.begin(); }\n  iterator end() { return MemAccs.end(); }\n  const_iterator begin() const { return MemAccs.begin(); }\n  const_iterator end() const { return MemAccs.end(); }\n  size_t size() const { return MemAccs.size(); }\n\n  unsigned getNumIterators() const;\n\n  Scop *getParent() { return &Parent; }\n  const Scop *getParent() const { return &Parent; }\n\n  const std::vector<Instruction *> &getInstructions() const {\n    return Instructions;\n  }\n\n  /// Set the list of instructions for this statement. It replaces the current\n  /// list.\n  void setInstructions(ArrayRef<Instruction *> Range) {\n    Instructions.assign(Range.begin(), Range.end());\n  }\n\n  std::vector<Instruction *>::const_iterator insts_begin() const {\n    return Instructions.begin();\n  }\n\n  std::vector<Instruction *>::const_iterator insts_end() const {\n    return Instructions.end();\n  }\n\n  /// The range of instructions in this statement.\n  iterator_range<std::vector<Instruction *>::const_iterator> insts() const {\n    return {insts_begin(), insts_end()};\n  }\n\n  /// Insert an instruction before all other instructions in this statement.\n  void prependInstruction(Instruction *Inst) {\n    Instructions.insert(Instructions.begin(), Inst);\n  }\n\n  const char *getBaseName() const;\n\n  /// Set the isl AST build.\n  void setAstBuild(isl::ast_build B) { Build = B; }\n\n  /// Get the isl AST build.\n  isl::ast_build getAstBuild() const { return Build; }\n\n  /// Restrict the domain of the statement.\n  ///\n  /// @param NewDomain The new statement domain.\n  void restrictDomain(isl::set NewDomain);\n\n  /// Get the loop for a dimension.\n  ///\n  /// @param Dimension The dimension of the induction variable\n  /// @return The loop at a certain dimension.\n  Loop *getLoopForDimension(unsigned Dimension) const;\n\n  /// Align the parameters in the statement to the scop context\n  void realignParams();\n\n  /// Print the ScopStmt.\n  ///\n  /// @param OS                The output stream the ScopStmt is printed to.\n  /// @param PrintInstructions Whether to print the statement's instructions as\n  ///                          well.\n  void print(raw_ostream &OS, bool PrintInstructions) const;\n\n  /// Print the instructions in ScopStmt.\n  ///\n  void printInstructions(raw_ostream &OS) const;\n\n  /// Check whether there is a value read access for @p V in this statement, and\n  /// if not, create one.\n  ///\n  /// This allows to add MemoryAccesses after the initial creation of the Scop\n  /// by ScopBuilder.\n  ///\n  /// @return The already existing or newly created MemoryKind::Value READ\n  /// MemoryAccess.\n  ///\n  /// @see ScopBuilder::ensureValueRead(Value*,ScopStmt*)\n  MemoryAccess *ensureValueRead(Value *V);\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  /// Print the ScopStmt to stderr.\n  void dump() const;\n#endif\n};\n\n/// Print ScopStmt S to raw_ostream OS.\nraw_ostream &operator<<(raw_ostream &OS, const ScopStmt &S);\n\n/// Build the conditions sets for the branch condition @p Condition in\n/// the @p Domain.\n///\n/// This will fill @p ConditionSets with the conditions under which control\n/// will be moved from @p TI to its successors. Hence, @p ConditionSets will\n/// have as many elements as @p TI has successors. If @p TI is nullptr the\n/// context under which @p Condition is true/false will be returned as the\n/// new elements of @p ConditionSets.\nbool buildConditionSets(Scop &S, BasicBlock *BB, Value *Condition,\n                        Instruction *TI, Loop *L, __isl_keep isl_set *Domain,\n                        DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                        SmallVectorImpl<__isl_give isl_set *> &ConditionSets);\n\n/// Build condition sets for unsigned ICmpInst(s).\n/// Special handling is required for unsigned operands to ensure that if\n/// MSB (aka the Sign bit) is set for an operands in an unsigned ICmpInst\n/// it should wrap around.\n///\n/// @param IsStrictUpperBound holds information on the predicate relation\n/// between TestVal and UpperBound, i.e,\n/// TestVal < UpperBound  OR  TestVal <= UpperBound\n__isl_give isl_set *\nbuildUnsignedConditionSets(Scop &S, BasicBlock *BB, Value *Condition,\n                           __isl_keep isl_set *Domain, const SCEV *SCEV_TestVal,\n                           const SCEV *SCEV_UpperBound,\n                           DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                           bool IsStrictUpperBound);\n\n/// Build the conditions sets for the terminator @p TI in the @p Domain.\n///\n/// This will fill @p ConditionSets with the conditions under which control\n/// will be moved from @p TI to its successors. Hence, @p ConditionSets will\n/// have as many elements as @p TI has successors.\nbool buildConditionSets(Scop &S, BasicBlock *BB, Instruction *TI, Loop *L,\n                        __isl_keep isl_set *Domain,\n                        DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                        SmallVectorImpl<__isl_give isl_set *> &ConditionSets);\n\n/// Static Control Part\n///\n/// A Scop is the polyhedral representation of a control flow region detected\n/// by the Scop detection. It is generated by translating the LLVM-IR and\n/// abstracting its effects.\n///\n/// A Scop consists of a set of:\n///\n///   * A set of statements executed in the Scop.\n///\n///   * A set of global parameters\n///   Those parameters are scalar integer values, which are constant during\n///   execution.\n///\n///   * A context\n///   This context contains information about the values the parameters\n///   can take and relations between different parameters.\nclass Scop {\npublic:\n  /// Type to represent a pair of minimal/maximal access to an array.\n  using MinMaxAccessTy = std::pair<isl::pw_multi_aff, isl::pw_multi_aff>;\n\n  /// Vector of minimal/maximal accesses to different arrays.\n  using MinMaxVectorTy = SmallVector<MinMaxAccessTy, 4>;\n\n  /// Pair of minimal/maximal access vectors representing\n  /// read write and read only accesses\n  using MinMaxVectorPairTy = std::pair<MinMaxVectorTy, MinMaxVectorTy>;\n\n  /// Vector of pair of minimal/maximal access vectors representing\n  /// non read only and read only accesses for each alias group.\n  using MinMaxVectorPairVectorTy = SmallVector<MinMaxVectorPairTy, 4>;\n\nprivate:\n  friend class ScopBuilder;\n\n  /// Isl context.\n  ///\n  /// We need a shared_ptr with reference counter to delete the context when all\n  /// isl objects are deleted. We will distribute the shared_ptr to all objects\n  /// that use the context to create isl objects, and increase the reference\n  /// counter. By doing this, we guarantee that the context is deleted when we\n  /// delete the last object that creates isl objects with the context. This\n  /// declaration needs to be the first in class to gracefully destroy all isl\n  /// objects before the context.\n  std::shared_ptr<isl_ctx> IslCtx;\n\n  ScalarEvolution *SE;\n  DominatorTree *DT;\n\n  /// The underlying Region.\n  Region &R;\n\n  /// The name of the SCoP (identical to the regions name)\n  Optional<std::string> name;\n\n  // Access functions of the SCoP.\n  //\n  // This owns all the MemoryAccess objects of the Scop created in this pass.\n  AccFuncVector AccessFunctions;\n\n  /// Flag to indicate that the scheduler actually optimized the SCoP.\n  bool IsOptimized = false;\n\n  /// True if the underlying region has a single exiting block.\n  bool HasSingleExitEdge;\n\n  /// Flag to remember if the SCoP contained an error block or not.\n  bool HasErrorBlock = false;\n\n  /// Max loop depth.\n  unsigned MaxLoopDepth = 0;\n\n  /// Number of copy statements.\n  unsigned CopyStmtsNum = 0;\n\n  /// Flag to indicate if the Scop is to be skipped.\n  bool SkipScop = false;\n\n  using StmtSet = std::list<ScopStmt>;\n\n  /// The statements in this Scop.\n  StmtSet Stmts;\n\n  /// Parameters of this Scop\n  ParameterSetTy Parameters;\n\n  /// Mapping from parameters to their ids.\n  DenseMap<const SCEV *, isl::id> ParameterIds;\n\n  /// The context of the SCoP created during SCoP detection.\n  ScopDetection::DetectionContext &DC;\n\n  /// OptimizationRemarkEmitter object for displaying diagnostic remarks\n  OptimizationRemarkEmitter &ORE;\n\n  /// A map from basic blocks to vector of SCoP statements. Currently this\n  /// vector comprises only of a single statement.\n  DenseMap<BasicBlock *, std::vector<ScopStmt *>> StmtMap;\n\n  /// A map from instructions to SCoP statements.\n  DenseMap<Instruction *, ScopStmt *> InstStmtMap;\n\n  /// A map from basic blocks to their domains.\n  DenseMap<BasicBlock *, isl::set> DomainMap;\n\n  /// Constraints on parameters.\n  isl::set Context = nullptr;\n\n  /// The affinator used to translate SCEVs to isl expressions.\n  SCEVAffinator Affinator;\n\n  using ArrayInfoMapTy =\n      std::map<std::pair<AssertingVH<const Value>, MemoryKind>,\n               std::unique_ptr<ScopArrayInfo>>;\n\n  using ArrayNameMapTy = StringMap<std::unique_ptr<ScopArrayInfo>>;\n\n  using ArrayInfoSetTy = SetVector<ScopArrayInfo *>;\n\n  /// A map to remember ScopArrayInfo objects for all base pointers.\n  ///\n  /// As PHI nodes may have two array info objects associated, we add a flag\n  /// that distinguishes between the PHI node specific ArrayInfo object\n  /// and the normal one.\n  ArrayInfoMapTy ScopArrayInfoMap;\n\n  /// A map to remember ScopArrayInfo objects for all names of memory\n  ///        references.\n  ArrayNameMapTy ScopArrayNameMap;\n\n  /// A set to remember ScopArrayInfo objects.\n  /// @see Scop::ScopArrayInfoMap\n  ArrayInfoSetTy ScopArrayInfoSet;\n\n  /// The assumptions under which this scop was built.\n  ///\n  /// When constructing a scop sometimes the exact representation of a statement\n  /// or condition would be very complex, but there is a common case which is a\n  /// lot simpler, but which is only valid under certain assumptions. The\n  /// assumed context records the assumptions taken during the construction of\n  /// this scop and that need to be code generated as a run-time test.\n  isl::set AssumedContext;\n\n  /// The restrictions under which this SCoP was built.\n  ///\n  /// The invalid context is similar to the assumed context as it contains\n  /// constraints over the parameters. However, while we need the constraints\n  /// in the assumed context to be \"true\" the constraints in the invalid context\n  /// need to be \"false\". Otherwise they behave the same.\n  isl::set InvalidContext;\n\n  /// The context under which the SCoP must have defined behavior. Optimizer and\n  /// code generator can assume that the SCoP will only be executed with\n  /// parameter values within this context. This might be either because we can\n  /// prove that other values are impossible or explicitly have undefined\n  /// behavior, such as due to no-wrap flags. If this becomes too complex, can\n  /// also be nullptr.\n  ///\n  /// In contrast to Scop::AssumedContext and Scop::InvalidContext, these do not\n  /// need to be checked at runtime.\n  ///\n  /// Scop::Context on the other side is an overapproximation and does not\n  /// include all requirements, but is always defined. However, there is still\n  /// no guarantee that there is no undefined behavior in\n  /// DefinedBehaviorContext.\n  isl::set DefinedBehaviorContext;\n\n  /// The schedule of the SCoP\n  ///\n  /// The schedule of the SCoP describes the execution order of the statements\n  /// in the scop by assigning each statement instance a possibly\n  /// multi-dimensional execution time. The schedule is stored as a tree of\n  /// schedule nodes.\n  ///\n  /// The most common nodes in a schedule tree are so-called band nodes. Band\n  /// nodes map statement instances into a multi dimensional schedule space.\n  /// This space can be seen as a multi-dimensional clock.\n  ///\n  /// Example:\n  ///\n  /// <S,(5,4)>  may be mapped to (5,4) by this schedule:\n  ///\n  /// s0 = i (Year of execution)\n  /// s1 = j (Day of execution)\n  ///\n  /// or to (9, 20) by this schedule:\n  ///\n  /// s0 = i + j (Year of execution)\n  /// s1 = 20 (Day of execution)\n  ///\n  /// The order statement instances are executed is defined by the\n  /// schedule vectors they are mapped to. A statement instance\n  /// <A, (i, j, ..)> is executed before a statement instance <B, (i', ..)>, if\n  /// the schedule vector of A is lexicographic smaller than the schedule\n  /// vector of B.\n  ///\n  /// Besides band nodes, schedule trees contain additional nodes that specify\n  /// a textual ordering between two subtrees or filter nodes that filter the\n  /// set of statement instances that will be scheduled in a subtree. There\n  /// are also several other nodes. A full description of the different nodes\n  /// in a schedule tree is given in the isl manual.\n  isl::schedule Schedule = nullptr;\n\n  /// Whether the schedule has been modified after derived from the CFG by\n  /// ScopBuilder.\n  bool ScheduleModified = false;\n\n  /// The set of minimal/maximal accesses for each alias group.\n  ///\n  /// When building runtime alias checks we look at all memory instructions and\n  /// build so called alias groups. Each group contains a set of accesses to\n  /// different base arrays which might alias with each other. However, between\n  /// alias groups there is no aliasing possible.\n  ///\n  /// In a program with int and float pointers annotated with tbaa information\n  /// we would probably generate two alias groups, one for the int pointers and\n  /// one for the float pointers.\n  ///\n  /// During code generation we will create a runtime alias check for each alias\n  /// group to ensure the SCoP is executed in an alias free environment.\n  MinMaxVectorPairVectorTy MinMaxAliasGroups;\n\n  /// Mapping from invariant loads to the representing invariant load of\n  ///        their equivalence class.\n  ValueToValueMap InvEquivClassVMap;\n\n  /// List of invariant accesses.\n  InvariantEquivClassesTy InvariantEquivClasses;\n\n  /// The smallest array index not yet assigned.\n  long ArrayIdx = 0;\n\n  /// The smallest statement index not yet assigned.\n  long StmtIdx = 0;\n\n  /// A number that uniquely represents a Scop within its function\n  const int ID;\n\n  /// Map of values to the MemoryAccess that writes its definition.\n  ///\n  /// There must be at most one definition per llvm::Instruction in a SCoP.\n  DenseMap<Value *, MemoryAccess *> ValueDefAccs;\n\n  /// Map of values to the MemoryAccess that reads a PHI.\n  DenseMap<PHINode *, MemoryAccess *> PHIReadAccs;\n\n  /// List of all uses (i.e. read MemoryAccesses) for a MemoryKind::Value\n  /// scalar.\n  DenseMap<const ScopArrayInfo *, SmallVector<MemoryAccess *, 4>> ValueUseAccs;\n\n  /// List of all incoming values (write MemoryAccess) of a MemoryKind::PHI or\n  /// MemoryKind::ExitPHI scalar.\n  DenseMap<const ScopArrayInfo *, SmallVector<MemoryAccess *, 4>>\n      PHIIncomingAccs;\n\n  /// Scop constructor; invoked from ScopBuilder::buildScop.\n  Scop(Region &R, ScalarEvolution &SE, LoopInfo &LI, DominatorTree &DT,\n       ScopDetection::DetectionContext &DC, OptimizationRemarkEmitter &ORE,\n       int ID);\n\n  //@}\n\n  /// Initialize this ScopBuilder.\n  void init(AAResults &AA, AssumptionCache &AC, DominatorTree &DT,\n            LoopInfo &LI);\n\n  /// Return the access for the base ptr of @p MA if any.\n  MemoryAccess *lookupBasePtrAccess(MemoryAccess *MA);\n\n  /// Create an id for @p Param and store it in the ParameterIds map.\n  void createParameterId(const SCEV *Param);\n\n  /// Build the Context of the Scop.\n  void buildContext();\n\n  /// Add the bounds of the parameters to the context.\n  void addParameterBounds();\n\n  /// Simplify the assumed and invalid context.\n  void simplifyContexts();\n\n  /// Create a new SCoP statement for @p BB.\n  ///\n  /// A new statement for @p BB will be created and added to the statement\n  /// vector\n  /// and map.\n  ///\n  /// @param BB              The basic block we build the statement for.\n  /// @param Name            The name of the new statement.\n  /// @param SurroundingLoop The loop the created statement is contained in.\n  /// @param Instructions    The instructions in the statement.\n  void addScopStmt(BasicBlock *BB, StringRef Name, Loop *SurroundingLoop,\n                   std::vector<Instruction *> Instructions);\n\n  /// Create a new SCoP statement for @p R.\n  ///\n  /// A new statement for @p R will be created and added to the statement vector\n  /// and map.\n  ///\n  /// @param R                      The region we build the statement for.\n  /// @param Name                   The name of the new statement.\n  /// @param SurroundingLoop        The loop the created statement is contained\n  ///                               in.\n  /// @param EntryBlockInstructions The (interesting) instructions in the\n  ///                               entry block of the region statement.\n  void addScopStmt(Region *R, StringRef Name, Loop *SurroundingLoop,\n                   std::vector<Instruction *> EntryBlockInstructions);\n\n  /// Removes @p Stmt from the StmtMap.\n  void removeFromStmtMap(ScopStmt &Stmt);\n\n  /// Removes all statements where the entry block of the statement does not\n  /// have a corresponding domain in the domain map (or it is empty).\n  void removeStmtNotInDomainMap();\n\n  /// Collect all memory access relations of a given type.\n  ///\n  /// @param Predicate A predicate function that returns true if an access is\n  ///                  of a given type.\n  ///\n  /// @returns The set of memory accesses in the scop that match the predicate.\n  isl::union_map\n  getAccessesOfType(std::function<bool(MemoryAccess &)> Predicate);\n\n  /// @name Helper functions for printing the Scop.\n  ///\n  //@{\n  void printContext(raw_ostream &OS) const;\n  void printArrayInfo(raw_ostream &OS) const;\n  void printStatements(raw_ostream &OS, bool PrintInstructions) const;\n  void printAliasAssumptions(raw_ostream &OS) const;\n  //@}\n\npublic:\n  Scop(const Scop &) = delete;\n  Scop &operator=(const Scop &) = delete;\n  ~Scop();\n\n  /// Increment actual number of aliasing assumptions taken\n  ///\n  /// @param Step    Number of new aliasing assumptions which should be added to\n  /// the number of already taken assumptions.\n  static void incrementNumberOfAliasingAssumptions(unsigned Step);\n\n  /// Get the count of copy statements added to this Scop.\n  ///\n  /// @return The count of copy statements added to this Scop.\n  unsigned getCopyStmtsNum() { return CopyStmtsNum; }\n\n  /// Create a new copy statement.\n  ///\n  /// A new statement will be created and added to the statement vector.\n  ///\n  /// @param Stmt       The parent statement.\n  /// @param SourceRel  The source location.\n  /// @param TargetRel  The target location.\n  /// @param Domain     The original domain under which the copy statement would\n  ///                   be executed.\n  ScopStmt *addScopStmt(isl::map SourceRel, isl::map TargetRel,\n                        isl::set Domain);\n\n  /// Add the access function to all MemoryAccess objects of the Scop\n  ///        created in this pass.\n  void addAccessFunction(MemoryAccess *Access) {\n    AccessFunctions.emplace_back(Access);\n\n    // Register value definitions.\n    if (Access->isWrite() && Access->isOriginalValueKind()) {\n      assert(!ValueDefAccs.count(Access->getAccessValue()) &&\n             \"there can be just one definition per value\");\n      ValueDefAccs[Access->getAccessValue()] = Access;\n    } else if (Access->isRead() && Access->isOriginalPHIKind()) {\n      PHINode *PHI = cast<PHINode>(Access->getAccessInstruction());\n      assert(!PHIReadAccs.count(PHI) &&\n             \"there can be just one PHI read per PHINode\");\n      PHIReadAccs[PHI] = Access;\n    }\n  }\n\n  /// Add metadata for @p Access.\n  void addAccessData(MemoryAccess *Access);\n\n  /// Add new invariant access equivalence class\n  void\n  addInvariantEquivClass(const InvariantEquivClassTy &InvariantEquivClass) {\n    InvariantEquivClasses.emplace_back(InvariantEquivClass);\n  }\n\n  /// Add mapping from invariant loads to the representing invariant load of\n  ///        their equivalence class.\n  void addInvariantLoadMapping(const Value *LoadInst, Value *ClassRep) {\n    InvEquivClassVMap[LoadInst] = ClassRep;\n  }\n\n  /// Remove the metadata stored for @p Access.\n  void removeAccessData(MemoryAccess *Access);\n\n  /// Return the scalar evolution.\n  ScalarEvolution *getSE() const;\n\n  /// Return the dominator tree.\n  DominatorTree *getDT() const { return DT; }\n\n  /// Return the LoopInfo used for this Scop.\n  LoopInfo *getLI() const { return Affinator.getLI(); }\n\n  /// Get the count of parameters used in this Scop.\n  ///\n  /// @return The count of parameters used in this Scop.\n  size_t getNumParams() const { return Parameters.size(); }\n\n  /// Return whether given SCEV is used as the parameter in this Scop.\n  bool isParam(const SCEV *Param) const { return Parameters.count(Param); }\n\n  /// Take a list of parameters and add the new ones to the scop.\n  void addParams(const ParameterSetTy &NewParameters);\n\n  /// Return an iterator range containing the scop parameters.\n  iterator_range<ParameterSetTy::iterator> parameters() const {\n    return make_range(Parameters.begin(), Parameters.end());\n  }\n\n  /// Return an iterator range containing invariant accesses.\n  iterator_range<InvariantEquivClassesTy::iterator> invariantEquivClasses() {\n    return make_range(InvariantEquivClasses.begin(),\n                      InvariantEquivClasses.end());\n  }\n\n  /// Return an iterator range containing all the MemoryAccess objects of the\n  /// Scop.\n  iterator_range<AccFuncVector::iterator> access_functions() {\n    return make_range(AccessFunctions.begin(), AccessFunctions.end());\n  }\n\n  /// Return whether this scop is empty, i.e. contains no statements that\n  /// could be executed.\n  bool isEmpty() const { return Stmts.empty(); }\n\n  StringRef getName() {\n    if (!name)\n      name = R.getNameStr();\n    return *name;\n  }\n\n  using array_iterator = ArrayInfoSetTy::iterator;\n  using const_array_iterator = ArrayInfoSetTy::const_iterator;\n  using array_range = iterator_range<ArrayInfoSetTy::iterator>;\n  using const_array_range = iterator_range<ArrayInfoSetTy::const_iterator>;\n\n  inline array_iterator array_begin() { return ScopArrayInfoSet.begin(); }\n\n  inline array_iterator array_end() { return ScopArrayInfoSet.end(); }\n\n  inline const_array_iterator array_begin() const {\n    return ScopArrayInfoSet.begin();\n  }\n\n  inline const_array_iterator array_end() const {\n    return ScopArrayInfoSet.end();\n  }\n\n  inline array_range arrays() {\n    return array_range(array_begin(), array_end());\n  }\n\n  inline const_array_range arrays() const {\n    return const_array_range(array_begin(), array_end());\n  }\n\n  /// Return the isl_id that represents a certain parameter.\n  ///\n  /// @param Parameter A SCEV that was recognized as a Parameter.\n  ///\n  /// @return The corresponding isl_id or NULL otherwise.\n  isl::id getIdForParam(const SCEV *Parameter) const;\n\n  /// Get the maximum region of this static control part.\n  ///\n  /// @return The maximum region of this static control part.\n  inline const Region &getRegion() const { return R; }\n  inline Region &getRegion() { return R; }\n\n  /// Return the function this SCoP is in.\n  Function &getFunction() const { return *R.getEntry()->getParent(); }\n\n  /// Check if @p L is contained in the SCoP.\n  bool contains(const Loop *L) const { return R.contains(L); }\n\n  /// Check if @p BB is contained in the SCoP.\n  bool contains(const BasicBlock *BB) const { return R.contains(BB); }\n\n  /// Check if @p I is contained in the SCoP.\n  bool contains(const Instruction *I) const { return R.contains(I); }\n\n  /// Return the unique exit block of the SCoP.\n  BasicBlock *getExit() const { return R.getExit(); }\n\n  /// Return the unique exiting block of the SCoP if any.\n  BasicBlock *getExitingBlock() const { return R.getExitingBlock(); }\n\n  /// Return the unique entry block of the SCoP.\n  BasicBlock *getEntry() const { return R.getEntry(); }\n\n  /// Return the unique entering block of the SCoP if any.\n  BasicBlock *getEnteringBlock() const { return R.getEnteringBlock(); }\n\n  /// Return true if @p BB is the exit block of the SCoP.\n  bool isExit(BasicBlock *BB) const { return getExit() == BB; }\n\n  /// Return a range of all basic blocks in the SCoP.\n  Region::block_range blocks() const { return R.blocks(); }\n\n  /// Return true if and only if @p BB dominates the SCoP.\n  bool isDominatedBy(const DominatorTree &DT, BasicBlock *BB) const;\n\n  /// Get the maximum depth of the loop.\n  ///\n  /// @return The maximum depth of the loop.\n  inline unsigned getMaxLoopDepth() const { return MaxLoopDepth; }\n\n  /// Return the invariant equivalence class for @p Val if any.\n  InvariantEquivClassTy *lookupInvariantEquivClass(Value *Val);\n\n  /// Return the set of invariant accesses.\n  InvariantEquivClassesTy &getInvariantAccesses() {\n    return InvariantEquivClasses;\n  }\n\n  /// Check if the scop has any invariant access.\n  bool hasInvariantAccesses() { return !InvariantEquivClasses.empty(); }\n\n  /// Mark the SCoP as optimized by the scheduler.\n  void markAsOptimized() { IsOptimized = true; }\n\n  /// Check if the SCoP has been optimized by the scheduler.\n  bool isOptimized() const { return IsOptimized; }\n\n  /// Mark the SCoP to be skipped by ScopPass passes.\n  void markAsToBeSkipped() { SkipScop = true; }\n\n  /// Check if the SCoP is to be skipped by ScopPass passes.\n  bool isToBeSkipped() const { return SkipScop; }\n\n  /// Return the ID of the Scop\n  int getID() const { return ID; }\n\n  /// Get the name of the entry and exit blocks of this Scop.\n  ///\n  /// These along with the function name can uniquely identify a Scop.\n  ///\n  /// @return std::pair whose first element is the entry name & second element\n  ///         is the exit name.\n  std::pair<std::string, std::string> getEntryExitStr() const;\n\n  /// Get the name of this Scop.\n  std::string getNameStr() const;\n\n  /// Get the constraint on parameter of this Scop.\n  ///\n  /// @return The constraint on parameter of this Scop.\n  isl::set getContext() const;\n\n  /// Return the context where execution behavior is defined. Might return\n  /// nullptr.\n  isl::set getDefinedBehaviorContext() const { return DefinedBehaviorContext; }\n\n  /// Return the define behavior context, or if not available, its approximation\n  /// from all other contexts.\n  isl::set getBestKnownDefinedBehaviorContext() const {\n    if (DefinedBehaviorContext)\n      return DefinedBehaviorContext;\n\n    return Context.intersect_params(AssumedContext).subtract(InvalidContext);\n  }\n\n  /// Return space of isl context parameters.\n  ///\n  /// Returns the set of context parameters that are currently constrained. In\n  /// case the full set of parameters is needed, see @getFullParamSpace.\n  isl::space getParamSpace() const;\n\n  /// Return the full space of parameters.\n  ///\n  /// getParamSpace will only return the parameters of the context that are\n  /// actually constrained, whereas getFullParamSpace will return all\n  //  parameters. This is useful in cases, where we need to ensure all\n  //  parameters are available, as certain isl functions will abort if this is\n  //  not the case.\n  isl::space getFullParamSpace() const;\n\n  /// Get the assumed context for this Scop.\n  ///\n  /// @return The assumed context of this Scop.\n  isl::set getAssumedContext() const;\n\n  /// Return true if the optimized SCoP can be executed.\n  ///\n  /// In addition to the runtime check context this will also utilize the domain\n  /// constraints to decide it the optimized version can actually be executed.\n  ///\n  /// @returns True if the optimized SCoP can be executed.\n  bool hasFeasibleRuntimeContext() const;\n\n  /// Check if the assumption in @p Set is trivial or not.\n  ///\n  /// @param Set  The relations between parameters that are assumed to hold.\n  /// @param Sign Enum to indicate if the assumptions in @p Set are positive\n  ///             (needed/assumptions) or negative (invalid/restrictions).\n  ///\n  /// @returns True if the assumption @p Set is not trivial.\n  bool isEffectiveAssumption(isl::set Set, AssumptionSign Sign);\n\n  /// Track and report an assumption.\n  ///\n  /// Use 'clang -Rpass-analysis=polly-scops' or 'opt\n  /// -pass-remarks-analysis=polly-scops' to output the assumptions.\n  ///\n  /// @param Kind The assumption kind describing the underlying cause.\n  /// @param Set  The relations between parameters that are assumed to hold.\n  /// @param Loc  The location in the source that caused this assumption.\n  /// @param Sign Enum to indicate if the assumptions in @p Set are positive\n  ///             (needed/assumptions) or negative (invalid/restrictions).\n  /// @param BB   The block in which this assumption was taken. Used to\n  ///             calculate hotness when emitting remark.\n  ///\n  /// @returns True if the assumption is not trivial.\n  bool trackAssumption(AssumptionKind Kind, isl::set Set, DebugLoc Loc,\n                       AssumptionSign Sign, BasicBlock *BB);\n\n  /// Add the conditions from @p Set (or subtract them if @p Sign is\n  /// AS_RESTRICTION) to the defined behaviour context.\n  void intersectDefinedBehavior(isl::set Set, AssumptionSign Sign);\n\n  /// Add assumptions to assumed context.\n  ///\n  /// The assumptions added will be assumed to hold during the execution of the\n  /// scop. However, as they are generally not statically provable, at code\n  /// generation time run-time checks will be generated that ensure the\n  /// assumptions hold.\n  ///\n  /// WARNING: We currently exploit in simplifyAssumedContext the knowledge\n  ///          that assumptions do not change the set of statement instances\n  ///          executed.\n  ///\n  /// @param Kind The assumption kind describing the underlying cause.\n  /// @param Set  The relations between parameters that are assumed to hold.\n  /// @param Loc  The location in the source that caused this assumption.\n  /// @param Sign Enum to indicate if the assumptions in @p Set are positive\n  ///             (needed/assumptions) or negative (invalid/restrictions).\n  /// @param BB   The block in which this assumption was taken. Used to\n  ///             calculate hotness when emitting remark.\n  /// @param RTC  Does the assumption require a runtime check?\n  void addAssumption(AssumptionKind Kind, isl::set Set, DebugLoc Loc,\n                     AssumptionSign Sign, BasicBlock *BB, bool RTC = true);\n\n  /// Mark the scop as invalid.\n  ///\n  /// This method adds an assumption to the scop that is always invalid. As a\n  /// result, the scop will not be optimized later on. This function is commonly\n  /// called when a condition makes it impossible (or too compile time\n  /// expensive) to process this scop any further.\n  ///\n  /// @param Kind The assumption kind describing the underlying cause.\n  /// @param Loc  The location in the source that triggered .\n  /// @param BB   The BasicBlock where it was triggered.\n  void invalidate(AssumptionKind Kind, DebugLoc Loc, BasicBlock *BB = nullptr);\n\n  /// Get the invalid context for this Scop.\n  ///\n  /// @return The invalid context of this Scop.\n  isl::set getInvalidContext() const;\n\n  /// Return true if and only if the InvalidContext is trivial (=empty).\n  bool hasTrivialInvalidContext() const { return InvalidContext.is_empty(); }\n\n  /// Return all alias groups for this SCoP.\n  const MinMaxVectorPairVectorTy &getAliasGroups() const {\n    return MinMaxAliasGroups;\n  }\n\n  void addAliasGroup(MinMaxVectorTy &MinMaxAccessesReadWrite,\n                     MinMaxVectorTy &MinMaxAccessesReadOnly) {\n    MinMaxAliasGroups.emplace_back();\n    MinMaxAliasGroups.back().first = MinMaxAccessesReadWrite;\n    MinMaxAliasGroups.back().second = MinMaxAccessesReadOnly;\n  }\n\n  /// Remove statements from the list of scop statements.\n  ///\n  /// @param ShouldDelete  A function that returns true if the statement passed\n  ///                      to it should be deleted.\n  /// @param AfterHoisting If true, also remove from data access lists.\n  ///                      These lists are filled during\n  ///                      ScopBuilder::buildAccessRelations. Therefore, if this\n  ///                      method is called before buildAccessRelations, false\n  ///                      must be passed.\n  void removeStmts(function_ref<bool(ScopStmt &)> ShouldDelete,\n                   bool AfterHoisting = true);\n\n  /// Get an isl string representing the context.\n  std::string getContextStr() const;\n\n  /// Get an isl string representing the assumed context.\n  std::string getAssumedContextStr() const;\n\n  /// Get an isl string representing the invalid context.\n  std::string getInvalidContextStr() const;\n\n  /// Return the list of ScopStmts that represent the given @p BB.\n  ArrayRef<ScopStmt *> getStmtListFor(BasicBlock *BB) const;\n\n  /// Get the statement to put a PHI WRITE into.\n  ///\n  /// @param U The operand of a PHINode.\n  ScopStmt *getIncomingStmtFor(const Use &U) const;\n\n  /// Return the last statement representing @p BB.\n  ///\n  /// Of the sequence of statements that represent a @p BB, this is the last one\n  /// to be executed. It is typically used to determine which instruction to add\n  /// a MemoryKind::PHI WRITE to. For this purpose, it is not strictly required\n  /// to be executed last, only that the incoming value is available in it.\n  ScopStmt *getLastStmtFor(BasicBlock *BB) const;\n\n  /// Return the ScopStmts that represents the Region @p R, or nullptr if\n  ///        it is not represented by any statement in this Scop.\n  ArrayRef<ScopStmt *> getStmtListFor(Region *R) const;\n\n  /// Return the ScopStmts that represents @p RN; can return nullptr if\n  ///        the RegionNode is not within the SCoP or has been removed due to\n  ///        simplifications.\n  ArrayRef<ScopStmt *> getStmtListFor(RegionNode *RN) const;\n\n  /// Return the ScopStmt an instruction belongs to, or nullptr if it\n  ///        does not belong to any statement in this Scop.\n  ScopStmt *getStmtFor(Instruction *Inst) const {\n    return InstStmtMap.lookup(Inst);\n  }\n\n  /// Return the number of statements in the SCoP.\n  size_t getSize() const { return Stmts.size(); }\n\n  /// @name Statements Iterators\n  ///\n  /// These iterators iterate over all statements of this Scop.\n  //@{\n  using iterator = StmtSet::iterator;\n  using const_iterator = StmtSet::const_iterator;\n\n  iterator begin() { return Stmts.begin(); }\n  iterator end() { return Stmts.end(); }\n  const_iterator begin() const { return Stmts.begin(); }\n  const_iterator end() const { return Stmts.end(); }\n\n  using reverse_iterator = StmtSet::reverse_iterator;\n  using const_reverse_iterator = StmtSet::const_reverse_iterator;\n\n  reverse_iterator rbegin() { return Stmts.rbegin(); }\n  reverse_iterator rend() { return Stmts.rend(); }\n  const_reverse_iterator rbegin() const { return Stmts.rbegin(); }\n  const_reverse_iterator rend() const { return Stmts.rend(); }\n  //@}\n\n  /// Return the set of required invariant loads.\n  const InvariantLoadsSetTy &getRequiredInvariantLoads() const {\n    return DC.RequiredILS;\n  }\n\n  /// Add @p LI to the set of required invariant loads.\n  void addRequiredInvariantLoad(LoadInst *LI) { DC.RequiredILS.insert(LI); }\n\n  /// Return the set of boxed (thus overapproximated) loops.\n  const BoxedLoopsSetTy &getBoxedLoops() const { return DC.BoxedLoopsSet; }\n\n  /// Return true if and only if @p R is a non-affine subregion.\n  bool isNonAffineSubRegion(const Region *R) {\n    return DC.NonAffineSubRegionSet.count(R);\n  }\n\n  const MapInsnToMemAcc &getInsnToMemAccMap() const { return DC.InsnToMemAcc; }\n\n  /// Return the (possibly new) ScopArrayInfo object for @p Access.\n  ///\n  /// @param ElementType The type of the elements stored in this array.\n  /// @param Kind        The kind of the array info object.\n  /// @param BaseName    The optional name of this memory reference.\n  ScopArrayInfo *getOrCreateScopArrayInfo(Value *BasePtr, Type *ElementType,\n                                          ArrayRef<const SCEV *> Sizes,\n                                          MemoryKind Kind,\n                                          const char *BaseName = nullptr);\n\n  /// Create an array and return the corresponding ScopArrayInfo object.\n  ///\n  /// @param ElementType The type of the elements stored in this array.\n  /// @param BaseName    The name of this memory reference.\n  /// @param Sizes       The sizes of dimensions.\n  ScopArrayInfo *createScopArrayInfo(Type *ElementType,\n                                     const std::string &BaseName,\n                                     const std::vector<unsigned> &Sizes);\n\n  /// Return the cached ScopArrayInfo object for @p BasePtr.\n  ///\n  /// @param BasePtr   The base pointer the object has been stored for.\n  /// @param Kind      The kind of array info object.\n  ///\n  /// @returns The ScopArrayInfo pointer or NULL if no such pointer is\n  ///          available.\n  ScopArrayInfo *getScopArrayInfoOrNull(Value *BasePtr, MemoryKind Kind);\n\n  /// Return the cached ScopArrayInfo object for @p BasePtr.\n  ///\n  /// @param BasePtr   The base pointer the object has been stored for.\n  /// @param Kind      The kind of array info object.\n  ///\n  /// @returns The ScopArrayInfo pointer (may assert if no such pointer is\n  ///          available).\n  ScopArrayInfo *getScopArrayInfo(Value *BasePtr, MemoryKind Kind);\n\n  /// Invalidate ScopArrayInfo object for base address.\n  ///\n  /// @param BasePtr The base pointer of the ScopArrayInfo object to invalidate.\n  /// @param Kind    The Kind of the ScopArrayInfo object.\n  void invalidateScopArrayInfo(Value *BasePtr, MemoryKind Kind) {\n    auto It = ScopArrayInfoMap.find(std::make_pair(BasePtr, Kind));\n    if (It == ScopArrayInfoMap.end())\n      return;\n    ScopArrayInfoSet.remove(It->second.get());\n    ScopArrayInfoMap.erase(It);\n  }\n\n  /// Set new isl context.\n  void setContext(isl::set NewContext);\n\n  /// Update maximal loop depth. If @p Depth is smaller than current value,\n  /// then maximal loop depth is not updated.\n  void updateMaxLoopDepth(unsigned Depth) {\n    MaxLoopDepth = std::max(MaxLoopDepth, Depth);\n  }\n\n  /// Align the parameters in the statement to the scop context\n  void realignParams();\n\n  /// Return true if this SCoP can be profitably optimized.\n  ///\n  /// @param ScalarsAreUnprofitable Never consider statements with scalar writes\n  ///                               as profitably optimizable.\n  ///\n  /// @return Whether this SCoP can be profitably optimized.\n  bool isProfitable(bool ScalarsAreUnprofitable) const;\n\n  /// Return true if the SCoP contained at least one error block.\n  bool hasErrorBlock() const { return HasErrorBlock; }\n\n  /// Notify SCoP that it contains an error block\n  void notifyErrorBlock() { HasErrorBlock = true; }\n\n  /// Return true if the underlying region has a single exiting block.\n  bool hasSingleExitEdge() const { return HasSingleExitEdge; }\n\n  /// Print the static control part.\n  ///\n  /// @param OS The output stream the static control part is printed to.\n  /// @param PrintInstructions Whether to print the statement's instructions as\n  ///                          well.\n  void print(raw_ostream &OS, bool PrintInstructions) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  /// Print the ScopStmt to stderr.\n  void dump() const;\n#endif\n\n  /// Get the isl context of this static control part.\n  ///\n  /// @return The isl context of this static control part.\n  isl::ctx getIslCtx() const;\n\n  /// Directly return the shared_ptr of the context.\n  const std::shared_ptr<isl_ctx> &getSharedIslCtx() const { return IslCtx; }\n\n  /// Compute the isl representation for the SCEV @p E\n  ///\n  /// @param E  The SCEV that should be translated.\n  /// @param BB An (optional) basic block in which the isl_pw_aff is computed.\n  ///           SCEVs known to not reference any loops in the SCoP can be\n  ///           passed without a @p BB.\n  /// @param NonNegative Flag to indicate the @p E has to be non-negative.\n  ///\n  /// Note that this function will always return a valid isl_pw_aff. However, if\n  /// the translation of @p E was deemed to complex the SCoP is invalidated and\n  /// a dummy value of appropriate dimension is returned. This allows to bail\n  /// for complex cases without \"error handling code\" needed on the users side.\n  PWACtx getPwAff(const SCEV *E, BasicBlock *BB = nullptr,\n                  bool NonNegative = false,\n                  RecordedAssumptionsTy *RecordedAssumptions = nullptr);\n\n  /// Compute the isl representation for the SCEV @p E\n  ///\n  /// This function is like @see Scop::getPwAff() but strips away the invalid\n  /// domain part associated with the piecewise affine function.\n  isl::pw_aff\n  getPwAffOnly(const SCEV *E, BasicBlock *BB = nullptr,\n               RecordedAssumptionsTy *RecordedAssumptions = nullptr);\n\n  /// Check if an <nsw> AddRec for the loop L is cached.\n  bool hasNSWAddRecForLoop(Loop *L) { return Affinator.hasNSWAddRecForLoop(L); }\n\n  /// Return the domain of @p Stmt.\n  ///\n  /// @param Stmt The statement for which the conditions should be returned.\n  isl::set getDomainConditions(const ScopStmt *Stmt) const;\n\n  /// Return the domain of @p BB.\n  ///\n  /// @param BB The block for which the conditions should be returned.\n  isl::set getDomainConditions(BasicBlock *BB) const;\n\n  /// Return the domain of @p BB. If it does not exist, create an empty one.\n  isl::set &getOrInitEmptyDomain(BasicBlock *BB) { return DomainMap[BB]; }\n\n  /// Check if domain is determined for @p BB.\n  bool isDomainDefined(BasicBlock *BB) const { return DomainMap.count(BB) > 0; }\n\n  /// Set domain for @p BB.\n  void setDomain(BasicBlock *BB, isl::set &Domain) { DomainMap[BB] = Domain; }\n\n  /// Get a union set containing the iteration domains of all statements.\n  isl::union_set getDomains() const;\n\n  /// Get a union map of all may-writes performed in the SCoP.\n  isl::union_map getMayWrites();\n\n  /// Get a union map of all must-writes performed in the SCoP.\n  isl::union_map getMustWrites();\n\n  /// Get a union map of all writes performed in the SCoP.\n  isl::union_map getWrites();\n\n  /// Get a union map of all reads performed in the SCoP.\n  isl::union_map getReads();\n\n  /// Get a union map of all memory accesses performed in the SCoP.\n  isl::union_map getAccesses();\n\n  /// Get a union map of all memory accesses performed in the SCoP.\n  ///\n  /// @param Array The array to which the accesses should belong.\n  isl::union_map getAccesses(ScopArrayInfo *Array);\n\n  /// Get the schedule of all the statements in the SCoP.\n  ///\n  /// @return The schedule of all the statements in the SCoP, if the schedule of\n  /// the Scop does not contain extension nodes, and nullptr, otherwise.\n  isl::union_map getSchedule() const;\n\n  /// Get a schedule tree describing the schedule of all statements.\n  isl::schedule getScheduleTree() const;\n\n  /// Update the current schedule\n  ///\n  /// NewSchedule The new schedule (given as a flat union-map).\n  void setSchedule(isl::union_map NewSchedule);\n\n  /// Update the current schedule\n  ///\n  /// NewSchedule The new schedule (given as schedule tree).\n  void setScheduleTree(isl::schedule NewSchedule);\n\n  /// Whether the schedule is the original schedule as derived from the CFG by\n  /// ScopBuilder.\n  bool isOriginalSchedule() const { return !ScheduleModified; }\n\n  /// Intersects the domains of all statements in the SCoP.\n  ///\n  /// @return true if a change was made\n  bool restrictDomains(isl::union_set Domain);\n\n  /// Get the depth of a loop relative to the outermost loop in the Scop.\n  ///\n  /// This will return\n  ///    0 if @p L is an outermost loop in the SCoP\n  ///   >0 for other loops in the SCoP\n  ///   -1 if @p L is nullptr or there is no outermost loop in the SCoP\n  int getRelativeLoopDepth(const Loop *L) const;\n\n  /// Find the ScopArrayInfo associated with an isl Id\n  ///        that has name @p Name.\n  ScopArrayInfo *getArrayInfoByName(const std::string BaseName);\n\n  /// Simplify the SCoP representation.\n  ///\n  /// @param AfterHoisting Whether it is called after invariant load hoisting.\n  ///                      When true, also removes statements without\n  ///                      side-effects.\n  void simplifySCoP(bool AfterHoisting);\n\n  /// Get the next free array index.\n  ///\n  /// This function returns a unique index which can be used to identify an\n  /// array.\n  long getNextArrayIdx() { return ArrayIdx++; }\n\n  /// Get the next free statement index.\n  ///\n  /// This function returns a unique index which can be used to identify a\n  /// statement.\n  long getNextStmtIdx() { return StmtIdx++; }\n\n  /// Get the representing SCEV for @p S if applicable, otherwise @p S.\n  ///\n  /// Invariant loads of the same location are put in an equivalence class and\n  /// only one of them is chosen as a representing element that will be\n  /// modeled as a parameter. The others have to be normalized, i.e.,\n  /// replaced by the representing element of their equivalence class, in order\n  /// to get the correct parameter value, e.g., in the SCEVAffinator.\n  ///\n  /// @param S The SCEV to normalize.\n  ///\n  /// @return The representing SCEV for invariant loads or @p S if none.\n  const SCEV *getRepresentingInvariantLoadSCEV(const SCEV *S) const;\n\n  /// Return the MemoryAccess that writes an llvm::Value, represented by a\n  /// ScopArrayInfo.\n  ///\n  /// There can be at most one such MemoryAccess per llvm::Value in the SCoP.\n  /// Zero is possible for read-only values.\n  MemoryAccess *getValueDef(const ScopArrayInfo *SAI) const;\n\n  /// Return all MemoryAccesses that us an llvm::Value, represented by a\n  /// ScopArrayInfo.\n  ArrayRef<MemoryAccess *> getValueUses(const ScopArrayInfo *SAI) const;\n\n  /// Return the MemoryAccess that represents an llvm::PHINode.\n  ///\n  /// ExitPHIs's PHINode is not within the SCoPs. This function returns nullptr\n  /// for them.\n  MemoryAccess *getPHIRead(const ScopArrayInfo *SAI) const;\n\n  /// Return all MemoryAccesses for all incoming statements of a PHINode,\n  /// represented by a ScopArrayInfo.\n  ArrayRef<MemoryAccess *> getPHIIncomings(const ScopArrayInfo *SAI) const;\n\n  /// Return whether @p Inst has a use outside of this SCoP.\n  bool isEscaping(Instruction *Inst);\n\n  struct ScopStatistics {\n    int NumAffineLoops = 0;\n    int NumBoxedLoops = 0;\n\n    int NumValueWrites = 0;\n    int NumValueWritesInLoops = 0;\n    int NumPHIWrites = 0;\n    int NumPHIWritesInLoops = 0;\n    int NumSingletonWrites = 0;\n    int NumSingletonWritesInLoops = 0;\n  };\n\n  /// Collect statistic about this SCoP.\n  ///\n  /// These are most commonly used for LLVM's static counters (Statistic.h) in\n  /// various places. If statistics are disabled, only zeros are returned to\n  /// avoid the overhead.\n  ScopStatistics getStatistics() const;\n};\n\n/// Print Scop scop to raw_ostream OS.\nraw_ostream &operator<<(raw_ostream &OS, const Scop &scop);\n\n/// The legacy pass manager's analysis pass to compute scop information\n///        for a region.\nclass ScopInfoRegionPass : public RegionPass {\n  /// The Scop pointer which is used to construct a Scop.\n  std::unique_ptr<Scop> S;\n\npublic:\n  static char ID; // Pass identification, replacement for typeid\n\n  ScopInfoRegionPass() : RegionPass(ID) {}\n  ~ScopInfoRegionPass() override = default;\n\n  /// Build Scop object, the Polly IR of static control\n  ///        part for the current SESE-Region.\n  ///\n  /// @return If the current region is a valid for a static control part,\n  ///         return the Polly IR representing this static control part,\n  ///         return null otherwise.\n  Scop *getScop() { return S.get(); }\n  const Scop *getScop() const { return S.get(); }\n\n  /// Calculate the polyhedral scop information for a given Region.\n  bool runOnRegion(Region *R, RGPassManager &RGM) override;\n\n  void releaseMemory() override { S.reset(); }\n\n  void print(raw_ostream &O, const Module *M = nullptr) const override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\nclass ScopInfo {\npublic:\n  using RegionToScopMapTy = MapVector<Region *, std::unique_ptr<Scop>>;\n  using reverse_iterator = RegionToScopMapTy::reverse_iterator;\n  using const_reverse_iterator = RegionToScopMapTy::const_reverse_iterator;\n  using iterator = RegionToScopMapTy::iterator;\n  using const_iterator = RegionToScopMapTy::const_iterator;\n\nprivate:\n  /// A map of Region to its Scop object containing\n  ///        Polly IR of static control part.\n  RegionToScopMapTy RegionToScopMap;\n  const DataLayout &DL;\n  ScopDetection &SD;\n  ScalarEvolution &SE;\n  LoopInfo &LI;\n  AAResults &AA;\n  DominatorTree &DT;\n  AssumptionCache &AC;\n  OptimizationRemarkEmitter &ORE;\n\npublic:\n  ScopInfo(const DataLayout &DL, ScopDetection &SD, ScalarEvolution &SE,\n           LoopInfo &LI, AAResults &AA, DominatorTree &DT, AssumptionCache &AC,\n           OptimizationRemarkEmitter &ORE);\n\n  /// Get the Scop object for the given Region.\n  ///\n  /// @return If the given region is the maximal region within a scop, return\n  ///         the scop object. If the given region is a subregion, return a\n  ///         nullptr. Top level region containing the entry block of a function\n  ///         is not considered in the scop creation.\n  Scop *getScop(Region *R) const {\n    auto MapIt = RegionToScopMap.find(R);\n    if (MapIt != RegionToScopMap.end())\n      return MapIt->second.get();\n    return nullptr;\n  }\n\n  /// Recompute the Scop-Information for a function.\n  ///\n  /// This invalidates any iterators.\n  void recompute();\n\n  /// Handle invalidation explicitly\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &Inv);\n\n  iterator begin() { return RegionToScopMap.begin(); }\n  iterator end() { return RegionToScopMap.end(); }\n  const_iterator begin() const { return RegionToScopMap.begin(); }\n  const_iterator end() const { return RegionToScopMap.end(); }\n  reverse_iterator rbegin() { return RegionToScopMap.rbegin(); }\n  reverse_iterator rend() { return RegionToScopMap.rend(); }\n  const_reverse_iterator rbegin() const { return RegionToScopMap.rbegin(); }\n  const_reverse_iterator rend() const { return RegionToScopMap.rend(); }\n  bool empty() const { return RegionToScopMap.empty(); }\n};\n\nstruct ScopInfoAnalysis : public AnalysisInfoMixin<ScopInfoAnalysis> {\n  static AnalysisKey Key;\n\n  using Result = ScopInfo;\n\n  Result run(Function &, FunctionAnalysisManager &);\n};\n\nstruct ScopInfoPrinterPass : public PassInfoMixin<ScopInfoPrinterPass> {\n  ScopInfoPrinterPass(raw_ostream &OS) : Stream(OS) {}\n\n  PreservedAnalyses run(Function &, FunctionAnalysisManager &);\n\n  raw_ostream &Stream;\n};\n\n//===----------------------------------------------------------------------===//\n/// The legacy pass manager's analysis pass to compute scop information\n///        for the whole function.\n///\n/// This pass will maintain a map of the maximal region within a scop to its\n/// scop object for all the feasible scops present in a function.\n/// This pass is an alternative to the ScopInfoRegionPass in order to avoid a\n/// region pass manager.\nclass ScopInfoWrapperPass : public FunctionPass {\n  std::unique_ptr<ScopInfo> Result;\n\npublic:\n  ScopInfoWrapperPass() : FunctionPass(ID) {}\n  ~ScopInfoWrapperPass() override = default;\n\n  static char ID; // Pass identification, replacement for typeid\n\n  ScopInfo *getSI() { return Result.get(); }\n  const ScopInfo *getSI() const { return Result.get(); }\n\n  /// Calculate all the polyhedral scops for a given function.\n  bool runOnFunction(Function &F) override;\n\n  void releaseMemory() override { Result.reset(); }\n\n  void print(raw_ostream &O, const Module *M = nullptr) const override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n} // end namespace polly\n\n#endif // POLLY_SCOPINFO_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "content": "//===- ScopInfo.cpp -------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Create a polyhedral description for a static control flow region.\n//\n// The pass creates a polyhedral description of the Scops detected by the Scop\n// detection derived from their LLVM-IR code.\n//\n// This representation is shared among several tools in the polyhedral\n// community, which are e.g. Cloog, Pluto, Loopo, Graphite.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"polly/ScopInfo.h\"\n#include \"polly/LinkAllPasses.h\"\n#include \"polly/Options.h\"\n#include \"polly/ScopBuilder.h\"\n#include \"polly/ScopDetection.h\"\n#include \"polly/Support/GICHelper.h\"\n#include \"polly/Support/ISLOStream.h\"\n#include \"polly/Support/ISLTools.h\"\n#include \"polly/Support/SCEVAffinator.h\"\n#include \"polly/Support/SCEVValidator.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/ADT/Sequence.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/Loads.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n#include \"llvm/Analysis/RegionInfo.h\"\n#include \"llvm/Analysis/RegionIterator.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"isl/aff.h\"\n#include \"isl/local_space.h\"\n#include \"isl/map.h\"\n#include \"isl/options.h\"\n#include \"isl/set.h\"\n#include <cassert>\n\nusing namespace llvm;\nusing namespace polly;\n\n#define DEBUG_TYPE \"polly-scops\"\n\nSTATISTIC(AssumptionsAliasing, \"Number of aliasing assumptions taken.\");\nSTATISTIC(AssumptionsInbounds, \"Number of inbounds assumptions taken.\");\nSTATISTIC(AssumptionsWrapping, \"Number of wrapping assumptions taken.\");\nSTATISTIC(AssumptionsUnsigned, \"Number of unsigned assumptions taken.\");\nSTATISTIC(AssumptionsComplexity, \"Number of too complex SCoPs.\");\nSTATISTIC(AssumptionsUnprofitable, \"Number of unprofitable SCoPs.\");\nSTATISTIC(AssumptionsErrorBlock, \"Number of error block assumptions taken.\");\nSTATISTIC(AssumptionsInfiniteLoop, \"Number of bounded loop assumptions taken.\");\nSTATISTIC(AssumptionsInvariantLoad,\n          \"Number of invariant loads assumptions taken.\");\nSTATISTIC(AssumptionsDelinearization,\n          \"Number of delinearization assumptions taken.\");\n\nSTATISTIC(NumScops, \"Number of feasible SCoPs after ScopInfo\");\nSTATISTIC(NumLoopsInScop, \"Number of loops in scops\");\nSTATISTIC(NumBoxedLoops, \"Number of boxed loops in SCoPs after ScopInfo\");\nSTATISTIC(NumAffineLoops, \"Number of affine loops in SCoPs after ScopInfo\");\n\nSTATISTIC(NumScopsDepthZero, \"Number of scops with maximal loop depth 0\");\nSTATISTIC(NumScopsDepthOne, \"Number of scops with maximal loop depth 1\");\nSTATISTIC(NumScopsDepthTwo, \"Number of scops with maximal loop depth 2\");\nSTATISTIC(NumScopsDepthThree, \"Number of scops with maximal loop depth 3\");\nSTATISTIC(NumScopsDepthFour, \"Number of scops with maximal loop depth 4\");\nSTATISTIC(NumScopsDepthFive, \"Number of scops with maximal loop depth 5\");\nSTATISTIC(NumScopsDepthLarger,\n          \"Number of scops with maximal loop depth 6 and larger\");\nSTATISTIC(MaxNumLoopsInScop, \"Maximal number of loops in scops\");\n\nSTATISTIC(NumValueWrites, \"Number of scalar value writes after ScopInfo\");\nSTATISTIC(\n    NumValueWritesInLoops,\n    \"Number of scalar value writes nested in affine loops after ScopInfo\");\nSTATISTIC(NumPHIWrites, \"Number of scalar phi writes after ScopInfo\");\nSTATISTIC(NumPHIWritesInLoops,\n          \"Number of scalar phi writes nested in affine loops after ScopInfo\");\nSTATISTIC(NumSingletonWrites, \"Number of singleton writes after ScopInfo\");\nSTATISTIC(NumSingletonWritesInLoops,\n          \"Number of singleton writes nested in affine loops after ScopInfo\");\n\nint const polly::MaxDisjunctsInDomain = 20;\n\n// The number of disjunct in the context after which we stop to add more\n// disjuncts. This parameter is there to avoid exponential growth in the\n// number of disjunct when adding non-convex sets to the context.\nstatic int const MaxDisjunctsInContext = 4;\n\n// Be a bit more generous for the defined behavior context which is used less\n// often.\nstatic int const MaxDisjunktsInDefinedBehaviourContext = 8;\n\nstatic cl::opt<bool> PollyRemarksMinimal(\n    \"polly-remarks-minimal\",\n    cl::desc(\"Do not emit remarks about assumptions that are known\"),\n    cl::Hidden, cl::ZeroOrMore, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<bool>\n    IslOnErrorAbort(\"polly-on-isl-error-abort\",\n                    cl::desc(\"Abort if an isl error is encountered\"),\n                    cl::init(true), cl::cat(PollyCategory));\n\nstatic cl::opt<bool> PollyPreciseInbounds(\n    \"polly-precise-inbounds\",\n    cl::desc(\"Take more precise inbounds assumptions (do not scale well)\"),\n    cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<bool> PollyIgnoreParamBounds(\n    \"polly-ignore-parameter-bounds\",\n    cl::desc(\n        \"Do not add parameter bounds and do no gist simplify sets accordingly\"),\n    cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<bool> PollyPreciseFoldAccesses(\n    \"polly-precise-fold-accesses\",\n    cl::desc(\"Fold memory accesses to model more possible delinearizations \"\n             \"(does not scale well)\"),\n    cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nbool polly::UseInstructionNames;\n\nstatic cl::opt<bool, true> XUseInstructionNames(\n    \"polly-use-llvm-names\",\n    cl::desc(\"Use LLVM-IR names when deriving statement names\"),\n    cl::location(UseInstructionNames), cl::Hidden, cl::init(false),\n    cl::ZeroOrMore, cl::cat(PollyCategory));\n\nstatic cl::opt<bool> PollyPrintInstructions(\n    \"polly-print-instructions\", cl::desc(\"Output instructions per ScopStmt\"),\n    cl::Hidden, cl::Optional, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::list<std::string> IslArgs(\"polly-isl-arg\",\n                                     cl::value_desc(\"argument\"),\n                                     cl::desc(\"Option passed to ISL\"),\n                                     cl::ZeroOrMore, cl::cat(PollyCategory));\n\n//===----------------------------------------------------------------------===//\n\nstatic isl::set addRangeBoundsToSet(isl::set S, const ConstantRange &Range,\n                                    int dim, isl::dim type) {\n  isl::val V;\n  isl::ctx Ctx = S.get_ctx();\n\n  // The upper and lower bound for a parameter value is derived either from\n  // the data type of the parameter or from the - possibly more restrictive -\n  // range metadata.\n  V = valFromAPInt(Ctx.get(), Range.getSignedMin(), true);\n  S = S.lower_bound_val(type, dim, V);\n  V = valFromAPInt(Ctx.get(), Range.getSignedMax(), true);\n  S = S.upper_bound_val(type, dim, V);\n\n  if (Range.isFullSet())\n    return S;\n\n  if (S.n_basic_set() > MaxDisjunctsInContext)\n    return S;\n\n  // In case of signed wrapping, we can refine the set of valid values by\n  // excluding the part not covered by the wrapping range.\n  if (Range.isSignWrappedSet()) {\n    V = valFromAPInt(Ctx.get(), Range.getLower(), true);\n    isl::set SLB = S.lower_bound_val(type, dim, V);\n\n    V = valFromAPInt(Ctx.get(), Range.getUpper(), true);\n    V = V.sub_ui(1);\n    isl::set SUB = S.upper_bound_val(type, dim, V);\n    S = SLB.unite(SUB);\n  }\n\n  return S;\n}\n\nstatic const ScopArrayInfo *identifyBasePtrOriginSAI(Scop *S, Value *BasePtr) {\n  LoadInst *BasePtrLI = dyn_cast<LoadInst>(BasePtr);\n  if (!BasePtrLI)\n    return nullptr;\n\n  if (!S->contains(BasePtrLI))\n    return nullptr;\n\n  ScalarEvolution &SE = *S->getSE();\n\n  auto *OriginBaseSCEV =\n      SE.getPointerBase(SE.getSCEV(BasePtrLI->getPointerOperand()));\n  if (!OriginBaseSCEV)\n    return nullptr;\n\n  auto *OriginBaseSCEVUnknown = dyn_cast<SCEVUnknown>(OriginBaseSCEV);\n  if (!OriginBaseSCEVUnknown)\n    return nullptr;\n\n  return S->getScopArrayInfo(OriginBaseSCEVUnknown->getValue(),\n                             MemoryKind::Array);\n}\n\nScopArrayInfo::ScopArrayInfo(Value *BasePtr, Type *ElementType, isl::ctx Ctx,\n                             ArrayRef<const SCEV *> Sizes, MemoryKind Kind,\n                             const DataLayout &DL, Scop *S,\n                             const char *BaseName)\n    : BasePtr(BasePtr), ElementType(ElementType), Kind(Kind), DL(DL), S(*S) {\n  std::string BasePtrName =\n      BaseName ? BaseName\n               : getIslCompatibleName(\"MemRef\", BasePtr, S->getNextArrayIdx(),\n                                      Kind == MemoryKind::PHI ? \"__phi\" : \"\",\n                                      UseInstructionNames);\n  Id = isl::id::alloc(Ctx, BasePtrName, this);\n\n  updateSizes(Sizes);\n\n  if (!BasePtr || Kind != MemoryKind::Array) {\n    BasePtrOriginSAI = nullptr;\n    return;\n  }\n\n  BasePtrOriginSAI = identifyBasePtrOriginSAI(S, BasePtr);\n  if (BasePtrOriginSAI)\n    const_cast<ScopArrayInfo *>(BasePtrOriginSAI)->addDerivedSAI(this);\n}\n\nScopArrayInfo::~ScopArrayInfo() = default;\n\nisl::space ScopArrayInfo::getSpace() const {\n  auto Space = isl::space(Id.get_ctx(), 0, getNumberOfDimensions());\n  Space = Space.set_tuple_id(isl::dim::set, Id);\n  return Space;\n}\n\nbool ScopArrayInfo::isReadOnly() {\n  isl::union_set WriteSet = S.getWrites().range();\n  isl::space Space = getSpace();\n  WriteSet = WriteSet.extract_set(Space);\n\n  return bool(WriteSet.is_empty());\n}\n\nbool ScopArrayInfo::isCompatibleWith(const ScopArrayInfo *Array) const {\n  if (Array->getElementType() != getElementType())\n    return false;\n\n  if (Array->getNumberOfDimensions() != getNumberOfDimensions())\n    return false;\n\n  for (unsigned i = 0; i < getNumberOfDimensions(); i++)\n    if (Array->getDimensionSize(i) != getDimensionSize(i))\n      return false;\n\n  return true;\n}\n\nvoid ScopArrayInfo::updateElementType(Type *NewElementType) {\n  if (NewElementType == ElementType)\n    return;\n\n  auto OldElementSize = DL.getTypeAllocSizeInBits(ElementType);\n  auto NewElementSize = DL.getTypeAllocSizeInBits(NewElementType);\n\n  if (NewElementSize == OldElementSize || NewElementSize == 0)\n    return;\n\n  if (NewElementSize % OldElementSize == 0 && NewElementSize < OldElementSize) {\n    ElementType = NewElementType;\n  } else {\n    auto GCD = GreatestCommonDivisor64(NewElementSize, OldElementSize);\n    ElementType = IntegerType::get(ElementType->getContext(), GCD);\n  }\n}\n\n/// Make the ScopArrayInfo model a Fortran Array\nvoid ScopArrayInfo::applyAndSetFAD(Value *FAD) {\n  assert(FAD && \"got invalid Fortran array descriptor\");\n  if (this->FAD) {\n    assert(this->FAD == FAD &&\n           \"receiving different array descriptors for same array\");\n    return;\n  }\n\n  assert(DimensionSizesPw.size() > 0 && !DimensionSizesPw[0]);\n  assert(!this->FAD);\n  this->FAD = FAD;\n\n  isl::space Space(S.getIslCtx(), 1, 0);\n\n  std::string param_name = getName();\n  param_name += \"_fortranarr_size\";\n  isl::id IdPwAff = isl::id::alloc(S.getIslCtx(), param_name, this);\n\n  Space = Space.set_dim_id(isl::dim::param, 0, IdPwAff);\n  isl::pw_aff PwAff =\n      isl::aff::var_on_domain(isl::local_space(Space), isl::dim::param, 0);\n\n  DimensionSizesPw[0] = PwAff;\n}\n\nbool ScopArrayInfo::updateSizes(ArrayRef<const SCEV *> NewSizes,\n                                bool CheckConsistency) {\n  int SharedDims = std::min(NewSizes.size(), DimensionSizes.size());\n  int ExtraDimsNew = NewSizes.size() - SharedDims;\n  int ExtraDimsOld = DimensionSizes.size() - SharedDims;\n\n  if (CheckConsistency) {\n    for (int i = 0; i < SharedDims; i++) {\n      auto *NewSize = NewSizes[i + ExtraDimsNew];\n      auto *KnownSize = DimensionSizes[i + ExtraDimsOld];\n      if (NewSize && KnownSize && NewSize != KnownSize)\n        return false;\n    }\n\n    if (DimensionSizes.size() >= NewSizes.size())\n      return true;\n  }\n\n  DimensionSizes.clear();\n  DimensionSizes.insert(DimensionSizes.begin(), NewSizes.begin(),\n                        NewSizes.end());\n  DimensionSizesPw.clear();\n  for (const SCEV *Expr : DimensionSizes) {\n    if (!Expr) {\n      DimensionSizesPw.push_back(nullptr);\n      continue;\n    }\n    isl::pw_aff Size = S.getPwAffOnly(Expr);\n    DimensionSizesPw.push_back(Size);\n  }\n  return true;\n}\n\nstd::string ScopArrayInfo::getName() const { return Id.get_name(); }\n\nint ScopArrayInfo::getElemSizeInBytes() const {\n  return DL.getTypeAllocSize(ElementType);\n}\n\nisl::id ScopArrayInfo::getBasePtrId() const { return Id; }\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void ScopArrayInfo::dump() const { print(errs()); }\n#endif\n\nvoid ScopArrayInfo::print(raw_ostream &OS, bool SizeAsPwAff) const {\n  OS.indent(8) << *getElementType() << \" \" << getName();\n  unsigned u = 0;\n  // If this is a Fortran array, then we can print the outermost dimension\n  // as a isl_pw_aff even though there is no SCEV information.\n  bool IsOutermostSizeKnown = SizeAsPwAff && FAD;\n\n  if (!IsOutermostSizeKnown && getNumberOfDimensions() > 0 &&\n      !getDimensionSize(0)) {\n    OS << \"[*]\";\n    u++;\n  }\n  for (; u < getNumberOfDimensions(); u++) {\n    OS << \"[\";\n\n    if (SizeAsPwAff) {\n      isl::pw_aff Size = getDimensionSizePw(u);\n      OS << \" \" << Size << \" \";\n    } else {\n      OS << *getDimensionSize(u);\n    }\n\n    OS << \"]\";\n  }\n\n  OS << \";\";\n\n  if (BasePtrOriginSAI)\n    OS << \" [BasePtrOrigin: \" << BasePtrOriginSAI->getName() << \"]\";\n\n  OS << \" // Element size \" << getElemSizeInBytes() << \"\\n\";\n}\n\nconst ScopArrayInfo *\nScopArrayInfo::getFromAccessFunction(isl::pw_multi_aff PMA) {\n  isl::id Id = PMA.get_tuple_id(isl::dim::out);\n  assert(!Id.is_null() && \"Output dimension didn't have an ID\");\n  return getFromId(Id);\n}\n\nconst ScopArrayInfo *ScopArrayInfo::getFromId(isl::id Id) {\n  void *User = Id.get_user();\n  const ScopArrayInfo *SAI = static_cast<ScopArrayInfo *>(User);\n  return SAI;\n}\n\nvoid MemoryAccess::wrapConstantDimensions() {\n  auto *SAI = getScopArrayInfo();\n  isl::space ArraySpace = SAI->getSpace();\n  isl::ctx Ctx = ArraySpace.get_ctx();\n  unsigned DimsArray = SAI->getNumberOfDimensions();\n\n  isl::multi_aff DivModAff = isl::multi_aff::identity(\n      ArraySpace.map_from_domain_and_range(ArraySpace));\n  isl::local_space LArraySpace = isl::local_space(ArraySpace);\n\n  // Begin with last dimension, to iteratively carry into higher dimensions.\n  for (int i = DimsArray - 1; i > 0; i--) {\n    auto *DimSize = SAI->getDimensionSize(i);\n    auto *DimSizeCst = dyn_cast<SCEVConstant>(DimSize);\n\n    // This transformation is not applicable to dimensions with dynamic size.\n    if (!DimSizeCst)\n      continue;\n\n    // This transformation is not applicable to dimensions of size zero.\n    if (DimSize->isZero())\n      continue;\n\n    isl::val DimSizeVal =\n        valFromAPInt(Ctx.get(), DimSizeCst->getAPInt(), false);\n    isl::aff Var = isl::aff::var_on_domain(LArraySpace, isl::dim::set, i);\n    isl::aff PrevVar =\n        isl::aff::var_on_domain(LArraySpace, isl::dim::set, i - 1);\n\n    // Compute: index % size\n    // Modulo must apply in the divide of the previous iteration, if any.\n    isl::aff Modulo = Var.mod(DimSizeVal);\n    Modulo = Modulo.pullback(DivModAff);\n\n    // Compute: floor(index / size)\n    isl::aff Divide = Var.div(isl::aff(LArraySpace, DimSizeVal));\n    Divide = Divide.floor();\n    Divide = Divide.add(PrevVar);\n    Divide = Divide.pullback(DivModAff);\n\n    // Apply Modulo and Divide.\n    DivModAff = DivModAff.set_aff(i, Modulo);\n    DivModAff = DivModAff.set_aff(i - 1, Divide);\n  }\n\n  // Apply all modulo/divides on the accesses.\n  isl::map Relation = AccessRelation;\n  Relation = Relation.apply_range(isl::map::from_multi_aff(DivModAff));\n  Relation = Relation.detect_equalities();\n  AccessRelation = Relation;\n}\n\nvoid MemoryAccess::updateDimensionality() {\n  auto *SAI = getScopArrayInfo();\n  isl::space ArraySpace = SAI->getSpace();\n  isl::space AccessSpace = AccessRelation.get_space().range();\n  isl::ctx Ctx = ArraySpace.get_ctx();\n\n  auto DimsArray = ArraySpace.dim(isl::dim::set);\n  auto DimsAccess = AccessSpace.dim(isl::dim::set);\n  auto DimsMissing = DimsArray - DimsAccess;\n\n  auto *BB = getStatement()->getEntryBlock();\n  auto &DL = BB->getModule()->getDataLayout();\n  unsigned ArrayElemSize = SAI->getElemSizeInBytes();\n  unsigned ElemBytes = DL.getTypeAllocSize(getElementType());\n\n  isl::map Map = isl::map::from_domain_and_range(\n      isl::set::universe(AccessSpace), isl::set::universe(ArraySpace));\n\n  for (auto i : seq<isl_size>(0, DimsMissing))\n    Map = Map.fix_si(isl::dim::out, i, 0);\n\n  for (auto i : seq<isl_size>(DimsMissing, DimsArray))\n    Map = Map.equate(isl::dim::in, i - DimsMissing, isl::dim::out, i);\n\n  AccessRelation = AccessRelation.apply_range(Map);\n\n  // For the non delinearized arrays, divide the access function of the last\n  // subscript by the size of the elements in the array.\n  //\n  // A stride one array access in C expressed as A[i] is expressed in\n  // LLVM-IR as something like A[i * elementsize]. This hides the fact that\n  // two subsequent values of 'i' index two values that are stored next to\n  // each other in memory. By this division we make this characteristic\n  // obvious again. If the base pointer was accessed with offsets not divisible\n  // by the accesses element size, we will have chosen a smaller ArrayElemSize\n  // that divides the offsets of all accesses to this base pointer.\n  if (DimsAccess == 1) {\n    isl::val V = isl::val(Ctx, ArrayElemSize);\n    AccessRelation = AccessRelation.floordiv_val(V);\n  }\n\n  // We currently do this only if we added at least one dimension, which means\n  // some dimension's indices have not been specified, an indicator that some\n  // index values have been added together.\n  // TODO: Investigate general usefulness; Effect on unit tests is to make index\n  // expressions more complicated.\n  if (DimsMissing)\n    wrapConstantDimensions();\n\n  if (!isAffine())\n    computeBoundsOnAccessRelation(ArrayElemSize);\n\n  // Introduce multi-element accesses in case the type loaded by this memory\n  // access is larger than the canonical element type of the array.\n  //\n  // An access ((float *)A)[i] to an array char *A is modeled as\n  // {[i] -> A[o] : 4 i <= o <= 4 i + 3\n  if (ElemBytes > ArrayElemSize) {\n    assert(ElemBytes % ArrayElemSize == 0 &&\n           \"Loaded element size should be multiple of canonical element size\");\n    isl::map Map = isl::map::from_domain_and_range(\n        isl::set::universe(ArraySpace), isl::set::universe(ArraySpace));\n    for (auto i : seq<isl_size>(0, DimsArray - 1))\n      Map = Map.equate(isl::dim::in, i, isl::dim::out, i);\n\n    isl::constraint C;\n    isl::local_space LS;\n\n    LS = isl::local_space(Map.get_space());\n    int Num = ElemBytes / getScopArrayInfo()->getElemSizeInBytes();\n\n    C = isl::constraint::alloc_inequality(LS);\n    C = C.set_constant_val(isl::val(Ctx, Num - 1));\n    C = C.set_coefficient_si(isl::dim::in, DimsArray - 1, 1);\n    C = C.set_coefficient_si(isl::dim::out, DimsArray - 1, -1);\n    Map = Map.add_constraint(C);\n\n    C = isl::constraint::alloc_inequality(LS);\n    C = C.set_coefficient_si(isl::dim::in, DimsArray - 1, -1);\n    C = C.set_coefficient_si(isl::dim::out, DimsArray - 1, 1);\n    C = C.set_constant_val(isl::val(Ctx, 0));\n    Map = Map.add_constraint(C);\n    AccessRelation = AccessRelation.apply_range(Map);\n  }\n}\n\nconst std::string\nMemoryAccess::getReductionOperatorStr(MemoryAccess::ReductionType RT) {\n  switch (RT) {\n  case MemoryAccess::RT_NONE:\n    llvm_unreachable(\"Requested a reduction operator string for a memory \"\n                     \"access which isn't a reduction\");\n  case MemoryAccess::RT_ADD:\n    return \"+\";\n  case MemoryAccess::RT_MUL:\n    return \"*\";\n  case MemoryAccess::RT_BOR:\n    return \"|\";\n  case MemoryAccess::RT_BXOR:\n    return \"^\";\n  case MemoryAccess::RT_BAND:\n    return \"&\";\n  }\n  llvm_unreachable(\"Unknown reduction type\");\n}\n\nconst ScopArrayInfo *MemoryAccess::getOriginalScopArrayInfo() const {\n  isl::id ArrayId = getArrayId();\n  void *User = ArrayId.get_user();\n  const ScopArrayInfo *SAI = static_cast<ScopArrayInfo *>(User);\n  return SAI;\n}\n\nconst ScopArrayInfo *MemoryAccess::getLatestScopArrayInfo() const {\n  isl::id ArrayId = getLatestArrayId();\n  void *User = ArrayId.get_user();\n  const ScopArrayInfo *SAI = static_cast<ScopArrayInfo *>(User);\n  return SAI;\n}\n\nisl::id MemoryAccess::getOriginalArrayId() const {\n  return AccessRelation.get_tuple_id(isl::dim::out);\n}\n\nisl::id MemoryAccess::getLatestArrayId() const {\n  if (!hasNewAccessRelation())\n    return getOriginalArrayId();\n  return NewAccessRelation.get_tuple_id(isl::dim::out);\n}\n\nisl::map MemoryAccess::getAddressFunction() const {\n  return getAccessRelation().lexmin();\n}\n\nisl::pw_multi_aff\nMemoryAccess::applyScheduleToAccessRelation(isl::union_map USchedule) const {\n  isl::map Schedule, ScheduledAccRel;\n  isl::union_set UDomain;\n\n  UDomain = getStatement()->getDomain();\n  USchedule = USchedule.intersect_domain(UDomain);\n  Schedule = isl::map::from_union_map(USchedule);\n  ScheduledAccRel = getAddressFunction().apply_domain(Schedule);\n  return isl::pw_multi_aff::from_map(ScheduledAccRel);\n}\n\nisl::map MemoryAccess::getOriginalAccessRelation() const {\n  return AccessRelation;\n}\n\nstd::string MemoryAccess::getOriginalAccessRelationStr() const {\n  return AccessRelation.to_str();\n}\n\nisl::space MemoryAccess::getOriginalAccessRelationSpace() const {\n  return AccessRelation.get_space();\n}\n\nisl::map MemoryAccess::getNewAccessRelation() const {\n  return NewAccessRelation;\n}\n\nstd::string MemoryAccess::getNewAccessRelationStr() const {\n  return NewAccessRelation.to_str();\n}\n\nstd::string MemoryAccess::getAccessRelationStr() const {\n  return getAccessRelation().to_str();\n}\n\nisl::basic_map MemoryAccess::createBasicAccessMap(ScopStmt *Statement) {\n  isl::space Space = isl::space(Statement->getIslCtx(), 0, 1);\n  Space = Space.align_params(Statement->getDomainSpace());\n\n  return isl::basic_map::from_domain_and_range(\n      isl::basic_set::universe(Statement->getDomainSpace()),\n      isl::basic_set::universe(Space));\n}\n\n// Formalize no out-of-bound access assumption\n//\n// When delinearizing array accesses we optimistically assume that the\n// delinearized accesses do not access out of bound locations (the subscript\n// expression of each array evaluates for each statement instance that is\n// executed to a value that is larger than zero and strictly smaller than the\n// size of the corresponding dimension). The only exception is the outermost\n// dimension for which we do not need to assume any upper bound.  At this point\n// we formalize this assumption to ensure that at code generation time the\n// relevant run-time checks can be generated.\n//\n// To find the set of constraints necessary to avoid out of bound accesses, we\n// first build the set of data locations that are not within array bounds. We\n// then apply the reverse access relation to obtain the set of iterations that\n// may contain invalid accesses and reduce this set of iterations to the ones\n// that are actually executed by intersecting them with the domain of the\n// statement. If we now project out all loop dimensions, we obtain a set of\n// parameters that may cause statement instances to be executed that may\n// possibly yield out of bound memory accesses. The complement of these\n// constraints is the set of constraints that needs to be assumed to ensure such\n// statement instances are never executed.\nisl::set MemoryAccess::assumeNoOutOfBound() {\n  auto *SAI = getScopArrayInfo();\n  isl::space Space = getOriginalAccessRelationSpace().range();\n  isl::set Outside = isl::set::empty(Space);\n  for (int i = 1, Size = Space.dim(isl::dim::set); i < Size; ++i) {\n    isl::local_space LS(Space);\n    isl::pw_aff Var = isl::pw_aff::var_on_domain(LS, isl::dim::set, i);\n    isl::pw_aff Zero = isl::pw_aff(LS);\n\n    isl::set DimOutside = Var.lt_set(Zero);\n    isl::pw_aff SizeE = SAI->getDimensionSizePw(i);\n    SizeE = SizeE.add_dims(isl::dim::in, Space.dim(isl::dim::set));\n    SizeE = SizeE.set_tuple_id(isl::dim::in, Space.get_tuple_id(isl::dim::set));\n    DimOutside = DimOutside.unite(SizeE.le_set(Var));\n\n    Outside = Outside.unite(DimOutside);\n  }\n\n  Outside = Outside.apply(getAccessRelation().reverse());\n  Outside = Outside.intersect(Statement->getDomain());\n  Outside = Outside.params();\n\n  // Remove divs to avoid the construction of overly complicated assumptions.\n  // Doing so increases the set of parameter combinations that are assumed to\n  // not appear. This is always save, but may make the resulting run-time check\n  // bail out more often than strictly necessary.\n  Outside = Outside.remove_divs();\n  Outside = Outside.complement();\n\n  if (!PollyPreciseInbounds)\n    Outside = Outside.gist_params(Statement->getDomain().params());\n  return Outside;\n}\n\nvoid MemoryAccess::buildMemIntrinsicAccessRelation() {\n  assert(isMemoryIntrinsic());\n  assert(Subscripts.size() == 2 && Sizes.size() == 1);\n\n  isl::pw_aff SubscriptPWA = getPwAff(Subscripts[0]);\n  isl::map SubscriptMap = isl::map::from_pw_aff(SubscriptPWA);\n\n  isl::map LengthMap;\n  if (Subscripts[1] == nullptr) {\n    LengthMap = isl::map::universe(SubscriptMap.get_space());\n  } else {\n    isl::pw_aff LengthPWA = getPwAff(Subscripts[1]);\n    LengthMap = isl::map::from_pw_aff(LengthPWA);\n    isl::space RangeSpace = LengthMap.get_space().range();\n    LengthMap = LengthMap.apply_range(isl::map::lex_gt(RangeSpace));\n  }\n  LengthMap = LengthMap.lower_bound_si(isl::dim::out, 0, 0);\n  LengthMap = LengthMap.align_params(SubscriptMap.get_space());\n  SubscriptMap = SubscriptMap.align_params(LengthMap.get_space());\n  LengthMap = LengthMap.sum(SubscriptMap);\n  AccessRelation =\n      LengthMap.set_tuple_id(isl::dim::in, getStatement()->getDomainId());\n}\n\nvoid MemoryAccess::computeBoundsOnAccessRelation(unsigned ElementSize) {\n  ScalarEvolution *SE = Statement->getParent()->getSE();\n\n  auto MAI = MemAccInst(getAccessInstruction());\n  if (isa<MemIntrinsic>(MAI))\n    return;\n\n  Value *Ptr = MAI.getPointerOperand();\n  if (!Ptr || !SE->isSCEVable(Ptr->getType()))\n    return;\n\n  auto *PtrSCEV = SE->getSCEV(Ptr);\n  if (isa<SCEVCouldNotCompute>(PtrSCEV))\n    return;\n\n  auto *BasePtrSCEV = SE->getPointerBase(PtrSCEV);\n  if (BasePtrSCEV && !isa<SCEVCouldNotCompute>(BasePtrSCEV))\n    PtrSCEV = SE->getMinusSCEV(PtrSCEV, BasePtrSCEV);\n\n  const ConstantRange &Range = SE->getSignedRange(PtrSCEV);\n  if (Range.isFullSet())\n    return;\n\n  if (Range.isUpperWrapped() || Range.isSignWrappedSet())\n    return;\n\n  bool isWrapping = Range.isSignWrappedSet();\n\n  unsigned BW = Range.getBitWidth();\n  const auto One = APInt(BW, 1);\n  const auto LB = isWrapping ? Range.getLower() : Range.getSignedMin();\n  const auto UB = isWrapping ? (Range.getUpper() - One) : Range.getSignedMax();\n\n  auto Min = LB.sdiv(APInt(BW, ElementSize));\n  auto Max = UB.sdiv(APInt(BW, ElementSize)) + One;\n\n  assert(Min.sle(Max) && \"Minimum expected to be less or equal than max\");\n\n  isl::map Relation = AccessRelation;\n  isl::set AccessRange = Relation.range();\n  AccessRange = addRangeBoundsToSet(AccessRange, ConstantRange(Min, Max), 0,\n                                    isl::dim::set);\n  AccessRelation = Relation.intersect_range(AccessRange);\n}\n\nvoid MemoryAccess::foldAccessRelation() {\n  if (Sizes.size() < 2 || isa<SCEVConstant>(Sizes[1]))\n    return;\n\n  int Size = Subscripts.size();\n\n  isl::map NewAccessRelation = AccessRelation;\n\n  for (int i = Size - 2; i >= 0; --i) {\n    isl::space Space;\n    isl::map MapOne, MapTwo;\n    isl::pw_aff DimSize = getPwAff(Sizes[i + 1]);\n\n    isl::space SpaceSize = DimSize.get_space();\n    isl::id ParamId = SpaceSize.get_dim_id(isl::dim::param, 0);\n\n    Space = AccessRelation.get_space();\n    Space = Space.range().map_from_set();\n    Space = Space.align_params(SpaceSize);\n\n    int ParamLocation = Space.find_dim_by_id(isl::dim::param, ParamId);\n\n    MapOne = isl::map::universe(Space);\n    for (int j = 0; j < Size; ++j)\n      MapOne = MapOne.equate(isl::dim::in, j, isl::dim::out, j);\n    MapOne = MapOne.lower_bound_si(isl::dim::in, i + 1, 0);\n\n    MapTwo = isl::map::universe(Space);\n    for (int j = 0; j < Size; ++j)\n      if (j < i || j > i + 1)\n        MapTwo = MapTwo.equate(isl::dim::in, j, isl::dim::out, j);\n\n    isl::local_space LS(Space);\n    isl::constraint C;\n    C = isl::constraint::alloc_equality(LS);\n    C = C.set_constant_si(-1);\n    C = C.set_coefficient_si(isl::dim::in, i, 1);\n    C = C.set_coefficient_si(isl::dim::out, i, -1);\n    MapTwo = MapTwo.add_constraint(C);\n    C = isl::constraint::alloc_equality(LS);\n    C = C.set_coefficient_si(isl::dim::in, i + 1, 1);\n    C = C.set_coefficient_si(isl::dim::out, i + 1, -1);\n    C = C.set_coefficient_si(isl::dim::param, ParamLocation, 1);\n    MapTwo = MapTwo.add_constraint(C);\n    MapTwo = MapTwo.upper_bound_si(isl::dim::in, i + 1, -1);\n\n    MapOne = MapOne.unite(MapTwo);\n    NewAccessRelation = NewAccessRelation.apply_range(MapOne);\n  }\n\n  isl::id BaseAddrId = getScopArrayInfo()->getBasePtrId();\n  isl::space Space = Statement->getDomainSpace();\n  NewAccessRelation = NewAccessRelation.set_tuple_id(\n      isl::dim::in, Space.get_tuple_id(isl::dim::set));\n  NewAccessRelation = NewAccessRelation.set_tuple_id(isl::dim::out, BaseAddrId);\n  NewAccessRelation = NewAccessRelation.gist_domain(Statement->getDomain());\n\n  // Access dimension folding might in certain cases increase the number of\n  // disjuncts in the memory access, which can possibly complicate the generated\n  // run-time checks and can lead to costly compilation.\n  if (!PollyPreciseFoldAccesses &&\n      NewAccessRelation.n_basic_map() > AccessRelation.n_basic_map()) {\n  } else {\n    AccessRelation = NewAccessRelation;\n  }\n}\n\nvoid MemoryAccess::buildAccessRelation(const ScopArrayInfo *SAI) {\n  assert(AccessRelation.is_null() && \"AccessRelation already built\");\n\n  // Initialize the invalid domain which describes all iterations for which the\n  // access relation is not modeled correctly.\n  isl::set StmtInvalidDomain = getStatement()->getInvalidDomain();\n  InvalidDomain = isl::set::empty(StmtInvalidDomain.get_space());\n\n  isl::ctx Ctx = Id.get_ctx();\n  isl::id BaseAddrId = SAI->getBasePtrId();\n\n  if (getAccessInstruction() && isa<MemIntrinsic>(getAccessInstruction())) {\n    buildMemIntrinsicAccessRelation();\n    AccessRelation = AccessRelation.set_tuple_id(isl::dim::out, BaseAddrId);\n    return;\n  }\n\n  if (!isAffine()) {\n    // We overapproximate non-affine accesses with a possible access to the\n    // whole array. For read accesses it does not make a difference, if an\n    // access must or may happen. However, for write accesses it is important to\n    // differentiate between writes that must happen and writes that may happen.\n    if (AccessRelation.is_null())\n      AccessRelation = createBasicAccessMap(Statement);\n\n    AccessRelation = AccessRelation.set_tuple_id(isl::dim::out, BaseAddrId);\n    return;\n  }\n\n  isl::space Space = isl::space(Ctx, 0, Statement->getNumIterators(), 0);\n  AccessRelation = isl::map::universe(Space);\n\n  for (int i = 0, Size = Subscripts.size(); i < Size; ++i) {\n    isl::pw_aff Affine = getPwAff(Subscripts[i]);\n    isl::map SubscriptMap = isl::map::from_pw_aff(Affine);\n    AccessRelation = AccessRelation.flat_range_product(SubscriptMap);\n  }\n\n  Space = Statement->getDomainSpace();\n  AccessRelation = AccessRelation.set_tuple_id(\n      isl::dim::in, Space.get_tuple_id(isl::dim::set));\n  AccessRelation = AccessRelation.set_tuple_id(isl::dim::out, BaseAddrId);\n\n  AccessRelation = AccessRelation.gist_domain(Statement->getDomain());\n}\n\nMemoryAccess::MemoryAccess(ScopStmt *Stmt, Instruction *AccessInst,\n                           AccessType AccType, Value *BaseAddress,\n                           Type *ElementType, bool Affine,\n                           ArrayRef<const SCEV *> Subscripts,\n                           ArrayRef<const SCEV *> Sizes, Value *AccessValue,\n                           MemoryKind Kind)\n    : Kind(Kind), AccType(AccType), Statement(Stmt), InvalidDomain(nullptr),\n      BaseAddr(BaseAddress), ElementType(ElementType),\n      Sizes(Sizes.begin(), Sizes.end()), AccessInstruction(AccessInst),\n      AccessValue(AccessValue), IsAffine(Affine),\n      Subscripts(Subscripts.begin(), Subscripts.end()), AccessRelation(nullptr),\n      NewAccessRelation(nullptr), FAD(nullptr) {\n  static const std::string TypeStrings[] = {\"\", \"_Read\", \"_Write\", \"_MayWrite\"};\n  const std::string Access = TypeStrings[AccType] + utostr(Stmt->size());\n\n  std::string IdName = Stmt->getBaseName() + Access;\n  Id = isl::id::alloc(Stmt->getParent()->getIslCtx(), IdName, this);\n}\n\nMemoryAccess::MemoryAccess(ScopStmt *Stmt, AccessType AccType, isl::map AccRel)\n    : Kind(MemoryKind::Array), AccType(AccType), Statement(Stmt),\n      InvalidDomain(nullptr), AccessRelation(nullptr),\n      NewAccessRelation(AccRel), FAD(nullptr) {\n  isl::id ArrayInfoId = NewAccessRelation.get_tuple_id(isl::dim::out);\n  auto *SAI = ScopArrayInfo::getFromId(ArrayInfoId);\n  Sizes.push_back(nullptr);\n  for (unsigned i = 1; i < SAI->getNumberOfDimensions(); i++)\n    Sizes.push_back(SAI->getDimensionSize(i));\n  ElementType = SAI->getElementType();\n  BaseAddr = SAI->getBasePtr();\n  static const std::string TypeStrings[] = {\"\", \"_Read\", \"_Write\", \"_MayWrite\"};\n  const std::string Access = TypeStrings[AccType] + utostr(Stmt->size());\n\n  std::string IdName = Stmt->getBaseName() + Access;\n  Id = isl::id::alloc(Stmt->getParent()->getIslCtx(), IdName, this);\n}\n\nMemoryAccess::~MemoryAccess() = default;\n\nvoid MemoryAccess::realignParams() {\n  isl::set Ctx = Statement->getParent()->getContext();\n  InvalidDomain = InvalidDomain.gist_params(Ctx);\n  AccessRelation = AccessRelation.gist_params(Ctx);\n\n  // Predictable parameter order is required for JSON imports. Ensure alignment\n  // by explicitly calling align_params.\n  isl::space CtxSpace = Ctx.get_space();\n  InvalidDomain = InvalidDomain.align_params(CtxSpace);\n  AccessRelation = AccessRelation.align_params(CtxSpace);\n}\n\nconst std::string MemoryAccess::getReductionOperatorStr() const {\n  return MemoryAccess::getReductionOperatorStr(getReductionType());\n}\n\nisl::id MemoryAccess::getId() const { return Id; }\n\nraw_ostream &polly::operator<<(raw_ostream &OS,\n                               MemoryAccess::ReductionType RT) {\n  if (RT == MemoryAccess::RT_NONE)\n    OS << \"NONE\";\n  else\n    OS << MemoryAccess::getReductionOperatorStr(RT);\n  return OS;\n}\n\nvoid MemoryAccess::setFortranArrayDescriptor(Value *FAD) { this->FAD = FAD; }\n\nvoid MemoryAccess::print(raw_ostream &OS) const {\n  switch (AccType) {\n  case READ:\n    OS.indent(12) << \"ReadAccess :=\\t\";\n    break;\n  case MUST_WRITE:\n    OS.indent(12) << \"MustWriteAccess :=\\t\";\n    break;\n  case MAY_WRITE:\n    OS.indent(12) << \"MayWriteAccess :=\\t\";\n    break;\n  }\n\n  OS << \"[Reduction Type: \" << getReductionType() << \"] \";\n\n  if (FAD) {\n    OS << \"[Fortran array descriptor: \" << FAD->getName();\n    OS << \"] \";\n  };\n\n  OS << \"[Scalar: \" << isScalarKind() << \"]\\n\";\n  OS.indent(16) << getOriginalAccessRelationStr() << \";\\n\";\n  if (hasNewAccessRelation())\n    OS.indent(11) << \"new: \" << getNewAccessRelationStr() << \";\\n\";\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void MemoryAccess::dump() const { print(errs()); }\n#endif\n\nisl::pw_aff MemoryAccess::getPwAff(const SCEV *E) {\n  auto *Stmt = getStatement();\n  PWACtx PWAC = Stmt->getParent()->getPwAff(E, Stmt->getEntryBlock());\n  isl::set StmtDom = getStatement()->getDomain();\n  StmtDom = StmtDom.reset_tuple_id();\n  isl::set NewInvalidDom = StmtDom.intersect(PWAC.second);\n  InvalidDomain = InvalidDomain.unite(NewInvalidDom);\n  return PWAC.first;\n}\n\n// Create a map in the size of the provided set domain, that maps from the\n// one element of the provided set domain to another element of the provided\n// set domain.\n// The mapping is limited to all points that are equal in all but the last\n// dimension and for which the last dimension of the input is strict smaller\n// than the last dimension of the output.\n//\n//   getEqualAndLarger(set[i0, i1, ..., iX]):\n//\n//   set[i0, i1, ..., iX] -> set[o0, o1, ..., oX]\n//     : i0 = o0, i1 = o1, ..., i(X-1) = o(X-1), iX < oX\n//\nstatic isl::map getEqualAndLarger(isl::space SetDomain) {\n  isl::space Space = SetDomain.map_from_set();\n  isl::map Map = isl::map::universe(Space);\n  unsigned lastDimension = Map.dim(isl::dim::in) - 1;\n\n  // Set all but the last dimension to be equal for the input and output\n  //\n  //   input[i0, i1, ..., iX] -> output[o0, o1, ..., oX]\n  //     : i0 = o0, i1 = o1, ..., i(X-1) = o(X-1)\n  for (unsigned i = 0; i < lastDimension; ++i)\n    Map = Map.equate(isl::dim::in, i, isl::dim::out, i);\n\n  // Set the last dimension of the input to be strict smaller than the\n  // last dimension of the output.\n  //\n  //   input[?,?,?,...,iX] -> output[?,?,?,...,oX] : iX < oX\n  Map = Map.order_lt(isl::dim::in, lastDimension, isl::dim::out, lastDimension);\n  return Map;\n}\n\nisl::set MemoryAccess::getStride(isl::map Schedule) const {\n  isl::map AccessRelation = getAccessRelation();\n  isl::space Space = Schedule.get_space().range();\n  isl::map NextScatt = getEqualAndLarger(Space);\n\n  Schedule = Schedule.reverse();\n  NextScatt = NextScatt.lexmin();\n\n  NextScatt = NextScatt.apply_range(Schedule);\n  NextScatt = NextScatt.apply_range(AccessRelation);\n  NextScatt = NextScatt.apply_domain(Schedule);\n  NextScatt = NextScatt.apply_domain(AccessRelation);\n\n  isl::set Deltas = NextScatt.deltas();\n  return Deltas;\n}\n\nbool MemoryAccess::isStrideX(isl::map Schedule, int StrideWidth) const {\n  isl::set Stride, StrideX;\n  bool IsStrideX;\n\n  Stride = getStride(Schedule);\n  StrideX = isl::set::universe(Stride.get_space());\n  for (auto i : seq<isl_size>(0, StrideX.dim(isl::dim::set) - 1))\n    StrideX = StrideX.fix_si(isl::dim::set, i, 0);\n  StrideX = StrideX.fix_si(isl::dim::set, StrideX.dim(isl::dim::set) - 1,\n                           StrideWidth);\n  IsStrideX = Stride.is_subset(StrideX);\n\n  return IsStrideX;\n}\n\nbool MemoryAccess::isStrideZero(isl::map Schedule) const {\n  return isStrideX(Schedule, 0);\n}\n\nbool MemoryAccess::isStrideOne(isl::map Schedule) const {\n  return isStrideX(Schedule, 1);\n}\n\nvoid MemoryAccess::setAccessRelation(isl::map NewAccess) {\n  AccessRelation = NewAccess;\n}\n\nvoid MemoryAccess::setNewAccessRelation(isl::map NewAccess) {\n  assert(NewAccess);\n\n#ifndef NDEBUG\n  // Check domain space compatibility.\n  isl::space NewSpace = NewAccess.get_space();\n  isl::space NewDomainSpace = NewSpace.domain();\n  isl::space OriginalDomainSpace = getStatement()->getDomainSpace();\n  assert(OriginalDomainSpace.has_equal_tuples(NewDomainSpace));\n\n  // Reads must be executed unconditionally. Writes might be executed in a\n  // subdomain only.\n  if (isRead()) {\n    // Check whether there is an access for every statement instance.\n    isl::set StmtDomain = getStatement()->getDomain();\n    isl::set DefinedContext =\n        getStatement()->getParent()->getBestKnownDefinedBehaviorContext();\n    StmtDomain = StmtDomain.intersect_params(DefinedContext);\n    isl::set NewDomain = NewAccess.domain();\n    assert(!StmtDomain.is_subset(NewDomain).is_false() &&\n           \"Partial READ accesses not supported\");\n  }\n\n  isl::space NewAccessSpace = NewAccess.get_space();\n  assert(NewAccessSpace.has_tuple_id(isl::dim::set) &&\n         \"Must specify the array that is accessed\");\n  isl::id NewArrayId = NewAccessSpace.get_tuple_id(isl::dim::set);\n  auto *SAI = static_cast<ScopArrayInfo *>(NewArrayId.get_user());\n  assert(SAI && \"Must set a ScopArrayInfo\");\n\n  if (SAI->isArrayKind() && SAI->getBasePtrOriginSAI()) {\n    InvariantEquivClassTy *EqClass =\n        getStatement()->getParent()->lookupInvariantEquivClass(\n            SAI->getBasePtr());\n    assert(EqClass &&\n           \"Access functions to indirect arrays must have an invariant and \"\n           \"hoisted base pointer\");\n  }\n\n  // Check whether access dimensions correspond to number of dimensions of the\n  // accesses array.\n  isl_size Dims = SAI->getNumberOfDimensions();\n  assert(NewAccessSpace.dim(isl::dim::set) == Dims &&\n         \"Access dims must match array dims\");\n#endif\n\n  NewAccess = NewAccess.gist_params(getStatement()->getParent()->getContext());\n  NewAccess = NewAccess.gist_domain(getStatement()->getDomain());\n  NewAccessRelation = NewAccess;\n}\n\nbool MemoryAccess::isLatestPartialAccess() const {\n  isl::set StmtDom = getStatement()->getDomain();\n  isl::set AccDom = getLatestAccessRelation().domain();\n\n  return !StmtDom.is_subset(AccDom);\n}\n\n//===----------------------------------------------------------------------===//\n\nisl::map ScopStmt::getSchedule() const {\n  isl::set Domain = getDomain();\n  if (Domain.is_empty())\n    return isl::map::from_aff(isl::aff(isl::local_space(getDomainSpace())));\n  auto Schedule = getParent()->getSchedule();\n  if (!Schedule)\n    return nullptr;\n  Schedule = Schedule.intersect_domain(isl::union_set(Domain));\n  if (Schedule.is_empty())\n    return isl::map::from_aff(isl::aff(isl::local_space(getDomainSpace())));\n  isl::map M = M.from_union_map(Schedule);\n  M = M.coalesce();\n  M = M.gist_domain(Domain);\n  M = M.coalesce();\n  return M;\n}\n\nvoid ScopStmt::restrictDomain(isl::set NewDomain) {\n  assert(NewDomain.is_subset(Domain) &&\n         \"New domain is not a subset of old domain!\");\n  Domain = NewDomain;\n}\n\nvoid ScopStmt::addAccess(MemoryAccess *Access, bool Prepend) {\n  Instruction *AccessInst = Access->getAccessInstruction();\n\n  if (Access->isArrayKind()) {\n    MemoryAccessList &MAL = InstructionToAccess[AccessInst];\n    MAL.emplace_front(Access);\n  } else if (Access->isValueKind() && Access->isWrite()) {\n    Instruction *AccessVal = cast<Instruction>(Access->getAccessValue());\n    assert(!ValueWrites.lookup(AccessVal));\n\n    ValueWrites[AccessVal] = Access;\n  } else if (Access->isValueKind() && Access->isRead()) {\n    Value *AccessVal = Access->getAccessValue();\n    assert(!ValueReads.lookup(AccessVal));\n\n    ValueReads[AccessVal] = Access;\n  } else if (Access->isAnyPHIKind() && Access->isWrite()) {\n    PHINode *PHI = cast<PHINode>(Access->getAccessValue());\n    assert(!PHIWrites.lookup(PHI));\n\n    PHIWrites[PHI] = Access;\n  } else if (Access->isAnyPHIKind() && Access->isRead()) {\n    PHINode *PHI = cast<PHINode>(Access->getAccessValue());\n    assert(!PHIReads.lookup(PHI));\n\n    PHIReads[PHI] = Access;\n  }\n\n  if (Prepend) {\n    MemAccs.insert(MemAccs.begin(), Access);\n    return;\n  }\n  MemAccs.push_back(Access);\n}\n\nvoid ScopStmt::realignParams() {\n  for (MemoryAccess *MA : *this)\n    MA->realignParams();\n\n  isl::set Ctx = Parent.getContext();\n  InvalidDomain = InvalidDomain.gist_params(Ctx);\n  Domain = Domain.gist_params(Ctx);\n\n  // Predictable parameter order is required for JSON imports. Ensure alignment\n  // by explicitly calling align_params.\n  isl::space CtxSpace = Ctx.get_space();\n  InvalidDomain = InvalidDomain.align_params(CtxSpace);\n  Domain = Domain.align_params(CtxSpace);\n}\n\nScopStmt::ScopStmt(Scop &parent, Region &R, StringRef Name,\n                   Loop *SurroundingLoop,\n                   std::vector<Instruction *> EntryBlockInstructions)\n    : Parent(parent), InvalidDomain(nullptr), Domain(nullptr), R(&R),\n      Build(nullptr), BaseName(Name), SurroundingLoop(SurroundingLoop),\n      Instructions(EntryBlockInstructions) {}\n\nScopStmt::ScopStmt(Scop &parent, BasicBlock &bb, StringRef Name,\n                   Loop *SurroundingLoop,\n                   std::vector<Instruction *> Instructions)\n    : Parent(parent), InvalidDomain(nullptr), Domain(nullptr), BB(&bb),\n      Build(nullptr), BaseName(Name), SurroundingLoop(SurroundingLoop),\n      Instructions(Instructions) {}\n\nScopStmt::ScopStmt(Scop &parent, isl::map SourceRel, isl::map TargetRel,\n                   isl::set NewDomain)\n    : Parent(parent), InvalidDomain(nullptr), Domain(NewDomain),\n      Build(nullptr) {\n  BaseName = getIslCompatibleName(\"CopyStmt_\", \"\",\n                                  std::to_string(parent.getCopyStmtsNum()));\n  isl::id Id = isl::id::alloc(getIslCtx(), getBaseName(), this);\n  Domain = Domain.set_tuple_id(Id);\n  TargetRel = TargetRel.set_tuple_id(isl::dim::in, Id);\n  auto *Access =\n      new MemoryAccess(this, MemoryAccess::AccessType::MUST_WRITE, TargetRel);\n  parent.addAccessFunction(Access);\n  addAccess(Access);\n  SourceRel = SourceRel.set_tuple_id(isl::dim::in, Id);\n  Access = new MemoryAccess(this, MemoryAccess::AccessType::READ, SourceRel);\n  parent.addAccessFunction(Access);\n  addAccess(Access);\n}\n\nScopStmt::~ScopStmt() = default;\n\nstd::string ScopStmt::getDomainStr() const { return Domain.to_str(); }\n\nstd::string ScopStmt::getScheduleStr() const {\n  auto *S = getSchedule().release();\n  if (!S)\n    return {};\n  auto Str = stringFromIslObj(S);\n  isl_map_free(S);\n  return Str;\n}\n\nvoid ScopStmt::setInvalidDomain(isl::set ID) { InvalidDomain = ID; }\n\nBasicBlock *ScopStmt::getEntryBlock() const {\n  if (isBlockStmt())\n    return getBasicBlock();\n  return getRegion()->getEntry();\n}\n\nunsigned ScopStmt::getNumIterators() const { return NestLoops.size(); }\n\nconst char *ScopStmt::getBaseName() const { return BaseName.c_str(); }\n\nLoop *ScopStmt::getLoopForDimension(unsigned Dimension) const {\n  return NestLoops[Dimension];\n}\n\nisl::ctx ScopStmt::getIslCtx() const { return Parent.getIslCtx(); }\n\nisl::set ScopStmt::getDomain() const { return Domain; }\n\nisl::space ScopStmt::getDomainSpace() const { return Domain.get_space(); }\n\nisl::id ScopStmt::getDomainId() const { return Domain.get_tuple_id(); }\n\nvoid ScopStmt::printInstructions(raw_ostream &OS) const {\n  OS << \"Instructions {\\n\";\n\n  for (Instruction *Inst : Instructions)\n    OS.indent(16) << *Inst << \"\\n\";\n\n  OS.indent(12) << \"}\\n\";\n}\n\nvoid ScopStmt::print(raw_ostream &OS, bool PrintInstructions) const {\n  OS << \"\\t\" << getBaseName() << \"\\n\";\n  OS.indent(12) << \"Domain :=\\n\";\n\n  if (Domain) {\n    OS.indent(16) << getDomainStr() << \";\\n\";\n  } else\n    OS.indent(16) << \"n/a\\n\";\n\n  OS.indent(12) << \"Schedule :=\\n\";\n\n  if (Domain) {\n    OS.indent(16) << getScheduleStr() << \";\\n\";\n  } else\n    OS.indent(16) << \"n/a\\n\";\n\n  for (MemoryAccess *Access : MemAccs)\n    Access->print(OS);\n\n  if (PrintInstructions)\n    printInstructions(OS.indent(12));\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void ScopStmt::dump() const { print(dbgs(), true); }\n#endif\n\nvoid ScopStmt::removeAccessData(MemoryAccess *MA) {\n  if (MA->isRead() && MA->isOriginalValueKind()) {\n    bool Found = ValueReads.erase(MA->getAccessValue());\n    (void)Found;\n    assert(Found && \"Expected access data not found\");\n  }\n  if (MA->isWrite() && MA->isOriginalValueKind()) {\n    bool Found = ValueWrites.erase(cast<Instruction>(MA->getAccessValue()));\n    (void)Found;\n    assert(Found && \"Expected access data not found\");\n  }\n  if (MA->isWrite() && MA->isOriginalAnyPHIKind()) {\n    bool Found = PHIWrites.erase(cast<PHINode>(MA->getAccessInstruction()));\n    (void)Found;\n    assert(Found && \"Expected access data not found\");\n  }\n  if (MA->isRead() && MA->isOriginalAnyPHIKind()) {\n    bool Found = PHIReads.erase(cast<PHINode>(MA->getAccessInstruction()));\n    (void)Found;\n    assert(Found && \"Expected access data not found\");\n  }\n}\n\nvoid ScopStmt::removeMemoryAccess(MemoryAccess *MA) {\n  // Remove the memory accesses from this statement together with all scalar\n  // accesses that were caused by it. MemoryKind::Value READs have no access\n  // instruction, hence would not be removed by this function. However, it is\n  // only used for invariant LoadInst accesses, its arguments are always affine,\n  // hence synthesizable, and therefore there are no MemoryKind::Value READ\n  // accesses to be removed.\n  auto Predicate = [&](MemoryAccess *Acc) {\n    return Acc->getAccessInstruction() == MA->getAccessInstruction();\n  };\n  for (auto *MA : MemAccs) {\n    if (Predicate(MA)) {\n      removeAccessData(MA);\n      Parent.removeAccessData(MA);\n    }\n  }\n  MemAccs.erase(std::remove_if(MemAccs.begin(), MemAccs.end(), Predicate),\n                MemAccs.end());\n  InstructionToAccess.erase(MA->getAccessInstruction());\n}\n\nvoid ScopStmt::removeSingleMemoryAccess(MemoryAccess *MA, bool AfterHoisting) {\n  if (AfterHoisting) {\n    auto MAIt = std::find(MemAccs.begin(), MemAccs.end(), MA);\n    assert(MAIt != MemAccs.end());\n    MemAccs.erase(MAIt);\n\n    removeAccessData(MA);\n    Parent.removeAccessData(MA);\n  }\n\n  auto It = InstructionToAccess.find(MA->getAccessInstruction());\n  if (It != InstructionToAccess.end()) {\n    It->second.remove(MA);\n    if (It->second.empty())\n      InstructionToAccess.erase(MA->getAccessInstruction());\n  }\n}\n\nMemoryAccess *ScopStmt::ensureValueRead(Value *V) {\n  MemoryAccess *Access = lookupInputAccessOf(V);\n  if (Access)\n    return Access;\n\n  ScopArrayInfo *SAI =\n      Parent.getOrCreateScopArrayInfo(V, V->getType(), {}, MemoryKind::Value);\n  Access = new MemoryAccess(this, nullptr, MemoryAccess::READ, V, V->getType(),\n                            true, {}, {}, V, MemoryKind::Value);\n  Parent.addAccessFunction(Access);\n  Access->buildAccessRelation(SAI);\n  addAccess(Access);\n  Parent.addAccessData(Access);\n  return Access;\n}\n\nraw_ostream &polly::operator<<(raw_ostream &OS, const ScopStmt &S) {\n  S.print(OS, PollyPrintInstructions);\n  return OS;\n}\n\n//===----------------------------------------------------------------------===//\n/// Scop class implement\n\nvoid Scop::setContext(isl::set NewContext) {\n  Context = NewContext.align_params(Context.get_space());\n}\n\nnamespace {\n\n/// Remap parameter values but keep AddRecs valid wrt. invariant loads.\nstruct SCEVSensitiveParameterRewriter\n    : public SCEVRewriteVisitor<SCEVSensitiveParameterRewriter> {\n  const ValueToValueMap &VMap;\n\npublic:\n  SCEVSensitiveParameterRewriter(const ValueToValueMap &VMap,\n                                 ScalarEvolution &SE)\n      : SCEVRewriteVisitor(SE), VMap(VMap) {}\n\n  static const SCEV *rewrite(const SCEV *E, ScalarEvolution &SE,\n                             const ValueToValueMap &VMap) {\n    SCEVSensitiveParameterRewriter SSPR(VMap, SE);\n    return SSPR.visit(E);\n  }\n\n  const SCEV *visitAddRecExpr(const SCEVAddRecExpr *E) {\n    auto *Start = visit(E->getStart());\n    auto *AddRec = SE.getAddRecExpr(SE.getConstant(E->getType(), 0),\n                                    visit(E->getStepRecurrence(SE)),\n                                    E->getLoop(), SCEV::FlagAnyWrap);\n    return SE.getAddExpr(Start, AddRec);\n  }\n\n  const SCEV *visitUnknown(const SCEVUnknown *E) {\n    if (auto *NewValue = VMap.lookup(E->getValue()))\n      return SE.getUnknown(NewValue);\n    return E;\n  }\n};\n\n/// Check whether we should remap a SCEV expression.\nstruct SCEVFindInsideScop : public SCEVTraversal<SCEVFindInsideScop> {\n  const ValueToValueMap &VMap;\n  bool FoundInside = false;\n  const Scop *S;\n\npublic:\n  SCEVFindInsideScop(const ValueToValueMap &VMap, ScalarEvolution &SE,\n                     const Scop *S)\n      : SCEVTraversal(*this), VMap(VMap), S(S) {}\n\n  static bool hasVariant(const SCEV *E, ScalarEvolution &SE,\n                         const ValueToValueMap &VMap, const Scop *S) {\n    SCEVFindInsideScop SFIS(VMap, SE, S);\n    SFIS.visitAll(E);\n    return SFIS.FoundInside;\n  }\n\n  bool follow(const SCEV *E) {\n    if (auto *AddRec = dyn_cast<SCEVAddRecExpr>(E)) {\n      FoundInside |= S->getRegion().contains(AddRec->getLoop());\n    } else if (auto *Unknown = dyn_cast<SCEVUnknown>(E)) {\n      if (Instruction *I = dyn_cast<Instruction>(Unknown->getValue()))\n        FoundInside |= S->getRegion().contains(I) && !VMap.count(I);\n    }\n    return !FoundInside;\n  }\n\n  bool isDone() { return FoundInside; }\n};\n} // end anonymous namespace\n\nconst SCEV *Scop::getRepresentingInvariantLoadSCEV(const SCEV *E) const {\n  // Check whether it makes sense to rewrite the SCEV.  (ScalarEvolution\n  // doesn't like addition between an AddRec and an expression that\n  // doesn't have a dominance relationship with it.)\n  if (SCEVFindInsideScop::hasVariant(E, *SE, InvEquivClassVMap, this))\n    return E;\n\n  // Rewrite SCEV.\n  return SCEVSensitiveParameterRewriter::rewrite(E, *SE, InvEquivClassVMap);\n}\n\n// This table of function names is used to translate parameter names in more\n// human-readable names. This makes it easier to interpret Polly analysis\n// results.\nStringMap<std::string> KnownNames = {\n    {\"_Z13get_global_idj\", \"global_id\"},\n    {\"_Z12get_local_idj\", \"local_id\"},\n    {\"_Z15get_global_sizej\", \"global_size\"},\n    {\"_Z14get_local_sizej\", \"local_size\"},\n    {\"_Z12get_work_dimv\", \"work_dim\"},\n    {\"_Z17get_global_offsetj\", \"global_offset\"},\n    {\"_Z12get_group_idj\", \"group_id\"},\n    {\"_Z14get_num_groupsj\", \"num_groups\"},\n};\n\nstatic std::string getCallParamName(CallInst *Call) {\n  std::string Result;\n  raw_string_ostream OS(Result);\n  std::string Name = Call->getCalledFunction()->getName().str();\n\n  auto Iterator = KnownNames.find(Name);\n  if (Iterator != KnownNames.end())\n    Name = \"__\" + Iterator->getValue();\n  OS << Name;\n  for (auto &Operand : Call->arg_operands()) {\n    ConstantInt *Op = cast<ConstantInt>(&Operand);\n    OS << \"_\" << Op->getValue();\n  }\n  OS.flush();\n  return Result;\n}\n\nvoid Scop::createParameterId(const SCEV *Parameter) {\n  assert(Parameters.count(Parameter));\n  assert(!ParameterIds.count(Parameter));\n\n  std::string ParameterName = \"p_\" + std::to_string(getNumParams() - 1);\n\n  if (const SCEVUnknown *ValueParameter = dyn_cast<SCEVUnknown>(Parameter)) {\n    Value *Val = ValueParameter->getValue();\n    CallInst *Call = dyn_cast<CallInst>(Val);\n\n    if (Call && isConstCall(Call)) {\n      ParameterName = getCallParamName(Call);\n    } else if (UseInstructionNames) {\n      // If this parameter references a specific Value and this value has a name\n      // we use this name as it is likely to be unique and more useful than just\n      // a number.\n      if (Val->hasName())\n        ParameterName = Val->getName().str();\n      else if (LoadInst *LI = dyn_cast<LoadInst>(Val)) {\n        auto *LoadOrigin = LI->getPointerOperand()->stripInBoundsOffsets();\n        if (LoadOrigin->hasName()) {\n          ParameterName += \"_loaded_from_\";\n          ParameterName +=\n              LI->getPointerOperand()->stripInBoundsOffsets()->getName();\n        }\n      }\n    }\n\n    ParameterName = getIslCompatibleName(\"\", ParameterName, \"\");\n  }\n\n  isl::id Id = isl::id::alloc(getIslCtx(), ParameterName,\n                              const_cast<void *>((const void *)Parameter));\n  ParameterIds[Parameter] = Id;\n}\n\nvoid Scop::addParams(const ParameterSetTy &NewParameters) {\n  for (const SCEV *Parameter : NewParameters) {\n    // Normalize the SCEV to get the representing element for an invariant load.\n    Parameter = extractConstantFactor(Parameter, *SE).second;\n    Parameter = getRepresentingInvariantLoadSCEV(Parameter);\n\n    if (Parameters.insert(Parameter))\n      createParameterId(Parameter);\n  }\n}\n\nisl::id Scop::getIdForParam(const SCEV *Parameter) const {\n  // Normalize the SCEV to get the representing element for an invariant load.\n  Parameter = getRepresentingInvariantLoadSCEV(Parameter);\n  return ParameterIds.lookup(Parameter);\n}\n\nbool Scop::isDominatedBy(const DominatorTree &DT, BasicBlock *BB) const {\n  return DT.dominates(BB, getEntry());\n}\n\nvoid Scop::buildContext() {\n  isl::space Space = isl::space::params_alloc(getIslCtx(), 0);\n  Context = isl::set::universe(Space);\n  InvalidContext = isl::set::empty(Space);\n  AssumedContext = isl::set::universe(Space);\n  DefinedBehaviorContext = isl::set::universe(Space);\n}\n\nvoid Scop::addParameterBounds() {\n  unsigned PDim = 0;\n  for (auto *Parameter : Parameters) {\n    ConstantRange SRange = SE->getSignedRange(Parameter);\n    Context = addRangeBoundsToSet(Context, SRange, PDim++, isl::dim::param);\n  }\n  intersectDefinedBehavior(Context, AS_ASSUMPTION);\n}\n\nstatic std::vector<isl::id> getFortranArrayIds(Scop::array_range Arrays) {\n  std::vector<isl::id> OutermostSizeIds;\n  for (auto Array : Arrays) {\n    // To check if an array is a Fortran array, we check if it has a isl_pw_aff\n    // for its outermost dimension. Fortran arrays will have this since the\n    // outermost dimension size can be picked up from their runtime description.\n    // TODO: actually need to check if it has a FAD, but for now this works.\n    if (Array->getNumberOfDimensions() > 0) {\n      isl::pw_aff PwAff = Array->getDimensionSizePw(0);\n      if (!PwAff)\n        continue;\n\n      isl::id Id = PwAff.get_dim_id(isl::dim::param, 0);\n      assert(!Id.is_null() &&\n             \"Invalid Id for PwAff expression in Fortran array\");\n      OutermostSizeIds.push_back(Id);\n    }\n  }\n  return OutermostSizeIds;\n}\n\n// The FORTRAN array size parameters are known to be non-negative.\nstatic isl::set boundFortranArrayParams(isl::set Context,\n                                        Scop::array_range Arrays) {\n  std::vector<isl::id> OutermostSizeIds;\n  OutermostSizeIds = getFortranArrayIds(Arrays);\n\n  for (isl::id Id : OutermostSizeIds) {\n    int dim = Context.find_dim_by_id(isl::dim::param, Id);\n    Context = Context.lower_bound_si(isl::dim::param, dim, 0);\n  }\n\n  return Context;\n}\n\nvoid Scop::realignParams() {\n  if (PollyIgnoreParamBounds)\n    return;\n\n  // Add all parameters into a common model.\n  isl::space Space = getFullParamSpace();\n\n  // Align the parameters of all data structures to the model.\n  Context = Context.align_params(Space);\n  AssumedContext = AssumedContext.align_params(Space);\n  InvalidContext = InvalidContext.align_params(Space);\n\n  // Bound the size of the fortran array dimensions.\n  Context = boundFortranArrayParams(Context, arrays());\n\n  // As all parameters are known add bounds to them.\n  addParameterBounds();\n\n  for (ScopStmt &Stmt : *this)\n    Stmt.realignParams();\n  // Simplify the schedule according to the context too.\n  Schedule = Schedule.gist_domain_params(getContext());\n\n  // Predictable parameter order is required for JSON imports. Ensure alignment\n  // by explicitly calling align_params.\n  Schedule = Schedule.align_params(Space);\n}\n\nstatic isl::set simplifyAssumptionContext(isl::set AssumptionContext,\n                                          const Scop &S) {\n  // If we have modeled all blocks in the SCoP that have side effects we can\n  // simplify the context with the constraints that are needed for anything to\n  // be executed at all. However, if we have error blocks in the SCoP we already\n  // assumed some parameter combinations cannot occur and removed them from the\n  // domains, thus we cannot use the remaining domain to simplify the\n  // assumptions.\n  if (!S.hasErrorBlock()) {\n    auto DomainParameters = S.getDomains().params();\n    AssumptionContext = AssumptionContext.gist_params(DomainParameters);\n  }\n\n  AssumptionContext = AssumptionContext.gist_params(S.getContext());\n  return AssumptionContext;\n}\n\nvoid Scop::simplifyContexts() {\n  // The parameter constraints of the iteration domains give us a set of\n  // constraints that need to hold for all cases where at least a single\n  // statement iteration is executed in the whole scop. We now simplify the\n  // assumed context under the assumption that such constraints hold and at\n  // least a single statement iteration is executed. For cases where no\n  // statement instances are executed, the assumptions we have taken about\n  // the executed code do not matter and can be changed.\n  //\n  // WARNING: This only holds if the assumptions we have taken do not reduce\n  //          the set of statement instances that are executed. Otherwise we\n  //          may run into a case where the iteration domains suggest that\n  //          for a certain set of parameter constraints no code is executed,\n  //          but in the original program some computation would have been\n  //          performed. In such a case, modifying the run-time conditions and\n  //          possibly influencing the run-time check may cause certain scops\n  //          to not be executed.\n  //\n  // Example:\n  //\n  //   When delinearizing the following code:\n  //\n  //     for (long i = 0; i < 100; i++)\n  //       for (long j = 0; j < m; j++)\n  //         A[i+p][j] = 1.0;\n  //\n  //   we assume that the condition m <= 0 or (m >= 1 and p >= 0) holds as\n  //   otherwise we would access out of bound data. Now, knowing that code is\n  //   only executed for the case m >= 0, it is sufficient to assume p >= 0.\n  AssumedContext = simplifyAssumptionContext(AssumedContext, *this);\n  InvalidContext = InvalidContext.align_params(getParamSpace());\n  simplify(DefinedBehaviorContext);\n  DefinedBehaviorContext = DefinedBehaviorContext.align_params(getParamSpace());\n}\n\nisl::set Scop::getDomainConditions(const ScopStmt *Stmt) const {\n  return getDomainConditions(Stmt->getEntryBlock());\n}\n\nisl::set Scop::getDomainConditions(BasicBlock *BB) const {\n  auto DIt = DomainMap.find(BB);\n  if (DIt != DomainMap.end())\n    return DIt->getSecond();\n\n  auto &RI = *R.getRegionInfo();\n  auto *BBR = RI.getRegionFor(BB);\n  while (BBR->getEntry() == BB)\n    BBR = BBR->getParent();\n  return getDomainConditions(BBR->getEntry());\n}\n\nScop::Scop(Region &R, ScalarEvolution &ScalarEvolution, LoopInfo &LI,\n           DominatorTree &DT, ScopDetection::DetectionContext &DC,\n           OptimizationRemarkEmitter &ORE, int ID)\n    : IslCtx(isl_ctx_alloc(), isl_ctx_free), SE(&ScalarEvolution), DT(&DT),\n      R(R), name(None), HasSingleExitEdge(R.getExitingBlock()), DC(DC),\n      ORE(ORE), Affinator(this, LI), ID(ID) {\n  SmallVector<char *, 8> IslArgv;\n  IslArgv.reserve(1 + IslArgs.size());\n\n  // Substitute for program name.\n  IslArgv.push_back(const_cast<char *>(\"-polly-isl-arg\"));\n\n  for (std::string &Arg : IslArgs)\n    IslArgv.push_back(const_cast<char *>(Arg.c_str()));\n\n  // Abort if unknown argument is passed.\n  // Note that \"-V\" (print isl version) will always call exit(0), so we cannot\n  // avoid ISL aborting the program at this point.\n  unsigned IslParseFlags = ISL_ARG_ALL;\n\n  isl_ctx_parse_options(IslCtx.get(), IslArgv.size(), IslArgv.data(),\n                        IslParseFlags);\n\n  if (IslOnErrorAbort)\n    isl_options_set_on_error(getIslCtx().get(), ISL_ON_ERROR_ABORT);\n  buildContext();\n}\n\nScop::~Scop() = default;\n\nvoid Scop::removeFromStmtMap(ScopStmt &Stmt) {\n  for (Instruction *Inst : Stmt.getInstructions())\n    InstStmtMap.erase(Inst);\n\n  if (Stmt.isRegionStmt()) {\n    for (BasicBlock *BB : Stmt.getRegion()->blocks()) {\n      StmtMap.erase(BB);\n      // Skip entry basic block, as its instructions are already deleted as\n      // part of the statement's instruction list.\n      if (BB == Stmt.getEntryBlock())\n        continue;\n      for (Instruction &Inst : *BB)\n        InstStmtMap.erase(&Inst);\n    }\n  } else {\n    auto StmtMapIt = StmtMap.find(Stmt.getBasicBlock());\n    if (StmtMapIt != StmtMap.end())\n      StmtMapIt->second.erase(std::remove(StmtMapIt->second.begin(),\n                                          StmtMapIt->second.end(), &Stmt),\n                              StmtMapIt->second.end());\n    for (Instruction *Inst : Stmt.getInstructions())\n      InstStmtMap.erase(Inst);\n  }\n}\n\nvoid Scop::removeStmts(function_ref<bool(ScopStmt &)> ShouldDelete,\n                       bool AfterHoisting) {\n  for (auto StmtIt = Stmts.begin(), StmtEnd = Stmts.end(); StmtIt != StmtEnd;) {\n    if (!ShouldDelete(*StmtIt)) {\n      StmtIt++;\n      continue;\n    }\n\n    // Start with removing all of the statement's accesses including erasing it\n    // from all maps that are pointing to them.\n    // Make a temporary copy because removing MAs invalidates the iterator.\n    SmallVector<MemoryAccess *, 16> MAList(StmtIt->begin(), StmtIt->end());\n    for (MemoryAccess *MA : MAList)\n      StmtIt->removeSingleMemoryAccess(MA, AfterHoisting);\n\n    removeFromStmtMap(*StmtIt);\n    StmtIt = Stmts.erase(StmtIt);\n  }\n}\n\nvoid Scop::removeStmtNotInDomainMap() {\n  removeStmts([this](ScopStmt &Stmt) -> bool {\n    isl::set Domain = DomainMap.lookup(Stmt.getEntryBlock());\n    if (!Domain)\n      return true;\n    return Domain.is_empty();\n  });\n}\n\nvoid Scop::simplifySCoP(bool AfterHoisting) {\n  removeStmts(\n      [AfterHoisting](ScopStmt &Stmt) -> bool {\n        // Never delete statements that contain calls to debug functions.\n        if (hasDebugCall(&Stmt))\n          return false;\n\n        bool RemoveStmt = Stmt.isEmpty();\n\n        // Remove read only statements only after invariant load hoisting.\n        if (!RemoveStmt && AfterHoisting) {\n          bool OnlyRead = true;\n          for (MemoryAccess *MA : Stmt) {\n            if (MA->isRead())\n              continue;\n\n            OnlyRead = false;\n            break;\n          }\n\n          RemoveStmt = OnlyRead;\n        }\n        return RemoveStmt;\n      },\n      AfterHoisting);\n}\n\nInvariantEquivClassTy *Scop::lookupInvariantEquivClass(Value *Val) {\n  LoadInst *LInst = dyn_cast<LoadInst>(Val);\n  if (!LInst)\n    return nullptr;\n\n  if (Value *Rep = InvEquivClassVMap.lookup(LInst))\n    LInst = cast<LoadInst>(Rep);\n\n  Type *Ty = LInst->getType();\n  const SCEV *PointerSCEV = SE->getSCEV(LInst->getPointerOperand());\n  for (auto &IAClass : InvariantEquivClasses) {\n    if (PointerSCEV != IAClass.IdentifyingPointer || Ty != IAClass.AccessType)\n      continue;\n\n    auto &MAs = IAClass.InvariantAccesses;\n    for (auto *MA : MAs)\n      if (MA->getAccessInstruction() == Val)\n        return &IAClass;\n  }\n\n  return nullptr;\n}\n\nScopArrayInfo *Scop::getOrCreateScopArrayInfo(Value *BasePtr, Type *ElementType,\n                                              ArrayRef<const SCEV *> Sizes,\n                                              MemoryKind Kind,\n                                              const char *BaseName) {\n  assert((BasePtr || BaseName) &&\n         \"BasePtr and BaseName can not be nullptr at the same time.\");\n  assert(!(BasePtr && BaseName) && \"BaseName is redundant.\");\n  auto &SAI = BasePtr ? ScopArrayInfoMap[std::make_pair(BasePtr, Kind)]\n                      : ScopArrayNameMap[BaseName];\n  if (!SAI) {\n    auto &DL = getFunction().getParent()->getDataLayout();\n    SAI.reset(new ScopArrayInfo(BasePtr, ElementType, getIslCtx(), Sizes, Kind,\n                                DL, this, BaseName));\n    ScopArrayInfoSet.insert(SAI.get());\n  } else {\n    SAI->updateElementType(ElementType);\n    // In case of mismatching array sizes, we bail out by setting the run-time\n    // context to false.\n    if (!SAI->updateSizes(Sizes))\n      invalidate(DELINEARIZATION, DebugLoc());\n  }\n  return SAI.get();\n}\n\nScopArrayInfo *Scop::createScopArrayInfo(Type *ElementType,\n                                         const std::string &BaseName,\n                                         const std::vector<unsigned> &Sizes) {\n  auto *DimSizeType = Type::getInt64Ty(getSE()->getContext());\n  std::vector<const SCEV *> SCEVSizes;\n\n  for (auto size : Sizes)\n    if (size)\n      SCEVSizes.push_back(getSE()->getConstant(DimSizeType, size, false));\n    else\n      SCEVSizes.push_back(nullptr);\n\n  auto *SAI = getOrCreateScopArrayInfo(nullptr, ElementType, SCEVSizes,\n                                       MemoryKind::Array, BaseName.c_str());\n  return SAI;\n}\n\nScopArrayInfo *Scop::getScopArrayInfoOrNull(Value *BasePtr, MemoryKind Kind) {\n  auto *SAI = ScopArrayInfoMap[std::make_pair(BasePtr, Kind)].get();\n  return SAI;\n}\n\nScopArrayInfo *Scop::getScopArrayInfo(Value *BasePtr, MemoryKind Kind) {\n  auto *SAI = getScopArrayInfoOrNull(BasePtr, Kind);\n  assert(SAI && \"No ScopArrayInfo available for this base pointer\");\n  return SAI;\n}\n\nstd::string Scop::getContextStr() const { return getContext().to_str(); }\n\nstd::string Scop::getAssumedContextStr() const {\n  assert(AssumedContext && \"Assumed context not yet built\");\n  return AssumedContext.to_str();\n}\n\nstd::string Scop::getInvalidContextStr() const {\n  return InvalidContext.to_str();\n}\n\nstd::string Scop::getNameStr() const {\n  std::string ExitName, EntryName;\n  std::tie(EntryName, ExitName) = getEntryExitStr();\n  return EntryName + \"---\" + ExitName;\n}\n\nstd::pair<std::string, std::string> Scop::getEntryExitStr() const {\n  std::string ExitName, EntryName;\n  raw_string_ostream ExitStr(ExitName);\n  raw_string_ostream EntryStr(EntryName);\n\n  R.getEntry()->printAsOperand(EntryStr, false);\n  EntryStr.str();\n\n  if (R.getExit()) {\n    R.getExit()->printAsOperand(ExitStr, false);\n    ExitStr.str();\n  } else\n    ExitName = \"FunctionExit\";\n\n  return std::make_pair(EntryName, ExitName);\n}\n\nisl::set Scop::getContext() const { return Context; }\n\nisl::space Scop::getParamSpace() const { return getContext().get_space(); }\n\nisl::space Scop::getFullParamSpace() const {\n  std::vector<isl::id> FortranIDs;\n  FortranIDs = getFortranArrayIds(arrays());\n\n  isl::space Space = isl::space::params_alloc(\n      getIslCtx(), ParameterIds.size() + FortranIDs.size());\n\n  unsigned PDim = 0;\n  for (const SCEV *Parameter : Parameters) {\n    isl::id Id = getIdForParam(Parameter);\n    Space = Space.set_dim_id(isl::dim::param, PDim++, Id);\n  }\n\n  for (isl::id Id : FortranIDs)\n    Space = Space.set_dim_id(isl::dim::param, PDim++, Id);\n\n  return Space;\n}\n\nisl::set Scop::getAssumedContext() const {\n  assert(AssumedContext && \"Assumed context not yet built\");\n  return AssumedContext;\n}\n\nbool Scop::isProfitable(bool ScalarsAreUnprofitable) const {\n  if (PollyProcessUnprofitable)\n    return true;\n\n  if (isEmpty())\n    return false;\n\n  unsigned OptimizableStmtsOrLoops = 0;\n  for (auto &Stmt : *this) {\n    if (Stmt.getNumIterators() == 0)\n      continue;\n\n    bool ContainsArrayAccs = false;\n    bool ContainsScalarAccs = false;\n    for (auto *MA : Stmt) {\n      if (MA->isRead())\n        continue;\n      ContainsArrayAccs |= MA->isLatestArrayKind();\n      ContainsScalarAccs |= MA->isLatestScalarKind();\n    }\n\n    if (!ScalarsAreUnprofitable || (ContainsArrayAccs && !ContainsScalarAccs))\n      OptimizableStmtsOrLoops += Stmt.getNumIterators();\n  }\n\n  return OptimizableStmtsOrLoops > 1;\n}\n\nbool Scop::hasFeasibleRuntimeContext() const {\n  if (Stmts.empty())\n    return false;\n\n  isl::set PositiveContext = getAssumedContext();\n  isl::set NegativeContext = getInvalidContext();\n  PositiveContext = PositiveContext.intersect_params(Context);\n  PositiveContext = PositiveContext.intersect_params(getDomains().params());\n  return PositiveContext.is_empty().is_false() &&\n         PositiveContext.is_subset(NegativeContext).is_false();\n}\n\nMemoryAccess *Scop::lookupBasePtrAccess(MemoryAccess *MA) {\n  Value *PointerBase = MA->getOriginalBaseAddr();\n\n  auto *PointerBaseInst = dyn_cast<Instruction>(PointerBase);\n  if (!PointerBaseInst)\n    return nullptr;\n\n  auto *BasePtrStmt = getStmtFor(PointerBaseInst);\n  if (!BasePtrStmt)\n    return nullptr;\n\n  return BasePtrStmt->getArrayAccessOrNULLFor(PointerBaseInst);\n}\n\nstatic std::string toString(AssumptionKind Kind) {\n  switch (Kind) {\n  case ALIASING:\n    return \"No-aliasing\";\n  case INBOUNDS:\n    return \"Inbounds\";\n  case WRAPPING:\n    return \"No-overflows\";\n  case UNSIGNED:\n    return \"Signed-unsigned\";\n  case COMPLEXITY:\n    return \"Low complexity\";\n  case PROFITABLE:\n    return \"Profitable\";\n  case ERRORBLOCK:\n    return \"No-error\";\n  case INFINITELOOP:\n    return \"Finite loop\";\n  case INVARIANTLOAD:\n    return \"Invariant load\";\n  case DELINEARIZATION:\n    return \"Delinearization\";\n  }\n  llvm_unreachable(\"Unknown AssumptionKind!\");\n}\n\nbool Scop::isEffectiveAssumption(isl::set Set, AssumptionSign Sign) {\n  if (Sign == AS_ASSUMPTION) {\n    if (Context.is_subset(Set))\n      return false;\n\n    if (AssumedContext.is_subset(Set))\n      return false;\n  } else {\n    if (Set.is_disjoint(Context))\n      return false;\n\n    if (Set.is_subset(InvalidContext))\n      return false;\n  }\n  return true;\n}\n\nbool Scop::trackAssumption(AssumptionKind Kind, isl::set Set, DebugLoc Loc,\n                           AssumptionSign Sign, BasicBlock *BB) {\n  if (PollyRemarksMinimal && !isEffectiveAssumption(Set, Sign))\n    return false;\n\n  // Do never emit trivial assumptions as they only clutter the output.\n  if (!PollyRemarksMinimal) {\n    isl::set Univ;\n    if (Sign == AS_ASSUMPTION)\n      Univ = isl::set::universe(Set.get_space());\n\n    bool IsTrivial = (Sign == AS_RESTRICTION && Set.is_empty()) ||\n                     (Sign == AS_ASSUMPTION && Univ.is_equal(Set));\n\n    if (IsTrivial)\n      return false;\n  }\n\n  switch (Kind) {\n  case ALIASING:\n    AssumptionsAliasing++;\n    break;\n  case INBOUNDS:\n    AssumptionsInbounds++;\n    break;\n  case WRAPPING:\n    AssumptionsWrapping++;\n    break;\n  case UNSIGNED:\n    AssumptionsUnsigned++;\n    break;\n  case COMPLEXITY:\n    AssumptionsComplexity++;\n    break;\n  case PROFITABLE:\n    AssumptionsUnprofitable++;\n    break;\n  case ERRORBLOCK:\n    AssumptionsErrorBlock++;\n    break;\n  case INFINITELOOP:\n    AssumptionsInfiniteLoop++;\n    break;\n  case INVARIANTLOAD:\n    AssumptionsInvariantLoad++;\n    break;\n  case DELINEARIZATION:\n    AssumptionsDelinearization++;\n    break;\n  }\n\n  auto Suffix = Sign == AS_ASSUMPTION ? \" assumption:\\t\" : \" restriction:\\t\";\n  std::string Msg = toString(Kind) + Suffix + Set.to_str();\n  if (BB)\n    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"AssumpRestrict\", Loc, BB)\n             << Msg);\n  else\n    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"AssumpRestrict\", Loc,\n                                        R.getEntry())\n             << Msg);\n  return true;\n}\n\nvoid Scop::addAssumption(AssumptionKind Kind, isl::set Set, DebugLoc Loc,\n                         AssumptionSign Sign, BasicBlock *BB,\n                         bool RequiresRTC) {\n  // Simplify the assumptions/restrictions first.\n  Set = Set.gist_params(getContext());\n  intersectDefinedBehavior(Set, Sign);\n\n  if (!RequiresRTC)\n    return;\n\n  if (!trackAssumption(Kind, Set, Loc, Sign, BB))\n    return;\n\n  if (Sign == AS_ASSUMPTION)\n    AssumedContext = AssumedContext.intersect(Set).coalesce();\n  else\n    InvalidContext = InvalidContext.unite(Set).coalesce();\n}\n\nvoid Scop::intersectDefinedBehavior(isl::set Set, AssumptionSign Sign) {\n  if (!DefinedBehaviorContext)\n    return;\n\n  if (Sign == AS_ASSUMPTION)\n    DefinedBehaviorContext = DefinedBehaviorContext.intersect(Set);\n  else\n    DefinedBehaviorContext = DefinedBehaviorContext.subtract(Set);\n\n  // Limit the complexity of the context. If complexity is exceeded, simplify\n  // the set and check again.\n  if (DefinedBehaviorContext.n_basic_set() >\n      MaxDisjunktsInDefinedBehaviourContext) {\n    simplify(DefinedBehaviorContext);\n    if (DefinedBehaviorContext.n_basic_set() >\n        MaxDisjunktsInDefinedBehaviourContext)\n      DefinedBehaviorContext = nullptr;\n  }\n}\n\nvoid Scop::invalidate(AssumptionKind Kind, DebugLoc Loc, BasicBlock *BB) {\n  LLVM_DEBUG(dbgs() << \"Invalidate SCoP because of reason \" << Kind << \"\\n\");\n  addAssumption(Kind, isl::set::empty(getParamSpace()), Loc, AS_ASSUMPTION, BB);\n}\n\nisl::set Scop::getInvalidContext() const { return InvalidContext; }\n\nvoid Scop::printContext(raw_ostream &OS) const {\n  OS << \"Context:\\n\";\n  OS.indent(4) << Context << \"\\n\";\n\n  OS.indent(4) << \"Assumed Context:\\n\";\n  OS.indent(4) << AssumedContext << \"\\n\";\n\n  OS.indent(4) << \"Invalid Context:\\n\";\n  OS.indent(4) << InvalidContext << \"\\n\";\n\n  OS.indent(4) << \"Defined Behavior Context:\\n\";\n  if (DefinedBehaviorContext)\n    OS.indent(4) << DefinedBehaviorContext << \"\\n\";\n  else\n    OS.indent(4) << \"<unavailable>\\n\";\n\n  unsigned Dim = 0;\n  for (const SCEV *Parameter : Parameters)\n    OS.indent(4) << \"p\" << Dim++ << \": \" << *Parameter << \"\\n\";\n}\n\nvoid Scop::printAliasAssumptions(raw_ostream &OS) const {\n  int noOfGroups = 0;\n  for (const MinMaxVectorPairTy &Pair : MinMaxAliasGroups) {\n    if (Pair.second.size() == 0)\n      noOfGroups += 1;\n    else\n      noOfGroups += Pair.second.size();\n  }\n\n  OS.indent(4) << \"Alias Groups (\" << noOfGroups << \"):\\n\";\n  if (MinMaxAliasGroups.empty()) {\n    OS.indent(8) << \"n/a\\n\";\n    return;\n  }\n\n  for (const MinMaxVectorPairTy &Pair : MinMaxAliasGroups) {\n\n    // If the group has no read only accesses print the write accesses.\n    if (Pair.second.empty()) {\n      OS.indent(8) << \"[[\";\n      for (const MinMaxAccessTy &MMANonReadOnly : Pair.first) {\n        OS << \" <\" << MMANonReadOnly.first << \", \" << MMANonReadOnly.second\n           << \">\";\n      }\n      OS << \" ]]\\n\";\n    }\n\n    for (const MinMaxAccessTy &MMAReadOnly : Pair.second) {\n      OS.indent(8) << \"[[\";\n      OS << \" <\" << MMAReadOnly.first << \", \" << MMAReadOnly.second << \">\";\n      for (const MinMaxAccessTy &MMANonReadOnly : Pair.first) {\n        OS << \" <\" << MMANonReadOnly.first << \", \" << MMANonReadOnly.second\n           << \">\";\n      }\n      OS << \" ]]\\n\";\n    }\n  }\n}\n\nvoid Scop::printStatements(raw_ostream &OS, bool PrintInstructions) const {\n  OS << \"Statements {\\n\";\n\n  for (const ScopStmt &Stmt : *this) {\n    OS.indent(4);\n    Stmt.print(OS, PrintInstructions);\n  }\n\n  OS.indent(4) << \"}\\n\";\n}\n\nvoid Scop::printArrayInfo(raw_ostream &OS) const {\n  OS << \"Arrays {\\n\";\n\n  for (auto &Array : arrays())\n    Array->print(OS);\n\n  OS.indent(4) << \"}\\n\";\n\n  OS.indent(4) << \"Arrays (Bounds as pw_affs) {\\n\";\n\n  for (auto &Array : arrays())\n    Array->print(OS, /* SizeAsPwAff */ true);\n\n  OS.indent(4) << \"}\\n\";\n}\n\nvoid Scop::print(raw_ostream &OS, bool PrintInstructions) const {\n  OS.indent(4) << \"Function: \" << getFunction().getName() << \"\\n\";\n  OS.indent(4) << \"Region: \" << getNameStr() << \"\\n\";\n  OS.indent(4) << \"Max Loop Depth:  \" << getMaxLoopDepth() << \"\\n\";\n  OS.indent(4) << \"Invariant Accesses: {\\n\";\n  for (const auto &IAClass : InvariantEquivClasses) {\n    const auto &MAs = IAClass.InvariantAccesses;\n    if (MAs.empty()) {\n      OS.indent(12) << \"Class Pointer: \" << *IAClass.IdentifyingPointer << \"\\n\";\n    } else {\n      MAs.front()->print(OS);\n      OS.indent(12) << \"Execution Context: \" << IAClass.ExecutionContext\n                    << \"\\n\";\n    }\n  }\n  OS.indent(4) << \"}\\n\";\n  printContext(OS.indent(4));\n  printArrayInfo(OS.indent(4));\n  printAliasAssumptions(OS);\n  printStatements(OS.indent(4), PrintInstructions);\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void Scop::dump() const { print(dbgs(), true); }\n#endif\n\nisl::ctx Scop::getIslCtx() const { return IslCtx.get(); }\n\n__isl_give PWACtx Scop::getPwAff(const SCEV *E, BasicBlock *BB,\n                                 bool NonNegative,\n                                 RecordedAssumptionsTy *RecordedAssumptions) {\n  // First try to use the SCEVAffinator to generate a piecewise defined\n  // affine function from @p E in the context of @p BB. If that tasks becomes to\n  // complex the affinator might return a nullptr. In such a case we invalidate\n  // the SCoP and return a dummy value. This way we do not need to add error\n  // handling code to all users of this function.\n  auto PWAC = Affinator.getPwAff(E, BB, RecordedAssumptions);\n  if (PWAC.first) {\n    // TODO: We could use a heuristic and either use:\n    //         SCEVAffinator::takeNonNegativeAssumption\n    //       or\n    //         SCEVAffinator::interpretAsUnsigned\n    //       to deal with unsigned or \"NonNegative\" SCEVs.\n    if (NonNegative)\n      Affinator.takeNonNegativeAssumption(PWAC, RecordedAssumptions);\n    return PWAC;\n  }\n\n  auto DL = BB ? BB->getTerminator()->getDebugLoc() : DebugLoc();\n  invalidate(COMPLEXITY, DL, BB);\n  return Affinator.getPwAff(SE->getZero(E->getType()), BB, RecordedAssumptions);\n}\n\nisl::union_set Scop::getDomains() const {\n  isl_space *EmptySpace = isl_space_params_alloc(getIslCtx().get(), 0);\n  isl_union_set *Domain = isl_union_set_empty(EmptySpace);\n\n  for (const ScopStmt &Stmt : *this)\n    Domain = isl_union_set_add_set(Domain, Stmt.getDomain().release());\n\n  return isl::manage(Domain);\n}\n\nisl::pw_aff Scop::getPwAffOnly(const SCEV *E, BasicBlock *BB,\n                               RecordedAssumptionsTy *RecordedAssumptions) {\n  PWACtx PWAC = getPwAff(E, BB, RecordedAssumptions);\n  return PWAC.first;\n}\n\nisl::union_map\nScop::getAccessesOfType(std::function<bool(MemoryAccess &)> Predicate) {\n  isl::union_map Accesses = isl::union_map::empty(getParamSpace());\n\n  for (ScopStmt &Stmt : *this) {\n    for (MemoryAccess *MA : Stmt) {\n      if (!Predicate(*MA))\n        continue;\n\n      isl::set Domain = Stmt.getDomain();\n      isl::map AccessDomain = MA->getAccessRelation();\n      AccessDomain = AccessDomain.intersect_domain(Domain);\n      Accesses = Accesses.add_map(AccessDomain);\n    }\n  }\n\n  return Accesses.coalesce();\n}\n\nisl::union_map Scop::getMustWrites() {\n  return getAccessesOfType([](MemoryAccess &MA) { return MA.isMustWrite(); });\n}\n\nisl::union_map Scop::getMayWrites() {\n  return getAccessesOfType([](MemoryAccess &MA) { return MA.isMayWrite(); });\n}\n\nisl::union_map Scop::getWrites() {\n  return getAccessesOfType([](MemoryAccess &MA) { return MA.isWrite(); });\n}\n\nisl::union_map Scop::getReads() {\n  return getAccessesOfType([](MemoryAccess &MA) { return MA.isRead(); });\n}\n\nisl::union_map Scop::getAccesses() {\n  return getAccessesOfType([](MemoryAccess &MA) { return true; });\n}\n\nisl::union_map Scop::getAccesses(ScopArrayInfo *Array) {\n  return getAccessesOfType(\n      [Array](MemoryAccess &MA) { return MA.getScopArrayInfo() == Array; });\n}\n\nisl::union_map Scop::getSchedule() const {\n  auto Tree = getScheduleTree();\n  return Tree.get_map();\n}\n\nisl::schedule Scop::getScheduleTree() const {\n  return Schedule.intersect_domain(getDomains());\n}\n\nvoid Scop::setSchedule(isl::union_map NewSchedule) {\n  auto S = isl::schedule::from_domain(getDomains());\n  Schedule = S.insert_partial_schedule(\n      isl::multi_union_pw_aff::from_union_map(NewSchedule));\n  ScheduleModified = true;\n}\n\nvoid Scop::setScheduleTree(isl::schedule NewSchedule) {\n  Schedule = NewSchedule;\n  ScheduleModified = true;\n}\n\nbool Scop::restrictDomains(isl::union_set Domain) {\n  bool Changed = false;\n  for (ScopStmt &Stmt : *this) {\n    isl::union_set StmtDomain = isl::union_set(Stmt.getDomain());\n    isl::union_set NewStmtDomain = StmtDomain.intersect(Domain);\n\n    if (StmtDomain.is_subset(NewStmtDomain))\n      continue;\n\n    Changed = true;\n\n    NewStmtDomain = NewStmtDomain.coalesce();\n\n    if (NewStmtDomain.is_empty())\n      Stmt.restrictDomain(isl::set::empty(Stmt.getDomainSpace()));\n    else\n      Stmt.restrictDomain(isl::set(NewStmtDomain));\n  }\n  return Changed;\n}\n\nScalarEvolution *Scop::getSE() const { return SE; }\n\nvoid Scop::addScopStmt(BasicBlock *BB, StringRef Name, Loop *SurroundingLoop,\n                       std::vector<Instruction *> Instructions) {\n  assert(BB && \"Unexpected nullptr!\");\n  Stmts.emplace_back(*this, *BB, Name, SurroundingLoop, Instructions);\n  auto *Stmt = &Stmts.back();\n  StmtMap[BB].push_back(Stmt);\n  for (Instruction *Inst : Instructions) {\n    assert(!InstStmtMap.count(Inst) &&\n           \"Unexpected statement corresponding to the instruction.\");\n    InstStmtMap[Inst] = Stmt;\n  }\n}\n\nvoid Scop::addScopStmt(Region *R, StringRef Name, Loop *SurroundingLoop,\n                       std::vector<Instruction *> Instructions) {\n  assert(R && \"Unexpected nullptr!\");\n  Stmts.emplace_back(*this, *R, Name, SurroundingLoop, Instructions);\n  auto *Stmt = &Stmts.back();\n\n  for (Instruction *Inst : Instructions) {\n    assert(!InstStmtMap.count(Inst) &&\n           \"Unexpected statement corresponding to the instruction.\");\n    InstStmtMap[Inst] = Stmt;\n  }\n\n  for (BasicBlock *BB : R->blocks()) {\n    StmtMap[BB].push_back(Stmt);\n    if (BB == R->getEntry())\n      continue;\n    for (Instruction &Inst : *BB) {\n      assert(!InstStmtMap.count(&Inst) &&\n             \"Unexpected statement corresponding to the instruction.\");\n      InstStmtMap[&Inst] = Stmt;\n    }\n  }\n}\n\nScopStmt *Scop::addScopStmt(isl::map SourceRel, isl::map TargetRel,\n                            isl::set Domain) {\n#ifndef NDEBUG\n  isl::set SourceDomain = SourceRel.domain();\n  isl::set TargetDomain = TargetRel.domain();\n  assert(Domain.is_subset(TargetDomain) &&\n         \"Target access not defined for complete statement domain\");\n  assert(Domain.is_subset(SourceDomain) &&\n         \"Source access not defined for complete statement domain\");\n#endif\n  Stmts.emplace_back(*this, SourceRel, TargetRel, Domain);\n  CopyStmtsNum++;\n  return &(Stmts.back());\n}\n\nArrayRef<ScopStmt *> Scop::getStmtListFor(BasicBlock *BB) const {\n  auto StmtMapIt = StmtMap.find(BB);\n  if (StmtMapIt == StmtMap.end())\n    return {};\n  return StmtMapIt->second;\n}\n\nScopStmt *Scop::getIncomingStmtFor(const Use &U) const {\n  auto *PHI = cast<PHINode>(U.getUser());\n  BasicBlock *IncomingBB = PHI->getIncomingBlock(U);\n\n  // If the value is a non-synthesizable from the incoming block, use the\n  // statement that contains it as user statement.\n  if (auto *IncomingInst = dyn_cast<Instruction>(U.get())) {\n    if (IncomingInst->getParent() == IncomingBB) {\n      if (ScopStmt *IncomingStmt = getStmtFor(IncomingInst))\n        return IncomingStmt;\n    }\n  }\n\n  // Otherwise, use the epilogue/last statement.\n  return getLastStmtFor(IncomingBB);\n}\n\nScopStmt *Scop::getLastStmtFor(BasicBlock *BB) const {\n  ArrayRef<ScopStmt *> StmtList = getStmtListFor(BB);\n  if (!StmtList.empty())\n    return StmtList.back();\n  return nullptr;\n}\n\nArrayRef<ScopStmt *> Scop::getStmtListFor(RegionNode *RN) const {\n  if (RN->isSubRegion())\n    return getStmtListFor(RN->getNodeAs<Region>());\n  return getStmtListFor(RN->getNodeAs<BasicBlock>());\n}\n\nArrayRef<ScopStmt *> Scop::getStmtListFor(Region *R) const {\n  return getStmtListFor(R->getEntry());\n}\n\nint Scop::getRelativeLoopDepth(const Loop *L) const {\n  if (!L || !R.contains(L))\n    return -1;\n  // outermostLoopInRegion always returns nullptr for top level regions\n  if (R.isTopLevelRegion()) {\n    // LoopInfo's depths start at 1, we start at 0\n    return L->getLoopDepth() - 1;\n  } else {\n    Loop *OuterLoop = R.outermostLoopInRegion(const_cast<Loop *>(L));\n    assert(OuterLoop);\n    return L->getLoopDepth() - OuterLoop->getLoopDepth();\n  }\n}\n\nScopArrayInfo *Scop::getArrayInfoByName(const std::string BaseName) {\n  for (auto &SAI : arrays()) {\n    if (SAI->getName() == BaseName)\n      return SAI;\n  }\n  return nullptr;\n}\n\nvoid Scop::addAccessData(MemoryAccess *Access) {\n  const ScopArrayInfo *SAI = Access->getOriginalScopArrayInfo();\n  assert(SAI && \"can only use after access relations have been constructed\");\n\n  if (Access->isOriginalValueKind() && Access->isRead())\n    ValueUseAccs[SAI].push_back(Access);\n  else if (Access->isOriginalAnyPHIKind() && Access->isWrite())\n    PHIIncomingAccs[SAI].push_back(Access);\n}\n\nvoid Scop::removeAccessData(MemoryAccess *Access) {\n  if (Access->isOriginalValueKind() && Access->isWrite()) {\n    ValueDefAccs.erase(Access->getAccessValue());\n  } else if (Access->isOriginalValueKind() && Access->isRead()) {\n    auto &Uses = ValueUseAccs[Access->getScopArrayInfo()];\n    auto NewEnd = std::remove(Uses.begin(), Uses.end(), Access);\n    Uses.erase(NewEnd, Uses.end());\n  } else if (Access->isOriginalPHIKind() && Access->isRead()) {\n    PHINode *PHI = cast<PHINode>(Access->getAccessInstruction());\n    PHIReadAccs.erase(PHI);\n  } else if (Access->isOriginalAnyPHIKind() && Access->isWrite()) {\n    auto &Incomings = PHIIncomingAccs[Access->getScopArrayInfo()];\n    auto NewEnd = std::remove(Incomings.begin(), Incomings.end(), Access);\n    Incomings.erase(NewEnd, Incomings.end());\n  }\n}\n\nMemoryAccess *Scop::getValueDef(const ScopArrayInfo *SAI) const {\n  assert(SAI->isValueKind());\n\n  Instruction *Val = dyn_cast<Instruction>(SAI->getBasePtr());\n  if (!Val)\n    return nullptr;\n\n  return ValueDefAccs.lookup(Val);\n}\n\nArrayRef<MemoryAccess *> Scop::getValueUses(const ScopArrayInfo *SAI) const {\n  assert(SAI->isValueKind());\n  auto It = ValueUseAccs.find(SAI);\n  if (It == ValueUseAccs.end())\n    return {};\n  return It->second;\n}\n\nMemoryAccess *Scop::getPHIRead(const ScopArrayInfo *SAI) const {\n  assert(SAI->isPHIKind() || SAI->isExitPHIKind());\n\n  if (SAI->isExitPHIKind())\n    return nullptr;\n\n  PHINode *PHI = cast<PHINode>(SAI->getBasePtr());\n  return PHIReadAccs.lookup(PHI);\n}\n\nArrayRef<MemoryAccess *> Scop::getPHIIncomings(const ScopArrayInfo *SAI) const {\n  assert(SAI->isPHIKind() || SAI->isExitPHIKind());\n  auto It = PHIIncomingAccs.find(SAI);\n  if (It == PHIIncomingAccs.end())\n    return {};\n  return It->second;\n}\n\nbool Scop::isEscaping(Instruction *Inst) {\n  assert(contains(Inst) && \"The concept of escaping makes only sense for \"\n                           \"values defined inside the SCoP\");\n\n  for (Use &Use : Inst->uses()) {\n    BasicBlock *UserBB = getUseBlock(Use);\n    if (!contains(UserBB))\n      return true;\n\n    // When the SCoP region exit needs to be simplified, PHIs in the region exit\n    // move to a new basic block such that its incoming blocks are not in the\n    // SCoP anymore.\n    if (hasSingleExitEdge() && isa<PHINode>(Use.getUser()) &&\n        isExit(cast<PHINode>(Use.getUser())->getParent()))\n      return true;\n  }\n  return false;\n}\n\nvoid Scop::incrementNumberOfAliasingAssumptions(unsigned step) {\n  AssumptionsAliasing += step;\n}\n\nScop::ScopStatistics Scop::getStatistics() const {\n  ScopStatistics Result;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_STATS)\n  auto LoopStat = ScopDetection::countBeneficialLoops(&R, *SE, *getLI(), 0);\n\n  int NumTotalLoops = LoopStat.NumLoops;\n  Result.NumBoxedLoops = getBoxedLoops().size();\n  Result.NumAffineLoops = NumTotalLoops - Result.NumBoxedLoops;\n\n  for (const ScopStmt &Stmt : *this) {\n    isl::set Domain = Stmt.getDomain().intersect_params(getContext());\n    bool IsInLoop = Stmt.getNumIterators() >= 1;\n    for (MemoryAccess *MA : Stmt) {\n      if (!MA->isWrite())\n        continue;\n\n      if (MA->isLatestValueKind()) {\n        Result.NumValueWrites += 1;\n        if (IsInLoop)\n          Result.NumValueWritesInLoops += 1;\n      }\n\n      if (MA->isLatestAnyPHIKind()) {\n        Result.NumPHIWrites += 1;\n        if (IsInLoop)\n          Result.NumPHIWritesInLoops += 1;\n      }\n\n      isl::set AccSet =\n          MA->getAccessRelation().intersect_domain(Domain).range();\n      if (AccSet.is_singleton()) {\n        Result.NumSingletonWrites += 1;\n        if (IsInLoop)\n          Result.NumSingletonWritesInLoops += 1;\n      }\n    }\n  }\n#endif\n  return Result;\n}\n\nraw_ostream &polly::operator<<(raw_ostream &OS, const Scop &scop) {\n  scop.print(OS, PollyPrintInstructions);\n  return OS;\n}\n\n//===----------------------------------------------------------------------===//\nvoid ScopInfoRegionPass::getAnalysisUsage(AnalysisUsage &AU) const {\n  AU.addRequired<LoopInfoWrapperPass>();\n  AU.addRequired<RegionInfoPass>();\n  AU.addRequired<DominatorTreeWrapperPass>();\n  AU.addRequiredTransitive<ScalarEvolutionWrapperPass>();\n  AU.addRequiredTransitive<ScopDetectionWrapperPass>();\n  AU.addRequired<AAResultsWrapperPass>();\n  AU.addRequired<AssumptionCacheTracker>();\n  AU.addRequired<OptimizationRemarkEmitterWrapperPass>();\n  AU.setPreservesAll();\n}\n\nvoid updateLoopCountStatistic(ScopDetection::LoopStats Stats,\n                              Scop::ScopStatistics ScopStats) {\n  assert(Stats.NumLoops == ScopStats.NumAffineLoops + ScopStats.NumBoxedLoops);\n\n  NumScops++;\n  NumLoopsInScop += Stats.NumLoops;\n  MaxNumLoopsInScop =\n      std::max(MaxNumLoopsInScop.getValue(), (unsigned)Stats.NumLoops);\n\n  if (Stats.MaxDepth == 0)\n    NumScopsDepthZero++;\n  else if (Stats.MaxDepth == 1)\n    NumScopsDepthOne++;\n  else if (Stats.MaxDepth == 2)\n    NumScopsDepthTwo++;\n  else if (Stats.MaxDepth == 3)\n    NumScopsDepthThree++;\n  else if (Stats.MaxDepth == 4)\n    NumScopsDepthFour++;\n  else if (Stats.MaxDepth == 5)\n    NumScopsDepthFive++;\n  else\n    NumScopsDepthLarger++;\n\n  NumAffineLoops += ScopStats.NumAffineLoops;\n  NumBoxedLoops += ScopStats.NumBoxedLoops;\n\n  NumValueWrites += ScopStats.NumValueWrites;\n  NumValueWritesInLoops += ScopStats.NumValueWritesInLoops;\n  NumPHIWrites += ScopStats.NumPHIWrites;\n  NumPHIWritesInLoops += ScopStats.NumPHIWritesInLoops;\n  NumSingletonWrites += ScopStats.NumSingletonWrites;\n  NumSingletonWritesInLoops += ScopStats.NumSingletonWritesInLoops;\n}\n\nbool ScopInfoRegionPass::runOnRegion(Region *R, RGPassManager &RGM) {\n  auto &SD = getAnalysis<ScopDetectionWrapperPass>().getSD();\n\n  if (!SD.isMaxRegionInScop(*R))\n    return false;\n\n  Function *F = R->getEntry()->getParent();\n  auto &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();\n  auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();\n  auto const &DL = F->getParent()->getDataLayout();\n  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();\n  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(*F);\n  auto &ORE = getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();\n\n  ScopBuilder SB(R, AC, AA, DL, DT, LI, SD, SE, ORE);\n  S = SB.getScop(); // take ownership of scop object\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_STATS)\n  if (S) {\n    ScopDetection::LoopStats Stats =\n        ScopDetection::countBeneficialLoops(&S->getRegion(), SE, LI, 0);\n    updateLoopCountStatistic(Stats, S->getStatistics());\n  }\n#endif\n\n  return false;\n}\n\nvoid ScopInfoRegionPass::print(raw_ostream &OS, const Module *) const {\n  if (S)\n    S->print(OS, PollyPrintInstructions);\n  else\n    OS << \"Invalid Scop!\\n\";\n}\n\nchar ScopInfoRegionPass::ID = 0;\n\nPass *polly::createScopInfoRegionPassPass() { return new ScopInfoRegionPass(); }\n\nINITIALIZE_PASS_BEGIN(ScopInfoRegionPass, \"polly-scops\",\n                      \"Polly - Create polyhedral description of Scops\", false,\n                      false);\nINITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);\nINITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(RegionInfoPass);\nINITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(ScopDetectionWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass);\nINITIALIZE_PASS_END(ScopInfoRegionPass, \"polly-scops\",\n                    \"Polly - Create polyhedral description of Scops\", false,\n                    false)\n\n//===----------------------------------------------------------------------===//\nScopInfo::ScopInfo(const DataLayout &DL, ScopDetection &SD, ScalarEvolution &SE,\n                   LoopInfo &LI, AliasAnalysis &AA, DominatorTree &DT,\n                   AssumptionCache &AC, OptimizationRemarkEmitter &ORE)\n    : DL(DL), SD(SD), SE(SE), LI(LI), AA(AA), DT(DT), AC(AC), ORE(ORE) {\n  recompute();\n}\n\nvoid ScopInfo::recompute() {\n  RegionToScopMap.clear();\n  /// Create polyhedral description of scops for all the valid regions of a\n  /// function.\n  for (auto &It : SD) {\n    Region *R = const_cast<Region *>(It);\n    if (!SD.isMaxRegionInScop(*R))\n      continue;\n\n    ScopBuilder SB(R, AC, AA, DL, DT, LI, SD, SE, ORE);\n    std::unique_ptr<Scop> S = SB.getScop();\n    if (!S)\n      continue;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_STATS)\n    ScopDetection::LoopStats Stats =\n        ScopDetection::countBeneficialLoops(&S->getRegion(), SE, LI, 0);\n    updateLoopCountStatistic(Stats, S->getStatistics());\n#endif\n    bool Inserted = RegionToScopMap.insert({R, std::move(S)}).second;\n    assert(Inserted && \"Building Scop for the same region twice!\");\n    (void)Inserted;\n  }\n}\n\nbool ScopInfo::invalidate(Function &F, const PreservedAnalyses &PA,\n                          FunctionAnalysisManager::Invalidator &Inv) {\n  // Check whether the analysis, all analyses on functions have been preserved\n  // or anything we're holding references to is being invalidated\n  auto PAC = PA.getChecker<ScopInfoAnalysis>();\n  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Function>>()) ||\n         Inv.invalidate<ScopAnalysis>(F, PA) ||\n         Inv.invalidate<ScalarEvolutionAnalysis>(F, PA) ||\n         Inv.invalidate<LoopAnalysis>(F, PA) ||\n         Inv.invalidate<AAManager>(F, PA) ||\n         Inv.invalidate<DominatorTreeAnalysis>(F, PA) ||\n         Inv.invalidate<AssumptionAnalysis>(F, PA);\n}\n\nAnalysisKey ScopInfoAnalysis::Key;\n\nScopInfoAnalysis::Result ScopInfoAnalysis::run(Function &F,\n                                               FunctionAnalysisManager &FAM) {\n  auto &SD = FAM.getResult<ScopAnalysis>(F);\n  auto &SE = FAM.getResult<ScalarEvolutionAnalysis>(F);\n  auto &LI = FAM.getResult<LoopAnalysis>(F);\n  auto &AA = FAM.getResult<AAManager>(F);\n  auto &DT = FAM.getResult<DominatorTreeAnalysis>(F);\n  auto &AC = FAM.getResult<AssumptionAnalysis>(F);\n  auto &DL = F.getParent()->getDataLayout();\n  auto &ORE = FAM.getResult<OptimizationRemarkEmitterAnalysis>(F);\n  return {DL, SD, SE, LI, AA, DT, AC, ORE};\n}\n\nPreservedAnalyses ScopInfoPrinterPass::run(Function &F,\n                                           FunctionAnalysisManager &FAM) {\n  auto &SI = FAM.getResult<ScopInfoAnalysis>(F);\n  // Since the legacy PM processes Scops in bottom up, we print them in reverse\n  // order here to keep the output persistent\n  for (auto &It : reverse(SI)) {\n    if (It.second)\n      It.second->print(Stream, PollyPrintInstructions);\n    else\n      Stream << \"Invalid Scop!\\n\";\n  }\n  return PreservedAnalyses::all();\n}\n\nvoid ScopInfoWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {\n  AU.addRequired<LoopInfoWrapperPass>();\n  AU.addRequired<RegionInfoPass>();\n  AU.addRequired<DominatorTreeWrapperPass>();\n  AU.addRequiredTransitive<ScalarEvolutionWrapperPass>();\n  AU.addRequiredTransitive<ScopDetectionWrapperPass>();\n  AU.addRequired<AAResultsWrapperPass>();\n  AU.addRequired<AssumptionCacheTracker>();\n  AU.addRequired<OptimizationRemarkEmitterWrapperPass>();\n  AU.setPreservesAll();\n}\n\nbool ScopInfoWrapperPass::runOnFunction(Function &F) {\n  auto &SD = getAnalysis<ScopDetectionWrapperPass>().getSD();\n  auto &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();\n  auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();\n  auto const &DL = F.getParent()->getDataLayout();\n  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();\n  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);\n  auto &ORE = getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();\n\n  Result.reset(new ScopInfo{DL, SD, SE, LI, AA, DT, AC, ORE});\n  return false;\n}\n\nvoid ScopInfoWrapperPass::print(raw_ostream &OS, const Module *) const {\n  for (auto &It : *Result) {\n    if (It.second)\n      It.second->print(OS, PollyPrintInstructions);\n    else\n      OS << \"Invalid Scop!\\n\";\n  }\n}\n\nchar ScopInfoWrapperPass::ID = 0;\n\nPass *polly::createScopInfoWrapperPassPass() {\n  return new ScopInfoWrapperPass();\n}\n\nINITIALIZE_PASS_BEGIN(\n    ScopInfoWrapperPass, \"polly-function-scops\",\n    \"Polly - Create polyhedral description of all Scops of a function\", false,\n    false);\nINITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);\nINITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(RegionInfoPass);\nINITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(ScopDetectionWrapperPass);\nINITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass);\nINITIALIZE_PASS_END(\n    ScopInfoWrapperPass, \"polly-function-scops\",\n    \"Polly - Create polyhedral description of all Scops of a function\", false,\n    false)\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 60, "line": 194}, "message": "destructor '~LoopStats' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetection.h", "reportHash": "309354acc6ce518bc385c54b882d1239", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 60, "line": 194}, "message": "move constructor 'LoopStats' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetection.h", "reportHash": "04e226040ef585767fdf8067dc9927a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 62, "line": 2729}, "message": "default constructor 'ScopStatistics' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopInfo.h", "reportHash": "1a64cd9fd41f3d598820341350698dd2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 1339}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "d85754450305f1477e4bcf9d211871d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 1339}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "36f1430b62cb0b805aaa75bee8190459", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 64, "line": 1787}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "4a82dd62e2fddd35d85f234e9c953b2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 1797}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "0a1962bf7c14354626d1fb38477c9b24", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 64, "line": 2341}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "18bd31ca3d3cea9ed78a7868f0317f47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 64, "line": 2345}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "b5fb079925abe87653286bef8b870d02", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 64, "line": 2349}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "4f49ff906569ee39e59f930376e9707d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 64, "line": 2353}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "6252611c71ec27c96b679670b2e0d8b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 64, "line": 2357}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "2591c76c669812031a833f4c007ab40b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 2362}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopInfo.cpp", "reportHash": "e6c16ec330eb888725639e1e27af10f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
