<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "content": "//===--- SemaTemplateInstantiateDecl.cpp - C++ Template Decl Instantiation ===/\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//===----------------------------------------------------------------------===/\n//\n//  This file implements C++ template instantiation for declarations.\n//\n//===----------------------------------------------------------------------===/\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/DependentDiagnostic.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/PrettyDeclStackTrace.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"clang/Sema/TemplateInstCallback.h\"\n#include \"llvm/Support/TimeProfiler.h\"\n\nusing namespace clang;\n\nstatic bool isDeclWithinFunction(const Decl *D) {\n  const DeclContext *DC = D->getDeclContext();\n  if (DC->isFunctionOrMethod())\n    return true;\n\n  if (DC->isRecord())\n    return cast<CXXRecordDecl>(DC)->isLocalClass();\n\n  return false;\n}\n\ntemplate<typename DeclT>\nstatic bool SubstQualifier(Sema &SemaRef, const DeclT *OldDecl, DeclT *NewDecl,\n                           const MultiLevelTemplateArgumentList &TemplateArgs) {\n  if (!OldDecl->getQualifierLoc())\n    return false;\n\n  assert((NewDecl->getFriendObjectKind() ||\n          !OldDecl->getLexicalDeclContext()->isDependentContext()) &&\n         \"non-friend with qualified name defined in dependent context\");\n  Sema::ContextRAII SavedContext(\n      SemaRef,\n      const_cast<DeclContext *>(NewDecl->getFriendObjectKind()\n                                    ? NewDecl->getLexicalDeclContext()\n                                    : OldDecl->getLexicalDeclContext()));\n\n  NestedNameSpecifierLoc NewQualifierLoc\n      = SemaRef.SubstNestedNameSpecifierLoc(OldDecl->getQualifierLoc(),\n                                            TemplateArgs);\n\n  if (!NewQualifierLoc)\n    return true;\n\n  NewDecl->setQualifierInfo(NewQualifierLoc);\n  return false;\n}\n\nbool TemplateDeclInstantiator::SubstQualifier(const DeclaratorDecl *OldDecl,\n                                              DeclaratorDecl *NewDecl) {\n  return ::SubstQualifier(SemaRef, OldDecl, NewDecl, TemplateArgs);\n}\n\nbool TemplateDeclInstantiator::SubstQualifier(const TagDecl *OldDecl,\n                                              TagDecl *NewDecl) {\n  return ::SubstQualifier(SemaRef, OldDecl, NewDecl, TemplateArgs);\n}\n\n// Include attribute instantiation code.\n#include \"clang/Sema/AttrTemplateInstantiate.inc\"\n\nstatic void instantiateDependentAlignedAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AlignedAttr *Aligned, Decl *New, bool IsPackExpansion) {\n  if (Aligned->isAlignmentExpr()) {\n    // The alignment expression is a constant expression.\n    EnterExpressionEvaluationContext Unevaluated(\n        S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n    ExprResult Result = S.SubstExpr(Aligned->getAlignmentExpr(), TemplateArgs);\n    if (!Result.isInvalid())\n      S.AddAlignedAttr(New, *Aligned, Result.getAs<Expr>(), IsPackExpansion);\n  } else {\n    TypeSourceInfo *Result = S.SubstType(Aligned->getAlignmentType(),\n                                         TemplateArgs, Aligned->getLocation(),\n                                         DeclarationName());\n    if (Result)\n      S.AddAlignedAttr(New, *Aligned, Result, IsPackExpansion);\n  }\n}\n\nstatic void instantiateDependentAlignedAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AlignedAttr *Aligned, Decl *New) {\n  if (!Aligned->isPackExpansion()) {\n    instantiateDependentAlignedAttr(S, TemplateArgs, Aligned, New, false);\n    return;\n  }\n\n  SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n  if (Aligned->isAlignmentExpr())\n    S.collectUnexpandedParameterPacks(Aligned->getAlignmentExpr(),\n                                      Unexpanded);\n  else\n    S.collectUnexpandedParameterPacks(Aligned->getAlignmentType()->getTypeLoc(),\n                                      Unexpanded);\n  assert(!Unexpanded.empty() && \"Pack expansion without parameter packs?\");\n\n  // Determine whether we can expand this attribute pack yet.\n  bool Expand = true, RetainExpansion = false;\n  Optional<unsigned> NumExpansions;\n  // FIXME: Use the actual location of the ellipsis.\n  SourceLocation EllipsisLoc = Aligned->getLocation();\n  if (S.CheckParameterPacksForExpansion(EllipsisLoc, Aligned->getRange(),\n                                        Unexpanded, TemplateArgs, Expand,\n                                        RetainExpansion, NumExpansions))\n    return;\n\n  if (!Expand) {\n    Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(S, -1);\n    instantiateDependentAlignedAttr(S, TemplateArgs, Aligned, New, true);\n  } else {\n    for (unsigned I = 0; I != *NumExpansions; ++I) {\n      Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(S, I);\n      instantiateDependentAlignedAttr(S, TemplateArgs, Aligned, New, false);\n    }\n  }\n}\n\nstatic void instantiateDependentAssumeAlignedAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AssumeAlignedAttr *Aligned, Decl *New) {\n  // The alignment expression is a constant expression.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  Expr *E, *OE = nullptr;\n  ExprResult Result = S.SubstExpr(Aligned->getAlignment(), TemplateArgs);\n  if (Result.isInvalid())\n    return;\n  E = Result.getAs<Expr>();\n\n  if (Aligned->getOffset()) {\n    Result = S.SubstExpr(Aligned->getOffset(), TemplateArgs);\n    if (Result.isInvalid())\n      return;\n    OE = Result.getAs<Expr>();\n  }\n\n  S.AddAssumeAlignedAttr(New, *Aligned, E, OE);\n}\n\nstatic void instantiateDependentAlignValueAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AlignValueAttr *Aligned, Decl *New) {\n  // The alignment expression is a constant expression.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n  ExprResult Result = S.SubstExpr(Aligned->getAlignment(), TemplateArgs);\n  if (!Result.isInvalid())\n    S.AddAlignValueAttr(New, *Aligned, Result.getAs<Expr>());\n}\n\nstatic void instantiateDependentAllocAlignAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AllocAlignAttr *Align, Decl *New) {\n  Expr *Param = IntegerLiteral::Create(\n      S.getASTContext(),\n      llvm::APInt(64, Align->getParamIndex().getSourceIndex()),\n      S.getASTContext().UnsignedLongLongTy, Align->getLocation());\n  S.AddAllocAlignAttr(New, *Align, Param);\n}\n\nstatic void instantiateDependentAnnotationAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AnnotateAttr *Attr, Decl *New) {\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n  SmallVector<Expr *, 4> Args;\n  Args.reserve(Attr->args_size());\n  for (auto *E : Attr->args()) {\n    ExprResult Result = S.SubstExpr(E, TemplateArgs);\n    if (!Result.isUsable())\n      return;\n    Args.push_back(Result.get());\n  }\n  S.AddAnnotationAttr(New, *Attr, Attr->getAnnotation(), Args);\n}\n\nstatic Expr *instantiateDependentFunctionAttrCondition(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const Attr *A, Expr *OldCond, const Decl *Tmpl, FunctionDecl *New) {\n  Expr *Cond = nullptr;\n  {\n    Sema::ContextRAII SwitchContext(S, New);\n    EnterExpressionEvaluationContext Unevaluated(\n        S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n    ExprResult Result = S.SubstExpr(OldCond, TemplateArgs);\n    if (Result.isInvalid())\n      return nullptr;\n    Cond = Result.getAs<Expr>();\n  }\n  if (!Cond->isTypeDependent()) {\n    ExprResult Converted = S.PerformContextuallyConvertToBool(Cond);\n    if (Converted.isInvalid())\n      return nullptr;\n    Cond = Converted.get();\n  }\n\n  SmallVector<PartialDiagnosticAt, 8> Diags;\n  if (OldCond->isValueDependent() && !Cond->isValueDependent() &&\n      !Expr::isPotentialConstantExprUnevaluated(Cond, New, Diags)) {\n    S.Diag(A->getLocation(), diag::err_attr_cond_never_constant_expr) << A;\n    for (const auto &P : Diags)\n      S.Diag(P.first, P.second);\n    return nullptr;\n  }\n  return Cond;\n}\n\nstatic void instantiateDependentEnableIfAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const EnableIfAttr *EIA, const Decl *Tmpl, FunctionDecl *New) {\n  Expr *Cond = instantiateDependentFunctionAttrCondition(\n      S, TemplateArgs, EIA, EIA->getCond(), Tmpl, New);\n\n  if (Cond)\n    New->addAttr(new (S.getASTContext()) EnableIfAttr(S.getASTContext(), *EIA,\n                                                      Cond, EIA->getMessage()));\n}\n\nstatic void instantiateDependentDiagnoseIfAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const DiagnoseIfAttr *DIA, const Decl *Tmpl, FunctionDecl *New) {\n  Expr *Cond = instantiateDependentFunctionAttrCondition(\n      S, TemplateArgs, DIA, DIA->getCond(), Tmpl, New);\n\n  if (Cond)\n    New->addAttr(new (S.getASTContext()) DiagnoseIfAttr(\n        S.getASTContext(), *DIA, Cond, DIA->getMessage(),\n        DIA->getDiagnosticType(), DIA->getArgDependent(), New));\n}\n\n// Constructs and adds to New a new instance of CUDALaunchBoundsAttr using\n// template A as the base and arguments from TemplateArgs.\nstatic void instantiateDependentCUDALaunchBoundsAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const CUDALaunchBoundsAttr &Attr, Decl *New) {\n  // The alignment expression is a constant expression.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  ExprResult Result = S.SubstExpr(Attr.getMaxThreads(), TemplateArgs);\n  if (Result.isInvalid())\n    return;\n  Expr *MaxThreads = Result.getAs<Expr>();\n\n  Expr *MinBlocks = nullptr;\n  if (Attr.getMinBlocks()) {\n    Result = S.SubstExpr(Attr.getMinBlocks(), TemplateArgs);\n    if (Result.isInvalid())\n      return;\n    MinBlocks = Result.getAs<Expr>();\n  }\n\n  S.AddLaunchBoundsAttr(New, Attr, MaxThreads, MinBlocks);\n}\n\nstatic void\ninstantiateDependentModeAttr(Sema &S,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                             const ModeAttr &Attr, Decl *New) {\n  S.AddModeAttr(New, Attr, Attr.getMode(),\n                /*InInstantiation=*/true);\n}\n\n/// Instantiation of 'declare simd' attribute and its arguments.\nstatic void instantiateOMPDeclareSimdDeclAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const OMPDeclareSimdDeclAttr &Attr, Decl *New) {\n  // Allow 'this' in clauses with varlists.\n  if (auto *FTD = dyn_cast<FunctionTemplateDecl>(New))\n    New = FTD->getTemplatedDecl();\n  auto *FD = cast<FunctionDecl>(New);\n  auto *ThisContext = dyn_cast_or_null<CXXRecordDecl>(FD->getDeclContext());\n  SmallVector<Expr *, 4> Uniforms, Aligneds, Alignments, Linears, Steps;\n  SmallVector<unsigned, 4> LinModifiers;\n\n  auto SubstExpr = [&](Expr *E) -> ExprResult {\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts()))\n      if (auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {\n        Sema::ContextRAII SavedContext(S, FD);\n        LocalInstantiationScope Local(S);\n        if (FD->getNumParams() > PVD->getFunctionScopeIndex())\n          Local.InstantiatedLocal(\n              PVD, FD->getParamDecl(PVD->getFunctionScopeIndex()));\n        return S.SubstExpr(E, TemplateArgs);\n      }\n    Sema::CXXThisScopeRAII ThisScope(S, ThisContext, Qualifiers(),\n                                     FD->isCXXInstanceMember());\n    return S.SubstExpr(E, TemplateArgs);\n  };\n\n  // Substitute a single OpenMP clause, which is a potentially-evaluated\n  // full-expression.\n  auto Subst = [&](Expr *E) -> ExprResult {\n    EnterExpressionEvaluationContext Evaluated(\n        S, Sema::ExpressionEvaluationContext::PotentiallyEvaluated);\n    ExprResult Res = SubstExpr(E);\n    if (Res.isInvalid())\n      return Res;\n    return S.ActOnFinishFullExpr(Res.get(), false);\n  };\n\n  ExprResult Simdlen;\n  if (auto *E = Attr.getSimdlen())\n    Simdlen = Subst(E);\n\n  if (Attr.uniforms_size() > 0) {\n    for(auto *E : Attr.uniforms()) {\n      ExprResult Inst = Subst(E);\n      if (Inst.isInvalid())\n        continue;\n      Uniforms.push_back(Inst.get());\n    }\n  }\n\n  auto AI = Attr.alignments_begin();\n  for (auto *E : Attr.aligneds()) {\n    ExprResult Inst = Subst(E);\n    if (Inst.isInvalid())\n      continue;\n    Aligneds.push_back(Inst.get());\n    Inst = ExprEmpty();\n    if (*AI)\n      Inst = S.SubstExpr(*AI, TemplateArgs);\n    Alignments.push_back(Inst.get());\n    ++AI;\n  }\n\n  auto SI = Attr.steps_begin();\n  for (auto *E : Attr.linears()) {\n    ExprResult Inst = Subst(E);\n    if (Inst.isInvalid())\n      continue;\n    Linears.push_back(Inst.get());\n    Inst = ExprEmpty();\n    if (*SI)\n      Inst = S.SubstExpr(*SI, TemplateArgs);\n    Steps.push_back(Inst.get());\n    ++SI;\n  }\n  LinModifiers.append(Attr.modifiers_begin(), Attr.modifiers_end());\n  (void)S.ActOnOpenMPDeclareSimdDirective(\n      S.ConvertDeclToDeclGroup(New), Attr.getBranchState(), Simdlen.get(),\n      Uniforms, Aligneds, Alignments, Linears, LinModifiers, Steps,\n      Attr.getRange());\n}\n\n/// Instantiation of 'declare variant' attribute and its arguments.\nstatic void instantiateOMPDeclareVariantAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const OMPDeclareVariantAttr &Attr, Decl *New) {\n  // Allow 'this' in clauses with varlists.\n  if (auto *FTD = dyn_cast<FunctionTemplateDecl>(New))\n    New = FTD->getTemplatedDecl();\n  auto *FD = cast<FunctionDecl>(New);\n  auto *ThisContext = dyn_cast_or_null<CXXRecordDecl>(FD->getDeclContext());\n\n  auto &&SubstExpr = [FD, ThisContext, &S, &TemplateArgs](Expr *E) {\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts()))\n      if (auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {\n        Sema::ContextRAII SavedContext(S, FD);\n        LocalInstantiationScope Local(S);\n        if (FD->getNumParams() > PVD->getFunctionScopeIndex())\n          Local.InstantiatedLocal(\n              PVD, FD->getParamDecl(PVD->getFunctionScopeIndex()));\n        return S.SubstExpr(E, TemplateArgs);\n      }\n    Sema::CXXThisScopeRAII ThisScope(S, ThisContext, Qualifiers(),\n                                     FD->isCXXInstanceMember());\n    return S.SubstExpr(E, TemplateArgs);\n  };\n\n  // Substitute a single OpenMP clause, which is a potentially-evaluated\n  // full-expression.\n  auto &&Subst = [&SubstExpr, &S](Expr *E) {\n    EnterExpressionEvaluationContext Evaluated(\n        S, Sema::ExpressionEvaluationContext::PotentiallyEvaluated);\n    ExprResult Res = SubstExpr(E);\n    if (Res.isInvalid())\n      return Res;\n    return S.ActOnFinishFullExpr(Res.get(), false);\n  };\n\n  ExprResult VariantFuncRef;\n  if (Expr *E = Attr.getVariantFuncRef()) {\n    // Do not mark function as is used to prevent its emission if this is the\n    // only place where it is used.\n    EnterExpressionEvaluationContext Unevaluated(\n        S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n    VariantFuncRef = Subst(E);\n  }\n\n  // Copy the template version of the OMPTraitInfo and run substitute on all\n  // score and condition expressiosn.\n  OMPTraitInfo &TI = S.getASTContext().getNewOMPTraitInfo();\n  TI = *Attr.getTraitInfos();\n\n  // Try to substitute template parameters in score and condition expressions.\n  auto SubstScoreOrConditionExpr = [&S, Subst](Expr *&E, bool) {\n    if (E) {\n      EnterExpressionEvaluationContext Unevaluated(\n          S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n      ExprResult ER = Subst(E);\n      if (ER.isUsable())\n        E = ER.get();\n      else\n        return true;\n    }\n    return false;\n  };\n  if (TI.anyScoreOrCondition(SubstScoreOrConditionExpr))\n    return;\n\n  Expr *E = VariantFuncRef.get();\n  // Check function/variant ref for `omp declare variant` but not for `omp\n  // begin declare variant` (which use implicit attributes).\n  Optional<std::pair<FunctionDecl *, Expr *>> DeclVarData =\n      S.checkOpenMPDeclareVariantFunction(S.ConvertDeclToDeclGroup(New),\n                                          VariantFuncRef.get(), TI,\n                                          Attr.getRange());\n\n  if (!DeclVarData)\n    return;\n\n  E = DeclVarData.getValue().second;\n  FD = DeclVarData.getValue().first;\n\n  if (auto *VariantDRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts())) {\n    if (auto *VariantFD = dyn_cast<FunctionDecl>(VariantDRE->getDecl())) {\n      if (auto *VariantFTD = VariantFD->getDescribedFunctionTemplate()) {\n        if (!VariantFTD->isThisDeclarationADefinition())\n          return;\n        Sema::TentativeAnalysisScope Trap(S);\n        const TemplateArgumentList *TAL = TemplateArgumentList::CreateCopy(\n            S.Context, TemplateArgs.getInnermost());\n\n        auto *SubstFD = S.InstantiateFunctionDeclaration(VariantFTD, TAL,\n                                                         New->getLocation());\n        if (!SubstFD)\n          return;\n        QualType NewType = S.Context.mergeFunctionTypes(\n            SubstFD->getType(), FD->getType(),\n            /* OfBlockPointer */ false,\n            /* Unqualified */ false, /* AllowCXX */ true);\n        if (NewType.isNull())\n          return;\n        S.InstantiateFunctionDefinition(\n            New->getLocation(), SubstFD, /* Recursive */ true,\n            /* DefinitionRequired */ false, /* AtEndOfTU */ false);\n        SubstFD->setInstantiationIsPending(!SubstFD->isDefined());\n        E = DeclRefExpr::Create(S.Context, NestedNameSpecifierLoc(),\n                                SourceLocation(), SubstFD,\n                                /* RefersToEnclosingVariableOrCapture */ false,\n                                /* NameLoc */ SubstFD->getLocation(),\n                                SubstFD->getType(), ExprValueKind::VK_RValue);\n      }\n    }\n  }\n\n  S.ActOnOpenMPDeclareVariantDirective(FD, E, TI, Attr.getRange());\n}\n\nstatic void instantiateDependentAMDGPUFlatWorkGroupSizeAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AMDGPUFlatWorkGroupSizeAttr &Attr, Decl *New) {\n  // Both min and max expression are constant expressions.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  ExprResult Result = S.SubstExpr(Attr.getMin(), TemplateArgs);\n  if (Result.isInvalid())\n    return;\n  Expr *MinExpr = Result.getAs<Expr>();\n\n  Result = S.SubstExpr(Attr.getMax(), TemplateArgs);\n  if (Result.isInvalid())\n    return;\n  Expr *MaxExpr = Result.getAs<Expr>();\n\n  S.addAMDGPUFlatWorkGroupSizeAttr(New, Attr, MinExpr, MaxExpr);\n}\n\nstatic ExplicitSpecifier\ninstantiateExplicitSpecifier(Sema &S,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                             ExplicitSpecifier ES, FunctionDecl *New) {\n  if (!ES.getExpr())\n    return ES;\n  Expr *OldCond = ES.getExpr();\n  Expr *Cond = nullptr;\n  {\n    EnterExpressionEvaluationContext Unevaluated(\n        S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n    ExprResult SubstResult = S.SubstExpr(OldCond, TemplateArgs);\n    if (SubstResult.isInvalid()) {\n      return ExplicitSpecifier::Invalid();\n    }\n    Cond = SubstResult.get();\n  }\n  ExplicitSpecifier Result(Cond, ES.getKind());\n  if (!Cond->isTypeDependent())\n    S.tryResolveExplicitSpecifier(Result);\n  return Result;\n}\n\nstatic void instantiateDependentAMDGPUWavesPerEUAttr(\n    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,\n    const AMDGPUWavesPerEUAttr &Attr, Decl *New) {\n  // Both min and max expression are constant expressions.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  ExprResult Result = S.SubstExpr(Attr.getMin(), TemplateArgs);\n  if (Result.isInvalid())\n    return;\n  Expr *MinExpr = Result.getAs<Expr>();\n\n  Expr *MaxExpr = nullptr;\n  if (auto Max = Attr.getMax()) {\n    Result = S.SubstExpr(Max, TemplateArgs);\n    if (Result.isInvalid())\n      return;\n    MaxExpr = Result.getAs<Expr>();\n  }\n\n  S.addAMDGPUWavesPerEUAttr(New, Attr, MinExpr, MaxExpr);\n}\n\n/// Determine whether the attribute A might be relevent to the declaration D.\n/// If not, we can skip instantiating it. The attribute may or may not have\n/// been instantiated yet.\nstatic bool isRelevantAttr(Sema &S, const Decl *D, const Attr *A) {\n  // 'preferred_name' is only relevant to the matching specialization of the\n  // template.\n  if (const auto *PNA = dyn_cast<PreferredNameAttr>(A)) {\n    QualType T = PNA->getTypedefType();\n    const auto *RD = cast<CXXRecordDecl>(D);\n    if (!T->isDependentType() && !RD->isDependentContext() &&\n        !declaresSameEntity(T->getAsCXXRecordDecl(), RD))\n      return false;\n    for (const auto *ExistingPNA : D->specific_attrs<PreferredNameAttr>())\n      if (S.Context.hasSameType(ExistingPNA->getTypedefType(),\n                                PNA->getTypedefType()))\n        return false;\n    return true;\n  }\n\n  return true;\n}\n\nvoid Sema::InstantiateAttrsForDecl(\n    const MultiLevelTemplateArgumentList &TemplateArgs, const Decl *Tmpl,\n    Decl *New, LateInstantiatedAttrVec *LateAttrs,\n    LocalInstantiationScope *OuterMostScope) {\n  if (NamedDecl *ND = dyn_cast<NamedDecl>(New)) {\n    // FIXME: This function is called multiple times for the same template\n    // specialization. We should only instantiate attributes that were added\n    // since the previous instantiation.\n    for (const auto *TmplAttr : Tmpl->attrs()) {\n      if (!isRelevantAttr(*this, New, TmplAttr))\n        continue;\n\n      // FIXME: If any of the special case versions from InstantiateAttrs become\n      // applicable to template declaration, we'll need to add them here.\n      CXXThisScopeRAII ThisScope(\n          *this, dyn_cast_or_null<CXXRecordDecl>(ND->getDeclContext()),\n          Qualifiers(), ND->isCXXInstanceMember());\n\n      Attr *NewAttr = sema::instantiateTemplateAttributeForDecl(\n          TmplAttr, Context, *this, TemplateArgs);\n      if (NewAttr && isRelevantAttr(*this, New, NewAttr))\n        New->addAttr(NewAttr);\n    }\n  }\n}\n\nstatic Sema::RetainOwnershipKind\nattrToRetainOwnershipKind(const Attr *A) {\n  switch (A->getKind()) {\n  case clang::attr::CFConsumed:\n    return Sema::RetainOwnershipKind::CF;\n  case clang::attr::OSConsumed:\n    return Sema::RetainOwnershipKind::OS;\n  case clang::attr::NSConsumed:\n    return Sema::RetainOwnershipKind::NS;\n  default:\n    llvm_unreachable(\"Wrong argument supplied\");\n  }\n}\n\nvoid Sema::InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,\n                            const Decl *Tmpl, Decl *New,\n                            LateInstantiatedAttrVec *LateAttrs,\n                            LocalInstantiationScope *OuterMostScope) {\n  for (const auto *TmplAttr : Tmpl->attrs()) {\n    if (!isRelevantAttr(*this, New, TmplAttr))\n      continue;\n\n    // FIXME: This should be generalized to more than just the AlignedAttr.\n    const AlignedAttr *Aligned = dyn_cast<AlignedAttr>(TmplAttr);\n    if (Aligned && Aligned->isAlignmentDependent()) {\n      instantiateDependentAlignedAttr(*this, TemplateArgs, Aligned, New);\n      continue;\n    }\n\n    if (const auto *AssumeAligned = dyn_cast<AssumeAlignedAttr>(TmplAttr)) {\n      instantiateDependentAssumeAlignedAttr(*this, TemplateArgs, AssumeAligned, New);\n      continue;\n    }\n\n    if (const auto *AlignValue = dyn_cast<AlignValueAttr>(TmplAttr)) {\n      instantiateDependentAlignValueAttr(*this, TemplateArgs, AlignValue, New);\n      continue;\n    }\n\n    if (const auto *AllocAlign = dyn_cast<AllocAlignAttr>(TmplAttr)) {\n      instantiateDependentAllocAlignAttr(*this, TemplateArgs, AllocAlign, New);\n      continue;\n    }\n\n    if (const auto *Annotate = dyn_cast<AnnotateAttr>(TmplAttr)) {\n      instantiateDependentAnnotationAttr(*this, TemplateArgs, Annotate, New);\n      continue;\n    }\n\n    if (const auto *EnableIf = dyn_cast<EnableIfAttr>(TmplAttr)) {\n      instantiateDependentEnableIfAttr(*this, TemplateArgs, EnableIf, Tmpl,\n                                       cast<FunctionDecl>(New));\n      continue;\n    }\n\n    if (const auto *DiagnoseIf = dyn_cast<DiagnoseIfAttr>(TmplAttr)) {\n      instantiateDependentDiagnoseIfAttr(*this, TemplateArgs, DiagnoseIf, Tmpl,\n                                         cast<FunctionDecl>(New));\n      continue;\n    }\n\n    if (const auto *CUDALaunchBounds =\n            dyn_cast<CUDALaunchBoundsAttr>(TmplAttr)) {\n      instantiateDependentCUDALaunchBoundsAttr(*this, TemplateArgs,\n                                               *CUDALaunchBounds, New);\n      continue;\n    }\n\n    if (const auto *Mode = dyn_cast<ModeAttr>(TmplAttr)) {\n      instantiateDependentModeAttr(*this, TemplateArgs, *Mode, New);\n      continue;\n    }\n\n    if (const auto *OMPAttr = dyn_cast<OMPDeclareSimdDeclAttr>(TmplAttr)) {\n      instantiateOMPDeclareSimdDeclAttr(*this, TemplateArgs, *OMPAttr, New);\n      continue;\n    }\n\n    if (const auto *OMPAttr = dyn_cast<OMPDeclareVariantAttr>(TmplAttr)) {\n      instantiateOMPDeclareVariantAttr(*this, TemplateArgs, *OMPAttr, New);\n      continue;\n    }\n\n    if (const auto *AMDGPUFlatWorkGroupSize =\n            dyn_cast<AMDGPUFlatWorkGroupSizeAttr>(TmplAttr)) {\n      instantiateDependentAMDGPUFlatWorkGroupSizeAttr(\n          *this, TemplateArgs, *AMDGPUFlatWorkGroupSize, New);\n    }\n\n    if (const auto *AMDGPUFlatWorkGroupSize =\n            dyn_cast<AMDGPUWavesPerEUAttr>(TmplAttr)) {\n      instantiateDependentAMDGPUWavesPerEUAttr(*this, TemplateArgs,\n                                               *AMDGPUFlatWorkGroupSize, New);\n    }\n\n    // Existing DLL attribute on the instantiation takes precedence.\n    if (TmplAttr->getKind() == attr::DLLExport ||\n        TmplAttr->getKind() == attr::DLLImport) {\n      if (New->hasAttr<DLLExportAttr>() || New->hasAttr<DLLImportAttr>()) {\n        continue;\n      }\n    }\n\n    if (const auto *ABIAttr = dyn_cast<ParameterABIAttr>(TmplAttr)) {\n      AddParameterABIAttr(New, *ABIAttr, ABIAttr->getABI());\n      continue;\n    }\n\n    if (isa<NSConsumedAttr>(TmplAttr) || isa<OSConsumedAttr>(TmplAttr) ||\n        isa<CFConsumedAttr>(TmplAttr)) {\n      AddXConsumedAttr(New, *TmplAttr, attrToRetainOwnershipKind(TmplAttr),\n                       /*template instantiation=*/true);\n      continue;\n    }\n\n    if (auto *A = dyn_cast<PointerAttr>(TmplAttr)) {\n      if (!New->hasAttr<PointerAttr>())\n        New->addAttr(A->clone(Context));\n      continue;\n    }\n\n    if (auto *A = dyn_cast<OwnerAttr>(TmplAttr)) {\n      if (!New->hasAttr<OwnerAttr>())\n        New->addAttr(A->clone(Context));\n      continue;\n    }\n\n    assert(!TmplAttr->isPackExpansion());\n    if (TmplAttr->isLateParsed() && LateAttrs) {\n      // Late parsed attributes must be instantiated and attached after the\n      // enclosing class has been instantiated.  See Sema::InstantiateClass.\n      LocalInstantiationScope *Saved = nullptr;\n      if (CurrentInstantiationScope)\n        Saved = CurrentInstantiationScope->cloneScopes(OuterMostScope);\n      LateAttrs->push_back(LateInstantiatedAttribute(TmplAttr, Saved, New));\n    } else {\n      // Allow 'this' within late-parsed attributes.\n      auto *ND = cast<NamedDecl>(New);\n      auto *ThisContext = dyn_cast_or_null<CXXRecordDecl>(ND->getDeclContext());\n      CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(),\n                                 ND->isCXXInstanceMember());\n\n      Attr *NewAttr = sema::instantiateTemplateAttribute(TmplAttr, Context,\n                                                         *this, TemplateArgs);\n      if (NewAttr && isRelevantAttr(*this, New, TmplAttr))\n        New->addAttr(NewAttr);\n    }\n  }\n}\n\n/// In the MS ABI, we need to instantiate default arguments of dllexported\n/// default constructors along with the constructor definition. This allows IR\n/// gen to emit a constructor closure which calls the default constructor with\n/// its default arguments.\nvoid Sema::InstantiateDefaultCtorDefaultArgs(CXXConstructorDecl *Ctor) {\n  assert(Context.getTargetInfo().getCXXABI().isMicrosoft() &&\n         Ctor->isDefaultConstructor());\n  unsigned NumParams = Ctor->getNumParams();\n  if (NumParams == 0)\n    return;\n  DLLExportAttr *Attr = Ctor->getAttr<DLLExportAttr>();\n  if (!Attr)\n    return;\n  for (unsigned I = 0; I != NumParams; ++I) {\n    (void)CheckCXXDefaultArgExpr(Attr->getLocation(), Ctor,\n                                   Ctor->getParamDecl(I));\n    DiscardCleanupsInEvaluationContext();\n  }\n}\n\n/// Get the previous declaration of a declaration for the purposes of template\n/// instantiation. If this finds a previous declaration, then the previous\n/// declaration of the instantiation of D should be an instantiation of the\n/// result of this function.\ntemplate<typename DeclT>\nstatic DeclT *getPreviousDeclForInstantiation(DeclT *D) {\n  DeclT *Result = D->getPreviousDecl();\n\n  // If the declaration is within a class, and the previous declaration was\n  // merged from a different definition of that class, then we don't have a\n  // previous declaration for the purpose of template instantiation.\n  if (Result && isa<CXXRecordDecl>(D->getDeclContext()) &&\n      D->getLexicalDeclContext() != Result->getLexicalDeclContext())\n    return nullptr;\n\n  return Result;\n}\n\nDecl *\nTemplateDeclInstantiator::VisitTranslationUnitDecl(TranslationUnitDecl *D) {\n  llvm_unreachable(\"Translation units cannot be instantiated\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitPragmaCommentDecl(PragmaCommentDecl *D) {\n  llvm_unreachable(\"pragma comment cannot be instantiated\");\n}\n\nDecl *TemplateDeclInstantiator::VisitPragmaDetectMismatchDecl(\n    PragmaDetectMismatchDecl *D) {\n  llvm_unreachable(\"pragma comment cannot be instantiated\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitExternCContextDecl(ExternCContextDecl *D) {\n  llvm_unreachable(\"extern \\\"C\\\" context cannot be instantiated\");\n}\n\nDecl *TemplateDeclInstantiator::VisitMSGuidDecl(MSGuidDecl *D) {\n  llvm_unreachable(\"GUID declaration cannot be instantiated\");\n}\n\nDecl *TemplateDeclInstantiator::VisitTemplateParamObjectDecl(\n    TemplateParamObjectDecl *D) {\n  llvm_unreachable(\"template parameter objects cannot be instantiated\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitLabelDecl(LabelDecl *D) {\n  LabelDecl *Inst = LabelDecl::Create(SemaRef.Context, Owner, D->getLocation(),\n                                      D->getIdentifier());\n  Owner->addDecl(Inst);\n  return Inst;\n}\n\nDecl *\nTemplateDeclInstantiator::VisitNamespaceDecl(NamespaceDecl *D) {\n  llvm_unreachable(\"Namespaces cannot be instantiated\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitNamespaceAliasDecl(NamespaceAliasDecl *D) {\n  NamespaceAliasDecl *Inst\n    = NamespaceAliasDecl::Create(SemaRef.Context, Owner,\n                                 D->getNamespaceLoc(),\n                                 D->getAliasLoc(),\n                                 D->getIdentifier(),\n                                 D->getQualifierLoc(),\n                                 D->getTargetNameLoc(),\n                                 D->getNamespace());\n  Owner->addDecl(Inst);\n  return Inst;\n}\n\nDecl *TemplateDeclInstantiator::InstantiateTypedefNameDecl(TypedefNameDecl *D,\n                                                           bool IsTypeAlias) {\n  bool Invalid = false;\n  TypeSourceInfo *DI = D->getTypeSourceInfo();\n  if (DI->getType()->isInstantiationDependentType() ||\n      DI->getType()->isVariablyModifiedType()) {\n    DI = SemaRef.SubstType(DI, TemplateArgs,\n                           D->getLocation(), D->getDeclName());\n    if (!DI) {\n      Invalid = true;\n      DI = SemaRef.Context.getTrivialTypeSourceInfo(SemaRef.Context.IntTy);\n    }\n  } else {\n    SemaRef.MarkDeclarationsReferencedInType(D->getLocation(), DI->getType());\n  }\n\n  // HACK: g++ has a bug where it gets the value kind of ?: wrong.\n  // libstdc++ relies upon this bug in its implementation of common_type.\n  // If we happen to be processing that implementation, fake up the g++ ?:\n  // semantics. See LWG issue 2141 for more information on the bug.\n  const DecltypeType *DT = DI->getType()->getAs<DecltypeType>();\n  CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D->getDeclContext());\n  if (DT && RD && isa<ConditionalOperator>(DT->getUnderlyingExpr()) &&\n      DT->isReferenceType() &&\n      RD->getEnclosingNamespaceContext() == SemaRef.getStdNamespace() &&\n      RD->getIdentifier() && RD->getIdentifier()->isStr(\"common_type\") &&\n      D->getIdentifier() && D->getIdentifier()->isStr(\"type\") &&\n      SemaRef.getSourceManager().isInSystemHeader(D->getBeginLoc()))\n    // Fold it to the (non-reference) type which g++ would have produced.\n    DI = SemaRef.Context.getTrivialTypeSourceInfo(\n      DI->getType().getNonReferenceType());\n\n  // Create the new typedef\n  TypedefNameDecl *Typedef;\n  if (IsTypeAlias)\n    Typedef = TypeAliasDecl::Create(SemaRef.Context, Owner, D->getBeginLoc(),\n                                    D->getLocation(), D->getIdentifier(), DI);\n  else\n    Typedef = TypedefDecl::Create(SemaRef.Context, Owner, D->getBeginLoc(),\n                                  D->getLocation(), D->getIdentifier(), DI);\n  if (Invalid)\n    Typedef->setInvalidDecl();\n\n  // If the old typedef was the name for linkage purposes of an anonymous\n  // tag decl, re-establish that relationship for the new typedef.\n  if (const TagType *oldTagType = D->getUnderlyingType()->getAs<TagType>()) {\n    TagDecl *oldTag = oldTagType->getDecl();\n    if (oldTag->getTypedefNameForAnonDecl() == D && !Invalid) {\n      TagDecl *newTag = DI->getType()->castAs<TagType>()->getDecl();\n      assert(!newTag->hasNameForLinkage());\n      newTag->setTypedefNameForAnonDecl(Typedef);\n    }\n  }\n\n  if (TypedefNameDecl *Prev = getPreviousDeclForInstantiation(D)) {\n    NamedDecl *InstPrev = SemaRef.FindInstantiatedDecl(D->getLocation(), Prev,\n                                                       TemplateArgs);\n    if (!InstPrev)\n      return nullptr;\n\n    TypedefNameDecl *InstPrevTypedef = cast<TypedefNameDecl>(InstPrev);\n\n    // If the typedef types are not identical, reject them.\n    SemaRef.isIncompatibleTypedef(InstPrevTypedef, Typedef);\n\n    Typedef->setPreviousDecl(InstPrevTypedef);\n  }\n\n  SemaRef.InstantiateAttrs(TemplateArgs, D, Typedef);\n\n  if (D->getUnderlyingType()->getAs<DependentNameType>())\n    SemaRef.inferGslPointerAttribute(Typedef);\n\n  Typedef->setAccess(D->getAccess());\n\n  return Typedef;\n}\n\nDecl *TemplateDeclInstantiator::VisitTypedefDecl(TypedefDecl *D) {\n  Decl *Typedef = InstantiateTypedefNameDecl(D, /*IsTypeAlias=*/false);\n  if (Typedef)\n    Owner->addDecl(Typedef);\n  return Typedef;\n}\n\nDecl *TemplateDeclInstantiator::VisitTypeAliasDecl(TypeAliasDecl *D) {\n  Decl *Typedef = InstantiateTypedefNameDecl(D, /*IsTypeAlias=*/true);\n  if (Typedef)\n    Owner->addDecl(Typedef);\n  return Typedef;\n}\n\nDecl *\nTemplateDeclInstantiator::VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D) {\n  // Create a local instantiation scope for this type alias template, which\n  // will contain the instantiations of the template parameters.\n  LocalInstantiationScope Scope(SemaRef);\n\n  TemplateParameterList *TempParams = D->getTemplateParameters();\n  TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n  if (!InstParams)\n    return nullptr;\n\n  TypeAliasDecl *Pattern = D->getTemplatedDecl();\n\n  TypeAliasTemplateDecl *PrevAliasTemplate = nullptr;\n  if (getPreviousDeclForInstantiation<TypedefNameDecl>(Pattern)) {\n    DeclContext::lookup_result Found = Owner->lookup(Pattern->getDeclName());\n    if (!Found.empty()) {\n      PrevAliasTemplate = dyn_cast<TypeAliasTemplateDecl>(Found.front());\n    }\n  }\n\n  TypeAliasDecl *AliasInst = cast_or_null<TypeAliasDecl>(\n    InstantiateTypedefNameDecl(Pattern, /*IsTypeAlias=*/true));\n  if (!AliasInst)\n    return nullptr;\n\n  TypeAliasTemplateDecl *Inst\n    = TypeAliasTemplateDecl::Create(SemaRef.Context, Owner, D->getLocation(),\n                                    D->getDeclName(), InstParams, AliasInst);\n  AliasInst->setDescribedAliasTemplate(Inst);\n  if (PrevAliasTemplate)\n    Inst->setPreviousDecl(PrevAliasTemplate);\n\n  Inst->setAccess(D->getAccess());\n\n  if (!PrevAliasTemplate)\n    Inst->setInstantiatedFromMemberTemplate(D);\n\n  Owner->addDecl(Inst);\n\n  return Inst;\n}\n\nDecl *TemplateDeclInstantiator::VisitBindingDecl(BindingDecl *D) {\n  auto *NewBD = BindingDecl::Create(SemaRef.Context, Owner, D->getLocation(),\n                                    D->getIdentifier());\n  NewBD->setReferenced(D->isReferenced());\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, NewBD);\n  return NewBD;\n}\n\nDecl *TemplateDeclInstantiator::VisitDecompositionDecl(DecompositionDecl *D) {\n  // Transform the bindings first.\n  SmallVector<BindingDecl*, 16> NewBindings;\n  for (auto *OldBD : D->bindings())\n    NewBindings.push_back(cast<BindingDecl>(VisitBindingDecl(OldBD)));\n  ArrayRef<BindingDecl*> NewBindingArray = NewBindings;\n\n  auto *NewDD = cast_or_null<DecompositionDecl>(\n      VisitVarDecl(D, /*InstantiatingVarTemplate=*/false, &NewBindingArray));\n\n  if (!NewDD || NewDD->isInvalidDecl())\n    for (auto *NewBD : NewBindings)\n      NewBD->setInvalidDecl();\n\n  return NewDD;\n}\n\nDecl *TemplateDeclInstantiator::VisitVarDecl(VarDecl *D) {\n  return VisitVarDecl(D, /*InstantiatingVarTemplate=*/false);\n}\n\nDecl *TemplateDeclInstantiator::VisitVarDecl(VarDecl *D,\n                                             bool InstantiatingVarTemplate,\n                                             ArrayRef<BindingDecl*> *Bindings) {\n\n  // Do substitution on the type of the declaration\n  TypeSourceInfo *DI = SemaRef.SubstType(\n      D->getTypeSourceInfo(), TemplateArgs, D->getTypeSpecStartLoc(),\n      D->getDeclName(), /*AllowDeducedTST*/true);\n  if (!DI)\n    return nullptr;\n\n  if (DI->getType()->isFunctionType()) {\n    SemaRef.Diag(D->getLocation(), diag::err_variable_instantiates_to_function)\n      << D->isStaticDataMember() << DI->getType();\n    return nullptr;\n  }\n\n  DeclContext *DC = Owner;\n  if (D->isLocalExternDecl())\n    SemaRef.adjustContextForLocalExternDecl(DC);\n\n  // Build the instantiated declaration.\n  VarDecl *Var;\n  if (Bindings)\n    Var = DecompositionDecl::Create(SemaRef.Context, DC, D->getInnerLocStart(),\n                                    D->getLocation(), DI->getType(), DI,\n                                    D->getStorageClass(), *Bindings);\n  else\n    Var = VarDecl::Create(SemaRef.Context, DC, D->getInnerLocStart(),\n                          D->getLocation(), D->getIdentifier(), DI->getType(),\n                          DI, D->getStorageClass());\n\n  // In ARC, infer 'retaining' for variables of retainable type.\n  if (SemaRef.getLangOpts().ObjCAutoRefCount &&\n      SemaRef.inferObjCARCLifetime(Var))\n    Var->setInvalidDecl();\n\n  if (SemaRef.getLangOpts().OpenCL)\n    SemaRef.deduceOpenCLAddressSpace(Var);\n\n  // Substitute the nested name specifier, if any.\n  if (SubstQualifier(D, Var))\n    return nullptr;\n\n  SemaRef.BuildVariableInstantiation(Var, D, TemplateArgs, LateAttrs, Owner,\n                                     StartingScope, InstantiatingVarTemplate);\n\n  if (D->isNRVOVariable()) {\n    QualType ReturnType = cast<FunctionDecl>(DC)->getReturnType();\n    if (SemaRef.isCopyElisionCandidate(ReturnType, Var, Sema::CES_Strict))\n      Var->setNRVOVariable(true);\n  }\n\n  Var->setImplicit(D->isImplicit());\n\n  if (Var->isStaticLocal())\n    SemaRef.CheckStaticLocalForDllExport(Var);\n\n  return Var;\n}\n\nDecl *TemplateDeclInstantiator::VisitAccessSpecDecl(AccessSpecDecl *D) {\n  AccessSpecDecl* AD\n    = AccessSpecDecl::Create(SemaRef.Context, D->getAccess(), Owner,\n                             D->getAccessSpecifierLoc(), D->getColonLoc());\n  Owner->addHiddenDecl(AD);\n  return AD;\n}\n\nDecl *TemplateDeclInstantiator::VisitFieldDecl(FieldDecl *D) {\n  bool Invalid = false;\n  TypeSourceInfo *DI = D->getTypeSourceInfo();\n  if (DI->getType()->isInstantiationDependentType() ||\n      DI->getType()->isVariablyModifiedType())  {\n    DI = SemaRef.SubstType(DI, TemplateArgs,\n                           D->getLocation(), D->getDeclName());\n    if (!DI) {\n      DI = D->getTypeSourceInfo();\n      Invalid = true;\n    } else if (DI->getType()->isFunctionType()) {\n      // C++ [temp.arg.type]p3:\n      //   If a declaration acquires a function type through a type\n      //   dependent on a template-parameter and this causes a\n      //   declaration that does not use the syntactic form of a\n      //   function declarator to have function type, the program is\n      //   ill-formed.\n      SemaRef.Diag(D->getLocation(), diag::err_field_instantiates_to_function)\n        << DI->getType();\n      Invalid = true;\n    }\n  } else {\n    SemaRef.MarkDeclarationsReferencedInType(D->getLocation(), DI->getType());\n  }\n\n  Expr *BitWidth = D->getBitWidth();\n  if (Invalid)\n    BitWidth = nullptr;\n  else if (BitWidth) {\n    // The bit-width expression is a constant expression.\n    EnterExpressionEvaluationContext Unevaluated(\n        SemaRef, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n    ExprResult InstantiatedBitWidth\n      = SemaRef.SubstExpr(BitWidth, TemplateArgs);\n    if (InstantiatedBitWidth.isInvalid()) {\n      Invalid = true;\n      BitWidth = nullptr;\n    } else\n      BitWidth = InstantiatedBitWidth.getAs<Expr>();\n  }\n\n  FieldDecl *Field = SemaRef.CheckFieldDecl(D->getDeclName(),\n                                            DI->getType(), DI,\n                                            cast<RecordDecl>(Owner),\n                                            D->getLocation(),\n                                            D->isMutable(),\n                                            BitWidth,\n                                            D->getInClassInitStyle(),\n                                            D->getInnerLocStart(),\n                                            D->getAccess(),\n                                            nullptr);\n  if (!Field) {\n    cast<Decl>(Owner)->setInvalidDecl();\n    return nullptr;\n  }\n\n  SemaRef.InstantiateAttrs(TemplateArgs, D, Field, LateAttrs, StartingScope);\n\n  if (Field->hasAttrs())\n    SemaRef.CheckAlignasUnderalignment(Field);\n\n  if (Invalid)\n    Field->setInvalidDecl();\n\n  if (!Field->getDeclName()) {\n    // Keep track of where this decl came from.\n    SemaRef.Context.setInstantiatedFromUnnamedFieldDecl(Field, D);\n  }\n  if (CXXRecordDecl *Parent= dyn_cast<CXXRecordDecl>(Field->getDeclContext())) {\n    if (Parent->isAnonymousStructOrUnion() &&\n        Parent->getRedeclContext()->isFunctionOrMethod())\n      SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, Field);\n  }\n\n  Field->setImplicit(D->isImplicit());\n  Field->setAccess(D->getAccess());\n  Owner->addDecl(Field);\n\n  return Field;\n}\n\nDecl *TemplateDeclInstantiator::VisitMSPropertyDecl(MSPropertyDecl *D) {\n  bool Invalid = false;\n  TypeSourceInfo *DI = D->getTypeSourceInfo();\n\n  if (DI->getType()->isVariablyModifiedType()) {\n    SemaRef.Diag(D->getLocation(), diag::err_property_is_variably_modified)\n      << D;\n    Invalid = true;\n  } else if (DI->getType()->isInstantiationDependentType())  {\n    DI = SemaRef.SubstType(DI, TemplateArgs,\n                           D->getLocation(), D->getDeclName());\n    if (!DI) {\n      DI = D->getTypeSourceInfo();\n      Invalid = true;\n    } else if (DI->getType()->isFunctionType()) {\n      // C++ [temp.arg.type]p3:\n      //   If a declaration acquires a function type through a type\n      //   dependent on a template-parameter and this causes a\n      //   declaration that does not use the syntactic form of a\n      //   function declarator to have function type, the program is\n      //   ill-formed.\n      SemaRef.Diag(D->getLocation(), diag::err_field_instantiates_to_function)\n      << DI->getType();\n      Invalid = true;\n    }\n  } else {\n    SemaRef.MarkDeclarationsReferencedInType(D->getLocation(), DI->getType());\n  }\n\n  MSPropertyDecl *Property = MSPropertyDecl::Create(\n      SemaRef.Context, Owner, D->getLocation(), D->getDeclName(), DI->getType(),\n      DI, D->getBeginLoc(), D->getGetterId(), D->getSetterId());\n\n  SemaRef.InstantiateAttrs(TemplateArgs, D, Property, LateAttrs,\n                           StartingScope);\n\n  if (Invalid)\n    Property->setInvalidDecl();\n\n  Property->setAccess(D->getAccess());\n  Owner->addDecl(Property);\n\n  return Property;\n}\n\nDecl *TemplateDeclInstantiator::VisitIndirectFieldDecl(IndirectFieldDecl *D) {\n  NamedDecl **NamedChain =\n    new (SemaRef.Context)NamedDecl*[D->getChainingSize()];\n\n  int i = 0;\n  for (auto *PI : D->chain()) {\n    NamedDecl *Next = SemaRef.FindInstantiatedDecl(D->getLocation(), PI,\n                                              TemplateArgs);\n    if (!Next)\n      return nullptr;\n\n    NamedChain[i++] = Next;\n  }\n\n  QualType T = cast<FieldDecl>(NamedChain[i-1])->getType();\n  IndirectFieldDecl *IndirectField = IndirectFieldDecl::Create(\n      SemaRef.Context, Owner, D->getLocation(), D->getIdentifier(), T,\n      {NamedChain, D->getChainingSize()});\n\n  for (const auto *Attr : D->attrs())\n    IndirectField->addAttr(Attr->clone(SemaRef.Context));\n\n  IndirectField->setImplicit(D->isImplicit());\n  IndirectField->setAccess(D->getAccess());\n  Owner->addDecl(IndirectField);\n  return IndirectField;\n}\n\nDecl *TemplateDeclInstantiator::VisitFriendDecl(FriendDecl *D) {\n  // Handle friend type expressions by simply substituting template\n  // parameters into the pattern type and checking the result.\n  if (TypeSourceInfo *Ty = D->getFriendType()) {\n    TypeSourceInfo *InstTy;\n    // If this is an unsupported friend, don't bother substituting template\n    // arguments into it. The actual type referred to won't be used by any\n    // parts of Clang, and may not be valid for instantiating. Just use the\n    // same info for the instantiated friend.\n    if (D->isUnsupportedFriend()) {\n      InstTy = Ty;\n    } else {\n      InstTy = SemaRef.SubstType(Ty, TemplateArgs,\n                                 D->getLocation(), DeclarationName());\n    }\n    if (!InstTy)\n      return nullptr;\n\n    FriendDecl *FD = SemaRef.CheckFriendTypeDecl(D->getBeginLoc(),\n                                                 D->getFriendLoc(), InstTy);\n    if (!FD)\n      return nullptr;\n\n    FD->setAccess(AS_public);\n    FD->setUnsupportedFriend(D->isUnsupportedFriend());\n    Owner->addDecl(FD);\n    return FD;\n  }\n\n  NamedDecl *ND = D->getFriendDecl();\n  assert(ND && \"friend decl must be a decl or a type!\");\n\n  // All of the Visit implementations for the various potential friend\n  // declarations have to be carefully written to work for friend\n  // objects, with the most important detail being that the target\n  // decl should almost certainly not be placed in Owner.\n  Decl *NewND = Visit(ND);\n  if (!NewND) return nullptr;\n\n  FriendDecl *FD =\n    FriendDecl::Create(SemaRef.Context, Owner, D->getLocation(),\n                       cast<NamedDecl>(NewND), D->getFriendLoc());\n  FD->setAccess(AS_public);\n  FD->setUnsupportedFriend(D->isUnsupportedFriend());\n  Owner->addDecl(FD);\n  return FD;\n}\n\nDecl *TemplateDeclInstantiator::VisitStaticAssertDecl(StaticAssertDecl *D) {\n  Expr *AssertExpr = D->getAssertExpr();\n\n  // The expression in a static assertion is a constant expression.\n  EnterExpressionEvaluationContext Unevaluated(\n      SemaRef, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  ExprResult InstantiatedAssertExpr\n    = SemaRef.SubstExpr(AssertExpr, TemplateArgs);\n  if (InstantiatedAssertExpr.isInvalid())\n    return nullptr;\n\n  return SemaRef.BuildStaticAssertDeclaration(D->getLocation(),\n                                              InstantiatedAssertExpr.get(),\n                                              D->getMessage(),\n                                              D->getRParenLoc(),\n                                              D->isFailed());\n}\n\nDecl *TemplateDeclInstantiator::VisitEnumDecl(EnumDecl *D) {\n  EnumDecl *PrevDecl = nullptr;\n  if (EnumDecl *PatternPrev = getPreviousDeclForInstantiation(D)) {\n    NamedDecl *Prev = SemaRef.FindInstantiatedDecl(D->getLocation(),\n                                                   PatternPrev,\n                                                   TemplateArgs);\n    if (!Prev) return nullptr;\n    PrevDecl = cast<EnumDecl>(Prev);\n  }\n\n  EnumDecl *Enum =\n      EnumDecl::Create(SemaRef.Context, Owner, D->getBeginLoc(),\n                       D->getLocation(), D->getIdentifier(), PrevDecl,\n                       D->isScoped(), D->isScopedUsingClassTag(), D->isFixed());\n  if (D->isFixed()) {\n    if (TypeSourceInfo *TI = D->getIntegerTypeSourceInfo()) {\n      // If we have type source information for the underlying type, it means it\n      // has been explicitly set by the user. Perform substitution on it before\n      // moving on.\n      SourceLocation UnderlyingLoc = TI->getTypeLoc().getBeginLoc();\n      TypeSourceInfo *NewTI = SemaRef.SubstType(TI, TemplateArgs, UnderlyingLoc,\n                                                DeclarationName());\n      if (!NewTI || SemaRef.CheckEnumUnderlyingType(NewTI))\n        Enum->setIntegerType(SemaRef.Context.IntTy);\n      else\n        Enum->setIntegerTypeSourceInfo(NewTI);\n    } else {\n      assert(!D->getIntegerType()->isDependentType()\n             && \"Dependent type without type source info\");\n      Enum->setIntegerType(D->getIntegerType());\n    }\n  }\n\n  SemaRef.InstantiateAttrs(TemplateArgs, D, Enum);\n\n  Enum->setInstantiationOfMemberEnum(D, TSK_ImplicitInstantiation);\n  Enum->setAccess(D->getAccess());\n  // Forward the mangling number from the template to the instantiated decl.\n  SemaRef.Context.setManglingNumber(Enum, SemaRef.Context.getManglingNumber(D));\n  // See if the old tag was defined along with a declarator.\n  // If it did, mark the new tag as being associated with that declarator.\n  if (DeclaratorDecl *DD = SemaRef.Context.getDeclaratorForUnnamedTagDecl(D))\n    SemaRef.Context.addDeclaratorForUnnamedTagDecl(Enum, DD);\n  // See if the old tag was defined along with a typedef.\n  // If it did, mark the new tag as being associated with that typedef.\n  if (TypedefNameDecl *TND = SemaRef.Context.getTypedefNameForUnnamedTagDecl(D))\n    SemaRef.Context.addTypedefNameForUnnamedTagDecl(Enum, TND);\n  if (SubstQualifier(D, Enum)) return nullptr;\n  Owner->addDecl(Enum);\n\n  EnumDecl *Def = D->getDefinition();\n  if (Def && Def != D) {\n    // If this is an out-of-line definition of an enum member template, check\n    // that the underlying types match in the instantiation of both\n    // declarations.\n    if (TypeSourceInfo *TI = Def->getIntegerTypeSourceInfo()) {\n      SourceLocation UnderlyingLoc = TI->getTypeLoc().getBeginLoc();\n      QualType DefnUnderlying =\n        SemaRef.SubstType(TI->getType(), TemplateArgs,\n                          UnderlyingLoc, DeclarationName());\n      SemaRef.CheckEnumRedeclaration(Def->getLocation(), Def->isScoped(),\n                                     DefnUnderlying, /*IsFixed=*/true, Enum);\n    }\n  }\n\n  // C++11 [temp.inst]p1: The implicit instantiation of a class template\n  // specialization causes the implicit instantiation of the declarations, but\n  // not the definitions of scoped member enumerations.\n  //\n  // DR1484 clarifies that enumeration definitions inside of a template\n  // declaration aren't considered entities that can be separately instantiated\n  // from the rest of the entity they are declared inside of.\n  if (isDeclWithinFunction(D) ? D == Def : Def && !Enum->isScoped()) {\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, Enum);\n    InstantiateEnumDefinition(Enum, Def);\n  }\n\n  return Enum;\n}\n\nvoid TemplateDeclInstantiator::InstantiateEnumDefinition(\n    EnumDecl *Enum, EnumDecl *Pattern) {\n  Enum->startDefinition();\n\n  // Update the location to refer to the definition.\n  Enum->setLocation(Pattern->getLocation());\n\n  SmallVector<Decl*, 4> Enumerators;\n\n  EnumConstantDecl *LastEnumConst = nullptr;\n  for (auto *EC : Pattern->enumerators()) {\n    // The specified value for the enumerator.\n    ExprResult Value((Expr *)nullptr);\n    if (Expr *UninstValue = EC->getInitExpr()) {\n      // The enumerator's value expression is a constant expression.\n      EnterExpressionEvaluationContext Unevaluated(\n          SemaRef, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n      Value = SemaRef.SubstExpr(UninstValue, TemplateArgs);\n    }\n\n    // Drop the initial value and continue.\n    bool isInvalid = false;\n    if (Value.isInvalid()) {\n      Value = nullptr;\n      isInvalid = true;\n    }\n\n    EnumConstantDecl *EnumConst\n      = SemaRef.CheckEnumConstant(Enum, LastEnumConst,\n                                  EC->getLocation(), EC->getIdentifier(),\n                                  Value.get());\n\n    if (isInvalid) {\n      if (EnumConst)\n        EnumConst->setInvalidDecl();\n      Enum->setInvalidDecl();\n    }\n\n    if (EnumConst) {\n      SemaRef.InstantiateAttrs(TemplateArgs, EC, EnumConst);\n\n      EnumConst->setAccess(Enum->getAccess());\n      Enum->addDecl(EnumConst);\n      Enumerators.push_back(EnumConst);\n      LastEnumConst = EnumConst;\n\n      if (Pattern->getDeclContext()->isFunctionOrMethod() &&\n          !Enum->isScoped()) {\n        // If the enumeration is within a function or method, record the enum\n        // constant as a local.\n        SemaRef.CurrentInstantiationScope->InstantiatedLocal(EC, EnumConst);\n      }\n    }\n  }\n\n  SemaRef.ActOnEnumBody(Enum->getLocation(), Enum->getBraceRange(), Enum,\n                        Enumerators, nullptr, ParsedAttributesView());\n}\n\nDecl *TemplateDeclInstantiator::VisitEnumConstantDecl(EnumConstantDecl *D) {\n  llvm_unreachable(\"EnumConstantDecls can only occur within EnumDecls.\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitBuiltinTemplateDecl(BuiltinTemplateDecl *D) {\n  llvm_unreachable(\"BuiltinTemplateDecls cannot be instantiated.\");\n}\n\nDecl *TemplateDeclInstantiator::VisitClassTemplateDecl(ClassTemplateDecl *D) {\n  bool isFriend = (D->getFriendObjectKind() != Decl::FOK_None);\n\n  // Create a local instantiation scope for this class template, which\n  // will contain the instantiations of the template parameters.\n  LocalInstantiationScope Scope(SemaRef);\n  TemplateParameterList *TempParams = D->getTemplateParameters();\n  TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n  if (!InstParams)\n    return nullptr;\n\n  CXXRecordDecl *Pattern = D->getTemplatedDecl();\n\n  // Instantiate the qualifier.  We have to do this first in case\n  // we're a friend declaration, because if we are then we need to put\n  // the new declaration in the appropriate context.\n  NestedNameSpecifierLoc QualifierLoc = Pattern->getQualifierLoc();\n  if (QualifierLoc) {\n    QualifierLoc = SemaRef.SubstNestedNameSpecifierLoc(QualifierLoc,\n                                                       TemplateArgs);\n    if (!QualifierLoc)\n      return nullptr;\n  }\n\n  CXXRecordDecl *PrevDecl = nullptr;\n  ClassTemplateDecl *PrevClassTemplate = nullptr;\n\n  if (!isFriend && getPreviousDeclForInstantiation(Pattern)) {\n    DeclContext::lookup_result Found = Owner->lookup(Pattern->getDeclName());\n    if (!Found.empty()) {\n      PrevClassTemplate = dyn_cast<ClassTemplateDecl>(Found.front());\n      if (PrevClassTemplate)\n        PrevDecl = PrevClassTemplate->getTemplatedDecl();\n    }\n  }\n\n  // If this isn't a friend, then it's a member template, in which\n  // case we just want to build the instantiation in the\n  // specialization.  If it is a friend, we want to build it in\n  // the appropriate context.\n  DeclContext *DC = Owner;\n  if (isFriend) {\n    if (QualifierLoc) {\n      CXXScopeSpec SS;\n      SS.Adopt(QualifierLoc);\n      DC = SemaRef.computeDeclContext(SS);\n      if (!DC) return nullptr;\n    } else {\n      DC = SemaRef.FindInstantiatedContext(Pattern->getLocation(),\n                                           Pattern->getDeclContext(),\n                                           TemplateArgs);\n    }\n\n    // Look for a previous declaration of the template in the owning\n    // context.\n    LookupResult R(SemaRef, Pattern->getDeclName(), Pattern->getLocation(),\n                   Sema::LookupOrdinaryName,\n                   SemaRef.forRedeclarationInCurContext());\n    SemaRef.LookupQualifiedName(R, DC);\n\n    if (R.isSingleResult()) {\n      PrevClassTemplate = R.getAsSingle<ClassTemplateDecl>();\n      if (PrevClassTemplate)\n        PrevDecl = PrevClassTemplate->getTemplatedDecl();\n    }\n\n    if (!PrevClassTemplate && QualifierLoc) {\n      SemaRef.Diag(Pattern->getLocation(), diag::err_not_tag_in_scope)\n        << D->getTemplatedDecl()->getTagKind() << Pattern->getDeclName() << DC\n        << QualifierLoc.getSourceRange();\n      return nullptr;\n    }\n\n    bool AdoptedPreviousTemplateParams = false;\n    if (PrevClassTemplate) {\n      bool Complain = true;\n\n      // HACK: libstdc++ 4.2.1 contains an ill-formed friend class\n      // template for struct std::tr1::__detail::_Map_base, where the\n      // template parameters of the friend declaration don't match the\n      // template parameters of the original declaration. In this one\n      // case, we don't complain about the ill-formed friend\n      // declaration.\n      if (isFriend && Pattern->getIdentifier() &&\n          Pattern->getIdentifier()->isStr(\"_Map_base\") &&\n          DC->isNamespace() &&\n          cast<NamespaceDecl>(DC)->getIdentifier() &&\n          cast<NamespaceDecl>(DC)->getIdentifier()->isStr(\"__detail\")) {\n        DeclContext *DCParent = DC->getParent();\n        if (DCParent->isNamespace() &&\n            cast<NamespaceDecl>(DCParent)->getIdentifier() &&\n            cast<NamespaceDecl>(DCParent)->getIdentifier()->isStr(\"tr1\")) {\n          if (cast<Decl>(DCParent)->isInStdNamespace())\n            Complain = false;\n        }\n      }\n\n      TemplateParameterList *PrevParams\n        = PrevClassTemplate->getMostRecentDecl()->getTemplateParameters();\n\n      // Make sure the parameter lists match.\n      if (!SemaRef.TemplateParameterListsAreEqual(InstParams, PrevParams,\n                                                  Complain,\n                                                  Sema::TPL_TemplateMatch)) {\n        if (Complain)\n          return nullptr;\n\n        AdoptedPreviousTemplateParams = true;\n        InstParams = PrevParams;\n      }\n\n      // Do some additional validation, then merge default arguments\n      // from the existing declarations.\n      if (!AdoptedPreviousTemplateParams &&\n          SemaRef.CheckTemplateParameterList(InstParams, PrevParams,\n                                             Sema::TPC_ClassTemplate))\n        return nullptr;\n    }\n  }\n\n  CXXRecordDecl *RecordInst = CXXRecordDecl::Create(\n      SemaRef.Context, Pattern->getTagKind(), DC, Pattern->getBeginLoc(),\n      Pattern->getLocation(), Pattern->getIdentifier(), PrevDecl,\n      /*DelayTypeCreation=*/true);\n\n  if (QualifierLoc)\n    RecordInst->setQualifierInfo(QualifierLoc);\n\n  SemaRef.InstantiateAttrsForDecl(TemplateArgs, Pattern, RecordInst, LateAttrs,\n                                                              StartingScope);\n\n  ClassTemplateDecl *Inst\n    = ClassTemplateDecl::Create(SemaRef.Context, DC, D->getLocation(),\n                                D->getIdentifier(), InstParams, RecordInst);\n  assert(!(isFriend && Owner->isDependentContext()));\n  Inst->setPreviousDecl(PrevClassTemplate);\n\n  RecordInst->setDescribedClassTemplate(Inst);\n\n  if (isFriend) {\n    if (PrevClassTemplate)\n      Inst->setAccess(PrevClassTemplate->getAccess());\n    else\n      Inst->setAccess(D->getAccess());\n\n    Inst->setObjectOfFriendDecl();\n    // TODO: do we want to track the instantiation progeny of this\n    // friend target decl?\n  } else {\n    Inst->setAccess(D->getAccess());\n    if (!PrevClassTemplate)\n      Inst->setInstantiatedFromMemberTemplate(D);\n  }\n\n  // Trigger creation of the type for the instantiation.\n  SemaRef.Context.getInjectedClassNameType(RecordInst,\n                                    Inst->getInjectedClassNameSpecialization());\n\n  // Finish handling of friends.\n  if (isFriend) {\n    DC->makeDeclVisibleInContext(Inst);\n    Inst->setLexicalDeclContext(Owner);\n    RecordInst->setLexicalDeclContext(Owner);\n    return Inst;\n  }\n\n  if (D->isOutOfLine()) {\n    Inst->setLexicalDeclContext(D->getLexicalDeclContext());\n    RecordInst->setLexicalDeclContext(D->getLexicalDeclContext());\n  }\n\n  Owner->addDecl(Inst);\n\n  if (!PrevClassTemplate) {\n    // Queue up any out-of-line partial specializations of this member\n    // class template; the client will force their instantiation once\n    // the enclosing class has been instantiated.\n    SmallVector<ClassTemplatePartialSpecializationDecl *, 4> PartialSpecs;\n    D->getPartialSpecializations(PartialSpecs);\n    for (unsigned I = 0, N = PartialSpecs.size(); I != N; ++I)\n      if (PartialSpecs[I]->getFirstDecl()->isOutOfLine())\n        OutOfLinePartialSpecs.push_back(std::make_pair(Inst, PartialSpecs[I]));\n  }\n\n  return Inst;\n}\n\nDecl *\nTemplateDeclInstantiator::VisitClassTemplatePartialSpecializationDecl(\n                                   ClassTemplatePartialSpecializationDecl *D) {\n  ClassTemplateDecl *ClassTemplate = D->getSpecializedTemplate();\n\n  // Lookup the already-instantiated declaration in the instantiation\n  // of the class template and return that.\n  DeclContext::lookup_result Found\n    = Owner->lookup(ClassTemplate->getDeclName());\n  if (Found.empty())\n    return nullptr;\n\n  ClassTemplateDecl *InstClassTemplate\n    = dyn_cast<ClassTemplateDecl>(Found.front());\n  if (!InstClassTemplate)\n    return nullptr;\n\n  if (ClassTemplatePartialSpecializationDecl *Result\n        = InstClassTemplate->findPartialSpecInstantiatedFromMember(D))\n    return Result;\n\n  return InstantiateClassTemplatePartialSpecialization(InstClassTemplate, D);\n}\n\nDecl *TemplateDeclInstantiator::VisitVarTemplateDecl(VarTemplateDecl *D) {\n  assert(D->getTemplatedDecl()->isStaticDataMember() &&\n         \"Only static data member templates are allowed.\");\n\n  // Create a local instantiation scope for this variable template, which\n  // will contain the instantiations of the template parameters.\n  LocalInstantiationScope Scope(SemaRef);\n  TemplateParameterList *TempParams = D->getTemplateParameters();\n  TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n  if (!InstParams)\n    return nullptr;\n\n  VarDecl *Pattern = D->getTemplatedDecl();\n  VarTemplateDecl *PrevVarTemplate = nullptr;\n\n  if (getPreviousDeclForInstantiation(Pattern)) {\n    DeclContext::lookup_result Found = Owner->lookup(Pattern->getDeclName());\n    if (!Found.empty())\n      PrevVarTemplate = dyn_cast<VarTemplateDecl>(Found.front());\n  }\n\n  VarDecl *VarInst =\n      cast_or_null<VarDecl>(VisitVarDecl(Pattern,\n                                         /*InstantiatingVarTemplate=*/true));\n  if (!VarInst) return nullptr;\n\n  DeclContext *DC = Owner;\n\n  VarTemplateDecl *Inst = VarTemplateDecl::Create(\n      SemaRef.Context, DC, D->getLocation(), D->getIdentifier(), InstParams,\n      VarInst);\n  VarInst->setDescribedVarTemplate(Inst);\n  Inst->setPreviousDecl(PrevVarTemplate);\n\n  Inst->setAccess(D->getAccess());\n  if (!PrevVarTemplate)\n    Inst->setInstantiatedFromMemberTemplate(D);\n\n  if (D->isOutOfLine()) {\n    Inst->setLexicalDeclContext(D->getLexicalDeclContext());\n    VarInst->setLexicalDeclContext(D->getLexicalDeclContext());\n  }\n\n  Owner->addDecl(Inst);\n\n  if (!PrevVarTemplate) {\n    // Queue up any out-of-line partial specializations of this member\n    // variable template; the client will force their instantiation once\n    // the enclosing class has been instantiated.\n    SmallVector<VarTemplatePartialSpecializationDecl *, 4> PartialSpecs;\n    D->getPartialSpecializations(PartialSpecs);\n    for (unsigned I = 0, N = PartialSpecs.size(); I != N; ++I)\n      if (PartialSpecs[I]->getFirstDecl()->isOutOfLine())\n        OutOfLineVarPartialSpecs.push_back(\n            std::make_pair(Inst, PartialSpecs[I]));\n  }\n\n  return Inst;\n}\n\nDecl *TemplateDeclInstantiator::VisitVarTemplatePartialSpecializationDecl(\n    VarTemplatePartialSpecializationDecl *D) {\n  assert(D->isStaticDataMember() &&\n         \"Only static data member templates are allowed.\");\n\n  VarTemplateDecl *VarTemplate = D->getSpecializedTemplate();\n\n  // Lookup the already-instantiated declaration and return that.\n  DeclContext::lookup_result Found = Owner->lookup(VarTemplate->getDeclName());\n  assert(!Found.empty() && \"Instantiation found nothing?\");\n\n  VarTemplateDecl *InstVarTemplate = dyn_cast<VarTemplateDecl>(Found.front());\n  assert(InstVarTemplate && \"Instantiation did not find a variable template?\");\n\n  if (VarTemplatePartialSpecializationDecl *Result =\n          InstVarTemplate->findPartialSpecInstantiatedFromMember(D))\n    return Result;\n\n  return InstantiateVarTemplatePartialSpecialization(InstVarTemplate, D);\n}\n\nDecl *\nTemplateDeclInstantiator::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {\n  // Create a local instantiation scope for this function template, which\n  // will contain the instantiations of the template parameters and then get\n  // merged with the local instantiation scope for the function template\n  // itself.\n  LocalInstantiationScope Scope(SemaRef);\n\n  TemplateParameterList *TempParams = D->getTemplateParameters();\n  TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n  if (!InstParams)\n    return nullptr;\n\n  FunctionDecl *Instantiated = nullptr;\n  if (CXXMethodDecl *DMethod = dyn_cast<CXXMethodDecl>(D->getTemplatedDecl()))\n    Instantiated = cast_or_null<FunctionDecl>(VisitCXXMethodDecl(DMethod,\n                                                                 InstParams));\n  else\n    Instantiated = cast_or_null<FunctionDecl>(VisitFunctionDecl(\n                                                          D->getTemplatedDecl(),\n                                                                InstParams));\n\n  if (!Instantiated)\n    return nullptr;\n\n  // Link the instantiated function template declaration to the function\n  // template from which it was instantiated.\n  FunctionTemplateDecl *InstTemplate\n    = Instantiated->getDescribedFunctionTemplate();\n  InstTemplate->setAccess(D->getAccess());\n  assert(InstTemplate &&\n         \"VisitFunctionDecl/CXXMethodDecl didn't create a template!\");\n\n  bool isFriend = (InstTemplate->getFriendObjectKind() != Decl::FOK_None);\n\n  // Link the instantiation back to the pattern *unless* this is a\n  // non-definition friend declaration.\n  if (!InstTemplate->getInstantiatedFromMemberTemplate() &&\n      !(isFriend && !D->getTemplatedDecl()->isThisDeclarationADefinition()))\n    InstTemplate->setInstantiatedFromMemberTemplate(D);\n\n  // Make declarations visible in the appropriate context.\n  if (!isFriend) {\n    Owner->addDecl(InstTemplate);\n  } else if (InstTemplate->getDeclContext()->isRecord() &&\n             !getPreviousDeclForInstantiation(D)) {\n    SemaRef.CheckFriendAccess(InstTemplate);\n  }\n\n  return InstTemplate;\n}\n\nDecl *TemplateDeclInstantiator::VisitCXXRecordDecl(CXXRecordDecl *D) {\n  CXXRecordDecl *PrevDecl = nullptr;\n  if (D->isInjectedClassName())\n    PrevDecl = cast<CXXRecordDecl>(Owner);\n  else if (CXXRecordDecl *PatternPrev = getPreviousDeclForInstantiation(D)) {\n    NamedDecl *Prev = SemaRef.FindInstantiatedDecl(D->getLocation(),\n                                                   PatternPrev,\n                                                   TemplateArgs);\n    if (!Prev) return nullptr;\n    PrevDecl = cast<CXXRecordDecl>(Prev);\n  }\n\n  CXXRecordDecl *Record = CXXRecordDecl::Create(\n      SemaRef.Context, D->getTagKind(), Owner, D->getBeginLoc(),\n      D->getLocation(), D->getIdentifier(), PrevDecl);\n\n  // Substitute the nested name specifier, if any.\n  if (SubstQualifier(D, Record))\n    return nullptr;\n\n  SemaRef.InstantiateAttrsForDecl(TemplateArgs, D, Record, LateAttrs,\n                                                              StartingScope);\n\n  Record->setImplicit(D->isImplicit());\n  // FIXME: Check against AS_none is an ugly hack to work around the issue that\n  // the tag decls introduced by friend class declarations don't have an access\n  // specifier. Remove once this area of the code gets sorted out.\n  if (D->getAccess() != AS_none)\n    Record->setAccess(D->getAccess());\n  if (!D->isInjectedClassName())\n    Record->setInstantiationOfMemberClass(D, TSK_ImplicitInstantiation);\n\n  // If the original function was part of a friend declaration,\n  // inherit its namespace state.\n  if (D->getFriendObjectKind())\n    Record->setObjectOfFriendDecl();\n\n  // Make sure that anonymous structs and unions are recorded.\n  if (D->isAnonymousStructOrUnion())\n    Record->setAnonymousStructOrUnion(true);\n\n  if (D->isLocalClass())\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, Record);\n\n  // Forward the mangling number from the template to the instantiated decl.\n  SemaRef.Context.setManglingNumber(Record,\n                                    SemaRef.Context.getManglingNumber(D));\n\n  // See if the old tag was defined along with a declarator.\n  // If it did, mark the new tag as being associated with that declarator.\n  if (DeclaratorDecl *DD = SemaRef.Context.getDeclaratorForUnnamedTagDecl(D))\n    SemaRef.Context.addDeclaratorForUnnamedTagDecl(Record, DD);\n\n  // See if the old tag was defined along with a typedef.\n  // If it did, mark the new tag as being associated with that typedef.\n  if (TypedefNameDecl *TND = SemaRef.Context.getTypedefNameForUnnamedTagDecl(D))\n    SemaRef.Context.addTypedefNameForUnnamedTagDecl(Record, TND);\n\n  Owner->addDecl(Record);\n\n  // DR1484 clarifies that the members of a local class are instantiated as part\n  // of the instantiation of their enclosing entity.\n  if (D->isCompleteDefinition() && D->isLocalClass()) {\n    Sema::LocalEagerInstantiationScope LocalInstantiations(SemaRef);\n\n    SemaRef.InstantiateClass(D->getLocation(), Record, D, TemplateArgs,\n                             TSK_ImplicitInstantiation,\n                             /*Complain=*/true);\n\n    // For nested local classes, we will instantiate the members when we\n    // reach the end of the outermost (non-nested) local class.\n    if (!D->isCXXClassMember())\n      SemaRef.InstantiateClassMembers(D->getLocation(), Record, TemplateArgs,\n                                      TSK_ImplicitInstantiation);\n\n    // This class may have local implicit instantiations that need to be\n    // performed within this scope.\n    LocalInstantiations.perform();\n  }\n\n  SemaRef.DiagnoseUnusedNestedTypedefs(Record);\n\n  return Record;\n}\n\n/// Adjust the given function type for an instantiation of the\n/// given declaration, to cope with modifications to the function's type that\n/// aren't reflected in the type-source information.\n///\n/// \\param D The declaration we're instantiating.\n/// \\param TInfo The already-instantiated type.\nstatic QualType adjustFunctionTypeForInstantiation(ASTContext &Context,\n                                                   FunctionDecl *D,\n                                                   TypeSourceInfo *TInfo) {\n  const FunctionProtoType *OrigFunc\n    = D->getType()->castAs<FunctionProtoType>();\n  const FunctionProtoType *NewFunc\n    = TInfo->getType()->castAs<FunctionProtoType>();\n  if (OrigFunc->getExtInfo() == NewFunc->getExtInfo())\n    return TInfo->getType();\n\n  FunctionProtoType::ExtProtoInfo NewEPI = NewFunc->getExtProtoInfo();\n  NewEPI.ExtInfo = OrigFunc->getExtInfo();\n  return Context.getFunctionType(NewFunc->getReturnType(),\n                                 NewFunc->getParamTypes(), NewEPI);\n}\n\n/// Normal class members are of more specific types and therefore\n/// don't make it here.  This function serves three purposes:\n///   1) instantiating function templates\n///   2) substituting friend declarations\n///   3) substituting deduction guide declarations for nested class templates\nDecl *TemplateDeclInstantiator::VisitFunctionDecl(\n    FunctionDecl *D, TemplateParameterList *TemplateParams,\n    RewriteKind FunctionRewriteKind) {\n  // Check whether there is already a function template specialization for\n  // this declaration.\n  FunctionTemplateDecl *FunctionTemplate = D->getDescribedFunctionTemplate();\n  if (FunctionTemplate && !TemplateParams) {\n    ArrayRef<TemplateArgument> Innermost = TemplateArgs.getInnermost();\n\n    void *InsertPos = nullptr;\n    FunctionDecl *SpecFunc\n      = FunctionTemplate->findSpecialization(Innermost, InsertPos);\n\n    // If we already have a function template specialization, return it.\n    if (SpecFunc)\n      return SpecFunc;\n  }\n\n  bool isFriend;\n  if (FunctionTemplate)\n    isFriend = (FunctionTemplate->getFriendObjectKind() != Decl::FOK_None);\n  else\n    isFriend = (D->getFriendObjectKind() != Decl::FOK_None);\n\n  bool MergeWithParentScope = (TemplateParams != nullptr) ||\n    Owner->isFunctionOrMethod() ||\n    !(isa<Decl>(Owner) &&\n      cast<Decl>(Owner)->isDefinedOutsideFunctionOrMethod());\n  LocalInstantiationScope Scope(SemaRef, MergeWithParentScope);\n\n  ExplicitSpecifier InstantiatedExplicitSpecifier;\n  if (auto *DGuide = dyn_cast<CXXDeductionGuideDecl>(D)) {\n    InstantiatedExplicitSpecifier = instantiateExplicitSpecifier(\n        SemaRef, TemplateArgs, DGuide->getExplicitSpecifier(), DGuide);\n    if (InstantiatedExplicitSpecifier.isInvalid())\n      return nullptr;\n  }\n\n  SmallVector<ParmVarDecl *, 4> Params;\n  TypeSourceInfo *TInfo = SubstFunctionType(D, Params);\n  if (!TInfo)\n    return nullptr;\n  QualType T = adjustFunctionTypeForInstantiation(SemaRef.Context, D, TInfo);\n\n  if (TemplateParams && TemplateParams->size()) {\n    auto *LastParam =\n        dyn_cast<TemplateTypeParmDecl>(TemplateParams->asArray().back());\n    if (LastParam && LastParam->isImplicit() &&\n        LastParam->hasTypeConstraint()) {\n      // In abbreviated templates, the type-constraints of invented template\n      // type parameters are instantiated with the function type, invalidating\n      // the TemplateParameterList which relied on the template type parameter\n      // not having a type constraint. Recreate the TemplateParameterList with\n      // the updated parameter list.\n      TemplateParams = TemplateParameterList::Create(\n          SemaRef.Context, TemplateParams->getTemplateLoc(),\n          TemplateParams->getLAngleLoc(), TemplateParams->asArray(),\n          TemplateParams->getRAngleLoc(), TemplateParams->getRequiresClause());\n    }\n  }\n\n  NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc();\n  if (QualifierLoc) {\n    QualifierLoc = SemaRef.SubstNestedNameSpecifierLoc(QualifierLoc,\n                                                       TemplateArgs);\n    if (!QualifierLoc)\n      return nullptr;\n  }\n\n  // FIXME: Concepts: Do not substitute into constraint expressions\n  Expr *TrailingRequiresClause = D->getTrailingRequiresClause();\n  if (TrailingRequiresClause) {\n    EnterExpressionEvaluationContext ConstantEvaluated(\n        SemaRef, Sema::ExpressionEvaluationContext::Unevaluated);\n    ExprResult SubstRC = SemaRef.SubstExpr(TrailingRequiresClause,\n                                           TemplateArgs);\n    if (SubstRC.isInvalid())\n      return nullptr;\n    TrailingRequiresClause = SubstRC.get();\n    if (!SemaRef.CheckConstraintExpression(TrailingRequiresClause))\n      return nullptr;\n  }\n\n  // If we're instantiating a local function declaration, put the result\n  // in the enclosing namespace; otherwise we need to find the instantiated\n  // context.\n  DeclContext *DC;\n  if (D->isLocalExternDecl()) {\n    DC = Owner;\n    SemaRef.adjustContextForLocalExternDecl(DC);\n  } else if (isFriend && QualifierLoc) {\n    CXXScopeSpec SS;\n    SS.Adopt(QualifierLoc);\n    DC = SemaRef.computeDeclContext(SS);\n    if (!DC) return nullptr;\n  } else {\n    DC = SemaRef.FindInstantiatedContext(D->getLocation(), D->getDeclContext(),\n                                         TemplateArgs);\n  }\n\n  DeclarationNameInfo NameInfo\n    = SemaRef.SubstDeclarationNameInfo(D->getNameInfo(), TemplateArgs);\n\n  if (FunctionRewriteKind != RewriteKind::None)\n    adjustForRewrite(FunctionRewriteKind, D, T, TInfo, NameInfo);\n\n  FunctionDecl *Function;\n  if (auto *DGuide = dyn_cast<CXXDeductionGuideDecl>(D)) {\n    Function = CXXDeductionGuideDecl::Create(\n        SemaRef.Context, DC, D->getInnerLocStart(),\n        InstantiatedExplicitSpecifier, NameInfo, T, TInfo,\n        D->getSourceRange().getEnd());\n    if (DGuide->isCopyDeductionCandidate())\n      cast<CXXDeductionGuideDecl>(Function)->setIsCopyDeductionCandidate();\n    Function->setAccess(D->getAccess());\n  } else {\n    Function = FunctionDecl::Create(\n        SemaRef.Context, DC, D->getInnerLocStart(), NameInfo, T, TInfo,\n        D->getCanonicalDecl()->getStorageClass(), D->isInlineSpecified(),\n        D->hasWrittenPrototype(), D->getConstexprKind(),\n        TrailingRequiresClause);\n    Function->setRangeEnd(D->getSourceRange().getEnd());\n  }\n\n  if (D->isInlined())\n    Function->setImplicitlyInline();\n\n  if (QualifierLoc)\n    Function->setQualifierInfo(QualifierLoc);\n\n  if (D->isLocalExternDecl())\n    Function->setLocalExternDecl();\n\n  DeclContext *LexicalDC = Owner;\n  if (!isFriend && D->isOutOfLine() && !D->isLocalExternDecl()) {\n    assert(D->getDeclContext()->isFileContext());\n    LexicalDC = D->getDeclContext();\n  }\n\n  Function->setLexicalDeclContext(LexicalDC);\n\n  // Attach the parameters\n  for (unsigned P = 0; P < Params.size(); ++P)\n    if (Params[P])\n      Params[P]->setOwningFunction(Function);\n  Function->setParams(Params);\n\n  if (TrailingRequiresClause)\n    Function->setTrailingRequiresClause(TrailingRequiresClause);\n\n  if (TemplateParams) {\n    // Our resulting instantiation is actually a function template, since we\n    // are substituting only the outer template parameters. For example, given\n    //\n    //   template<typename T>\n    //   struct X {\n    //     template<typename U> friend void f(T, U);\n    //   };\n    //\n    //   X<int> x;\n    //\n    // We are instantiating the friend function template \"f\" within X<int>,\n    // which means substituting int for T, but leaving \"f\" as a friend function\n    // template.\n    // Build the function template itself.\n    FunctionTemplate = FunctionTemplateDecl::Create(SemaRef.Context, DC,\n                                                    Function->getLocation(),\n                                                    Function->getDeclName(),\n                                                    TemplateParams, Function);\n    Function->setDescribedFunctionTemplate(FunctionTemplate);\n\n    FunctionTemplate->setLexicalDeclContext(LexicalDC);\n\n    if (isFriend && D->isThisDeclarationADefinition()) {\n      FunctionTemplate->setInstantiatedFromMemberTemplate(\n                                           D->getDescribedFunctionTemplate());\n    }\n  } else if (FunctionTemplate) {\n    // Record this function template specialization.\n    ArrayRef<TemplateArgument> Innermost = TemplateArgs.getInnermost();\n    Function->setFunctionTemplateSpecialization(FunctionTemplate,\n                            TemplateArgumentList::CreateCopy(SemaRef.Context,\n                                                             Innermost),\n                                                /*InsertPos=*/nullptr);\n  } else if (isFriend && D->isThisDeclarationADefinition()) {\n    // Do not connect the friend to the template unless it's actually a\n    // definition. We don't want non-template functions to be marked as being\n    // template instantiations.\n    Function->setInstantiationOfMemberFunction(D, TSK_ImplicitInstantiation);\n  }\n\n  if (isFriend) {\n    Function->setObjectOfFriendDecl();\n    if (FunctionTemplateDecl *FT = Function->getDescribedFunctionTemplate())\n      FT->setObjectOfFriendDecl();\n  }\n\n  if (InitFunctionInstantiation(Function, D))\n    Function->setInvalidDecl();\n\n  bool IsExplicitSpecialization = false;\n\n  LookupResult Previous(\n      SemaRef, Function->getDeclName(), SourceLocation(),\n      D->isLocalExternDecl() ? Sema::LookupRedeclarationWithLinkage\n                             : Sema::LookupOrdinaryName,\n      D->isLocalExternDecl() ? Sema::ForExternalRedeclaration\n                             : SemaRef.forRedeclarationInCurContext());\n\n  if (DependentFunctionTemplateSpecializationInfo *Info\n        = D->getDependentSpecializationInfo()) {\n    assert(isFriend && \"non-friend has dependent specialization info?\");\n\n    // Instantiate the explicit template arguments.\n    TemplateArgumentListInfo ExplicitArgs(Info->getLAngleLoc(),\n                                          Info->getRAngleLoc());\n    if (SemaRef.Subst(Info->getTemplateArgs(), Info->getNumTemplateArgs(),\n                      ExplicitArgs, TemplateArgs))\n      return nullptr;\n\n    // Map the candidate templates to their instantiations.\n    for (unsigned I = 0, E = Info->getNumTemplates(); I != E; ++I) {\n      Decl *Temp = SemaRef.FindInstantiatedDecl(D->getLocation(),\n                                                Info->getTemplate(I),\n                                                TemplateArgs);\n      if (!Temp) return nullptr;\n\n      Previous.addDecl(cast<FunctionTemplateDecl>(Temp));\n    }\n\n    if (SemaRef.CheckFunctionTemplateSpecialization(Function,\n                                                    &ExplicitArgs,\n                                                    Previous))\n      Function->setInvalidDecl();\n\n    IsExplicitSpecialization = true;\n  } else if (const ASTTemplateArgumentListInfo *Info =\n                 D->getTemplateSpecializationArgsAsWritten()) {\n    // The name of this function was written as a template-id.\n    SemaRef.LookupQualifiedName(Previous, DC);\n\n    // Instantiate the explicit template arguments.\n    TemplateArgumentListInfo ExplicitArgs(Info->getLAngleLoc(),\n                                          Info->getRAngleLoc());\n    if (SemaRef.Subst(Info->getTemplateArgs(), Info->getNumTemplateArgs(),\n                      ExplicitArgs, TemplateArgs))\n      return nullptr;\n\n    if (SemaRef.CheckFunctionTemplateSpecialization(Function,\n                                                    &ExplicitArgs,\n                                                    Previous))\n      Function->setInvalidDecl();\n\n    IsExplicitSpecialization = true;\n  } else if (TemplateParams || !FunctionTemplate) {\n    // Look only into the namespace where the friend would be declared to\n    // find a previous declaration. This is the innermost enclosing namespace,\n    // as described in ActOnFriendFunctionDecl.\n    SemaRef.LookupQualifiedName(Previous, DC->getRedeclContext());\n\n    // In C++, the previous declaration we find might be a tag type\n    // (class or enum). In this case, the new declaration will hide the\n    // tag type. Note that this does does not apply if we're declaring a\n    // typedef (C++ [dcl.typedef]p4).\n    if (Previous.isSingleTagDecl())\n      Previous.clear();\n\n    // Filter out previous declarations that don't match the scope. The only\n    // effect this has is to remove declarations found in inline namespaces\n    // for friend declarations with unqualified names.\n    SemaRef.FilterLookupForScope(Previous, DC, /*Scope*/ nullptr,\n                                 /*ConsiderLinkage*/ true,\n                                 QualifierLoc.hasQualifier());\n  }\n\n  SemaRef.CheckFunctionDeclaration(/*Scope*/ nullptr, Function, Previous,\n                                   IsExplicitSpecialization);\n\n  // Check the template parameter list against the previous declaration. The\n  // goal here is to pick up default arguments added since the friend was\n  // declared; we know the template parameter lists match, since otherwise\n  // we would not have picked this template as the previous declaration.\n  if (isFriend && TemplateParams && FunctionTemplate->getPreviousDecl()) {\n    SemaRef.CheckTemplateParameterList(\n        TemplateParams,\n        FunctionTemplate->getPreviousDecl()->getTemplateParameters(),\n        Function->isThisDeclarationADefinition()\n            ? Sema::TPC_FriendFunctionTemplateDefinition\n            : Sema::TPC_FriendFunctionTemplate);\n  }\n\n  // If we're introducing a friend definition after the first use, trigger\n  // instantiation.\n  // FIXME: If this is a friend function template definition, we should check\n  // to see if any specializations have been used.\n  if (isFriend && D->isThisDeclarationADefinition() && Function->isUsed(false)) {\n    if (MemberSpecializationInfo *MSInfo =\n            Function->getMemberSpecializationInfo()) {\n      if (MSInfo->getPointOfInstantiation().isInvalid()) {\n        SourceLocation Loc = D->getLocation(); // FIXME\n        MSInfo->setPointOfInstantiation(Loc);\n        SemaRef.PendingLocalImplicitInstantiations.push_back(\n            std::make_pair(Function, Loc));\n      }\n    }\n  }\n\n  if (D->isExplicitlyDefaulted()) {\n    if (SubstDefaultedFunction(Function, D))\n      return nullptr;\n  }\n  if (D->isDeleted())\n    SemaRef.SetDeclDeleted(Function, D->getLocation());\n\n  NamedDecl *PrincipalDecl =\n      (TemplateParams ? cast<NamedDecl>(FunctionTemplate) : Function);\n\n  // If this declaration lives in a different context from its lexical context,\n  // add it to the corresponding lookup table.\n  if (isFriend ||\n      (Function->isLocalExternDecl() && !Function->getPreviousDecl()))\n    DC->makeDeclVisibleInContext(PrincipalDecl);\n\n  if (Function->isOverloadedOperator() && !DC->isRecord() &&\n      PrincipalDecl->isInIdentifierNamespace(Decl::IDNS_Ordinary))\n    PrincipalDecl->setNonMemberOperator();\n\n  return Function;\n}\n\nDecl *TemplateDeclInstantiator::VisitCXXMethodDecl(\n    CXXMethodDecl *D, TemplateParameterList *TemplateParams,\n    Optional<const ASTTemplateArgumentListInfo *> ClassScopeSpecializationArgs,\n    RewriteKind FunctionRewriteKind) {\n  FunctionTemplateDecl *FunctionTemplate = D->getDescribedFunctionTemplate();\n  if (FunctionTemplate && !TemplateParams) {\n    // We are creating a function template specialization from a function\n    // template. Check whether there is already a function template\n    // specialization for this particular set of template arguments.\n    ArrayRef<TemplateArgument> Innermost = TemplateArgs.getInnermost();\n\n    void *InsertPos = nullptr;\n    FunctionDecl *SpecFunc\n      = FunctionTemplate->findSpecialization(Innermost, InsertPos);\n\n    // If we already have a function template specialization, return it.\n    if (SpecFunc)\n      return SpecFunc;\n  }\n\n  bool isFriend;\n  if (FunctionTemplate)\n    isFriend = (FunctionTemplate->getFriendObjectKind() != Decl::FOK_None);\n  else\n    isFriend = (D->getFriendObjectKind() != Decl::FOK_None);\n\n  bool MergeWithParentScope = (TemplateParams != nullptr) ||\n    !(isa<Decl>(Owner) &&\n      cast<Decl>(Owner)->isDefinedOutsideFunctionOrMethod());\n  LocalInstantiationScope Scope(SemaRef, MergeWithParentScope);\n\n  // Instantiate enclosing template arguments for friends.\n  SmallVector<TemplateParameterList *, 4> TempParamLists;\n  unsigned NumTempParamLists = 0;\n  if (isFriend && (NumTempParamLists = D->getNumTemplateParameterLists())) {\n    TempParamLists.resize(NumTempParamLists);\n    for (unsigned I = 0; I != NumTempParamLists; ++I) {\n      TemplateParameterList *TempParams = D->getTemplateParameterList(I);\n      TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n      if (!InstParams)\n        return nullptr;\n      TempParamLists[I] = InstParams;\n    }\n  }\n\n  ExplicitSpecifier InstantiatedExplicitSpecifier =\n      instantiateExplicitSpecifier(SemaRef, TemplateArgs,\n                                   ExplicitSpecifier::getFromDecl(D), D);\n  if (InstantiatedExplicitSpecifier.isInvalid())\n    return nullptr;\n\n  SmallVector<ParmVarDecl *, 4> Params;\n  TypeSourceInfo *TInfo = SubstFunctionType(D, Params);\n  if (!TInfo)\n    return nullptr;\n  QualType T = adjustFunctionTypeForInstantiation(SemaRef.Context, D, TInfo);\n\n  if (TemplateParams && TemplateParams->size()) {\n    auto *LastParam =\n        dyn_cast<TemplateTypeParmDecl>(TemplateParams->asArray().back());\n    if (LastParam && LastParam->isImplicit() &&\n        LastParam->hasTypeConstraint()) {\n      // In abbreviated templates, the type-constraints of invented template\n      // type parameters are instantiated with the function type, invalidating\n      // the TemplateParameterList which relied on the template type parameter\n      // not having a type constraint. Recreate the TemplateParameterList with\n      // the updated parameter list.\n      TemplateParams = TemplateParameterList::Create(\n          SemaRef.Context, TemplateParams->getTemplateLoc(),\n          TemplateParams->getLAngleLoc(), TemplateParams->asArray(),\n          TemplateParams->getRAngleLoc(), TemplateParams->getRequiresClause());\n    }\n  }\n\n  NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc();\n  if (QualifierLoc) {\n    QualifierLoc = SemaRef.SubstNestedNameSpecifierLoc(QualifierLoc,\n                                                 TemplateArgs);\n    if (!QualifierLoc)\n      return nullptr;\n  }\n\n  // FIXME: Concepts: Do not substitute into constraint expressions\n  Expr *TrailingRequiresClause = D->getTrailingRequiresClause();\n  if (TrailingRequiresClause) {\n    EnterExpressionEvaluationContext ConstantEvaluated(\n        SemaRef, Sema::ExpressionEvaluationContext::Unevaluated);\n    auto *ThisContext = dyn_cast_or_null<CXXRecordDecl>(Owner);\n    Sema::CXXThisScopeRAII ThisScope(SemaRef, ThisContext,\n                                     D->getMethodQualifiers(), ThisContext);\n    ExprResult SubstRC = SemaRef.SubstExpr(TrailingRequiresClause,\n                                           TemplateArgs);\n    if (SubstRC.isInvalid())\n      return nullptr;\n    TrailingRequiresClause = SubstRC.get();\n    if (!SemaRef.CheckConstraintExpression(TrailingRequiresClause))\n      return nullptr;\n  }\n\n  DeclContext *DC = Owner;\n  if (isFriend) {\n    if (QualifierLoc) {\n      CXXScopeSpec SS;\n      SS.Adopt(QualifierLoc);\n      DC = SemaRef.computeDeclContext(SS);\n\n      if (DC && SemaRef.RequireCompleteDeclContext(SS, DC))\n        return nullptr;\n    } else {\n      DC = SemaRef.FindInstantiatedContext(D->getLocation(),\n                                           D->getDeclContext(),\n                                           TemplateArgs);\n    }\n    if (!DC) return nullptr;\n  }\n\n  DeclarationNameInfo NameInfo\n    = SemaRef.SubstDeclarationNameInfo(D->getNameInfo(), TemplateArgs);\n\n  if (FunctionRewriteKind != RewriteKind::None)\n    adjustForRewrite(FunctionRewriteKind, D, T, TInfo, NameInfo);\n\n  // Build the instantiated method declaration.\n  CXXRecordDecl *Record = cast<CXXRecordDecl>(DC);\n  CXXMethodDecl *Method = nullptr;\n\n  SourceLocation StartLoc = D->getInnerLocStart();\n  if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(D)) {\n    Method = CXXConstructorDecl::Create(\n        SemaRef.Context, Record, StartLoc, NameInfo, T, TInfo,\n        InstantiatedExplicitSpecifier, Constructor->isInlineSpecified(), false,\n        Constructor->getConstexprKind(), InheritedConstructor(),\n        TrailingRequiresClause);\n    Method->setRangeEnd(Constructor->getEndLoc());\n  } else if (CXXDestructorDecl *Destructor = dyn_cast<CXXDestructorDecl>(D)) {\n    Method = CXXDestructorDecl::Create(\n        SemaRef.Context, Record, StartLoc, NameInfo, T, TInfo,\n        Destructor->isInlineSpecified(), false, Destructor->getConstexprKind(),\n        TrailingRequiresClause);\n    Method->setRangeEnd(Destructor->getEndLoc());\n  } else if (CXXConversionDecl *Conversion = dyn_cast<CXXConversionDecl>(D)) {\n    Method = CXXConversionDecl::Create(\n        SemaRef.Context, Record, StartLoc, NameInfo, T, TInfo,\n        Conversion->isInlineSpecified(), InstantiatedExplicitSpecifier,\n        Conversion->getConstexprKind(), Conversion->getEndLoc(),\n        TrailingRequiresClause);\n  } else {\n    StorageClass SC = D->isStatic() ? SC_Static : SC_None;\n    Method = CXXMethodDecl::Create(SemaRef.Context, Record, StartLoc, NameInfo,\n                                   T, TInfo, SC, D->isInlineSpecified(),\n                                   D->getConstexprKind(), D->getEndLoc(),\n                                   TrailingRequiresClause);\n  }\n\n  if (D->isInlined())\n    Method->setImplicitlyInline();\n\n  if (QualifierLoc)\n    Method->setQualifierInfo(QualifierLoc);\n\n  if (TemplateParams) {\n    // Our resulting instantiation is actually a function template, since we\n    // are substituting only the outer template parameters. For example, given\n    //\n    //   template<typename T>\n    //   struct X {\n    //     template<typename U> void f(T, U);\n    //   };\n    //\n    //   X<int> x;\n    //\n    // We are instantiating the member template \"f\" within X<int>, which means\n    // substituting int for T, but leaving \"f\" as a member function template.\n    // Build the function template itself.\n    FunctionTemplate = FunctionTemplateDecl::Create(SemaRef.Context, Record,\n                                                    Method->getLocation(),\n                                                    Method->getDeclName(),\n                                                    TemplateParams, Method);\n    if (isFriend) {\n      FunctionTemplate->setLexicalDeclContext(Owner);\n      FunctionTemplate->setObjectOfFriendDecl();\n    } else if (D->isOutOfLine())\n      FunctionTemplate->setLexicalDeclContext(D->getLexicalDeclContext());\n    Method->setDescribedFunctionTemplate(FunctionTemplate);\n  } else if (FunctionTemplate) {\n    // Record this function template specialization.\n    ArrayRef<TemplateArgument> Innermost = TemplateArgs.getInnermost();\n    Method->setFunctionTemplateSpecialization(FunctionTemplate,\n                         TemplateArgumentList::CreateCopy(SemaRef.Context,\n                                                          Innermost),\n                                              /*InsertPos=*/nullptr);\n  } else if (!isFriend) {\n    // Record that this is an instantiation of a member function.\n    Method->setInstantiationOfMemberFunction(D, TSK_ImplicitInstantiation);\n  }\n\n  // If we are instantiating a member function defined\n  // out-of-line, the instantiation will have the same lexical\n  // context (which will be a namespace scope) as the template.\n  if (isFriend) {\n    if (NumTempParamLists)\n      Method->setTemplateParameterListsInfo(\n          SemaRef.Context,\n          llvm::makeArrayRef(TempParamLists.data(), NumTempParamLists));\n\n    Method->setLexicalDeclContext(Owner);\n    Method->setObjectOfFriendDecl();\n  } else if (D->isOutOfLine())\n    Method->setLexicalDeclContext(D->getLexicalDeclContext());\n\n  // Attach the parameters\n  for (unsigned P = 0; P < Params.size(); ++P)\n    Params[P]->setOwningFunction(Method);\n  Method->setParams(Params);\n\n  if (InitMethodInstantiation(Method, D))\n    Method->setInvalidDecl();\n\n  LookupResult Previous(SemaRef, NameInfo, Sema::LookupOrdinaryName,\n                        Sema::ForExternalRedeclaration);\n\n  bool IsExplicitSpecialization = false;\n\n  // If the name of this function was written as a template-id, instantiate\n  // the explicit template arguments.\n  if (DependentFunctionTemplateSpecializationInfo *Info\n        = D->getDependentSpecializationInfo()) {\n    assert(isFriend && \"non-friend has dependent specialization info?\");\n\n    // Instantiate the explicit template arguments.\n    TemplateArgumentListInfo ExplicitArgs(Info->getLAngleLoc(),\n                                          Info->getRAngleLoc());\n    if (SemaRef.Subst(Info->getTemplateArgs(), Info->getNumTemplateArgs(),\n                      ExplicitArgs, TemplateArgs))\n      return nullptr;\n\n    // Map the candidate templates to their instantiations.\n    for (unsigned I = 0, E = Info->getNumTemplates(); I != E; ++I) {\n      Decl *Temp = SemaRef.FindInstantiatedDecl(D->getLocation(),\n                                                Info->getTemplate(I),\n                                                TemplateArgs);\n      if (!Temp) return nullptr;\n\n      Previous.addDecl(cast<FunctionTemplateDecl>(Temp));\n    }\n\n    if (SemaRef.CheckFunctionTemplateSpecialization(Method,\n                                                    &ExplicitArgs,\n                                                    Previous))\n      Method->setInvalidDecl();\n\n    IsExplicitSpecialization = true;\n  } else if (const ASTTemplateArgumentListInfo *Info =\n                 ClassScopeSpecializationArgs.getValueOr(\n                     D->getTemplateSpecializationArgsAsWritten())) {\n    SemaRef.LookupQualifiedName(Previous, DC);\n\n    TemplateArgumentListInfo ExplicitArgs(Info->getLAngleLoc(),\n                                          Info->getRAngleLoc());\n    if (SemaRef.Subst(Info->getTemplateArgs(), Info->getNumTemplateArgs(),\n                      ExplicitArgs, TemplateArgs))\n      return nullptr;\n\n    if (SemaRef.CheckFunctionTemplateSpecialization(Method,\n                                                    &ExplicitArgs,\n                                                    Previous))\n      Method->setInvalidDecl();\n\n    IsExplicitSpecialization = true;\n  } else if (ClassScopeSpecializationArgs) {\n    // Class-scope explicit specialization written without explicit template\n    // arguments.\n    SemaRef.LookupQualifiedName(Previous, DC);\n    if (SemaRef.CheckFunctionTemplateSpecialization(Method, nullptr, Previous))\n      Method->setInvalidDecl();\n\n    IsExplicitSpecialization = true;\n  } else if (!FunctionTemplate || TemplateParams || isFriend) {\n    SemaRef.LookupQualifiedName(Previous, Record);\n\n    // In C++, the previous declaration we find might be a tag type\n    // (class or enum). In this case, the new declaration will hide the\n    // tag type. Note that this does does not apply if we're declaring a\n    // typedef (C++ [dcl.typedef]p4).\n    if (Previous.isSingleTagDecl())\n      Previous.clear();\n  }\n\n  SemaRef.CheckFunctionDeclaration(nullptr, Method, Previous,\n                                   IsExplicitSpecialization);\n\n  if (D->isPure())\n    SemaRef.CheckPureMethod(Method, SourceRange());\n\n  // Propagate access.  For a non-friend declaration, the access is\n  // whatever we're propagating from.  For a friend, it should be the\n  // previous declaration we just found.\n  if (isFriend && Method->getPreviousDecl())\n    Method->setAccess(Method->getPreviousDecl()->getAccess());\n  else\n    Method->setAccess(D->getAccess());\n  if (FunctionTemplate)\n    FunctionTemplate->setAccess(Method->getAccess());\n\n  SemaRef.CheckOverrideControl(Method);\n\n  // If a function is defined as defaulted or deleted, mark it as such now.\n  if (D->isExplicitlyDefaulted()) {\n    if (SubstDefaultedFunction(Method, D))\n      return nullptr;\n  }\n  if (D->isDeletedAsWritten())\n    SemaRef.SetDeclDeleted(Method, Method->getLocation());\n\n  // If this is an explicit specialization, mark the implicitly-instantiated\n  // template specialization as being an explicit specialization too.\n  // FIXME: Is this necessary?\n  if (IsExplicitSpecialization && !isFriend)\n    SemaRef.CompleteMemberSpecialization(Method, Previous);\n\n  // If there's a function template, let our caller handle it.\n  if (FunctionTemplate) {\n    // do nothing\n\n  // Don't hide a (potentially) valid declaration with an invalid one.\n  } else if (Method->isInvalidDecl() && !Previous.empty()) {\n    // do nothing\n\n  // Otherwise, check access to friends and make them visible.\n  } else if (isFriend) {\n    // We only need to re-check access for methods which we didn't\n    // manage to match during parsing.\n    if (!D->getPreviousDecl())\n      SemaRef.CheckFriendAccess(Method);\n\n    Record->makeDeclVisibleInContext(Method);\n\n  // Otherwise, add the declaration.  We don't need to do this for\n  // class-scope specializations because we'll have matched them with\n  // the appropriate template.\n  } else {\n    Owner->addDecl(Method);\n  }\n\n  // PR17480: Honor the used attribute to instantiate member function\n  // definitions\n  if (Method->hasAttr<UsedAttr>()) {\n    if (const auto *A = dyn_cast<CXXRecordDecl>(Owner)) {\n      SourceLocation Loc;\n      if (const MemberSpecializationInfo *MSInfo =\n              A->getMemberSpecializationInfo())\n        Loc = MSInfo->getPointOfInstantiation();\n      else if (const auto *Spec = dyn_cast<ClassTemplateSpecializationDecl>(A))\n        Loc = Spec->getPointOfInstantiation();\n      SemaRef.MarkFunctionReferenced(Loc, Method);\n    }\n  }\n\n  return Method;\n}\n\nDecl *TemplateDeclInstantiator::VisitCXXConstructorDecl(CXXConstructorDecl *D) {\n  return VisitCXXMethodDecl(D);\n}\n\nDecl *TemplateDeclInstantiator::VisitCXXDestructorDecl(CXXDestructorDecl *D) {\n  return VisitCXXMethodDecl(D);\n}\n\nDecl *TemplateDeclInstantiator::VisitCXXConversionDecl(CXXConversionDecl *D) {\n  return VisitCXXMethodDecl(D);\n}\n\nDecl *TemplateDeclInstantiator::VisitParmVarDecl(ParmVarDecl *D) {\n  return SemaRef.SubstParmVarDecl(D, TemplateArgs, /*indexAdjustment*/ 0, None,\n                                  /*ExpectParameterPack=*/ false);\n}\n\nDecl *TemplateDeclInstantiator::VisitTemplateTypeParmDecl(\n                                                    TemplateTypeParmDecl *D) {\n  // TODO: don't always clone when decls are refcounted.\n  assert(D->getTypeForDecl()->isTemplateTypeParmType());\n\n  Optional<unsigned> NumExpanded;\n\n  if (const TypeConstraint *TC = D->getTypeConstraint()) {\n    if (D->isPackExpansion() && !D->isExpandedParameterPack()) {\n      assert(TC->getTemplateArgsAsWritten() &&\n             \"type parameter can only be an expansion when explicit arguments \"\n             \"are specified\");\n      // The template type parameter pack's type is a pack expansion of types.\n      // Determine whether we need to expand this parameter pack into separate\n      // types.\n      SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n      for (auto &ArgLoc : TC->getTemplateArgsAsWritten()->arguments())\n        SemaRef.collectUnexpandedParameterPacks(ArgLoc, Unexpanded);\n\n      // Determine whether the set of unexpanded parameter packs can and should\n      // be expanded.\n      bool Expand = true;\n      bool RetainExpansion = false;\n      if (SemaRef.CheckParameterPacksForExpansion(\n              cast<CXXFoldExpr>(TC->getImmediatelyDeclaredConstraint())\n                  ->getEllipsisLoc(),\n              SourceRange(TC->getConceptNameLoc(),\n                          TC->hasExplicitTemplateArgs() ?\n                          TC->getTemplateArgsAsWritten()->getRAngleLoc() :\n                          TC->getConceptNameInfo().getEndLoc()),\n              Unexpanded, TemplateArgs, Expand, RetainExpansion, NumExpanded))\n        return nullptr;\n    }\n  }\n\n  TemplateTypeParmDecl *Inst = TemplateTypeParmDecl::Create(\n      SemaRef.Context, Owner, D->getBeginLoc(), D->getLocation(),\n      D->getDepth() - TemplateArgs.getNumSubstitutedLevels(), D->getIndex(),\n      D->getIdentifier(), D->wasDeclaredWithTypename(), D->isParameterPack(),\n      D->hasTypeConstraint(), NumExpanded);\n\n  Inst->setAccess(AS_public);\n  Inst->setImplicit(D->isImplicit());\n  if (auto *TC = D->getTypeConstraint()) {\n    if (!D->isImplicit()) {\n      // Invented template parameter type constraints will be instantiated with\n      // the corresponding auto-typed parameter as it might reference other\n      // parameters.\n\n      // TODO: Concepts: do not instantiate the constraint (delayed constraint\n      // substitution)\n      const ASTTemplateArgumentListInfo *TemplArgInfo\n        = TC->getTemplateArgsAsWritten();\n      TemplateArgumentListInfo InstArgs;\n\n      if (TemplArgInfo) {\n        InstArgs.setLAngleLoc(TemplArgInfo->LAngleLoc);\n        InstArgs.setRAngleLoc(TemplArgInfo->RAngleLoc);\n        if (SemaRef.Subst(TemplArgInfo->getTemplateArgs(),\n                          TemplArgInfo->NumTemplateArgs,\n                          InstArgs, TemplateArgs))\n          return nullptr;\n      }\n      if (SemaRef.AttachTypeConstraint(\n              TC->getNestedNameSpecifierLoc(), TC->getConceptNameInfo(),\n              TC->getNamedConcept(), &InstArgs, Inst,\n              D->isParameterPack()\n                  ? cast<CXXFoldExpr>(TC->getImmediatelyDeclaredConstraint())\n                      ->getEllipsisLoc()\n                  : SourceLocation()))\n        return nullptr;\n    }\n  }\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited()) {\n    TypeSourceInfo *InstantiatedDefaultArg =\n        SemaRef.SubstType(D->getDefaultArgumentInfo(), TemplateArgs,\n                          D->getDefaultArgumentLoc(), D->getDeclName());\n    if (InstantiatedDefaultArg)\n      Inst->setDefaultArgument(InstantiatedDefaultArg);\n  }\n\n  // Introduce this template parameter's instantiation into the instantiation\n  // scope.\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, Inst);\n\n  return Inst;\n}\n\nDecl *TemplateDeclInstantiator::VisitNonTypeTemplateParmDecl(\n                                                 NonTypeTemplateParmDecl *D) {\n  // Substitute into the type of the non-type template parameter.\n  TypeLoc TL = D->getTypeSourceInfo()->getTypeLoc();\n  SmallVector<TypeSourceInfo *, 4> ExpandedParameterPackTypesAsWritten;\n  SmallVector<QualType, 4> ExpandedParameterPackTypes;\n  bool IsExpandedParameterPack = false;\n  TypeSourceInfo *DI;\n  QualType T;\n  bool Invalid = false;\n\n  if (D->isExpandedParameterPack()) {\n    // The non-type template parameter pack is an already-expanded pack\n    // expansion of types. Substitute into each of the expanded types.\n    ExpandedParameterPackTypes.reserve(D->getNumExpansionTypes());\n    ExpandedParameterPackTypesAsWritten.reserve(D->getNumExpansionTypes());\n    for (unsigned I = 0, N = D->getNumExpansionTypes(); I != N; ++I) {\n      TypeSourceInfo *NewDI =\n          SemaRef.SubstType(D->getExpansionTypeSourceInfo(I), TemplateArgs,\n                            D->getLocation(), D->getDeclName());\n      if (!NewDI)\n        return nullptr;\n\n      QualType NewT =\n          SemaRef.CheckNonTypeTemplateParameterType(NewDI, D->getLocation());\n      if (NewT.isNull())\n        return nullptr;\n\n      ExpandedParameterPackTypesAsWritten.push_back(NewDI);\n      ExpandedParameterPackTypes.push_back(NewT);\n    }\n\n    IsExpandedParameterPack = true;\n    DI = D->getTypeSourceInfo();\n    T = DI->getType();\n  } else if (D->isPackExpansion()) {\n    // The non-type template parameter pack's type is a pack expansion of types.\n    // Determine whether we need to expand this parameter pack into separate\n    // types.\n    PackExpansionTypeLoc Expansion = TL.castAs<PackExpansionTypeLoc>();\n    TypeLoc Pattern = Expansion.getPatternLoc();\n    SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n    SemaRef.collectUnexpandedParameterPacks(Pattern, Unexpanded);\n\n    // Determine whether the set of unexpanded parameter packs can and should\n    // be expanded.\n    bool Expand = true;\n    bool RetainExpansion = false;\n    Optional<unsigned> OrigNumExpansions\n      = Expansion.getTypePtr()->getNumExpansions();\n    Optional<unsigned> NumExpansions = OrigNumExpansions;\n    if (SemaRef.CheckParameterPacksForExpansion(Expansion.getEllipsisLoc(),\n                                                Pattern.getSourceRange(),\n                                                Unexpanded,\n                                                TemplateArgs,\n                                                Expand, RetainExpansion,\n                                                NumExpansions))\n      return nullptr;\n\n    if (Expand) {\n      for (unsigned I = 0; I != *NumExpansions; ++I) {\n        Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, I);\n        TypeSourceInfo *NewDI = SemaRef.SubstType(Pattern, TemplateArgs,\n                                                  D->getLocation(),\n                                                  D->getDeclName());\n        if (!NewDI)\n          return nullptr;\n\n        QualType NewT =\n            SemaRef.CheckNonTypeTemplateParameterType(NewDI, D->getLocation());\n        if (NewT.isNull())\n          return nullptr;\n\n        ExpandedParameterPackTypesAsWritten.push_back(NewDI);\n        ExpandedParameterPackTypes.push_back(NewT);\n      }\n\n      // Note that we have an expanded parameter pack. The \"type\" of this\n      // expanded parameter pack is the original expansion type, but callers\n      // will end up using the expanded parameter pack types for type-checking.\n      IsExpandedParameterPack = true;\n      DI = D->getTypeSourceInfo();\n      T = DI->getType();\n    } else {\n      // We cannot fully expand the pack expansion now, so substitute into the\n      // pattern and create a new pack expansion type.\n      Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, -1);\n      TypeSourceInfo *NewPattern = SemaRef.SubstType(Pattern, TemplateArgs,\n                                                     D->getLocation(),\n                                                     D->getDeclName());\n      if (!NewPattern)\n        return nullptr;\n\n      SemaRef.CheckNonTypeTemplateParameterType(NewPattern, D->getLocation());\n      DI = SemaRef.CheckPackExpansion(NewPattern, Expansion.getEllipsisLoc(),\n                                      NumExpansions);\n      if (!DI)\n        return nullptr;\n\n      T = DI->getType();\n    }\n  } else {\n    // Simple case: substitution into a parameter that is not a parameter pack.\n    DI = SemaRef.SubstType(D->getTypeSourceInfo(), TemplateArgs,\n                           D->getLocation(), D->getDeclName());\n    if (!DI)\n      return nullptr;\n\n    // Check that this type is acceptable for a non-type template parameter.\n    T = SemaRef.CheckNonTypeTemplateParameterType(DI, D->getLocation());\n    if (T.isNull()) {\n      T = SemaRef.Context.IntTy;\n      Invalid = true;\n    }\n  }\n\n  NonTypeTemplateParmDecl *Param;\n  if (IsExpandedParameterPack)\n    Param = NonTypeTemplateParmDecl::Create(\n        SemaRef.Context, Owner, D->getInnerLocStart(), D->getLocation(),\n        D->getDepth() - TemplateArgs.getNumSubstitutedLevels(),\n        D->getPosition(), D->getIdentifier(), T, DI, ExpandedParameterPackTypes,\n        ExpandedParameterPackTypesAsWritten);\n  else\n    Param = NonTypeTemplateParmDecl::Create(\n        SemaRef.Context, Owner, D->getInnerLocStart(), D->getLocation(),\n        D->getDepth() - TemplateArgs.getNumSubstitutedLevels(),\n        D->getPosition(), D->getIdentifier(), T, D->isParameterPack(), DI);\n\n  if (AutoTypeLoc AutoLoc = DI->getTypeLoc().getContainedAutoTypeLoc())\n    if (AutoLoc.isConstrained())\n      if (SemaRef.AttachTypeConstraint(\n              AutoLoc, Param,\n              IsExpandedParameterPack\n                ? DI->getTypeLoc().getAs<PackExpansionTypeLoc>()\n                    .getEllipsisLoc()\n                : SourceLocation()))\n        Invalid = true;\n\n  Param->setAccess(AS_public);\n  Param->setImplicit(D->isImplicit());\n  if (Invalid)\n    Param->setInvalidDecl();\n\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited()) {\n    EnterExpressionEvaluationContext ConstantEvaluated(\n        SemaRef, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n    ExprResult Value = SemaRef.SubstExpr(D->getDefaultArgument(), TemplateArgs);\n    if (!Value.isInvalid())\n      Param->setDefaultArgument(Value.get());\n  }\n\n  // Introduce this template parameter's instantiation into the instantiation\n  // scope.\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, Param);\n  return Param;\n}\n\nstatic void collectUnexpandedParameterPacks(\n    Sema &S,\n    TemplateParameterList *Params,\n    SmallVectorImpl<UnexpandedParameterPack> &Unexpanded) {\n  for (const auto &P : *Params) {\n    if (P->isTemplateParameterPack())\n      continue;\n    if (NonTypeTemplateParmDecl *NTTP = dyn_cast<NonTypeTemplateParmDecl>(P))\n      S.collectUnexpandedParameterPacks(NTTP->getTypeSourceInfo()->getTypeLoc(),\n                                        Unexpanded);\n    if (TemplateTemplateParmDecl *TTP = dyn_cast<TemplateTemplateParmDecl>(P))\n      collectUnexpandedParameterPacks(S, TTP->getTemplateParameters(),\n                                      Unexpanded);\n  }\n}\n\nDecl *\nTemplateDeclInstantiator::VisitTemplateTemplateParmDecl(\n                                                  TemplateTemplateParmDecl *D) {\n  // Instantiate the template parameter list of the template template parameter.\n  TemplateParameterList *TempParams = D->getTemplateParameters();\n  TemplateParameterList *InstParams;\n  SmallVector<TemplateParameterList*, 8> ExpandedParams;\n\n  bool IsExpandedParameterPack = false;\n\n  if (D->isExpandedParameterPack()) {\n    // The template template parameter pack is an already-expanded pack\n    // expansion of template parameters. Substitute into each of the expanded\n    // parameters.\n    ExpandedParams.reserve(D->getNumExpansionTemplateParameters());\n    for (unsigned I = 0, N = D->getNumExpansionTemplateParameters();\n         I != N; ++I) {\n      LocalInstantiationScope Scope(SemaRef);\n      TemplateParameterList *Expansion =\n        SubstTemplateParams(D->getExpansionTemplateParameters(I));\n      if (!Expansion)\n        return nullptr;\n      ExpandedParams.push_back(Expansion);\n    }\n\n    IsExpandedParameterPack = true;\n    InstParams = TempParams;\n  } else if (D->isPackExpansion()) {\n    // The template template parameter pack expands to a pack of template\n    // template parameters. Determine whether we need to expand this parameter\n    // pack into separate parameters.\n    SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n    collectUnexpandedParameterPacks(SemaRef, D->getTemplateParameters(),\n                                    Unexpanded);\n\n    // Determine whether the set of unexpanded parameter packs can and should\n    // be expanded.\n    bool Expand = true;\n    bool RetainExpansion = false;\n    Optional<unsigned> NumExpansions;\n    if (SemaRef.CheckParameterPacksForExpansion(D->getLocation(),\n                                                TempParams->getSourceRange(),\n                                                Unexpanded,\n                                                TemplateArgs,\n                                                Expand, RetainExpansion,\n                                                NumExpansions))\n      return nullptr;\n\n    if (Expand) {\n      for (unsigned I = 0; I != *NumExpansions; ++I) {\n        Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, I);\n        LocalInstantiationScope Scope(SemaRef);\n        TemplateParameterList *Expansion = SubstTemplateParams(TempParams);\n        if (!Expansion)\n          return nullptr;\n        ExpandedParams.push_back(Expansion);\n      }\n\n      // Note that we have an expanded parameter pack. The \"type\" of this\n      // expanded parameter pack is the original expansion type, but callers\n      // will end up using the expanded parameter pack types for type-checking.\n      IsExpandedParameterPack = true;\n      InstParams = TempParams;\n    } else {\n      // We cannot fully expand the pack expansion now, so just substitute\n      // into the pattern.\n      Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, -1);\n\n      LocalInstantiationScope Scope(SemaRef);\n      InstParams = SubstTemplateParams(TempParams);\n      if (!InstParams)\n        return nullptr;\n    }\n  } else {\n    // Perform the actual substitution of template parameters within a new,\n    // local instantiation scope.\n    LocalInstantiationScope Scope(SemaRef);\n    InstParams = SubstTemplateParams(TempParams);\n    if (!InstParams)\n      return nullptr;\n  }\n\n  // Build the template template parameter.\n  TemplateTemplateParmDecl *Param;\n  if (IsExpandedParameterPack)\n    Param = TemplateTemplateParmDecl::Create(\n        SemaRef.Context, Owner, D->getLocation(),\n        D->getDepth() - TemplateArgs.getNumSubstitutedLevels(),\n        D->getPosition(), D->getIdentifier(), InstParams, ExpandedParams);\n  else\n    Param = TemplateTemplateParmDecl::Create(\n        SemaRef.Context, Owner, D->getLocation(),\n        D->getDepth() - TemplateArgs.getNumSubstitutedLevels(),\n        D->getPosition(), D->isParameterPack(), D->getIdentifier(), InstParams);\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited()) {\n    NestedNameSpecifierLoc QualifierLoc =\n        D->getDefaultArgument().getTemplateQualifierLoc();\n    QualifierLoc =\n        SemaRef.SubstNestedNameSpecifierLoc(QualifierLoc, TemplateArgs);\n    TemplateName TName = SemaRef.SubstTemplateName(\n        QualifierLoc, D->getDefaultArgument().getArgument().getAsTemplate(),\n        D->getDefaultArgument().getTemplateNameLoc(), TemplateArgs);\n    if (!TName.isNull())\n      Param->setDefaultArgument(\n          SemaRef.Context,\n          TemplateArgumentLoc(SemaRef.Context, TemplateArgument(TName),\n                              D->getDefaultArgument().getTemplateQualifierLoc(),\n                              D->getDefaultArgument().getTemplateNameLoc()));\n  }\n  Param->setAccess(AS_public);\n  Param->setImplicit(D->isImplicit());\n\n  // Introduce this template parameter's instantiation into the instantiation\n  // scope.\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, Param);\n\n  return Param;\n}\n\nDecl *TemplateDeclInstantiator::VisitUsingDirectiveDecl(UsingDirectiveDecl *D) {\n  // Using directives are never dependent (and never contain any types or\n  // expressions), so they require no explicit instantiation work.\n\n  UsingDirectiveDecl *Inst\n    = UsingDirectiveDecl::Create(SemaRef.Context, Owner, D->getLocation(),\n                                 D->getNamespaceKeyLocation(),\n                                 D->getQualifierLoc(),\n                                 D->getIdentLocation(),\n                                 D->getNominatedNamespace(),\n                                 D->getCommonAncestor());\n\n  // Add the using directive to its declaration context\n  // only if this is not a function or method.\n  if (!Owner->isFunctionOrMethod())\n    Owner->addDecl(Inst);\n\n  return Inst;\n}\n\nDecl *TemplateDeclInstantiator::VisitUsingDecl(UsingDecl *D) {\n\n  // The nested name specifier may be dependent, for example\n  //     template <typename T> struct t {\n  //       struct s1 { T f1(); };\n  //       struct s2 : s1 { using s1::f1; };\n  //     };\n  //     template struct t<int>;\n  // Here, in using s1::f1, s1 refers to t<T>::s1;\n  // we need to substitute for t<int>::s1.\n  NestedNameSpecifierLoc QualifierLoc\n    = SemaRef.SubstNestedNameSpecifierLoc(D->getQualifierLoc(),\n                                          TemplateArgs);\n  if (!QualifierLoc)\n    return nullptr;\n\n  // For an inheriting constructor declaration, the name of the using\n  // declaration is the name of a constructor in this class, not in the\n  // base class.\n  DeclarationNameInfo NameInfo = D->getNameInfo();\n  if (NameInfo.getName().getNameKind() == DeclarationName::CXXConstructorName)\n    if (auto *RD = dyn_cast<CXXRecordDecl>(SemaRef.CurContext))\n      NameInfo.setName(SemaRef.Context.DeclarationNames.getCXXConstructorName(\n          SemaRef.Context.getCanonicalType(SemaRef.Context.getRecordType(RD))));\n\n  // We only need to do redeclaration lookups if we're in a class\n  // scope (in fact, it's not really even possible in non-class\n  // scopes).\n  bool CheckRedeclaration = Owner->isRecord();\n\n  LookupResult Prev(SemaRef, NameInfo, Sema::LookupUsingDeclName,\n                    Sema::ForVisibleRedeclaration);\n\n  UsingDecl *NewUD = UsingDecl::Create(SemaRef.Context, Owner,\n                                       D->getUsingLoc(),\n                                       QualifierLoc,\n                                       NameInfo,\n                                       D->hasTypename());\n\n  CXXScopeSpec SS;\n  SS.Adopt(QualifierLoc);\n  if (CheckRedeclaration) {\n    Prev.setHideTags(false);\n    SemaRef.LookupQualifiedName(Prev, Owner);\n\n    // Check for invalid redeclarations.\n    if (SemaRef.CheckUsingDeclRedeclaration(D->getUsingLoc(),\n                                            D->hasTypename(), SS,\n                                            D->getLocation(), Prev))\n      NewUD->setInvalidDecl();\n\n  }\n\n  if (!NewUD->isInvalidDecl() &&\n      SemaRef.CheckUsingDeclQualifier(D->getUsingLoc(), D->hasTypename(),\n                                      SS, NameInfo, D->getLocation()))\n    NewUD->setInvalidDecl();\n\n  SemaRef.Context.setInstantiatedFromUsingDecl(NewUD, D);\n  NewUD->setAccess(D->getAccess());\n  Owner->addDecl(NewUD);\n\n  // Don't process the shadow decls for an invalid decl.\n  if (NewUD->isInvalidDecl())\n    return NewUD;\n\n  if (NameInfo.getName().getNameKind() == DeclarationName::CXXConstructorName)\n    SemaRef.CheckInheritingConstructorUsingDecl(NewUD);\n\n  bool isFunctionScope = Owner->isFunctionOrMethod();\n\n  // Process the shadow decls.\n  for (auto *Shadow : D->shadows()) {\n    // FIXME: UsingShadowDecl doesn't preserve its immediate target, so\n    // reconstruct it in the case where it matters.\n    NamedDecl *OldTarget = Shadow->getTargetDecl();\n    if (auto *CUSD = dyn_cast<ConstructorUsingShadowDecl>(Shadow))\n      if (auto *BaseShadow = CUSD->getNominatedBaseClassShadowDecl())\n        OldTarget = BaseShadow;\n\n    NamedDecl *InstTarget =\n        cast_or_null<NamedDecl>(SemaRef.FindInstantiatedDecl(\n            Shadow->getLocation(), OldTarget, TemplateArgs));\n    if (!InstTarget)\n      return nullptr;\n\n    UsingShadowDecl *PrevDecl = nullptr;\n    if (CheckRedeclaration) {\n      if (SemaRef.CheckUsingShadowDecl(NewUD, InstTarget, Prev, PrevDecl))\n        continue;\n    } else if (UsingShadowDecl *OldPrev =\n                   getPreviousDeclForInstantiation(Shadow)) {\n      PrevDecl = cast_or_null<UsingShadowDecl>(SemaRef.FindInstantiatedDecl(\n          Shadow->getLocation(), OldPrev, TemplateArgs));\n    }\n\n    UsingShadowDecl *InstShadow =\n        SemaRef.BuildUsingShadowDecl(/*Scope*/nullptr, NewUD, InstTarget,\n                                     PrevDecl);\n    SemaRef.Context.setInstantiatedFromUsingShadowDecl(InstShadow, Shadow);\n\n    if (isFunctionScope)\n      SemaRef.CurrentInstantiationScope->InstantiatedLocal(Shadow, InstShadow);\n  }\n\n  return NewUD;\n}\n\nDecl *TemplateDeclInstantiator::VisitUsingShadowDecl(UsingShadowDecl *D) {\n  // Ignore these;  we handle them in bulk when processing the UsingDecl.\n  return nullptr;\n}\n\nDecl *TemplateDeclInstantiator::VisitConstructorUsingShadowDecl(\n    ConstructorUsingShadowDecl *D) {\n  // Ignore these;  we handle them in bulk when processing the UsingDecl.\n  return nullptr;\n}\n\ntemplate <typename T>\nDecl *TemplateDeclInstantiator::instantiateUnresolvedUsingDecl(\n    T *D, bool InstantiatingPackElement) {\n  // If this is a pack expansion, expand it now.\n  if (D->isPackExpansion() && !InstantiatingPackElement) {\n    SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n    SemaRef.collectUnexpandedParameterPacks(D->getQualifierLoc(), Unexpanded);\n    SemaRef.collectUnexpandedParameterPacks(D->getNameInfo(), Unexpanded);\n\n    // Determine whether the set of unexpanded parameter packs can and should\n    // be expanded.\n    bool Expand = true;\n    bool RetainExpansion = false;\n    Optional<unsigned> NumExpansions;\n    if (SemaRef.CheckParameterPacksForExpansion(\n          D->getEllipsisLoc(), D->getSourceRange(), Unexpanded, TemplateArgs,\n            Expand, RetainExpansion, NumExpansions))\n      return nullptr;\n\n    // This declaration cannot appear within a function template signature,\n    // so we can't have a partial argument list for a parameter pack.\n    assert(!RetainExpansion &&\n           \"should never need to retain an expansion for UsingPackDecl\");\n\n    if (!Expand) {\n      // We cannot fully expand the pack expansion now, so substitute into the\n      // pattern and create a new pack expansion.\n      Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, -1);\n      return instantiateUnresolvedUsingDecl(D, true);\n    }\n\n    // Within a function, we don't have any normal way to check for conflicts\n    // between shadow declarations from different using declarations in the\n    // same pack expansion, but this is always ill-formed because all expansions\n    // must produce (conflicting) enumerators.\n    //\n    // Sadly we can't just reject this in the template definition because it\n    // could be valid if the pack is empty or has exactly one expansion.\n    if (D->getDeclContext()->isFunctionOrMethod() && *NumExpansions > 1) {\n      SemaRef.Diag(D->getEllipsisLoc(),\n                   diag::err_using_decl_redeclaration_expansion);\n      return nullptr;\n    }\n\n    // Instantiate the slices of this pack and build a UsingPackDecl.\n    SmallVector<NamedDecl*, 8> Expansions;\n    for (unsigned I = 0; I != *NumExpansions; ++I) {\n      Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, I);\n      Decl *Slice = instantiateUnresolvedUsingDecl(D, true);\n      if (!Slice)\n        return nullptr;\n      // Note that we can still get unresolved using declarations here, if we\n      // had arguments for all packs but the pattern also contained other\n      // template arguments (this only happens during partial substitution, eg\n      // into the body of a generic lambda in a function template).\n      Expansions.push_back(cast<NamedDecl>(Slice));\n    }\n\n    auto *NewD = SemaRef.BuildUsingPackDecl(D, Expansions);\n    if (isDeclWithinFunction(D))\n      SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, NewD);\n    return NewD;\n  }\n\n  UnresolvedUsingTypenameDecl *TD = dyn_cast<UnresolvedUsingTypenameDecl>(D);\n  SourceLocation TypenameLoc = TD ? TD->getTypenameLoc() : SourceLocation();\n\n  NestedNameSpecifierLoc QualifierLoc\n    = SemaRef.SubstNestedNameSpecifierLoc(D->getQualifierLoc(),\n                                          TemplateArgs);\n  if (!QualifierLoc)\n    return nullptr;\n\n  CXXScopeSpec SS;\n  SS.Adopt(QualifierLoc);\n\n  DeclarationNameInfo NameInfo\n    = SemaRef.SubstDeclarationNameInfo(D->getNameInfo(), TemplateArgs);\n\n  // Produce a pack expansion only if we're not instantiating a particular\n  // slice of a pack expansion.\n  bool InstantiatingSlice = D->getEllipsisLoc().isValid() &&\n                            SemaRef.ArgumentPackSubstitutionIndex != -1;\n  SourceLocation EllipsisLoc =\n      InstantiatingSlice ? SourceLocation() : D->getEllipsisLoc();\n\n  NamedDecl *UD = SemaRef.BuildUsingDeclaration(\n      /*Scope*/ nullptr, D->getAccess(), D->getUsingLoc(),\n      /*HasTypename*/ TD, TypenameLoc, SS, NameInfo, EllipsisLoc,\n      ParsedAttributesView(),\n      /*IsInstantiation*/ true);\n  if (UD)\n    SemaRef.Context.setInstantiatedFromUsingDecl(UD, D);\n\n  return UD;\n}\n\nDecl *TemplateDeclInstantiator::VisitUnresolvedUsingTypenameDecl(\n    UnresolvedUsingTypenameDecl *D) {\n  return instantiateUnresolvedUsingDecl(D);\n}\n\nDecl *TemplateDeclInstantiator::VisitUnresolvedUsingValueDecl(\n    UnresolvedUsingValueDecl *D) {\n  return instantiateUnresolvedUsingDecl(D);\n}\n\nDecl *TemplateDeclInstantiator::VisitUsingPackDecl(UsingPackDecl *D) {\n  SmallVector<NamedDecl*, 8> Expansions;\n  for (auto *UD : D->expansions()) {\n    if (NamedDecl *NewUD =\n            SemaRef.FindInstantiatedDecl(D->getLocation(), UD, TemplateArgs))\n      Expansions.push_back(NewUD);\n    else\n      return nullptr;\n  }\n\n  auto *NewD = SemaRef.BuildUsingPackDecl(D, Expansions);\n  if (isDeclWithinFunction(D))\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, NewD);\n  return NewD;\n}\n\nDecl *TemplateDeclInstantiator::VisitClassScopeFunctionSpecializationDecl(\n    ClassScopeFunctionSpecializationDecl *Decl) {\n  CXXMethodDecl *OldFD = Decl->getSpecialization();\n  return cast_or_null<CXXMethodDecl>(\n      VisitCXXMethodDecl(OldFD, nullptr, Decl->getTemplateArgsAsWritten()));\n}\n\nDecl *TemplateDeclInstantiator::VisitOMPThreadPrivateDecl(\n                                     OMPThreadPrivateDecl *D) {\n  SmallVector<Expr *, 5> Vars;\n  for (auto *I : D->varlists()) {\n    Expr *Var = SemaRef.SubstExpr(I, TemplateArgs).get();\n    assert(isa<DeclRefExpr>(Var) && \"threadprivate arg is not a DeclRefExpr\");\n    Vars.push_back(Var);\n  }\n\n  OMPThreadPrivateDecl *TD =\n    SemaRef.CheckOMPThreadPrivateDecl(D->getLocation(), Vars);\n\n  TD->setAccess(AS_public);\n  Owner->addDecl(TD);\n\n  return TD;\n}\n\nDecl *TemplateDeclInstantiator::VisitOMPAllocateDecl(OMPAllocateDecl *D) {\n  SmallVector<Expr *, 5> Vars;\n  for (auto *I : D->varlists()) {\n    Expr *Var = SemaRef.SubstExpr(I, TemplateArgs).get();\n    assert(isa<DeclRefExpr>(Var) && \"allocate arg is not a DeclRefExpr\");\n    Vars.push_back(Var);\n  }\n  SmallVector<OMPClause *, 4> Clauses;\n  // Copy map clauses from the original mapper.\n  for (OMPClause *C : D->clauselists()) {\n    auto *AC = cast<OMPAllocatorClause>(C);\n    ExprResult NewE = SemaRef.SubstExpr(AC->getAllocator(), TemplateArgs);\n    if (!NewE.isUsable())\n      continue;\n    OMPClause *IC = SemaRef.ActOnOpenMPAllocatorClause(\n        NewE.get(), AC->getBeginLoc(), AC->getLParenLoc(), AC->getEndLoc());\n    Clauses.push_back(IC);\n  }\n\n  Sema::DeclGroupPtrTy Res = SemaRef.ActOnOpenMPAllocateDirective(\n      D->getLocation(), Vars, Clauses, Owner);\n  if (Res.get().isNull())\n    return nullptr;\n  return Res.get().getSingleDecl();\n}\n\nDecl *TemplateDeclInstantiator::VisitOMPRequiresDecl(OMPRequiresDecl *D) {\n  llvm_unreachable(\n      \"Requires directive cannot be instantiated within a dependent context\");\n}\n\nDecl *TemplateDeclInstantiator::VisitOMPDeclareReductionDecl(\n    OMPDeclareReductionDecl *D) {\n  // Instantiate type and check if it is allowed.\n  const bool RequiresInstantiation =\n      D->getType()->isDependentType() ||\n      D->getType()->isInstantiationDependentType() ||\n      D->getType()->containsUnexpandedParameterPack();\n  QualType SubstReductionType;\n  if (RequiresInstantiation) {\n    SubstReductionType = SemaRef.ActOnOpenMPDeclareReductionType(\n        D->getLocation(),\n        ParsedType::make(SemaRef.SubstType(\n            D->getType(), TemplateArgs, D->getLocation(), DeclarationName())));\n  } else {\n    SubstReductionType = D->getType();\n  }\n  if (SubstReductionType.isNull())\n    return nullptr;\n  Expr *Combiner = D->getCombiner();\n  Expr *Init = D->getInitializer();\n  bool IsCorrect = true;\n  // Create instantiated copy.\n  std::pair<QualType, SourceLocation> ReductionTypes[] = {\n      std::make_pair(SubstReductionType, D->getLocation())};\n  auto *PrevDeclInScope = D->getPrevDeclInScope();\n  if (PrevDeclInScope && !PrevDeclInScope->isInvalidDecl()) {\n    PrevDeclInScope = cast<OMPDeclareReductionDecl>(\n        SemaRef.CurrentInstantiationScope->findInstantiationOf(PrevDeclInScope)\n            ->get<Decl *>());\n  }\n  auto DRD = SemaRef.ActOnOpenMPDeclareReductionDirectiveStart(\n      /*S=*/nullptr, Owner, D->getDeclName(), ReductionTypes, D->getAccess(),\n      PrevDeclInScope);\n  auto *NewDRD = cast<OMPDeclareReductionDecl>(DRD.get().getSingleDecl());\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, NewDRD);\n  Expr *SubstCombiner = nullptr;\n  Expr *SubstInitializer = nullptr;\n  // Combiners instantiation sequence.\n  if (Combiner) {\n    SemaRef.ActOnOpenMPDeclareReductionCombinerStart(\n        /*S=*/nullptr, NewDRD);\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(\n        cast<DeclRefExpr>(D->getCombinerIn())->getDecl(),\n        cast<DeclRefExpr>(NewDRD->getCombinerIn())->getDecl());\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(\n        cast<DeclRefExpr>(D->getCombinerOut())->getDecl(),\n        cast<DeclRefExpr>(NewDRD->getCombinerOut())->getDecl());\n    auto *ThisContext = dyn_cast_or_null<CXXRecordDecl>(Owner);\n    Sema::CXXThisScopeRAII ThisScope(SemaRef, ThisContext, Qualifiers(),\n                                     ThisContext);\n    SubstCombiner = SemaRef.SubstExpr(Combiner, TemplateArgs).get();\n    SemaRef.ActOnOpenMPDeclareReductionCombinerEnd(NewDRD, SubstCombiner);\n  }\n  // Initializers instantiation sequence.\n  if (Init) {\n    VarDecl *OmpPrivParm = SemaRef.ActOnOpenMPDeclareReductionInitializerStart(\n        /*S=*/nullptr, NewDRD);\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(\n        cast<DeclRefExpr>(D->getInitOrig())->getDecl(),\n        cast<DeclRefExpr>(NewDRD->getInitOrig())->getDecl());\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(\n        cast<DeclRefExpr>(D->getInitPriv())->getDecl(),\n        cast<DeclRefExpr>(NewDRD->getInitPriv())->getDecl());\n    if (D->getInitializerKind() == OMPDeclareReductionDecl::CallInit) {\n      SubstInitializer = SemaRef.SubstExpr(Init, TemplateArgs).get();\n    } else {\n      auto *OldPrivParm =\n          cast<VarDecl>(cast<DeclRefExpr>(D->getInitPriv())->getDecl());\n      IsCorrect = IsCorrect && OldPrivParm->hasInit();\n      if (IsCorrect)\n        SemaRef.InstantiateVariableInitializer(OmpPrivParm, OldPrivParm,\n                                               TemplateArgs);\n    }\n    SemaRef.ActOnOpenMPDeclareReductionInitializerEnd(NewDRD, SubstInitializer,\n                                                      OmpPrivParm);\n  }\n  IsCorrect = IsCorrect && SubstCombiner &&\n              (!Init ||\n               (D->getInitializerKind() == OMPDeclareReductionDecl::CallInit &&\n                SubstInitializer) ||\n               (D->getInitializerKind() != OMPDeclareReductionDecl::CallInit &&\n                !SubstInitializer));\n\n  (void)SemaRef.ActOnOpenMPDeclareReductionDirectiveEnd(\n      /*S=*/nullptr, DRD, IsCorrect && !D->isInvalidDecl());\n\n  return NewDRD;\n}\n\nDecl *\nTemplateDeclInstantiator::VisitOMPDeclareMapperDecl(OMPDeclareMapperDecl *D) {\n  // Instantiate type and check if it is allowed.\n  const bool RequiresInstantiation =\n      D->getType()->isDependentType() ||\n      D->getType()->isInstantiationDependentType() ||\n      D->getType()->containsUnexpandedParameterPack();\n  QualType SubstMapperTy;\n  DeclarationName VN = D->getVarName();\n  if (RequiresInstantiation) {\n    SubstMapperTy = SemaRef.ActOnOpenMPDeclareMapperType(\n        D->getLocation(),\n        ParsedType::make(SemaRef.SubstType(D->getType(), TemplateArgs,\n                                           D->getLocation(), VN)));\n  } else {\n    SubstMapperTy = D->getType();\n  }\n  if (SubstMapperTy.isNull())\n    return nullptr;\n  // Create an instantiated copy of mapper.\n  auto *PrevDeclInScope = D->getPrevDeclInScope();\n  if (PrevDeclInScope && !PrevDeclInScope->isInvalidDecl()) {\n    PrevDeclInScope = cast<OMPDeclareMapperDecl>(\n        SemaRef.CurrentInstantiationScope->findInstantiationOf(PrevDeclInScope)\n            ->get<Decl *>());\n  }\n  bool IsCorrect = true;\n  SmallVector<OMPClause *, 6> Clauses;\n  // Instantiate the mapper variable.\n  DeclarationNameInfo DirName;\n  SemaRef.StartOpenMPDSABlock(llvm::omp::OMPD_declare_mapper, DirName,\n                              /*S=*/nullptr,\n                              (*D->clauselist_begin())->getBeginLoc());\n  ExprResult MapperVarRef = SemaRef.ActOnOpenMPDeclareMapperDirectiveVarDecl(\n      /*S=*/nullptr, SubstMapperTy, D->getLocation(), VN);\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(\n      cast<DeclRefExpr>(D->getMapperVarRef())->getDecl(),\n      cast<DeclRefExpr>(MapperVarRef.get())->getDecl());\n  auto *ThisContext = dyn_cast_or_null<CXXRecordDecl>(Owner);\n  Sema::CXXThisScopeRAII ThisScope(SemaRef, ThisContext, Qualifiers(),\n                                   ThisContext);\n  // Instantiate map clauses.\n  for (OMPClause *C : D->clauselists()) {\n    auto *OldC = cast<OMPMapClause>(C);\n    SmallVector<Expr *, 4> NewVars;\n    for (Expr *OE : OldC->varlists()) {\n      Expr *NE = SemaRef.SubstExpr(OE, TemplateArgs).get();\n      if (!NE) {\n        IsCorrect = false;\n        break;\n      }\n      NewVars.push_back(NE);\n    }\n    if (!IsCorrect)\n      break;\n    NestedNameSpecifierLoc NewQualifierLoc =\n        SemaRef.SubstNestedNameSpecifierLoc(OldC->getMapperQualifierLoc(),\n                                            TemplateArgs);\n    CXXScopeSpec SS;\n    SS.Adopt(NewQualifierLoc);\n    DeclarationNameInfo NewNameInfo =\n        SemaRef.SubstDeclarationNameInfo(OldC->getMapperIdInfo(), TemplateArgs);\n    OMPVarListLocTy Locs(OldC->getBeginLoc(), OldC->getLParenLoc(),\n                         OldC->getEndLoc());\n    OMPClause *NewC = SemaRef.ActOnOpenMPMapClause(\n        OldC->getMapTypeModifiers(), OldC->getMapTypeModifiersLoc(), SS,\n        NewNameInfo, OldC->getMapType(), OldC->isImplicitMapType(),\n        OldC->getMapLoc(), OldC->getColonLoc(), NewVars, Locs);\n    Clauses.push_back(NewC);\n  }\n  SemaRef.EndOpenMPDSABlock(nullptr);\n  if (!IsCorrect)\n    return nullptr;\n  Sema::DeclGroupPtrTy DG = SemaRef.ActOnOpenMPDeclareMapperDirective(\n      /*S=*/nullptr, Owner, D->getDeclName(), SubstMapperTy, D->getLocation(),\n      VN, D->getAccess(), MapperVarRef.get(), Clauses, PrevDeclInScope);\n  Decl *NewDMD = DG.get().getSingleDecl();\n  SemaRef.CurrentInstantiationScope->InstantiatedLocal(D, NewDMD);\n  return NewDMD;\n}\n\nDecl *TemplateDeclInstantiator::VisitOMPCapturedExprDecl(\n    OMPCapturedExprDecl * /*D*/) {\n  llvm_unreachable(\"Should not be met in templates\");\n}\n\nDecl *TemplateDeclInstantiator::VisitFunctionDecl(FunctionDecl *D) {\n  return VisitFunctionDecl(D, nullptr);\n}\n\nDecl *\nTemplateDeclInstantiator::VisitCXXDeductionGuideDecl(CXXDeductionGuideDecl *D) {\n  Decl *Inst = VisitFunctionDecl(D, nullptr);\n  if (Inst && !D->getDescribedFunctionTemplate())\n    Owner->addDecl(Inst);\n  return Inst;\n}\n\nDecl *TemplateDeclInstantiator::VisitCXXMethodDecl(CXXMethodDecl *D) {\n  return VisitCXXMethodDecl(D, nullptr);\n}\n\nDecl *TemplateDeclInstantiator::VisitRecordDecl(RecordDecl *D) {\n  llvm_unreachable(\"There are only CXXRecordDecls in C++\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitClassTemplateSpecializationDecl(\n    ClassTemplateSpecializationDecl *D) {\n  // As a MS extension, we permit class-scope explicit specialization\n  // of member class templates.\n  ClassTemplateDecl *ClassTemplate = D->getSpecializedTemplate();\n  assert(ClassTemplate->getDeclContext()->isRecord() &&\n         D->getTemplateSpecializationKind() == TSK_ExplicitSpecialization &&\n         \"can only instantiate an explicit specialization \"\n         \"for a member class template\");\n\n  // Lookup the already-instantiated declaration in the instantiation\n  // of the class template.\n  ClassTemplateDecl *InstClassTemplate =\n      cast_or_null<ClassTemplateDecl>(SemaRef.FindInstantiatedDecl(\n          D->getLocation(), ClassTemplate, TemplateArgs));\n  if (!InstClassTemplate)\n    return nullptr;\n\n  // Substitute into the template arguments of the class template explicit\n  // specialization.\n  TemplateSpecializationTypeLoc Loc = D->getTypeAsWritten()->getTypeLoc().\n                                        castAs<TemplateSpecializationTypeLoc>();\n  TemplateArgumentListInfo InstTemplateArgs(Loc.getLAngleLoc(),\n                                            Loc.getRAngleLoc());\n  SmallVector<TemplateArgumentLoc, 4> ArgLocs;\n  for (unsigned I = 0; I != Loc.getNumArgs(); ++I)\n    ArgLocs.push_back(Loc.getArgLoc(I));\n  if (SemaRef.Subst(ArgLocs.data(), ArgLocs.size(),\n                    InstTemplateArgs, TemplateArgs))\n    return nullptr;\n\n  // Check that the template argument list is well-formed for this\n  // class template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (SemaRef.CheckTemplateArgumentList(InstClassTemplate,\n                                        D->getLocation(),\n                                        InstTemplateArgs,\n                                        false,\n                                        Converted,\n                                        /*UpdateArgsWithConversion=*/true))\n    return nullptr;\n\n  // Figure out where to insert this class template explicit specialization\n  // in the member template's set of class template explicit specializations.\n  void *InsertPos = nullptr;\n  ClassTemplateSpecializationDecl *PrevDecl =\n      InstClassTemplate->findSpecialization(Converted, InsertPos);\n\n  // Check whether we've already seen a conflicting instantiation of this\n  // declaration (for instance, if there was a prior implicit instantiation).\n  bool Ignored;\n  if (PrevDecl &&\n      SemaRef.CheckSpecializationInstantiationRedecl(D->getLocation(),\n                                                     D->getSpecializationKind(),\n                                                     PrevDecl,\n                                                     PrevDecl->getSpecializationKind(),\n                                                     PrevDecl->getPointOfInstantiation(),\n                                                     Ignored))\n    return nullptr;\n\n  // If PrevDecl was a definition and D is also a definition, diagnose.\n  // This happens in cases like:\n  //\n  //   template<typename T, typename U>\n  //   struct Outer {\n  //     template<typename X> struct Inner;\n  //     template<> struct Inner<T> {};\n  //     template<> struct Inner<U> {};\n  //   };\n  //\n  //   Outer<int, int> outer; // error: the explicit specializations of Inner\n  //                          // have the same signature.\n  if (PrevDecl && PrevDecl->getDefinition() &&\n      D->isThisDeclarationADefinition()) {\n    SemaRef.Diag(D->getLocation(), diag::err_redefinition) << PrevDecl;\n    SemaRef.Diag(PrevDecl->getDefinition()->getLocation(),\n                 diag::note_previous_definition);\n    return nullptr;\n  }\n\n  // Create the class template partial specialization declaration.\n  ClassTemplateSpecializationDecl *InstD =\n      ClassTemplateSpecializationDecl::Create(\n          SemaRef.Context, D->getTagKind(), Owner, D->getBeginLoc(),\n          D->getLocation(), InstClassTemplate, Converted, PrevDecl);\n\n  // Add this partial specialization to the set of class template partial\n  // specializations.\n  if (!PrevDecl)\n    InstClassTemplate->AddSpecialization(InstD, InsertPos);\n\n  // Substitute the nested name specifier, if any.\n  if (SubstQualifier(D, InstD))\n    return nullptr;\n\n  // Build the canonical type that describes the converted template\n  // arguments of the class template explicit specialization.\n  QualType CanonType = SemaRef.Context.getTemplateSpecializationType(\n      TemplateName(InstClassTemplate), Converted,\n      SemaRef.Context.getRecordType(InstD));\n\n  // Build the fully-sugared type for this class template\n  // specialization as the user wrote in the specialization\n  // itself. This means that we'll pretty-print the type retrieved\n  // from the specialization's declaration the way that the user\n  // actually wrote the specialization, rather than formatting the\n  // name based on the \"canonical\" representation used to store the\n  // template arguments in the specialization.\n  TypeSourceInfo *WrittenTy = SemaRef.Context.getTemplateSpecializationTypeInfo(\n      TemplateName(InstClassTemplate), D->getLocation(), InstTemplateArgs,\n      CanonType);\n\n  InstD->setAccess(D->getAccess());\n  InstD->setInstantiationOfMemberClass(D, TSK_ImplicitInstantiation);\n  InstD->setSpecializationKind(D->getSpecializationKind());\n  InstD->setTypeAsWritten(WrittenTy);\n  InstD->setExternLoc(D->getExternLoc());\n  InstD->setTemplateKeywordLoc(D->getTemplateKeywordLoc());\n\n  Owner->addDecl(InstD);\n\n  // Instantiate the members of the class-scope explicit specialization eagerly.\n  // We don't have support for lazy instantiation of an explicit specialization\n  // yet, and MSVC eagerly instantiates in this case.\n  // FIXME: This is wrong in standard C++.\n  if (D->isThisDeclarationADefinition() &&\n      SemaRef.InstantiateClass(D->getLocation(), InstD, D, TemplateArgs,\n                               TSK_ImplicitInstantiation,\n                               /*Complain=*/true))\n    return nullptr;\n\n  return InstD;\n}\n\nDecl *TemplateDeclInstantiator::VisitVarTemplateSpecializationDecl(\n    VarTemplateSpecializationDecl *D) {\n\n  TemplateArgumentListInfo VarTemplateArgsInfo;\n  VarTemplateDecl *VarTemplate = D->getSpecializedTemplate();\n  assert(VarTemplate &&\n         \"A template specialization without specialized template?\");\n\n  VarTemplateDecl *InstVarTemplate =\n      cast_or_null<VarTemplateDecl>(SemaRef.FindInstantiatedDecl(\n          D->getLocation(), VarTemplate, TemplateArgs));\n  if (!InstVarTemplate)\n    return nullptr;\n\n  // Substitute the current template arguments.\n  const TemplateArgumentListInfo &TemplateArgsInfo = D->getTemplateArgsInfo();\n  VarTemplateArgsInfo.setLAngleLoc(TemplateArgsInfo.getLAngleLoc());\n  VarTemplateArgsInfo.setRAngleLoc(TemplateArgsInfo.getRAngleLoc());\n\n  if (SemaRef.Subst(TemplateArgsInfo.getArgumentArray(),\n                    TemplateArgsInfo.size(), VarTemplateArgsInfo, TemplateArgs))\n    return nullptr;\n\n  // Check that the template argument list is well-formed for this template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (SemaRef.CheckTemplateArgumentList(InstVarTemplate, D->getLocation(),\n                                        VarTemplateArgsInfo, false, Converted,\n                                        /*UpdateArgsWithConversion=*/true))\n    return nullptr;\n\n  // Check whether we've already seen a declaration of this specialization.\n  void *InsertPos = nullptr;\n  VarTemplateSpecializationDecl *PrevDecl =\n      InstVarTemplate->findSpecialization(Converted, InsertPos);\n\n  // Check whether we've already seen a conflicting instantiation of this\n  // declaration (for instance, if there was a prior implicit instantiation).\n  bool Ignored;\n  if (PrevDecl && SemaRef.CheckSpecializationInstantiationRedecl(\n                      D->getLocation(), D->getSpecializationKind(), PrevDecl,\n                      PrevDecl->getSpecializationKind(),\n                      PrevDecl->getPointOfInstantiation(), Ignored))\n    return nullptr;\n\n  return VisitVarTemplateSpecializationDecl(\n      InstVarTemplate, D, VarTemplateArgsInfo, Converted, PrevDecl);\n}\n\nDecl *TemplateDeclInstantiator::VisitVarTemplateSpecializationDecl(\n    VarTemplateDecl *VarTemplate, VarDecl *D,\n    const TemplateArgumentListInfo &TemplateArgsInfo,\n    ArrayRef<TemplateArgument> Converted,\n    VarTemplateSpecializationDecl *PrevDecl) {\n\n  // Do substitution on the type of the declaration\n  TypeSourceInfo *DI =\n      SemaRef.SubstType(D->getTypeSourceInfo(), TemplateArgs,\n                        D->getTypeSpecStartLoc(), D->getDeclName());\n  if (!DI)\n    return nullptr;\n\n  if (DI->getType()->isFunctionType()) {\n    SemaRef.Diag(D->getLocation(), diag::err_variable_instantiates_to_function)\n        << D->isStaticDataMember() << DI->getType();\n    return nullptr;\n  }\n\n  // Build the instantiated declaration\n  VarTemplateSpecializationDecl *Var = VarTemplateSpecializationDecl::Create(\n      SemaRef.Context, Owner, D->getInnerLocStart(), D->getLocation(),\n      VarTemplate, DI->getType(), DI, D->getStorageClass(), Converted);\n  Var->setTemplateArgsInfo(TemplateArgsInfo);\n  if (!PrevDecl) {\n    void *InsertPos = nullptr;\n    VarTemplate->findSpecialization(Converted, InsertPos);\n    VarTemplate->AddSpecialization(Var, InsertPos);\n  }\n\n  if (SemaRef.getLangOpts().OpenCL)\n    SemaRef.deduceOpenCLAddressSpace(Var);\n\n  // Substitute the nested name specifier, if any.\n  if (SubstQualifier(D, Var))\n    return nullptr;\n\n  SemaRef.BuildVariableInstantiation(Var, D, TemplateArgs, LateAttrs, Owner,\n                                     StartingScope, false, PrevDecl);\n\n  return Var;\n}\n\nDecl *TemplateDeclInstantiator::VisitObjCAtDefsFieldDecl(ObjCAtDefsFieldDecl *D) {\n  llvm_unreachable(\"@defs is not supported in Objective-C++\");\n}\n\nDecl *TemplateDeclInstantiator::VisitFriendTemplateDecl(FriendTemplateDecl *D) {\n  // FIXME: We need to be able to instantiate FriendTemplateDecls.\n  unsigned DiagID = SemaRef.getDiagnostics().getCustomDiagID(\n                                               DiagnosticsEngine::Error,\n                                               \"cannot instantiate %0 yet\");\n  SemaRef.Diag(D->getLocation(), DiagID)\n    << D->getDeclKindName();\n\n  return nullptr;\n}\n\nDecl *TemplateDeclInstantiator::VisitConceptDecl(ConceptDecl *D) {\n  llvm_unreachable(\"Concept definitions cannot reside inside a template\");\n}\n\nDecl *\nTemplateDeclInstantiator::VisitRequiresExprBodyDecl(RequiresExprBodyDecl *D) {\n  return RequiresExprBodyDecl::Create(SemaRef.Context, D->getDeclContext(),\n                                      D->getBeginLoc());\n}\n\nDecl *TemplateDeclInstantiator::VisitDecl(Decl *D) {\n  llvm_unreachable(\"Unexpected decl\");\n}\n\nDecl *Sema::SubstDecl(Decl *D, DeclContext *Owner,\n                      const MultiLevelTemplateArgumentList &TemplateArgs) {\n  TemplateDeclInstantiator Instantiator(*this, Owner, TemplateArgs);\n  if (D->isInvalidDecl())\n    return nullptr;\n\n  Decl *SubstD;\n  runWithSufficientStackSpace(D->getLocation(), [&] {\n    SubstD = Instantiator.Visit(D);\n  });\n  return SubstD;\n}\n\nvoid TemplateDeclInstantiator::adjustForRewrite(RewriteKind RK,\n                                                FunctionDecl *Orig, QualType &T,\n                                                TypeSourceInfo *&TInfo,\n                                                DeclarationNameInfo &NameInfo) {\n  assert(RK == RewriteKind::RewriteSpaceshipAsEqualEqual);\n\n  // C++2a [class.compare.default]p3:\n  //   the return type is replaced with bool\n  auto *FPT = T->castAs<FunctionProtoType>();\n  T = SemaRef.Context.getFunctionType(\n      SemaRef.Context.BoolTy, FPT->getParamTypes(), FPT->getExtProtoInfo());\n\n  // Update the return type in the source info too. The most straightforward\n  // way is to create new TypeSourceInfo for the new type. Use the location of\n  // the '= default' as the location of the new type.\n  //\n  // FIXME: Set the correct return type when we initially transform the type,\n  // rather than delaying it to now.\n  TypeSourceInfo *NewTInfo =\n      SemaRef.Context.getTrivialTypeSourceInfo(T, Orig->getEndLoc());\n  auto OldLoc = TInfo->getTypeLoc().getAsAdjusted<FunctionProtoTypeLoc>();\n  assert(OldLoc && \"type of function is not a function type?\");\n  auto NewLoc = NewTInfo->getTypeLoc().castAs<FunctionProtoTypeLoc>();\n  for (unsigned I = 0, N = OldLoc.getNumParams(); I != N; ++I)\n    NewLoc.setParam(I, OldLoc.getParam(I));\n  TInfo = NewTInfo;\n\n  //   and the declarator-id is replaced with operator==\n  NameInfo.setName(\n      SemaRef.Context.DeclarationNames.getCXXOperatorName(OO_EqualEqual));\n}\n\nFunctionDecl *Sema::SubstSpaceshipAsEqualEqual(CXXRecordDecl *RD,\n                                               FunctionDecl *Spaceship) {\n  if (Spaceship->isInvalidDecl())\n    return nullptr;\n\n  // C++2a [class.compare.default]p3:\n  //   an == operator function is declared implicitly [...] with the same\n  //   access and function-definition and in the same class scope as the\n  //   three-way comparison operator function\n  MultiLevelTemplateArgumentList NoTemplateArgs;\n  NoTemplateArgs.setKind(TemplateSubstitutionKind::Rewrite);\n  NoTemplateArgs.addOuterRetainedLevels(RD->getTemplateDepth());\n  TemplateDeclInstantiator Instantiator(*this, RD, NoTemplateArgs);\n  Decl *R;\n  if (auto *MD = dyn_cast<CXXMethodDecl>(Spaceship)) {\n    R = Instantiator.VisitCXXMethodDecl(\n        MD, nullptr, None,\n        TemplateDeclInstantiator::RewriteKind::RewriteSpaceshipAsEqualEqual);\n  } else {\n    assert(Spaceship->getFriendObjectKind() &&\n           \"defaulted spaceship is neither a member nor a friend\");\n\n    R = Instantiator.VisitFunctionDecl(\n        Spaceship, nullptr,\n        TemplateDeclInstantiator::RewriteKind::RewriteSpaceshipAsEqualEqual);\n    if (!R)\n      return nullptr;\n\n    FriendDecl *FD =\n        FriendDecl::Create(Context, RD, Spaceship->getLocation(),\n                           cast<NamedDecl>(R), Spaceship->getBeginLoc());\n    FD->setAccess(AS_public);\n    RD->addDecl(FD);\n  }\n  return cast_or_null<FunctionDecl>(R);\n}\n\n/// Instantiates a nested template parameter list in the current\n/// instantiation context.\n///\n/// \\param L The parameter list to instantiate\n///\n/// \\returns NULL if there was an error\nTemplateParameterList *\nTemplateDeclInstantiator::SubstTemplateParams(TemplateParameterList *L) {\n  // Get errors for all the parameters before bailing out.\n  bool Invalid = false;\n\n  unsigned N = L->size();\n  typedef SmallVector<NamedDecl *, 8> ParamVector;\n  ParamVector Params;\n  Params.reserve(N);\n  for (auto &P : *L) {\n    NamedDecl *D = cast_or_null<NamedDecl>(Visit(P));\n    Params.push_back(D);\n    Invalid = Invalid || !D || D->isInvalidDecl();\n  }\n\n  // Clean up if we had an error.\n  if (Invalid)\n    return nullptr;\n\n  // FIXME: Concepts: Substitution into requires clause should only happen when\n  // checking satisfaction.\n  Expr *InstRequiresClause = nullptr;\n  if (Expr *E = L->getRequiresClause()) {\n    EnterExpressionEvaluationContext ConstantEvaluated(\n        SemaRef, Sema::ExpressionEvaluationContext::Unevaluated);\n    ExprResult Res = SemaRef.SubstExpr(E, TemplateArgs);\n    if (Res.isInvalid() || !Res.isUsable()) {\n      return nullptr;\n    }\n    InstRequiresClause = Res.get();\n  }\n\n  TemplateParameterList *InstL\n    = TemplateParameterList::Create(SemaRef.Context, L->getTemplateLoc(),\n                                    L->getLAngleLoc(), Params,\n                                    L->getRAngleLoc(), InstRequiresClause);\n  return InstL;\n}\n\nTemplateParameterList *\nSema::SubstTemplateParams(TemplateParameterList *Params, DeclContext *Owner,\n                          const MultiLevelTemplateArgumentList &TemplateArgs) {\n  TemplateDeclInstantiator Instantiator(*this, Owner, TemplateArgs);\n  return Instantiator.SubstTemplateParams(Params);\n}\n\n/// Instantiate the declaration of a class template partial\n/// specialization.\n///\n/// \\param ClassTemplate the (instantiated) class template that is partially\n// specialized by the instantiation of \\p PartialSpec.\n///\n/// \\param PartialSpec the (uninstantiated) class template partial\n/// specialization that we are instantiating.\n///\n/// \\returns The instantiated partial specialization, if successful; otherwise,\n/// NULL to indicate an error.\nClassTemplatePartialSpecializationDecl *\nTemplateDeclInstantiator::InstantiateClassTemplatePartialSpecialization(\n                                            ClassTemplateDecl *ClassTemplate,\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n  // Create a local instantiation scope for this class template partial\n  // specialization, which will contain the instantiations of the template\n  // parameters.\n  LocalInstantiationScope Scope(SemaRef);\n\n  // Substitute into the template parameters of the class template partial\n  // specialization.\n  TemplateParameterList *TempParams = PartialSpec->getTemplateParameters();\n  TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n  if (!InstParams)\n    return nullptr;\n\n  // Substitute into the template arguments of the class template partial\n  // specialization.\n  const ASTTemplateArgumentListInfo *TemplArgInfo\n    = PartialSpec->getTemplateArgsAsWritten();\n  TemplateArgumentListInfo InstTemplateArgs(TemplArgInfo->LAngleLoc,\n                                            TemplArgInfo->RAngleLoc);\n  if (SemaRef.Subst(TemplArgInfo->getTemplateArgs(),\n                    TemplArgInfo->NumTemplateArgs,\n                    InstTemplateArgs, TemplateArgs))\n    return nullptr;\n\n  // Check that the template argument list is well-formed for this\n  // class template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (SemaRef.CheckTemplateArgumentList(ClassTemplate,\n                                        PartialSpec->getLocation(),\n                                        InstTemplateArgs,\n                                        false,\n                                        Converted))\n    return nullptr;\n\n  // Check these arguments are valid for a template partial specialization.\n  if (SemaRef.CheckTemplatePartialSpecializationArgs(\n          PartialSpec->getLocation(), ClassTemplate, InstTemplateArgs.size(),\n          Converted))\n    return nullptr;\n\n  // Figure out where to insert this class template partial specialization\n  // in the member template's set of class template partial specializations.\n  void *InsertPos = nullptr;\n  ClassTemplateSpecializationDecl *PrevDecl\n    = ClassTemplate->findPartialSpecialization(Converted, InstParams,\n                                               InsertPos);\n\n  // Build the canonical type that describes the converted template\n  // arguments of the class template partial specialization.\n  QualType CanonType\n    = SemaRef.Context.getTemplateSpecializationType(TemplateName(ClassTemplate),\n                                                    Converted);\n\n  // Build the fully-sugared type for this class template\n  // specialization as the user wrote in the specialization\n  // itself. This means that we'll pretty-print the type retrieved\n  // from the specialization's declaration the way that the user\n  // actually wrote the specialization, rather than formatting the\n  // name based on the \"canonical\" representation used to store the\n  // template arguments in the specialization.\n  TypeSourceInfo *WrittenTy\n    = SemaRef.Context.getTemplateSpecializationTypeInfo(\n                                                    TemplateName(ClassTemplate),\n                                                    PartialSpec->getLocation(),\n                                                    InstTemplateArgs,\n                                                    CanonType);\n\n  if (PrevDecl) {\n    // We've already seen a partial specialization with the same template\n    // parameters and template arguments. This can happen, for example, when\n    // substituting the outer template arguments ends up causing two\n    // class template partial specializations of a member class template\n    // to have identical forms, e.g.,\n    //\n    //   template<typename T, typename U>\n    //   struct Outer {\n    //     template<typename X, typename Y> struct Inner;\n    //     template<typename Y> struct Inner<T, Y>;\n    //     template<typename Y> struct Inner<U, Y>;\n    //   };\n    //\n    //   Outer<int, int> outer; // error: the partial specializations of Inner\n    //                          // have the same signature.\n    SemaRef.Diag(PartialSpec->getLocation(), diag::err_partial_spec_redeclared)\n      << WrittenTy->getType();\n    SemaRef.Diag(PrevDecl->getLocation(), diag::note_prev_partial_spec_here)\n      << SemaRef.Context.getTypeDeclType(PrevDecl);\n    return nullptr;\n  }\n\n\n  // Create the class template partial specialization declaration.\n  ClassTemplatePartialSpecializationDecl *InstPartialSpec =\n      ClassTemplatePartialSpecializationDecl::Create(\n          SemaRef.Context, PartialSpec->getTagKind(), Owner,\n          PartialSpec->getBeginLoc(), PartialSpec->getLocation(), InstParams,\n          ClassTemplate, Converted, InstTemplateArgs, CanonType, nullptr);\n  // Substitute the nested name specifier, if any.\n  if (SubstQualifier(PartialSpec, InstPartialSpec))\n    return nullptr;\n\n  InstPartialSpec->setInstantiatedFromMember(PartialSpec);\n  InstPartialSpec->setTypeAsWritten(WrittenTy);\n\n  // Check the completed partial specialization.\n  SemaRef.CheckTemplatePartialSpecialization(InstPartialSpec);\n\n  // Add this partial specialization to the set of class template partial\n  // specializations.\n  ClassTemplate->AddPartialSpecialization(InstPartialSpec,\n                                          /*InsertPos=*/nullptr);\n  return InstPartialSpec;\n}\n\n/// Instantiate the declaration of a variable template partial\n/// specialization.\n///\n/// \\param VarTemplate the (instantiated) variable template that is partially\n/// specialized by the instantiation of \\p PartialSpec.\n///\n/// \\param PartialSpec the (uninstantiated) variable template partial\n/// specialization that we are instantiating.\n///\n/// \\returns The instantiated partial specialization, if successful; otherwise,\n/// NULL to indicate an error.\nVarTemplatePartialSpecializationDecl *\nTemplateDeclInstantiator::InstantiateVarTemplatePartialSpecialization(\n    VarTemplateDecl *VarTemplate,\n    VarTemplatePartialSpecializationDecl *PartialSpec) {\n  // Create a local instantiation scope for this variable template partial\n  // specialization, which will contain the instantiations of the template\n  // parameters.\n  LocalInstantiationScope Scope(SemaRef);\n\n  // Substitute into the template parameters of the variable template partial\n  // specialization.\n  TemplateParameterList *TempParams = PartialSpec->getTemplateParameters();\n  TemplateParameterList *InstParams = SubstTemplateParams(TempParams);\n  if (!InstParams)\n    return nullptr;\n\n  // Substitute into the template arguments of the variable template partial\n  // specialization.\n  const ASTTemplateArgumentListInfo *TemplArgInfo\n    = PartialSpec->getTemplateArgsAsWritten();\n  TemplateArgumentListInfo InstTemplateArgs(TemplArgInfo->LAngleLoc,\n                                            TemplArgInfo->RAngleLoc);\n  if (SemaRef.Subst(TemplArgInfo->getTemplateArgs(),\n                    TemplArgInfo->NumTemplateArgs,\n                    InstTemplateArgs, TemplateArgs))\n    return nullptr;\n\n  // Check that the template argument list is well-formed for this\n  // class template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (SemaRef.CheckTemplateArgumentList(VarTemplate, PartialSpec->getLocation(),\n                                        InstTemplateArgs, false, Converted))\n    return nullptr;\n\n  // Check these arguments are valid for a template partial specialization.\n  if (SemaRef.CheckTemplatePartialSpecializationArgs(\n          PartialSpec->getLocation(), VarTemplate, InstTemplateArgs.size(),\n          Converted))\n    return nullptr;\n\n  // Figure out where to insert this variable template partial specialization\n  // in the member template's set of variable template partial specializations.\n  void *InsertPos = nullptr;\n  VarTemplateSpecializationDecl *PrevDecl =\n      VarTemplate->findPartialSpecialization(Converted, InstParams, InsertPos);\n\n  // Build the canonical type that describes the converted template\n  // arguments of the variable template partial specialization.\n  QualType CanonType = SemaRef.Context.getTemplateSpecializationType(\n      TemplateName(VarTemplate), Converted);\n\n  // Build the fully-sugared type for this variable template\n  // specialization as the user wrote in the specialization\n  // itself. This means that we'll pretty-print the type retrieved\n  // from the specialization's declaration the way that the user\n  // actually wrote the specialization, rather than formatting the\n  // name based on the \"canonical\" representation used to store the\n  // template arguments in the specialization.\n  TypeSourceInfo *WrittenTy = SemaRef.Context.getTemplateSpecializationTypeInfo(\n      TemplateName(VarTemplate), PartialSpec->getLocation(), InstTemplateArgs,\n      CanonType);\n\n  if (PrevDecl) {\n    // We've already seen a partial specialization with the same template\n    // parameters and template arguments. This can happen, for example, when\n    // substituting the outer template arguments ends up causing two\n    // variable template partial specializations of a member variable template\n    // to have identical forms, e.g.,\n    //\n    //   template<typename T, typename U>\n    //   struct Outer {\n    //     template<typename X, typename Y> pair<X,Y> p;\n    //     template<typename Y> pair<T, Y> p;\n    //     template<typename Y> pair<U, Y> p;\n    //   };\n    //\n    //   Outer<int, int> outer; // error: the partial specializations of Inner\n    //                          // have the same signature.\n    SemaRef.Diag(PartialSpec->getLocation(),\n                 diag::err_var_partial_spec_redeclared)\n        << WrittenTy->getType();\n    SemaRef.Diag(PrevDecl->getLocation(),\n                 diag::note_var_prev_partial_spec_here);\n    return nullptr;\n  }\n\n  // Do substitution on the type of the declaration\n  TypeSourceInfo *DI = SemaRef.SubstType(\n      PartialSpec->getTypeSourceInfo(), TemplateArgs,\n      PartialSpec->getTypeSpecStartLoc(), PartialSpec->getDeclName());\n  if (!DI)\n    return nullptr;\n\n  if (DI->getType()->isFunctionType()) {\n    SemaRef.Diag(PartialSpec->getLocation(),\n                 diag::err_variable_instantiates_to_function)\n        << PartialSpec->isStaticDataMember() << DI->getType();\n    return nullptr;\n  }\n\n  // Create the variable template partial specialization declaration.\n  VarTemplatePartialSpecializationDecl *InstPartialSpec =\n      VarTemplatePartialSpecializationDecl::Create(\n          SemaRef.Context, Owner, PartialSpec->getInnerLocStart(),\n          PartialSpec->getLocation(), InstParams, VarTemplate, DI->getType(),\n          DI, PartialSpec->getStorageClass(), Converted, InstTemplateArgs);\n\n  // Substitute the nested name specifier, if any.\n  if (SubstQualifier(PartialSpec, InstPartialSpec))\n    return nullptr;\n\n  InstPartialSpec->setInstantiatedFromMember(PartialSpec);\n  InstPartialSpec->setTypeAsWritten(WrittenTy);\n\n  // Check the completed partial specialization.\n  SemaRef.CheckTemplatePartialSpecialization(InstPartialSpec);\n\n  // Add this partial specialization to the set of variable template partial\n  // specializations. The instantiation of the initializer is not necessary.\n  VarTemplate->AddPartialSpecialization(InstPartialSpec, /*InsertPos=*/nullptr);\n\n  SemaRef.BuildVariableInstantiation(InstPartialSpec, PartialSpec, TemplateArgs,\n                                     LateAttrs, Owner, StartingScope);\n\n  return InstPartialSpec;\n}\n\nTypeSourceInfo*\nTemplateDeclInstantiator::SubstFunctionType(FunctionDecl *D,\n                              SmallVectorImpl<ParmVarDecl *> &Params) {\n  TypeSourceInfo *OldTInfo = D->getTypeSourceInfo();\n  assert(OldTInfo && \"substituting function without type source info\");\n  assert(Params.empty() && \"parameter vector is non-empty at start\");\n\n  CXXRecordDecl *ThisContext = nullptr;\n  Qualifiers ThisTypeQuals;\n  if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(D)) {\n    ThisContext = cast<CXXRecordDecl>(Owner);\n    ThisTypeQuals = Method->getMethodQualifiers();\n  }\n\n  TypeSourceInfo *NewTInfo\n    = SemaRef.SubstFunctionDeclType(OldTInfo, TemplateArgs,\n                                    D->getTypeSpecStartLoc(),\n                                    D->getDeclName(),\n                                    ThisContext, ThisTypeQuals);\n  if (!NewTInfo)\n    return nullptr;\n\n  TypeLoc OldTL = OldTInfo->getTypeLoc().IgnoreParens();\n  if (FunctionProtoTypeLoc OldProtoLoc = OldTL.getAs<FunctionProtoTypeLoc>()) {\n    if (NewTInfo != OldTInfo) {\n      // Get parameters from the new type info.\n      TypeLoc NewTL = NewTInfo->getTypeLoc().IgnoreParens();\n      FunctionProtoTypeLoc NewProtoLoc = NewTL.castAs<FunctionProtoTypeLoc>();\n      unsigned NewIdx = 0;\n      for (unsigned OldIdx = 0, NumOldParams = OldProtoLoc.getNumParams();\n           OldIdx != NumOldParams; ++OldIdx) {\n        ParmVarDecl *OldParam = OldProtoLoc.getParam(OldIdx);\n        if (!OldParam)\n          return nullptr;\n\n        LocalInstantiationScope *Scope = SemaRef.CurrentInstantiationScope;\n\n        Optional<unsigned> NumArgumentsInExpansion;\n        if (OldParam->isParameterPack())\n          NumArgumentsInExpansion =\n              SemaRef.getNumArgumentsInExpansion(OldParam->getType(),\n                                                 TemplateArgs);\n        if (!NumArgumentsInExpansion) {\n          // Simple case: normal parameter, or a parameter pack that's\n          // instantiated to a (still-dependent) parameter pack.\n          ParmVarDecl *NewParam = NewProtoLoc.getParam(NewIdx++);\n          Params.push_back(NewParam);\n          Scope->InstantiatedLocal(OldParam, NewParam);\n        } else {\n          // Parameter pack expansion: make the instantiation an argument pack.\n          Scope->MakeInstantiatedLocalArgPack(OldParam);\n          for (unsigned I = 0; I != *NumArgumentsInExpansion; ++I) {\n            ParmVarDecl *NewParam = NewProtoLoc.getParam(NewIdx++);\n            Params.push_back(NewParam);\n            Scope->InstantiatedLocalPackArg(OldParam, NewParam);\n          }\n        }\n      }\n    } else {\n      // The function type itself was not dependent and therefore no\n      // substitution occurred. However, we still need to instantiate\n      // the function parameters themselves.\n      const FunctionProtoType *OldProto =\n          cast<FunctionProtoType>(OldProtoLoc.getType());\n      for (unsigned i = 0, i_end = OldProtoLoc.getNumParams(); i != i_end;\n           ++i) {\n        ParmVarDecl *OldParam = OldProtoLoc.getParam(i);\n        if (!OldParam) {\n          Params.push_back(SemaRef.BuildParmVarDeclForTypedef(\n              D, D->getLocation(), OldProto->getParamType(i)));\n          continue;\n        }\n\n        ParmVarDecl *Parm =\n            cast_or_null<ParmVarDecl>(VisitParmVarDecl(OldParam));\n        if (!Parm)\n          return nullptr;\n        Params.push_back(Parm);\n      }\n    }\n  } else {\n    // If the type of this function, after ignoring parentheses, is not\n    // *directly* a function type, then we're instantiating a function that\n    // was declared via a typedef or with attributes, e.g.,\n    //\n    //   typedef int functype(int, int);\n    //   functype func;\n    //   int __cdecl meth(int, int);\n    //\n    // In this case, we'll just go instantiate the ParmVarDecls that we\n    // synthesized in the method declaration.\n    SmallVector<QualType, 4> ParamTypes;\n    Sema::ExtParameterInfoBuilder ExtParamInfos;\n    if (SemaRef.SubstParmTypes(D->getLocation(), D->parameters(), nullptr,\n                               TemplateArgs, ParamTypes, &Params,\n                               ExtParamInfos))\n      return nullptr;\n  }\n\n  return NewTInfo;\n}\n\n/// Introduce the instantiated function parameters into the local\n/// instantiation scope, and set the parameter names to those used\n/// in the template.\nstatic bool addInstantiatedParametersToScope(Sema &S, FunctionDecl *Function,\n                                             const FunctionDecl *PatternDecl,\n                                             LocalInstantiationScope &Scope,\n                           const MultiLevelTemplateArgumentList &TemplateArgs) {\n  unsigned FParamIdx = 0;\n  for (unsigned I = 0, N = PatternDecl->getNumParams(); I != N; ++I) {\n    const ParmVarDecl *PatternParam = PatternDecl->getParamDecl(I);\n    if (!PatternParam->isParameterPack()) {\n      // Simple case: not a parameter pack.\n      assert(FParamIdx < Function->getNumParams());\n      ParmVarDecl *FunctionParam = Function->getParamDecl(FParamIdx);\n      FunctionParam->setDeclName(PatternParam->getDeclName());\n      // If the parameter's type is not dependent, update it to match the type\n      // in the pattern. They can differ in top-level cv-qualifiers, and we want\n      // the pattern's type here. If the type is dependent, they can't differ,\n      // per core issue 1668. Substitute into the type from the pattern, in case\n      // it's instantiation-dependent.\n      // FIXME: Updating the type to work around this is at best fragile.\n      if (!PatternDecl->getType()->isDependentType()) {\n        QualType T = S.SubstType(PatternParam->getType(), TemplateArgs,\n                                 FunctionParam->getLocation(),\n                                 FunctionParam->getDeclName());\n        if (T.isNull())\n          return true;\n        FunctionParam->setType(T);\n      }\n\n      Scope.InstantiatedLocal(PatternParam, FunctionParam);\n      ++FParamIdx;\n      continue;\n    }\n\n    // Expand the parameter pack.\n    Scope.MakeInstantiatedLocalArgPack(PatternParam);\n    Optional<unsigned> NumArgumentsInExpansion\n      = S.getNumArgumentsInExpansion(PatternParam->getType(), TemplateArgs);\n    if (NumArgumentsInExpansion) {\n      QualType PatternType =\n          PatternParam->getType()->castAs<PackExpansionType>()->getPattern();\n      for (unsigned Arg = 0; Arg < *NumArgumentsInExpansion; ++Arg) {\n        ParmVarDecl *FunctionParam = Function->getParamDecl(FParamIdx);\n        FunctionParam->setDeclName(PatternParam->getDeclName());\n        if (!PatternDecl->getType()->isDependentType()) {\n          Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(S, Arg);\n          QualType T = S.SubstType(PatternType, TemplateArgs,\n                                   FunctionParam->getLocation(),\n                                   FunctionParam->getDeclName());\n          if (T.isNull())\n            return true;\n          FunctionParam->setType(T);\n        }\n\n        Scope.InstantiatedLocalPackArg(PatternParam, FunctionParam);\n        ++FParamIdx;\n      }\n    }\n  }\n\n  return false;\n}\n\nbool Sema::InstantiateDefaultArgument(SourceLocation CallLoc, FunctionDecl *FD,\n                                      ParmVarDecl *Param) {\n  assert(Param->hasUninstantiatedDefaultArg());\n  Expr *UninstExpr = Param->getUninstantiatedDefaultArg();\n\n  EnterExpressionEvaluationContext EvalContext(\n      *this, ExpressionEvaluationContext::PotentiallyEvaluated, Param);\n\n  // Instantiate the expression.\n  //\n  // FIXME: Pass in a correct Pattern argument, otherwise\n  // getTemplateInstantiationArgs uses the lexical context of FD, e.g.\n  //\n  // template<typename T>\n  // struct A {\n  //   static int FooImpl();\n  //\n  //   template<typename Tp>\n  //   // bug: default argument A<T>::FooImpl() is evaluated with 2-level\n  //   // template argument list [[T], [Tp]], should be [[Tp]].\n  //   friend A<Tp> Foo(int a);\n  // };\n  //\n  // template<typename T>\n  // A<T> Foo(int a = A<T>::FooImpl());\n  MultiLevelTemplateArgumentList TemplateArgs\n    = getTemplateInstantiationArgs(FD, nullptr, /*RelativeToPrimary=*/true);\n\n  InstantiatingTemplate Inst(*this, CallLoc, Param,\n                             TemplateArgs.getInnermost());\n  if (Inst.isInvalid())\n    return true;\n  if (Inst.isAlreadyInstantiating()) {\n    Diag(Param->getBeginLoc(), diag::err_recursive_default_argument) << FD;\n    Param->setInvalidDecl();\n    return true;\n  }\n\n  ExprResult Result;\n  {\n    // C++ [dcl.fct.default]p5:\n    //   The names in the [default argument] expression are bound, and\n    //   the semantic constraints are checked, at the point where the\n    //   default argument expression appears.\n    ContextRAII SavedContext(*this, FD);\n    LocalInstantiationScope Local(*this);\n\n    FunctionDecl *Pattern = FD->getTemplateInstantiationPattern(\n        /*ForDefinition*/ false);\n    if (addInstantiatedParametersToScope(*this, FD, Pattern, Local,\n                                         TemplateArgs))\n      return true;\n\n    runWithSufficientStackSpace(CallLoc, [&] {\n      Result = SubstInitializer(UninstExpr, TemplateArgs,\n                                /*DirectInit*/false);\n    });\n  }\n  if (Result.isInvalid())\n    return true;\n\n  // Check the expression as an initializer for the parameter.\n  InitializedEntity Entity\n    = InitializedEntity::InitializeParameter(Context, Param);\n  InitializationKind Kind = InitializationKind::CreateCopy(\n      Param->getLocation(),\n      /*FIXME:EqualLoc*/ UninstExpr->getBeginLoc());\n  Expr *ResultE = Result.getAs<Expr>();\n\n  InitializationSequence InitSeq(*this, Entity, Kind, ResultE);\n  Result = InitSeq.Perform(*this, Entity, Kind, ResultE);\n  if (Result.isInvalid())\n    return true;\n\n  Result =\n      ActOnFinishFullExpr(Result.getAs<Expr>(), Param->getOuterLocStart(),\n                          /*DiscardedValue*/ false);\n  if (Result.isInvalid())\n    return true;\n\n  // Remember the instantiated default argument.\n  Param->setDefaultArg(Result.getAs<Expr>());\n  if (ASTMutationListener *L = getASTMutationListener())\n    L->DefaultArgumentInstantiated(Param);\n\n  return false;\n}\n\nvoid Sema::InstantiateExceptionSpec(SourceLocation PointOfInstantiation,\n                                    FunctionDecl *Decl) {\n  const FunctionProtoType *Proto = Decl->getType()->castAs<FunctionProtoType>();\n  if (Proto->getExceptionSpecType() != EST_Uninstantiated)\n    return;\n\n  InstantiatingTemplate Inst(*this, PointOfInstantiation, Decl,\n                             InstantiatingTemplate::ExceptionSpecification());\n  if (Inst.isInvalid()) {\n    // We hit the instantiation depth limit. Clear the exception specification\n    // so that our callers don't have to cope with EST_Uninstantiated.\n    UpdateExceptionSpec(Decl, EST_None);\n    return;\n  }\n  if (Inst.isAlreadyInstantiating()) {\n    // This exception specification indirectly depends on itself. Reject.\n    // FIXME: Corresponding rule in the standard?\n    Diag(PointOfInstantiation, diag::err_exception_spec_cycle) << Decl;\n    UpdateExceptionSpec(Decl, EST_None);\n    return;\n  }\n\n  // Enter the scope of this instantiation. We don't use\n  // PushDeclContext because we don't have a scope.\n  Sema::ContextRAII savedContext(*this, Decl);\n  LocalInstantiationScope Scope(*this);\n\n  MultiLevelTemplateArgumentList TemplateArgs =\n    getTemplateInstantiationArgs(Decl, nullptr, /*RelativeToPrimary*/true);\n\n  // FIXME: We can't use getTemplateInstantiationPattern(false) in general\n  // here, because for a non-defining friend declaration in a class template,\n  // we don't store enough information to map back to the friend declaration in\n  // the template.\n  FunctionDecl *Template = Proto->getExceptionSpecTemplate();\n  if (addInstantiatedParametersToScope(*this, Decl, Template, Scope,\n                                       TemplateArgs)) {\n    UpdateExceptionSpec(Decl, EST_None);\n    return;\n  }\n\n  SubstExceptionSpec(Decl, Template->getType()->castAs<FunctionProtoType>(),\n                     TemplateArgs);\n}\n\nbool Sema::CheckInstantiatedFunctionTemplateConstraints(\n    SourceLocation PointOfInstantiation, FunctionDecl *Decl,\n    ArrayRef<TemplateArgument> TemplateArgs,\n    ConstraintSatisfaction &Satisfaction) {\n  // In most cases we're not going to have constraints, so check for that first.\n  FunctionTemplateDecl *Template = Decl->getPrimaryTemplate();\n  // Note - code synthesis context for the constraints check is created\n  // inside CheckConstraintsSatisfaction.\n  SmallVector<const Expr *, 3> TemplateAC;\n  Template->getAssociatedConstraints(TemplateAC);\n  if (TemplateAC.empty()) {\n    Satisfaction.IsSatisfied = true;\n    return false;\n  }\n\n  // Enter the scope of this instantiation. We don't use\n  // PushDeclContext because we don't have a scope.\n  Sema::ContextRAII savedContext(*this, Decl);\n  LocalInstantiationScope Scope(*this);\n\n  // If this is not an explicit specialization - we need to get the instantiated\n  // version of the template arguments and add them to scope for the\n  // substitution.\n  if (Decl->isTemplateInstantiation()) {\n    InstantiatingTemplate Inst(*this, Decl->getPointOfInstantiation(),\n        InstantiatingTemplate::ConstraintsCheck{}, Decl->getPrimaryTemplate(),\n        TemplateArgs, SourceRange());\n    if (Inst.isInvalid())\n      return true;\n    MultiLevelTemplateArgumentList MLTAL(\n        *Decl->getTemplateSpecializationArgs());\n    if (addInstantiatedParametersToScope(\n            *this, Decl, Decl->getPrimaryTemplate()->getTemplatedDecl(),\n            Scope, MLTAL))\n      return true;\n  }\n  Qualifiers ThisQuals;\n  CXXRecordDecl *Record = nullptr;\n  if (auto *Method = dyn_cast<CXXMethodDecl>(Decl)) {\n    ThisQuals = Method->getMethodQualifiers();\n    Record = Method->getParent();\n  }\n  CXXThisScopeRAII ThisScope(*this, Record, ThisQuals, Record != nullptr);\n  return CheckConstraintSatisfaction(Template, TemplateAC, TemplateArgs,\n                                     PointOfInstantiation, Satisfaction);\n}\n\n/// Initializes the common fields of an instantiation function\n/// declaration (New) from the corresponding fields of its template (Tmpl).\n///\n/// \\returns true if there was an error\nbool\nTemplateDeclInstantiator::InitFunctionInstantiation(FunctionDecl *New,\n                                                    FunctionDecl *Tmpl) {\n  New->setImplicit(Tmpl->isImplicit());\n\n  // Forward the mangling number from the template to the instantiated decl.\n  SemaRef.Context.setManglingNumber(New,\n                                    SemaRef.Context.getManglingNumber(Tmpl));\n\n  // If we are performing substituting explicitly-specified template arguments\n  // or deduced template arguments into a function template and we reach this\n  // point, we are now past the point where SFINAE applies and have committed\n  // to keeping the new function template specialization. We therefore\n  // convert the active template instantiation for the function template\n  // into a template instantiation for this specific function template\n  // specialization, which is not a SFINAE context, so that we diagnose any\n  // further errors in the declaration itself.\n  //\n  // FIXME: This is a hack.\n  typedef Sema::CodeSynthesisContext ActiveInstType;\n  ActiveInstType &ActiveInst = SemaRef.CodeSynthesisContexts.back();\n  if (ActiveInst.Kind == ActiveInstType::ExplicitTemplateArgumentSubstitution ||\n      ActiveInst.Kind == ActiveInstType::DeducedTemplateArgumentSubstitution) {\n    if (FunctionTemplateDecl *FunTmpl\n          = dyn_cast<FunctionTemplateDecl>(ActiveInst.Entity)) {\n      assert(FunTmpl->getTemplatedDecl() == Tmpl &&\n             \"Deduction from the wrong function template?\");\n      (void) FunTmpl;\n      SemaRef.InstantiatingSpecializations.erase(\n          {ActiveInst.Entity->getCanonicalDecl(), ActiveInst.Kind});\n      atTemplateEnd(SemaRef.TemplateInstCallbacks, SemaRef, ActiveInst);\n      ActiveInst.Kind = ActiveInstType::TemplateInstantiation;\n      ActiveInst.Entity = New;\n      atTemplateBegin(SemaRef.TemplateInstCallbacks, SemaRef, ActiveInst);\n    }\n  }\n\n  const FunctionProtoType *Proto = Tmpl->getType()->getAs<FunctionProtoType>();\n  assert(Proto && \"Function template without prototype?\");\n\n  if (Proto->hasExceptionSpec() || Proto->getNoReturnAttr()) {\n    FunctionProtoType::ExtProtoInfo EPI = Proto->getExtProtoInfo();\n\n    // DR1330: In C++11, defer instantiation of a non-trivial\n    // exception specification.\n    // DR1484: Local classes and their members are instantiated along with the\n    // containing function.\n    if (SemaRef.getLangOpts().CPlusPlus11 &&\n        EPI.ExceptionSpec.Type != EST_None &&\n        EPI.ExceptionSpec.Type != EST_DynamicNone &&\n        EPI.ExceptionSpec.Type != EST_BasicNoexcept &&\n        !Tmpl->isInLocalScopeForInstantiation()) {\n      FunctionDecl *ExceptionSpecTemplate = Tmpl;\n      if (EPI.ExceptionSpec.Type == EST_Uninstantiated)\n        ExceptionSpecTemplate = EPI.ExceptionSpec.SourceTemplate;\n      ExceptionSpecificationType NewEST = EST_Uninstantiated;\n      if (EPI.ExceptionSpec.Type == EST_Unevaluated)\n        NewEST = EST_Unevaluated;\n\n      // Mark the function has having an uninstantiated exception specification.\n      const FunctionProtoType *NewProto\n        = New->getType()->getAs<FunctionProtoType>();\n      assert(NewProto && \"Template instantiation without function prototype?\");\n      EPI = NewProto->getExtProtoInfo();\n      EPI.ExceptionSpec.Type = NewEST;\n      EPI.ExceptionSpec.SourceDecl = New;\n      EPI.ExceptionSpec.SourceTemplate = ExceptionSpecTemplate;\n      New->setType(SemaRef.Context.getFunctionType(\n          NewProto->getReturnType(), NewProto->getParamTypes(), EPI));\n    } else {\n      Sema::ContextRAII SwitchContext(SemaRef, New);\n      SemaRef.SubstExceptionSpec(New, Proto, TemplateArgs);\n    }\n  }\n\n  // Get the definition. Leaves the variable unchanged if undefined.\n  const FunctionDecl *Definition = Tmpl;\n  Tmpl->isDefined(Definition);\n\n  SemaRef.InstantiateAttrs(TemplateArgs, Definition, New,\n                           LateAttrs, StartingScope);\n\n  return false;\n}\n\n/// Initializes common fields of an instantiated method\n/// declaration (New) from the corresponding fields of its template\n/// (Tmpl).\n///\n/// \\returns true if there was an error\nbool\nTemplateDeclInstantiator::InitMethodInstantiation(CXXMethodDecl *New,\n                                                  CXXMethodDecl *Tmpl) {\n  if (InitFunctionInstantiation(New, Tmpl))\n    return true;\n\n  if (isa<CXXDestructorDecl>(New) && SemaRef.getLangOpts().CPlusPlus11)\n    SemaRef.AdjustDestructorExceptionSpec(cast<CXXDestructorDecl>(New));\n\n  New->setAccess(Tmpl->getAccess());\n  if (Tmpl->isVirtualAsWritten())\n    New->setVirtualAsWritten(true);\n\n  // FIXME: New needs a pointer to Tmpl\n  return false;\n}\n\nbool TemplateDeclInstantiator::SubstDefaultedFunction(FunctionDecl *New,\n                                                      FunctionDecl *Tmpl) {\n  // Transfer across any unqualified lookups.\n  if (auto *DFI = Tmpl->getDefaultedFunctionInfo()) {\n    SmallVector<DeclAccessPair, 32> Lookups;\n    Lookups.reserve(DFI->getUnqualifiedLookups().size());\n    bool AnyChanged = false;\n    for (DeclAccessPair DA : DFI->getUnqualifiedLookups()) {\n      NamedDecl *D = SemaRef.FindInstantiatedDecl(New->getLocation(),\n                                                  DA.getDecl(), TemplateArgs);\n      if (!D)\n        return true;\n      AnyChanged |= (D != DA.getDecl());\n      Lookups.push_back(DeclAccessPair::make(D, DA.getAccess()));\n    }\n\n    // It's unlikely that substitution will change any declarations. Don't\n    // store an unnecessary copy in that case.\n    New->setDefaultedFunctionInfo(\n        AnyChanged ? FunctionDecl::DefaultedFunctionInfo::Create(\n                         SemaRef.Context, Lookups)\n                   : DFI);\n  }\n\n  SemaRef.SetDeclDefaulted(New, Tmpl->getLocation());\n  return false;\n}\n\n/// Instantiate (or find existing instantiation of) a function template with a\n/// given set of template arguments.\n///\n/// Usually this should not be used, and template argument deduction should be\n/// used in its place.\nFunctionDecl *\nSema::InstantiateFunctionDeclaration(FunctionTemplateDecl *FTD,\n                                     const TemplateArgumentList *Args,\n                                     SourceLocation Loc) {\n  FunctionDecl *FD = FTD->getTemplatedDecl();\n\n  sema::TemplateDeductionInfo Info(Loc);\n  InstantiatingTemplate Inst(\n      *this, Loc, FTD, Args->asArray(),\n      CodeSynthesisContext::ExplicitTemplateArgumentSubstitution, Info);\n  if (Inst.isInvalid())\n    return nullptr;\n\n  ContextRAII SavedContext(*this, FD);\n  MultiLevelTemplateArgumentList MArgs(*Args);\n\n  return cast_or_null<FunctionDecl>(SubstDecl(FD, FD->getParent(), MArgs));\n}\n\n/// Instantiate the definition of the given function from its\n/// template.\n///\n/// \\param PointOfInstantiation the point at which the instantiation was\n/// required. Note that this is not precisely a \"point of instantiation\"\n/// for the function, but it's close.\n///\n/// \\param Function the already-instantiated declaration of a\n/// function template specialization or member function of a class template\n/// specialization.\n///\n/// \\param Recursive if true, recursively instantiates any functions that\n/// are required by this instantiation.\n///\n/// \\param DefinitionRequired if true, then we are performing an explicit\n/// instantiation where the body of the function is required. Complain if\n/// there is no such body.\nvoid Sema::InstantiateFunctionDefinition(SourceLocation PointOfInstantiation,\n                                         FunctionDecl *Function,\n                                         bool Recursive,\n                                         bool DefinitionRequired,\n                                         bool AtEndOfTU) {\n  if (Function->isInvalidDecl() || isa<CXXDeductionGuideDecl>(Function))\n    return;\n\n  // Never instantiate an explicit specialization except if it is a class scope\n  // explicit specialization.\n  TemplateSpecializationKind TSK =\n      Function->getTemplateSpecializationKindForInstantiation();\n  if (TSK == TSK_ExplicitSpecialization)\n    return;\n\n  // Don't instantiate a definition if we already have one.\n  const FunctionDecl *ExistingDefn = nullptr;\n  if (Function->isDefined(ExistingDefn,\n                          /*CheckForPendingFriendDefinition=*/true)) {\n    if (ExistingDefn->isThisDeclarationADefinition())\n      return;\n\n    // If we're asked to instantiate a function whose body comes from an\n    // instantiated friend declaration, attach the instantiated body to the\n    // corresponding declaration of the function.\n    assert(ExistingDefn->isThisDeclarationInstantiatedFromAFriendDefinition());\n    Function = const_cast<FunctionDecl*>(ExistingDefn);\n  }\n\n  // Find the function body that we'll be substituting.\n  const FunctionDecl *PatternDecl = Function->getTemplateInstantiationPattern();\n  assert(PatternDecl && \"instantiating a non-template\");\n\n  const FunctionDecl *PatternDef = PatternDecl->getDefinition();\n  Stmt *Pattern = nullptr;\n  if (PatternDef) {\n    Pattern = PatternDef->getBody(PatternDef);\n    PatternDecl = PatternDef;\n    if (PatternDef->willHaveBody())\n      PatternDef = nullptr;\n  }\n\n  // FIXME: We need to track the instantiation stack in order to know which\n  // definitions should be visible within this instantiation.\n  if (DiagnoseUninstantiableTemplate(PointOfInstantiation, Function,\n                                Function->getInstantiatedFromMemberFunction(),\n                                     PatternDecl, PatternDef, TSK,\n                                     /*Complain*/DefinitionRequired)) {\n    if (DefinitionRequired)\n      Function->setInvalidDecl();\n    else if (TSK == TSK_ExplicitInstantiationDefinition) {\n      // Try again at the end of the translation unit (at which point a\n      // definition will be required).\n      assert(!Recursive);\n      Function->setInstantiationIsPending(true);\n      PendingInstantiations.push_back(\n        std::make_pair(Function, PointOfInstantiation));\n    } else if (TSK == TSK_ImplicitInstantiation) {\n      if (AtEndOfTU && !getDiagnostics().hasErrorOccurred() &&\n          !getSourceManager().isInSystemHeader(PatternDecl->getBeginLoc())) {\n        Diag(PointOfInstantiation, diag::warn_func_template_missing)\n          << Function;\n        Diag(PatternDecl->getLocation(), diag::note_forward_template_decl);\n        if (getLangOpts().CPlusPlus11)\n          Diag(PointOfInstantiation, diag::note_inst_declaration_hint)\n            << Function;\n      }\n    }\n\n    return;\n  }\n\n  // Postpone late parsed template instantiations.\n  if (PatternDecl->isLateTemplateParsed() &&\n      !LateTemplateParser) {\n    Function->setInstantiationIsPending(true);\n    LateParsedInstantiations.push_back(\n        std::make_pair(Function, PointOfInstantiation));\n    return;\n  }\n\n  llvm::TimeTraceScope TimeScope(\"InstantiateFunction\", [&]() {\n    std::string Name;\n    llvm::raw_string_ostream OS(Name);\n    Function->getNameForDiagnostic(OS, getPrintingPolicy(),\n                                   /*Qualified=*/true);\n    return Name;\n  });\n\n  // If we're performing recursive template instantiation, create our own\n  // queue of pending implicit instantiations that we will instantiate later,\n  // while we're still within our own instantiation context.\n  // This has to happen before LateTemplateParser below is called, so that\n  // it marks vtables used in late parsed templates as used.\n  GlobalEagerInstantiationScope GlobalInstantiations(*this,\n                                                     /*Enabled=*/Recursive);\n  LocalEagerInstantiationScope LocalInstantiations(*this);\n\n  // Call the LateTemplateParser callback if there is a need to late parse\n  // a templated function definition.\n  if (!Pattern && PatternDecl->isLateTemplateParsed() &&\n      LateTemplateParser) {\n    // FIXME: Optimize to allow individual templates to be deserialized.\n    if (PatternDecl->isFromASTFile())\n      ExternalSource->ReadLateParsedTemplates(LateParsedTemplateMap);\n\n    auto LPTIter = LateParsedTemplateMap.find(PatternDecl);\n    assert(LPTIter != LateParsedTemplateMap.end() &&\n           \"missing LateParsedTemplate\");\n    LateTemplateParser(OpaqueParser, *LPTIter->second);\n    Pattern = PatternDecl->getBody(PatternDecl);\n  }\n\n  // Note, we should never try to instantiate a deleted function template.\n  assert((Pattern || PatternDecl->isDefaulted() ||\n          PatternDecl->hasSkippedBody()) &&\n         \"unexpected kind of function template definition\");\n\n  // C++1y [temp.explicit]p10:\n  //   Except for inline functions, declarations with types deduced from their\n  //   initializer or return value, and class template specializations, other\n  //   explicit instantiation declarations have the effect of suppressing the\n  //   implicit instantiation of the entity to which they refer.\n  if (TSK == TSK_ExplicitInstantiationDeclaration &&\n      !PatternDecl->isInlined() &&\n      !PatternDecl->getReturnType()->getContainedAutoType())\n    return;\n\n  if (PatternDecl->isInlined()) {\n    // Function, and all later redeclarations of it (from imported modules,\n    // for instance), are now implicitly inline.\n    for (auto *D = Function->getMostRecentDecl(); /**/;\n         D = D->getPreviousDecl()) {\n      D->setImplicitlyInline();\n      if (D == Function)\n        break;\n    }\n  }\n\n  InstantiatingTemplate Inst(*this, PointOfInstantiation, Function);\n  if (Inst.isInvalid() || Inst.isAlreadyInstantiating())\n    return;\n  PrettyDeclStackTraceEntry CrashInfo(Context, Function, SourceLocation(),\n                                      \"instantiating function definition\");\n\n  // The instantiation is visible here, even if it was first declared in an\n  // unimported module.\n  Function->setVisibleDespiteOwningModule();\n\n  // Copy the inner loc start from the pattern.\n  Function->setInnerLocStart(PatternDecl->getInnerLocStart());\n\n  EnterExpressionEvaluationContext EvalContext(\n      *this, Sema::ExpressionEvaluationContext::PotentiallyEvaluated);\n\n  // Introduce a new scope where local variable instantiations will be\n  // recorded, unless we're actually a member function within a local\n  // class, in which case we need to merge our results with the parent\n  // scope (of the enclosing function).\n  bool MergeWithParentScope = false;\n  if (CXXRecordDecl *Rec = dyn_cast<CXXRecordDecl>(Function->getDeclContext()))\n    MergeWithParentScope = Rec->isLocalClass();\n\n  LocalInstantiationScope Scope(*this, MergeWithParentScope);\n\n  if (PatternDecl->isDefaulted())\n    SetDeclDefaulted(Function, PatternDecl->getLocation());\n  else {\n    MultiLevelTemplateArgumentList TemplateArgs =\n      getTemplateInstantiationArgs(Function, nullptr, false, PatternDecl);\n\n    // Substitute into the qualifier; we can get a substitution failure here\n    // through evil use of alias templates.\n    // FIXME: Is CurContext correct for this? Should we go to the (instantiation\n    // of the) lexical context of the pattern?\n    SubstQualifier(*this, PatternDecl, Function, TemplateArgs);\n\n    ActOnStartOfFunctionDef(nullptr, Function);\n\n    // Enter the scope of this instantiation. We don't use\n    // PushDeclContext because we don't have a scope.\n    Sema::ContextRAII savedContext(*this, Function);\n\n    if (addInstantiatedParametersToScope(*this, Function, PatternDecl, Scope,\n                                         TemplateArgs))\n      return;\n\n    StmtResult Body;\n    if (PatternDecl->hasSkippedBody()) {\n      ActOnSkippedFunctionBody(Function);\n      Body = nullptr;\n    } else {\n      if (CXXConstructorDecl *Ctor = dyn_cast<CXXConstructorDecl>(Function)) {\n        // If this is a constructor, instantiate the member initializers.\n        InstantiateMemInitializers(Ctor, cast<CXXConstructorDecl>(PatternDecl),\n                                   TemplateArgs);\n\n        // If this is an MS ABI dllexport default constructor, instantiate any\n        // default arguments.\n        if (Context.getTargetInfo().getCXXABI().isMicrosoft() &&\n            Ctor->isDefaultConstructor()) {\n          InstantiateDefaultCtorDefaultArgs(Ctor);\n        }\n      }\n\n      // Instantiate the function body.\n      Body = SubstStmt(Pattern, TemplateArgs);\n\n      if (Body.isInvalid())\n        Function->setInvalidDecl();\n    }\n    // FIXME: finishing the function body while in an expression evaluation\n    // context seems wrong. Investigate more.\n    ActOnFinishFunctionBody(Function, Body.get(), /*IsInstantiation=*/true);\n\n    PerformDependentDiagnostics(PatternDecl, TemplateArgs);\n\n    if (auto *Listener = getASTMutationListener())\n      Listener->FunctionDefinitionInstantiated(Function);\n\n    savedContext.pop();\n  }\n\n  DeclGroupRef DG(Function);\n  Consumer.HandleTopLevelDecl(DG);\n\n  // This class may have local implicit instantiations that need to be\n  // instantiation within this scope.\n  LocalInstantiations.perform();\n  Scope.Exit();\n  GlobalInstantiations.perform();\n}\n\nVarTemplateSpecializationDecl *Sema::BuildVarTemplateInstantiation(\n    VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n    const TemplateArgumentList &TemplateArgList,\n    const TemplateArgumentListInfo &TemplateArgsInfo,\n    SmallVectorImpl<TemplateArgument> &Converted,\n    SourceLocation PointOfInstantiation,\n    LateInstantiatedAttrVec *LateAttrs,\n    LocalInstantiationScope *StartingScope) {\n  if (FromVar->isInvalidDecl())\n    return nullptr;\n\n  InstantiatingTemplate Inst(*this, PointOfInstantiation, FromVar);\n  if (Inst.isInvalid())\n    return nullptr;\n\n  MultiLevelTemplateArgumentList TemplateArgLists;\n  TemplateArgLists.addOuterTemplateArguments(&TemplateArgList);\n\n  // Instantiate the first declaration of the variable template: for a partial\n  // specialization of a static data member template, the first declaration may\n  // or may not be the declaration in the class; if it's in the class, we want\n  // to instantiate a member in the class (a declaration), and if it's outside,\n  // we want to instantiate a definition.\n  //\n  // If we're instantiating an explicitly-specialized member template or member\n  // partial specialization, don't do this. The member specialization completely\n  // replaces the original declaration in this case.\n  bool IsMemberSpec = false;\n  if (VarTemplatePartialSpecializationDecl *PartialSpec =\n          dyn_cast<VarTemplatePartialSpecializationDecl>(FromVar))\n    IsMemberSpec = PartialSpec->isMemberSpecialization();\n  else if (VarTemplateDecl *FromTemplate = FromVar->getDescribedVarTemplate())\n    IsMemberSpec = FromTemplate->isMemberSpecialization();\n  if (!IsMemberSpec)\n    FromVar = FromVar->getFirstDecl();\n\n  MultiLevelTemplateArgumentList MultiLevelList(TemplateArgList);\n  TemplateDeclInstantiator Instantiator(*this, FromVar->getDeclContext(),\n                                        MultiLevelList);\n\n  // TODO: Set LateAttrs and StartingScope ...\n\n  return cast_or_null<VarTemplateSpecializationDecl>(\n      Instantiator.VisitVarTemplateSpecializationDecl(\n          VarTemplate, FromVar, TemplateArgsInfo, Converted));\n}\n\n/// Instantiates a variable template specialization by completing it\n/// with appropriate type information and initializer.\nVarTemplateSpecializationDecl *Sema::CompleteVarTemplateSpecializationDecl(\n    VarTemplateSpecializationDecl *VarSpec, VarDecl *PatternDecl,\n    const MultiLevelTemplateArgumentList &TemplateArgs) {\n  assert(PatternDecl->isThisDeclarationADefinition() &&\n         \"don't have a definition to instantiate from\");\n\n  // Do substitution on the type of the declaration\n  TypeSourceInfo *DI =\n      SubstType(PatternDecl->getTypeSourceInfo(), TemplateArgs,\n                PatternDecl->getTypeSpecStartLoc(), PatternDecl->getDeclName());\n  if (!DI)\n    return nullptr;\n\n  // Update the type of this variable template specialization.\n  VarSpec->setType(DI->getType());\n\n  // Convert the declaration into a definition now.\n  VarSpec->setCompleteDefinition();\n\n  // Instantiate the initializer.\n  InstantiateVariableInitializer(VarSpec, PatternDecl, TemplateArgs);\n\n  if (getLangOpts().OpenCL)\n    deduceOpenCLAddressSpace(VarSpec);\n\n  return VarSpec;\n}\n\n/// BuildVariableInstantiation - Used after a new variable has been created.\n/// Sets basic variable data and decides whether to postpone the\n/// variable instantiation.\nvoid Sema::BuildVariableInstantiation(\n    VarDecl *NewVar, VarDecl *OldVar,\n    const MultiLevelTemplateArgumentList &TemplateArgs,\n    LateInstantiatedAttrVec *LateAttrs, DeclContext *Owner,\n    LocalInstantiationScope *StartingScope,\n    bool InstantiatingVarTemplate,\n    VarTemplateSpecializationDecl *PrevDeclForVarTemplateSpecialization) {\n  // Instantiating a partial specialization to produce a partial\n  // specialization.\n  bool InstantiatingVarTemplatePartialSpec =\n      isa<VarTemplatePartialSpecializationDecl>(OldVar) &&\n      isa<VarTemplatePartialSpecializationDecl>(NewVar);\n  // Instantiating from a variable template (or partial specialization) to\n  // produce a variable template specialization.\n  bool InstantiatingSpecFromTemplate =\n      isa<VarTemplateSpecializationDecl>(NewVar) &&\n      (OldVar->getDescribedVarTemplate() ||\n       isa<VarTemplatePartialSpecializationDecl>(OldVar));\n\n  // If we are instantiating a local extern declaration, the\n  // instantiation belongs lexically to the containing function.\n  // If we are instantiating a static data member defined\n  // out-of-line, the instantiation will have the same lexical\n  // context (which will be a namespace scope) as the template.\n  if (OldVar->isLocalExternDecl()) {\n    NewVar->setLocalExternDecl();\n    NewVar->setLexicalDeclContext(Owner);\n  } else if (OldVar->isOutOfLine())\n    NewVar->setLexicalDeclContext(OldVar->getLexicalDeclContext());\n  NewVar->setTSCSpec(OldVar->getTSCSpec());\n  NewVar->setInitStyle(OldVar->getInitStyle());\n  NewVar->setCXXForRangeDecl(OldVar->isCXXForRangeDecl());\n  NewVar->setObjCForDecl(OldVar->isObjCForDecl());\n  NewVar->setConstexpr(OldVar->isConstexpr());\n  MaybeAddCUDAConstantAttr(NewVar);\n  NewVar->setInitCapture(OldVar->isInitCapture());\n  NewVar->setPreviousDeclInSameBlockScope(\n      OldVar->isPreviousDeclInSameBlockScope());\n  NewVar->setAccess(OldVar->getAccess());\n\n  if (!OldVar->isStaticDataMember()) {\n    if (OldVar->isUsed(false))\n      NewVar->setIsUsed();\n    NewVar->setReferenced(OldVar->isReferenced());\n  }\n\n  InstantiateAttrs(TemplateArgs, OldVar, NewVar, LateAttrs, StartingScope);\n\n  LookupResult Previous(\n      *this, NewVar->getDeclName(), NewVar->getLocation(),\n      NewVar->isLocalExternDecl() ? Sema::LookupRedeclarationWithLinkage\n                                  : Sema::LookupOrdinaryName,\n      NewVar->isLocalExternDecl() ? Sema::ForExternalRedeclaration\n                                  : forRedeclarationInCurContext());\n\n  if (NewVar->isLocalExternDecl() && OldVar->getPreviousDecl() &&\n      (!OldVar->getPreviousDecl()->getDeclContext()->isDependentContext() ||\n       OldVar->getPreviousDecl()->getDeclContext()==OldVar->getDeclContext())) {\n    // We have a previous declaration. Use that one, so we merge with the\n    // right type.\n    if (NamedDecl *NewPrev = FindInstantiatedDecl(\n            NewVar->getLocation(), OldVar->getPreviousDecl(), TemplateArgs))\n      Previous.addDecl(NewPrev);\n  } else if (!isa<VarTemplateSpecializationDecl>(NewVar) &&\n             OldVar->hasLinkage()) {\n    LookupQualifiedName(Previous, NewVar->getDeclContext(), false);\n  } else if (PrevDeclForVarTemplateSpecialization) {\n    Previous.addDecl(PrevDeclForVarTemplateSpecialization);\n  }\n  CheckVariableDeclaration(NewVar, Previous);\n\n  if (!InstantiatingVarTemplate) {\n    NewVar->getLexicalDeclContext()->addHiddenDecl(NewVar);\n    if (!NewVar->isLocalExternDecl() || !NewVar->getPreviousDecl())\n      NewVar->getDeclContext()->makeDeclVisibleInContext(NewVar);\n  }\n\n  if (!OldVar->isOutOfLine()) {\n    if (NewVar->getDeclContext()->isFunctionOrMethod())\n      CurrentInstantiationScope->InstantiatedLocal(OldVar, NewVar);\n  }\n\n  // Link instantiations of static data members back to the template from\n  // which they were instantiated.\n  //\n  // Don't do this when instantiating a template (we link the template itself\n  // back in that case) nor when instantiating a static data member template\n  // (that's not a member specialization).\n  if (NewVar->isStaticDataMember() && !InstantiatingVarTemplate &&\n      !InstantiatingSpecFromTemplate)\n    NewVar->setInstantiationOfStaticDataMember(OldVar,\n                                               TSK_ImplicitInstantiation);\n\n  // If the pattern is an (in-class) explicit specialization, then the result\n  // is also an explicit specialization.\n  if (VarTemplateSpecializationDecl *OldVTSD =\n          dyn_cast<VarTemplateSpecializationDecl>(OldVar)) {\n    if (OldVTSD->getSpecializationKind() == TSK_ExplicitSpecialization &&\n        !isa<VarTemplatePartialSpecializationDecl>(OldVTSD))\n      cast<VarTemplateSpecializationDecl>(NewVar)->setSpecializationKind(\n          TSK_ExplicitSpecialization);\n  }\n\n  // Forward the mangling number from the template to the instantiated decl.\n  Context.setManglingNumber(NewVar, Context.getManglingNumber(OldVar));\n  Context.setStaticLocalNumber(NewVar, Context.getStaticLocalNumber(OldVar));\n\n  // Figure out whether to eagerly instantiate the initializer.\n  if (InstantiatingVarTemplate || InstantiatingVarTemplatePartialSpec) {\n    // We're producing a template. Don't instantiate the initializer yet.\n  } else if (NewVar->getType()->isUndeducedType()) {\n    // We need the type to complete the declaration of the variable.\n    InstantiateVariableInitializer(NewVar, OldVar, TemplateArgs);\n  } else if (InstantiatingSpecFromTemplate ||\n             (OldVar->isInline() && OldVar->isThisDeclarationADefinition() &&\n              !NewVar->isThisDeclarationADefinition())) {\n    // Delay instantiation of the initializer for variable template\n    // specializations or inline static data members until a definition of the\n    // variable is needed.\n  } else {\n    InstantiateVariableInitializer(NewVar, OldVar, TemplateArgs);\n  }\n\n  // Diagnose unused local variables with dependent types, where the diagnostic\n  // will have been deferred.\n  if (!NewVar->isInvalidDecl() &&\n      NewVar->getDeclContext()->isFunctionOrMethod() &&\n      OldVar->getType()->isDependentType())\n    DiagnoseUnusedDecl(NewVar);\n}\n\n/// Instantiate the initializer of a variable.\nvoid Sema::InstantiateVariableInitializer(\n    VarDecl *Var, VarDecl *OldVar,\n    const MultiLevelTemplateArgumentList &TemplateArgs) {\n  if (ASTMutationListener *L = getASTContext().getASTMutationListener())\n    L->VariableDefinitionInstantiated(Var);\n\n  // We propagate the 'inline' flag with the initializer, because it\n  // would otherwise imply that the variable is a definition for a\n  // non-static data member.\n  if (OldVar->isInlineSpecified())\n    Var->setInlineSpecified();\n  else if (OldVar->isInline())\n    Var->setImplicitlyInline();\n\n  if (OldVar->getInit()) {\n    EnterExpressionEvaluationContext Evaluated(\n        *this, Sema::ExpressionEvaluationContext::PotentiallyEvaluated, Var);\n\n    // Instantiate the initializer.\n    ExprResult Init;\n\n    {\n      ContextRAII SwitchContext(*this, Var->getDeclContext());\n      Init = SubstInitializer(OldVar->getInit(), TemplateArgs,\n                              OldVar->getInitStyle() == VarDecl::CallInit);\n    }\n\n    if (!Init.isInvalid()) {\n      Expr *InitExpr = Init.get();\n\n      if (Var->hasAttr<DLLImportAttr>() &&\n          (!InitExpr ||\n           !InitExpr->isConstantInitializer(getASTContext(), false))) {\n        // Do not dynamically initialize dllimport variables.\n      } else if (InitExpr) {\n        bool DirectInit = OldVar->isDirectInit();\n        AddInitializerToDecl(Var, InitExpr, DirectInit);\n      } else\n        ActOnUninitializedDecl(Var);\n    } else {\n      // FIXME: Not too happy about invalidating the declaration\n      // because of a bogus initializer.\n      Var->setInvalidDecl();\n    }\n  } else {\n    // `inline` variables are a definition and declaration all in one; we won't\n    // pick up an initializer from anywhere else.\n    if (Var->isStaticDataMember() && !Var->isInline()) {\n      if (!Var->isOutOfLine())\n        return;\n\n      // If the declaration inside the class had an initializer, don't add\n      // another one to the out-of-line definition.\n      if (OldVar->getFirstDecl()->hasInit())\n        return;\n    }\n\n    // We'll add an initializer to a for-range declaration later.\n    if (Var->isCXXForRangeDecl() || Var->isObjCForDecl())\n      return;\n\n    ActOnUninitializedDecl(Var);\n  }\n\n  if (getLangOpts().CUDA)\n    checkAllowedCUDAInitializer(Var);\n}\n\n/// Instantiate the definition of the given variable from its\n/// template.\n///\n/// \\param PointOfInstantiation the point at which the instantiation was\n/// required. Note that this is not precisely a \"point of instantiation\"\n/// for the variable, but it's close.\n///\n/// \\param Var the already-instantiated declaration of a templated variable.\n///\n/// \\param Recursive if true, recursively instantiates any functions that\n/// are required by this instantiation.\n///\n/// \\param DefinitionRequired if true, then we are performing an explicit\n/// instantiation where a definition of the variable is required. Complain\n/// if there is no such definition.\nvoid Sema::InstantiateVariableDefinition(SourceLocation PointOfInstantiation,\n                                         VarDecl *Var, bool Recursive,\n                                      bool DefinitionRequired, bool AtEndOfTU) {\n  if (Var->isInvalidDecl())\n    return;\n\n  // Never instantiate an explicitly-specialized entity.\n  TemplateSpecializationKind TSK =\n      Var->getTemplateSpecializationKindForInstantiation();\n  if (TSK == TSK_ExplicitSpecialization)\n    return;\n\n  // Find the pattern and the arguments to substitute into it.\n  VarDecl *PatternDecl = Var->getTemplateInstantiationPattern();\n  assert(PatternDecl && \"no pattern for templated variable\");\n  MultiLevelTemplateArgumentList TemplateArgs =\n      getTemplateInstantiationArgs(Var);\n\n  VarTemplateSpecializationDecl *VarSpec =\n      dyn_cast<VarTemplateSpecializationDecl>(Var);\n  if (VarSpec) {\n    // If this is a static data member template, there might be an\n    // uninstantiated initializer on the declaration. If so, instantiate\n    // it now.\n    //\n    // FIXME: This largely duplicates what we would do below. The difference\n    // is that along this path we may instantiate an initializer from an\n    // in-class declaration of the template and instantiate the definition\n    // from a separate out-of-class definition.\n    if (PatternDecl->isStaticDataMember() &&\n        (PatternDecl = PatternDecl->getFirstDecl())->hasInit() &&\n        !Var->hasInit()) {\n      // FIXME: Factor out the duplicated instantiation context setup/tear down\n      // code here.\n      InstantiatingTemplate Inst(*this, PointOfInstantiation, Var);\n      if (Inst.isInvalid() || Inst.isAlreadyInstantiating())\n        return;\n      PrettyDeclStackTraceEntry CrashInfo(Context, Var, SourceLocation(),\n                                          \"instantiating variable initializer\");\n\n      // The instantiation is visible here, even if it was first declared in an\n      // unimported module.\n      Var->setVisibleDespiteOwningModule();\n\n      // If we're performing recursive template instantiation, create our own\n      // queue of pending implicit instantiations that we will instantiate\n      // later, while we're still within our own instantiation context.\n      GlobalEagerInstantiationScope GlobalInstantiations(*this,\n                                                         /*Enabled=*/Recursive);\n      LocalInstantiationScope Local(*this);\n      LocalEagerInstantiationScope LocalInstantiations(*this);\n\n      // Enter the scope of this instantiation. We don't use\n      // PushDeclContext because we don't have a scope.\n      ContextRAII PreviousContext(*this, Var->getDeclContext());\n      InstantiateVariableInitializer(Var, PatternDecl, TemplateArgs);\n      PreviousContext.pop();\n\n      // This variable may have local implicit instantiations that need to be\n      // instantiated within this scope.\n      LocalInstantiations.perform();\n      Local.Exit();\n      GlobalInstantiations.perform();\n    }\n  } else {\n    assert(Var->isStaticDataMember() && PatternDecl->isStaticDataMember() &&\n           \"not a static data member?\");\n  }\n\n  VarDecl *Def = PatternDecl->getDefinition(getASTContext());\n\n  // If we don't have a definition of the variable template, we won't perform\n  // any instantiation. Rather, we rely on the user to instantiate this\n  // definition (or provide a specialization for it) in another translation\n  // unit.\n  if (!Def && !DefinitionRequired) {\n    if (TSK == TSK_ExplicitInstantiationDefinition) {\n      PendingInstantiations.push_back(\n        std::make_pair(Var, PointOfInstantiation));\n    } else if (TSK == TSK_ImplicitInstantiation) {\n      // Warn about missing definition at the end of translation unit.\n      if (AtEndOfTU && !getDiagnostics().hasErrorOccurred() &&\n          !getSourceManager().isInSystemHeader(PatternDecl->getBeginLoc())) {\n        Diag(PointOfInstantiation, diag::warn_var_template_missing)\n          << Var;\n        Diag(PatternDecl->getLocation(), diag::note_forward_template_decl);\n        if (getLangOpts().CPlusPlus11)\n          Diag(PointOfInstantiation, diag::note_inst_declaration_hint) << Var;\n      }\n      return;\n    }\n  }\n\n  // FIXME: We need to track the instantiation stack in order to know which\n  // definitions should be visible within this instantiation.\n  // FIXME: Produce diagnostics when Var->getInstantiatedFromStaticDataMember().\n  if (DiagnoseUninstantiableTemplate(PointOfInstantiation, Var,\n                                     /*InstantiatedFromMember*/false,\n                                     PatternDecl, Def, TSK,\n                                     /*Complain*/DefinitionRequired))\n    return;\n\n  // C++11 [temp.explicit]p10:\n  //   Except for inline functions, const variables of literal types, variables\n  //   of reference types, [...] explicit instantiation declarations\n  //   have the effect of suppressing the implicit instantiation of the entity\n  //   to which they refer.\n  //\n  // FIXME: That's not exactly the same as \"might be usable in constant\n  // expressions\", which only allows constexpr variables and const integral\n  // types, not arbitrary const literal types.\n  if (TSK == TSK_ExplicitInstantiationDeclaration &&\n      !Var->mightBeUsableInConstantExpressions(getASTContext()))\n    return;\n\n  // Make sure to pass the instantiated variable to the consumer at the end.\n  struct PassToConsumerRAII {\n    ASTConsumer &Consumer;\n    VarDecl *Var;\n\n    PassToConsumerRAII(ASTConsumer &Consumer, VarDecl *Var)\n      : Consumer(Consumer), Var(Var) { }\n\n    ~PassToConsumerRAII() {\n      Consumer.HandleCXXStaticMemberVarInstantiation(Var);\n    }\n  } PassToConsumerRAII(Consumer, Var);\n\n  // If we already have a definition, we're done.\n  if (VarDecl *Def = Var->getDefinition()) {\n    // We may be explicitly instantiating something we've already implicitly\n    // instantiated.\n    Def->setTemplateSpecializationKind(Var->getTemplateSpecializationKind(),\n                                       PointOfInstantiation);\n    return;\n  }\n\n  InstantiatingTemplate Inst(*this, PointOfInstantiation, Var);\n  if (Inst.isInvalid() || Inst.isAlreadyInstantiating())\n    return;\n  PrettyDeclStackTraceEntry CrashInfo(Context, Var, SourceLocation(),\n                                      \"instantiating variable definition\");\n\n  // If we're performing recursive template instantiation, create our own\n  // queue of pending implicit instantiations that we will instantiate later,\n  // while we're still within our own instantiation context.\n  GlobalEagerInstantiationScope GlobalInstantiations(*this,\n                                                     /*Enabled=*/Recursive);\n\n  // Enter the scope of this instantiation. We don't use\n  // PushDeclContext because we don't have a scope.\n  ContextRAII PreviousContext(*this, Var->getDeclContext());\n  LocalInstantiationScope Local(*this);\n\n  LocalEagerInstantiationScope LocalInstantiations(*this);\n\n  VarDecl *OldVar = Var;\n  if (Def->isStaticDataMember() && !Def->isOutOfLine()) {\n    // We're instantiating an inline static data member whose definition was\n    // provided inside the class.\n    InstantiateVariableInitializer(Var, Def, TemplateArgs);\n  } else if (!VarSpec) {\n    Var = cast_or_null<VarDecl>(SubstDecl(Def, Var->getDeclContext(),\n                                          TemplateArgs));\n  } else if (Var->isStaticDataMember() &&\n             Var->getLexicalDeclContext()->isRecord()) {\n    // We need to instantiate the definition of a static data member template,\n    // and all we have is the in-class declaration of it. Instantiate a separate\n    // declaration of the definition.\n    TemplateDeclInstantiator Instantiator(*this, Var->getDeclContext(),\n                                          TemplateArgs);\n    Var = cast_or_null<VarDecl>(Instantiator.VisitVarTemplateSpecializationDecl(\n        VarSpec->getSpecializedTemplate(), Def, VarSpec->getTemplateArgsInfo(),\n        VarSpec->getTemplateArgs().asArray(), VarSpec));\n    if (Var) {\n      llvm::PointerUnion<VarTemplateDecl *,\n                         VarTemplatePartialSpecializationDecl *> PatternPtr =\n          VarSpec->getSpecializedTemplateOrPartial();\n      if (VarTemplatePartialSpecializationDecl *Partial =\n          PatternPtr.dyn_cast<VarTemplatePartialSpecializationDecl *>())\n        cast<VarTemplateSpecializationDecl>(Var)->setInstantiationOf(\n            Partial, &VarSpec->getTemplateInstantiationArgs());\n\n      // Attach the initializer.\n      InstantiateVariableInitializer(Var, Def, TemplateArgs);\n    }\n  } else\n    // Complete the existing variable's definition with an appropriately\n    // substituted type and initializer.\n    Var = CompleteVarTemplateSpecializationDecl(VarSpec, Def, TemplateArgs);\n\n  PreviousContext.pop();\n\n  if (Var) {\n    PassToConsumerRAII.Var = Var;\n    Var->setTemplateSpecializationKind(OldVar->getTemplateSpecializationKind(),\n                                       OldVar->getPointOfInstantiation());\n  }\n\n  // This variable may have local implicit instantiations that need to be\n  // instantiated within this scope.\n  LocalInstantiations.perform();\n  Local.Exit();\n  GlobalInstantiations.perform();\n}\n\nvoid\nSema::InstantiateMemInitializers(CXXConstructorDecl *New,\n                                 const CXXConstructorDecl *Tmpl,\n                           const MultiLevelTemplateArgumentList &TemplateArgs) {\n\n  SmallVector<CXXCtorInitializer*, 4> NewInits;\n  bool AnyErrors = Tmpl->isInvalidDecl();\n\n  // Instantiate all the initializers.\n  for (const auto *Init : Tmpl->inits()) {\n    // Only instantiate written initializers, let Sema re-construct implicit\n    // ones.\n    if (!Init->isWritten())\n      continue;\n\n    SourceLocation EllipsisLoc;\n\n    if (Init->isPackExpansion()) {\n      // This is a pack expansion. We should expand it now.\n      TypeLoc BaseTL = Init->getTypeSourceInfo()->getTypeLoc();\n      SmallVector<UnexpandedParameterPack, 4> Unexpanded;\n      collectUnexpandedParameterPacks(BaseTL, Unexpanded);\n      collectUnexpandedParameterPacks(Init->getInit(), Unexpanded);\n      bool ShouldExpand = false;\n      bool RetainExpansion = false;\n      Optional<unsigned> NumExpansions;\n      if (CheckParameterPacksForExpansion(Init->getEllipsisLoc(),\n                                          BaseTL.getSourceRange(),\n                                          Unexpanded,\n                                          TemplateArgs, ShouldExpand,\n                                          RetainExpansion,\n                                          NumExpansions)) {\n        AnyErrors = true;\n        New->setInvalidDecl();\n        continue;\n      }\n      assert(ShouldExpand && \"Partial instantiation of base initializer?\");\n\n      // Loop over all of the arguments in the argument pack(s),\n      for (unsigned I = 0; I != *NumExpansions; ++I) {\n        Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(*this, I);\n\n        // Instantiate the initializer.\n        ExprResult TempInit = SubstInitializer(Init->getInit(), TemplateArgs,\n                                               /*CXXDirectInit=*/true);\n        if (TempInit.isInvalid()) {\n          AnyErrors = true;\n          break;\n        }\n\n        // Instantiate the base type.\n        TypeSourceInfo *BaseTInfo = SubstType(Init->getTypeSourceInfo(),\n                                              TemplateArgs,\n                                              Init->getSourceLocation(),\n                                              New->getDeclName());\n        if (!BaseTInfo) {\n          AnyErrors = true;\n          break;\n        }\n\n        // Build the initializer.\n        MemInitResult NewInit = BuildBaseInitializer(BaseTInfo->getType(),\n                                                     BaseTInfo, TempInit.get(),\n                                                     New->getParent(),\n                                                     SourceLocation());\n        if (NewInit.isInvalid()) {\n          AnyErrors = true;\n          break;\n        }\n\n        NewInits.push_back(NewInit.get());\n      }\n\n      continue;\n    }\n\n    // Instantiate the initializer.\n    ExprResult TempInit = SubstInitializer(Init->getInit(), TemplateArgs,\n                                           /*CXXDirectInit=*/true);\n    if (TempInit.isInvalid()) {\n      AnyErrors = true;\n      continue;\n    }\n\n    MemInitResult NewInit;\n    if (Init->isDelegatingInitializer() || Init->isBaseInitializer()) {\n      TypeSourceInfo *TInfo = SubstType(Init->getTypeSourceInfo(),\n                                        TemplateArgs,\n                                        Init->getSourceLocation(),\n                                        New->getDeclName());\n      if (!TInfo) {\n        AnyErrors = true;\n        New->setInvalidDecl();\n        continue;\n      }\n\n      if (Init->isBaseInitializer())\n        NewInit = BuildBaseInitializer(TInfo->getType(), TInfo, TempInit.get(),\n                                       New->getParent(), EllipsisLoc);\n      else\n        NewInit = BuildDelegatingInitializer(TInfo, TempInit.get(),\n                                  cast<CXXRecordDecl>(CurContext->getParent()));\n    } else if (Init->isMemberInitializer()) {\n      FieldDecl *Member = cast_or_null<FieldDecl>(FindInstantiatedDecl(\n                                                     Init->getMemberLocation(),\n                                                     Init->getMember(),\n                                                     TemplateArgs));\n      if (!Member) {\n        AnyErrors = true;\n        New->setInvalidDecl();\n        continue;\n      }\n\n      NewInit = BuildMemberInitializer(Member, TempInit.get(),\n                                       Init->getSourceLocation());\n    } else if (Init->isIndirectMemberInitializer()) {\n      IndirectFieldDecl *IndirectMember =\n         cast_or_null<IndirectFieldDecl>(FindInstantiatedDecl(\n                                 Init->getMemberLocation(),\n                                 Init->getIndirectMember(), TemplateArgs));\n\n      if (!IndirectMember) {\n        AnyErrors = true;\n        New->setInvalidDecl();\n        continue;\n      }\n\n      NewInit = BuildMemberInitializer(IndirectMember, TempInit.get(),\n                                       Init->getSourceLocation());\n    }\n\n    if (NewInit.isInvalid()) {\n      AnyErrors = true;\n      New->setInvalidDecl();\n    } else {\n      NewInits.push_back(NewInit.get());\n    }\n  }\n\n  // Assign all the initializers to the new constructor.\n  ActOnMemInitializers(New,\n                       /*FIXME: ColonLoc */\n                       SourceLocation(),\n                       NewInits,\n                       AnyErrors);\n}\n\n// TODO: this could be templated if the various decl types used the\n// same method name.\nstatic bool isInstantiationOf(ClassTemplateDecl *Pattern,\n                              ClassTemplateDecl *Instance) {\n  Pattern = Pattern->getCanonicalDecl();\n\n  do {\n    Instance = Instance->getCanonicalDecl();\n    if (Pattern == Instance) return true;\n    Instance = Instance->getInstantiatedFromMemberTemplate();\n  } while (Instance);\n\n  return false;\n}\n\nstatic bool isInstantiationOf(FunctionTemplateDecl *Pattern,\n                              FunctionTemplateDecl *Instance) {\n  Pattern = Pattern->getCanonicalDecl();\n\n  do {\n    Instance = Instance->getCanonicalDecl();\n    if (Pattern == Instance) return true;\n    Instance = Instance->getInstantiatedFromMemberTemplate();\n  } while (Instance);\n\n  return false;\n}\n\nstatic bool\nisInstantiationOf(ClassTemplatePartialSpecializationDecl *Pattern,\n                  ClassTemplatePartialSpecializationDecl *Instance) {\n  Pattern\n    = cast<ClassTemplatePartialSpecializationDecl>(Pattern->getCanonicalDecl());\n  do {\n    Instance = cast<ClassTemplatePartialSpecializationDecl>(\n                                                Instance->getCanonicalDecl());\n    if (Pattern == Instance)\n      return true;\n    Instance = Instance->getInstantiatedFromMember();\n  } while (Instance);\n\n  return false;\n}\n\nstatic bool isInstantiationOf(CXXRecordDecl *Pattern,\n                              CXXRecordDecl *Instance) {\n  Pattern = Pattern->getCanonicalDecl();\n\n  do {\n    Instance = Instance->getCanonicalDecl();\n    if (Pattern == Instance) return true;\n    Instance = Instance->getInstantiatedFromMemberClass();\n  } while (Instance);\n\n  return false;\n}\n\nstatic bool isInstantiationOf(FunctionDecl *Pattern,\n                              FunctionDecl *Instance) {\n  Pattern = Pattern->getCanonicalDecl();\n\n  do {\n    Instance = Instance->getCanonicalDecl();\n    if (Pattern == Instance) return true;\n    Instance = Instance->getInstantiatedFromMemberFunction();\n  } while (Instance);\n\n  return false;\n}\n\nstatic bool isInstantiationOf(EnumDecl *Pattern,\n                              EnumDecl *Instance) {\n  Pattern = Pattern->getCanonicalDecl();\n\n  do {\n    Instance = Instance->getCanonicalDecl();\n    if (Pattern == Instance) return true;\n    Instance = Instance->getInstantiatedFromMemberEnum();\n  } while (Instance);\n\n  return false;\n}\n\nstatic bool isInstantiationOf(UsingShadowDecl *Pattern,\n                              UsingShadowDecl *Instance,\n                              ASTContext &C) {\n  return declaresSameEntity(C.getInstantiatedFromUsingShadowDecl(Instance),\n                            Pattern);\n}\n\nstatic bool isInstantiationOf(UsingDecl *Pattern, UsingDecl *Instance,\n                              ASTContext &C) {\n  return declaresSameEntity(C.getInstantiatedFromUsingDecl(Instance), Pattern);\n}\n\ntemplate<typename T>\nstatic bool isInstantiationOfUnresolvedUsingDecl(T *Pattern, Decl *Other,\n                                                 ASTContext &Ctx) {\n  // An unresolved using declaration can instantiate to an unresolved using\n  // declaration, or to a using declaration or a using declaration pack.\n  //\n  // Multiple declarations can claim to be instantiated from an unresolved\n  // using declaration if it's a pack expansion. We want the UsingPackDecl\n  // in that case, not the individual UsingDecls within the pack.\n  bool OtherIsPackExpansion;\n  NamedDecl *OtherFrom;\n  if (auto *OtherUUD = dyn_cast<T>(Other)) {\n    OtherIsPackExpansion = OtherUUD->isPackExpansion();\n    OtherFrom = Ctx.getInstantiatedFromUsingDecl(OtherUUD);\n  } else if (auto *OtherUPD = dyn_cast<UsingPackDecl>(Other)) {\n    OtherIsPackExpansion = true;\n    OtherFrom = OtherUPD->getInstantiatedFromUsingDecl();\n  } else if (auto *OtherUD = dyn_cast<UsingDecl>(Other)) {\n    OtherIsPackExpansion = false;\n    OtherFrom = Ctx.getInstantiatedFromUsingDecl(OtherUD);\n  } else {\n    return false;\n  }\n  return Pattern->isPackExpansion() == OtherIsPackExpansion &&\n         declaresSameEntity(OtherFrom, Pattern);\n}\n\nstatic bool isInstantiationOfStaticDataMember(VarDecl *Pattern,\n                                              VarDecl *Instance) {\n  assert(Instance->isStaticDataMember());\n\n  Pattern = Pattern->getCanonicalDecl();\n\n  do {\n    Instance = Instance->getCanonicalDecl();\n    if (Pattern == Instance) return true;\n    Instance = Instance->getInstantiatedFromStaticDataMember();\n  } while (Instance);\n\n  return false;\n}\n\n// Other is the prospective instantiation\n// D is the prospective pattern\nstatic bool isInstantiationOf(ASTContext &Ctx, NamedDecl *D, Decl *Other) {\n  if (auto *UUD = dyn_cast<UnresolvedUsingTypenameDecl>(D))\n    return isInstantiationOfUnresolvedUsingDecl(UUD, Other, Ctx);\n\n  if (auto *UUD = dyn_cast<UnresolvedUsingValueDecl>(D))\n    return isInstantiationOfUnresolvedUsingDecl(UUD, Other, Ctx);\n\n  if (D->getKind() != Other->getKind())\n    return false;\n\n  if (auto *Record = dyn_cast<CXXRecordDecl>(Other))\n    return isInstantiationOf(cast<CXXRecordDecl>(D), Record);\n\n  if (auto *Function = dyn_cast<FunctionDecl>(Other))\n    return isInstantiationOf(cast<FunctionDecl>(D), Function);\n\n  if (auto *Enum = dyn_cast<EnumDecl>(Other))\n    return isInstantiationOf(cast<EnumDecl>(D), Enum);\n\n  if (auto *Var = dyn_cast<VarDecl>(Other))\n    if (Var->isStaticDataMember())\n      return isInstantiationOfStaticDataMember(cast<VarDecl>(D), Var);\n\n  if (auto *Temp = dyn_cast<ClassTemplateDecl>(Other))\n    return isInstantiationOf(cast<ClassTemplateDecl>(D), Temp);\n\n  if (auto *Temp = dyn_cast<FunctionTemplateDecl>(Other))\n    return isInstantiationOf(cast<FunctionTemplateDecl>(D), Temp);\n\n  if (auto *PartialSpec =\n          dyn_cast<ClassTemplatePartialSpecializationDecl>(Other))\n    return isInstantiationOf(cast<ClassTemplatePartialSpecializationDecl>(D),\n                             PartialSpec);\n\n  if (auto *Field = dyn_cast<FieldDecl>(Other)) {\n    if (!Field->getDeclName()) {\n      // This is an unnamed field.\n      return declaresSameEntity(Ctx.getInstantiatedFromUnnamedFieldDecl(Field),\n                                cast<FieldDecl>(D));\n    }\n  }\n\n  if (auto *Using = dyn_cast<UsingDecl>(Other))\n    return isInstantiationOf(cast<UsingDecl>(D), Using, Ctx);\n\n  if (auto *Shadow = dyn_cast<UsingShadowDecl>(Other))\n    return isInstantiationOf(cast<UsingShadowDecl>(D), Shadow, Ctx);\n\n  return D->getDeclName() &&\n         D->getDeclName() == cast<NamedDecl>(Other)->getDeclName();\n}\n\ntemplate<typename ForwardIterator>\nstatic NamedDecl *findInstantiationOf(ASTContext &Ctx,\n                                      NamedDecl *D,\n                                      ForwardIterator first,\n                                      ForwardIterator last) {\n  for (; first != last; ++first)\n    if (isInstantiationOf(Ctx, D, *first))\n      return cast<NamedDecl>(*first);\n\n  return nullptr;\n}\n\n/// Finds the instantiation of the given declaration context\n/// within the current instantiation.\n///\n/// \\returns NULL if there was an error\nDeclContext *Sema::FindInstantiatedContext(SourceLocation Loc, DeclContext* DC,\n                          const MultiLevelTemplateArgumentList &TemplateArgs) {\n  if (NamedDecl *D = dyn_cast<NamedDecl>(DC)) {\n    Decl* ID = FindInstantiatedDecl(Loc, D, TemplateArgs, true);\n    return cast_or_null<DeclContext>(ID);\n  } else return DC;\n}\n\n/// Determine whether the given context is dependent on template parameters at\n/// level \\p Level or below.\n///\n/// Sometimes we only substitute an inner set of template arguments and leave\n/// the outer templates alone. In such cases, contexts dependent only on the\n/// outer levels are not effectively dependent.\nstatic bool isDependentContextAtLevel(DeclContext *DC, unsigned Level) {\n  if (!DC->isDependentContext())\n    return false;\n  if (!Level)\n    return true;\n  return cast<Decl>(DC)->getTemplateDepth() > Level;\n}\n\n/// Find the instantiation of the given declaration within the\n/// current instantiation.\n///\n/// This routine is intended to be used when \\p D is a declaration\n/// referenced from within a template, that needs to mapped into the\n/// corresponding declaration within an instantiation. For example,\n/// given:\n///\n/// \\code\n/// template<typename T>\n/// struct X {\n///   enum Kind {\n///     KnownValue = sizeof(T)\n///   };\n///\n///   bool getKind() const { return KnownValue; }\n/// };\n///\n/// template struct X<int>;\n/// \\endcode\n///\n/// In the instantiation of X<int>::getKind(), we need to map the \\p\n/// EnumConstantDecl for \\p KnownValue (which refers to\n/// X<T>::<Kind>::KnownValue) to its instantiation (X<int>::<Kind>::KnownValue).\n/// \\p FindInstantiatedDecl performs this mapping from within the instantiation\n/// of X<int>.\nNamedDecl *Sema::FindInstantiatedDecl(SourceLocation Loc, NamedDecl *D,\n                          const MultiLevelTemplateArgumentList &TemplateArgs,\n                          bool FindingInstantiatedContext) {\n  DeclContext *ParentDC = D->getDeclContext();\n  // Determine whether our parent context depends on any of the tempalte\n  // arguments we're currently substituting.\n  bool ParentDependsOnArgs = isDependentContextAtLevel(\n      ParentDC, TemplateArgs.getNumRetainedOuterLevels());\n  // FIXME: Parmeters of pointer to functions (y below) that are themselves\n  // parameters (p below) can have their ParentDC set to the translation-unit\n  // - thus we can not consistently check if the ParentDC of such a parameter\n  // is Dependent or/and a FunctionOrMethod.\n  // For e.g. this code, during Template argument deduction tries to\n  // find an instantiated decl for (T y) when the ParentDC for y is\n  // the translation unit.\n  //   e.g. template <class T> void Foo(auto (*p)(T y) -> decltype(y())) {}\n  //   float baz(float(*)()) { return 0.0; }\n  //   Foo(baz);\n  // The better fix here is perhaps to ensure that a ParmVarDecl, by the time\n  // it gets here, always has a FunctionOrMethod as its ParentDC??\n  // For now:\n  //  - as long as we have a ParmVarDecl whose parent is non-dependent and\n  //    whose type is not instantiation dependent, do nothing to the decl\n  //  - otherwise find its instantiated decl.\n  if (isa<ParmVarDecl>(D) && !ParentDependsOnArgs &&\n      !cast<ParmVarDecl>(D)->getType()->isInstantiationDependentType())\n    return D;\n  if (isa<ParmVarDecl>(D) || isa<NonTypeTemplateParmDecl>(D) ||\n      isa<TemplateTypeParmDecl>(D) || isa<TemplateTemplateParmDecl>(D) ||\n      (ParentDependsOnArgs && (ParentDC->isFunctionOrMethod() ||\n                               isa<OMPDeclareReductionDecl>(ParentDC) ||\n                               isa<OMPDeclareMapperDecl>(ParentDC))) ||\n      (isa<CXXRecordDecl>(D) && cast<CXXRecordDecl>(D)->isLambda())) {\n    // D is a local of some kind. Look into the map of local\n    // declarations to their instantiations.\n    if (CurrentInstantiationScope) {\n      if (auto Found = CurrentInstantiationScope->findInstantiationOf(D)) {\n        if (Decl *FD = Found->dyn_cast<Decl *>())\n          return cast<NamedDecl>(FD);\n\n        int PackIdx = ArgumentPackSubstitutionIndex;\n        assert(PackIdx != -1 &&\n               \"found declaration pack but not pack expanding\");\n        typedef LocalInstantiationScope::DeclArgumentPack DeclArgumentPack;\n        return cast<NamedDecl>((*Found->get<DeclArgumentPack *>())[PackIdx]);\n      }\n    }\n\n    // If we're performing a partial substitution during template argument\n    // deduction, we may not have values for template parameters yet. They\n    // just map to themselves.\n    if (isa<NonTypeTemplateParmDecl>(D) || isa<TemplateTypeParmDecl>(D) ||\n        isa<TemplateTemplateParmDecl>(D))\n      return D;\n\n    if (D->isInvalidDecl())\n      return nullptr;\n\n    // Normally this function only searches for already instantiated declaration\n    // however we have to make an exclusion for local types used before\n    // definition as in the code:\n    //\n    //   template<typename T> void f1() {\n    //     void g1(struct x1);\n    //     struct x1 {};\n    //   }\n    //\n    // In this case instantiation of the type of 'g1' requires definition of\n    // 'x1', which is defined later. Error recovery may produce an enum used\n    // before definition. In these cases we need to instantiate relevant\n    // declarations here.\n    bool NeedInstantiate = false;\n    if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D))\n      NeedInstantiate = RD->isLocalClass();\n    else if (isa<TypedefNameDecl>(D) &&\n             isa<CXXDeductionGuideDecl>(D->getDeclContext()))\n      NeedInstantiate = true;\n    else\n      NeedInstantiate = isa<EnumDecl>(D);\n    if (NeedInstantiate) {\n      Decl *Inst = SubstDecl(D, CurContext, TemplateArgs);\n      CurrentInstantiationScope->InstantiatedLocal(D, Inst);\n      return cast<TypeDecl>(Inst);\n    }\n\n    // If we didn't find the decl, then we must have a label decl that hasn't\n    // been found yet.  Lazily instantiate it and return it now.\n    assert(isa<LabelDecl>(D));\n\n    Decl *Inst = SubstDecl(D, CurContext, TemplateArgs);\n    assert(Inst && \"Failed to instantiate label??\");\n\n    CurrentInstantiationScope->InstantiatedLocal(D, Inst);\n    return cast<LabelDecl>(Inst);\n  }\n\n  if (CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(D)) {\n    if (!Record->isDependentContext())\n      return D;\n\n    // Determine whether this record is the \"templated\" declaration describing\n    // a class template or class template partial specialization.\n    ClassTemplateDecl *ClassTemplate = Record->getDescribedClassTemplate();\n    if (ClassTemplate)\n      ClassTemplate = ClassTemplate->getCanonicalDecl();\n    else if (ClassTemplatePartialSpecializationDecl *PartialSpec\n               = dyn_cast<ClassTemplatePartialSpecializationDecl>(Record))\n      ClassTemplate = PartialSpec->getSpecializedTemplate()->getCanonicalDecl();\n\n    // Walk the current context to find either the record or an instantiation of\n    // it.\n    DeclContext *DC = CurContext;\n    while (!DC->isFileContext()) {\n      // If we're performing substitution while we're inside the template\n      // definition, we'll find our own context. We're done.\n      if (DC->Equals(Record))\n        return Record;\n\n      if (CXXRecordDecl *InstRecord = dyn_cast<CXXRecordDecl>(DC)) {\n        // Check whether we're in the process of instantiating a class template\n        // specialization of the template we're mapping.\n        if (ClassTemplateSpecializationDecl *InstSpec\n                      = dyn_cast<ClassTemplateSpecializationDecl>(InstRecord)){\n          ClassTemplateDecl *SpecTemplate = InstSpec->getSpecializedTemplate();\n          if (ClassTemplate && isInstantiationOf(ClassTemplate, SpecTemplate))\n            return InstRecord;\n        }\n\n        // Check whether we're in the process of instantiating a member class.\n        if (isInstantiationOf(Record, InstRecord))\n          return InstRecord;\n      }\n\n      // Move to the outer template scope.\n      if (FunctionDecl *FD = dyn_cast<FunctionDecl>(DC)) {\n        if (FD->getFriendObjectKind() && FD->getDeclContext()->isFileContext()){\n          DC = FD->getLexicalDeclContext();\n          continue;\n        }\n        // An implicit deduction guide acts as if it's within the class template\n        // specialization described by its name and first N template params.\n        auto *Guide = dyn_cast<CXXDeductionGuideDecl>(FD);\n        if (Guide && Guide->isImplicit()) {\n          TemplateDecl *TD = Guide->getDeducedTemplate();\n          // Convert the arguments to an \"as-written\" list.\n          TemplateArgumentListInfo Args(Loc, Loc);\n          for (TemplateArgument Arg : TemplateArgs.getInnermost().take_front(\n                                        TD->getTemplateParameters()->size())) {\n            ArrayRef<TemplateArgument> Unpacked(Arg);\n            if (Arg.getKind() == TemplateArgument::Pack)\n              Unpacked = Arg.pack_elements();\n            for (TemplateArgument UnpackedArg : Unpacked)\n              Args.addArgument(\n                  getTrivialTemplateArgumentLoc(UnpackedArg, QualType(), Loc));\n          }\n          QualType T = CheckTemplateIdType(TemplateName(TD), Loc, Args);\n          if (T.isNull())\n            return nullptr;\n          auto *SubstRecord = T->getAsCXXRecordDecl();\n          assert(SubstRecord && \"class template id not a class type?\");\n          // Check that this template-id names the primary template and not a\n          // partial or explicit specialization. (In the latter cases, it's\n          // meaningless to attempt to find an instantiation of D within the\n          // specialization.)\n          // FIXME: The standard doesn't say what should happen here.\n          if (FindingInstantiatedContext &&\n              usesPartialOrExplicitSpecialization(\n                  Loc, cast<ClassTemplateSpecializationDecl>(SubstRecord))) {\n            Diag(Loc, diag::err_specialization_not_primary_template)\n              << T << (SubstRecord->getTemplateSpecializationKind() ==\n                           TSK_ExplicitSpecialization);\n            return nullptr;\n          }\n          DC = SubstRecord;\n          continue;\n        }\n      }\n\n      DC = DC->getParent();\n    }\n\n    // Fall through to deal with other dependent record types (e.g.,\n    // anonymous unions in class templates).\n  }\n\n  if (!ParentDependsOnArgs)\n    return D;\n\n  ParentDC = FindInstantiatedContext(Loc, ParentDC, TemplateArgs);\n  if (!ParentDC)\n    return nullptr;\n\n  if (ParentDC != D->getDeclContext()) {\n    // We performed some kind of instantiation in the parent context,\n    // so now we need to look into the instantiated parent context to\n    // find the instantiation of the declaration D.\n\n    // If our context used to be dependent, we may need to instantiate\n    // it before performing lookup into that context.\n    bool IsBeingInstantiated = false;\n    if (CXXRecordDecl *Spec = dyn_cast<CXXRecordDecl>(ParentDC)) {\n      if (!Spec->isDependentContext()) {\n        QualType T = Context.getTypeDeclType(Spec);\n        const RecordType *Tag = T->getAs<RecordType>();\n        assert(Tag && \"type of non-dependent record is not a RecordType\");\n        if (Tag->isBeingDefined())\n          IsBeingInstantiated = true;\n        if (!Tag->isBeingDefined() &&\n            RequireCompleteType(Loc, T, diag::err_incomplete_type))\n          return nullptr;\n\n        ParentDC = Tag->getDecl();\n      }\n    }\n\n    NamedDecl *Result = nullptr;\n    // FIXME: If the name is a dependent name, this lookup won't necessarily\n    // find it. Does that ever matter?\n    if (auto Name = D->getDeclName()) {\n      DeclarationNameInfo NameInfo(Name, D->getLocation());\n      DeclarationNameInfo NewNameInfo =\n          SubstDeclarationNameInfo(NameInfo, TemplateArgs);\n      Name = NewNameInfo.getName();\n      if (!Name)\n        return nullptr;\n      DeclContext::lookup_result Found = ParentDC->lookup(Name);\n\n      Result = findInstantiationOf(Context, D, Found.begin(), Found.end());\n    } else {\n      // Since we don't have a name for the entity we're looking for,\n      // our only option is to walk through all of the declarations to\n      // find that name. This will occur in a few cases:\n      //\n      //   - anonymous struct/union within a template\n      //   - unnamed class/struct/union/enum within a template\n      //\n      // FIXME: Find a better way to find these instantiations!\n      Result = findInstantiationOf(Context, D,\n                                   ParentDC->decls_begin(),\n                                   ParentDC->decls_end());\n    }\n\n    if (!Result) {\n      if (isa<UsingShadowDecl>(D)) {\n        // UsingShadowDecls can instantiate to nothing because of using hiding.\n      } else if (hasUncompilableErrorOccurred()) {\n        // We've already complained about some ill-formed code, so most likely\n        // this declaration failed to instantiate. There's no point in\n        // complaining further, since this is normal in invalid code.\n        // FIXME: Use more fine-grained 'invalid' tracking for this.\n      } else if (IsBeingInstantiated) {\n        // The class in which this member exists is currently being\n        // instantiated, and we haven't gotten around to instantiating this\n        // member yet. This can happen when the code uses forward declarations\n        // of member classes, and introduces ordering dependencies via\n        // template instantiation.\n        Diag(Loc, diag::err_member_not_yet_instantiated)\n          << D->getDeclName()\n          << Context.getTypeDeclType(cast<CXXRecordDecl>(ParentDC));\n        Diag(D->getLocation(), diag::note_non_instantiated_member_here);\n      } else if (EnumConstantDecl *ED = dyn_cast<EnumConstantDecl>(D)) {\n        // This enumeration constant was found when the template was defined,\n        // but can't be found in the instantiation. This can happen if an\n        // unscoped enumeration member is explicitly specialized.\n        EnumDecl *Enum = cast<EnumDecl>(ED->getLexicalDeclContext());\n        EnumDecl *Spec = cast<EnumDecl>(FindInstantiatedDecl(Loc, Enum,\n                                                             TemplateArgs));\n        assert(Spec->getTemplateSpecializationKind() ==\n                 TSK_ExplicitSpecialization);\n        Diag(Loc, diag::err_enumerator_does_not_exist)\n          << D->getDeclName()\n          << Context.getTypeDeclType(cast<TypeDecl>(Spec->getDeclContext()));\n        Diag(Spec->getLocation(), diag::note_enum_specialized_here)\n          << Context.getTypeDeclType(Spec);\n      } else {\n        // We should have found something, but didn't.\n        llvm_unreachable(\"Unable to find instantiation of declaration!\");\n      }\n    }\n\n    D = Result;\n  }\n\n  return D;\n}\n\n/// Performs template instantiation for all implicit template\n/// instantiations we have seen until this point.\nvoid Sema::PerformPendingInstantiations(bool LocalOnly) {\n  std::deque<PendingImplicitInstantiation> delayedPCHInstantiations;\n  while (!PendingLocalImplicitInstantiations.empty() ||\n         (!LocalOnly && !PendingInstantiations.empty())) {\n    PendingImplicitInstantiation Inst;\n\n    if (PendingLocalImplicitInstantiations.empty()) {\n      Inst = PendingInstantiations.front();\n      PendingInstantiations.pop_front();\n    } else {\n      Inst = PendingLocalImplicitInstantiations.front();\n      PendingLocalImplicitInstantiations.pop_front();\n    }\n\n    // Instantiate function definitions\n    if (FunctionDecl *Function = dyn_cast<FunctionDecl>(Inst.first)) {\n      bool DefinitionRequired = Function->getTemplateSpecializationKind() ==\n                                TSK_ExplicitInstantiationDefinition;\n      if (Function->isMultiVersion()) {\n        getASTContext().forEachMultiversionedFunctionVersion(\n            Function, [this, Inst, DefinitionRequired](FunctionDecl *CurFD) {\n              InstantiateFunctionDefinition(/*FIXME:*/ Inst.second, CurFD, true,\n                                            DefinitionRequired, true);\n              if (CurFD->isDefined())\n                CurFD->setInstantiationIsPending(false);\n            });\n      } else {\n        InstantiateFunctionDefinition(/*FIXME:*/ Inst.second, Function, true,\n                                      DefinitionRequired, true);\n        if (Function->isDefined())\n          Function->setInstantiationIsPending(false);\n      }\n      // Definition of a PCH-ed template declaration may be available only in the TU.\n      if (!LocalOnly && LangOpts.PCHInstantiateTemplates &&\n          TUKind == TU_Prefix && Function->instantiationIsPending())\n        delayedPCHInstantiations.push_back(Inst);\n      continue;\n    }\n\n    // Instantiate variable definitions\n    VarDecl *Var = cast<VarDecl>(Inst.first);\n\n    assert((Var->isStaticDataMember() ||\n            isa<VarTemplateSpecializationDecl>(Var)) &&\n           \"Not a static data member, nor a variable template\"\n           \" specialization?\");\n\n    // Don't try to instantiate declarations if the most recent redeclaration\n    // is invalid.\n    if (Var->getMostRecentDecl()->isInvalidDecl())\n      continue;\n\n    // Check if the most recent declaration has changed the specialization kind\n    // and removed the need for implicit instantiation.\n    switch (Var->getMostRecentDecl()\n                ->getTemplateSpecializationKindForInstantiation()) {\n    case TSK_Undeclared:\n      llvm_unreachable(\"Cannot instantitiate an undeclared specialization.\");\n    case TSK_ExplicitInstantiationDeclaration:\n    case TSK_ExplicitSpecialization:\n      continue;  // No longer need to instantiate this type.\n    case TSK_ExplicitInstantiationDefinition:\n      // We only need an instantiation if the pending instantiation *is* the\n      // explicit instantiation.\n      if (Var != Var->getMostRecentDecl())\n        continue;\n      break;\n    case TSK_ImplicitInstantiation:\n      break;\n    }\n\n    PrettyDeclStackTraceEntry CrashInfo(Context, Var, SourceLocation(),\n                                        \"instantiating variable definition\");\n    bool DefinitionRequired = Var->getTemplateSpecializationKind() ==\n                              TSK_ExplicitInstantiationDefinition;\n\n    // Instantiate static data member definitions or variable template\n    // specializations.\n    InstantiateVariableDefinition(/*FIXME:*/ Inst.second, Var, true,\n                                  DefinitionRequired, true);\n  }\n\n  if (!LocalOnly && LangOpts.PCHInstantiateTemplates)\n    PendingInstantiations.swap(delayedPCHInstantiations);\n}\n\nvoid Sema::PerformDependentDiagnostics(const DeclContext *Pattern,\n                       const MultiLevelTemplateArgumentList &TemplateArgs) {\n  for (auto DD : Pattern->ddiags()) {\n    switch (DD->getKind()) {\n    case DependentDiagnostic::Access:\n      HandleDependentAccessCheck(*DD, TemplateArgs);\n      break;\n    }\n  }\n}\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 20, "line": 380}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "reportHash": "0c6dd16fe4ffaffebfd82e47d642fcec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 20, "line": 397}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "reportHash": "8cedeef063f4b722eba7f9264ff57c67", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 20, "line": 397}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "reportHash": "97e6351eeba1f59e4bf4746a2ac5a1f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 20, "line": 421}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "reportHash": "357fdb8c28c98e181d37cbe8336a0a71", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 20, "line": 421}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "reportHash": "a48731b89385d678aaf1b648db5d7ba9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
