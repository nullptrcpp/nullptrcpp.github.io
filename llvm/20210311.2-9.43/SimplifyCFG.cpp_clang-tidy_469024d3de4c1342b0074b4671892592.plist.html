<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "content": "//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Peephole optimize the CFG.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/ScopeExit.h\"\n#include \"llvm/ADT/Sequence.h\"\n#include \"llvm/ADT/SetOperations.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/Analysis/GuardUtils.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/MemorySSA.h\"\n#include \"llvm/Analysis/MemorySSAUpdater.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/MDBuilder.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/NoFolder.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/PseudoProbe.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include \"llvm/Transforms/Utils/SSAUpdater.h\"\n#include \"llvm/Transforms/Utils/ValueMapper.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\nusing namespace PatternMatch;\n\n#define DEBUG_TYPE \"simplifycfg\"\n\ncl::opt<bool> llvm::RequireAndPreserveDomTree(\n    \"simplifycfg-require-and-preserve-domtree\", cl::Hidden, cl::ZeroOrMore,\n    cl::init(false),\n    cl::desc(\"Temorary development switch used to gradually uplift SimplifyCFG \"\n             \"into preserving DomTree,\"));\n\n// Chosen as 2 so as to be cheap, but still to have enough power to fold\n// a select, so the \"clamp\" idiom (of a min followed by a max) will be caught.\n// To catch this, we need to fold a compare and a select, hence '2' being the\n// minimum reasonable default.\nstatic cl::opt<unsigned> PHINodeFoldingThreshold(\n    \"phi-node-folding-threshold\", cl::Hidden, cl::init(2),\n    cl::desc(\n        \"Control the amount of phi node folding to perform (default = 2)\"));\n\nstatic cl::opt<unsigned> TwoEntryPHINodeFoldingThreshold(\n    \"two-entry-phi-node-folding-threshold\", cl::Hidden, cl::init(4),\n    cl::desc(\"Control the maximal total instruction cost that we are willing \"\n             \"to speculatively execute to fold a 2-entry PHI node into a \"\n             \"select (default = 4)\"));\n\nstatic cl::opt<bool> DupRet(\n    \"simplifycfg-dup-ret\", cl::Hidden, cl::init(false),\n    cl::desc(\"Duplicate return instructions into unconditional branches\"));\n\nstatic cl::opt<bool>\n    HoistCommon(\"simplifycfg-hoist-common\", cl::Hidden, cl::init(true),\n                cl::desc(\"Hoist common instructions up to the parent block\"));\n\nstatic cl::opt<bool>\n    SinkCommon(\"simplifycfg-sink-common\", cl::Hidden, cl::init(true),\n               cl::desc(\"Sink common instructions down to the end block\"));\n\nstatic cl::opt<bool> HoistCondStores(\n    \"simplifycfg-hoist-cond-stores\", cl::Hidden, cl::init(true),\n    cl::desc(\"Hoist conditional stores if an unconditional store precedes\"));\n\nstatic cl::opt<bool> MergeCondStores(\n    \"simplifycfg-merge-cond-stores\", cl::Hidden, cl::init(true),\n    cl::desc(\"Hoist conditional stores even if an unconditional store does not \"\n             \"precede - hoist multiple conditional stores into a single \"\n             \"predicated store\"));\n\nstatic cl::opt<bool> MergeCondStoresAggressively(\n    \"simplifycfg-merge-cond-stores-aggressively\", cl::Hidden, cl::init(false),\n    cl::desc(\"When merging conditional stores, do so even if the resultant \"\n             \"basic blocks are unlikely to be if-converted as a result\"));\n\nstatic cl::opt<bool> SpeculateOneExpensiveInst(\n    \"speculate-one-expensive-inst\", cl::Hidden, cl::init(true),\n    cl::desc(\"Allow exactly one expensive instruction to be speculatively \"\n             \"executed\"));\n\nstatic cl::opt<unsigned> MaxSpeculationDepth(\n    \"max-speculation-depth\", cl::Hidden, cl::init(10),\n    cl::desc(\"Limit maximum recursion depth when calculating costs of \"\n             \"speculatively executed instructions\"));\n\nstatic cl::opt<int>\nMaxSmallBlockSize(\"simplifycfg-max-small-block-size\", cl::Hidden, cl::init(10),\n                  cl::desc(\"Max size of a block which is still considered \"\n                           \"small enough to thread through\"));\n\n// Two is chosen to allow one negation and a logical combine.\nstatic cl::opt<unsigned>\n    BranchFoldThreshold(\"simplifycfg-branch-fold-threshold\", cl::Hidden,\n                        cl::init(2),\n                        cl::desc(\"Maximum cost of combining conditions when \"\n                                 \"folding branches\"));\n\nSTATISTIC(NumBitMaps, \"Number of switch instructions turned into bitmaps\");\nSTATISTIC(NumLinearMaps,\n          \"Number of switch instructions turned into linear mapping\");\nSTATISTIC(NumLookupTables,\n          \"Number of switch instructions turned into lookup tables\");\nSTATISTIC(\n    NumLookupTablesHoles,\n    \"Number of switch instructions turned into lookup tables (holes checked)\");\nSTATISTIC(NumTableCmpReuses, \"Number of reused switch table lookup compares\");\nSTATISTIC(NumFoldValueComparisonIntoPredecessors,\n          \"Number of value comparisons folded into predecessor basic blocks\");\nSTATISTIC(NumFoldBranchToCommonDest,\n          \"Number of branches folded into predecessor basic block\");\nSTATISTIC(\n    NumHoistCommonCode,\n    \"Number of common instruction 'blocks' hoisted up to the begin block\");\nSTATISTIC(NumHoistCommonInstrs,\n          \"Number of common instructions hoisted up to the begin block\");\nSTATISTIC(NumSinkCommonCode,\n          \"Number of common instruction 'blocks' sunk down to the end block\");\nSTATISTIC(NumSinkCommonInstrs,\n          \"Number of common instructions sunk down to the end block\");\nSTATISTIC(NumSpeculations, \"Number of speculative executed instructions\");\nSTATISTIC(NumInvokes,\n          \"Number of invokes with empty resume blocks simplified into calls\");\n\nnamespace {\n\n// The first field contains the value that the switch produces when a certain\n// case group is selected, and the second field is a vector containing the\n// cases composing the case group.\nusing SwitchCaseResultVectorTy =\n    SmallVector<std::pair<Constant *, SmallVector<ConstantInt *, 4>>, 2>;\n\n// The first field contains the phi node that generates a result of the switch\n// and the second field contains the value generated for a certain case in the\n// switch for that PHI.\nusing SwitchCaseResultsTy = SmallVector<std::pair<PHINode *, Constant *>, 4>;\n\n/// ValueEqualityComparisonCase - Represents a case of a switch.\nstruct ValueEqualityComparisonCase {\n  ConstantInt *Value;\n  BasicBlock *Dest;\n\n  ValueEqualityComparisonCase(ConstantInt *Value, BasicBlock *Dest)\n      : Value(Value), Dest(Dest) {}\n\n  bool operator<(ValueEqualityComparisonCase RHS) const {\n    // Comparing pointers is ok as we only rely on the order for uniquing.\n    return Value < RHS.Value;\n  }\n\n  bool operator==(BasicBlock *RHSDest) const { return Dest == RHSDest; }\n};\n\nclass SimplifyCFGOpt {\n  const TargetTransformInfo &TTI;\n  DomTreeUpdater *DTU;\n  const DataLayout &DL;\n  ArrayRef<WeakVH> LoopHeaders;\n  const SimplifyCFGOptions &Options;\n  bool Resimplify;\n\n  Value *isValueEqualityComparison(Instruction *TI);\n  BasicBlock *GetValueEqualityComparisonCases(\n      Instruction *TI, std::vector<ValueEqualityComparisonCase> &Cases);\n  bool SimplifyEqualityComparisonWithOnlyPredecessor(Instruction *TI,\n                                                     BasicBlock *Pred,\n                                                     IRBuilder<> &Builder);\n  bool PerformValueComparisonIntoPredecessorFolding(Instruction *TI, Value *&CV,\n                                                    Instruction *PTI,\n                                                    IRBuilder<> &Builder);\n  bool FoldValueComparisonIntoPredecessors(Instruction *TI,\n                                           IRBuilder<> &Builder);\n\n  bool simplifyReturn(ReturnInst *RI, IRBuilder<> &Builder);\n  bool simplifyResume(ResumeInst *RI, IRBuilder<> &Builder);\n  bool simplifySingleResume(ResumeInst *RI);\n  bool simplifyCommonResume(ResumeInst *RI);\n  bool simplifyCleanupReturn(CleanupReturnInst *RI);\n  bool simplifyUnreachable(UnreachableInst *UI);\n  bool simplifySwitch(SwitchInst *SI, IRBuilder<> &Builder);\n  bool simplifyIndirectBr(IndirectBrInst *IBI);\n  bool simplifyBranch(BranchInst *Branch, IRBuilder<> &Builder);\n  bool simplifyUncondBranch(BranchInst *BI, IRBuilder<> &Builder);\n  bool simplifyCondBranch(BranchInst *BI, IRBuilder<> &Builder);\n  bool SimplifyCondBranchToTwoReturns(BranchInst *BI, IRBuilder<> &Builder);\n\n  bool tryToSimplifyUncondBranchWithICmpInIt(ICmpInst *ICI,\n                                             IRBuilder<> &Builder);\n\n  bool HoistThenElseCodeToIf(BranchInst *BI, const TargetTransformInfo &TTI);\n  bool SpeculativelyExecuteBB(BranchInst *BI, BasicBlock *ThenBB,\n                              const TargetTransformInfo &TTI);\n  bool SimplifyTerminatorOnSelect(Instruction *OldTerm, Value *Cond,\n                                  BasicBlock *TrueBB, BasicBlock *FalseBB,\n                                  uint32_t TrueWeight, uint32_t FalseWeight);\n  bool SimplifyBranchOnICmpChain(BranchInst *BI, IRBuilder<> &Builder,\n                                 const DataLayout &DL);\n  bool SimplifySwitchOnSelect(SwitchInst *SI, SelectInst *Select);\n  bool SimplifyIndirectBrOnSelect(IndirectBrInst *IBI, SelectInst *SI);\n  bool TurnSwitchRangeIntoICmp(SwitchInst *SI, IRBuilder<> &Builder);\n\npublic:\n  SimplifyCFGOpt(const TargetTransformInfo &TTI, DomTreeUpdater *DTU,\n                 const DataLayout &DL, ArrayRef<WeakVH> LoopHeaders,\n                 const SimplifyCFGOptions &Opts)\n      : TTI(TTI), DTU(DTU), DL(DL), LoopHeaders(LoopHeaders), Options(Opts) {\n    assert((!DTU || !DTU->hasPostDomTree()) &&\n           \"SimplifyCFG is not yet capable of maintaining validity of a \"\n           \"PostDomTree, so don't ask for it.\");\n  }\n\n  bool simplifyOnce(BasicBlock *BB);\n  bool simplifyOnceImpl(BasicBlock *BB);\n  bool run(BasicBlock *BB);\n\n  // Helper to set Resimplify and return change indication.\n  bool requestResimplify() {\n    Resimplify = true;\n    return true;\n  }\n};\n\n} // end anonymous namespace\n\n/// Return true if it is safe to merge these two\n/// terminator instructions together.\nstatic bool\nSafeToMergeTerminators(Instruction *SI1, Instruction *SI2,\n                       SmallSetVector<BasicBlock *, 4> *FailBlocks = nullptr) {\n  if (SI1 == SI2)\n    return false; // Can't merge with self!\n\n  // It is not safe to merge these two switch instructions if they have a common\n  // successor, and if that successor has a PHI node, and if *that* PHI node has\n  // conflicting incoming values from the two switch blocks.\n  BasicBlock *SI1BB = SI1->getParent();\n  BasicBlock *SI2BB = SI2->getParent();\n\n  SmallPtrSet<BasicBlock *, 16> SI1Succs(succ_begin(SI1BB), succ_end(SI1BB));\n  bool Fail = false;\n  for (BasicBlock *Succ : successors(SI2BB))\n    if (SI1Succs.count(Succ))\n      for (BasicBlock::iterator BBI = Succ->begin(); isa<PHINode>(BBI); ++BBI) {\n        PHINode *PN = cast<PHINode>(BBI);\n        if (PN->getIncomingValueForBlock(SI1BB) !=\n            PN->getIncomingValueForBlock(SI2BB)) {\n          if (FailBlocks)\n            FailBlocks->insert(Succ);\n          Fail = true;\n        }\n      }\n\n  return !Fail;\n}\n\n/// Update PHI nodes in Succ to indicate that there will now be entries in it\n/// from the 'NewPred' block. The values that will be flowing into the PHI nodes\n/// will be the same as those coming in from ExistPred, an existing predecessor\n/// of Succ.\nstatic void AddPredecessorToBlock(BasicBlock *Succ, BasicBlock *NewPred,\n                                  BasicBlock *ExistPred,\n                                  MemorySSAUpdater *MSSAU = nullptr) {\n  for (PHINode &PN : Succ->phis())\n    PN.addIncoming(PN.getIncomingValueForBlock(ExistPred), NewPred);\n  if (MSSAU)\n    if (auto *MPhi = MSSAU->getMemorySSA()->getMemoryAccess(Succ))\n      MPhi->addIncoming(MPhi->getIncomingValueForBlock(ExistPred), NewPred);\n}\n\n/// Compute an abstract \"cost\" of speculating the given instruction,\n/// which is assumed to be safe to speculate. TCC_Free means cheap,\n/// TCC_Basic means less cheap, and TCC_Expensive means prohibitively\n/// expensive.\nstatic InstructionCost computeSpeculationCost(const User *I,\n                                              const TargetTransformInfo &TTI) {\n  assert(isSafeToSpeculativelyExecute(I) &&\n         \"Instruction is not safe to speculatively execute!\");\n  return TTI.getUserCost(I, TargetTransformInfo::TCK_SizeAndLatency);\n}\n\n/// If we have a merge point of an \"if condition\" as accepted above,\n/// return true if the specified value dominates the block.  We\n/// don't handle the true generality of domination here, just a special case\n/// which works well enough for us.\n///\n/// If AggressiveInsts is non-null, and if V does not dominate BB, we check to\n/// see if V (which must be an instruction) and its recursive operands\n/// that do not dominate BB have a combined cost lower than Budget and\n/// are non-trapping.  If both are true, the instruction is inserted into the\n/// set and true is returned.\n///\n/// The cost for most non-trapping instructions is defined as 1 except for\n/// Select whose cost is 2.\n///\n/// After this function returns, Cost is increased by the cost of\n/// V plus its non-dominating operands.  If that cost is greater than\n/// Budget, false is returned and Cost is undefined.\nstatic bool dominatesMergePoint(Value *V, BasicBlock *BB,\n                                SmallPtrSetImpl<Instruction *> &AggressiveInsts,\n                                InstructionCost &Cost,\n                                InstructionCost Budget,\n                                const TargetTransformInfo &TTI,\n                                unsigned Depth = 0) {\n  // It is possible to hit a zero-cost cycle (phi/gep instructions for example),\n  // so limit the recursion depth.\n  // TODO: While this recursion limit does prevent pathological behavior, it\n  // would be better to track visited instructions to avoid cycles.\n  if (Depth == MaxSpeculationDepth)\n    return false;\n\n  Instruction *I = dyn_cast<Instruction>(V);\n  if (!I) {\n    // Non-instructions all dominate instructions, but not all constantexprs\n    // can be executed unconditionally.\n    if (ConstantExpr *C = dyn_cast<ConstantExpr>(V))\n      if (C->canTrap())\n        return false;\n    return true;\n  }\n  BasicBlock *PBB = I->getParent();\n\n  // We don't want to allow weird loops that might have the \"if condition\" in\n  // the bottom of this block.\n  if (PBB == BB)\n    return false;\n\n  // If this instruction is defined in a block that contains an unconditional\n  // branch to BB, then it must be in the 'conditional' part of the \"if\n  // statement\".  If not, it definitely dominates the region.\n  BranchInst *BI = dyn_cast<BranchInst>(PBB->getTerminator());\n  if (!BI || BI->isConditional() || BI->getSuccessor(0) != BB)\n    return true;\n\n  // If we have seen this instruction before, don't count it again.\n  if (AggressiveInsts.count(I))\n    return true;\n\n  // Okay, it looks like the instruction IS in the \"condition\".  Check to\n  // see if it's a cheap instruction to unconditionally compute, and if it\n  // only uses stuff defined outside of the condition.  If so, hoist it out.\n  if (!isSafeToSpeculativelyExecute(I))\n    return false;\n\n  Cost += computeSpeculationCost(I, TTI);\n\n  // Allow exactly one instruction to be speculated regardless of its cost\n  // (as long as it is safe to do so).\n  // This is intended to flatten the CFG even if the instruction is a division\n  // or other expensive operation. The speculation of an expensive instruction\n  // is expected to be undone in CodeGenPrepare if the speculation has not\n  // enabled further IR optimizations.\n  if (Cost > Budget &&\n      (!SpeculateOneExpensiveInst || !AggressiveInsts.empty() || Depth > 0 ||\n       !Cost.isValid()))\n    return false;\n\n  // Okay, we can only really hoist these out if their operands do\n  // not take us over the cost threshold.\n  for (Use &Op : I->operands())\n    if (!dominatesMergePoint(Op, BB, AggressiveInsts, Cost, Budget, TTI,\n                             Depth + 1))\n      return false;\n  // Okay, it's safe to do this!  Remember this instruction.\n  AggressiveInsts.insert(I);\n  return true;\n}\n\n/// Extract ConstantInt from value, looking through IntToPtr\n/// and PointerNullValue. Return NULL if value is not a constant int.\nstatic ConstantInt *GetConstantInt(Value *V, const DataLayout &DL) {\n  // Normal constant int.\n  ConstantInt *CI = dyn_cast<ConstantInt>(V);\n  if (CI || !isa<Constant>(V) || !V->getType()->isPointerTy())\n    return CI;\n\n  // This is some kind of pointer constant. Turn it into a pointer-sized\n  // ConstantInt if possible.\n  IntegerType *PtrTy = cast<IntegerType>(DL.getIntPtrType(V->getType()));\n\n  // Null pointer means 0, see SelectionDAGBuilder::getValue(const Value*).\n  if (isa<ConstantPointerNull>(V))\n    return ConstantInt::get(PtrTy, 0);\n\n  // IntToPtr const int.\n  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(V))\n    if (CE->getOpcode() == Instruction::IntToPtr)\n      if (ConstantInt *CI = dyn_cast<ConstantInt>(CE->getOperand(0))) {\n        // The constant is very likely to have the right type already.\n        if (CI->getType() == PtrTy)\n          return CI;\n        else\n          return cast<ConstantInt>(\n              ConstantExpr::getIntegerCast(CI, PtrTy, /*isSigned=*/false));\n      }\n  return nullptr;\n}\n\nnamespace {\n\n/// Given a chain of or (||) or and (&&) comparison of a value against a\n/// constant, this will try to recover the information required for a switch\n/// structure.\n/// It will depth-first traverse the chain of comparison, seeking for patterns\n/// like %a == 12 or %a < 4 and combine them to produce a set of integer\n/// representing the different cases for the switch.\n/// Note that if the chain is composed of '||' it will build the set of elements\n/// that matches the comparisons (i.e. any of this value validate the chain)\n/// while for a chain of '&&' it will build the set elements that make the test\n/// fail.\nstruct ConstantComparesGatherer {\n  const DataLayout &DL;\n\n  /// Value found for the switch comparison\n  Value *CompValue = nullptr;\n\n  /// Extra clause to be checked before the switch\n  Value *Extra = nullptr;\n\n  /// Set of integers to match in switch\n  SmallVector<ConstantInt *, 8> Vals;\n\n  /// Number of comparisons matched in the and/or chain\n  unsigned UsedICmps = 0;\n\n  /// Construct and compute the result for the comparison instruction Cond\n  ConstantComparesGatherer(Instruction *Cond, const DataLayout &DL) : DL(DL) {\n    gather(Cond);\n  }\n\n  ConstantComparesGatherer(const ConstantComparesGatherer &) = delete;\n  ConstantComparesGatherer &\n  operator=(const ConstantComparesGatherer &) = delete;\n\nprivate:\n  /// Try to set the current value used for the comparison, it succeeds only if\n  /// it wasn't set before or if the new value is the same as the old one\n  bool setValueOnce(Value *NewVal) {\n    if (CompValue && CompValue != NewVal)\n      return false;\n    CompValue = NewVal;\n    return (CompValue != nullptr);\n  }\n\n  /// Try to match Instruction \"I\" as a comparison against a constant and\n  /// populates the array Vals with the set of values that match (or do not\n  /// match depending on isEQ).\n  /// Return false on failure. On success, the Value the comparison matched\n  /// against is placed in CompValue.\n  /// If CompValue is already set, the function is expected to fail if a match\n  /// is found but the value compared to is different.\n  bool matchInstruction(Instruction *I, bool isEQ) {\n    // If this is an icmp against a constant, handle this as one of the cases.\n    ICmpInst *ICI;\n    ConstantInt *C;\n    if (!((ICI = dyn_cast<ICmpInst>(I)) &&\n          (C = GetConstantInt(I->getOperand(1), DL)))) {\n      return false;\n    }\n\n    Value *RHSVal;\n    const APInt *RHSC;\n\n    // Pattern match a special case\n    // (x & ~2^z) == y --> x == y || x == y|2^z\n    // This undoes a transformation done by instcombine to fuse 2 compares.\n    if (ICI->getPredicate() == (isEQ ? ICmpInst::ICMP_EQ : ICmpInst::ICMP_NE)) {\n      // It's a little bit hard to see why the following transformations are\n      // correct. Here is a CVC3 program to verify them for 64-bit values:\n\n      /*\n         ONE  : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);\n         x    : BITVECTOR(64);\n         y    : BITVECTOR(64);\n         z    : BITVECTOR(64);\n         mask : BITVECTOR(64) = BVSHL(ONE, z);\n         QUERY( (y & ~mask = y) =>\n                ((x & ~mask = y) <=> (x = y OR x = (y |  mask)))\n         );\n         QUERY( (y |  mask = y) =>\n                ((x |  mask = y) <=> (x = y OR x = (y & ~mask)))\n         );\n      */\n\n      // Please note that each pattern must be a dual implication (<--> or\n      // iff). One directional implication can create spurious matches. If the\n      // implication is only one-way, an unsatisfiable condition on the left\n      // side can imply a satisfiable condition on the right side. Dual\n      // implication ensures that satisfiable conditions are transformed to\n      // other satisfiable conditions and unsatisfiable conditions are\n      // transformed to other unsatisfiable conditions.\n\n      // Here is a concrete example of a unsatisfiable condition on the left\n      // implying a satisfiable condition on the right:\n      //\n      // mask = (1 << z)\n      // (x & ~mask) == y  --> (x == y || x == (y | mask))\n      //\n      // Substituting y = 3, z = 0 yields:\n      // (x & -2) == 3 --> (x == 3 || x == 2)\n\n      // Pattern match a special case:\n      /*\n        QUERY( (y & ~mask = y) =>\n               ((x & ~mask = y) <=> (x = y OR x = (y |  mask)))\n        );\n      */\n      if (match(ICI->getOperand(0),\n                m_And(m_Value(RHSVal), m_APInt(RHSC)))) {\n        APInt Mask = ~*RHSC;\n        if (Mask.isPowerOf2() && (C->getValue() & ~Mask) == C->getValue()) {\n          // If we already have a value for the switch, it has to match!\n          if (!setValueOnce(RHSVal))\n            return false;\n\n          Vals.push_back(C);\n          Vals.push_back(\n              ConstantInt::get(C->getContext(),\n                               C->getValue() | Mask));\n          UsedICmps++;\n          return true;\n        }\n      }\n\n      // Pattern match a special case:\n      /*\n        QUERY( (y |  mask = y) =>\n               ((x |  mask = y) <=> (x = y OR x = (y & ~mask)))\n        );\n      */\n      if (match(ICI->getOperand(0),\n                m_Or(m_Value(RHSVal), m_APInt(RHSC)))) {\n        APInt Mask = *RHSC;\n        if (Mask.isPowerOf2() && (C->getValue() | Mask) == C->getValue()) {\n          // If we already have a value for the switch, it has to match!\n          if (!setValueOnce(RHSVal))\n            return false;\n\n          Vals.push_back(C);\n          Vals.push_back(ConstantInt::get(C->getContext(),\n                                          C->getValue() & ~Mask));\n          UsedICmps++;\n          return true;\n        }\n      }\n\n      // If we already have a value for the switch, it has to match!\n      if (!setValueOnce(ICI->getOperand(0)))\n        return false;\n\n      UsedICmps++;\n      Vals.push_back(C);\n      return ICI->getOperand(0);\n    }\n\n    // If we have \"x ult 3\", for example, then we can add 0,1,2 to the set.\n    ConstantRange Span = ConstantRange::makeAllowedICmpRegion(\n        ICI->getPredicate(), C->getValue());\n\n    // Shift the range if the compare is fed by an add. This is the range\n    // compare idiom as emitted by instcombine.\n    Value *CandidateVal = I->getOperand(0);\n    if (match(I->getOperand(0), m_Add(m_Value(RHSVal), m_APInt(RHSC)))) {\n      Span = Span.subtract(*RHSC);\n      CandidateVal = RHSVal;\n    }\n\n    // If this is an and/!= check, then we are looking to build the set of\n    // value that *don't* pass the and chain. I.e. to turn \"x ugt 2\" into\n    // x != 0 && x != 1.\n    if (!isEQ)\n      Span = Span.inverse();\n\n    // If there are a ton of values, we don't want to make a ginormous switch.\n    if (Span.isSizeLargerThan(8) || Span.isEmptySet()) {\n      return false;\n    }\n\n    // If we already have a value for the switch, it has to match!\n    if (!setValueOnce(CandidateVal))\n      return false;\n\n    // Add all values from the range to the set\n    for (APInt Tmp = Span.getLower(); Tmp != Span.getUpper(); ++Tmp)\n      Vals.push_back(ConstantInt::get(I->getContext(), Tmp));\n\n    UsedICmps++;\n    return true;\n  }\n\n  /// Given a potentially 'or'd or 'and'd together collection of icmp\n  /// eq/ne/lt/gt instructions that compare a value against a constant, extract\n  /// the value being compared, and stick the list constants into the Vals\n  /// vector.\n  /// One \"Extra\" case is allowed to differ from the other.\n  void gather(Value *V) {\n    bool isEQ = match(V, m_LogicalOr(m_Value(), m_Value()));\n\n    // Keep a stack (SmallVector for efficiency) for depth-first traversal\n    SmallVector<Value *, 8> DFT;\n    SmallPtrSet<Value *, 8> Visited;\n\n    // Initialize\n    Visited.insert(V);\n    DFT.push_back(V);\n\n    while (!DFT.empty()) {\n      V = DFT.pop_back_val();\n\n      if (Instruction *I = dyn_cast<Instruction>(V)) {\n        // If it is a || (or && depending on isEQ), process the operands.\n        Value *Op0, *Op1;\n        if (isEQ ? match(I, m_LogicalOr(m_Value(Op0), m_Value(Op1)))\n                 : match(I, m_LogicalAnd(m_Value(Op0), m_Value(Op1)))) {\n          if (Visited.insert(Op1).second)\n            DFT.push_back(Op1);\n          if (Visited.insert(Op0).second)\n            DFT.push_back(Op0);\n\n          continue;\n        }\n\n        // Try to match the current instruction\n        if (matchInstruction(I, isEQ))\n          // Match succeed, continue the loop\n          continue;\n      }\n\n      // One element of the sequence of || (or &&) could not be match as a\n      // comparison against the same value as the others.\n      // We allow only one \"Extra\" case to be checked before the switch\n      if (!Extra) {\n        Extra = V;\n        continue;\n      }\n      // Failed to parse a proper sequence, abort now\n      CompValue = nullptr;\n      break;\n    }\n  }\n};\n\n} // end anonymous namespace\n\nstatic void EraseTerminatorAndDCECond(Instruction *TI,\n                                      MemorySSAUpdater *MSSAU = nullptr) {\n  Instruction *Cond = nullptr;\n  if (SwitchInst *SI = dyn_cast<SwitchInst>(TI)) {\n    Cond = dyn_cast<Instruction>(SI->getCondition());\n  } else if (BranchInst *BI = dyn_cast<BranchInst>(TI)) {\n    if (BI->isConditional())\n      Cond = dyn_cast<Instruction>(BI->getCondition());\n  } else if (IndirectBrInst *IBI = dyn_cast<IndirectBrInst>(TI)) {\n    Cond = dyn_cast<Instruction>(IBI->getAddress());\n  }\n\n  TI->eraseFromParent();\n  if (Cond)\n    RecursivelyDeleteTriviallyDeadInstructions(Cond, nullptr, MSSAU);\n}\n\n/// Return true if the specified terminator checks\n/// to see if a value is equal to constant integer value.\nValue *SimplifyCFGOpt::isValueEqualityComparison(Instruction *TI) {\n  Value *CV = nullptr;\n  if (SwitchInst *SI = dyn_cast<SwitchInst>(TI)) {\n    // Do not permit merging of large switch instructions into their\n    // predecessors unless there is only one predecessor.\n    if (!SI->getParent()->hasNPredecessorsOrMore(128 / SI->getNumSuccessors()))\n      CV = SI->getCondition();\n  } else if (BranchInst *BI = dyn_cast<BranchInst>(TI))\n    if (BI->isConditional() && BI->getCondition()->hasOneUse())\n      if (ICmpInst *ICI = dyn_cast<ICmpInst>(BI->getCondition())) {\n        if (ICI->isEquality() && GetConstantInt(ICI->getOperand(1), DL))\n          CV = ICI->getOperand(0);\n      }\n\n  // Unwrap any lossless ptrtoint cast.\n  if (CV) {\n    if (PtrToIntInst *PTII = dyn_cast<PtrToIntInst>(CV)) {\n      Value *Ptr = PTII->getPointerOperand();\n      if (PTII->getType() == DL.getIntPtrType(Ptr->getType()))\n        CV = Ptr;\n    }\n  }\n  return CV;\n}\n\n/// Given a value comparison instruction,\n/// decode all of the 'cases' that it represents and return the 'default' block.\nBasicBlock *SimplifyCFGOpt::GetValueEqualityComparisonCases(\n    Instruction *TI, std::vector<ValueEqualityComparisonCase> &Cases) {\n  if (SwitchInst *SI = dyn_cast<SwitchInst>(TI)) {\n    Cases.reserve(SI->getNumCases());\n    for (auto Case : SI->cases())\n      Cases.push_back(ValueEqualityComparisonCase(Case.getCaseValue(),\n                                                  Case.getCaseSuccessor()));\n    return SI->getDefaultDest();\n  }\n\n  BranchInst *BI = cast<BranchInst>(TI);\n  ICmpInst *ICI = cast<ICmpInst>(BI->getCondition());\n  BasicBlock *Succ = BI->getSuccessor(ICI->getPredicate() == ICmpInst::ICMP_NE);\n  Cases.push_back(ValueEqualityComparisonCase(\n      GetConstantInt(ICI->getOperand(1), DL), Succ));\n  return BI->getSuccessor(ICI->getPredicate() == ICmpInst::ICMP_EQ);\n}\n\n/// Given a vector of bb/value pairs, remove any entries\n/// in the list that match the specified block.\nstatic void\nEliminateBlockCases(BasicBlock *BB,\n                    std::vector<ValueEqualityComparisonCase> &Cases) {\n  llvm::erase_value(Cases, BB);\n}\n\n/// Return true if there are any keys in C1 that exist in C2 as well.\nstatic bool ValuesOverlap(std::vector<ValueEqualityComparisonCase> &C1,\n                          std::vector<ValueEqualityComparisonCase> &C2) {\n  std::vector<ValueEqualityComparisonCase> *V1 = &C1, *V2 = &C2;\n\n  // Make V1 be smaller than V2.\n  if (V1->size() > V2->size())\n    std::swap(V1, V2);\n\n  if (V1->empty())\n    return false;\n  if (V1->size() == 1) {\n    // Just scan V2.\n    ConstantInt *TheVal = (*V1)[0].Value;\n    for (unsigned i = 0, e = V2->size(); i != e; ++i)\n      if (TheVal == (*V2)[i].Value)\n        return true;\n  }\n\n  // Otherwise, just sort both lists and compare element by element.\n  array_pod_sort(V1->begin(), V1->end());\n  array_pod_sort(V2->begin(), V2->end());\n  unsigned i1 = 0, i2 = 0, e1 = V1->size(), e2 = V2->size();\n  while (i1 != e1 && i2 != e2) {\n    if ((*V1)[i1].Value == (*V2)[i2].Value)\n      return true;\n    if ((*V1)[i1].Value < (*V2)[i2].Value)\n      ++i1;\n    else\n      ++i2;\n  }\n  return false;\n}\n\n// Set branch weights on SwitchInst. This sets the metadata if there is at\n// least one non-zero weight.\nstatic void setBranchWeights(SwitchInst *SI, ArrayRef<uint32_t> Weights) {\n  // Check that there is at least one non-zero weight. Otherwise, pass\n  // nullptr to setMetadata which will erase the existing metadata.\n  MDNode *N = nullptr;\n  if (llvm::any_of(Weights, [](uint32_t W) { return W != 0; }))\n    N = MDBuilder(SI->getParent()->getContext()).createBranchWeights(Weights);\n  SI->setMetadata(LLVMContext::MD_prof, N);\n}\n\n// Similar to the above, but for branch and select instructions that take\n// exactly 2 weights.\nstatic void setBranchWeights(Instruction *I, uint32_t TrueWeight,\n                             uint32_t FalseWeight) {\n  assert(isa<BranchInst>(I) || isa<SelectInst>(I));\n  // Check that there is at least one non-zero weight. Otherwise, pass\n  // nullptr to setMetadata which will erase the existing metadata.\n  MDNode *N = nullptr;\n  if (TrueWeight || FalseWeight)\n    N = MDBuilder(I->getParent()->getContext())\n            .createBranchWeights(TrueWeight, FalseWeight);\n  I->setMetadata(LLVMContext::MD_prof, N);\n}\n\n/// If TI is known to be a terminator instruction and its block is known to\n/// only have a single predecessor block, check to see if that predecessor is\n/// also a value comparison with the same value, and if that comparison\n/// determines the outcome of this comparison. If so, simplify TI. This does a\n/// very limited form of jump threading.\nbool SimplifyCFGOpt::SimplifyEqualityComparisonWithOnlyPredecessor(\n    Instruction *TI, BasicBlock *Pred, IRBuilder<> &Builder) {\n  Value *PredVal = isValueEqualityComparison(Pred->getTerminator());\n  if (!PredVal)\n    return false; // Not a value comparison in predecessor.\n\n  Value *ThisVal = isValueEqualityComparison(TI);\n  assert(ThisVal && \"This isn't a value comparison!!\");\n  if (ThisVal != PredVal)\n    return false; // Different predicates.\n\n  // TODO: Preserve branch weight metadata, similarly to how\n  // FoldValueComparisonIntoPredecessors preserves it.\n\n  // Find out information about when control will move from Pred to TI's block.\n  std::vector<ValueEqualityComparisonCase> PredCases;\n  BasicBlock *PredDef =\n      GetValueEqualityComparisonCases(Pred->getTerminator(), PredCases);\n  EliminateBlockCases(PredDef, PredCases); // Remove default from cases.\n\n  // Find information about how control leaves this block.\n  std::vector<ValueEqualityComparisonCase> ThisCases;\n  BasicBlock *ThisDef = GetValueEqualityComparisonCases(TI, ThisCases);\n  EliminateBlockCases(ThisDef, ThisCases); // Remove default from cases.\n\n  // If TI's block is the default block from Pred's comparison, potentially\n  // simplify TI based on this knowledge.\n  if (PredDef == TI->getParent()) {\n    // If we are here, we know that the value is none of those cases listed in\n    // PredCases.  If there are any cases in ThisCases that are in PredCases, we\n    // can simplify TI.\n    if (!ValuesOverlap(PredCases, ThisCases))\n      return false;\n\n    if (isa<BranchInst>(TI)) {\n      // Okay, one of the successors of this condbr is dead.  Convert it to a\n      // uncond br.\n      assert(ThisCases.size() == 1 && \"Branch can only have one case!\");\n      // Insert the new branch.\n      Instruction *NI = Builder.CreateBr(ThisDef);\n      (void)NI;\n\n      // Remove PHI node entries for the dead edge.\n      ThisCases[0].Dest->removePredecessor(PredDef);\n\n      LLVM_DEBUG(dbgs() << \"Threading pred instr: \" << *Pred->getTerminator()\n                        << \"Through successor TI: \" << *TI << \"Leaving: \" << *NI\n                        << \"\\n\");\n\n      EraseTerminatorAndDCECond(TI);\n\n      if (DTU)\n        DTU->applyUpdates(\n            {{DominatorTree::Delete, PredDef, ThisCases[0].Dest}});\n\n      return true;\n    }\n\n    SwitchInstProfUpdateWrapper SI = *cast<SwitchInst>(TI);\n    // Okay, TI has cases that are statically dead, prune them away.\n    SmallPtrSet<Constant *, 16> DeadCases;\n    for (unsigned i = 0, e = PredCases.size(); i != e; ++i)\n      DeadCases.insert(PredCases[i].Value);\n\n    LLVM_DEBUG(dbgs() << \"Threading pred instr: \" << *Pred->getTerminator()\n                      << \"Through successor TI: \" << *TI);\n\n    SmallMapVector<BasicBlock *, int, 8> NumPerSuccessorCases;\n    for (SwitchInst::CaseIt i = SI->case_end(), e = SI->case_begin(); i != e;) {\n      --i;\n      auto *Successor = i->getCaseSuccessor();\n      ++NumPerSuccessorCases[Successor];\n      if (DeadCases.count(i->getCaseValue())) {\n        Successor->removePredecessor(PredDef);\n        SI.removeCase(i);\n        --NumPerSuccessorCases[Successor];\n      }\n    }\n\n    std::vector<DominatorTree::UpdateType> Updates;\n    for (const std::pair<BasicBlock *, int> &I : NumPerSuccessorCases)\n      if (I.second == 0)\n        Updates.push_back({DominatorTree::Delete, PredDef, I.first});\n    if (DTU)\n      DTU->applyUpdates(Updates);\n\n    LLVM_DEBUG(dbgs() << \"Leaving: \" << *TI << \"\\n\");\n    return true;\n  }\n\n  // Otherwise, TI's block must correspond to some matched value.  Find out\n  // which value (or set of values) this is.\n  ConstantInt *TIV = nullptr;\n  BasicBlock *TIBB = TI->getParent();\n  for (unsigned i = 0, e = PredCases.size(); i != e; ++i)\n    if (PredCases[i].Dest == TIBB) {\n      if (TIV)\n        return false; // Cannot handle multiple values coming to this block.\n      TIV = PredCases[i].Value;\n    }\n  assert(TIV && \"No edge from pred to succ?\");\n\n  // Okay, we found the one constant that our value can be if we get into TI's\n  // BB.  Find out which successor will unconditionally be branched to.\n  BasicBlock *TheRealDest = nullptr;\n  for (unsigned i = 0, e = ThisCases.size(); i != e; ++i)\n    if (ThisCases[i].Value == TIV) {\n      TheRealDest = ThisCases[i].Dest;\n      break;\n    }\n\n  // If not handled by any explicit cases, it is handled by the default case.\n  if (!TheRealDest)\n    TheRealDest = ThisDef;\n\n  SmallSetVector<BasicBlock *, 2> RemovedSuccs;\n\n  // Remove PHI node entries for dead edges.\n  BasicBlock *CheckEdge = TheRealDest;\n  for (BasicBlock *Succ : successors(TIBB))\n    if (Succ != CheckEdge) {\n      if (Succ != TheRealDest)\n        RemovedSuccs.insert(Succ);\n      Succ->removePredecessor(TIBB);\n    } else\n      CheckEdge = nullptr;\n\n  // Insert the new branch.\n  Instruction *NI = Builder.CreateBr(TheRealDest);\n  (void)NI;\n\n  LLVM_DEBUG(dbgs() << \"Threading pred instr: \" << *Pred->getTerminator()\n                    << \"Through successor TI: \" << *TI << \"Leaving: \" << *NI\n                    << \"\\n\");\n\n  EraseTerminatorAndDCECond(TI);\n  if (DTU) {\n    SmallVector<DominatorTree::UpdateType, 2> Updates;\n    Updates.reserve(RemovedSuccs.size());\n    for (auto *RemovedSucc : RemovedSuccs)\n      Updates.push_back({DominatorTree::Delete, TIBB, RemovedSucc});\n    DTU->applyUpdates(Updates);\n  }\n  return true;\n}\n\nnamespace {\n\n/// This class implements a stable ordering of constant\n/// integers that does not depend on their address.  This is important for\n/// applications that sort ConstantInt's to ensure uniqueness.\nstruct ConstantIntOrdering {\n  bool operator()(const ConstantInt *LHS, const ConstantInt *RHS) const {\n    return LHS->getValue().ult(RHS->getValue());\n  }\n};\n\n} // end anonymous namespace\n\nstatic int ConstantIntSortPredicate(ConstantInt *const *P1,\n                                    ConstantInt *const *P2) {\n  const ConstantInt *LHS = *P1;\n  const ConstantInt *RHS = *P2;\n  if (LHS == RHS)\n    return 0;\n  return LHS->getValue().ult(RHS->getValue()) ? 1 : -1;\n}\n\nstatic inline bool HasBranchWeights(const Instruction *I) {\n  MDNode *ProfMD = I->getMetadata(LLVMContext::MD_prof);\n  if (ProfMD && ProfMD->getOperand(0))\n    if (MDString *MDS = dyn_cast<MDString>(ProfMD->getOperand(0)))\n      return MDS->getString().equals(\"branch_weights\");\n\n  return false;\n}\n\n/// Get Weights of a given terminator, the default weight is at the front\n/// of the vector. If TI is a conditional eq, we need to swap the branch-weight\n/// metadata.\nstatic void GetBranchWeights(Instruction *TI,\n                             SmallVectorImpl<uint64_t> &Weights) {\n  MDNode *MD = TI->getMetadata(LLVMContext::MD_prof);\n  assert(MD);\n  for (unsigned i = 1, e = MD->getNumOperands(); i < e; ++i) {\n    ConstantInt *CI = mdconst::extract<ConstantInt>(MD->getOperand(i));\n    Weights.push_back(CI->getValue().getZExtValue());\n  }\n\n  // If TI is a conditional eq, the default case is the false case,\n  // and the corresponding branch-weight data is at index 2. We swap the\n  // default weight to be the first entry.\n  if (BranchInst *BI = dyn_cast<BranchInst>(TI)) {\n    assert(Weights.size() == 2);\n    ICmpInst *ICI = cast<ICmpInst>(BI->getCondition());\n    if (ICI->getPredicate() == ICmpInst::ICMP_EQ)\n      std::swap(Weights.front(), Weights.back());\n  }\n}\n\n/// Keep halving the weights until all can fit in uint32_t.\nstatic void FitWeights(MutableArrayRef<uint64_t> Weights) {\n  uint64_t Max = *std::max_element(Weights.begin(), Weights.end());\n  if (Max > UINT_MAX) {\n    unsigned Offset = 32 - countLeadingZeros(Max);\n    for (uint64_t &I : Weights)\n      I >>= Offset;\n  }\n}\n\nstatic void CloneInstructionsIntoPredecessorBlockAndUpdateSSAUses(\n    BasicBlock *BB, BasicBlock *PredBlock, ValueToValueMapTy &VMap) {\n  Instruction *PTI = PredBlock->getTerminator();\n\n  // If we have bonus instructions, clone them into the predecessor block.\n  // Note that there may be multiple predecessor blocks, so we cannot move\n  // bonus instructions to a predecessor block.\n  for (Instruction &BonusInst : *BB) {\n    if (isa<DbgInfoIntrinsic>(BonusInst) || BonusInst.isTerminator())\n      continue;\n\n    Instruction *NewBonusInst = BonusInst.clone();\n\n    if (PTI->getDebugLoc() != NewBonusInst->getDebugLoc()) {\n      // Unless the instruction has the same !dbg location as the original\n      // branch, drop it. When we fold the bonus instructions we want to make\n      // sure we reset their debug locations in order to avoid stepping on\n      // dead code caused by folding dead branches.\n      NewBonusInst->setDebugLoc(DebugLoc());\n    }\n\n    RemapInstruction(NewBonusInst, VMap,\n                     RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);\n    VMap[&BonusInst] = NewBonusInst;\n\n    // If we moved a load, we cannot any longer claim any knowledge about\n    // its potential value. The previous information might have been valid\n    // only given the branch precondition.\n    // For an analogous reason, we must also drop all the metadata whose\n    // semantics we don't understand. We *can* preserve !annotation, because\n    // it is tied to the instruction itself, not the value or position.\n    NewBonusInst->dropUnknownNonDebugMetadata(LLVMContext::MD_annotation);\n\n    PredBlock->getInstList().insert(PTI->getIterator(), NewBonusInst);\n    NewBonusInst->takeName(&BonusInst);\n    BonusInst.setName(NewBonusInst->getName() + \".old\");\n\n    // Update (liveout) uses of bonus instructions,\n    // now that the bonus instruction has been cloned into predecessor.\n    SSAUpdater SSAUpdate;\n    SSAUpdate.Initialize(BonusInst.getType(),\n                         (NewBonusInst->getName() + \".merge\").str());\n    SSAUpdate.AddAvailableValue(BB, &BonusInst);\n    SSAUpdate.AddAvailableValue(PredBlock, NewBonusInst);\n    for (Use &U : make_early_inc_range(BonusInst.uses()))\n      SSAUpdate.RewriteUseAfterInsertions(U);\n  }\n}\n\nbool SimplifyCFGOpt::PerformValueComparisonIntoPredecessorFolding(\n    Instruction *TI, Value *&CV, Instruction *PTI, IRBuilder<> &Builder) {\n  BasicBlock *BB = TI->getParent();\n  BasicBlock *Pred = PTI->getParent();\n\n  std::vector<DominatorTree::UpdateType> Updates;\n\n  // Figure out which 'cases' to copy from SI to PSI.\n  std::vector<ValueEqualityComparisonCase> BBCases;\n  BasicBlock *BBDefault = GetValueEqualityComparisonCases(TI, BBCases);\n\n  std::vector<ValueEqualityComparisonCase> PredCases;\n  BasicBlock *PredDefault = GetValueEqualityComparisonCases(PTI, PredCases);\n\n  // Based on whether the default edge from PTI goes to BB or not, fill in\n  // PredCases and PredDefault with the new switch cases we would like to\n  // build.\n  SmallMapVector<BasicBlock *, int, 8> NewSuccessors;\n\n  // Update the branch weight metadata along the way\n  SmallVector<uint64_t, 8> Weights;\n  bool PredHasWeights = HasBranchWeights(PTI);\n  bool SuccHasWeights = HasBranchWeights(TI);\n\n  if (PredHasWeights) {\n    GetBranchWeights(PTI, Weights);\n    // branch-weight metadata is inconsistent here.\n    if (Weights.size() != 1 + PredCases.size())\n      PredHasWeights = SuccHasWeights = false;\n  } else if (SuccHasWeights)\n    // If there are no predecessor weights but there are successor weights,\n    // populate Weights with 1, which will later be scaled to the sum of\n    // successor's weights\n    Weights.assign(1 + PredCases.size(), 1);\n\n  SmallVector<uint64_t, 8> SuccWeights;\n  if (SuccHasWeights) {\n    GetBranchWeights(TI, SuccWeights);\n    // branch-weight metadata is inconsistent here.\n    if (SuccWeights.size() != 1 + BBCases.size())\n      PredHasWeights = SuccHasWeights = false;\n  } else if (PredHasWeights)\n    SuccWeights.assign(1 + BBCases.size(), 1);\n\n  if (PredDefault == BB) {\n    // If this is the default destination from PTI, only the edges in TI\n    // that don't occur in PTI, or that branch to BB will be activated.\n    std::set<ConstantInt *, ConstantIntOrdering> PTIHandled;\n    for (unsigned i = 0, e = PredCases.size(); i != e; ++i)\n      if (PredCases[i].Dest != BB)\n        PTIHandled.insert(PredCases[i].Value);\n      else {\n        // The default destination is BB, we don't need explicit targets.\n        std::swap(PredCases[i], PredCases.back());\n\n        if (PredHasWeights || SuccHasWeights) {\n          // Increase weight for the default case.\n          Weights[0] += Weights[i + 1];\n          std::swap(Weights[i + 1], Weights.back());\n          Weights.pop_back();\n        }\n\n        PredCases.pop_back();\n        --i;\n        --e;\n      }\n\n    // Reconstruct the new switch statement we will be building.\n    if (PredDefault != BBDefault) {\n      PredDefault->removePredecessor(Pred);\n      if (PredDefault != BB)\n        Updates.push_back({DominatorTree::Delete, Pred, PredDefault});\n      PredDefault = BBDefault;\n      ++NewSuccessors[BBDefault];\n    }\n\n    unsigned CasesFromPred = Weights.size();\n    uint64_t ValidTotalSuccWeight = 0;\n    for (unsigned i = 0, e = BBCases.size(); i != e; ++i)\n      if (!PTIHandled.count(BBCases[i].Value) && BBCases[i].Dest != BBDefault) {\n        PredCases.push_back(BBCases[i]);\n        ++NewSuccessors[BBCases[i].Dest];\n        if (SuccHasWeights || PredHasWeights) {\n          // The default weight is at index 0, so weight for the ith case\n          // should be at index i+1. Scale the cases from successor by\n          // PredDefaultWeight (Weights[0]).\n          Weights.push_back(Weights[0] * SuccWeights[i + 1]);\n          ValidTotalSuccWeight += SuccWeights[i + 1];\n        }\n      }\n\n    if (SuccHasWeights || PredHasWeights) {\n      ValidTotalSuccWeight += SuccWeights[0];\n      // Scale the cases from predecessor by ValidTotalSuccWeight.\n      for (unsigned i = 1; i < CasesFromPred; ++i)\n        Weights[i] *= ValidTotalSuccWeight;\n      // Scale the default weight by SuccDefaultWeight (SuccWeights[0]).\n      Weights[0] *= SuccWeights[0];\n    }\n  } else {\n    // If this is not the default destination from PSI, only the edges\n    // in SI that occur in PSI with a destination of BB will be\n    // activated.\n    std::set<ConstantInt *, ConstantIntOrdering> PTIHandled;\n    std::map<ConstantInt *, uint64_t> WeightsForHandled;\n    for (unsigned i = 0, e = PredCases.size(); i != e; ++i)\n      if (PredCases[i].Dest == BB) {\n        PTIHandled.insert(PredCases[i].Value);\n\n        if (PredHasWeights || SuccHasWeights) {\n          WeightsForHandled[PredCases[i].Value] = Weights[i + 1];\n          std::swap(Weights[i + 1], Weights.back());\n          Weights.pop_back();\n        }\n\n        std::swap(PredCases[i], PredCases.back());\n        PredCases.pop_back();\n        --i;\n        --e;\n      }\n\n    // Okay, now we know which constants were sent to BB from the\n    // predecessor.  Figure out where they will all go now.\n    for (unsigned i = 0, e = BBCases.size(); i != e; ++i)\n      if (PTIHandled.count(BBCases[i].Value)) {\n        // If this is one we are capable of getting...\n        if (PredHasWeights || SuccHasWeights)\n          Weights.push_back(WeightsForHandled[BBCases[i].Value]);\n        PredCases.push_back(BBCases[i]);\n        ++NewSuccessors[BBCases[i].Dest];\n        PTIHandled.erase(BBCases[i].Value); // This constant is taken care of\n      }\n\n    // If there are any constants vectored to BB that TI doesn't handle,\n    // they must go to the default destination of TI.\n    for (ConstantInt *I : PTIHandled) {\n      if (PredHasWeights || SuccHasWeights)\n        Weights.push_back(WeightsForHandled[I]);\n      PredCases.push_back(ValueEqualityComparisonCase(I, BBDefault));\n      ++NewSuccessors[BBDefault];\n    }\n  }\n\n  // Okay, at this point, we know which new successor Pred will get.  Make\n  // sure we update the number of entries in the PHI nodes for these\n  // successors.\n  for (const std::pair<BasicBlock *, int /*Num*/> &NewSuccessor :\n       NewSuccessors) {\n    for (auto I : seq(0, NewSuccessor.second)) {\n      (void)I;\n      AddPredecessorToBlock(NewSuccessor.first, Pred, BB);\n    }\n    if (!is_contained(successors(Pred), NewSuccessor.first))\n      Updates.push_back({DominatorTree::Insert, Pred, NewSuccessor.first});\n  }\n\n  Builder.SetInsertPoint(PTI);\n  // Convert pointer to int before we switch.\n  if (CV->getType()->isPointerTy()) {\n    CV =\n        Builder.CreatePtrToInt(CV, DL.getIntPtrType(CV->getType()), \"magicptr\");\n  }\n\n  // Now that the successors are updated, create the new Switch instruction.\n  SwitchInst *NewSI = Builder.CreateSwitch(CV, PredDefault, PredCases.size());\n  NewSI->setDebugLoc(PTI->getDebugLoc());\n  for (ValueEqualityComparisonCase &V : PredCases)\n    NewSI->addCase(V.Value, V.Dest);\n\n  if (PredHasWeights || SuccHasWeights) {\n    // Halve the weights if any of them cannot fit in an uint32_t\n    FitWeights(Weights);\n\n    SmallVector<uint32_t, 8> MDWeights(Weights.begin(), Weights.end());\n\n    setBranchWeights(NewSI, MDWeights);\n  }\n\n  EraseTerminatorAndDCECond(PTI);\n\n  // Okay, last check.  If BB is still a successor of PSI, then we must\n  // have an infinite loop case.  If so, add an infinitely looping block\n  // to handle the case to preserve the behavior of the code.\n  BasicBlock *InfLoopBlock = nullptr;\n  for (unsigned i = 0, e = NewSI->getNumSuccessors(); i != e; ++i)\n    if (NewSI->getSuccessor(i) == BB) {\n      if (!InfLoopBlock) {\n        // Insert it at the end of the function, because it's either code,\n        // or it won't matter if it's hot. :)\n        InfLoopBlock =\n            BasicBlock::Create(BB->getContext(), \"infloop\", BB->getParent());\n        BranchInst::Create(InfLoopBlock, InfLoopBlock);\n        Updates.push_back({DominatorTree::Insert, InfLoopBlock, InfLoopBlock});\n      }\n      NewSI->setSuccessor(i, InfLoopBlock);\n    }\n\n  if (InfLoopBlock)\n    Updates.push_back({DominatorTree::Insert, Pred, InfLoopBlock});\n\n  Updates.push_back({DominatorTree::Delete, Pred, BB});\n\n  if (DTU)\n    DTU->applyUpdates(Updates);\n\n  ++NumFoldValueComparisonIntoPredecessors;\n  return true;\n}\n\n/// The specified terminator is a value equality comparison instruction\n/// (either a switch or a branch on \"X == c\").\n/// See if any of the predecessors of the terminator block are value comparisons\n/// on the same value.  If so, and if safe to do so, fold them together.\nbool SimplifyCFGOpt::FoldValueComparisonIntoPredecessors(Instruction *TI,\n                                                         IRBuilder<> &Builder) {\n  BasicBlock *BB = TI->getParent();\n  Value *CV = isValueEqualityComparison(TI); // CondVal\n  assert(CV && \"Not a comparison?\");\n\n  bool Changed = false;\n\n  SmallSetVector<BasicBlock *, 16> Preds(pred_begin(BB), pred_end(BB));\n  while (!Preds.empty()) {\n    BasicBlock *Pred = Preds.pop_back_val();\n    Instruction *PTI = Pred->getTerminator();\n\n    // Don't try to fold into itself.\n    if (Pred == BB)\n      continue;\n\n    // See if the predecessor is a comparison with the same value.\n    Value *PCV = isValueEqualityComparison(PTI); // PredCondVal\n    if (PCV != CV)\n      continue;\n\n    SmallSetVector<BasicBlock *, 4> FailBlocks;\n    if (!SafeToMergeTerminators(TI, PTI, &FailBlocks)) {\n      for (auto *Succ : FailBlocks) {\n        if (!SplitBlockPredecessors(Succ, TI->getParent(), \".fold.split\", DTU))\n          return false;\n      }\n    }\n\n    PerformValueComparisonIntoPredecessorFolding(TI, CV, PTI, Builder);\n    Changed = true;\n  }\n  return Changed;\n}\n\n// If we would need to insert a select that uses the value of this invoke\n// (comments in HoistThenElseCodeToIf explain why we would need to do this), we\n// can't hoist the invoke, as there is nowhere to put the select in this case.\nstatic bool isSafeToHoistInvoke(BasicBlock *BB1, BasicBlock *BB2,\n                                Instruction *I1, Instruction *I2) {\n  for (BasicBlock *Succ : successors(BB1)) {\n    for (const PHINode &PN : Succ->phis()) {\n      Value *BB1V = PN.getIncomingValueForBlock(BB1);\n      Value *BB2V = PN.getIncomingValueForBlock(BB2);\n      if (BB1V != BB2V && (BB1V == I1 || BB2V == I2)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nstatic bool passingValueIsAlwaysUndefined(Value *V, Instruction *I, bool PtrValueMayBeModified = false);\n\n/// Given a conditional branch that goes to BB1 and BB2, hoist any common code\n/// in the two blocks up into the branch block. The caller of this function\n/// guarantees that BI's block dominates BB1 and BB2.\nbool SimplifyCFGOpt::HoistThenElseCodeToIf(BranchInst *BI,\n                                           const TargetTransformInfo &TTI) {\n  // This does very trivial matching, with limited scanning, to find identical\n  // instructions in the two blocks.  In particular, we don't want to get into\n  // O(M*N) situations here where M and N are the sizes of BB1 and BB2.  As\n  // such, we currently just scan for obviously identical instructions in an\n  // identical order.\n  BasicBlock *BB1 = BI->getSuccessor(0); // The true destination.\n  BasicBlock *BB2 = BI->getSuccessor(1); // The false destination\n\n  BasicBlock::iterator BB1_Itr = BB1->begin();\n  BasicBlock::iterator BB2_Itr = BB2->begin();\n\n  Instruction *I1 = &*BB1_Itr++, *I2 = &*BB2_Itr++;\n  // Skip debug info if it is not identical.\n  DbgInfoIntrinsic *DBI1 = dyn_cast<DbgInfoIntrinsic>(I1);\n  DbgInfoIntrinsic *DBI2 = dyn_cast<DbgInfoIntrinsic>(I2);\n  if (!DBI1 || !DBI2 || !DBI1->isIdenticalToWhenDefined(DBI2)) {\n    while (isa<DbgInfoIntrinsic>(I1))\n      I1 = &*BB1_Itr++;\n    while (isa<DbgInfoIntrinsic>(I2))\n      I2 = &*BB2_Itr++;\n  }\n  // FIXME: Can we define a safety predicate for CallBr?\n  if (isa<PHINode>(I1) || !I1->isIdenticalToWhenDefined(I2) ||\n      (isa<InvokeInst>(I1) && !isSafeToHoistInvoke(BB1, BB2, I1, I2)) ||\n      isa<CallBrInst>(I1))\n    return false;\n\n  BasicBlock *BIParent = BI->getParent();\n\n  bool Changed = false;\n\n  auto _ = make_scope_exit([&]() {\n    if (Changed)\n      ++NumHoistCommonCode;\n  });\n\n  do {\n    // If we are hoisting the terminator instruction, don't move one (making a\n    // broken BB), instead clone it, and remove BI.\n    if (I1->isTerminator())\n      goto HoistTerminator;\n\n    // If we're going to hoist a call, make sure that the two instructions we're\n    // commoning/hoisting are both marked with musttail, or neither of them is\n    // marked as such. Otherwise, we might end up in a situation where we hoist\n    // from a block where the terminator is a `ret` to a block where the terminator\n    // is a `br`, and `musttail` calls expect to be followed by a return.\n    auto *C1 = dyn_cast<CallInst>(I1);\n    auto *C2 = dyn_cast<CallInst>(I2);\n    if (C1 && C2)\n      if (C1->isMustTailCall() != C2->isMustTailCall())\n        return Changed;\n\n    if (!TTI.isProfitableToHoist(I1) || !TTI.isProfitableToHoist(I2))\n      return Changed;\n\n    // If any of the two call sites has nomerge attribute, stop hoisting.\n    if (const auto *CB1 = dyn_cast<CallBase>(I1))\n      if (CB1->cannotMerge())\n        return Changed;\n    if (const auto *CB2 = dyn_cast<CallBase>(I2))\n      if (CB2->cannotMerge())\n        return Changed;\n\n    if (isa<DbgInfoIntrinsic>(I1) || isa<DbgInfoIntrinsic>(I2)) {\n      assert (isa<DbgInfoIntrinsic>(I1) && isa<DbgInfoIntrinsic>(I2));\n      // The debug location is an integral part of a debug info intrinsic\n      // and can't be separated from it or replaced.  Instead of attempting\n      // to merge locations, simply hoist both copies of the intrinsic.\n      BIParent->getInstList().splice(BI->getIterator(),\n                                     BB1->getInstList(), I1);\n      BIParent->getInstList().splice(BI->getIterator(),\n                                     BB2->getInstList(), I2);\n      Changed = true;\n    } else {\n      // For a normal instruction, we just move one to right before the branch,\n      // then replace all uses of the other with the first.  Finally, we remove\n      // the now redundant second instruction.\n      BIParent->getInstList().splice(BI->getIterator(),\n                                     BB1->getInstList(), I1);\n      if (!I2->use_empty())\n        I2->replaceAllUsesWith(I1);\n      I1->andIRFlags(I2);\n      unsigned KnownIDs[] = {LLVMContext::MD_tbaa,\n                             LLVMContext::MD_range,\n                             LLVMContext::MD_fpmath,\n                             LLVMContext::MD_invariant_load,\n                             LLVMContext::MD_nonnull,\n                             LLVMContext::MD_invariant_group,\n                             LLVMContext::MD_align,\n                             LLVMContext::MD_dereferenceable,\n                             LLVMContext::MD_dereferenceable_or_null,\n                             LLVMContext::MD_mem_parallel_loop_access,\n                             LLVMContext::MD_access_group,\n                             LLVMContext::MD_preserve_access_index};\n      combineMetadata(I1, I2, KnownIDs, true);\n\n      // I1 and I2 are being combined into a single instruction.  Its debug\n      // location is the merged locations of the original instructions.\n      I1->applyMergedLocation(I1->getDebugLoc(), I2->getDebugLoc());\n\n      I2->eraseFromParent();\n      Changed = true;\n    }\n    ++NumHoistCommonInstrs;\n\n    I1 = &*BB1_Itr++;\n    I2 = &*BB2_Itr++;\n    // Skip debug info if it is not identical.\n    DbgInfoIntrinsic *DBI1 = dyn_cast<DbgInfoIntrinsic>(I1);\n    DbgInfoIntrinsic *DBI2 = dyn_cast<DbgInfoIntrinsic>(I2);\n    if (!DBI1 || !DBI2 || !DBI1->isIdenticalToWhenDefined(DBI2)) {\n      while (isa<DbgInfoIntrinsic>(I1))\n        I1 = &*BB1_Itr++;\n      while (isa<DbgInfoIntrinsic>(I2))\n        I2 = &*BB2_Itr++;\n    }\n  } while (I1->isIdenticalToWhenDefined(I2));\n\n  return true;\n\nHoistTerminator:\n  // It may not be possible to hoist an invoke.\n  // FIXME: Can we define a safety predicate for CallBr?\n  if (isa<InvokeInst>(I1) && !isSafeToHoistInvoke(BB1, BB2, I1, I2))\n    return Changed;\n\n  // TODO: callbr hoisting currently disabled pending further study.\n  if (isa<CallBrInst>(I1))\n    return Changed;\n\n  for (BasicBlock *Succ : successors(BB1)) {\n    for (PHINode &PN : Succ->phis()) {\n      Value *BB1V = PN.getIncomingValueForBlock(BB1);\n      Value *BB2V = PN.getIncomingValueForBlock(BB2);\n      if (BB1V == BB2V)\n        continue;\n\n      // Check for passingValueIsAlwaysUndefined here because we would rather\n      // eliminate undefined control flow then converting it to a select.\n      if (passingValueIsAlwaysUndefined(BB1V, &PN) ||\n          passingValueIsAlwaysUndefined(BB2V, &PN))\n        return Changed;\n\n      if (isa<ConstantExpr>(BB1V) && !isSafeToSpeculativelyExecute(BB1V))\n        return Changed;\n      if (isa<ConstantExpr>(BB2V) && !isSafeToSpeculativelyExecute(BB2V))\n        return Changed;\n    }\n  }\n\n  // Okay, it is safe to hoist the terminator.\n  Instruction *NT = I1->clone();\n  BIParent->getInstList().insert(BI->getIterator(), NT);\n  if (!NT->getType()->isVoidTy()) {\n    I1->replaceAllUsesWith(NT);\n    I2->replaceAllUsesWith(NT);\n    NT->takeName(I1);\n  }\n  Changed = true;\n  ++NumHoistCommonInstrs;\n\n  // Ensure terminator gets a debug location, even an unknown one, in case\n  // it involves inlinable calls.\n  NT->applyMergedLocation(I1->getDebugLoc(), I2->getDebugLoc());\n\n  // PHIs created below will adopt NT's merged DebugLoc.\n  IRBuilder<NoFolder> Builder(NT);\n\n  // Hoisting one of the terminators from our successor is a great thing.\n  // Unfortunately, the successors of the if/else blocks may have PHI nodes in\n  // them.  If they do, all PHI entries for BB1/BB2 must agree for all PHI\n  // nodes, so we insert select instruction to compute the final result.\n  std::map<std::pair<Value *, Value *>, SelectInst *> InsertedSelects;\n  for (BasicBlock *Succ : successors(BB1)) {\n    for (PHINode &PN : Succ->phis()) {\n      Value *BB1V = PN.getIncomingValueForBlock(BB1);\n      Value *BB2V = PN.getIncomingValueForBlock(BB2);\n      if (BB1V == BB2V)\n        continue;\n\n      // These values do not agree.  Insert a select instruction before NT\n      // that determines the right value.\n      SelectInst *&SI = InsertedSelects[std::make_pair(BB1V, BB2V)];\n      if (!SI) {\n        // Propagate fast-math-flags from phi node to its replacement select.\n        IRBuilder<>::FastMathFlagGuard FMFGuard(Builder);\n        if (isa<FPMathOperator>(PN))\n          Builder.setFastMathFlags(PN.getFastMathFlags());\n\n        SI = cast<SelectInst>(\n            Builder.CreateSelect(BI->getCondition(), BB1V, BB2V,\n                                 BB1V->getName() + \".\" + BB2V->getName(), BI));\n      }\n\n      // Make the PHI node use the select for all incoming values for BB1/BB2\n      for (unsigned i = 0, e = PN.getNumIncomingValues(); i != e; ++i)\n        if (PN.getIncomingBlock(i) == BB1 || PN.getIncomingBlock(i) == BB2)\n          PN.setIncomingValue(i, SI);\n    }\n  }\n\n  SmallVector<DominatorTree::UpdateType, 4> Updates;\n\n  // Update any PHI nodes in our new successors.\n  for (BasicBlock *Succ : successors(BB1)) {\n    AddPredecessorToBlock(Succ, BIParent, BB1);\n    Updates.push_back({DominatorTree::Insert, BIParent, Succ});\n  }\n  for (BasicBlock *Succ : successors(BI))\n    Updates.push_back({DominatorTree::Delete, BIParent, Succ});\n\n  EraseTerminatorAndDCECond(BI);\n  if (DTU)\n    DTU->applyUpdates(Updates);\n  return Changed;\n}\n\n// Check lifetime markers.\nstatic bool isLifeTimeMarker(const Instruction *I) {\n  if (auto II = dyn_cast<IntrinsicInst>(I)) {\n    switch (II->getIntrinsicID()) {\n    default:\n      break;\n    case Intrinsic::lifetime_start:\n    case Intrinsic::lifetime_end:\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO: Refine this. This should avoid cases like turning constant memcpy sizes\n// into variables.\nstatic bool replacingOperandWithVariableIsCheap(const Instruction *I,\n                                                int OpIdx) {\n  return !isa<IntrinsicInst>(I);\n}\n\n// All instructions in Insts belong to different blocks that all unconditionally\n// branch to a common successor. Analyze each instruction and return true if it\n// would be possible to sink them into their successor, creating one common\n// instruction instead. For every value that would be required to be provided by\n// PHI node (because an operand varies in each input block), add to PHIOperands.\nstatic bool canSinkInstructions(\n    ArrayRef<Instruction *> Insts,\n    DenseMap<Instruction *, SmallVector<Value *, 4>> &PHIOperands) {\n  // Prune out obviously bad instructions to move. Each instruction must have\n  // exactly zero or one use, and we check later that use is by a single, common\n  // PHI instruction in the successor.\n  bool HasUse = !Insts.front()->user_empty();\n  for (auto *I : Insts) {\n    // These instructions may change or break semantics if moved.\n    if (isa<PHINode>(I) || I->isEHPad() || isa<AllocaInst>(I) ||\n        I->getType()->isTokenTy())\n      return false;\n\n    // Conservatively return false if I is an inline-asm instruction. Sinking\n    // and merging inline-asm instructions can potentially create arguments\n    // that cannot satisfy the inline-asm constraints.\n    // If the instruction has nomerge attribute, return false.\n    if (const auto *C = dyn_cast<CallBase>(I))\n      if (C->isInlineAsm() || C->cannotMerge())\n        return false;\n\n    // Each instruction must have zero or one use.\n    if (HasUse && !I->hasOneUse())\n      return false;\n    if (!HasUse && !I->user_empty())\n      return false;\n  }\n\n  const Instruction *I0 = Insts.front();\n  for (auto *I : Insts)\n    if (!I->isSameOperationAs(I0))\n      return false;\n\n  // All instructions in Insts are known to be the same opcode. If they have a\n  // use, check that the only user is a PHI or in the same block as the\n  // instruction, because if a user is in the same block as an instruction we're\n  // contemplating sinking, it must already be determined to be sinkable.\n  if (HasUse) {\n    auto *PNUse = dyn_cast<PHINode>(*I0->user_begin());\n    auto *Succ = I0->getParent()->getTerminator()->getSuccessor(0);\n    if (!all_of(Insts, [&PNUse,&Succ](const Instruction *I) -> bool {\n          auto *U = cast<Instruction>(*I->user_begin());\n          return (PNUse &&\n                  PNUse->getParent() == Succ &&\n                  PNUse->getIncomingValueForBlock(I->getParent()) == I) ||\n                 U->getParent() == I->getParent();\n        }))\n      return false;\n  }\n\n  // Because SROA can't handle speculating stores of selects, try not to sink\n  // loads, stores or lifetime markers of allocas when we'd have to create a\n  // PHI for the address operand. Also, because it is likely that loads or\n  // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink\n  // them.\n  // This can cause code churn which can have unintended consequences down\n  // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.\n  // FIXME: This is a workaround for a deficiency in SROA - see\n  // https://llvm.org/bugs/show_bug.cgi?id=30188\n  if (isa<StoreInst>(I0) && any_of(Insts, [](const Instruction *I) {\n        return isa<AllocaInst>(I->getOperand(1)->stripPointerCasts());\n      }))\n    return false;\n  if (isa<LoadInst>(I0) && any_of(Insts, [](const Instruction *I) {\n        return isa<AllocaInst>(I->getOperand(0)->stripPointerCasts());\n      }))\n    return false;\n  if (isLifeTimeMarker(I0) && any_of(Insts, [](const Instruction *I) {\n        return isa<AllocaInst>(I->getOperand(1)->stripPointerCasts());\n      }))\n    return false;\n\n  for (unsigned OI = 0, OE = I0->getNumOperands(); OI != OE; ++OI) {\n    Value *Op = I0->getOperand(OI);\n    if (Op->getType()->isTokenTy())\n      // Don't touch any operand of token type.\n      return false;\n\n    auto SameAsI0 = [&I0, OI](const Instruction *I) {\n      assert(I->getNumOperands() == I0->getNumOperands());\n      return I->getOperand(OI) == I0->getOperand(OI);\n    };\n    if (!all_of(Insts, SameAsI0)) {\n      if ((isa<Constant>(Op) && !replacingOperandWithVariableIsCheap(I0, OI)) ||\n          !canReplaceOperandWithVariable(I0, OI))\n        // We can't create a PHI from this GEP.\n        return false;\n      // Don't create indirect calls! The called value is the final operand.\n      if (isa<CallBase>(I0) && OI == OE - 1) {\n        // FIXME: if the call was *already* indirect, we should do this.\n        return false;\n      }\n      for (auto *I : Insts)\n        PHIOperands[I].push_back(I->getOperand(OI));\n    }\n  }\n  return true;\n}\n\n// Assuming canSinkLastInstruction(Blocks) has returned true, sink the last\n// instruction of every block in Blocks to their common successor, commoning\n// into one instruction.\nstatic bool sinkLastInstruction(ArrayRef<BasicBlock*> Blocks) {\n  auto *BBEnd = Blocks[0]->getTerminator()->getSuccessor(0);\n\n  // canSinkLastInstruction returning true guarantees that every block has at\n  // least one non-terminator instruction.\n  SmallVector<Instruction*,4> Insts;\n  for (auto *BB : Blocks) {\n    Instruction *I = BB->getTerminator();\n    do {\n      I = I->getPrevNode();\n    } while (isa<DbgInfoIntrinsic>(I) && I != &BB->front());\n    if (!isa<DbgInfoIntrinsic>(I))\n      Insts.push_back(I);\n  }\n\n  // The only checking we need to do now is that all users of all instructions\n  // are the same PHI node. canSinkLastInstruction should have checked this but\n  // it is slightly over-aggressive - it gets confused by commutative instructions\n  // so double-check it here.\n  Instruction *I0 = Insts.front();\n  if (!I0->user_empty()) {\n    auto *PNUse = dyn_cast<PHINode>(*I0->user_begin());\n    if (!all_of(Insts, [&PNUse](const Instruction *I) -> bool {\n          auto *U = cast<Instruction>(*I->user_begin());\n          return U == PNUse;\n        }))\n      return false;\n  }\n\n  // We don't need to do any more checking here; canSinkLastInstruction should\n  // have done it all for us.\n  SmallVector<Value*, 4> NewOperands;\n  for (unsigned O = 0, E = I0->getNumOperands(); O != E; ++O) {\n    // This check is different to that in canSinkLastInstruction. There, we\n    // cared about the global view once simplifycfg (and instcombine) have\n    // completed - it takes into account PHIs that become trivially\n    // simplifiable.  However here we need a more local view; if an operand\n    // differs we create a PHI and rely on instcombine to clean up the very\n    // small mess we may make.\n    bool NeedPHI = any_of(Insts, [&I0, O](const Instruction *I) {\n      return I->getOperand(O) != I0->getOperand(O);\n    });\n    if (!NeedPHI) {\n      NewOperands.push_back(I0->getOperand(O));\n      continue;\n    }\n\n    // Create a new PHI in the successor block and populate it.\n    auto *Op = I0->getOperand(O);\n    assert(!Op->getType()->isTokenTy() && \"Can't PHI tokens!\");\n    auto *PN = PHINode::Create(Op->getType(), Insts.size(),\n                               Op->getName() + \".sink\", &BBEnd->front());\n    for (auto *I : Insts)\n      PN->addIncoming(I->getOperand(O), I->getParent());\n    NewOperands.push_back(PN);\n  }\n\n  // Arbitrarily use I0 as the new \"common\" instruction; remap its operands\n  // and move it to the start of the successor block.\n  for (unsigned O = 0, E = I0->getNumOperands(); O != E; ++O)\n    I0->getOperandUse(O).set(NewOperands[O]);\n  I0->moveBefore(&*BBEnd->getFirstInsertionPt());\n\n  // Update metadata and IR flags, and merge debug locations.\n  for (auto *I : Insts)\n    if (I != I0) {\n      // The debug location for the \"common\" instruction is the merged locations\n      // of all the commoned instructions.  We start with the original location\n      // of the \"common\" instruction and iteratively merge each location in the\n      // loop below.\n      // This is an N-way merge, which will be inefficient if I0 is a CallInst.\n      // However, as N-way merge for CallInst is rare, so we use simplified API\n      // instead of using complex API for N-way merge.\n      I0->applyMergedLocation(I0->getDebugLoc(), I->getDebugLoc());\n      combineMetadataForCSE(I0, I, true);\n      I0->andIRFlags(I);\n    }\n\n  if (!I0->user_empty()) {\n    // canSinkLastInstruction checked that all instructions were used by\n    // one and only one PHI node. Find that now, RAUW it to our common\n    // instruction and nuke it.\n    auto *PN = cast<PHINode>(*I0->user_begin());\n    PN->replaceAllUsesWith(I0);\n    PN->eraseFromParent();\n  }\n\n  // Finally nuke all instructions apart from the common instruction.\n  for (auto *I : Insts)\n    if (I != I0)\n      I->eraseFromParent();\n\n  return true;\n}\n\nnamespace {\n\n  // LockstepReverseIterator - Iterates through instructions\n  // in a set of blocks in reverse order from the first non-terminator.\n  // For example (assume all blocks have size n):\n  //   LockstepReverseIterator I([B1, B2, B3]);\n  //   *I-- = [B1[n], B2[n], B3[n]];\n  //   *I-- = [B1[n-1], B2[n-1], B3[n-1]];\n  //   *I-- = [B1[n-2], B2[n-2], B3[n-2]];\n  //   ...\n  class LockstepReverseIterator {\n    ArrayRef<BasicBlock*> Blocks;\n    SmallVector<Instruction*,4> Insts;\n    bool Fail;\n\n  public:\n    LockstepReverseIterator(ArrayRef<BasicBlock*> Blocks) : Blocks(Blocks) {\n      reset();\n    }\n\n    void reset() {\n      Fail = false;\n      Insts.clear();\n      for (auto *BB : Blocks) {\n        Instruction *Inst = BB->getTerminator();\n        for (Inst = Inst->getPrevNode(); Inst && isa<DbgInfoIntrinsic>(Inst);)\n          Inst = Inst->getPrevNode();\n        if (!Inst) {\n          // Block wasn't big enough.\n          Fail = true;\n          return;\n        }\n        Insts.push_back(Inst);\n      }\n    }\n\n    bool isValid() const {\n      return !Fail;\n    }\n\n    void operator--() {\n      if (Fail)\n        return;\n      for (auto *&Inst : Insts) {\n        for (Inst = Inst->getPrevNode(); Inst && isa<DbgInfoIntrinsic>(Inst);)\n          Inst = Inst->getPrevNode();\n        // Already at beginning of block.\n        if (!Inst) {\n          Fail = true;\n          return;\n        }\n      }\n    }\n\n    ArrayRef<Instruction*> operator * () const {\n      return Insts;\n    }\n  };\n\n} // end anonymous namespace\n\n/// Check whether BB's predecessors end with unconditional branches. If it is\n/// true, sink any common code from the predecessors to BB.\n/// We also allow one predecessor to end with conditional branch (but no more\n/// than one).\nstatic bool SinkCommonCodeFromPredecessors(BasicBlock *BB,\n                                           DomTreeUpdater *DTU) {\n  // We support two situations:\n  //   (1) all incoming arcs are unconditional\n  //   (2) one incoming arc is conditional\n  //\n  // (2) is very common in switch defaults and\n  // else-if patterns;\n  //\n  //   if (a) f(1);\n  //   else if (b) f(2);\n  //\n  // produces:\n  //\n  //       [if]\n  //      /    \\\n  //    [f(1)] [if]\n  //      |     | \\\n  //      |     |  |\n  //      |  [f(2)]|\n  //       \\    | /\n  //        [ end ]\n  //\n  // [end] has two unconditional predecessor arcs and one conditional. The\n  // conditional refers to the implicit empty 'else' arc. This conditional\n  // arc can also be caused by an empty default block in a switch.\n  //\n  // In this case, we attempt to sink code from all *unconditional* arcs.\n  // If we can sink instructions from these arcs (determined during the scan\n  // phase below) we insert a common successor for all unconditional arcs and\n  // connect that to [end], to enable sinking:\n  //\n  //       [if]\n  //      /    \\\n  //    [x(1)] [if]\n  //      |     | \\\n  //      |     |  \\\n  //      |  [x(2)] |\n  //       \\   /    |\n  //   [sink.split] |\n  //         \\     /\n  //         [ end ]\n  //\n  SmallVector<BasicBlock*,4> UnconditionalPreds;\n  Instruction *Cond = nullptr;\n  for (auto *B : predecessors(BB)) {\n    auto *T = B->getTerminator();\n    if (isa<BranchInst>(T) && cast<BranchInst>(T)->isUnconditional())\n      UnconditionalPreds.push_back(B);\n    else if ((isa<BranchInst>(T) || isa<SwitchInst>(T)) && !Cond)\n      Cond = T;\n    else\n      return false;\n  }\n  if (UnconditionalPreds.size() < 2)\n    return false;\n\n  // We take a two-step approach to tail sinking. First we scan from the end of\n  // each block upwards in lockstep. If the n'th instruction from the end of each\n  // block can be sunk, those instructions are added to ValuesToSink and we\n  // carry on. If we can sink an instruction but need to PHI-merge some operands\n  // (because they're not identical in each instruction) we add these to\n  // PHIOperands.\n  unsigned ScanIdx = 0;\n  SmallPtrSet<Value*,4> InstructionsToSink;\n  DenseMap<Instruction*, SmallVector<Value*,4>> PHIOperands;\n  LockstepReverseIterator LRI(UnconditionalPreds);\n  while (LRI.isValid() &&\n         canSinkInstructions(*LRI, PHIOperands)) {\n    LLVM_DEBUG(dbgs() << \"SINK: instruction can be sunk: \" << *(*LRI)[0]\n                      << \"\\n\");\n    InstructionsToSink.insert((*LRI).begin(), (*LRI).end());\n    ++ScanIdx;\n    --LRI;\n  }\n\n  // If no instructions can be sunk, early-return.\n  if (ScanIdx == 0)\n    return false;\n\n  bool Changed = false;\n\n  auto ProfitableToSinkInstruction = [&](LockstepReverseIterator &LRI) {\n    unsigned NumPHIdValues = 0;\n    for (auto *I : *LRI)\n      for (auto *V : PHIOperands[I])\n        if (InstructionsToSink.count(V) == 0)\n          ++NumPHIdValues;\n    LLVM_DEBUG(dbgs() << \"SINK: #phid values: \" << NumPHIdValues << \"\\n\");\n    unsigned NumPHIInsts = NumPHIdValues / UnconditionalPreds.size();\n    if ((NumPHIdValues % UnconditionalPreds.size()) != 0)\n        NumPHIInsts++;\n\n    return NumPHIInsts <= 1;\n  };\n\n  if (Cond) {\n    // Check if we would actually sink anything first! This mutates the CFG and\n    // adds an extra block. The goal in doing this is to allow instructions that\n    // couldn't be sunk before to be sunk - obviously, speculatable instructions\n    // (such as trunc, add) can be sunk and predicated already. So we check that\n    // we're going to sink at least one non-speculatable instruction.\n    LRI.reset();\n    unsigned Idx = 0;\n    bool Profitable = false;\n    while (ProfitableToSinkInstruction(LRI) && Idx < ScanIdx) {\n      if (!isSafeToSpeculativelyExecute((*LRI)[0])) {\n        Profitable = true;\n        break;\n      }\n      --LRI;\n      ++Idx;\n    }\n    if (!Profitable)\n      return false;\n\n    LLVM_DEBUG(dbgs() << \"SINK: Splitting edge\\n\");\n    // We have a conditional edge and we're going to sink some instructions.\n    // Insert a new block postdominating all blocks we're going to sink from.\n    if (!SplitBlockPredecessors(BB, UnconditionalPreds, \".sink.split\", DTU))\n      // Edges couldn't be split.\n      return false;\n    Changed = true;\n  }\n\n  // Now that we've analyzed all potential sinking candidates, perform the\n  // actual sink. We iteratively sink the last non-terminator of the source\n  // blocks into their common successor unless doing so would require too\n  // many PHI instructions to be generated (currently only one PHI is allowed\n  // per sunk instruction).\n  //\n  // We can use InstructionsToSink to discount values needing PHI-merging that will\n  // actually be sunk in a later iteration. This allows us to be more\n  // aggressive in what we sink. This does allow a false positive where we\n  // sink presuming a later value will also be sunk, but stop half way through\n  // and never actually sink it which means we produce more PHIs than intended.\n  // This is unlikely in practice though.\n  unsigned SinkIdx = 0;\n  for (; SinkIdx != ScanIdx; ++SinkIdx) {\n    LLVM_DEBUG(dbgs() << \"SINK: Sink: \"\n                      << *UnconditionalPreds[0]->getTerminator()->getPrevNode()\n                      << \"\\n\");\n\n    // Because we've sunk every instruction in turn, the current instruction to\n    // sink is always at index 0.\n    LRI.reset();\n    if (!ProfitableToSinkInstruction(LRI)) {\n      // Too many PHIs would be created.\n      LLVM_DEBUG(\n          dbgs() << \"SINK: stopping here, too many PHIs would be created!\\n\");\n      break;\n    }\n\n    if (!sinkLastInstruction(UnconditionalPreds)) {\n      LLVM_DEBUG(\n          dbgs()\n          << \"SINK: stopping here, failed to actually sink instruction!\\n\");\n      break;\n    }\n\n    NumSinkCommonInstrs++;\n    Changed = true;\n  }\n  if (SinkIdx != 0)\n    ++NumSinkCommonCode;\n  return Changed;\n}\n\n/// Determine if we can hoist sink a sole store instruction out of a\n/// conditional block.\n///\n/// We are looking for code like the following:\n///   BrBB:\n///     store i32 %add, i32* %arrayidx2\n///     ... // No other stores or function calls (we could be calling a memory\n///     ... // function).\n///     %cmp = icmp ult %x, %y\n///     br i1 %cmp, label %EndBB, label %ThenBB\n///   ThenBB:\n///     store i32 %add5, i32* %arrayidx2\n///     br label EndBB\n///   EndBB:\n///     ...\n///   We are going to transform this into:\n///   BrBB:\n///     store i32 %add, i32* %arrayidx2\n///     ... //\n///     %cmp = icmp ult %x, %y\n///     %add.add5 = select i1 %cmp, i32 %add, %add5\n///     store i32 %add.add5, i32* %arrayidx2\n///     ...\n///\n/// \\return The pointer to the value of the previous store if the store can be\n///         hoisted into the predecessor block. 0 otherwise.\nstatic Value *isSafeToSpeculateStore(Instruction *I, BasicBlock *BrBB,\n                                     BasicBlock *StoreBB, BasicBlock *EndBB) {\n  StoreInst *StoreToHoist = dyn_cast<StoreInst>(I);\n  if (!StoreToHoist)\n    return nullptr;\n\n  // Volatile or atomic.\n  if (!StoreToHoist->isSimple())\n    return nullptr;\n\n  Value *StorePtr = StoreToHoist->getPointerOperand();\n\n  // Look for a store to the same pointer in BrBB.\n  unsigned MaxNumInstToLookAt = 9;\n  // Skip pseudo probe intrinsic calls which are not really killing any memory\n  // accesses.\n  for (Instruction &CurI : reverse(BrBB->instructionsWithoutDebug(true))) {\n    if (!MaxNumInstToLookAt)\n      break;\n    --MaxNumInstToLookAt;\n\n    // Could be calling an instruction that affects memory like free().\n    if (CurI.mayHaveSideEffects() && !isa<StoreInst>(CurI))\n      return nullptr;\n\n    if (auto *SI = dyn_cast<StoreInst>(&CurI)) {\n      // Found the previous store make sure it stores to the same location.\n      if (SI->getPointerOperand() == StorePtr)\n        // Found the previous store, return its value operand.\n        return SI->getValueOperand();\n      return nullptr; // Unknown store.\n    }\n  }\n\n  return nullptr;\n}\n\n/// Estimate the cost of the insertion(s) and check that the PHI nodes can be\n/// converted to selects.\nstatic bool validateAndCostRequiredSelects(BasicBlock *BB, BasicBlock *ThenBB,\n                                           BasicBlock *EndBB,\n                                           unsigned &SpeculatedInstructions,\n                                           InstructionCost &Cost,\n                                           const TargetTransformInfo &TTI) {\n  TargetTransformInfo::TargetCostKind CostKind =\n    BB->getParent()->hasMinSize()\n    ? TargetTransformInfo::TCK_CodeSize\n    : TargetTransformInfo::TCK_SizeAndLatency;\n\n  bool HaveRewritablePHIs = false;\n  for (PHINode &PN : EndBB->phis()) {\n    Value *OrigV = PN.getIncomingValueForBlock(BB);\n    Value *ThenV = PN.getIncomingValueForBlock(ThenBB);\n\n    // FIXME: Try to remove some of the duplication with HoistThenElseCodeToIf.\n    // Skip PHIs which are trivial.\n    if (ThenV == OrigV)\n      continue;\n\n    Cost += TTI.getCmpSelInstrCost(Instruction::Select, PN.getType(), nullptr,\n                                   CmpInst::BAD_ICMP_PREDICATE, CostKind);\n\n    // Don't convert to selects if we could remove undefined behavior instead.\n    if (passingValueIsAlwaysUndefined(OrigV, &PN) ||\n        passingValueIsAlwaysUndefined(ThenV, &PN))\n      return false;\n\n    HaveRewritablePHIs = true;\n    ConstantExpr *OrigCE = dyn_cast<ConstantExpr>(OrigV);\n    ConstantExpr *ThenCE = dyn_cast<ConstantExpr>(ThenV);\n    if (!OrigCE && !ThenCE)\n      continue; // Known safe and cheap.\n\n    if ((ThenCE && !isSafeToSpeculativelyExecute(ThenCE)) ||\n        (OrigCE && !isSafeToSpeculativelyExecute(OrigCE)))\n      return false;\n    InstructionCost OrigCost = OrigCE ? computeSpeculationCost(OrigCE, TTI) : 0;\n    InstructionCost ThenCost = ThenCE ? computeSpeculationCost(ThenCE, TTI) : 0;\n    InstructionCost MaxCost =\n        2 * PHINodeFoldingThreshold * TargetTransformInfo::TCC_Basic;\n    if (OrigCost + ThenCost > MaxCost)\n      return false;\n\n    // Account for the cost of an unfolded ConstantExpr which could end up\n    // getting expanded into Instructions.\n    // FIXME: This doesn't account for how many operations are combined in the\n    // constant expression.\n    ++SpeculatedInstructions;\n    if (SpeculatedInstructions > 1)\n      return false;\n  }\n\n  return HaveRewritablePHIs;\n}\n\n/// Speculate a conditional basic block flattening the CFG.\n///\n/// Note that this is a very risky transform currently. Speculating\n/// instructions like this is most often not desirable. Instead, there is an MI\n/// pass which can do it with full awareness of the resource constraints.\n/// However, some cases are \"obvious\" and we should do directly. An example of\n/// this is speculating a single, reasonably cheap instruction.\n///\n/// There is only one distinct advantage to flattening the CFG at the IR level:\n/// it makes very common but simplistic optimizations such as are common in\n/// instcombine and the DAG combiner more powerful by removing CFG edges and\n/// modeling their effects with easier to reason about SSA value graphs.\n///\n///\n/// An illustration of this transform is turning this IR:\n/// \\code\n///   BB:\n///     %cmp = icmp ult %x, %y\n///     br i1 %cmp, label %EndBB, label %ThenBB\n///   ThenBB:\n///     %sub = sub %x, %y\n///     br label BB2\n///   EndBB:\n///     %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]\n///     ...\n/// \\endcode\n///\n/// Into this IR:\n/// \\code\n///   BB:\n///     %cmp = icmp ult %x, %y\n///     %sub = sub %x, %y\n///     %cond = select i1 %cmp, 0, %sub\n///     ...\n/// \\endcode\n///\n/// \\returns true if the conditional block is removed.\nbool SimplifyCFGOpt::SpeculativelyExecuteBB(BranchInst *BI, BasicBlock *ThenBB,\n                                            const TargetTransformInfo &TTI) {\n  // Be conservative for now. FP select instruction can often be expensive.\n  Value *BrCond = BI->getCondition();\n  if (isa<FCmpInst>(BrCond))\n    return false;\n\n  BasicBlock *BB = BI->getParent();\n  BasicBlock *EndBB = ThenBB->getTerminator()->getSuccessor(0);\n  InstructionCost Budget =\n      PHINodeFoldingThreshold * TargetTransformInfo::TCC_Basic;\n\n  // If ThenBB is actually on the false edge of the conditional branch, remember\n  // to swap the select operands later.\n  bool Invert = false;\n  if (ThenBB != BI->getSuccessor(0)) {\n    assert(ThenBB == BI->getSuccessor(1) && \"No edge from 'if' block?\");\n    Invert = true;\n  }\n  assert(EndBB == BI->getSuccessor(!Invert) && \"No edge from to end block\");\n\n  // Keep a count of how many times instructions are used within ThenBB when\n  // they are candidates for sinking into ThenBB. Specifically:\n  // - They are defined in BB, and\n  // - They have no side effects, and\n  // - All of their uses are in ThenBB.\n  SmallDenseMap<Instruction *, unsigned, 4> SinkCandidateUseCounts;\n\n  SmallVector<Instruction *, 4> SpeculatedDbgIntrinsics;\n\n  unsigned SpeculatedInstructions = 0;\n  Value *SpeculatedStoreValue = nullptr;\n  StoreInst *SpeculatedStore = nullptr;\n  for (BasicBlock::iterator BBI = ThenBB->begin(),\n                            BBE = std::prev(ThenBB->end());\n       BBI != BBE; ++BBI) {\n    Instruction *I = &*BBI;\n    // Skip debug info.\n    if (isa<DbgInfoIntrinsic>(I)) {\n      SpeculatedDbgIntrinsics.push_back(I);\n      continue;\n    }\n\n    // Skip pseudo probes. The consequence is we lose track of the branch\n    // probability for ThenBB, which is fine since the optimization here takes\n    // place regardless of the branch probability.\n    if (isa<PseudoProbeInst>(I)) {\n      continue;\n    }\n\n    // Only speculatively execute a single instruction (not counting the\n    // terminator) for now.\n    ++SpeculatedInstructions;\n    if (SpeculatedInstructions > 1)\n      return false;\n\n    // Don't hoist the instruction if it's unsafe or expensive.\n    if (!isSafeToSpeculativelyExecute(I) &&\n        !(HoistCondStores && (SpeculatedStoreValue = isSafeToSpeculateStore(\n                                  I, BB, ThenBB, EndBB))))\n      return false;\n    if (!SpeculatedStoreValue &&\n        computeSpeculationCost(I, TTI) >\n            PHINodeFoldingThreshold * TargetTransformInfo::TCC_Basic)\n      return false;\n\n    // Store the store speculation candidate.\n    if (SpeculatedStoreValue)\n      SpeculatedStore = cast<StoreInst>(I);\n\n    // Do not hoist the instruction if any of its operands are defined but not\n    // used in BB. The transformation will prevent the operand from\n    // being sunk into the use block.\n    for (Use &Op : I->operands()) {\n      Instruction *OpI = dyn_cast<Instruction>(Op);\n      if (!OpI || OpI->getParent() != BB || OpI->mayHaveSideEffects())\n        continue; // Not a candidate for sinking.\n\n      ++SinkCandidateUseCounts[OpI];\n    }\n  }\n\n  // Consider any sink candidates which are only used in ThenBB as costs for\n  // speculation. Note, while we iterate over a DenseMap here, we are summing\n  // and so iteration order isn't significant.\n  for (SmallDenseMap<Instruction *, unsigned, 4>::iterator\n           I = SinkCandidateUseCounts.begin(),\n           E = SinkCandidateUseCounts.end();\n       I != E; ++I)\n    if (I->first->hasNUses(I->second)) {\n      ++SpeculatedInstructions;\n      if (SpeculatedInstructions > 1)\n        return false;\n    }\n\n  // Check that we can insert the selects and that it's not too expensive to do\n  // so.\n  bool Convert = SpeculatedStore != nullptr;\n  InstructionCost Cost = 0;\n  Convert |= validateAndCostRequiredSelects(BB, ThenBB, EndBB,\n                                            SpeculatedInstructions,\n                                            Cost, TTI);\n  if (!Convert || Cost > Budget)\n    return false;\n\n  // If we get here, we can hoist the instruction and if-convert.\n  LLVM_DEBUG(dbgs() << \"SPECULATIVELY EXECUTING BB\" << *ThenBB << \"\\n\";);\n\n  // Insert a select of the value of the speculated store.\n  if (SpeculatedStoreValue) {\n    IRBuilder<NoFolder> Builder(BI);\n    Value *TrueV = SpeculatedStore->getValueOperand();\n    Value *FalseV = SpeculatedStoreValue;\n    if (Invert)\n      std::swap(TrueV, FalseV);\n    Value *S = Builder.CreateSelect(\n        BrCond, TrueV, FalseV, \"spec.store.select\", BI);\n    SpeculatedStore->setOperand(0, S);\n    SpeculatedStore->applyMergedLocation(BI->getDebugLoc(),\n                                         SpeculatedStore->getDebugLoc());\n  }\n\n  // Metadata can be dependent on the condition we are hoisting above.\n  // Conservatively strip all metadata on the instruction. Drop the debug loc\n  // to avoid making it appear as if the condition is a constant, which would\n  // be misleading while debugging.\n  for (auto &I : *ThenBB) {\n    if (!SpeculatedStoreValue || &I != SpeculatedStore)\n      I.setDebugLoc(DebugLoc());\n    I.dropUnknownNonDebugMetadata();\n  }\n\n  // A hoisted conditional probe should be treated as dangling so that it will\n  // not be over-counted when the samples collected on the non-conditional path\n  // are counted towards the conditional path. We leave it for the counts\n  // inference algorithm to figure out a proper count for a danglng probe.\n  moveAndDanglePseudoProbes(ThenBB, BI);\n\n  // Hoist the instructions.\n  BB->getInstList().splice(BI->getIterator(), ThenBB->getInstList(),\n                           ThenBB->begin(), std::prev(ThenBB->end()));\n\n  // Insert selects and rewrite the PHI operands.\n  IRBuilder<NoFolder> Builder(BI);\n  for (PHINode &PN : EndBB->phis()) {\n    unsigned OrigI = PN.getBasicBlockIndex(BB);\n    unsigned ThenI = PN.getBasicBlockIndex(ThenBB);\n    Value *OrigV = PN.getIncomingValue(OrigI);\n    Value *ThenV = PN.getIncomingValue(ThenI);\n\n    // Skip PHIs which are trivial.\n    if (OrigV == ThenV)\n      continue;\n\n    // Create a select whose true value is the speculatively executed value and\n    // false value is the pre-existing value. Swap them if the branch\n    // destinations were inverted.\n    Value *TrueV = ThenV, *FalseV = OrigV;\n    if (Invert)\n      std::swap(TrueV, FalseV);\n    Value *V = Builder.CreateSelect(BrCond, TrueV, FalseV, \"spec.select\", BI);\n    PN.setIncomingValue(OrigI, V);\n    PN.setIncomingValue(ThenI, V);\n  }\n\n  // Remove speculated dbg intrinsics.\n  // FIXME: Is it possible to do this in a more elegant way? Moving/merging the\n  // dbg value for the different flows and inserting it after the select.\n  for (Instruction *I : SpeculatedDbgIntrinsics)\n    I->eraseFromParent();\n\n  ++NumSpeculations;\n  return true;\n}\n\n/// Return true if we can thread a branch across this block.\nstatic bool BlockIsSimpleEnoughToThreadThrough(BasicBlock *BB) {\n  int Size = 0;\n\n  for (Instruction &I : BB->instructionsWithoutDebug()) {\n    if (Size > MaxSmallBlockSize)\n      return false; // Don't clone large BB's.\n\n    // Can't fold blocks that contain noduplicate or convergent calls.\n    if (CallInst *CI = dyn_cast<CallInst>(&I))\n      if (CI->cannotDuplicate() || CI->isConvergent())\n        return false;\n\n    // We will delete Phis while threading, so Phis should not be accounted in\n    // block's size\n    if (!isa<PHINode>(I))\n      ++Size;\n\n    // We can only support instructions that do not define values that are\n    // live outside of the current basic block.\n    for (User *U : I.users()) {\n      Instruction *UI = cast<Instruction>(U);\n      if (UI->getParent() != BB || isa<PHINode>(UI))\n        return false;\n    }\n\n    // Looks ok, continue checking.\n  }\n\n  return true;\n}\n\n/// If we have a conditional branch on a PHI node value that is defined in the\n/// same block as the branch and if any PHI entries are constants, thread edges\n/// corresponding to that entry to be branches to their ultimate destination.\nstatic bool FoldCondBranchOnPHI(BranchInst *BI, DomTreeUpdater *DTU,\n                                const DataLayout &DL, AssumptionCache *AC) {\n  BasicBlock *BB = BI->getParent();\n  PHINode *PN = dyn_cast<PHINode>(BI->getCondition());\n  // NOTE: we currently cannot transform this case if the PHI node is used\n  // outside of the block.\n  if (!PN || PN->getParent() != BB || !PN->hasOneUse())\n    return false;\n\n  // Degenerate case of a single entry PHI.\n  if (PN->getNumIncomingValues() == 1) {\n    FoldSingleEntryPHINodes(PN->getParent());\n    return true;\n  }\n\n  // Now we know that this block has multiple preds and two succs.\n  if (!BlockIsSimpleEnoughToThreadThrough(BB))\n    return false;\n\n  // Okay, this is a simple enough basic block.  See if any phi values are\n  // constants.\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i) {\n    ConstantInt *CB = dyn_cast<ConstantInt>(PN->getIncomingValue(i));\n    if (!CB || !CB->getType()->isIntegerTy(1))\n      continue;\n\n    // Okay, we now know that all edges from PredBB should be revectored to\n    // branch to RealDest.\n    BasicBlock *PredBB = PN->getIncomingBlock(i);\n    BasicBlock *RealDest = BI->getSuccessor(!CB->getZExtValue());\n\n    if (RealDest == BB)\n      continue; // Skip self loops.\n    // Skip if the predecessor's terminator is an indirect branch.\n    if (isa<IndirectBrInst>(PredBB->getTerminator()))\n      continue;\n\n    SmallVector<DominatorTree::UpdateType, 3> Updates;\n\n    // The dest block might have PHI nodes, other predecessors and other\n    // difficult cases.  Instead of being smart about this, just insert a new\n    // block that jumps to the destination block, effectively splitting\n    // the edge we are about to create.\n    BasicBlock *EdgeBB =\n        BasicBlock::Create(BB->getContext(), RealDest->getName() + \".critedge\",\n                           RealDest->getParent(), RealDest);\n    BranchInst *CritEdgeBranch = BranchInst::Create(RealDest, EdgeBB);\n    Updates.push_back({DominatorTree::Insert, EdgeBB, RealDest});\n    CritEdgeBranch->setDebugLoc(BI->getDebugLoc());\n\n    // Update PHI nodes.\n    AddPredecessorToBlock(RealDest, EdgeBB, BB);\n\n    // BB may have instructions that are being threaded over.  Clone these\n    // instructions into EdgeBB.  We know that there will be no uses of the\n    // cloned instructions outside of EdgeBB.\n    BasicBlock::iterator InsertPt = EdgeBB->begin();\n    DenseMap<Value *, Value *> TranslateMap; // Track translated values.\n    for (BasicBlock::iterator BBI = BB->begin(); &*BBI != BI; ++BBI) {\n      if (PHINode *PN = dyn_cast<PHINode>(BBI)) {\n        TranslateMap[PN] = PN->getIncomingValueForBlock(PredBB);\n        continue;\n      }\n      // Clone the instruction.\n      Instruction *N = BBI->clone();\n      if (BBI->hasName())\n        N->setName(BBI->getName() + \".c\");\n\n      // Update operands due to translation.\n      for (Use &Op : N->operands()) {\n        DenseMap<Value *, Value *>::iterator PI = TranslateMap.find(Op);\n        if (PI != TranslateMap.end())\n          Op = PI->second;\n      }\n\n      // Check for trivial simplification.\n      if (Value *V = SimplifyInstruction(N, {DL, nullptr, nullptr, AC})) {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = V;\n        if (!N->mayHaveSideEffects()) {\n          N->deleteValue(); // Instruction folded away, don't need actual inst\n          N = nullptr;\n        }\n      } else {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = N;\n      }\n      if (N) {\n        // Insert the new instruction into its new home.\n        EdgeBB->getInstList().insert(InsertPt, N);\n\n        // Register the new instruction with the assumption cache if necessary.\n        if (AC && match(N, m_Intrinsic<Intrinsic::assume>()))\n          AC->registerAssumption(cast<IntrinsicInst>(N));\n      }\n    }\n\n    // Loop over all of the edges from PredBB to BB, changing them to branch\n    // to EdgeBB instead.\n    Instruction *PredBBTI = PredBB->getTerminator();\n    for (unsigned i = 0, e = PredBBTI->getNumSuccessors(); i != e; ++i)\n      if (PredBBTI->getSuccessor(i) == BB) {\n        BB->removePredecessor(PredBB);\n        PredBBTI->setSuccessor(i, EdgeBB);\n      }\n\n    Updates.push_back({DominatorTree::Insert, PredBB, EdgeBB});\n    Updates.push_back({DominatorTree::Delete, PredBB, BB});\n\n    if (DTU)\n      DTU->applyUpdates(Updates);\n\n    // Recurse, simplifying any other constants.\n    return FoldCondBranchOnPHI(BI, DTU, DL, AC) || true;\n  }\n\n  return false;\n}\n\n/// Given a BB that starts with the specified two-entry PHI node,\n/// see if we can eliminate it.\nstatic bool FoldTwoEntryPHINode(PHINode *PN, const TargetTransformInfo &TTI,\n                                DomTreeUpdater *DTU, const DataLayout &DL) {\n  // Ok, this is a two entry PHI node.  Check to see if this is a simple \"if\n  // statement\", which has a very simple dominance structure.  Basically, we\n  // are trying to find the condition that is being branched on, which\n  // subsequently causes this merge to happen.  We really want control\n  // dependence information for this check, but simplifycfg can't keep it up\n  // to date, and this catches most of the cases we care about anyway.\n  BasicBlock *BB = PN->getParent();\n\n  BasicBlock *IfTrue, *IfFalse;\n  Value *IfCond = GetIfCondition(BB, IfTrue, IfFalse);\n  if (!IfCond ||\n      // Don't bother if the branch will be constant folded trivially.\n      isa<ConstantInt>(IfCond))\n    return false;\n\n  // Okay, we found that we can merge this two-entry phi node into a select.\n  // Doing so would require us to fold *all* two entry phi nodes in this block.\n  // At some point this becomes non-profitable (particularly if the target\n  // doesn't support cmov's).  Only do this transformation if there are two or\n  // fewer PHI nodes in this block.\n  unsigned NumPhis = 0;\n  for (BasicBlock::iterator I = BB->begin(); isa<PHINode>(I); ++NumPhis, ++I)\n    if (NumPhis > 2)\n      return false;\n\n  // Loop over the PHI's seeing if we can promote them all to select\n  // instructions.  While we are at it, keep track of the instructions\n  // that need to be moved to the dominating block.\n  SmallPtrSet<Instruction *, 4> AggressiveInsts;\n  InstructionCost Cost = 0;\n  InstructionCost Budget =\n      TwoEntryPHINodeFoldingThreshold * TargetTransformInfo::TCC_Basic;\n\n  bool Changed = false;\n  for (BasicBlock::iterator II = BB->begin(); isa<PHINode>(II);) {\n    PHINode *PN = cast<PHINode>(II++);\n    if (Value *V = SimplifyInstruction(PN, {DL, PN})) {\n      PN->replaceAllUsesWith(V);\n      PN->eraseFromParent();\n      Changed = true;\n      continue;\n    }\n\n    if (!dominatesMergePoint(PN->getIncomingValue(0), BB, AggressiveInsts,\n                             Cost, Budget, TTI) ||\n        !dominatesMergePoint(PN->getIncomingValue(1), BB, AggressiveInsts,\n                             Cost, Budget, TTI))\n      return Changed;\n  }\n\n  // If we folded the first phi, PN dangles at this point.  Refresh it.  If\n  // we ran out of PHIs then we simplified them all.\n  PN = dyn_cast<PHINode>(BB->begin());\n  if (!PN)\n    return true;\n\n  // Return true if at least one of these is a 'not', and another is either\n  // a 'not' too, or a constant.\n  auto CanHoistNotFromBothValues = [](Value *V0, Value *V1) {\n    if (!match(V0, m_Not(m_Value())))\n      std::swap(V0, V1);\n    auto Invertible = m_CombineOr(m_Not(m_Value()), m_AnyIntegralConstant());\n    return match(V0, m_Not(m_Value())) && match(V1, Invertible);\n  };\n\n  // Don't fold i1 branches on PHIs which contain binary operators or\n  // select form of or/ands, unless one of the incoming values is an 'not' and\n  // another one is freely invertible.\n  // These can often be turned into switches and other things.\n  auto IsBinOpOrAnd = [](Value *V) {\n    return match(\n        V, m_CombineOr(m_BinOp(), m_CombineOr(m_LogicalAnd(), m_LogicalOr())));\n  };\n  if (PN->getType()->isIntegerTy(1) &&\n      (IsBinOpOrAnd(PN->getIncomingValue(0)) ||\n       IsBinOpOrAnd(PN->getIncomingValue(1)) || IsBinOpOrAnd(IfCond)) &&\n      !CanHoistNotFromBothValues(PN->getIncomingValue(0),\n                                 PN->getIncomingValue(1)))\n    return Changed;\n\n  // If all PHI nodes are promotable, check to make sure that all instructions\n  // in the predecessor blocks can be promoted as well. If not, we won't be able\n  // to get rid of the control flow, so it's not worth promoting to select\n  // instructions.\n  BasicBlock *DomBlock = nullptr;\n  BasicBlock *IfBlock1 = PN->getIncomingBlock(0);\n  BasicBlock *IfBlock2 = PN->getIncomingBlock(1);\n  if (cast<BranchInst>(IfBlock1->getTerminator())->isConditional()) {\n    IfBlock1 = nullptr;\n  } else {\n    DomBlock = *pred_begin(IfBlock1);\n    for (BasicBlock::iterator I = IfBlock1->begin(); !I->isTerminator(); ++I)\n      if (!AggressiveInsts.count(&*I) && !isa<DbgInfoIntrinsic>(I) &&\n          !isa<PseudoProbeInst>(I)) {\n        // This is not an aggressive instruction that we can promote.\n        // Because of this, we won't be able to get rid of the control flow, so\n        // the xform is not worth it.\n        return Changed;\n      }\n  }\n\n  if (cast<BranchInst>(IfBlock2->getTerminator())->isConditional()) {\n    IfBlock2 = nullptr;\n  } else {\n    DomBlock = *pred_begin(IfBlock2);\n    for (BasicBlock::iterator I = IfBlock2->begin(); !I->isTerminator(); ++I)\n      if (!AggressiveInsts.count(&*I) && !isa<DbgInfoIntrinsic>(I) &&\n          !isa<PseudoProbeInst>(I)) {\n        // This is not an aggressive instruction that we can promote.\n        // Because of this, we won't be able to get rid of the control flow, so\n        // the xform is not worth it.\n        return Changed;\n      }\n  }\n  assert(DomBlock && \"Failed to find root DomBlock\");\n\n  LLVM_DEBUG(dbgs() << \"FOUND IF CONDITION!  \" << *IfCond\n                    << \"  T: \" << IfTrue->getName()\n                    << \"  F: \" << IfFalse->getName() << \"\\n\");\n\n  // If we can still promote the PHI nodes after this gauntlet of tests,\n  // do all of the PHI's now.\n  Instruction *InsertPt = DomBlock->getTerminator();\n  IRBuilder<NoFolder> Builder(InsertPt);\n\n  // Move all 'aggressive' instructions, which are defined in the\n  // conditional parts of the if's up to the dominating block.\n  if (IfBlock1)\n    hoistAllInstructionsInto(DomBlock, InsertPt, IfBlock1);\n  if (IfBlock2)\n    hoistAllInstructionsInto(DomBlock, InsertPt, IfBlock2);\n\n  // Propagate fast-math-flags from phi nodes to replacement selects.\n  IRBuilder<>::FastMathFlagGuard FMFGuard(Builder);\n  while (PHINode *PN = dyn_cast<PHINode>(BB->begin())) {\n    if (isa<FPMathOperator>(PN))\n      Builder.setFastMathFlags(PN->getFastMathFlags());\n\n    // Change the PHI node into a select instruction.\n    Value *TrueVal = PN->getIncomingValue(PN->getIncomingBlock(0) == IfFalse);\n    Value *FalseVal = PN->getIncomingValue(PN->getIncomingBlock(0) == IfTrue);\n\n    Value *Sel = Builder.CreateSelect(IfCond, TrueVal, FalseVal, \"\", InsertPt);\n    PN->replaceAllUsesWith(Sel);\n    Sel->takeName(PN);\n    PN->eraseFromParent();\n  }\n\n  // At this point, IfBlock1 and IfBlock2 are both empty, so our if statement\n  // has been flattened.  Change DomBlock to jump directly to our new block to\n  // avoid other simplifycfg's kicking in on the diamond.\n  Instruction *OldTI = DomBlock->getTerminator();\n  Builder.SetInsertPoint(OldTI);\n  Builder.CreateBr(BB);\n\n  SmallVector<DominatorTree::UpdateType, 3> Updates;\n  if (DTU) {\n    Updates.push_back({DominatorTree::Insert, DomBlock, BB});\n    for (auto *Successor : successors(DomBlock))\n      Updates.push_back({DominatorTree::Delete, DomBlock, Successor});\n  }\n\n  OldTI->eraseFromParent();\n  if (DTU)\n    DTU->applyUpdates(Updates);\n\n  return true;\n}\n\n/// If we found a conditional branch that goes to two returning blocks,\n/// try to merge them together into one return,\n/// introducing a select if the return values disagree.\nbool SimplifyCFGOpt::SimplifyCondBranchToTwoReturns(BranchInst *BI,\n                                                    IRBuilder<> &Builder) {\n  auto *BB = BI->getParent();\n  assert(BI->isConditional() && \"Must be a conditional branch\");\n  BasicBlock *TrueSucc = BI->getSuccessor(0);\n  BasicBlock *FalseSucc = BI->getSuccessor(1);\n  // NOTE: destinations may match, this could be degenerate uncond branch.\n  ReturnInst *TrueRet = cast<ReturnInst>(TrueSucc->getTerminator());\n  ReturnInst *FalseRet = cast<ReturnInst>(FalseSucc->getTerminator());\n\n  // Check to ensure both blocks are empty (just a return) or optionally empty\n  // with PHI nodes.  If there are other instructions, merging would cause extra\n  // computation on one path or the other.\n  if (!TrueSucc->getFirstNonPHIOrDbg()->isTerminator())\n    return false;\n  if (!FalseSucc->getFirstNonPHIOrDbg()->isTerminator())\n    return false;\n\n  Builder.SetInsertPoint(BI);\n  // Okay, we found a branch that is going to two return nodes.  If\n  // there is no return value for this function, just change the\n  // branch into a return.\n  if (FalseRet->getNumOperands() == 0) {\n    TrueSucc->removePredecessor(BB);\n    FalseSucc->removePredecessor(BB);\n    Builder.CreateRetVoid();\n    EraseTerminatorAndDCECond(BI);\n    if (DTU) {\n      SmallVector<DominatorTree::UpdateType, 2> Updates;\n      Updates.push_back({DominatorTree::Delete, BB, TrueSucc});\n      if (TrueSucc != FalseSucc)\n        Updates.push_back({DominatorTree::Delete, BB, FalseSucc});\n      DTU->applyUpdates(Updates);\n    }\n    return true;\n  }\n\n  // Otherwise, figure out what the true and false return values are\n  // so we can insert a new select instruction.\n  Value *TrueValue = TrueRet->getReturnValue();\n  Value *FalseValue = FalseRet->getReturnValue();\n\n  // Unwrap any PHI nodes in the return blocks.\n  if (PHINode *TVPN = dyn_cast_or_null<PHINode>(TrueValue))\n    if (TVPN->getParent() == TrueSucc)\n      TrueValue = TVPN->getIncomingValueForBlock(BB);\n  if (PHINode *FVPN = dyn_cast_or_null<PHINode>(FalseValue))\n    if (FVPN->getParent() == FalseSucc)\n      FalseValue = FVPN->getIncomingValueForBlock(BB);\n\n  // In order for this transformation to be safe, we must be able to\n  // unconditionally execute both operands to the return.  This is\n  // normally the case, but we could have a potentially-trapping\n  // constant expression that prevents this transformation from being\n  // safe.\n  if (ConstantExpr *TCV = dyn_cast_or_null<ConstantExpr>(TrueValue))\n    if (TCV->canTrap())\n      return false;\n  if (ConstantExpr *FCV = dyn_cast_or_null<ConstantExpr>(FalseValue))\n    if (FCV->canTrap())\n      return false;\n\n  // Okay, we collected all the mapped values and checked them for sanity, and\n  // defined to really do this transformation.  First, update the CFG.\n  TrueSucc->removePredecessor(BB);\n  FalseSucc->removePredecessor(BB);\n\n  // Insert select instructions where needed.\n  Value *BrCond = BI->getCondition();\n  if (TrueValue) {\n    // Insert a select if the results differ.\n    if (TrueValue == FalseValue || isa<UndefValue>(FalseValue)) {\n    } else if (isa<UndefValue>(TrueValue)) {\n      TrueValue = FalseValue;\n    } else {\n      TrueValue =\n          Builder.CreateSelect(BrCond, TrueValue, FalseValue, \"retval\", BI);\n    }\n  }\n\n  Value *RI =\n      !TrueValue ? Builder.CreateRetVoid() : Builder.CreateRet(TrueValue);\n\n  (void)RI;\n\n  LLVM_DEBUG(dbgs() << \"\\nCHANGING BRANCH TO TWO RETURNS INTO SELECT:\"\n                    << \"\\n  \" << *BI << \"\\nNewRet = \" << *RI << \"\\nTRUEBLOCK: \"\n                    << *TrueSucc << \"\\nFALSEBLOCK: \" << *FalseSucc);\n\n  EraseTerminatorAndDCECond(BI);\n  if (DTU) {\n    SmallVector<DominatorTree::UpdateType, 2> Updates;\n    Updates.push_back({DominatorTree::Delete, BB, TrueSucc});\n    if (TrueSucc != FalseSucc)\n      Updates.push_back({DominatorTree::Delete, BB, FalseSucc});\n    DTU->applyUpdates(Updates);\n  }\n\n  return true;\n}\n\n/// Return true if either PBI or BI has branch weight available, and store\n/// the weights in {Pred|Succ}{True|False}Weight. If one of PBI and BI does\n/// not have branch weight, use 1:1 as its weight.\nstatic bool extractPredSuccWeights(BranchInst *PBI, BranchInst *BI,\n                                   uint64_t &PredTrueWeight,\n                                   uint64_t &PredFalseWeight,\n                                   uint64_t &SuccTrueWeight,\n                                   uint64_t &SuccFalseWeight) {\n  bool PredHasWeights =\n      PBI->extractProfMetadata(PredTrueWeight, PredFalseWeight);\n  bool SuccHasWeights =\n      BI->extractProfMetadata(SuccTrueWeight, SuccFalseWeight);\n  if (PredHasWeights || SuccHasWeights) {\n    if (!PredHasWeights)\n      PredTrueWeight = PredFalseWeight = 1;\n    if (!SuccHasWeights)\n      SuccTrueWeight = SuccFalseWeight = 1;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Determine if the two branches share a common destination,\n// and deduce a glue that we need to use to join branch's conditions\n// to arrive at the common destination.\nstatic Optional<std::pair<Instruction::BinaryOps, bool>>\nCheckIfCondBranchesShareCommonDestination(BranchInst *BI, BranchInst *PBI) {\n  assert(BI && PBI && BI->isConditional() && PBI->isConditional() &&\n         \"Both blocks must end with a conditional branches.\");\n  assert(is_contained(predecessors(BI->getParent()), PBI->getParent()) &&\n         \"PredBB must be a predecessor of BB.\");\n\n  if (PBI->getSuccessor(0) == BI->getSuccessor(0))\n    return {{Instruction::Or, false}};\n  else if (PBI->getSuccessor(1) == BI->getSuccessor(1))\n    return {{Instruction::And, false}};\n  else if (PBI->getSuccessor(0) == BI->getSuccessor(1))\n    return {{Instruction::And, true}};\n  else if (PBI->getSuccessor(1) == BI->getSuccessor(0))\n    return {{Instruction::Or, true}};\n  return None;\n}\n\nstatic bool PerformBranchToCommonDestFolding(BranchInst *BI, BranchInst *PBI,\n                                             DomTreeUpdater *DTU,\n                                             MemorySSAUpdater *MSSAU) {\n  BasicBlock *BB = BI->getParent();\n  BasicBlock *PredBlock = PBI->getParent();\n\n  // Determine if the two branches share a common destination.\n  Instruction::BinaryOps Opc;\n  bool InvertPredCond;\n  std::tie(Opc, InvertPredCond) =\n      *CheckIfCondBranchesShareCommonDestination(BI, PBI);\n\n  LLVM_DEBUG(dbgs() << \"FOLDING BRANCH TO COMMON DEST:\\n\" << *PBI << *BB);\n\n  IRBuilder<> Builder(PBI);\n  // The builder is used to create instructions to eliminate the branch in BB.\n  // If BB's terminator has !annotation metadata, add it to the new\n  // instructions.\n  Builder.CollectMetadataToCopy(BB->getTerminator(),\n                                {LLVMContext::MD_annotation});\n\n  // If we need to invert the condition in the pred block to match, do so now.\n  if (InvertPredCond) {\n    Value *NewCond = PBI->getCondition();\n    if (NewCond->hasOneUse() && isa<CmpInst>(NewCond)) {\n      CmpInst *CI = cast<CmpInst>(NewCond);\n      CI->setPredicate(CI->getInversePredicate());\n    } else {\n      NewCond =\n          Builder.CreateNot(NewCond, PBI->getCondition()->getName() + \".not\");\n    }\n\n    PBI->setCondition(NewCond);\n    PBI->swapSuccessors();\n  }\n\n  BasicBlock *UniqueSucc =\n      PBI->getSuccessor(0) == BB ? BI->getSuccessor(0) : BI->getSuccessor(1);\n\n  // Before cloning instructions, notify the successor basic block that it\n  // is about to have a new predecessor. This will update PHI nodes,\n  // which will allow us to update live-out uses of bonus instructions.\n  AddPredecessorToBlock(UniqueSucc, PredBlock, BB, MSSAU);\n\n  // Try to update branch weights.\n  uint64_t PredTrueWeight, PredFalseWeight, SuccTrueWeight, SuccFalseWeight;\n  if (extractPredSuccWeights(PBI, BI, PredTrueWeight, PredFalseWeight,\n                             SuccTrueWeight, SuccFalseWeight)) {\n    SmallVector<uint64_t, 8> NewWeights;\n\n    if (PBI->getSuccessor(0) == BB) {\n      // PBI: br i1 %x, BB, FalseDest\n      // BI:  br i1 %y, UniqueSucc, FalseDest\n      // TrueWeight is TrueWeight for PBI * TrueWeight for BI.\n      NewWeights.push_back(PredTrueWeight * SuccTrueWeight);\n      // FalseWeight is FalseWeight for PBI * TotalWeight for BI +\n      //               TrueWeight for PBI * FalseWeight for BI.\n      // We assume that total weights of a BranchInst can fit into 32 bits.\n      // Therefore, we will not have overflow using 64-bit arithmetic.\n      NewWeights.push_back(PredFalseWeight *\n                               (SuccFalseWeight + SuccTrueWeight) +\n                           PredTrueWeight * SuccFalseWeight);\n    } else {\n      // PBI: br i1 %x, TrueDest, BB\n      // BI:  br i1 %y, TrueDest, UniqueSucc\n      // TrueWeight is TrueWeight for PBI * TotalWeight for BI +\n      //              FalseWeight for PBI * TrueWeight for BI.\n      NewWeights.push_back(PredTrueWeight * (SuccFalseWeight + SuccTrueWeight) +\n                           PredFalseWeight * SuccTrueWeight);\n      // FalseWeight is FalseWeight for PBI * FalseWeight for BI.\n      NewWeights.push_back(PredFalseWeight * SuccFalseWeight);\n    }\n\n    // Halve the weights if any of them cannot fit in an uint32_t\n    FitWeights(NewWeights);\n\n    SmallVector<uint32_t, 8> MDWeights(NewWeights.begin(), NewWeights.end());\n    setBranchWeights(PBI, MDWeights[0], MDWeights[1]);\n\n    // TODO: If BB is reachable from all paths through PredBlock, then we\n    // could replace PBI's branch probabilities with BI's.\n  } else\n    PBI->setMetadata(LLVMContext::MD_prof, nullptr);\n\n  // Now, update the CFG.\n  PBI->setSuccessor(PBI->getSuccessor(0) != BB, UniqueSucc);\n\n  if (DTU)\n    DTU->applyUpdates({{DominatorTree::Insert, PredBlock, UniqueSucc},\n                       {DominatorTree::Delete, PredBlock, BB}});\n\n  // If BI was a loop latch, it may have had associated loop metadata.\n  // We need to copy it to the new latch, that is, PBI.\n  if (MDNode *LoopMD = BI->getMetadata(LLVMContext::MD_loop))\n    PBI->setMetadata(LLVMContext::MD_loop, LoopMD);\n\n  ValueToValueMapTy VMap; // maps original values to cloned values\n  CloneInstructionsIntoPredecessorBlockAndUpdateSSAUses(BB, PredBlock, VMap);\n\n  // Now that the Cond was cloned into the predecessor basic block,\n  // or/and the two conditions together.\n  Instruction *NewCond = cast<Instruction>(Builder.CreateBinOp(\n      Opc, PBI->getCondition(), VMap[BI->getCondition()], \"or.cond\"));\n  PBI->setCondition(NewCond);\n\n  // Copy any debug value intrinsics into the end of PredBlock.\n  for (Instruction &I : *BB) {\n    if (isa<DbgInfoIntrinsic>(I)) {\n      Instruction *NewI = I.clone();\n      RemapInstruction(NewI, VMap,\n                       RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);\n      NewI->insertBefore(PBI);\n    }\n  }\n\n  ++NumFoldBranchToCommonDest;\n  return true;\n}\n\n/// If this basic block is simple enough, and if a predecessor branches to us\n/// and one of our successors, fold the block into the predecessor and use\n/// logical operations to pick the right destination.\nbool llvm::FoldBranchToCommonDest(BranchInst *BI, DomTreeUpdater *DTU,\n                                  MemorySSAUpdater *MSSAU,\n                                  const TargetTransformInfo *TTI,\n                                  unsigned BonusInstThreshold) {\n  // If this block ends with an unconditional branch,\n  // let SpeculativelyExecuteBB() deal with it.\n  if (!BI->isConditional())\n    return false;\n\n  BasicBlock *BB = BI->getParent();\n\n  const unsigned PredCount = pred_size(BB);\n\n  bool Changed = false;\n\n  TargetTransformInfo::TargetCostKind CostKind =\n    BB->getParent()->hasMinSize() ? TargetTransformInfo::TCK_CodeSize\n                                  : TargetTransformInfo::TCK_SizeAndLatency;\n\n  Instruction *Cond = dyn_cast<Instruction>(BI->getCondition());\n\n  if (!Cond || (!isa<CmpInst>(Cond) && !isa<BinaryOperator>(Cond)) ||\n      Cond->getParent() != BB || !Cond->hasOneUse())\n    return Changed;\n\n  // Only allow this transformation if computing the condition doesn't involve\n  // too many instructions and these involved instructions can be executed\n  // unconditionally. We denote all involved instructions except the condition\n  // as \"bonus instructions\", and only allow this transformation when the\n  // number of the bonus instructions we'll need to create when cloning into\n  // each predecessor does not exceed a certain threshold.\n  unsigned NumBonusInsts = 0;\n  for (Instruction &I : *BB) {\n    // Don't check the branch condition comparison itself.\n    if (&I == Cond)\n      continue;\n    // Ignore dbg intrinsics, and the terminator.\n    if (isa<DbgInfoIntrinsic>(I) || isa<BranchInst>(I))\n      continue;\n    // I must be safe to execute unconditionally.\n    if (!isSafeToSpeculativelyExecute(&I))\n      return Changed;\n\n    // Account for the cost of duplicating this instruction into each\n    // predecessor.\n    NumBonusInsts += PredCount;\n    // Early exits once we reach the limit.\n    if (NumBonusInsts > BonusInstThreshold)\n      return Changed;\n  }\n\n  // Cond is known to be a compare or binary operator.  Check to make sure that\n  // neither operand is a potentially-trapping constant expression.\n  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(Cond->getOperand(0)))\n    if (CE->canTrap())\n      return Changed;\n  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(Cond->getOperand(1)))\n    if (CE->canTrap())\n      return Changed;\n\n  // Finally, don't infinitely unroll conditional loops.\n  if (is_contained(successors(BB), BB))\n    return Changed;\n\n  for (BasicBlock *PredBlock : predecessors(BB)) {\n    BranchInst *PBI = dyn_cast<BranchInst>(PredBlock->getTerminator());\n\n    // Check that we have two conditional branches.  If there is a PHI node in\n    // the common successor, verify that the same value flows in from both\n    // blocks.\n    if (!PBI || PBI->isUnconditional() || !SafeToMergeTerminators(BI, PBI))\n      continue;\n\n    // Determine if the two branches share a common destination.\n    Instruction::BinaryOps Opc;\n    bool InvertPredCond;\n    if (auto Recepie = CheckIfCondBranchesShareCommonDestination(BI, PBI))\n      std::tie(Opc, InvertPredCond) = *Recepie;\n    else\n      continue;\n\n    // Check the cost of inserting the necessary logic before performing the\n    // transformation.\n    if (TTI) {\n      Type *Ty = BI->getCondition()->getType();\n      InstructionCost Cost = TTI->getArithmeticInstrCost(Opc, Ty, CostKind);\n      if (InvertPredCond && (!PBI->getCondition()->hasOneUse() ||\n          !isa<CmpInst>(PBI->getCondition())))\n        Cost += TTI->getArithmeticInstrCost(Instruction::Xor, Ty, CostKind);\n\n      if (Cost > BranchFoldThreshold)\n        continue;\n    }\n\n    return PerformBranchToCommonDestFolding(BI, PBI, DTU, MSSAU);\n  }\n  return Changed;\n}\n\n// If there is only one store in BB1 and BB2, return it, otherwise return\n// nullptr.\nstatic StoreInst *findUniqueStoreInBlocks(BasicBlock *BB1, BasicBlock *BB2) {\n  StoreInst *S = nullptr;\n  for (auto *BB : {BB1, BB2}) {\n    if (!BB)\n      continue;\n    for (auto &I : *BB)\n      if (auto *SI = dyn_cast<StoreInst>(&I)) {\n        if (S)\n          // Multiple stores seen.\n          return nullptr;\n        else\n          S = SI;\n      }\n  }\n  return S;\n}\n\nstatic Value *ensureValueAvailableInSuccessor(Value *V, BasicBlock *BB,\n                                              Value *AlternativeV = nullptr) {\n  // PHI is going to be a PHI node that allows the value V that is defined in\n  // BB to be referenced in BB's only successor.\n  //\n  // If AlternativeV is nullptr, the only value we care about in PHI is V. It\n  // doesn't matter to us what the other operand is (it'll never get used). We\n  // could just create a new PHI with an undef incoming value, but that could\n  // increase register pressure if EarlyCSE/InstCombine can't fold it with some\n  // other PHI. So here we directly look for some PHI in BB's successor with V\n  // as an incoming operand. If we find one, we use it, else we create a new\n  // one.\n  //\n  // If AlternativeV is not nullptr, we care about both incoming values in PHI.\n  // PHI must be exactly: phi <ty> [ %BB, %V ], [ %OtherBB, %AlternativeV]\n  // where OtherBB is the single other predecessor of BB's only successor.\n  PHINode *PHI = nullptr;\n  BasicBlock *Succ = BB->getSingleSuccessor();\n\n  for (auto I = Succ->begin(); isa<PHINode>(I); ++I)\n    if (cast<PHINode>(I)->getIncomingValueForBlock(BB) == V) {\n      PHI = cast<PHINode>(I);\n      if (!AlternativeV)\n        break;\n\n      assert(Succ->hasNPredecessors(2));\n      auto PredI = pred_begin(Succ);\n      BasicBlock *OtherPredBB = *PredI == BB ? *++PredI : *PredI;\n      if (PHI->getIncomingValueForBlock(OtherPredBB) == AlternativeV)\n        break;\n      PHI = nullptr;\n    }\n  if (PHI)\n    return PHI;\n\n  // If V is not an instruction defined in BB, just return it.\n  if (!AlternativeV &&\n      (!isa<Instruction>(V) || cast<Instruction>(V)->getParent() != BB))\n    return V;\n\n  PHI = PHINode::Create(V->getType(), 2, \"simplifycfg.merge\", &Succ->front());\n  PHI->addIncoming(V, BB);\n  for (BasicBlock *PredBB : predecessors(Succ))\n    if (PredBB != BB)\n      PHI->addIncoming(\n          AlternativeV ? AlternativeV : UndefValue::get(V->getType()), PredBB);\n  return PHI;\n}\n\nstatic bool mergeConditionalStoreToAddress(\n    BasicBlock *PTB, BasicBlock *PFB, BasicBlock *QTB, BasicBlock *QFB,\n    BasicBlock *PostBB, Value *Address, bool InvertPCond, bool InvertQCond,\n    DomTreeUpdater *DTU, const DataLayout &DL, const TargetTransformInfo &TTI) {\n  // For every pointer, there must be exactly two stores, one coming from\n  // PTB or PFB, and the other from QTB or QFB. We don't support more than one\n  // store (to any address) in PTB,PFB or QTB,QFB.\n  // FIXME: We could relax this restriction with a bit more work and performance\n  // testing.\n  StoreInst *PStore = findUniqueStoreInBlocks(PTB, PFB);\n  StoreInst *QStore = findUniqueStoreInBlocks(QTB, QFB);\n  if (!PStore || !QStore)\n    return false;\n\n  // Now check the stores are compatible.\n  if (!QStore->isUnordered() || !PStore->isUnordered())\n    return false;\n\n  // Check that sinking the store won't cause program behavior changes. Sinking\n  // the store out of the Q blocks won't change any behavior as we're sinking\n  // from a block to its unconditional successor. But we're moving a store from\n  // the P blocks down through the middle block (QBI) and past both QFB and QTB.\n  // So we need to check that there are no aliasing loads or stores in\n  // QBI, QTB and QFB. We also need to check there are no conflicting memory\n  // operations between PStore and the end of its parent block.\n  //\n  // The ideal way to do this is to query AliasAnalysis, but we don't\n  // preserve AA currently so that is dangerous. Be super safe and just\n  // check there are no other memory operations at all.\n  for (auto &I : *QFB->getSinglePredecessor())\n    if (I.mayReadOrWriteMemory())\n      return false;\n  for (auto &I : *QFB)\n    if (&I != QStore && I.mayReadOrWriteMemory())\n      return false;\n  if (QTB)\n    for (auto &I : *QTB)\n      if (&I != QStore && I.mayReadOrWriteMemory())\n        return false;\n  for (auto I = BasicBlock::iterator(PStore), E = PStore->getParent()->end();\n       I != E; ++I)\n    if (&*I != PStore && I->mayReadOrWriteMemory())\n      return false;\n\n  // If we're not in aggressive mode, we only optimize if we have some\n  // confidence that by optimizing we'll allow P and/or Q to be if-converted.\n  auto IsWorthwhile = [&](BasicBlock *BB, ArrayRef<StoreInst *> FreeStores) {\n    if (!BB)\n      return true;\n    // Heuristic: if the block can be if-converted/phi-folded and the\n    // instructions inside are all cheap (arithmetic/GEPs), it's worthwhile to\n    // thread this store.\n    InstructionCost Cost = 0;\n    InstructionCost Budget =\n        PHINodeFoldingThreshold * TargetTransformInfo::TCC_Basic;\n    for (auto &I : BB->instructionsWithoutDebug()) {\n      // Consider terminator instruction to be free.\n      if (I.isTerminator())\n        continue;\n      // If this is one the stores that we want to speculate out of this BB,\n      // then don't count it's cost, consider it to be free.\n      if (auto *S = dyn_cast<StoreInst>(&I))\n        if (llvm::find(FreeStores, S))\n          continue;\n      // Else, we have a white-list of instructions that we are ak speculating.\n      if (!isa<BinaryOperator>(I) && !isa<GetElementPtrInst>(I))\n        return false; // Not in white-list - not worthwhile folding.\n      // And finally, if this is a non-free instruction that we are okay\n      // speculating, ensure that we consider the speculation budget.\n      Cost += TTI.getUserCost(&I, TargetTransformInfo::TCK_SizeAndLatency);\n      if (Cost > Budget)\n        return false; // Eagerly refuse to fold as soon as we're out of budget.\n    }\n    assert(Cost <= Budget &&\n           \"When we run out of budget we will eagerly return from within the \"\n           \"per-instruction loop.\");\n    return true;\n  };\n\n  const std::array<StoreInst *, 2> FreeStores = {PStore, QStore};\n  if (!MergeCondStoresAggressively &&\n      (!IsWorthwhile(PTB, FreeStores) || !IsWorthwhile(PFB, FreeStores) ||\n       !IsWorthwhile(QTB, FreeStores) || !IsWorthwhile(QFB, FreeStores)))\n    return false;\n\n  // If PostBB has more than two predecessors, we need to split it so we can\n  // sink the store.\n  if (std::next(pred_begin(PostBB), 2) != pred_end(PostBB)) {\n    // We know that QFB's only successor is PostBB. And QFB has a single\n    // predecessor. If QTB exists, then its only successor is also PostBB.\n    // If QTB does not exist, then QFB's only predecessor has a conditional\n    // branch to QFB and PostBB.\n    BasicBlock *TruePred = QTB ? QTB : QFB->getSinglePredecessor();\n    BasicBlock *NewBB =\n        SplitBlockPredecessors(PostBB, {QFB, TruePred}, \"condstore.split\", DTU);\n    if (!NewBB)\n      return false;\n    PostBB = NewBB;\n  }\n\n  // OK, we're going to sink the stores to PostBB. The store has to be\n  // conditional though, so first create the predicate.\n  Value *PCond = cast<BranchInst>(PFB->getSinglePredecessor()->getTerminator())\n                     ->getCondition();\n  Value *QCond = cast<BranchInst>(QFB->getSinglePredecessor()->getTerminator())\n                     ->getCondition();\n\n  Value *PPHI = ensureValueAvailableInSuccessor(PStore->getValueOperand(),\n                                                PStore->getParent());\n  Value *QPHI = ensureValueAvailableInSuccessor(QStore->getValueOperand(),\n                                                QStore->getParent(), PPHI);\n\n  IRBuilder<> QB(&*PostBB->getFirstInsertionPt());\n\n  Value *PPred = PStore->getParent() == PTB ? PCond : QB.CreateNot(PCond);\n  Value *QPred = QStore->getParent() == QTB ? QCond : QB.CreateNot(QCond);\n\n  if (InvertPCond)\n    PPred = QB.CreateNot(PPred);\n  if (InvertQCond)\n    QPred = QB.CreateNot(QPred);\n  Value *CombinedPred = QB.CreateOr(PPred, QPred);\n\n  auto *T = SplitBlockAndInsertIfThen(CombinedPred, &*QB.GetInsertPoint(),\n                                      /*Unreachable=*/false,\n                                      /*BranchWeights=*/nullptr, DTU);\n  QB.SetInsertPoint(T);\n  StoreInst *SI = cast<StoreInst>(QB.CreateStore(QPHI, Address));\n  AAMDNodes AAMD;\n  PStore->getAAMetadata(AAMD, /*Merge=*/false);\n  PStore->getAAMetadata(AAMD, /*Merge=*/true);\n  SI->setAAMetadata(AAMD);\n  // Choose the minimum alignment. If we could prove both stores execute, we\n  // could use biggest one.  In this case, though, we only know that one of the\n  // stores executes.  And we don't know it's safe to take the alignment from a\n  // store that doesn't execute.\n  SI->setAlignment(std::min(PStore->getAlign(), QStore->getAlign()));\n\n  QStore->eraseFromParent();\n  PStore->eraseFromParent();\n\n  return true;\n}\n\nstatic bool mergeConditionalStores(BranchInst *PBI, BranchInst *QBI,\n                                   DomTreeUpdater *DTU, const DataLayout &DL,\n                                   const TargetTransformInfo &TTI) {\n  // The intention here is to find diamonds or triangles (see below) where each\n  // conditional block contains a store to the same address. Both of these\n  // stores are conditional, so they can't be unconditionally sunk. But it may\n  // be profitable to speculatively sink the stores into one merged store at the\n  // end, and predicate the merged store on the union of the two conditions of\n  // PBI and QBI.\n  //\n  // This can reduce the number of stores executed if both of the conditions are\n  // true, and can allow the blocks to become small enough to be if-converted.\n  // This optimization will also chain, so that ladders of test-and-set\n  // sequences can be if-converted away.\n  //\n  // We only deal with simple diamonds or triangles:\n  //\n  //     PBI       or      PBI        or a combination of the two\n  //    /   \\               | \\\n  //   PTB  PFB             |  PFB\n  //    \\   /               | /\n  //     QBI                QBI\n  //    /  \\                | \\\n  //   QTB  QFB             |  QFB\n  //    \\  /                | /\n  //    PostBB            PostBB\n  //\n  // We model triangles as a type of diamond with a nullptr \"true\" block.\n  // Triangles are canonicalized so that the fallthrough edge is represented by\n  // a true condition, as in the diagram above.\n  BasicBlock *PTB = PBI->getSuccessor(0);\n  BasicBlock *PFB = PBI->getSuccessor(1);\n  BasicBlock *QTB = QBI->getSuccessor(0);\n  BasicBlock *QFB = QBI->getSuccessor(1);\n  BasicBlock *PostBB = QFB->getSingleSuccessor();\n\n  // Make sure we have a good guess for PostBB. If QTB's only successor is\n  // QFB, then QFB is a better PostBB.\n  if (QTB->getSingleSuccessor() == QFB)\n    PostBB = QFB;\n\n  // If we couldn't find a good PostBB, stop.\n  if (!PostBB)\n    return false;\n\n  bool InvertPCond = false, InvertQCond = false;\n  // Canonicalize fallthroughs to the true branches.\n  if (PFB == QBI->getParent()) {\n    std::swap(PFB, PTB);\n    InvertPCond = true;\n  }\n  if (QFB == PostBB) {\n    std::swap(QFB, QTB);\n    InvertQCond = true;\n  }\n\n  // From this point on we can assume PTB or QTB may be fallthroughs but PFB\n  // and QFB may not. Model fallthroughs as a nullptr block.\n  if (PTB == QBI->getParent())\n    PTB = nullptr;\n  if (QTB == PostBB)\n    QTB = nullptr;\n\n  // Legality bailouts. We must have at least the non-fallthrough blocks and\n  // the post-dominating block, and the non-fallthroughs must only have one\n  // predecessor.\n  auto HasOnePredAndOneSucc = [](BasicBlock *BB, BasicBlock *P, BasicBlock *S) {\n    return BB->getSinglePredecessor() == P && BB->getSingleSuccessor() == S;\n  };\n  if (!HasOnePredAndOneSucc(PFB, PBI->getParent(), QBI->getParent()) ||\n      !HasOnePredAndOneSucc(QFB, QBI->getParent(), PostBB))\n    return false;\n  if ((PTB && !HasOnePredAndOneSucc(PTB, PBI->getParent(), QBI->getParent())) ||\n      (QTB && !HasOnePredAndOneSucc(QTB, QBI->getParent(), PostBB)))\n    return false;\n  if (!QBI->getParent()->hasNUses(2))\n    return false;\n\n  // OK, this is a sequence of two diamonds or triangles.\n  // Check if there are stores in PTB or PFB that are repeated in QTB or QFB.\n  SmallPtrSet<Value *, 4> PStoreAddresses, QStoreAddresses;\n  for (auto *BB : {PTB, PFB}) {\n    if (!BB)\n      continue;\n    for (auto &I : *BB)\n      if (StoreInst *SI = dyn_cast<StoreInst>(&I))\n        PStoreAddresses.insert(SI->getPointerOperand());\n  }\n  for (auto *BB : {QTB, QFB}) {\n    if (!BB)\n      continue;\n    for (auto &I : *BB)\n      if (StoreInst *SI = dyn_cast<StoreInst>(&I))\n        QStoreAddresses.insert(SI->getPointerOperand());\n  }\n\n  set_intersect(PStoreAddresses, QStoreAddresses);\n  // set_intersect mutates PStoreAddresses in place. Rename it here to make it\n  // clear what it contains.\n  auto &CommonAddresses = PStoreAddresses;\n\n  bool Changed = false;\n  for (auto *Address : CommonAddresses)\n    Changed |=\n        mergeConditionalStoreToAddress(PTB, PFB, QTB, QFB, PostBB, Address,\n                                       InvertPCond, InvertQCond, DTU, DL, TTI);\n  return Changed;\n}\n\n/// If the previous block ended with a widenable branch, determine if reusing\n/// the target block is profitable and legal.  This will have the effect of\n/// \"widening\" PBI, but doesn't require us to reason about hosting safety.\nstatic bool tryWidenCondBranchToCondBranch(BranchInst *PBI, BranchInst *BI,\n                                           DomTreeUpdater *DTU) {\n  // TODO: This can be generalized in two important ways:\n  // 1) We can allow phi nodes in IfFalseBB and simply reuse all the input\n  //    values from the PBI edge.\n  // 2) We can sink side effecting instructions into BI's fallthrough\n  //    successor provided they doesn't contribute to computation of\n  //    BI's condition.\n  Value *CondWB, *WC;\n  BasicBlock *IfTrueBB, *IfFalseBB;\n  if (!parseWidenableBranch(PBI, CondWB, WC, IfTrueBB, IfFalseBB) ||\n      IfTrueBB != BI->getParent() || !BI->getParent()->getSinglePredecessor())\n    return false;\n  if (!IfFalseBB->phis().empty())\n    return false; // TODO\n  // Use lambda to lazily compute expensive condition after cheap ones.\n  auto NoSideEffects = [](BasicBlock &BB) {\n    return !llvm::any_of(BB, [](const Instruction &I) {\n        return I.mayWriteToMemory() || I.mayHaveSideEffects();\n      });\n  };\n  if (BI->getSuccessor(1) != IfFalseBB && // no inf looping\n      BI->getSuccessor(1)->getTerminatingDeoptimizeCall() && // profitability\n      NoSideEffects(*BI->getParent())) {\n    auto *OldSuccessor = BI->getSuccessor(1);\n    OldSuccessor->removePredecessor(BI->getParent());\n    BI->setSuccessor(1, IfFalseBB);\n    if (DTU)\n      DTU->applyUpdates(\n          {{DominatorTree::Insert, BI->getParent(), IfFalseBB},\n           {DominatorTree::Delete, BI->getParent(), OldSuccessor}});\n    return true;\n  }\n  if (BI->getSuccessor(0) != IfFalseBB && // no inf looping\n      BI->getSuccessor(0)->getTerminatingDeoptimizeCall() && // profitability\n      NoSideEffects(*BI->getParent())) {\n    auto *OldSuccessor = BI->getSuccessor(0);\n    OldSuccessor->removePredecessor(BI->getParent());\n    BI->setSuccessor(0, IfFalseBB);\n    if (DTU)\n      DTU->applyUpdates(\n          {{DominatorTree::Insert, BI->getParent(), IfFalseBB},\n           {DominatorTree::Delete, BI->getParent(), OldSuccessor}});\n    return true;\n  }\n  return false;\n}\n\n/// If we have a conditional branch as a predecessor of another block,\n/// this function tries to simplify it.  We know\n/// that PBI and BI are both conditional branches, and BI is in one of the\n/// successor blocks of PBI - PBI branches to BI.\nstatic bool SimplifyCondBranchToCondBranch(BranchInst *PBI, BranchInst *BI,\n                                           DomTreeUpdater *DTU,\n                                           const DataLayout &DL,\n                                           const TargetTransformInfo &TTI) {\n  assert(PBI->isConditional() && BI->isConditional());\n  BasicBlock *BB = BI->getParent();\n\n  // If this block ends with a branch instruction, and if there is a\n  // predecessor that ends on a branch of the same condition, make\n  // this conditional branch redundant.\n  if (PBI->getCondition() == BI->getCondition() &&\n      PBI->getSuccessor(0) != PBI->getSuccessor(1)) {\n    // Okay, the outcome of this conditional branch is statically\n    // knowable.  If this block had a single pred, handle specially.\n    if (BB->getSinglePredecessor()) {\n      // Turn this into a branch on constant.\n      bool CondIsTrue = PBI->getSuccessor(0) == BB;\n      BI->setCondition(\n          ConstantInt::get(Type::getInt1Ty(BB->getContext()), CondIsTrue));\n      return true; // Nuke the branch on constant.\n    }\n\n    // Otherwise, if there are multiple predecessors, insert a PHI that merges\n    // in the constant and simplify the block result.  Subsequent passes of\n    // simplifycfg will thread the block.\n    if (BlockIsSimpleEnoughToThreadThrough(BB)) {\n      pred_iterator PB = pred_begin(BB), PE = pred_end(BB);\n      PHINode *NewPN = PHINode::Create(\n          Type::getInt1Ty(BB->getContext()), std::distance(PB, PE),\n          BI->getCondition()->getName() + \".pr\", &BB->front());\n      // Okay, we're going to insert the PHI node.  Since PBI is not the only\n      // predecessor, compute the PHI'd conditional value for all of the preds.\n      // Any predecessor where the condition is not computable we keep symbolic.\n      for (pred_iterator PI = PB; PI != PE; ++PI) {\n        BasicBlock *P = *PI;\n        if ((PBI = dyn_cast<BranchInst>(P->getTerminator())) && PBI != BI &&\n            PBI->isConditional() && PBI->getCondition() == BI->getCondition() &&\n            PBI->getSuccessor(0) != PBI->getSuccessor(1)) {\n          bool CondIsTrue = PBI->getSuccessor(0) == BB;\n          NewPN->addIncoming(\n              ConstantInt::get(Type::getInt1Ty(BB->getContext()), CondIsTrue),\n              P);\n        } else {\n          NewPN->addIncoming(BI->getCondition(), P);\n        }\n      }\n\n      BI->setCondition(NewPN);\n      return true;\n    }\n  }\n\n  // If the previous block ended with a widenable branch, determine if reusing\n  // the target block is profitable and legal.  This will have the effect of\n  // \"widening\" PBI, but doesn't require us to reason about hosting safety.\n  if (tryWidenCondBranchToCondBranch(PBI, BI, DTU))\n    return true;\n\n  if (auto *CE = dyn_cast<ConstantExpr>(BI->getCondition()))\n    if (CE->canTrap())\n      return false;\n\n  // If both branches are conditional and both contain stores to the same\n  // address, remove the stores from the conditionals and create a conditional\n  // merged store at the end.\n  if (MergeCondStores && mergeConditionalStores(PBI, BI, DTU, DL, TTI))\n    return true;\n\n  // If this is a conditional branch in an empty block, and if any\n  // predecessors are a conditional branch to one of our destinations,\n  // fold the conditions into logical ops and one cond br.\n\n  // Ignore dbg intrinsics.\n  if (&*BB->instructionsWithoutDebug().begin() != BI)\n    return false;\n\n  int PBIOp, BIOp;\n  if (PBI->getSuccessor(0) == BI->getSuccessor(0)) {\n    PBIOp = 0;\n    BIOp = 0;\n  } else if (PBI->getSuccessor(0) == BI->getSuccessor(1)) {\n    PBIOp = 0;\n    BIOp = 1;\n  } else if (PBI->getSuccessor(1) == BI->getSuccessor(0)) {\n    PBIOp = 1;\n    BIOp = 0;\n  } else if (PBI->getSuccessor(1) == BI->getSuccessor(1)) {\n    PBIOp = 1;\n    BIOp = 1;\n  } else {\n    return false;\n  }\n\n  // Check to make sure that the other destination of this branch\n  // isn't BB itself.  If so, this is an infinite loop that will\n  // keep getting unwound.\n  if (PBI->getSuccessor(PBIOp) == BB)\n    return false;\n\n  // Do not perform this transformation if it would require\n  // insertion of a large number of select instructions. For targets\n  // without predication/cmovs, this is a big pessimization.\n\n  // Also do not perform this transformation if any phi node in the common\n  // destination block can trap when reached by BB or PBB (PR17073). In that\n  // case, it would be unsafe to hoist the operation into a select instruction.\n\n  BasicBlock *CommonDest = PBI->getSuccessor(PBIOp);\n  BasicBlock *RemovedDest = PBI->getSuccessor(PBIOp ^ 1);\n  unsigned NumPhis = 0;\n  for (BasicBlock::iterator II = CommonDest->begin(); isa<PHINode>(II);\n       ++II, ++NumPhis) {\n    if (NumPhis > 2) // Disable this xform.\n      return false;\n\n    PHINode *PN = cast<PHINode>(II);\n    Value *BIV = PN->getIncomingValueForBlock(BB);\n    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(BIV))\n      if (CE->canTrap())\n        return false;\n\n    unsigned PBBIdx = PN->getBasicBlockIndex(PBI->getParent());\n    Value *PBIV = PN->getIncomingValue(PBBIdx);\n    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(PBIV))\n      if (CE->canTrap())\n        return false;\n  }\n\n  // Finally, if everything is ok, fold the branches to logical ops.\n  BasicBlock *OtherDest = BI->getSuccessor(BIOp ^ 1);\n\n  LLVM_DEBUG(dbgs() << \"FOLDING BRs:\" << *PBI->getParent()\n                    << \"AND: \" << *BI->getParent());\n\n  SmallVector<DominatorTree::UpdateType, 5> Updates;\n\n  // If OtherDest *is* BB, then BB is a basic block with a single conditional\n  // branch in it, where one edge (OtherDest) goes back to itself but the other\n  // exits.  We don't *know* that the program avoids the infinite loop\n  // (even though that seems likely).  If we do this xform naively, we'll end up\n  // recursively unpeeling the loop.  Since we know that (after the xform is\n  // done) that the block *is* infinite if reached, we just make it an obviously\n  // infinite loop with no cond branch.\n  if (OtherDest == BB) {\n    // Insert it at the end of the function, because it's either code,\n    // or it won't matter if it's hot. :)\n    BasicBlock *InfLoopBlock =\n        BasicBlock::Create(BB->getContext(), \"infloop\", BB->getParent());\n    BranchInst::Create(InfLoopBlock, InfLoopBlock);\n    Updates.push_back({DominatorTree::Insert, InfLoopBlock, InfLoopBlock});\n    OtherDest = InfLoopBlock;\n  }\n\n  LLVM_DEBUG(dbgs() << *PBI->getParent()->getParent());\n\n  // BI may have other predecessors.  Because of this, we leave\n  // it alone, but modify PBI.\n\n  // Make sure we get to CommonDest on True&True directions.\n  Value *PBICond = PBI->getCondition();\n  IRBuilder<NoFolder> Builder(PBI);\n  if (PBIOp)\n    PBICond = Builder.CreateNot(PBICond, PBICond->getName() + \".not\");\n\n  Value *BICond = BI->getCondition();\n  if (BIOp)\n    BICond = Builder.CreateNot(BICond, BICond->getName() + \".not\");\n\n  // Merge the conditions.\n  Value *Cond = Builder.CreateOr(PBICond, BICond, \"brmerge\");\n\n  // Modify PBI to branch on the new condition to the new dests.\n  PBI->setCondition(Cond);\n  PBI->setSuccessor(0, CommonDest);\n  PBI->setSuccessor(1, OtherDest);\n\n  Updates.push_back({DominatorTree::Insert, PBI->getParent(), OtherDest});\n  Updates.push_back({DominatorTree::Delete, PBI->getParent(), RemovedDest});\n\n  if (DTU)\n    DTU->applyUpdates(Updates);\n\n  // Update branch weight for PBI.\n  uint64_t PredTrueWeight, PredFalseWeight, SuccTrueWeight, SuccFalseWeight;\n  uint64_t PredCommon, PredOther, SuccCommon, SuccOther;\n  bool HasWeights =\n      extractPredSuccWeights(PBI, BI, PredTrueWeight, PredFalseWeight,\n                             SuccTrueWeight, SuccFalseWeight);\n  if (HasWeights) {\n    PredCommon = PBIOp ? PredFalseWeight : PredTrueWeight;\n    PredOther = PBIOp ? PredTrueWeight : PredFalseWeight;\n    SuccCommon = BIOp ? SuccFalseWeight : SuccTrueWeight;\n    SuccOther = BIOp ? SuccTrueWeight : SuccFalseWeight;\n    // The weight to CommonDest should be PredCommon * SuccTotal +\n    //                                    PredOther * SuccCommon.\n    // The weight to OtherDest should be PredOther * SuccOther.\n    uint64_t NewWeights[2] = {PredCommon * (SuccCommon + SuccOther) +\n                                  PredOther * SuccCommon,\n                              PredOther * SuccOther};\n    // Halve the weights if any of them cannot fit in an uint32_t\n    FitWeights(NewWeights);\n\n    setBranchWeights(PBI, NewWeights[0], NewWeights[1]);\n  }\n\n  // OtherDest may have phi nodes.  If so, add an entry from PBI's\n  // block that are identical to the entries for BI's block.\n  AddPredecessorToBlock(OtherDest, PBI->getParent(), BB);\n\n  // We know that the CommonDest already had an edge from PBI to\n  // it.  If it has PHIs though, the PHIs may have different\n  // entries for BB and PBI's BB.  If so, insert a select to make\n  // them agree.\n  for (PHINode &PN : CommonDest->phis()) {\n    Value *BIV = PN.getIncomingValueForBlock(BB);\n    unsigned PBBIdx = PN.getBasicBlockIndex(PBI->getParent());\n    Value *PBIV = PN.getIncomingValue(PBBIdx);\n    if (BIV != PBIV) {\n      // Insert a select in PBI to pick the right value.\n      SelectInst *NV = cast<SelectInst>(\n          Builder.CreateSelect(PBICond, PBIV, BIV, PBIV->getName() + \".mux\"));\n      PN.setIncomingValue(PBBIdx, NV);\n      // Although the select has the same condition as PBI, the original branch\n      // weights for PBI do not apply to the new select because the select's\n      // 'logical' edges are incoming edges of the phi that is eliminated, not\n      // the outgoing edges of PBI.\n      if (HasWeights) {\n        uint64_t PredCommon = PBIOp ? PredFalseWeight : PredTrueWeight;\n        uint64_t PredOther = PBIOp ? PredTrueWeight : PredFalseWeight;\n        uint64_t SuccCommon = BIOp ? SuccFalseWeight : SuccTrueWeight;\n        uint64_t SuccOther = BIOp ? SuccTrueWeight : SuccFalseWeight;\n        // The weight to PredCommonDest should be PredCommon * SuccTotal.\n        // The weight to PredOtherDest should be PredOther * SuccCommon.\n        uint64_t NewWeights[2] = {PredCommon * (SuccCommon + SuccOther),\n                                  PredOther * SuccCommon};\n\n        FitWeights(NewWeights);\n\n        setBranchWeights(NV, NewWeights[0], NewWeights[1]);\n      }\n    }\n  }\n\n  LLVM_DEBUG(dbgs() << \"INTO: \" << *PBI->getParent());\n  LLVM_DEBUG(dbgs() << *PBI->getParent()->getParent());\n\n  // This basic block is probably dead.  We know it has at least\n  // one fewer predecessor.\n  return true;\n}\n\n// Simplifies a terminator by replacing it with a branch to TrueBB if Cond is\n// true or to FalseBB if Cond is false.\n// Takes care of updating the successors and removing the old terminator.\n// Also makes sure not to introduce new successors by assuming that edges to\n// non-successor TrueBBs and FalseBBs aren't reachable.\nbool SimplifyCFGOpt::SimplifyTerminatorOnSelect(Instruction *OldTerm,\n                                                Value *Cond, BasicBlock *TrueBB,\n                                                BasicBlock *FalseBB,\n                                                uint32_t TrueWeight,\n                                                uint32_t FalseWeight) {\n  auto *BB = OldTerm->getParent();\n  // Remove any superfluous successor edges from the CFG.\n  // First, figure out which successors to preserve.\n  // If TrueBB and FalseBB are equal, only try to preserve one copy of that\n  // successor.\n  BasicBlock *KeepEdge1 = TrueBB;\n  BasicBlock *KeepEdge2 = TrueBB != FalseBB ? FalseBB : nullptr;\n\n  SmallSetVector<BasicBlock *, 2> RemovedSuccessors;\n\n  // Then remove the rest.\n  for (BasicBlock *Succ : successors(OldTerm)) {\n    // Make sure only to keep exactly one copy of each edge.\n    if (Succ == KeepEdge1)\n      KeepEdge1 = nullptr;\n    else if (Succ == KeepEdge2)\n      KeepEdge2 = nullptr;\n    else {\n      Succ->removePredecessor(BB,\n                              /*KeepOneInputPHIs=*/true);\n\n      if (Succ != TrueBB && Succ != FalseBB)\n        RemovedSuccessors.insert(Succ);\n    }\n  }\n\n  IRBuilder<> Builder(OldTerm);\n  Builder.SetCurrentDebugLocation(OldTerm->getDebugLoc());\n\n  // Insert an appropriate new terminator.\n  if (!KeepEdge1 && !KeepEdge2) {\n    if (TrueBB == FalseBB) {\n      // We were only looking for one successor, and it was present.\n      // Create an unconditional branch to it.\n      Builder.CreateBr(TrueBB);\n    } else {\n      // We found both of the successors we were looking for.\n      // Create a conditional branch sharing the condition of the select.\n      BranchInst *NewBI = Builder.CreateCondBr(Cond, TrueBB, FalseBB);\n      if (TrueWeight != FalseWeight)\n        setBranchWeights(NewBI, TrueWeight, FalseWeight);\n    }\n  } else if (KeepEdge1 && (KeepEdge2 || TrueBB == FalseBB)) {\n    // Neither of the selected blocks were successors, so this\n    // terminator must be unreachable.\n    new UnreachableInst(OldTerm->getContext(), OldTerm);\n  } else {\n    // One of the selected values was a successor, but the other wasn't.\n    // Insert an unconditional branch to the one that was found;\n    // the edge to the one that wasn't must be unreachable.\n    if (!KeepEdge1) {\n      // Only TrueBB was found.\n      Builder.CreateBr(TrueBB);\n    } else {\n      // Only FalseBB was found.\n      Builder.CreateBr(FalseBB);\n    }\n  }\n\n  EraseTerminatorAndDCECond(OldTerm);\n\n  if (DTU) {\n    SmallVector<DominatorTree::UpdateType, 2> Updates;\n    Updates.reserve(RemovedSuccessors.size());\n    for (auto *RemovedSuccessor : RemovedSuccessors)\n      Updates.push_back({DominatorTree::Delete, BB, RemovedSuccessor});\n    DTU->applyUpdates(Updates);\n  }\n\n  return true;\n}\n\n// Replaces\n//   (switch (select cond, X, Y)) on constant X, Y\n// with a branch - conditional if X and Y lead to distinct BBs,\n// unconditional otherwise.\nbool SimplifyCFGOpt::SimplifySwitchOnSelect(SwitchInst *SI,\n                                            SelectInst *Select) {\n  // Check for constant integer values in the select.\n  ConstantInt *TrueVal = dyn_cast<ConstantInt>(Select->getTrueValue());\n  ConstantInt *FalseVal = dyn_cast<ConstantInt>(Select->getFalseValue());\n  if (!TrueVal || !FalseVal)\n    return false;\n\n  // Find the relevant condition and destinations.\n  Value *Condition = Select->getCondition();\n  BasicBlock *TrueBB = SI->findCaseValue(TrueVal)->getCaseSuccessor();\n  BasicBlock *FalseBB = SI->findCaseValue(FalseVal)->getCaseSuccessor();\n\n  // Get weight for TrueBB and FalseBB.\n  uint32_t TrueWeight = 0, FalseWeight = 0;\n  SmallVector<uint64_t, 8> Weights;\n  bool HasWeights = HasBranchWeights(SI);\n  if (HasWeights) {\n    GetBranchWeights(SI, Weights);\n    if (Weights.size() == 1 + SI->getNumCases()) {\n      TrueWeight =\n          (uint32_t)Weights[SI->findCaseValue(TrueVal)->getSuccessorIndex()];\n      FalseWeight =\n          (uint32_t)Weights[SI->findCaseValue(FalseVal)->getSuccessorIndex()];\n    }\n  }\n\n  // Perform the actual simplification.\n  return SimplifyTerminatorOnSelect(SI, Condition, TrueBB, FalseBB, TrueWeight,\n                                    FalseWeight);\n}\n\n// Replaces\n//   (indirectbr (select cond, blockaddress(@fn, BlockA),\n//                             blockaddress(@fn, BlockB)))\n// with\n//   (br cond, BlockA, BlockB).\nbool SimplifyCFGOpt::SimplifyIndirectBrOnSelect(IndirectBrInst *IBI,\n                                                SelectInst *SI) {\n  // Check that both operands of the select are block addresses.\n  BlockAddress *TBA = dyn_cast<BlockAddress>(SI->getTrueValue());\n  BlockAddress *FBA = dyn_cast<BlockAddress>(SI->getFalseValue());\n  if (!TBA || !FBA)\n    return false;\n\n  // Extract the actual blocks.\n  BasicBlock *TrueBB = TBA->getBasicBlock();\n  BasicBlock *FalseBB = FBA->getBasicBlock();\n\n  // Perform the actual simplification.\n  return SimplifyTerminatorOnSelect(IBI, SI->getCondition(), TrueBB, FalseBB, 0,\n                                    0);\n}\n\n/// This is called when we find an icmp instruction\n/// (a seteq/setne with a constant) as the only instruction in a\n/// block that ends with an uncond branch.  We are looking for a very specific\n/// pattern that occurs when \"A == 1 || A == 2 || A == 3\" gets simplified.  In\n/// this case, we merge the first two \"or's of icmp\" into a switch, but then the\n/// default value goes to an uncond block with a seteq in it, we get something\n/// like:\n///\n///   switch i8 %A, label %DEFAULT [ i8 1, label %end    i8 2, label %end ]\n/// DEFAULT:\n///   %tmp = icmp eq i8 %A, 92\n///   br label %end\n/// end:\n///   ... = phi i1 [ true, %entry ], [ %tmp, %DEFAULT ], [ true, %entry ]\n///\n/// We prefer to split the edge to 'end' so that there is a true/false entry to\n/// the PHI, merging the third icmp into the switch.\nbool SimplifyCFGOpt::tryToSimplifyUncondBranchWithICmpInIt(\n    ICmpInst *ICI, IRBuilder<> &Builder) {\n  BasicBlock *BB = ICI->getParent();\n\n  // If the block has any PHIs in it or the icmp has multiple uses, it is too\n  // complex.\n  if (isa<PHINode>(BB->begin()) || !ICI->hasOneUse())\n    return false;\n\n  Value *V = ICI->getOperand(0);\n  ConstantInt *Cst = cast<ConstantInt>(ICI->getOperand(1));\n\n  // The pattern we're looking for is where our only predecessor is a switch on\n  // 'V' and this block is the default case for the switch.  In this case we can\n  // fold the compared value into the switch to simplify things.\n  BasicBlock *Pred = BB->getSinglePredecessor();\n  if (!Pred || !isa<SwitchInst>(Pred->getTerminator()))\n    return false;\n\n  SwitchInst *SI = cast<SwitchInst>(Pred->getTerminator());\n  if (SI->getCondition() != V)\n    return false;\n\n  // If BB is reachable on a non-default case, then we simply know the value of\n  // V in this block.  Substitute it and constant fold the icmp instruction\n  // away.\n  if (SI->getDefaultDest() != BB) {\n    ConstantInt *VVal = SI->findCaseDest(BB);\n    assert(VVal && \"Should have a unique destination value\");\n    ICI->setOperand(0, VVal);\n\n    if (Value *V = SimplifyInstruction(ICI, {DL, ICI})) {\n      ICI->replaceAllUsesWith(V);\n      ICI->eraseFromParent();\n    }\n    // BB is now empty, so it is likely to simplify away.\n    return requestResimplify();\n  }\n\n  // Ok, the block is reachable from the default dest.  If the constant we're\n  // comparing exists in one of the other edges, then we can constant fold ICI\n  // and zap it.\n  if (SI->findCaseValue(Cst) != SI->case_default()) {\n    Value *V;\n    if (ICI->getPredicate() == ICmpInst::ICMP_EQ)\n      V = ConstantInt::getFalse(BB->getContext());\n    else\n      V = ConstantInt::getTrue(BB->getContext());\n\n    ICI->replaceAllUsesWith(V);\n    ICI->eraseFromParent();\n    // BB is now empty, so it is likely to simplify away.\n    return requestResimplify();\n  }\n\n  // The use of the icmp has to be in the 'end' block, by the only PHI node in\n  // the block.\n  BasicBlock *SuccBlock = BB->getTerminator()->getSuccessor(0);\n  PHINode *PHIUse = dyn_cast<PHINode>(ICI->user_back());\n  if (PHIUse == nullptr || PHIUse != &SuccBlock->front() ||\n      isa<PHINode>(++BasicBlock::iterator(PHIUse)))\n    return false;\n\n  // If the icmp is a SETEQ, then the default dest gets false, the new edge gets\n  // true in the PHI.\n  Constant *DefaultCst = ConstantInt::getTrue(BB->getContext());\n  Constant *NewCst = ConstantInt::getFalse(BB->getContext());\n\n  if (ICI->getPredicate() == ICmpInst::ICMP_EQ)\n    std::swap(DefaultCst, NewCst);\n\n  // Replace ICI (which is used by the PHI for the default value) with true or\n  // false depending on if it is EQ or NE.\n  ICI->replaceAllUsesWith(DefaultCst);\n  ICI->eraseFromParent();\n\n  SmallVector<DominatorTree::UpdateType, 2> Updates;\n\n  // Okay, the switch goes to this block on a default value.  Add an edge from\n  // the switch to the merge point on the compared value.\n  BasicBlock *NewBB =\n      BasicBlock::Create(BB->getContext(), \"switch.edge\", BB->getParent(), BB);\n  {\n    SwitchInstProfUpdateWrapper SIW(*SI);\n    auto W0 = SIW.getSuccessorWeight(0);\n    SwitchInstProfUpdateWrapper::CaseWeightOpt NewW;\n    if (W0) {\n      NewW = ((uint64_t(*W0) + 1) >> 1);\n      SIW.setSuccessorWeight(0, *NewW);\n    }\n    SIW.addCase(Cst, NewBB, NewW);\n    Updates.push_back({DominatorTree::Insert, Pred, NewBB});\n  }\n\n  // NewBB branches to the phi block, add the uncond branch and the phi entry.\n  Builder.SetInsertPoint(NewBB);\n  Builder.SetCurrentDebugLocation(SI->getDebugLoc());\n  Builder.CreateBr(SuccBlock);\n  Updates.push_back({DominatorTree::Insert, NewBB, SuccBlock});\n  PHIUse->addIncoming(NewCst, NewBB);\n  if (DTU)\n    DTU->applyUpdates(Updates);\n  return true;\n}\n\n/// The specified branch is a conditional branch.\n/// Check to see if it is branching on an or/and chain of icmp instructions, and\n/// fold it into a switch instruction if so.\nbool SimplifyCFGOpt::SimplifyBranchOnICmpChain(BranchInst *BI,\n                                               IRBuilder<> &Builder,\n                                               const DataLayout &DL) {\n  Instruction *Cond = dyn_cast<Instruction>(BI->getCondition());\n  if (!Cond)\n    return false;\n\n  // Change br (X == 0 | X == 1), T, F into a switch instruction.\n  // If this is a bunch of seteq's or'd together, or if it's a bunch of\n  // 'setne's and'ed together, collect them.\n\n  // Try to gather values from a chain of and/or to be turned into a switch\n  ConstantComparesGatherer ConstantCompare(Cond, DL);\n  // Unpack the result\n  SmallVectorImpl<ConstantInt *> &Values = ConstantCompare.Vals;\n  Value *CompVal = ConstantCompare.CompValue;\n  unsigned UsedICmps = ConstantCompare.UsedICmps;\n  Value *ExtraCase = ConstantCompare.Extra;\n\n  // If we didn't have a multiply compared value, fail.\n  if (!CompVal)\n    return false;\n\n  // Avoid turning single icmps into a switch.\n  if (UsedICmps <= 1)\n    return false;\n\n  bool TrueWhenEqual = match(Cond, m_LogicalOr(m_Value(), m_Value()));\n\n  // There might be duplicate constants in the list, which the switch\n  // instruction can't handle, remove them now.\n  array_pod_sort(Values.begin(), Values.end(), ConstantIntSortPredicate);\n  Values.erase(std::unique(Values.begin(), Values.end()), Values.end());\n\n  // If Extra was used, we require at least two switch values to do the\n  // transformation.  A switch with one value is just a conditional branch.\n  if (ExtraCase && Values.size() < 2)\n    return false;\n\n  // TODO: Preserve branch weight metadata, similarly to how\n  // FoldValueComparisonIntoPredecessors preserves it.\n\n  // Figure out which block is which destination.\n  BasicBlock *DefaultBB = BI->getSuccessor(1);\n  BasicBlock *EdgeBB = BI->getSuccessor(0);\n  if (!TrueWhenEqual)\n    std::swap(DefaultBB, EdgeBB);\n\n  BasicBlock *BB = BI->getParent();\n\n  // MSAN does not like undefs as branch condition which can be introduced\n  // with \"explicit branch\".\n  if (ExtraCase && BB->getParent()->hasFnAttribute(Attribute::SanitizeMemory))\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"Converting 'icmp' chain with \" << Values.size()\n                    << \" cases into SWITCH.  BB is:\\n\"\n                    << *BB);\n\n  SmallVector<DominatorTree::UpdateType, 2> Updates;\n\n  // If there are any extra values that couldn't be folded into the switch\n  // then we evaluate them with an explicit branch first. Split the block\n  // right before the condbr to handle it.\n  if (ExtraCase) {\n    BasicBlock *NewBB = SplitBlock(BB, BI, DTU, /*LI=*/nullptr,\n                                   /*MSSAU=*/nullptr, \"switch.early.test\");\n\n    // Remove the uncond branch added to the old block.\n    Instruction *OldTI = BB->getTerminator();\n    Builder.SetInsertPoint(OldTI);\n\n    if (TrueWhenEqual)\n      Builder.CreateCondBr(ExtraCase, EdgeBB, NewBB);\n    else\n      Builder.CreateCondBr(ExtraCase, NewBB, EdgeBB);\n\n    OldTI->eraseFromParent();\n\n    Updates.push_back({DominatorTree::Insert, BB, EdgeBB});\n\n    // If there are PHI nodes in EdgeBB, then we need to add a new entry to them\n    // for the edge we just added.\n    AddPredecessorToBlock(EdgeBB, BB, NewBB);\n\n    LLVM_DEBUG(dbgs() << \"  ** 'icmp' chain unhandled condition: \" << *ExtraCase\n                      << \"\\nEXTRABB = \" << *BB);\n    BB = NewBB;\n  }\n\n  Builder.SetInsertPoint(BI);\n  // Convert pointer to int before we switch.\n  if (CompVal->getType()->isPointerTy()) {\n    CompVal = Builder.CreatePtrToInt(\n        CompVal, DL.getIntPtrType(CompVal->getType()), \"magicptr\");\n  }\n\n  // Create the new switch instruction now.\n  SwitchInst *New = Builder.CreateSwitch(CompVal, DefaultBB, Values.size());\n\n  // Add all of the 'cases' to the switch instruction.\n  for (unsigned i = 0, e = Values.size(); i != e; ++i)\n    New->addCase(Values[i], EdgeBB);\n\n  // We added edges from PI to the EdgeBB.  As such, if there were any\n  // PHI nodes in EdgeBB, they need entries to be added corresponding to\n  // the number of edges added.\n  for (BasicBlock::iterator BBI = EdgeBB->begin(); isa<PHINode>(BBI); ++BBI) {\n    PHINode *PN = cast<PHINode>(BBI);\n    Value *InVal = PN->getIncomingValueForBlock(BB);\n    for (unsigned i = 0, e = Values.size() - 1; i != e; ++i)\n      PN->addIncoming(InVal, BB);\n  }\n\n  // Erase the old branch instruction.\n  EraseTerminatorAndDCECond(BI);\n  if (DTU)\n    DTU->applyUpdates(Updates);\n\n  LLVM_DEBUG(dbgs() << \"  ** 'icmp' chain result is:\\n\" << *BB << '\\n');\n  return true;\n}\n\nbool SimplifyCFGOpt::simplifyResume(ResumeInst *RI, IRBuilder<> &Builder) {\n  if (isa<PHINode>(RI->getValue()))\n    return simplifyCommonResume(RI);\n  else if (isa<LandingPadInst>(RI->getParent()->getFirstNonPHI()) &&\n           RI->getValue() == RI->getParent()->getFirstNonPHI())\n    // The resume must unwind the exception that caused control to branch here.\n    return simplifySingleResume(RI);\n\n  return false;\n}\n\n// Check if cleanup block is empty\nstatic bool isCleanupBlockEmpty(iterator_range<BasicBlock::iterator> R) {\n  for (Instruction &I : R) {\n    auto *II = dyn_cast<IntrinsicInst>(&I);\n    if (!II)\n      return false;\n\n    Intrinsic::ID IntrinsicID = II->getIntrinsicID();\n    switch (IntrinsicID) {\n    case Intrinsic::dbg_declare:\n    case Intrinsic::dbg_value:\n    case Intrinsic::dbg_label:\n    case Intrinsic::lifetime_end:\n      break;\n    default:\n      return false;\n    }\n  }\n  return true;\n}\n\n// Simplify resume that is shared by several landing pads (phi of landing pad).\nbool SimplifyCFGOpt::simplifyCommonResume(ResumeInst *RI) {\n  BasicBlock *BB = RI->getParent();\n\n  // Check that there are no other instructions except for debug and lifetime\n  // intrinsics between the phi's and resume instruction.\n  if (!isCleanupBlockEmpty(\n          make_range(RI->getParent()->getFirstNonPHI(), BB->getTerminator())))\n    return false;\n\n  SmallSetVector<BasicBlock *, 4> TrivialUnwindBlocks;\n  auto *PhiLPInst = cast<PHINode>(RI->getValue());\n\n  // Check incoming blocks to see if any of them are trivial.\n  for (unsigned Idx = 0, End = PhiLPInst->getNumIncomingValues(); Idx != End;\n       Idx++) {\n    auto *IncomingBB = PhiLPInst->getIncomingBlock(Idx);\n    auto *IncomingValue = PhiLPInst->getIncomingValue(Idx);\n\n    // If the block has other successors, we can not delete it because\n    // it has other dependents.\n    if (IncomingBB->getUniqueSuccessor() != BB)\n      continue;\n\n    auto *LandingPad = dyn_cast<LandingPadInst>(IncomingBB->getFirstNonPHI());\n    // Not the landing pad that caused the control to branch here.\n    if (IncomingValue != LandingPad)\n      continue;\n\n    if (isCleanupBlockEmpty(\n            make_range(LandingPad->getNextNode(), IncomingBB->getTerminator())))\n      TrivialUnwindBlocks.insert(IncomingBB);\n  }\n\n  // If no trivial unwind blocks, don't do any simplifications.\n  if (TrivialUnwindBlocks.empty())\n    return false;\n\n  // Turn all invokes that unwind here into calls.\n  for (auto *TrivialBB : TrivialUnwindBlocks) {\n    // Blocks that will be simplified should be removed from the phi node.\n    // Note there could be multiple edges to the resume block, and we need\n    // to remove them all.\n    while (PhiLPInst->getBasicBlockIndex(TrivialBB) != -1)\n      BB->removePredecessor(TrivialBB, true);\n\n    for (BasicBlock *Pred :\n         llvm::make_early_inc_range(predecessors(TrivialBB))) {\n      removeUnwindEdge(Pred, DTU);\n      ++NumInvokes;\n    }\n\n    // In each SimplifyCFG run, only the current processed block can be erased.\n    // Otherwise, it will break the iteration of SimplifyCFG pass. So instead\n    // of erasing TrivialBB, we only remove the branch to the common resume\n    // block so that we can later erase the resume block since it has no\n    // predecessors.\n    TrivialBB->getTerminator()->eraseFromParent();\n    new UnreachableInst(RI->getContext(), TrivialBB);\n    if (DTU)\n      DTU->applyUpdates({{DominatorTree::Delete, TrivialBB, BB}});\n  }\n\n  // Delete the resume block if all its predecessors have been removed.\n  if (pred_empty(BB)) {\n    if (DTU)\n      DTU->deleteBB(BB);\n    else\n      BB->eraseFromParent();\n  }\n\n  return !TrivialUnwindBlocks.empty();\n}\n\n// Simplify resume that is only used by a single (non-phi) landing pad.\nbool SimplifyCFGOpt::simplifySingleResume(ResumeInst *RI) {\n  BasicBlock *BB = RI->getParent();\n  auto *LPInst = cast<LandingPadInst>(BB->getFirstNonPHI());\n  assert(RI->getValue() == LPInst &&\n         \"Resume must unwind the exception that caused control to here\");\n\n  // Check that there are no other instructions except for debug intrinsics.\n  if (!isCleanupBlockEmpty(\n          make_range<Instruction *>(LPInst->getNextNode(), RI)))\n    return false;\n\n  // Turn all invokes that unwind here into calls and delete the basic block.\n  for (BasicBlock *Pred : llvm::make_early_inc_range(predecessors(BB))) {\n    removeUnwindEdge(Pred, DTU);\n    ++NumInvokes;\n  }\n\n  // The landingpad is now unreachable.  Zap it.\n  if (DTU)\n    DTU->deleteBB(BB);\n  else\n    BB->eraseFromParent();\n  return true;\n}\n\nstatic bool removeEmptyCleanup(CleanupReturnInst *RI, DomTreeUpdater *DTU) {\n  // If this is a trivial cleanup pad that executes no instructions, it can be\n  // eliminated.  If the cleanup pad continues to the caller, any predecessor\n  // that is an EH pad will be updated to continue to the caller and any\n  // predecessor that terminates with an invoke instruction will have its invoke\n  // instruction converted to a call instruction.  If the cleanup pad being\n  // simplified does not continue to the caller, each predecessor will be\n  // updated to continue to the unwind destination of the cleanup pad being\n  // simplified.\n  BasicBlock *BB = RI->getParent();\n  CleanupPadInst *CPInst = RI->getCleanupPad();\n  if (CPInst->getParent() != BB)\n    // This isn't an empty cleanup.\n    return false;\n\n  // We cannot kill the pad if it has multiple uses.  This typically arises\n  // from unreachable basic blocks.\n  if (!CPInst->hasOneUse())\n    return false;\n\n  // Check that there are no other instructions except for benign intrinsics.\n  if (!isCleanupBlockEmpty(\n          make_range<Instruction *>(CPInst->getNextNode(), RI)))\n    return false;\n\n  // If the cleanup return we are simplifying unwinds to the caller, this will\n  // set UnwindDest to nullptr.\n  BasicBlock *UnwindDest = RI->getUnwindDest();\n  Instruction *DestEHPad = UnwindDest ? UnwindDest->getFirstNonPHI() : nullptr;\n\n  // We're about to remove BB from the control flow.  Before we do, sink any\n  // PHINodes into the unwind destination.  Doing this before changing the\n  // control flow avoids some potentially slow checks, since we can currently\n  // be certain that UnwindDest and BB have no common predecessors (since they\n  // are both EH pads).\n  if (UnwindDest) {\n    // First, go through the PHI nodes in UnwindDest and update any nodes that\n    // reference the block we are removing\n    for (BasicBlock::iterator I = UnwindDest->begin(),\n                              IE = DestEHPad->getIterator();\n         I != IE; ++I) {\n      PHINode *DestPN = cast<PHINode>(I);\n\n      int Idx = DestPN->getBasicBlockIndex(BB);\n      // Since BB unwinds to UnwindDest, it has to be in the PHI node.\n      assert(Idx != -1);\n      // This PHI node has an incoming value that corresponds to a control\n      // path through the cleanup pad we are removing.  If the incoming\n      // value is in the cleanup pad, it must be a PHINode (because we\n      // verified above that the block is otherwise empty).  Otherwise, the\n      // value is either a constant or a value that dominates the cleanup\n      // pad being removed.\n      //\n      // Because BB and UnwindDest are both EH pads, all of their\n      // predecessors must unwind to these blocks, and since no instruction\n      // can have multiple unwind destinations, there will be no overlap in\n      // incoming blocks between SrcPN and DestPN.\n      Value *SrcVal = DestPN->getIncomingValue(Idx);\n      PHINode *SrcPN = dyn_cast<PHINode>(SrcVal);\n\n      // Remove the entry for the block we are deleting.\n      DestPN->removeIncomingValue(Idx, false);\n\n      if (SrcPN && SrcPN->getParent() == BB) {\n        // If the incoming value was a PHI node in the cleanup pad we are\n        // removing, we need to merge that PHI node's incoming values into\n        // DestPN.\n        for (unsigned SrcIdx = 0, SrcE = SrcPN->getNumIncomingValues();\n             SrcIdx != SrcE; ++SrcIdx) {\n          DestPN->addIncoming(SrcPN->getIncomingValue(SrcIdx),\n                              SrcPN->getIncomingBlock(SrcIdx));\n        }\n      } else {\n        // Otherwise, the incoming value came from above BB and\n        // so we can just reuse it.  We must associate all of BB's\n        // predecessors with this value.\n        for (auto *pred : predecessors(BB)) {\n          DestPN->addIncoming(SrcVal, pred);\n        }\n      }\n    }\n\n    // Sink any remaining PHI nodes directly into UnwindDest.\n    Instruction *InsertPt = DestEHPad;\n    for (BasicBlock::iterator I = BB->begin(),\n                              IE = BB->getFirstNonPHI()->getIterator();\n         I != IE;) {\n      // The iterator must be incremented here because the instructions are\n      // being moved to another block.\n      PHINode *PN = cast<PHINode>(I++);\n      if (PN->use_empty() || !PN->isUsedOutsideOfBlock(BB))\n        // If the PHI node has no uses or all of its uses are in this basic\n        // block (meaning they are debug or lifetime intrinsics), just leave\n        // it.  It will be erased when we erase BB below.\n        continue;\n\n      // Otherwise, sink this PHI node into UnwindDest.\n      // Any predecessors to UnwindDest which are not already represented\n      // must be back edges which inherit the value from the path through\n      // BB.  In this case, the PHI value must reference itself.\n      for (auto *pred : predecessors(UnwindDest))\n        if (pred != BB)\n          PN->addIncoming(PN, pred);\n      PN->moveBefore(InsertPt);\n    }\n  }\n\n  std::vector<DominatorTree::UpdateType> Updates;\n\n  // We use make_early_inc_range here because we may remove some predecessors.\n  for (BasicBlock *PredBB : llvm::make_early_inc_range(predecessors(BB))) {\n    if (UnwindDest == nullptr) {\n      if (DTU)\n        DTU->applyUpdates(Updates);\n      Updates.clear();\n      removeUnwindEdge(PredBB, DTU);\n      ++NumInvokes;\n    } else {\n      Instruction *TI = PredBB->getTerminator();\n      TI->replaceUsesOfWith(BB, UnwindDest);\n      Updates.push_back({DominatorTree::Insert, PredBB, UnwindDest});\n      Updates.push_back({DominatorTree::Delete, PredBB, BB});\n    }\n  }\n\n  if (DTU) {\n    DTU->applyUpdates(Updates);\n    DTU->deleteBB(BB);\n  } else\n    // The cleanup pad is now unreachable.  Zap it.\n    BB->eraseFromParent();\n\n  return true;\n}\n\n// Try to merge two cleanuppads together.\nstatic bool mergeCleanupPad(CleanupReturnInst *RI) {\n  // Skip any cleanuprets which unwind to caller, there is nothing to merge\n  // with.\n  BasicBlock *UnwindDest = RI->getUnwindDest();\n  if (!UnwindDest)\n    return false;\n\n  // This cleanupret isn't the only predecessor of this cleanuppad, it wouldn't\n  // be safe to merge without code duplication.\n  if (UnwindDest->getSinglePredecessor() != RI->getParent())\n    return false;\n\n  // Verify that our cleanuppad's unwind destination is another cleanuppad.\n  auto *SuccessorCleanupPad = dyn_cast<CleanupPadInst>(&UnwindDest->front());\n  if (!SuccessorCleanupPad)\n    return false;\n\n  CleanupPadInst *PredecessorCleanupPad = RI->getCleanupPad();\n  // Replace any uses of the successor cleanupad with the predecessor pad\n  // The only cleanuppad uses should be this cleanupret, it's cleanupret and\n  // funclet bundle operands.\n  SuccessorCleanupPad->replaceAllUsesWith(PredecessorCleanupPad);\n  // Remove the old cleanuppad.\n  SuccessorCleanupPad->eraseFromParent();\n  // Now, we simply replace the cleanupret with a branch to the unwind\n  // destination.\n  BranchInst::Create(UnwindDest, RI->getParent());\n  RI->eraseFromParent();\n\n  return true;\n}\n\nbool SimplifyCFGOpt::simplifyCleanupReturn(CleanupReturnInst *RI) {\n  // It is possible to transiantly have an undef cleanuppad operand because we\n  // have deleted some, but not all, dead blocks.\n  // Eventually, this block will be deleted.\n  if (isa<UndefValue>(RI->getOperand(0)))\n    return false;\n\n  if (mergeCleanupPad(RI))\n    return true;\n\n  if (removeEmptyCleanup(RI, DTU))\n    return true;\n\n  return false;\n}\n\nbool SimplifyCFGOpt::simplifyReturn(ReturnInst *RI, IRBuilder<> &Builder) {\n  BasicBlock *BB = RI->getParent();\n  if (!BB->getFirstNonPHIOrDbg()->isTerminator())\n    return false;\n\n  // Find predecessors that end with branches.\n  SmallVector<BasicBlock *, 8> UncondBranchPreds;\n  SmallVector<BranchInst *, 8> CondBranchPreds;\n  for (BasicBlock *P : predecessors(BB)) {\n    Instruction *PTI = P->getTerminator();\n    if (BranchInst *BI = dyn_cast<BranchInst>(PTI)) {\n      if (BI->isUnconditional())\n        UncondBranchPreds.push_back(P);\n      else\n        CondBranchPreds.push_back(BI);\n    }\n  }\n\n  // If we found some, do the transformation!\n  if (!UncondBranchPreds.empty() && DupRet) {\n    while (!UncondBranchPreds.empty()) {\n      BasicBlock *Pred = UncondBranchPreds.pop_back_val();\n      LLVM_DEBUG(dbgs() << \"FOLDING: \" << *BB\n                        << \"INTO UNCOND BRANCH PRED: \" << *Pred);\n      (void)FoldReturnIntoUncondBranch(RI, BB, Pred, DTU);\n    }\n\n    // If we eliminated all predecessors of the block, delete the block now.\n    if (pred_empty(BB)) {\n      // We know there are no successors, so just nuke the block.\n      if (DTU)\n        DTU->deleteBB(BB);\n      else\n        BB->eraseFromParent();\n    }\n\n    return true;\n  }\n\n  // Check out all of the conditional branches going to this return\n  // instruction.  If any of them just select between returns, change the\n  // branch itself into a select/return pair.\n  while (!CondBranchPreds.empty()) {\n    BranchInst *BI = CondBranchPreds.pop_back_val();\n\n    // Check to see if the non-BB successor is also a return block.\n    if (isa<ReturnInst>(BI->getSuccessor(0)->getTerminator()) &&\n        isa<ReturnInst>(BI->getSuccessor(1)->getTerminator()) &&\n        SimplifyCondBranchToTwoReturns(BI, Builder))\n      return true;\n  }\n  return false;\n}\n\nbool SimplifyCFGOpt::simplifyUnreachable(UnreachableInst *UI) {\n  BasicBlock *BB = UI->getParent();\n\n  bool Changed = false;\n\n  // If there are any instructions immediately before the unreachable that can\n  // be removed, do so.\n  while (UI->getIterator() != BB->begin()) {\n    BasicBlock::iterator BBI = UI->getIterator();\n    --BBI;\n    // Do not delete instructions that can have side effects which might cause\n    // the unreachable to not be reachable; specifically, calls and volatile\n    // operations may have this effect.\n    if (isa<CallInst>(BBI) && !isa<DbgInfoIntrinsic>(BBI))\n      break;\n\n    if (BBI->mayHaveSideEffects()) {\n      if (auto *SI = dyn_cast<StoreInst>(BBI)) {\n        if (SI->isVolatile())\n          break;\n      } else if (auto *LI = dyn_cast<LoadInst>(BBI)) {\n        if (LI->isVolatile())\n          break;\n      } else if (auto *RMWI = dyn_cast<AtomicRMWInst>(BBI)) {\n        if (RMWI->isVolatile())\n          break;\n      } else if (auto *CXI = dyn_cast<AtomicCmpXchgInst>(BBI)) {\n        if (CXI->isVolatile())\n          break;\n      } else if (isa<CatchPadInst>(BBI)) {\n        // A catchpad may invoke exception object constructors and such, which\n        // in some languages can be arbitrary code, so be conservative by\n        // default.\n        // For CoreCLR, it just involves a type test, so can be removed.\n        if (classifyEHPersonality(BB->getParent()->getPersonalityFn()) !=\n            EHPersonality::CoreCLR)\n          break;\n      } else if (!isa<FenceInst>(BBI) && !isa<VAArgInst>(BBI) &&\n                 !isa<LandingPadInst>(BBI)) {\n        break;\n      }\n      // Note that deleting LandingPad's here is in fact okay, although it\n      // involves a bit of subtle reasoning. If this inst is a LandingPad,\n      // all the predecessors of this block will be the unwind edges of Invokes,\n      // and we can therefore guarantee this block will be erased.\n    }\n\n    // Delete this instruction (any uses are guaranteed to be dead)\n    if (!BBI->use_empty())\n      BBI->replaceAllUsesWith(UndefValue::get(BBI->getType()));\n    BBI->eraseFromParent();\n    Changed = true;\n  }\n\n  // If the unreachable instruction is the first in the block, take a gander\n  // at all of the predecessors of this instruction, and simplify them.\n  if (&BB->front() != UI)\n    return Changed;\n\n  std::vector<DominatorTree::UpdateType> Updates;\n\n  SmallSetVector<BasicBlock *, 8> Preds(pred_begin(BB), pred_end(BB));\n  for (unsigned i = 0, e = Preds.size(); i != e; ++i) {\n    auto *Predecessor = Preds[i];\n    Instruction *TI = Predecessor->getTerminator();\n    IRBuilder<> Builder(TI);\n    if (auto *BI = dyn_cast<BranchInst>(TI)) {\n      // We could either have a proper unconditional branch,\n      // or a degenerate conditional branch with matching destinations.\n      if (all_of(BI->successors(),\n                 [BB](auto *Successor) { return Successor == BB; })) {\n        new UnreachableInst(TI->getContext(), TI);\n        TI->eraseFromParent();\n        Changed = true;\n      } else {\n        assert(BI->isConditional() && \"Can't get here with an uncond branch.\");\n        Value* Cond = BI->getCondition();\n        assert(BI->getSuccessor(0) != BI->getSuccessor(1) &&\n               \"The destinations are guaranteed to be different here.\");\n        if (BI->getSuccessor(0) == BB) {\n          Builder.CreateAssumption(Builder.CreateNot(Cond));\n          Builder.CreateBr(BI->getSuccessor(1));\n        } else {\n          assert(BI->getSuccessor(1) == BB && \"Incorrect CFG\");\n          Builder.CreateAssumption(Cond);\n          Builder.CreateBr(BI->getSuccessor(0));\n        }\n        EraseTerminatorAndDCECond(BI);\n        Changed = true;\n      }\n      Updates.push_back({DominatorTree::Delete, Predecessor, BB});\n    } else if (auto *SI = dyn_cast<SwitchInst>(TI)) {\n      SwitchInstProfUpdateWrapper SU(*SI);\n      for (auto i = SU->case_begin(), e = SU->case_end(); i != e;) {\n        if (i->getCaseSuccessor() != BB) {\n          ++i;\n          continue;\n        }\n        BB->removePredecessor(SU->getParent());\n        i = SU.removeCase(i);\n        e = SU->case_end();\n        Changed = true;\n      }\n      // Note that the default destination can't be removed!\n      if (SI->getDefaultDest() != BB)\n        Updates.push_back({DominatorTree::Delete, Predecessor, BB});\n    } else if (auto *II = dyn_cast<InvokeInst>(TI)) {\n      if (II->getUnwindDest() == BB) {\n        if (DTU)\n          DTU->applyUpdates(Updates);\n        Updates.clear();\n        removeUnwindEdge(TI->getParent(), DTU);\n        Changed = true;\n      }\n    } else if (auto *CSI = dyn_cast<CatchSwitchInst>(TI)) {\n      if (CSI->getUnwindDest() == BB) {\n        if (DTU)\n          DTU->applyUpdates(Updates);\n        Updates.clear();\n        removeUnwindEdge(TI->getParent(), DTU);\n        Changed = true;\n        continue;\n      }\n\n      for (CatchSwitchInst::handler_iterator I = CSI->handler_begin(),\n                                             E = CSI->handler_end();\n           I != E; ++I) {\n        if (*I == BB) {\n          CSI->removeHandler(I);\n          --I;\n          --E;\n          Changed = true;\n        }\n      }\n      Updates.push_back({DominatorTree::Delete, Predecessor, BB});\n      if (CSI->getNumHandlers() == 0) {\n        if (CSI->hasUnwindDest()) {\n          // Redirect all predecessors of the block containing CatchSwitchInst\n          // to instead branch to the CatchSwitchInst's unwind destination.\n          for (auto *PredecessorOfPredecessor : predecessors(Predecessor)) {\n            Updates.push_back({DominatorTree::Insert, PredecessorOfPredecessor,\n                               CSI->getUnwindDest()});\n            Updates.push_back(\n                {DominatorTree::Delete, PredecessorOfPredecessor, Predecessor});\n          }\n          Predecessor->replaceAllUsesWith(CSI->getUnwindDest());\n        } else {\n          // Rewrite all preds to unwind to caller (or from invoke to call).\n          if (DTU)\n            DTU->applyUpdates(Updates);\n          Updates.clear();\n          SmallVector<BasicBlock *, 8> EHPreds(predecessors(Predecessor));\n          for (BasicBlock *EHPred : EHPreds)\n            removeUnwindEdge(EHPred, DTU);\n        }\n        // The catchswitch is no longer reachable.\n        new UnreachableInst(CSI->getContext(), CSI);\n        CSI->eraseFromParent();\n        Changed = true;\n      }\n    } else if (auto *CRI = dyn_cast<CleanupReturnInst>(TI)) {\n      (void)CRI;\n      assert(CRI->hasUnwindDest() && CRI->getUnwindDest() == BB &&\n             \"Expected to always have an unwind to BB.\");\n      Updates.push_back({DominatorTree::Delete, Predecessor, BB});\n      new UnreachableInst(TI->getContext(), TI);\n      TI->eraseFromParent();\n      Changed = true;\n    }\n  }\n\n  if (DTU)\n    DTU->applyUpdates(Updates);\n\n  // If this block is now dead, remove it.\n  if (pred_empty(BB) && BB != &BB->getParent()->getEntryBlock()) {\n    // We know there are no successors, so just nuke the block.\n    if (DTU)\n      DTU->deleteBB(BB);\n    else\n      BB->eraseFromParent();\n    return true;\n  }\n\n  return Changed;\n}\n\nstatic bool CasesAreContiguous(SmallVectorImpl<ConstantInt *> &Cases) {\n  assert(Cases.size() >= 1);\n\n  array_pod_sort(Cases.begin(), Cases.end(), ConstantIntSortPredicate);\n  for (size_t I = 1, E = Cases.size(); I != E; ++I) {\n    if (Cases[I - 1]->getValue() != Cases[I]->getValue() + 1)\n      return false;\n  }\n  return true;\n}\n\nstatic void createUnreachableSwitchDefault(SwitchInst *Switch,\n                                           DomTreeUpdater *DTU) {\n  LLVM_DEBUG(dbgs() << \"SimplifyCFG: switch default is dead.\\n\");\n  auto *BB = Switch->getParent();\n  BasicBlock *NewDefaultBlock = SplitBlockPredecessors(\n      Switch->getDefaultDest(), Switch->getParent(), \"\", DTU);\n  auto *OrigDefaultBlock = Switch->getDefaultDest();\n  Switch->setDefaultDest(&*NewDefaultBlock);\n  if (DTU)\n    DTU->applyUpdates({{DominatorTree::Insert, BB, &*NewDefaultBlock},\n                       {DominatorTree::Delete, BB, OrigDefaultBlock}});\n  SplitBlock(&*NewDefaultBlock, &NewDefaultBlock->front(), DTU);\n  SmallVector<DominatorTree::UpdateType, 2> Updates;\n  for (auto *Successor : successors(NewDefaultBlock))\n    Updates.push_back({DominatorTree::Delete, NewDefaultBlock, Successor});\n  auto *NewTerminator = NewDefaultBlock->getTerminator();\n  new UnreachableInst(Switch->getContext(), NewTerminator);\n  EraseTerminatorAndDCECond(NewTerminator);\n  if (DTU)\n    DTU->applyUpdates(Updates);\n}\n\n/// Turn a switch with two reachable destinations into an integer range\n/// comparison and branch.\nbool SimplifyCFGOpt::TurnSwitchRangeIntoICmp(SwitchInst *SI,\n                                             IRBuilder<> &Builder) {\n  assert(SI->getNumCases() > 1 && \"Degenerate switch?\");\n\n  bool HasDefault =\n      !isa<UnreachableInst>(SI->getDefaultDest()->getFirstNonPHIOrDbg());\n\n  auto *BB = SI->getParent();\n\n  // Partition the cases into two sets with different destinations.\n  BasicBlock *DestA = HasDefault ? SI->getDefaultDest() : nullptr;\n  BasicBlock *DestB = nullptr;\n  SmallVector<ConstantInt *, 16> CasesA;\n  SmallVector<ConstantInt *, 16> CasesB;\n\n  for (auto Case : SI->cases()) {\n    BasicBlock *Dest = Case.getCaseSuccessor();\n    if (!DestA)\n      DestA = Dest;\n    if (Dest == DestA) {\n      CasesA.push_back(Case.getCaseValue());\n      continue;\n    }\n    if (!DestB)\n      DestB = Dest;\n    if (Dest == DestB) {\n      CasesB.push_back(Case.getCaseValue());\n      continue;\n    }\n    return false; // More than two destinations.\n  }\n\n  assert(DestA && DestB &&\n         \"Single-destination switch should have been folded.\");\n  assert(DestA != DestB);\n  assert(DestB != SI->getDefaultDest());\n  assert(!CasesB.empty() && \"There must be non-default cases.\");\n  assert(!CasesA.empty() || HasDefault);\n\n  // Figure out if one of the sets of cases form a contiguous range.\n  SmallVectorImpl<ConstantInt *> *ContiguousCases = nullptr;\n  BasicBlock *ContiguousDest = nullptr;\n  BasicBlock *OtherDest = nullptr;\n  if (!CasesA.empty() && CasesAreContiguous(CasesA)) {\n    ContiguousCases = &CasesA;\n    ContiguousDest = DestA;\n    OtherDest = DestB;\n  } else if (CasesAreContiguous(CasesB)) {\n    ContiguousCases = &CasesB;\n    ContiguousDest = DestB;\n    OtherDest = DestA;\n  } else\n    return false;\n\n  // Start building the compare and branch.\n\n  Constant *Offset = ConstantExpr::getNeg(ContiguousCases->back());\n  Constant *NumCases =\n      ConstantInt::get(Offset->getType(), ContiguousCases->size());\n\n  Value *Sub = SI->getCondition();\n  if (!Offset->isNullValue())\n    Sub = Builder.CreateAdd(Sub, Offset, Sub->getName() + \".off\");\n\n  Value *Cmp;\n  // If NumCases overflowed, then all possible values jump to the successor.\n  if (NumCases->isNullValue() && !ContiguousCases->empty())\n    Cmp = ConstantInt::getTrue(SI->getContext());\n  else\n    Cmp = Builder.CreateICmpULT(Sub, NumCases, \"switch\");\n  BranchInst *NewBI = Builder.CreateCondBr(Cmp, ContiguousDest, OtherDest);\n\n  // Update weight for the newly-created conditional branch.\n  if (HasBranchWeights(SI)) {\n    SmallVector<uint64_t, 8> Weights;\n    GetBranchWeights(SI, Weights);\n    if (Weights.size() == 1 + SI->getNumCases()) {\n      uint64_t TrueWeight = 0;\n      uint64_t FalseWeight = 0;\n      for (size_t I = 0, E = Weights.size(); I != E; ++I) {\n        if (SI->getSuccessor(I) == ContiguousDest)\n          TrueWeight += Weights[I];\n        else\n          FalseWeight += Weights[I];\n      }\n      while (TrueWeight > UINT32_MAX || FalseWeight > UINT32_MAX) {\n        TrueWeight /= 2;\n        FalseWeight /= 2;\n      }\n      setBranchWeights(NewBI, TrueWeight, FalseWeight);\n    }\n  }\n\n  // Prune obsolete incoming values off the successors' PHI nodes.\n  for (auto BBI = ContiguousDest->begin(); isa<PHINode>(BBI); ++BBI) {\n    unsigned PreviousEdges = ContiguousCases->size();\n    if (ContiguousDest == SI->getDefaultDest())\n      ++PreviousEdges;\n    for (unsigned I = 0, E = PreviousEdges - 1; I != E; ++I)\n      cast<PHINode>(BBI)->removeIncomingValue(SI->getParent());\n  }\n  for (auto BBI = OtherDest->begin(); isa<PHINode>(BBI); ++BBI) {\n    unsigned PreviousEdges = SI->getNumCases() - ContiguousCases->size();\n    if (OtherDest == SI->getDefaultDest())\n      ++PreviousEdges;\n    for (unsigned I = 0, E = PreviousEdges - 1; I != E; ++I)\n      cast<PHINode>(BBI)->removeIncomingValue(SI->getParent());\n  }\n\n  // Clean up the default block - it may have phis or other instructions before\n  // the unreachable terminator.\n  if (!HasDefault)\n    createUnreachableSwitchDefault(SI, DTU);\n\n  auto *UnreachableDefault = SI->getDefaultDest();\n\n  // Drop the switch.\n  SI->eraseFromParent();\n\n  if (!HasDefault && DTU)\n    DTU->applyUpdates({{DominatorTree::Delete, BB, UnreachableDefault}});\n\n  return true;\n}\n\n/// Compute masked bits for the condition of a switch\n/// and use it to remove dead cases.\nstatic bool eliminateDeadSwitchCases(SwitchInst *SI, DomTreeUpdater *DTU,\n                                     AssumptionCache *AC,\n                                     const DataLayout &DL) {\n  Value *Cond = SI->getCondition();\n  unsigned Bits = Cond->getType()->getIntegerBitWidth();\n  KnownBits Known = computeKnownBits(Cond, DL, 0, AC, SI);\n\n  // We can also eliminate cases by determining that their values are outside of\n  // the limited range of the condition based on how many significant (non-sign)\n  // bits are in the condition value.\n  unsigned ExtraSignBits = ComputeNumSignBits(Cond, DL, 0, AC, SI) - 1;\n  unsigned MaxSignificantBitsInCond = Bits - ExtraSignBits;\n\n  // Gather dead cases.\n  SmallVector<ConstantInt *, 8> DeadCases;\n  SmallMapVector<BasicBlock *, int, 8> NumPerSuccessorCases;\n  for (auto &Case : SI->cases()) {\n    auto *Successor = Case.getCaseSuccessor();\n    ++NumPerSuccessorCases[Successor];\n    const APInt &CaseVal = Case.getCaseValue()->getValue();\n    if (Known.Zero.intersects(CaseVal) || !Known.One.isSubsetOf(CaseVal) ||\n        (CaseVal.getMinSignedBits() > MaxSignificantBitsInCond)) {\n      DeadCases.push_back(Case.getCaseValue());\n      --NumPerSuccessorCases[Successor];\n      LLVM_DEBUG(dbgs() << \"SimplifyCFG: switch case \" << CaseVal\n                        << \" is dead.\\n\");\n    }\n  }\n\n  // If we can prove that the cases must cover all possible values, the\n  // default destination becomes dead and we can remove it.  If we know some\n  // of the bits in the value, we can use that to more precisely compute the\n  // number of possible unique case values.\n  bool HasDefault =\n      !isa<UnreachableInst>(SI->getDefaultDest()->getFirstNonPHIOrDbg());\n  const unsigned NumUnknownBits =\n      Bits - (Known.Zero | Known.One).countPopulation();\n  assert(NumUnknownBits <= Bits);\n  if (HasDefault && DeadCases.empty() &&\n      NumUnknownBits < 64 /* avoid overflow */ &&\n      SI->getNumCases() == (1ULL << NumUnknownBits)) {\n    createUnreachableSwitchDefault(SI, DTU);\n    return true;\n  }\n\n  if (DeadCases.empty())\n    return false;\n\n  SwitchInstProfUpdateWrapper SIW(*SI);\n  for (ConstantInt *DeadCase : DeadCases) {\n    SwitchInst::CaseIt CaseI = SI->findCaseValue(DeadCase);\n    assert(CaseI != SI->case_default() &&\n           \"Case was not found. Probably mistake in DeadCases forming.\");\n    // Prune unused values from PHI nodes.\n    CaseI->getCaseSuccessor()->removePredecessor(SI->getParent());\n    SIW.removeCase(CaseI);\n  }\n\n  std::vector<DominatorTree::UpdateType> Updates;\n  for (const std::pair<BasicBlock *, int> &I : NumPerSuccessorCases)\n    if (I.second == 0)\n      Updates.push_back({DominatorTree::Delete, SI->getParent(), I.first});\n  if (DTU)\n    DTU->applyUpdates(Updates);\n\n  return true;\n}\n\n/// If BB would be eligible for simplification by\n/// TryToSimplifyUncondBranchFromEmptyBlock (i.e. it is empty and terminated\n/// by an unconditional branch), look at the phi node for BB in the successor\n/// block and see if the incoming value is equal to CaseValue. If so, return\n/// the phi node, and set PhiIndex to BB's index in the phi node.\nstatic PHINode *FindPHIForConditionForwarding(ConstantInt *CaseValue,\n                                              BasicBlock *BB, int *PhiIndex) {\n  if (BB->getFirstNonPHIOrDbg() != BB->getTerminator())\n    return nullptr; // BB must be empty to be a candidate for simplification.\n  if (!BB->getSinglePredecessor())\n    return nullptr; // BB must be dominated by the switch.\n\n  BranchInst *Branch = dyn_cast<BranchInst>(BB->getTerminator());\n  if (!Branch || !Branch->isUnconditional())\n    return nullptr; // Terminator must be unconditional branch.\n\n  BasicBlock *Succ = Branch->getSuccessor(0);\n\n  for (PHINode &PHI : Succ->phis()) {\n    int Idx = PHI.getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"PHI has no entry for predecessor?\");\n\n    Value *InValue = PHI.getIncomingValue(Idx);\n    if (InValue != CaseValue)\n      continue;\n\n    *PhiIndex = Idx;\n    return &PHI;\n  }\n\n  return nullptr;\n}\n\n/// Try to forward the condition of a switch instruction to a phi node\n/// dominated by the switch, if that would mean that some of the destination\n/// blocks of the switch can be folded away. Return true if a change is made.\nstatic bool ForwardSwitchConditionToPHI(SwitchInst *SI) {\n  using ForwardingNodesMap = DenseMap<PHINode *, SmallVector<int, 4>>;\n\n  ForwardingNodesMap ForwardingNodes;\n  BasicBlock *SwitchBlock = SI->getParent();\n  bool Changed = false;\n  for (auto &Case : SI->cases()) {\n    ConstantInt *CaseValue = Case.getCaseValue();\n    BasicBlock *CaseDest = Case.getCaseSuccessor();\n\n    // Replace phi operands in successor blocks that are using the constant case\n    // value rather than the switch condition variable:\n    //   switchbb:\n    //   switch i32 %x, label %default [\n    //     i32 17, label %succ\n    //   ...\n    //   succ:\n    //     %r = phi i32 ... [ 17, %switchbb ] ...\n    // -->\n    //     %r = phi i32 ... [ %x, %switchbb ] ...\n\n    for (PHINode &Phi : CaseDest->phis()) {\n      // This only works if there is exactly 1 incoming edge from the switch to\n      // a phi. If there is >1, that means multiple cases of the switch map to 1\n      // value in the phi, and that phi value is not the switch condition. Thus,\n      // this transform would not make sense (the phi would be invalid because\n      // a phi can't have different incoming values from the same block).\n      int SwitchBBIdx = Phi.getBasicBlockIndex(SwitchBlock);\n      if (Phi.getIncomingValue(SwitchBBIdx) == CaseValue &&\n          count(Phi.blocks(), SwitchBlock) == 1) {\n        Phi.setIncomingValue(SwitchBBIdx, SI->getCondition());\n        Changed = true;\n      }\n    }\n\n    // Collect phi nodes that are indirectly using this switch's case constants.\n    int PhiIdx;\n    if (auto *Phi = FindPHIForConditionForwarding(CaseValue, CaseDest, &PhiIdx))\n      ForwardingNodes[Phi].push_back(PhiIdx);\n  }\n\n  for (auto &ForwardingNode : ForwardingNodes) {\n    PHINode *Phi = ForwardingNode.first;\n    SmallVectorImpl<int> &Indexes = ForwardingNode.second;\n    if (Indexes.size() < 2)\n      continue;\n\n    for (int Index : Indexes)\n      Phi->setIncomingValue(Index, SI->getCondition());\n    Changed = true;\n  }\n\n  return Changed;\n}\n\n/// Return true if the backend will be able to handle\n/// initializing an array of constants like C.\nstatic bool ValidLookupTableConstant(Constant *C, const TargetTransformInfo &TTI) {\n  if (C->isThreadDependent())\n    return false;\n  if (C->isDLLImportDependent())\n    return false;\n\n  if (!isa<ConstantFP>(C) && !isa<ConstantInt>(C) &&\n      !isa<ConstantPointerNull>(C) && !isa<GlobalValue>(C) &&\n      !isa<UndefValue>(C) && !isa<ConstantExpr>(C))\n    return false;\n\n  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(C)) {\n    if (!CE->isGEPWithNoNotionalOverIndexing())\n      return false;\n    if (!ValidLookupTableConstant(CE->getOperand(0), TTI))\n      return false;\n  }\n\n  if (!TTI.shouldBuildLookupTablesForConstant(C))\n    return false;\n\n  return true;\n}\n\n/// If V is a Constant, return it. Otherwise, try to look up\n/// its constant value in ConstantPool, returning 0 if it's not there.\nstatic Constant *\nLookupConstant(Value *V,\n               const SmallDenseMap<Value *, Constant *> &ConstantPool) {\n  if (Constant *C = dyn_cast<Constant>(V))\n    return C;\n  return ConstantPool.lookup(V);\n}\n\n/// Try to fold instruction I into a constant. This works for\n/// simple instructions such as binary operations where both operands are\n/// constant or can be replaced by constants from the ConstantPool. Returns the\n/// resulting constant on success, 0 otherwise.\nstatic Constant *\nConstantFold(Instruction *I, const DataLayout &DL,\n             const SmallDenseMap<Value *, Constant *> &ConstantPool) {\n  if (SelectInst *Select = dyn_cast<SelectInst>(I)) {\n    Constant *A = LookupConstant(Select->getCondition(), ConstantPool);\n    if (!A)\n      return nullptr;\n    if (A->isAllOnesValue())\n      return LookupConstant(Select->getTrueValue(), ConstantPool);\n    if (A->isNullValue())\n      return LookupConstant(Select->getFalseValue(), ConstantPool);\n    return nullptr;\n  }\n\n  SmallVector<Constant *, 4> COps;\n  for (unsigned N = 0, E = I->getNumOperands(); N != E; ++N) {\n    if (Constant *A = LookupConstant(I->getOperand(N), ConstantPool))\n      COps.push_back(A);\n    else\n      return nullptr;\n  }\n\n  if (CmpInst *Cmp = dyn_cast<CmpInst>(I)) {\n    return ConstantFoldCompareInstOperands(Cmp->getPredicate(), COps[0],\n                                           COps[1], DL);\n  }\n\n  return ConstantFoldInstOperands(I, COps, DL);\n}\n\n/// Try to determine the resulting constant values in phi nodes\n/// at the common destination basic block, *CommonDest, for one of the case\n/// destionations CaseDest corresponding to value CaseVal (0 for the default\n/// case), of a switch instruction SI.\nstatic bool\nGetCaseResults(SwitchInst *SI, ConstantInt *CaseVal, BasicBlock *CaseDest,\n               BasicBlock **CommonDest,\n               SmallVectorImpl<std::pair<PHINode *, Constant *>> &Res,\n               const DataLayout &DL, const TargetTransformInfo &TTI) {\n  // The block from which we enter the common destination.\n  BasicBlock *Pred = SI->getParent();\n\n  // If CaseDest is empty except for some side-effect free instructions through\n  // which we can constant-propagate the CaseVal, continue to its successor.\n  SmallDenseMap<Value *, Constant *> ConstantPool;\n  ConstantPool.insert(std::make_pair(SI->getCondition(), CaseVal));\n  for (Instruction &I :CaseDest->instructionsWithoutDebug()) {\n    if (I.isTerminator()) {\n      // If the terminator is a simple branch, continue to the next block.\n      if (I.getNumSuccessors() != 1 || I.isExceptionalTerminator())\n        return false;\n      Pred = CaseDest;\n      CaseDest = I.getSuccessor(0);\n    } else if (Constant *C = ConstantFold(&I, DL, ConstantPool)) {\n      // Instruction is side-effect free and constant.\n\n      // If the instruction has uses outside this block or a phi node slot for\n      // the block, it is not safe to bypass the instruction since it would then\n      // no longer dominate all its uses.\n      for (auto &Use : I.uses()) {\n        User *User = Use.getUser();\n        if (Instruction *I = dyn_cast<Instruction>(User))\n          if (I->getParent() == CaseDest)\n            continue;\n        if (PHINode *Phi = dyn_cast<PHINode>(User))\n          if (Phi->getIncomingBlock(Use) == CaseDest)\n            continue;\n        return false;\n      }\n\n      ConstantPool.insert(std::make_pair(&I, C));\n    } else {\n      break;\n    }\n  }\n\n  // If we did not have a CommonDest before, use the current one.\n  if (!*CommonDest)\n    *CommonDest = CaseDest;\n  // If the destination isn't the common one, abort.\n  if (CaseDest != *CommonDest)\n    return false;\n\n  // Get the values for this case from phi nodes in the destination block.\n  for (PHINode &PHI : (*CommonDest)->phis()) {\n    int Idx = PHI.getBasicBlockIndex(Pred);\n    if (Idx == -1)\n      continue;\n\n    Constant *ConstVal =\n        LookupConstant(PHI.getIncomingValue(Idx), ConstantPool);\n    if (!ConstVal)\n      return false;\n\n    // Be conservative about which kinds of constants we support.\n    if (!ValidLookupTableConstant(ConstVal, TTI))\n      return false;\n\n    Res.push_back(std::make_pair(&PHI, ConstVal));\n  }\n\n  return Res.size() > 0;\n}\n\n// Helper function used to add CaseVal to the list of cases that generate\n// Result. Returns the updated number of cases that generate this result.\nstatic uintptr_t MapCaseToResult(ConstantInt *CaseVal,\n                                 SwitchCaseResultVectorTy &UniqueResults,\n                                 Constant *Result) {\n  for (auto &I : UniqueResults) {\n    if (I.first == Result) {\n      I.second.push_back(CaseVal);\n      return I.second.size();\n    }\n  }\n  UniqueResults.push_back(\n      std::make_pair(Result, SmallVector<ConstantInt *, 4>(1, CaseVal)));\n  return 1;\n}\n\n// Helper function that initializes a map containing\n// results for the PHI node of the common destination block for a switch\n// instruction. Returns false if multiple PHI nodes have been found or if\n// there is not a common destination block for the switch.\nstatic bool\nInitializeUniqueCases(SwitchInst *SI, PHINode *&PHI, BasicBlock *&CommonDest,\n                      SwitchCaseResultVectorTy &UniqueResults,\n                      Constant *&DefaultResult, const DataLayout &DL,\n                      const TargetTransformInfo &TTI,\n                      uintptr_t MaxUniqueResults, uintptr_t MaxCasesPerResult) {\n  for (auto &I : SI->cases()) {\n    ConstantInt *CaseVal = I.getCaseValue();\n\n    // Resulting value at phi nodes for this case value.\n    SwitchCaseResultsTy Results;\n    if (!GetCaseResults(SI, CaseVal, I.getCaseSuccessor(), &CommonDest, Results,\n                        DL, TTI))\n      return false;\n\n    // Only one value per case is permitted.\n    if (Results.size() > 1)\n      return false;\n\n    // Add the case->result mapping to UniqueResults.\n    const uintptr_t NumCasesForResult =\n        MapCaseToResult(CaseVal, UniqueResults, Results.begin()->second);\n\n    // Early out if there are too many cases for this result.\n    if (NumCasesForResult > MaxCasesPerResult)\n      return false;\n\n    // Early out if there are too many unique results.\n    if (UniqueResults.size() > MaxUniqueResults)\n      return false;\n\n    // Check the PHI consistency.\n    if (!PHI)\n      PHI = Results[0].first;\n    else if (PHI != Results[0].first)\n      return false;\n  }\n  // Find the default result value.\n  SmallVector<std::pair<PHINode *, Constant *>, 1> DefaultResults;\n  BasicBlock *DefaultDest = SI->getDefaultDest();\n  GetCaseResults(SI, nullptr, SI->getDefaultDest(), &CommonDest, DefaultResults,\n                 DL, TTI);\n  // If the default value is not found abort unless the default destination\n  // is unreachable.\n  DefaultResult =\n      DefaultResults.size() == 1 ? DefaultResults.begin()->second : nullptr;\n  if ((!DefaultResult &&\n       !isa<UnreachableInst>(DefaultDest->getFirstNonPHIOrDbg())))\n    return false;\n\n  return true;\n}\n\n// Helper function that checks if it is possible to transform a switch with only\n// two cases (or two cases + default) that produces a result into a select.\n// Example:\n// switch (a) {\n//   case 10:                %0 = icmp eq i32 %a, 10\n//     return 10;            %1 = select i1 %0, i32 10, i32 4\n//   case 20:        ---->   %2 = icmp eq i32 %a, 20\n//     return 2;             %3 = select i1 %2, i32 2, i32 %1\n//   default:\n//     return 4;\n// }\nstatic Value *ConvertTwoCaseSwitch(const SwitchCaseResultVectorTy &ResultVector,\n                                   Constant *DefaultResult, Value *Condition,\n                                   IRBuilder<> &Builder) {\n  assert(ResultVector.size() == 2 &&\n         \"We should have exactly two unique results at this point\");\n  // If we are selecting between only two cases transform into a simple\n  // select or a two-way select if default is possible.\n  if (ResultVector[0].second.size() == 1 &&\n      ResultVector[1].second.size() == 1) {\n    ConstantInt *const FirstCase = ResultVector[0].second[0];\n    ConstantInt *const SecondCase = ResultVector[1].second[0];\n\n    bool DefaultCanTrigger = DefaultResult;\n    Value *SelectValue = ResultVector[1].first;\n    if (DefaultCanTrigger) {\n      Value *const ValueCompare =\n          Builder.CreateICmpEQ(Condition, SecondCase, \"switch.selectcmp\");\n      SelectValue = Builder.CreateSelect(ValueCompare, ResultVector[1].first,\n                                         DefaultResult, \"switch.select\");\n    }\n    Value *const ValueCompare =\n        Builder.CreateICmpEQ(Condition, FirstCase, \"switch.selectcmp\");\n    return Builder.CreateSelect(ValueCompare, ResultVector[0].first,\n                                SelectValue, \"switch.select\");\n  }\n\n  return nullptr;\n}\n\n// Helper function to cleanup a switch instruction that has been converted into\n// a select, fixing up PHI nodes and basic blocks.\nstatic void RemoveSwitchAfterSelectConversion(SwitchInst *SI, PHINode *PHI,\n                                              Value *SelectValue,\n                                              IRBuilder<> &Builder,\n                                              DomTreeUpdater *DTU) {\n  std::vector<DominatorTree::UpdateType> Updates;\n\n  BasicBlock *SelectBB = SI->getParent();\n  BasicBlock *DestBB = PHI->getParent();\n\n  if (!is_contained(predecessors(DestBB), SelectBB))\n    Updates.push_back({DominatorTree::Insert, SelectBB, DestBB});\n  Builder.CreateBr(DestBB);\n\n  // Remove the switch.\n\n  while (PHI->getBasicBlockIndex(SelectBB) >= 0)\n    PHI->removeIncomingValue(SelectBB);\n  PHI->addIncoming(SelectValue, SelectBB);\n\n  for (unsigned i = 0, e = SI->getNumSuccessors(); i < e; ++i) {\n    BasicBlock *Succ = SI->getSuccessor(i);\n\n    if (Succ == DestBB)\n      continue;\n    Succ->removePredecessor(SelectBB);\n    Updates.push_back({DominatorTree::Delete, SelectBB, Succ});\n  }\n  SI->eraseFromParent();\n  if (DTU)\n    DTU->applyUpdates(Updates);\n}\n\n/// If the switch is only used to initialize one or more\n/// phi nodes in a common successor block with only two different\n/// constant values, replace the switch with select.\nstatic bool switchToSelect(SwitchInst *SI, IRBuilder<> &Builder,\n                           DomTreeUpdater *DTU, const DataLayout &DL,\n                           const TargetTransformInfo &TTI) {\n  Value *const Cond = SI->getCondition();\n  PHINode *PHI = nullptr;\n  BasicBlock *CommonDest = nullptr;\n  Constant *DefaultResult;\n  SwitchCaseResultVectorTy UniqueResults;\n  // Collect all the cases that will deliver the same value from the switch.\n  if (!InitializeUniqueCases(SI, PHI, CommonDest, UniqueResults, DefaultResult,\n                             DL, TTI, 2, 1))\n    return false;\n  // Selects choose between maximum two values.\n  if (UniqueResults.size() != 2)\n    return false;\n  assert(PHI != nullptr && \"PHI for value select not found\");\n\n  Builder.SetInsertPoint(SI);\n  Value *SelectValue =\n      ConvertTwoCaseSwitch(UniqueResults, DefaultResult, Cond, Builder);\n  if (SelectValue) {\n    RemoveSwitchAfterSelectConversion(SI, PHI, SelectValue, Builder, DTU);\n    return true;\n  }\n  // The switch couldn't be converted into a select.\n  return false;\n}\n\nnamespace {\n\n/// This class represents a lookup table that can be used to replace a switch.\nclass SwitchLookupTable {\npublic:\n  /// Create a lookup table to use as a switch replacement with the contents\n  /// of Values, using DefaultValue to fill any holes in the table.\n  SwitchLookupTable(\n      Module &M, uint64_t TableSize, ConstantInt *Offset,\n      const SmallVectorImpl<std::pair<ConstantInt *, Constant *>> &Values,\n      Constant *DefaultValue, const DataLayout &DL, const StringRef &FuncName);\n\n  /// Build instructions with Builder to retrieve the value at\n  /// the position given by Index in the lookup table.\n  Value *BuildLookup(Value *Index, IRBuilder<> &Builder);\n\n  /// Return true if a table with TableSize elements of\n  /// type ElementType would fit in a target-legal register.\n  static bool WouldFitInRegister(const DataLayout &DL, uint64_t TableSize,\n                                 Type *ElementType);\n\nprivate:\n  // Depending on the contents of the table, it can be represented in\n  // different ways.\n  enum {\n    // For tables where each element contains the same value, we just have to\n    // store that single value and return it for each lookup.\n    SingleValueKind,\n\n    // For tables where there is a linear relationship between table index\n    // and values. We calculate the result with a simple multiplication\n    // and addition instead of a table lookup.\n    LinearMapKind,\n\n    // For small tables with integer elements, we can pack them into a bitmap\n    // that fits into a target-legal register. Values are retrieved by\n    // shift and mask operations.\n    BitMapKind,\n\n    // The table is stored as an array of values. Values are retrieved by load\n    // instructions from the table.\n    ArrayKind\n  } Kind;\n\n  // For SingleValueKind, this is the single value.\n  Constant *SingleValue = nullptr;\n\n  // For BitMapKind, this is the bitmap.\n  ConstantInt *BitMap = nullptr;\n  IntegerType *BitMapElementTy = nullptr;\n\n  // For LinearMapKind, these are the constants used to derive the value.\n  ConstantInt *LinearOffset = nullptr;\n  ConstantInt *LinearMultiplier = nullptr;\n\n  // For ArrayKind, this is the array.\n  GlobalVariable *Array = nullptr;\n};\n\n} // end anonymous namespace\n\nSwitchLookupTable::SwitchLookupTable(\n    Module &M, uint64_t TableSize, ConstantInt *Offset,\n    const SmallVectorImpl<std::pair<ConstantInt *, Constant *>> &Values,\n    Constant *DefaultValue, const DataLayout &DL, const StringRef &FuncName) {\n  assert(Values.size() && \"Can't build lookup table without values!\");\n  assert(TableSize >= Values.size() && \"Can't fit values in table!\");\n\n  // If all values in the table are equal, this is that value.\n  SingleValue = Values.begin()->second;\n\n  Type *ValueType = Values.begin()->second->getType();\n\n  // Build up the table contents.\n  SmallVector<Constant *, 64> TableContents(TableSize);\n  for (size_t I = 0, E = Values.size(); I != E; ++I) {\n    ConstantInt *CaseVal = Values[I].first;\n    Constant *CaseRes = Values[I].second;\n    assert(CaseRes->getType() == ValueType);\n\n    uint64_t Idx = (CaseVal->getValue() - Offset->getValue()).getLimitedValue();\n    TableContents[Idx] = CaseRes;\n\n    if (CaseRes != SingleValue)\n      SingleValue = nullptr;\n  }\n\n  // Fill in any holes in the table with the default result.\n  if (Values.size() < TableSize) {\n    assert(DefaultValue &&\n           \"Need a default value to fill the lookup table holes.\");\n    assert(DefaultValue->getType() == ValueType);\n    for (uint64_t I = 0; I < TableSize; ++I) {\n      if (!TableContents[I])\n        TableContents[I] = DefaultValue;\n    }\n\n    if (DefaultValue != SingleValue)\n      SingleValue = nullptr;\n  }\n\n  // If each element in the table contains the same value, we only need to store\n  // that single value.\n  if (SingleValue) {\n    Kind = SingleValueKind;\n    return;\n  }\n\n  // Check if we can derive the value with a linear transformation from the\n  // table index.\n  if (isa<IntegerType>(ValueType)) {\n    bool LinearMappingPossible = true;\n    APInt PrevVal;\n    APInt DistToPrev;\n    assert(TableSize >= 2 && \"Should be a SingleValue table.\");\n    // Check if there is the same distance between two consecutive values.\n    for (uint64_t I = 0; I < TableSize; ++I) {\n      ConstantInt *ConstVal = dyn_cast<ConstantInt>(TableContents[I]);\n      if (!ConstVal) {\n        // This is an undef. We could deal with it, but undefs in lookup tables\n        // are very seldom. It's probably not worth the additional complexity.\n        LinearMappingPossible = false;\n        break;\n      }\n      const APInt &Val = ConstVal->getValue();\n      if (I != 0) {\n        APInt Dist = Val - PrevVal;\n        if (I == 1) {\n          DistToPrev = Dist;\n        } else if (Dist != DistToPrev) {\n          LinearMappingPossible = false;\n          break;\n        }\n      }\n      PrevVal = Val;\n    }\n    if (LinearMappingPossible) {\n      LinearOffset = cast<ConstantInt>(TableContents[0]);\n      LinearMultiplier = ConstantInt::get(M.getContext(), DistToPrev);\n      Kind = LinearMapKind;\n      ++NumLinearMaps;\n      return;\n    }\n  }\n\n  // If the type is integer and the table fits in a register, build a bitmap.\n  if (WouldFitInRegister(DL, TableSize, ValueType)) {\n    IntegerType *IT = cast<IntegerType>(ValueType);\n    APInt TableInt(TableSize * IT->getBitWidth(), 0);\n    for (uint64_t I = TableSize; I > 0; --I) {\n      TableInt <<= IT->getBitWidth();\n      // Insert values into the bitmap. Undef values are set to zero.\n      if (!isa<UndefValue>(TableContents[I - 1])) {\n        ConstantInt *Val = cast<ConstantInt>(TableContents[I - 1]);\n        TableInt |= Val->getValue().zext(TableInt.getBitWidth());\n      }\n    }\n    BitMap = ConstantInt::get(M.getContext(), TableInt);\n    BitMapElementTy = IT;\n    Kind = BitMapKind;\n    ++NumBitMaps;\n    return;\n  }\n\n  // Store the table in an array.\n  ArrayType *ArrayTy = ArrayType::get(ValueType, TableSize);\n  Constant *Initializer = ConstantArray::get(ArrayTy, TableContents);\n\n  Array = new GlobalVariable(M, ArrayTy, /*isConstant=*/true,\n                             GlobalVariable::PrivateLinkage, Initializer,\n                             \"switch.table.\" + FuncName);\n  Array->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);\n  // Set the alignment to that of an array items. We will be only loading one\n  // value out of it.\n  Array->setAlignment(Align(DL.getPrefTypeAlignment(ValueType)));\n  Kind = ArrayKind;\n}\n\nValue *SwitchLookupTable::BuildLookup(Value *Index, IRBuilder<> &Builder) {\n  switch (Kind) {\n  case SingleValueKind:\n    return SingleValue;\n  case LinearMapKind: {\n    // Derive the result value from the input value.\n    Value *Result = Builder.CreateIntCast(Index, LinearMultiplier->getType(),\n                                          false, \"switch.idx.cast\");\n    if (!LinearMultiplier->isOne())\n      Result = Builder.CreateMul(Result, LinearMultiplier, \"switch.idx.mult\");\n    if (!LinearOffset->isZero())\n      Result = Builder.CreateAdd(Result, LinearOffset, \"switch.offset\");\n    return Result;\n  }\n  case BitMapKind: {\n    // Type of the bitmap (e.g. i59).\n    IntegerType *MapTy = BitMap->getType();\n\n    // Cast Index to the same type as the bitmap.\n    // Note: The Index is <= the number of elements in the table, so\n    // truncating it to the width of the bitmask is safe.\n    Value *ShiftAmt = Builder.CreateZExtOrTrunc(Index, MapTy, \"switch.cast\");\n\n    // Multiply the shift amount by the element width.\n    ShiftAmt = Builder.CreateMul(\n        ShiftAmt, ConstantInt::get(MapTy, BitMapElementTy->getBitWidth()),\n        \"switch.shiftamt\");\n\n    // Shift down.\n    Value *DownShifted =\n        Builder.CreateLShr(BitMap, ShiftAmt, \"switch.downshift\");\n    // Mask off.\n    return Builder.CreateTrunc(DownShifted, BitMapElementTy, \"switch.masked\");\n  }\n  case ArrayKind: {\n    // Make sure the table index will not overflow when treated as signed.\n    IntegerType *IT = cast<IntegerType>(Index->getType());\n    uint64_t TableSize =\n        Array->getInitializer()->getType()->getArrayNumElements();\n    if (TableSize > (1ULL << (IT->getBitWidth() - 1)))\n      Index = Builder.CreateZExt(\n          Index, IntegerType::get(IT->getContext(), IT->getBitWidth() + 1),\n          \"switch.tableidx.zext\");\n\n    Value *GEPIndices[] = {Builder.getInt32(0), Index};\n    Value *GEP = Builder.CreateInBoundsGEP(Array->getValueType(), Array,\n                                           GEPIndices, \"switch.gep\");\n    return Builder.CreateLoad(\n        cast<ArrayType>(Array->getValueType())->getElementType(), GEP,\n        \"switch.load\");\n  }\n  }\n  llvm_unreachable(\"Unknown lookup table kind!\");\n}\n\nbool SwitchLookupTable::WouldFitInRegister(const DataLayout &DL,\n                                           uint64_t TableSize,\n                                           Type *ElementType) {\n  auto *IT = dyn_cast<IntegerType>(ElementType);\n  if (!IT)\n    return false;\n  // FIXME: If the type is wider than it needs to be, e.g. i8 but all values\n  // are <= 15, we could try to narrow the type.\n\n  // Avoid overflow, fitsInLegalInteger uses unsigned int for the width.\n  if (TableSize >= UINT_MAX / IT->getBitWidth())\n    return false;\n  return DL.fitsInLegalInteger(TableSize * IT->getBitWidth());\n}\n\n/// Determine whether a lookup table should be built for this switch, based on\n/// the number of cases, size of the table, and the types of the results.\nstatic bool\nShouldBuildLookupTable(SwitchInst *SI, uint64_t TableSize,\n                       const TargetTransformInfo &TTI, const DataLayout &DL,\n                       const SmallDenseMap<PHINode *, Type *> &ResultTypes) {\n  if (SI->getNumCases() > TableSize || TableSize >= UINT64_MAX / 10)\n    return false; // TableSize overflowed, or mul below might overflow.\n\n  bool AllTablesFitInRegister = true;\n  bool HasIllegalType = false;\n  for (const auto &I : ResultTypes) {\n    Type *Ty = I.second;\n\n    // Saturate this flag to true.\n    HasIllegalType = HasIllegalType || !TTI.isTypeLegal(Ty);\n\n    // Saturate this flag to false.\n    AllTablesFitInRegister =\n        AllTablesFitInRegister &&\n        SwitchLookupTable::WouldFitInRegister(DL, TableSize, Ty);\n\n    // If both flags saturate, we're done. NOTE: This *only* works with\n    // saturating flags, and all flags have to saturate first due to the\n    // non-deterministic behavior of iterating over a dense map.\n    if (HasIllegalType && !AllTablesFitInRegister)\n      break;\n  }\n\n  // If each table would fit in a register, we should build it anyway.\n  if (AllTablesFitInRegister)\n    return true;\n\n  // Don't build a table that doesn't fit in-register if it has illegal types.\n  if (HasIllegalType)\n    return false;\n\n  // The table density should be at least 40%. This is the same criterion as for\n  // jump tables, see SelectionDAGBuilder::handleJTSwitchCase.\n  // FIXME: Find the best cut-off.\n  return SI->getNumCases() * 10 >= TableSize * 4;\n}\n\n/// Try to reuse the switch table index compare. Following pattern:\n/// \\code\n///     if (idx < tablesize)\n///        r = table[idx]; // table does not contain default_value\n///     else\n///        r = default_value;\n///     if (r != default_value)\n///        ...\n/// \\endcode\n/// Is optimized to:\n/// \\code\n///     cond = idx < tablesize;\n///     if (cond)\n///        r = table[idx];\n///     else\n///        r = default_value;\n///     if (cond)\n///        ...\n/// \\endcode\n/// Jump threading will then eliminate the second if(cond).\nstatic void reuseTableCompare(\n    User *PhiUser, BasicBlock *PhiBlock, BranchInst *RangeCheckBranch,\n    Constant *DefaultValue,\n    const SmallVectorImpl<std::pair<ConstantInt *, Constant *>> &Values) {\n  ICmpInst *CmpInst = dyn_cast<ICmpInst>(PhiUser);\n  if (!CmpInst)\n    return;\n\n  // We require that the compare is in the same block as the phi so that jump\n  // threading can do its work afterwards.\n  if (CmpInst->getParent() != PhiBlock)\n    return;\n\n  Constant *CmpOp1 = dyn_cast<Constant>(CmpInst->getOperand(1));\n  if (!CmpOp1)\n    return;\n\n  Value *RangeCmp = RangeCheckBranch->getCondition();\n  Constant *TrueConst = ConstantInt::getTrue(RangeCmp->getType());\n  Constant *FalseConst = ConstantInt::getFalse(RangeCmp->getType());\n\n  // Check if the compare with the default value is constant true or false.\n  Constant *DefaultConst = ConstantExpr::getICmp(CmpInst->getPredicate(),\n                                                 DefaultValue, CmpOp1, true);\n  if (DefaultConst != TrueConst && DefaultConst != FalseConst)\n    return;\n\n  // Check if the compare with the case values is distinct from the default\n  // compare result.\n  for (auto ValuePair : Values) {\n    Constant *CaseConst = ConstantExpr::getICmp(CmpInst->getPredicate(),\n                                                ValuePair.second, CmpOp1, true);\n    if (!CaseConst || CaseConst == DefaultConst || isa<UndefValue>(CaseConst))\n      return;\n    assert((CaseConst == TrueConst || CaseConst == FalseConst) &&\n           \"Expect true or false as compare result.\");\n  }\n\n  // Check if the branch instruction dominates the phi node. It's a simple\n  // dominance check, but sufficient for our needs.\n  // Although this check is invariant in the calling loops, it's better to do it\n  // at this late stage. Practically we do it at most once for a switch.\n  BasicBlock *BranchBlock = RangeCheckBranch->getParent();\n  for (BasicBlock *Pred : predecessors(PhiBlock)) {\n    if (Pred != BranchBlock && Pred->getUniquePredecessor() != BranchBlock)\n      return;\n  }\n\n  if (DefaultConst == FalseConst) {\n    // The compare yields the same result. We can replace it.\n    CmpInst->replaceAllUsesWith(RangeCmp);\n    ++NumTableCmpReuses;\n  } else {\n    // The compare yields the same result, just inverted. We can replace it.\n    Value *InvertedTableCmp = BinaryOperator::CreateXor(\n        RangeCmp, ConstantInt::get(RangeCmp->getType(), 1), \"inverted.cmp\",\n        RangeCheckBranch);\n    CmpInst->replaceAllUsesWith(InvertedTableCmp);\n    ++NumTableCmpReuses;\n  }\n}\n\n/// If the switch is only used to initialize one or more phi nodes in a common\n/// successor block with different constant values, replace the switch with\n/// lookup tables.\nstatic bool SwitchToLookupTable(SwitchInst *SI, IRBuilder<> &Builder,\n                                DomTreeUpdater *DTU, const DataLayout &DL,\n                                const TargetTransformInfo &TTI) {\n  assert(SI->getNumCases() > 1 && \"Degenerate switch?\");\n\n  BasicBlock *BB = SI->getParent();\n  Function *Fn = BB->getParent();\n  // Only build lookup table when we have a target that supports it or the\n  // attribute is not set.\n  if (!TTI.shouldBuildLookupTables() ||\n      (Fn->getFnAttribute(\"no-jump-tables\").getValueAsString() == \"true\"))\n    return false;\n\n  // FIXME: If the switch is too sparse for a lookup table, perhaps we could\n  // split off a dense part and build a lookup table for that.\n\n  // FIXME: This creates arrays of GEPs to constant strings, which means each\n  // GEP needs a runtime relocation in PIC code. We should just build one big\n  // string and lookup indices into that.\n\n  // Ignore switches with less than three cases. Lookup tables will not make\n  // them faster, so we don't analyze them.\n  if (SI->getNumCases() < 3)\n    return false;\n\n  // Figure out the corresponding result for each case value and phi node in the\n  // common destination, as well as the min and max case values.\n  assert(!SI->cases().empty());\n  SwitchInst::CaseIt CI = SI->case_begin();\n  ConstantInt *MinCaseVal = CI->getCaseValue();\n  ConstantInt *MaxCaseVal = CI->getCaseValue();\n\n  BasicBlock *CommonDest = nullptr;\n\n  using ResultListTy = SmallVector<std::pair<ConstantInt *, Constant *>, 4>;\n  SmallDenseMap<PHINode *, ResultListTy> ResultLists;\n\n  SmallDenseMap<PHINode *, Constant *> DefaultResults;\n  SmallDenseMap<PHINode *, Type *> ResultTypes;\n  SmallVector<PHINode *, 4> PHIs;\n\n  for (SwitchInst::CaseIt E = SI->case_end(); CI != E; ++CI) {\n    ConstantInt *CaseVal = CI->getCaseValue();\n    if (CaseVal->getValue().slt(MinCaseVal->getValue()))\n      MinCaseVal = CaseVal;\n    if (CaseVal->getValue().sgt(MaxCaseVal->getValue()))\n      MaxCaseVal = CaseVal;\n\n    // Resulting value at phi nodes for this case value.\n    using ResultsTy = SmallVector<std::pair<PHINode *, Constant *>, 4>;\n    ResultsTy Results;\n    if (!GetCaseResults(SI, CaseVal, CI->getCaseSuccessor(), &CommonDest,\n                        Results, DL, TTI))\n      return false;\n\n    // Append the result from this case to the list for each phi.\n    for (const auto &I : Results) {\n      PHINode *PHI = I.first;\n      Constant *Value = I.second;\n      if (!ResultLists.count(PHI))\n        PHIs.push_back(PHI);\n      ResultLists[PHI].push_back(std::make_pair(CaseVal, Value));\n    }\n  }\n\n  // Keep track of the result types.\n  for (PHINode *PHI : PHIs) {\n    ResultTypes[PHI] = ResultLists[PHI][0].second->getType();\n  }\n\n  uint64_t NumResults = ResultLists[PHIs[0]].size();\n  APInt RangeSpread = MaxCaseVal->getValue() - MinCaseVal->getValue();\n  uint64_t TableSize = RangeSpread.getLimitedValue() + 1;\n  bool TableHasHoles = (NumResults < TableSize);\n\n  // If the table has holes, we need a constant result for the default case\n  // or a bitmask that fits in a register.\n  SmallVector<std::pair<PHINode *, Constant *>, 4> DefaultResultsList;\n  bool HasDefaultResults =\n      GetCaseResults(SI, nullptr, SI->getDefaultDest(), &CommonDest,\n                     DefaultResultsList, DL, TTI);\n\n  bool NeedMask = (TableHasHoles && !HasDefaultResults);\n  if (NeedMask) {\n    // As an extra penalty for the validity test we require more cases.\n    if (SI->getNumCases() < 4) // FIXME: Find best threshold value (benchmark).\n      return false;\n    if (!DL.fitsInLegalInteger(TableSize))\n      return false;\n  }\n\n  for (const auto &I : DefaultResultsList) {\n    PHINode *PHI = I.first;\n    Constant *Result = I.second;\n    DefaultResults[PHI] = Result;\n  }\n\n  if (!ShouldBuildLookupTable(SI, TableSize, TTI, DL, ResultTypes))\n    return false;\n\n  std::vector<DominatorTree::UpdateType> Updates;\n\n  // Create the BB that does the lookups.\n  Module &Mod = *CommonDest->getParent()->getParent();\n  BasicBlock *LookupBB = BasicBlock::Create(\n      Mod.getContext(), \"switch.lookup\", CommonDest->getParent(), CommonDest);\n\n  // Compute the table index value.\n  Builder.SetInsertPoint(SI);\n  Value *TableIndex;\n  if (MinCaseVal->isNullValue())\n    TableIndex = SI->getCondition();\n  else\n    TableIndex = Builder.CreateSub(SI->getCondition(), MinCaseVal,\n                                   \"switch.tableidx\");\n\n  // Compute the maximum table size representable by the integer type we are\n  // switching upon.\n  unsigned CaseSize = MinCaseVal->getType()->getPrimitiveSizeInBits();\n  uint64_t MaxTableSize = CaseSize > 63 ? UINT64_MAX : 1ULL << CaseSize;\n  assert(MaxTableSize >= TableSize &&\n         \"It is impossible for a switch to have more entries than the max \"\n         \"representable value of its input integer type's size.\");\n\n  // If the default destination is unreachable, or if the lookup table covers\n  // all values of the conditional variable, branch directly to the lookup table\n  // BB. Otherwise, check that the condition is within the case range.\n  const bool DefaultIsReachable =\n      !isa<UnreachableInst>(SI->getDefaultDest()->getFirstNonPHIOrDbg());\n  const bool GeneratingCoveredLookupTable = (MaxTableSize == TableSize);\n  BranchInst *RangeCheckBranch = nullptr;\n\n  if (!DefaultIsReachable || GeneratingCoveredLookupTable) {\n    Builder.CreateBr(LookupBB);\n    Updates.push_back({DominatorTree::Insert, BB, LookupBB});\n    // Note: We call removeProdecessor later since we need to be able to get the\n    // PHI value for the default case in case we're using a bit mask.\n  } else {\n    Value *Cmp = Builder.CreateICmpULT(\n        TableIndex, ConstantInt::get(MinCaseVal->getType(), TableSize));\n    RangeCheckBranch =\n        Builder.CreateCondBr(Cmp, LookupBB, SI->getDefaultDest());\n    Updates.push_back({DominatorTree::Insert, BB, LookupBB});\n  }\n\n  // Populate the BB that does the lookups.\n  Builder.SetInsertPoint(LookupBB);\n\n  if (NeedMask) {\n    // Before doing the lookup, we do the hole check. The LookupBB is therefore\n    // re-purposed to do the hole check, and we create a new LookupBB.\n    BasicBlock *MaskBB = LookupBB;\n    MaskBB->setName(\"switch.hole_check\");\n    LookupBB = BasicBlock::Create(Mod.getContext(), \"switch.lookup\",\n                                  CommonDest->getParent(), CommonDest);\n\n    // Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid\n    // unnecessary illegal types.\n    uint64_t TableSizePowOf2 = NextPowerOf2(std::max(7ULL, TableSize - 1ULL));\n    APInt MaskInt(TableSizePowOf2, 0);\n    APInt One(TableSizePowOf2, 1);\n    // Build bitmask; fill in a 1 bit for every case.\n    const ResultListTy &ResultList = ResultLists[PHIs[0]];\n    for (size_t I = 0, E = ResultList.size(); I != E; ++I) {\n      uint64_t Idx = (ResultList[I].first->getValue() - MinCaseVal->getValue())\n                         .getLimitedValue();\n      MaskInt |= One << Idx;\n    }\n    ConstantInt *TableMask = ConstantInt::get(Mod.getContext(), MaskInt);\n\n    // Get the TableIndex'th bit of the bitmask.\n    // If this bit is 0 (meaning hole) jump to the default destination,\n    // else continue with table lookup.\n    IntegerType *MapTy = TableMask->getType();\n    Value *MaskIndex =\n        Builder.CreateZExtOrTrunc(TableIndex, MapTy, \"switch.maskindex\");\n    Value *Shifted = Builder.CreateLShr(TableMask, MaskIndex, \"switch.shifted\");\n    Value *LoBit = Builder.CreateTrunc(\n        Shifted, Type::getInt1Ty(Mod.getContext()), \"switch.lobit\");\n    Builder.CreateCondBr(LoBit, LookupBB, SI->getDefaultDest());\n    Updates.push_back({DominatorTree::Insert, MaskBB, LookupBB});\n    Updates.push_back({DominatorTree::Insert, MaskBB, SI->getDefaultDest()});\n    Builder.SetInsertPoint(LookupBB);\n    AddPredecessorToBlock(SI->getDefaultDest(), MaskBB, BB);\n  }\n\n  if (!DefaultIsReachable || GeneratingCoveredLookupTable) {\n    // We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,\n    // do not delete PHINodes here.\n    SI->getDefaultDest()->removePredecessor(BB,\n                                            /*KeepOneInputPHIs=*/true);\n    Updates.push_back({DominatorTree::Delete, BB, SI->getDefaultDest()});\n  }\n\n  bool ReturnedEarly = false;\n  for (PHINode *PHI : PHIs) {\n    const ResultListTy &ResultList = ResultLists[PHI];\n\n    // If using a bitmask, use any value to fill the lookup table holes.\n    Constant *DV = NeedMask ? ResultLists[PHI][0].second : DefaultResults[PHI];\n    StringRef FuncName = Fn->getName();\n    SwitchLookupTable Table(Mod, TableSize, MinCaseVal, ResultList, DV, DL,\n                            FuncName);\n\n    Value *Result = Table.BuildLookup(TableIndex, Builder);\n\n    // If the result is used to return immediately from the function, we want to\n    // do that right here.\n    if (PHI->hasOneUse() && isa<ReturnInst>(*PHI->user_begin()) &&\n        PHI->user_back() == CommonDest->getFirstNonPHIOrDbg()) {\n      Builder.CreateRet(Result);\n      ReturnedEarly = true;\n      break;\n    }\n\n    // Do a small peephole optimization: re-use the switch table compare if\n    // possible.\n    if (!TableHasHoles && HasDefaultResults && RangeCheckBranch) {\n      BasicBlock *PhiBlock = PHI->getParent();\n      // Search for compare instructions which use the phi.\n      for (auto *User : PHI->users()) {\n        reuseTableCompare(User, PhiBlock, RangeCheckBranch, DV, ResultList);\n      }\n    }\n\n    PHI->addIncoming(Result, LookupBB);\n  }\n\n  if (!ReturnedEarly) {\n    Builder.CreateBr(CommonDest);\n    Updates.push_back({DominatorTree::Insert, LookupBB, CommonDest});\n  }\n\n  // Remove the switch.\n  SmallSetVector<BasicBlock *, 8> RemovedSuccessors;\n  for (unsigned i = 0, e = SI->getNumSuccessors(); i < e; ++i) {\n    BasicBlock *Succ = SI->getSuccessor(i);\n\n    if (Succ == SI->getDefaultDest())\n      continue;\n    Succ->removePredecessor(BB);\n    RemovedSuccessors.insert(Succ);\n  }\n  SI->eraseFromParent();\n\n  if (DTU) {\n    for (BasicBlock *RemovedSuccessor : RemovedSuccessors)\n      Updates.push_back({DominatorTree::Delete, BB, RemovedSuccessor});\n    DTU->applyUpdates(Updates);\n  }\n\n  ++NumLookupTables;\n  if (NeedMask)\n    ++NumLookupTablesHoles;\n  return true;\n}\n\nstatic bool isSwitchDense(ArrayRef<int64_t> Values) {\n  // See also SelectionDAGBuilder::isDense(), which this function was based on.\n  uint64_t Diff = (uint64_t)Values.back() - (uint64_t)Values.front();\n  uint64_t Range = Diff + 1;\n  uint64_t NumCases = Values.size();\n  // 40% is the default density for building a jump table in optsize/minsize mode.\n  uint64_t MinDensity = 40;\n\n  return NumCases * 100 >= Range * MinDensity;\n}\n\n/// Try to transform a switch that has \"holes\" in it to a contiguous sequence\n/// of cases.\n///\n/// A switch such as: switch(i) {case 5: case 9: case 13: case 17:} can be\n/// range-reduced to: switch ((i-5) / 4) {case 0: case 1: case 2: case 3:}.\n///\n/// This converts a sparse switch into a dense switch which allows better\n/// lowering and could also allow transforming into a lookup table.\nstatic bool ReduceSwitchRange(SwitchInst *SI, IRBuilder<> &Builder,\n                              const DataLayout &DL,\n                              const TargetTransformInfo &TTI) {\n  auto *CondTy = cast<IntegerType>(SI->getCondition()->getType());\n  if (CondTy->getIntegerBitWidth() > 64 ||\n      !DL.fitsInLegalInteger(CondTy->getIntegerBitWidth()))\n    return false;\n  // Only bother with this optimization if there are more than 3 switch cases;\n  // SDAG will only bother creating jump tables for 4 or more cases.\n  if (SI->getNumCases() < 4)\n    return false;\n\n  // This transform is agnostic to the signedness of the input or case values. We\n  // can treat the case values as signed or unsigned. We can optimize more common\n  // cases such as a sequence crossing zero {-4,0,4,8} if we interpret case values\n  // as signed.\n  SmallVector<int64_t,4> Values;\n  for (auto &C : SI->cases())\n    Values.push_back(C.getCaseValue()->getValue().getSExtValue());\n  llvm::sort(Values);\n\n  // If the switch is already dense, there's nothing useful to do here.\n  if (isSwitchDense(Values))\n    return false;\n\n  // First, transform the values such that they start at zero and ascend.\n  int64_t Base = Values[0];\n  for (auto &V : Values)\n    V -= (uint64_t)(Base);\n\n  // Now we have signed numbers that have been shifted so that, given enough\n  // precision, there are no negative values. Since the rest of the transform\n  // is bitwise only, we switch now to an unsigned representation.\n\n  // This transform can be done speculatively because it is so cheap - it\n  // results in a single rotate operation being inserted.\n  // FIXME: It's possible that optimizing a switch on powers of two might also\n  // be beneficial - flag values are often powers of two and we could use a CLZ\n  // as the key function.\n\n  // countTrailingZeros(0) returns 64. As Values is guaranteed to have more than\n  // one element and LLVM disallows duplicate cases, Shift is guaranteed to be\n  // less than 64.\n  unsigned Shift = 64;\n  for (auto &V : Values)\n    Shift = std::min(Shift, countTrailingZeros((uint64_t)V));\n  assert(Shift < 64);\n  if (Shift > 0)\n    for (auto &V : Values)\n      V = (int64_t)((uint64_t)V >> Shift);\n\n  if (!isSwitchDense(Values))\n    // Transform didn't create a dense switch.\n    return false;\n\n  // The obvious transform is to shift the switch condition right and emit a\n  // check that the condition actually cleanly divided by GCD, i.e.\n  //   C & (1 << Shift - 1) == 0\n  // inserting a new CFG edge to handle the case where it didn't divide cleanly.\n  //\n  // A cheaper way of doing this is a simple ROTR(C, Shift). This performs the\n  // shift and puts the shifted-off bits in the uppermost bits. If any of these\n  // are nonzero then the switch condition will be very large and will hit the\n  // default case.\n\n  auto *Ty = cast<IntegerType>(SI->getCondition()->getType());\n  Builder.SetInsertPoint(SI);\n  auto *ShiftC = ConstantInt::get(Ty, Shift);\n  auto *Sub = Builder.CreateSub(SI->getCondition(), ConstantInt::get(Ty, Base));\n  auto *LShr = Builder.CreateLShr(Sub, ShiftC);\n  auto *Shl = Builder.CreateShl(Sub, Ty->getBitWidth() - Shift);\n  auto *Rot = Builder.CreateOr(LShr, Shl);\n  SI->replaceUsesOfWith(SI->getCondition(), Rot);\n\n  for (auto Case : SI->cases()) {\n    auto *Orig = Case.getCaseValue();\n    auto Sub = Orig->getValue() - APInt(Ty->getBitWidth(), Base);\n    Case.setValue(\n        cast<ConstantInt>(ConstantInt::get(Ty, Sub.lshr(ShiftC->getValue()))));\n  }\n  return true;\n}\n\nbool SimplifyCFGOpt::simplifySwitch(SwitchInst *SI, IRBuilder<> &Builder) {\n  BasicBlock *BB = SI->getParent();\n\n  if (isValueEqualityComparison(SI)) {\n    // If we only have one predecessor, and if it is a branch on this value,\n    // see if that predecessor totally determines the outcome of this switch.\n    if (BasicBlock *OnlyPred = BB->getSinglePredecessor())\n      if (SimplifyEqualityComparisonWithOnlyPredecessor(SI, OnlyPred, Builder))\n        return requestResimplify();\n\n    Value *Cond = SI->getCondition();\n    if (SelectInst *Select = dyn_cast<SelectInst>(Cond))\n      if (SimplifySwitchOnSelect(SI, Select))\n        return requestResimplify();\n\n    // If the block only contains the switch, see if we can fold the block\n    // away into any preds.\n    if (SI == &*BB->instructionsWithoutDebug().begin())\n      if (FoldValueComparisonIntoPredecessors(SI, Builder))\n        return requestResimplify();\n  }\n\n  // Try to transform the switch into an icmp and a branch.\n  if (TurnSwitchRangeIntoICmp(SI, Builder))\n    return requestResimplify();\n\n  // Remove unreachable cases.\n  if (eliminateDeadSwitchCases(SI, DTU, Options.AC, DL))\n    return requestResimplify();\n\n  if (switchToSelect(SI, Builder, DTU, DL, TTI))\n    return requestResimplify();\n\n  if (Options.ForwardSwitchCondToPhi && ForwardSwitchConditionToPHI(SI))\n    return requestResimplify();\n\n  // The conversion from switch to lookup tables results in difficult-to-analyze\n  // code and makes pruning branches much harder. This is a problem if the\n  // switch expression itself can still be restricted as a result of inlining or\n  // CVP. Therefore, only apply this transformation during late stages of the\n  // optimisation pipeline.\n  if (Options.ConvertSwitchToLookupTable &&\n      SwitchToLookupTable(SI, Builder, DTU, DL, TTI))\n    return requestResimplify();\n\n  if (ReduceSwitchRange(SI, Builder, DL, TTI))\n    return requestResimplify();\n\n  return false;\n}\n\nbool SimplifyCFGOpt::simplifyIndirectBr(IndirectBrInst *IBI) {\n  BasicBlock *BB = IBI->getParent();\n  bool Changed = false;\n\n  // Eliminate redundant destinations.\n  SmallPtrSet<Value *, 8> Succs;\n  SmallSetVector<BasicBlock *, 8> RemovedSuccs;\n  for (unsigned i = 0, e = IBI->getNumDestinations(); i != e; ++i) {\n    BasicBlock *Dest = IBI->getDestination(i);\n    if (!Dest->hasAddressTaken() || !Succs.insert(Dest).second) {\n      if (!Dest->hasAddressTaken())\n        RemovedSuccs.insert(Dest);\n      Dest->removePredecessor(BB);\n      IBI->removeDestination(i);\n      --i;\n      --e;\n      Changed = true;\n    }\n  }\n\n  if (DTU) {\n    std::vector<DominatorTree::UpdateType> Updates;\n    Updates.reserve(RemovedSuccs.size());\n    for (auto *RemovedSucc : RemovedSuccs)\n      Updates.push_back({DominatorTree::Delete, BB, RemovedSucc});\n    DTU->applyUpdates(Updates);\n  }\n\n  if (IBI->getNumDestinations() == 0) {\n    // If the indirectbr has no successors, change it to unreachable.\n    new UnreachableInst(IBI->getContext(), IBI);\n    EraseTerminatorAndDCECond(IBI);\n    return true;\n  }\n\n  if (IBI->getNumDestinations() == 1) {\n    // If the indirectbr has one successor, change it to a direct branch.\n    BranchInst::Create(IBI->getDestination(0), IBI);\n    EraseTerminatorAndDCECond(IBI);\n    return true;\n  }\n\n  if (SelectInst *SI = dyn_cast<SelectInst>(IBI->getAddress())) {\n    if (SimplifyIndirectBrOnSelect(IBI, SI))\n      return requestResimplify();\n  }\n  return Changed;\n}\n\n/// Given an block with only a single landing pad and a unconditional branch\n/// try to find another basic block which this one can be merged with.  This\n/// handles cases where we have multiple invokes with unique landing pads, but\n/// a shared handler.\n///\n/// We specifically choose to not worry about merging non-empty blocks\n/// here.  That is a PRE/scheduling problem and is best solved elsewhere.  In\n/// practice, the optimizer produces empty landing pad blocks quite frequently\n/// when dealing with exception dense code.  (see: instcombine, gvn, if-else\n/// sinking in this file)\n///\n/// This is primarily a code size optimization.  We need to avoid performing\n/// any transform which might inhibit optimization (such as our ability to\n/// specialize a particular handler via tail commoning).  We do this by not\n/// merging any blocks which require us to introduce a phi.  Since the same\n/// values are flowing through both blocks, we don't lose any ability to\n/// specialize.  If anything, we make such specialization more likely.\n///\n/// TODO - This transformation could remove entries from a phi in the target\n/// block when the inputs in the phi are the same for the two blocks being\n/// merged.  In some cases, this could result in removal of the PHI entirely.\nstatic bool TryToMergeLandingPad(LandingPadInst *LPad, BranchInst *BI,\n                                 BasicBlock *BB, DomTreeUpdater *DTU) {\n  auto Succ = BB->getUniqueSuccessor();\n  assert(Succ);\n  // If there's a phi in the successor block, we'd likely have to introduce\n  // a phi into the merged landing pad block.\n  if (isa<PHINode>(*Succ->begin()))\n    return false;\n\n  for (BasicBlock *OtherPred : predecessors(Succ)) {\n    if (BB == OtherPred)\n      continue;\n    BasicBlock::iterator I = OtherPred->begin();\n    LandingPadInst *LPad2 = dyn_cast<LandingPadInst>(I);\n    if (!LPad2 || !LPad2->isIdenticalTo(LPad))\n      continue;\n    for (++I; isa<DbgInfoIntrinsic>(I); ++I)\n      ;\n    BranchInst *BI2 = dyn_cast<BranchInst>(I);\n    if (!BI2 || !BI2->isIdenticalTo(BI))\n      continue;\n\n    std::vector<DominatorTree::UpdateType> Updates;\n\n    // We've found an identical block.  Update our predecessors to take that\n    // path instead and make ourselves dead.\n    SmallPtrSet<BasicBlock *, 16> Preds;\n    Preds.insert(pred_begin(BB), pred_end(BB));\n    for (BasicBlock *Pred : Preds) {\n      InvokeInst *II = cast<InvokeInst>(Pred->getTerminator());\n      assert(II->getNormalDest() != BB && II->getUnwindDest() == BB &&\n             \"unexpected successor\");\n      II->setUnwindDest(OtherPred);\n      Updates.push_back({DominatorTree::Insert, Pred, OtherPred});\n      Updates.push_back({DominatorTree::Delete, Pred, BB});\n    }\n\n    // The debug info in OtherPred doesn't cover the merged control flow that\n    // used to go through BB.  We need to delete it or update it.\n    for (auto I = OtherPred->begin(), E = OtherPred->end(); I != E;) {\n      Instruction &Inst = *I;\n      I++;\n      if (isa<DbgInfoIntrinsic>(Inst))\n        Inst.eraseFromParent();\n    }\n\n    SmallPtrSet<BasicBlock *, 16> Succs;\n    Succs.insert(succ_begin(BB), succ_end(BB));\n    for (BasicBlock *Succ : Succs) {\n      Succ->removePredecessor(BB);\n      Updates.push_back({DominatorTree::Delete, BB, Succ});\n    }\n\n    IRBuilder<> Builder(BI);\n    Builder.CreateUnreachable();\n    BI->eraseFromParent();\n    if (DTU)\n      DTU->applyUpdates(Updates);\n    return true;\n  }\n  return false;\n}\n\nbool SimplifyCFGOpt::simplifyBranch(BranchInst *Branch, IRBuilder<> &Builder) {\n  return Branch->isUnconditional() ? simplifyUncondBranch(Branch, Builder)\n                                   : simplifyCondBranch(Branch, Builder);\n}\n\nbool SimplifyCFGOpt::simplifyUncondBranch(BranchInst *BI,\n                                          IRBuilder<> &Builder) {\n  BasicBlock *BB = BI->getParent();\n  BasicBlock *Succ = BI->getSuccessor(0);\n\n  // If the Terminator is the only non-phi instruction, simplify the block.\n  // If LoopHeader is provided, check if the block or its successor is a loop\n  // header. (This is for early invocations before loop simplify and\n  // vectorization to keep canonical loop forms for nested loops. These blocks\n  // can be eliminated when the pass is invoked later in the back-end.)\n  // Note that if BB has only one predecessor then we do not introduce new\n  // backedge, so we can eliminate BB.\n  bool NeedCanonicalLoop =\n      Options.NeedCanonicalLoop &&\n      (!LoopHeaders.empty() && BB->hasNPredecessorsOrMore(2) &&\n       (is_contained(LoopHeaders, BB) || is_contained(LoopHeaders, Succ)));\n  BasicBlock::iterator I = BB->getFirstNonPHIOrDbg(true)->getIterator();\n  if (I->isTerminator() && BB != &BB->getParent()->getEntryBlock() &&\n      !NeedCanonicalLoop && TryToSimplifyUncondBranchFromEmptyBlock(BB, DTU))\n    return true;\n\n  // If the only instruction in the block is a seteq/setne comparison against a\n  // constant, try to simplify the block.\n  if (ICmpInst *ICI = dyn_cast<ICmpInst>(I))\n    if (ICI->isEquality() && isa<ConstantInt>(ICI->getOperand(1))) {\n      for (++I; isa<DbgInfoIntrinsic>(I); ++I)\n        ;\n      if (I->isTerminator() &&\n          tryToSimplifyUncondBranchWithICmpInIt(ICI, Builder))\n        return true;\n    }\n\n  // See if we can merge an empty landing pad block with another which is\n  // equivalent.\n  if (LandingPadInst *LPad = dyn_cast<LandingPadInst>(I)) {\n    for (++I; isa<DbgInfoIntrinsic>(I); ++I)\n      ;\n    if (I->isTerminator() && TryToMergeLandingPad(LPad, BI, BB, DTU))\n      return true;\n  }\n\n  // If this basic block is ONLY a compare and a branch, and if a predecessor\n  // branches to us and our successor, fold the comparison into the\n  // predecessor and use logical operations to update the incoming value\n  // for PHI nodes in common successor.\n  if (FoldBranchToCommonDest(BI, DTU, /*MSSAU=*/nullptr, &TTI,\n                             Options.BonusInstThreshold))\n    return requestResimplify();\n  return false;\n}\n\nstatic BasicBlock *allPredecessorsComeFromSameSource(BasicBlock *BB) {\n  BasicBlock *PredPred = nullptr;\n  for (auto *P : predecessors(BB)) {\n    BasicBlock *PPred = P->getSinglePredecessor();\n    if (!PPred || (PredPred && PredPred != PPred))\n      return nullptr;\n    PredPred = PPred;\n  }\n  return PredPred;\n}\n\nbool SimplifyCFGOpt::simplifyCondBranch(BranchInst *BI, IRBuilder<> &Builder) {\n  BasicBlock *BB = BI->getParent();\n  if (!Options.SimplifyCondBranch)\n    return false;\n\n  // Conditional branch\n  if (isValueEqualityComparison(BI)) {\n    // If we only have one predecessor, and if it is a branch on this value,\n    // see if that predecessor totally determines the outcome of this\n    // switch.\n    if (BasicBlock *OnlyPred = BB->getSinglePredecessor())\n      if (SimplifyEqualityComparisonWithOnlyPredecessor(BI, OnlyPred, Builder))\n        return requestResimplify();\n\n    // This block must be empty, except for the setcond inst, if it exists.\n    // Ignore dbg and pseudo intrinsics.\n    auto I = BB->instructionsWithoutDebug(true).begin();\n    if (&*I == BI) {\n      if (FoldValueComparisonIntoPredecessors(BI, Builder))\n        return requestResimplify();\n    } else if (&*I == cast<Instruction>(BI->getCondition())) {\n      ++I;\n      if (&*I == BI && FoldValueComparisonIntoPredecessors(BI, Builder))\n        return requestResimplify();\n    }\n  }\n\n  // Try to turn \"br (X == 0 | X == 1), T, F\" into a switch instruction.\n  if (SimplifyBranchOnICmpChain(BI, Builder, DL))\n    return true;\n\n  // If this basic block has dominating predecessor blocks and the dominating\n  // blocks' conditions imply BI's condition, we know the direction of BI.\n  Optional<bool> Imp = isImpliedByDomCondition(BI->getCondition(), BI, DL);\n  if (Imp) {\n    // Turn this into a branch on constant.\n    auto *OldCond = BI->getCondition();\n    ConstantInt *TorF = *Imp ? ConstantInt::getTrue(BB->getContext())\n                             : ConstantInt::getFalse(BB->getContext());\n    BI->setCondition(TorF);\n    RecursivelyDeleteTriviallyDeadInstructions(OldCond);\n    return requestResimplify();\n  }\n\n  // If this basic block is ONLY a compare and a branch, and if a predecessor\n  // branches to us and one of our successors, fold the comparison into the\n  // predecessor and use logical operations to pick the right destination.\n  if (FoldBranchToCommonDest(BI, DTU, /*MSSAU=*/nullptr, &TTI,\n                             Options.BonusInstThreshold))\n    return requestResimplify();\n\n  // We have a conditional branch to two blocks that are only reachable\n  // from BI.  We know that the condbr dominates the two blocks, so see if\n  // there is any identical code in the \"then\" and \"else\" blocks.  If so, we\n  // can hoist it up to the branching block.\n  if (BI->getSuccessor(0)->getSinglePredecessor()) {\n    if (BI->getSuccessor(1)->getSinglePredecessor()) {\n      if (HoistCommon && Options.HoistCommonInsts)\n        if (HoistThenElseCodeToIf(BI, TTI))\n          return requestResimplify();\n    } else {\n      // If Successor #1 has multiple preds, we may be able to conditionally\n      // execute Successor #0 if it branches to Successor #1.\n      Instruction *Succ0TI = BI->getSuccessor(0)->getTerminator();\n      if (Succ0TI->getNumSuccessors() == 1 &&\n          Succ0TI->getSuccessor(0) == BI->getSuccessor(1))\n        if (SpeculativelyExecuteBB(BI, BI->getSuccessor(0), TTI))\n          return requestResimplify();\n    }\n  } else if (BI->getSuccessor(1)->getSinglePredecessor()) {\n    // If Successor #0 has multiple preds, we may be able to conditionally\n    // execute Successor #1 if it branches to Successor #0.\n    Instruction *Succ1TI = BI->getSuccessor(1)->getTerminator();\n    if (Succ1TI->getNumSuccessors() == 1 &&\n        Succ1TI->getSuccessor(0) == BI->getSuccessor(0))\n      if (SpeculativelyExecuteBB(BI, BI->getSuccessor(1), TTI))\n        return requestResimplify();\n  }\n\n  // If this is a branch on a phi node in the current block, thread control\n  // through this block if any PHI node entries are constants.\n  if (PHINode *PN = dyn_cast<PHINode>(BI->getCondition()))\n    if (PN->getParent() == BI->getParent())\n      if (FoldCondBranchOnPHI(BI, DTU, DL, Options.AC))\n        return requestResimplify();\n\n  // Scan predecessor blocks for conditional branches.\n  for (BasicBlock *Pred : predecessors(BB))\n    if (BranchInst *PBI = dyn_cast<BranchInst>(Pred->getTerminator()))\n      if (PBI != BI && PBI->isConditional())\n        if (SimplifyCondBranchToCondBranch(PBI, BI, DTU, DL, TTI))\n          return requestResimplify();\n\n  // Look for diamond patterns.\n  if (MergeCondStores)\n    if (BasicBlock *PrevBB = allPredecessorsComeFromSameSource(BB))\n      if (BranchInst *PBI = dyn_cast<BranchInst>(PrevBB->getTerminator()))\n        if (PBI != BI && PBI->isConditional())\n          if (mergeConditionalStores(PBI, BI, DTU, DL, TTI))\n            return requestResimplify();\n\n  return false;\n}\n\n/// Check if passing a value to an instruction will cause undefined behavior.\nstatic bool passingValueIsAlwaysUndefined(Value *V, Instruction *I, bool PtrValueMayBeModified) {\n  Constant *C = dyn_cast<Constant>(V);\n  if (!C)\n    return false;\n\n  if (I->use_empty())\n    return false;\n\n  if (C->isNullValue() || isa<UndefValue>(C)) {\n    // Only look at the first use, avoid hurting compile time with long uselists\n    User *Use = *I->user_begin();\n\n    // Now make sure that there are no instructions in between that can alter\n    // control flow (eg. calls)\n    for (BasicBlock::iterator\n             i = ++BasicBlock::iterator(I),\n             UI = BasicBlock::iterator(dyn_cast<Instruction>(Use));\n         i != UI; ++i)\n      if (i == I->getParent()->end() || i->mayHaveSideEffects())\n        return false;\n\n    // Look through GEPs. A load from a GEP derived from NULL is still undefined\n    if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(Use))\n      if (GEP->getPointerOperand() == I) {\n        if (!GEP->isInBounds() || !GEP->hasAllZeroIndices())\n          PtrValueMayBeModified = true;\n        return passingValueIsAlwaysUndefined(V, GEP, PtrValueMayBeModified);\n      }\n\n    // Look through bitcasts.\n    if (BitCastInst *BC = dyn_cast<BitCastInst>(Use))\n      return passingValueIsAlwaysUndefined(V, BC, PtrValueMayBeModified);\n\n    // Load from null is undefined.\n    if (LoadInst *LI = dyn_cast<LoadInst>(Use))\n      if (!LI->isVolatile())\n        return !NullPointerIsDefined(LI->getFunction(),\n                                     LI->getPointerAddressSpace());\n\n    // Store to null is undefined.\n    if (StoreInst *SI = dyn_cast<StoreInst>(Use))\n      if (!SI->isVolatile())\n        return (!NullPointerIsDefined(SI->getFunction(),\n                                      SI->getPointerAddressSpace())) &&\n               SI->getPointerOperand() == I;\n\n    if (auto *CB = dyn_cast<CallBase>(Use)) {\n      if (C->isNullValue() && NullPointerIsDefined(CB->getFunction()))\n        return false;\n      // A call to null is undefined.\n      if (CB->getCalledOperand() == I)\n        return true;\n\n      if (C->isNullValue()) {\n        for (const llvm::Use &Arg : CB->args())\n          if (Arg == I) {\n            unsigned ArgIdx = CB->getArgOperandNo(&Arg);\n            if (CB->isPassingUndefUB(ArgIdx) &&\n                CB->paramHasAttr(ArgIdx, Attribute::NonNull)) {\n              // Passing null to a nonnnull+noundef argument is undefined.\n              return !PtrValueMayBeModified;\n            }\n          }\n      } else if (isa<UndefValue>(C)) {\n        // Passing undef to a noundef argument is undefined.\n        for (const llvm::Use &Arg : CB->args())\n          if (Arg == I) {\n            unsigned ArgIdx = CB->getArgOperandNo(&Arg);\n            if (CB->isPassingUndefUB(ArgIdx)) {\n              // Passing undef to a noundef argument is undefined.\n              return true;\n            }\n          }\n      }\n    }\n  }\n  return false;\n}\n\n/// If BB has an incoming value that will always trigger undefined behavior\n/// (eg. null pointer dereference), remove the branch leading here.\nstatic bool removeUndefIntroducingPredecessor(BasicBlock *BB,\n                                              DomTreeUpdater *DTU) {\n  for (PHINode &PHI : BB->phis())\n    for (unsigned i = 0, e = PHI.getNumIncomingValues(); i != e; ++i)\n      if (passingValueIsAlwaysUndefined(PHI.getIncomingValue(i), &PHI)) {\n        BasicBlock *Predecessor = PHI.getIncomingBlock(i);\n        Instruction *T = Predecessor->getTerminator();\n        IRBuilder<> Builder(T);\n        if (BranchInst *BI = dyn_cast<BranchInst>(T)) {\n          BB->removePredecessor(Predecessor);\n          // Turn uncoditional branches into unreachables and remove the dead\n          // destination from conditional branches.\n          if (BI->isUnconditional())\n            Builder.CreateUnreachable();\n          else\n            Builder.CreateBr(BI->getSuccessor(0) == BB ? BI->getSuccessor(1)\n                                                       : BI->getSuccessor(0));\n          BI->eraseFromParent();\n          if (DTU)\n            DTU->applyUpdates({{DominatorTree::Delete, Predecessor, BB}});\n          return true;\n        }\n        // TODO: SwitchInst.\n      }\n\n  return false;\n}\n\nbool SimplifyCFGOpt::simplifyOnceImpl(BasicBlock *BB) {\n  bool Changed = false;\n\n  assert(BB && BB->getParent() && \"Block not embedded in function!\");\n  assert(BB->getTerminator() && \"Degenerate basic block encountered!\");\n\n  // Remove basic blocks that have no predecessors (except the entry block)...\n  // or that just have themself as a predecessor.  These are unreachable.\n  if ((pred_empty(BB) && BB != &BB->getParent()->getEntryBlock()) ||\n      BB->getSinglePredecessor() == BB) {\n    LLVM_DEBUG(dbgs() << \"Removing BB: \\n\" << *BB);\n    DeleteDeadBlock(BB, DTU);\n    return true;\n  }\n\n  // Check to see if we can constant propagate this terminator instruction\n  // away...\n  Changed |= ConstantFoldTerminator(BB, /*DeleteDeadConditions=*/true,\n                                    /*TLI=*/nullptr, DTU);\n\n  // Check for and eliminate duplicate PHI nodes in this block.\n  Changed |= EliminateDuplicatePHINodes(BB);\n\n  // Check for and remove branches that will always cause undefined behavior.\n  Changed |= removeUndefIntroducingPredecessor(BB, DTU);\n\n  // Merge basic blocks into their predecessor if there is only one distinct\n  // pred, and if there is only one distinct successor of the predecessor, and\n  // if there are no PHI nodes.\n  if (MergeBlockIntoPredecessor(BB, DTU))\n    return true;\n\n  if (SinkCommon && Options.SinkCommonInsts)\n    Changed |= SinkCommonCodeFromPredecessors(BB, DTU);\n\n  IRBuilder<> Builder(BB);\n\n  if (Options.FoldTwoEntryPHINode) {\n    // If there is a trivial two-entry PHI node in this basic block, and we can\n    // eliminate it, do so now.\n    if (auto *PN = dyn_cast<PHINode>(BB->begin()))\n      if (PN->getNumIncomingValues() == 2)\n        Changed |= FoldTwoEntryPHINode(PN, TTI, DTU, DL);\n  }\n\n  Instruction *Terminator = BB->getTerminator();\n  Builder.SetInsertPoint(Terminator);\n  switch (Terminator->getOpcode()) {\n  case Instruction::Br:\n    Changed |= simplifyBranch(cast<BranchInst>(Terminator), Builder);\n    break;\n  case Instruction::Ret:\n    Changed |= simplifyReturn(cast<ReturnInst>(Terminator), Builder);\n    break;\n  case Instruction::Resume:\n    Changed |= simplifyResume(cast<ResumeInst>(Terminator), Builder);\n    break;\n  case Instruction::CleanupRet:\n    Changed |= simplifyCleanupReturn(cast<CleanupReturnInst>(Terminator));\n    break;\n  case Instruction::Switch:\n    Changed |= simplifySwitch(cast<SwitchInst>(Terminator), Builder);\n    break;\n  case Instruction::Unreachable:\n    Changed |= simplifyUnreachable(cast<UnreachableInst>(Terminator));\n    break;\n  case Instruction::IndirectBr:\n    Changed |= simplifyIndirectBr(cast<IndirectBrInst>(Terminator));\n    break;\n  }\n\n  return Changed;\n}\n\nbool SimplifyCFGOpt::simplifyOnce(BasicBlock *BB) {\n  bool Changed = simplifyOnceImpl(BB);\n\n  return Changed;\n}\n\nbool SimplifyCFGOpt::run(BasicBlock *BB) {\n  bool Changed = false;\n\n  // Repeated simplify BB as long as resimplification is requested.\n  do {\n    Resimplify = false;\n\n    // Perform one round of simplifcation. Resimplify flag will be set if\n    // another iteration is requested.\n    Changed |= simplifyOnce(BB);\n  } while (Resimplify);\n\n  return Changed;\n}\n\nbool llvm::simplifyCFG(BasicBlock *BB, const TargetTransformInfo &TTI,\n                       DomTreeUpdater *DTU, const SimplifyCFGOptions &Options,\n                       ArrayRef<WeakVH> LoopHeaders) {\n  return SimplifyCFGOpt(TTI, DTU, BB->getModule()->getDataLayout(), LoopHeaders,\n                        Options)\n      .run(BB);\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 62, "line": 204}, "message": "destructor '~ValueEqualityComparisonCase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "afc1083a4a740d3a64313626382ae8c3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 62, "line": 1408}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "4abed6a31c8785737e5818d8bab6aba7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 62, "line": 1699}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "02542061809d8001117eb36a61f282d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 62, "line": 1699}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "e8d98b050f130e8623a412a40f4282cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 62, "line": 1965}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "98d2371d8b1b15ea2c0354abc213312b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 62, "line": 1965}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "7979e69136b8f7481ced6bbba54332dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 62, "line": 2600}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "9f2aafe03b58b4c8ddb254d55810f0be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 62, "line": 2600}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "f2475444add88a7269032e73ab55b5a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 62, "line": 2611}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "d6d373598db0a141d9bb3588f155be94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 62, "line": 2611}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "c96d59040b7806e8afae4d057abafd18", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 62, "line": 3194}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "11ec81429a2ac9e4ac60c836de6d43d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 62, "line": 3194}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "ed4cad52eb97e8aea426f27ab98504d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 62, "line": 3358}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "d90c414bf391115ed78c449704193621", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 62, "line": 3358}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "5262e14d3b9f6e7f949e43a343ef1693", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 62, "line": 3420}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "59fe986b8df10c0e00322d95c582e068", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 62, "line": 3420}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "reportHash": "f6418f92a360f3a8a6745afb3af79f07", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
