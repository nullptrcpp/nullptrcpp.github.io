<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "content": "/*! \\file */\n/*\n * kmp.h -- KPTS runtime header file.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_H\n#define KMP_H\n\n#include \"kmp_config.h\"\n\n/* #define BUILD_PARALLEL_ORDERED 1 */\n\n/* This fix replaces gettimeofday with clock_gettime for better scalability on\n   the Altix.  Requires user code to be linked with -lrt. */\n//#define FIX_SGI_CLOCK\n\n/* Defines for OpenMP 3.0 tasking and auto scheduling */\n\n#ifndef KMP_STATIC_STEAL_ENABLED\n#define KMP_STATIC_STEAL_ENABLED 1\n#endif\n\n#define TASK_CURRENT_NOT_QUEUED 0\n#define TASK_CURRENT_QUEUED 1\n\n#ifdef BUILD_TIED_TASK_STACK\n#define TASK_STACK_EMPTY 0 // entries when the stack is empty\n#define TASK_STACK_BLOCK_BITS 5 // Used in TASK_STACK_SIZE and TASK_STACK_MASK\n// Number of entries in each task stack array\n#define TASK_STACK_BLOCK_SIZE (1 << TASK_STACK_BLOCK_BITS)\n// Mask for determining index into stack block\n#define TASK_STACK_INDEX_MASK (TASK_STACK_BLOCK_SIZE - 1)\n#endif // BUILD_TIED_TASK_STACK\n\n#define TASK_NOT_PUSHED 1\n#define TASK_SUCCESSFULLY_PUSHED 0\n#define TASK_TIED 1\n#define TASK_UNTIED 0\n#define TASK_EXPLICIT 1\n#define TASK_IMPLICIT 0\n#define TASK_PROXY 1\n#define TASK_FULL 0\n#define TASK_DETACHABLE 1\n#define TASK_UNDETACHABLE 0\n\n#define KMP_CANCEL_THREADS\n#define KMP_THREAD_ATTR\n\n// Android does not have pthread_cancel.  Undefine KMP_CANCEL_THREADS if being\n// built on Android\n#if defined(__ANDROID__)\n#undef KMP_CANCEL_THREADS\n#endif\n\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits>\n#include <type_traits>\n/* include <ctype.h> don't use; problems with /MD on Windows* OS NT due to bad\n   Microsoft library. Some macros provided below to replace these functions  */\n#ifndef __ABSOFT_WIN\n#include <sys/types.h>\n#endif\n#include <limits.h>\n#include <time.h>\n\n#include <errno.h>\n\n#include \"kmp_os.h\"\n\n#include \"kmp_safe_c_api.h\"\n\n#if KMP_STATS_ENABLED\nclass kmp_stats_list;\n#endif\n\n#if KMP_USE_HIER_SCHED\n// Only include hierarchical scheduling if affinity is supported\n#undef KMP_USE_HIER_SCHED\n#define KMP_USE_HIER_SCHED KMP_AFFINITY_SUPPORTED\n#endif\n\n#if KMP_USE_HWLOC && KMP_AFFINITY_SUPPORTED\n#include \"hwloc.h\"\n#ifndef HWLOC_OBJ_NUMANODE\n#define HWLOC_OBJ_NUMANODE HWLOC_OBJ_NODE\n#endif\n#ifndef HWLOC_OBJ_PACKAGE\n#define HWLOC_OBJ_PACKAGE HWLOC_OBJ_SOCKET\n#endif\n#if HWLOC_API_VERSION >= 0x00020000\n// hwloc 2.0 changed type of depth of object from unsigned to int\ntypedef int kmp_hwloc_depth_t;\n#else\ntypedef unsigned int kmp_hwloc_depth_t;\n#endif\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#include <xmmintrin.h>\n#endif\n\n#include \"kmp_debug.h\"\n#include \"kmp_lock.h\"\n#include \"kmp_version.h\"\n#if USE_DEBUGGER\n#include \"kmp_debugger.h\"\n#endif\n#include \"kmp_i18n.h\"\n\n#define KMP_HANDLE_SIGNALS (KMP_OS_UNIX || KMP_OS_WINDOWS)\n\n#include \"kmp_wrapper_malloc.h\"\n#if KMP_OS_UNIX\n#include <unistd.h>\n#if !defined NSIG && defined _NSIG\n#define NSIG _NSIG\n#endif\n#endif\n\n#if KMP_OS_LINUX\n#pragma weak clock_gettime\n#endif\n\n#if OMPT_SUPPORT\n#include \"ompt-internal.h\"\n#endif\n\n#ifndef UNLIKELY\n#define UNLIKELY(x) (x)\n#endif\n\n// Affinity format function\n#include \"kmp_str.h\"\n\n// 0 - no fast memory allocation, alignment: 8-byte on x86, 16-byte on x64.\n// 3 - fast allocation using sync, non-sync free lists of any size, non-self\n// free lists of limited size.\n#ifndef USE_FAST_MEMORY\n#define USE_FAST_MEMORY 3\n#endif\n\n#ifndef KMP_NESTED_HOT_TEAMS\n#define KMP_NESTED_HOT_TEAMS 0\n#define USE_NESTED_HOT_ARG(x)\n#else\n#if KMP_NESTED_HOT_TEAMS\n#define USE_NESTED_HOT_ARG(x) , x\n#else\n#define USE_NESTED_HOT_ARG(x)\n#endif\n#endif\n\n// Assume using BGET compare_exchange instruction instead of lock by default.\n#ifndef USE_CMP_XCHG_FOR_BGET\n#define USE_CMP_XCHG_FOR_BGET 1\n#endif\n\n// Test to see if queuing lock is better than bootstrap lock for bget\n// #ifndef USE_QUEUING_LOCK_FOR_BGET\n// #define USE_QUEUING_LOCK_FOR_BGET\n// #endif\n\n#define KMP_NSEC_PER_SEC 1000000000L\n#define KMP_USEC_PER_SEC 1000000L\n\n/*!\n@ingroup BASIC_TYPES\n@{\n*/\n\n/*!\nValues for bit flags used in the ident_t to describe the fields.\n*/\nenum {\n  /*! Use trampoline for internal microtasks */\n  KMP_IDENT_IMB = 0x01,\n  /*! Use c-style ident structure */\n  KMP_IDENT_KMPC = 0x02,\n  /* 0x04 is no longer used */\n  /*! Entry point generated by auto-parallelization */\n  KMP_IDENT_AUTOPAR = 0x08,\n  /*! Compiler generates atomic reduction option for kmpc_reduce* */\n  KMP_IDENT_ATOMIC_REDUCE = 0x10,\n  /*! To mark a 'barrier' directive in user code */\n  KMP_IDENT_BARRIER_EXPL = 0x20,\n  /*! To Mark implicit barriers. */\n  KMP_IDENT_BARRIER_IMPL = 0x0040,\n  KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0,\n  KMP_IDENT_BARRIER_IMPL_FOR = 0x0040,\n  KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0,\n\n  KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140,\n  KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0,\n\n  /*! To mark a static loop in OMPT callbacks */\n  KMP_IDENT_WORK_LOOP = 0x200,\n  /*! To mark a sections directive in OMPT callbacks */\n  KMP_IDENT_WORK_SECTIONS = 0x400,\n  /*! To mark a distribute construct in OMPT callbacks */\n  KMP_IDENT_WORK_DISTRIBUTE = 0x800,\n  /*! Atomic hint; bottom four bits as omp_sync_hint_t. Top four reserved and\n      not currently used. If one day we need more bits, then we can use\n      an invalid combination of hints to mean that another, larger field\n      should be used in a different flag. */\n  KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000,\n  KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000,\n  KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000,\n  KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000,\n  KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000,\n  KMP_IDENT_OPENMP_SPEC_VERSION_MASK = 0xFF000000\n};\n\n/*!\n * The ident structure that describes a source location.\n */\ntypedef struct ident {\n  kmp_int32 reserved_1; /**<  might be used in Fortran; see above  */\n  kmp_int32 flags; /**<  also f.flags; KMP_IDENT_xxx flags; KMP_IDENT_KMPC\n                      identifies this union member  */\n  kmp_int32 reserved_2; /**<  not really used in Fortran any more; see above */\n#if USE_ITT_BUILD\n/*  but currently used for storing region-specific ITT */\n/*  contextual information. */\n#endif /* USE_ITT_BUILD */\n  kmp_int32 reserved_3; /**< source[4] in Fortran, do not use for C++  */\n  char const *psource; /**< String describing the source location.\n                       The string is composed of semi-colon separated fields\n                       which describe the source file, the function and a pair\n                       of line numbers that delimit the construct. */\n  // Returns the OpenMP version in form major*10+minor (e.g., 50 for 5.0)\n  kmp_int32 get_openmp_version() {\n    return (((flags & KMP_IDENT_OPENMP_SPEC_VERSION_MASK) >> 24) & 0xFF);\n  }\n} ident_t;\n/*!\n@}\n*/\n\n// Some forward declarations.\ntypedef union kmp_team kmp_team_t;\ntypedef struct kmp_taskdata kmp_taskdata_t;\ntypedef union kmp_task_team kmp_task_team_t;\ntypedef union kmp_team kmp_team_p;\ntypedef union kmp_info kmp_info_p;\ntypedef union kmp_root kmp_root_p;\n\ntemplate <bool C = false, bool S = true> class kmp_flag_32;\ntemplate <bool C = false, bool S = true> class kmp_flag_64;\nclass kmp_flag_oncore;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* ------------------------------------------------------------------------ */\n\n/* Pack two 32-bit signed integers into a 64-bit signed integer */\n/* ToDo: Fix word ordering for big-endian machines. */\n#define KMP_PACK_64(HIGH_32, LOW_32)                                           \\\n  ((kmp_int64)((((kmp_uint64)(HIGH_32)) << 32) | (kmp_uint64)(LOW_32)))\n\n// Generic string manipulation macros. Assume that _x is of type char *\n#define SKIP_WS(_x)                                                            \\\n  {                                                                            \\\n    while (*(_x) == ' ' || *(_x) == '\\t')                                      \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_DIGITS(_x)                                                        \\\n  {                                                                            \\\n    while (*(_x) >= '0' && *(_x) <= '9')                                       \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_TOKEN(_x)                                                         \\\n  {                                                                            \\\n    while ((*(_x) >= '0' && *(_x) <= '9') || (*(_x) >= 'a' && *(_x) <= 'z') || \\\n           (*(_x) >= 'A' && *(_x) <= 'Z') || *(_x) == '_')                     \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_TO(_x, _c)                                                        \\\n  {                                                                            \\\n    while (*(_x) != '\\0' && *(_x) != (_c))                                     \\\n      (_x)++;                                                                  \\\n  }\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_MAX(x, y) ((x) > (y) ? (x) : (y))\n#define KMP_MIN(x, y) ((x) < (y) ? (x) : (y))\n\n/* ------------------------------------------------------------------------ */\n/* Enumeration types */\n\nenum kmp_state_timer {\n  ts_stop,\n  ts_start,\n  ts_pause,\n\n  ts_last_state\n};\n\nenum dynamic_mode {\n  dynamic_default,\n#ifdef USE_LOAD_BALANCE\n  dynamic_load_balance,\n#endif /* USE_LOAD_BALANCE */\n  dynamic_random,\n  dynamic_thread_limit,\n  dynamic_max\n};\n\n/* external schedule constants, duplicate enum omp_sched in omp.h in order to\n * not include it here */\n#ifndef KMP_SCHED_TYPE_DEFINED\n#define KMP_SCHED_TYPE_DEFINED\ntypedef enum kmp_sched {\n  kmp_sched_lower = 0, // lower and upper bounds are for routine parameter check\n  // Note: need to adjust __kmp_sch_map global array in case enum is changed\n  kmp_sched_static = 1, // mapped to kmp_sch_static_chunked           (33)\n  kmp_sched_dynamic = 2, // mapped to kmp_sch_dynamic_chunked          (35)\n  kmp_sched_guided = 3, // mapped to kmp_sch_guided_chunked           (36)\n  kmp_sched_auto = 4, // mapped to kmp_sch_auto                     (38)\n  kmp_sched_upper_std = 5, // upper bound for standard schedules\n  kmp_sched_lower_ext = 100, // lower bound of Intel extension schedules\n  kmp_sched_trapezoidal = 101, // mapped to kmp_sch_trapezoidal (39)\n#if KMP_STATIC_STEAL_ENABLED\n  kmp_sched_static_steal = 102, // mapped to kmp_sch_static_steal (44)\n#endif\n  kmp_sched_upper,\n  kmp_sched_default = kmp_sched_static, // default scheduling\n  kmp_sched_monotonic = 0x80000000\n} kmp_sched_t;\n#endif\n\n/*!\n @ingroup WORK_SHARING\n * Describes the loop schedule to be used for a parallel for loop.\n */\nenum sched_type : kmp_int32 {\n  kmp_sch_lower = 32, /**< lower bound for unordered values */\n  kmp_sch_static_chunked = 33,\n  kmp_sch_static = 34, /**< static unspecialized */\n  kmp_sch_dynamic_chunked = 35,\n  kmp_sch_guided_chunked = 36, /**< guided unspecialized */\n  kmp_sch_runtime = 37,\n  kmp_sch_auto = 38, /**< auto */\n  kmp_sch_trapezoidal = 39,\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_static_greedy = 40,\n  kmp_sch_static_balanced = 41,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_guided_iterative_chunked = 42,\n  kmp_sch_guided_analytical_chunked = 43,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_static_steal = 44,\n\n  /* static with chunk adjustment (e.g., simd) */\n  kmp_sch_static_balanced_chunked = 45,\n  kmp_sch_guided_simd = 46, /**< guided with chunk adjustment */\n  kmp_sch_runtime_simd = 47, /**< runtime with chunk adjustment */\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_upper, /**< upper bound for unordered values */\n\n  kmp_ord_lower = 64, /**< lower bound for ordered values, must be power of 2 */\n  kmp_ord_static_chunked = 65,\n  kmp_ord_static = 66, /**< ordered static unspecialized */\n  kmp_ord_dynamic_chunked = 67,\n  kmp_ord_guided_chunked = 68,\n  kmp_ord_runtime = 69,\n  kmp_ord_auto = 70, /**< ordered auto */\n  kmp_ord_trapezoidal = 71,\n  kmp_ord_upper, /**< upper bound for ordered values */\n\n  /* Schedules for Distribute construct */\n  kmp_distribute_static_chunked = 91, /**< distribute static chunked */\n  kmp_distribute_static = 92, /**< distribute static unspecialized */\n\n  /* For the \"nomerge\" versions, kmp_dispatch_next*() will always return a\n     single iteration/chunk, even if the loop is serialized. For the schedule\n     types listed above, the entire iteration vector is returned if the loop is\n     serialized. This doesn't work for gcc/gcomp sections. */\n  kmp_nm_lower = 160, /**< lower bound for nomerge values */\n\n  kmp_nm_static_chunked =\n      (kmp_sch_static_chunked - kmp_sch_lower + kmp_nm_lower),\n  kmp_nm_static = 162, /**< static unspecialized */\n  kmp_nm_dynamic_chunked = 163,\n  kmp_nm_guided_chunked = 164, /**< guided unspecialized */\n  kmp_nm_runtime = 165,\n  kmp_nm_auto = 166, /**< auto */\n  kmp_nm_trapezoidal = 167,\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_nm_static_greedy = 168,\n  kmp_nm_static_balanced = 169,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_nm_guided_iterative_chunked = 170,\n  kmp_nm_guided_analytical_chunked = 171,\n  kmp_nm_static_steal =\n      172, /* accessible only through OMP_SCHEDULE environment variable */\n\n  kmp_nm_ord_static_chunked = 193,\n  kmp_nm_ord_static = 194, /**< ordered static unspecialized */\n  kmp_nm_ord_dynamic_chunked = 195,\n  kmp_nm_ord_guided_chunked = 196,\n  kmp_nm_ord_runtime = 197,\n  kmp_nm_ord_auto = 198, /**< auto */\n  kmp_nm_ord_trapezoidal = 199,\n  kmp_nm_upper, /**< upper bound for nomerge values */\n\n  /* Support for OpenMP 4.5 monotonic and nonmonotonic schedule modifiers. Since\n     we need to distinguish the three possible cases (no modifier, monotonic\n     modifier, nonmonotonic modifier), we need separate bits for each modifier.\n     The absence of monotonic does not imply nonmonotonic, especially since 4.5\n     says that the behaviour of the \"no modifier\" case is implementation defined\n     in 4.5, but will become \"nonmonotonic\" in 5.0.\n\n     Since we're passing a full 32 bit value, we can use a couple of high bits\n     for these flags; out of paranoia we avoid the sign bit.\n\n     These modifiers can be or-ed into non-static schedules by the compiler to\n     pass the additional information. They will be stripped early in the\n     processing in __kmp_dispatch_init when setting up schedules, so most of the\n     code won't ever see schedules with these bits set.  */\n  kmp_sch_modifier_monotonic =\n      (1 << 29), /**< Set if the monotonic schedule modifier was present */\n  kmp_sch_modifier_nonmonotonic =\n      (1 << 30), /**< Set if the nonmonotonic schedule modifier was present */\n\n#define SCHEDULE_WITHOUT_MODIFIERS(s)                                          \\\n  (enum sched_type)(                                                           \\\n      (s) & ~(kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic))\n#define SCHEDULE_HAS_MONOTONIC(s) (((s)&kmp_sch_modifier_monotonic) != 0)\n#define SCHEDULE_HAS_NONMONOTONIC(s) (((s)&kmp_sch_modifier_nonmonotonic) != 0)\n#define SCHEDULE_HAS_NO_MODIFIERS(s)                                           \\\n  (((s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)) == 0)\n#define SCHEDULE_GET_MODIFIERS(s)                                              \\\n  ((enum sched_type)(                                                          \\\n      (s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)))\n#define SCHEDULE_SET_MODIFIERS(s, m)                                           \\\n  (s = (enum sched_type)((kmp_int32)s | (kmp_int32)m))\n#define SCHEDULE_NONMONOTONIC 0\n#define SCHEDULE_MONOTONIC 1\n\n  kmp_sch_default = kmp_sch_static /**< default scheduling algorithm */\n};\n\n// Apply modifiers on internal kind to standard kind\nstatic inline void\n__kmp_sched_apply_mods_stdkind(kmp_sched_t *kind,\n                               enum sched_type internal_kind) {\n  if (SCHEDULE_HAS_MONOTONIC(internal_kind)) {\n    *kind = (kmp_sched_t)((int)*kind | (int)kmp_sched_monotonic);\n  }\n}\n\n// Apply modifiers on standard kind to internal kind\nstatic inline void\n__kmp_sched_apply_mods_intkind(kmp_sched_t kind,\n                               enum sched_type *internal_kind) {\n  if ((int)kind & (int)kmp_sched_monotonic) {\n    *internal_kind = (enum sched_type)((int)*internal_kind |\n                                       (int)kmp_sch_modifier_monotonic);\n  }\n}\n\n// Get standard schedule without modifiers\nstatic inline kmp_sched_t __kmp_sched_without_mods(kmp_sched_t kind) {\n  return (kmp_sched_t)((int)kind & ~((int)kmp_sched_monotonic));\n}\n\n/* Type to keep runtime schedule set via OMP_SCHEDULE or omp_set_schedule() */\ntypedef union kmp_r_sched {\n  struct {\n    enum sched_type r_sched_type;\n    int chunk;\n  };\n  kmp_int64 sched;\n} kmp_r_sched_t;\n\nextern enum sched_type __kmp_sch_map[]; // map OMP 3.0 schedule types with our\n// internal schedule types\n\nenum library_type {\n  library_none,\n  library_serial,\n  library_turnaround,\n  library_throughput\n};\n\n#if KMP_OS_LINUX\nenum clock_function_type {\n  clock_function_gettimeofday,\n  clock_function_clock_gettime\n};\n#endif /* KMP_OS_LINUX */\n\n#if KMP_MIC_SUPPORTED\nenum mic_type { non_mic, mic1, mic2, mic3, dummy };\n#endif\n\n/* -- fast reduction stuff ------------------------------------------------ */\n\n#undef KMP_FAST_REDUCTION_BARRIER\n#define KMP_FAST_REDUCTION_BARRIER 1\n\n#undef KMP_FAST_REDUCTION_CORE_DUO\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_FAST_REDUCTION_CORE_DUO 1\n#endif\n\nenum _reduction_method {\n  reduction_method_not_defined = 0,\n  critical_reduce_block = (1 << 8),\n  atomic_reduce_block = (2 << 8),\n  tree_reduce_block = (3 << 8),\n  empty_reduce_block = (4 << 8)\n};\n\n// Description of the packed_reduction_method variable:\n// The packed_reduction_method variable consists of two enum types variables\n// that are packed together into 0-th byte and 1-st byte:\n// 0: (packed_reduction_method & 0x000000FF) is a 'enum barrier_type' value of\n// barrier that will be used in fast reduction: bs_plain_barrier or\n// bs_reduction_barrier\n// 1: (packed_reduction_method & 0x0000FF00) is a reduction method that will\n// be used in fast reduction;\n// Reduction method is of 'enum _reduction_method' type and it's defined the way\n// so that the bits of 0-th byte are empty, so no need to execute a shift\n// instruction while packing/unpacking\n\n#if KMP_FAST_REDUCTION_BARRIER\n#define PACK_REDUCTION_METHOD_AND_BARRIER(reduction_method, barrier_type)      \\\n  ((reduction_method) | (barrier_type))\n\n#define UNPACK_REDUCTION_METHOD(packed_reduction_method)                       \\\n  ((enum _reduction_method)((packed_reduction_method) & (0x0000FF00)))\n\n#define UNPACK_REDUCTION_BARRIER(packed_reduction_method)                      \\\n  ((enum barrier_type)((packed_reduction_method) & (0x000000FF)))\n#else\n#define PACK_REDUCTION_METHOD_AND_BARRIER(reduction_method, barrier_type)      \\\n  (reduction_method)\n\n#define UNPACK_REDUCTION_METHOD(packed_reduction_method)                       \\\n  (packed_reduction_method)\n\n#define UNPACK_REDUCTION_BARRIER(packed_reduction_method) (bs_plain_barrier)\n#endif\n\n#define TEST_REDUCTION_METHOD(packed_reduction_method, which_reduction_block)  \\\n  ((UNPACK_REDUCTION_METHOD(packed_reduction_method)) ==                       \\\n   (which_reduction_block))\n\n#if KMP_FAST_REDUCTION_BARRIER\n#define TREE_REDUCE_BLOCK_WITH_REDUCTION_BARRIER                               \\\n  (PACK_REDUCTION_METHOD_AND_BARRIER(tree_reduce_block, bs_reduction_barrier))\n\n#define TREE_REDUCE_BLOCK_WITH_PLAIN_BARRIER                                   \\\n  (PACK_REDUCTION_METHOD_AND_BARRIER(tree_reduce_block, bs_plain_barrier))\n#endif\n\ntypedef int PACKED_REDUCTION_METHOD_T;\n\n/* -- end of fast reduction stuff ----------------------------------------- */\n\n#if KMP_OS_WINDOWS\n#define USE_CBLKDATA\n#if KMP_MSVC_COMPAT\n#pragma warning(push)\n#pragma warning(disable : 271 310)\n#endif\n#include <windows.h>\n#if KMP_MSVC_COMPAT\n#pragma warning(pop)\n#endif\n#endif\n\n#if KMP_OS_UNIX\n#include <dlfcn.h>\n#include <pthread.h>\n#endif\n\nenum kmp_hw_t : int {\n  KMP_HW_UNKNOWN = -1,\n  KMP_HW_MACHINE = 0,\n  KMP_HW_SOCKET,\n  KMP_HW_PROC_GROUP,\n  KMP_HW_NUMA,\n  KMP_HW_DIE,\n  KMP_HW_L3,\n  KMP_HW_TILE,\n  KMP_HW_MODULE,\n  KMP_HW_L2,\n  KMP_HW_L1,\n  KMP_HW_CORE,\n  KMP_HW_THREAD,\n  KMP_HW_LAST\n};\n\n#define KMP_ASSERT_VALID_HW_TYPE(type)                                         \\\n  KMP_DEBUG_ASSERT(type >= (kmp_hw_t)0 && type < KMP_HW_LAST)\n\n#define KMP_FOREACH_HW_TYPE(type)                                              \\\n  for (kmp_hw_t type = (kmp_hw_t)0; type < KMP_HW_LAST;                        \\\n       type = (kmp_hw_t)((int)type + 1))\n\nconst char *__kmp_hw_get_catalog_string(kmp_hw_t type, bool plural = false);\n\n/* Only Linux* OS and Windows* OS support thread affinity. */\n#if KMP_AFFINITY_SUPPORTED\n\n// GROUP_AFFINITY is already defined for _MSC_VER>=1600 (VS2010 and later).\n#if KMP_OS_WINDOWS\n#if _MSC_VER < 1600 && KMP_MSVC_COMPAT\ntypedef struct GROUP_AFFINITY {\n  KAFFINITY Mask;\n  WORD Group;\n  WORD Reserved[3];\n} GROUP_AFFINITY;\n#endif /* _MSC_VER < 1600 */\n#if KMP_GROUP_AFFINITY\nextern int __kmp_num_proc_groups;\n#else\nstatic const int __kmp_num_proc_groups = 1;\n#endif /* KMP_GROUP_AFFINITY */\ntypedef DWORD (*kmp_GetActiveProcessorCount_t)(WORD);\nextern kmp_GetActiveProcessorCount_t __kmp_GetActiveProcessorCount;\n\ntypedef WORD (*kmp_GetActiveProcessorGroupCount_t)(void);\nextern kmp_GetActiveProcessorGroupCount_t __kmp_GetActiveProcessorGroupCount;\n\ntypedef BOOL (*kmp_GetThreadGroupAffinity_t)(HANDLE, GROUP_AFFINITY *);\nextern kmp_GetThreadGroupAffinity_t __kmp_GetThreadGroupAffinity;\n\ntypedef BOOL (*kmp_SetThreadGroupAffinity_t)(HANDLE, const GROUP_AFFINITY *,\n                                             GROUP_AFFINITY *);\nextern kmp_SetThreadGroupAffinity_t __kmp_SetThreadGroupAffinity;\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_USE_HWLOC\nextern hwloc_topology_t __kmp_hwloc_topology;\nextern int __kmp_hwloc_error;\nextern int __kmp_numa_detected;\nextern int __kmp_tile_depth;\n#endif\n\nextern size_t __kmp_affin_mask_size;\n#define KMP_AFFINITY_CAPABLE() (__kmp_affin_mask_size > 0)\n#define KMP_AFFINITY_DISABLE() (__kmp_affin_mask_size = 0)\n#define KMP_AFFINITY_ENABLE(mask_size) (__kmp_affin_mask_size = mask_size)\n#define KMP_CPU_SET_ITERATE(i, mask)                                           \\\n  for (i = (mask)->begin(); (int)i != (mask)->end(); i = (mask)->next(i))\n#define KMP_CPU_SET(i, mask) (mask)->set(i)\n#define KMP_CPU_ISSET(i, mask) (mask)->is_set(i)\n#define KMP_CPU_CLR(i, mask) (mask)->clear(i)\n#define KMP_CPU_ZERO(mask) (mask)->zero()\n#define KMP_CPU_COPY(dest, src) (dest)->copy(src)\n#define KMP_CPU_AND(dest, src) (dest)->bitwise_and(src)\n#define KMP_CPU_COMPLEMENT(max_bit_number, mask) (mask)->bitwise_not()\n#define KMP_CPU_UNION(dest, src) (dest)->bitwise_or(src)\n#define KMP_CPU_ALLOC(ptr) (ptr = __kmp_affinity_dispatch->allocate_mask())\n#define KMP_CPU_FREE(ptr) __kmp_affinity_dispatch->deallocate_mask(ptr)\n#define KMP_CPU_ALLOC_ON_STACK(ptr) KMP_CPU_ALLOC(ptr)\n#define KMP_CPU_FREE_FROM_STACK(ptr) KMP_CPU_FREE(ptr)\n#define KMP_CPU_INTERNAL_ALLOC(ptr) KMP_CPU_ALLOC(ptr)\n#define KMP_CPU_INTERNAL_FREE(ptr) KMP_CPU_FREE(ptr)\n#define KMP_CPU_INDEX(arr, i) __kmp_affinity_dispatch->index_mask_array(arr, i)\n#define KMP_CPU_ALLOC_ARRAY(arr, n)                                            \\\n  (arr = __kmp_affinity_dispatch->allocate_mask_array(n))\n#define KMP_CPU_FREE_ARRAY(arr, n)                                             \\\n  __kmp_affinity_dispatch->deallocate_mask_array(arr)\n#define KMP_CPU_INTERNAL_ALLOC_ARRAY(arr, n) KMP_CPU_ALLOC_ARRAY(arr, n)\n#define KMP_CPU_INTERNAL_FREE_ARRAY(arr, n) KMP_CPU_FREE_ARRAY(arr, n)\n#define __kmp_get_system_affinity(mask, abort_bool)                            \\\n  (mask)->get_system_affinity(abort_bool)\n#define __kmp_set_system_affinity(mask, abort_bool)                            \\\n  (mask)->set_system_affinity(abort_bool)\n#define __kmp_get_proc_group(mask) (mask)->get_proc_group()\n\nclass KMPAffinity {\npublic:\n  class Mask {\n  public:\n    void *operator new(size_t n);\n    void operator delete(void *p);\n    void *operator new[](size_t n);\n    void operator delete[](void *p);\n    virtual ~Mask() {}\n    // Set bit i to 1\n    virtual void set(int i) {}\n    // Return bit i\n    virtual bool is_set(int i) const { return false; }\n    // Set bit i to 0\n    virtual void clear(int i) {}\n    // Zero out entire mask\n    virtual void zero() {}\n    // Copy src into this mask\n    virtual void copy(const Mask *src) {}\n    // this &= rhs\n    virtual void bitwise_and(const Mask *rhs) {}\n    // this |= rhs\n    virtual void bitwise_or(const Mask *rhs) {}\n    // this = ~this\n    virtual void bitwise_not() {}\n    // API for iterating over an affinity mask\n    // for (int i = mask->begin(); i != mask->end(); i = mask->next(i))\n    virtual int begin() const { return 0; }\n    virtual int end() const { return 0; }\n    virtual int next(int previous) const { return 0; }\n#if KMP_OS_WINDOWS\n    virtual int set_process_affinity(bool abort_on_error) const { return -1; }\n#endif\n    // Set the system's affinity to this affinity mask's value\n    virtual int set_system_affinity(bool abort_on_error) const { return -1; }\n    // Set this affinity mask to the current system affinity\n    virtual int get_system_affinity(bool abort_on_error) { return -1; }\n    // Only 1 DWORD in the mask should have any procs set.\n    // Return the appropriate index, or -1 for an invalid mask.\n    virtual int get_proc_group() const { return -1; }\n  };\n  void *operator new(size_t n);\n  void operator delete(void *p);\n  // Need virtual destructor\n  virtual ~KMPAffinity() = default;\n  // Determine if affinity is capable\n  virtual void determine_capable(const char *env_var) {}\n  // Bind the current thread to os proc\n  virtual void bind_thread(int proc) {}\n  // Factory functions to allocate/deallocate a mask\n  virtual Mask *allocate_mask() { return nullptr; }\n  virtual void deallocate_mask(Mask *m) {}\n  virtual Mask *allocate_mask_array(int num) { return nullptr; }\n  virtual void deallocate_mask_array(Mask *m) {}\n  virtual Mask *index_mask_array(Mask *m, int index) { return nullptr; }\n  static void pick_api();\n  static void destroy_api();\n  enum api_type {\n    NATIVE_OS\n#if KMP_USE_HWLOC\n    ,\n    HWLOC\n#endif\n  };\n  virtual api_type get_api_type() const {\n    KMP_ASSERT(0);\n    return NATIVE_OS;\n  }\n\nprivate:\n  static bool picked_api;\n};\n\ntypedef KMPAffinity::Mask kmp_affin_mask_t;\nextern KMPAffinity *__kmp_affinity_dispatch;\n\n// Declare local char buffers with this size for printing debug and info\n// messages, using __kmp_affinity_print_mask().\n#define KMP_AFFIN_MASK_PRINT_LEN 1024\n\nenum affinity_type {\n  affinity_none = 0,\n  affinity_physical,\n  affinity_logical,\n  affinity_compact,\n  affinity_scatter,\n  affinity_explicit,\n  affinity_balanced,\n  affinity_disabled, // not used outsize the env var parser\n  affinity_default\n};\n\nenum affinity_gran {\n  affinity_gran_fine = 0,\n  affinity_gran_thread,\n  affinity_gran_core,\n  affinity_gran_tile,\n  affinity_gran_die,\n  affinity_gran_numa,\n  affinity_gran_package,\n  affinity_gran_node,\n#if KMP_GROUP_AFFINITY\n  // The \"group\" granularity isn't necesssarily coarser than all of the\n  // other levels, but we put it last in the enum.\n  affinity_gran_group,\n#endif /* KMP_GROUP_AFFINITY */\n  affinity_gran_default\n};\n\nenum affinity_top_method {\n  affinity_top_method_all = 0, // try all (supported) methods, in order\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  affinity_top_method_apicid,\n  affinity_top_method_x2apicid,\n  affinity_top_method_x2apicid_1f,\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n  affinity_top_method_cpuinfo, // KMP_CPUINFO_FILE is usable on Windows* OS, too\n#if KMP_GROUP_AFFINITY\n  affinity_top_method_group,\n#endif /* KMP_GROUP_AFFINITY */\n  affinity_top_method_flat,\n#if KMP_USE_HWLOC\n  affinity_top_method_hwloc,\n#endif\n  affinity_top_method_default\n};\n\n#define affinity_respect_mask_default (-1)\n\nextern enum affinity_type __kmp_affinity_type; /* Affinity type */\nextern enum affinity_gran __kmp_affinity_gran; /* Affinity granularity */\nextern int __kmp_affinity_gran_levels; /* corresponding int value */\nextern int __kmp_affinity_dups; /* Affinity duplicate masks */\nextern enum affinity_top_method __kmp_affinity_top_method;\nextern int __kmp_affinity_compact; /* Affinity 'compact' value */\nextern int __kmp_affinity_offset; /* Affinity offset value  */\nextern int __kmp_affinity_verbose; /* Was verbose specified for KMP_AFFINITY? */\nextern int __kmp_affinity_warnings; /* KMP_AFFINITY warnings enabled ? */\nextern int __kmp_affinity_respect_mask; // Respect process' init affinity mask?\nextern char *__kmp_affinity_proclist; /* proc ID list */\nextern kmp_affin_mask_t *__kmp_affinity_masks;\nextern unsigned __kmp_affinity_num_masks;\nextern void __kmp_affinity_bind_thread(int which);\n\nextern kmp_affin_mask_t *__kmp_affin_fullMask;\nextern char *__kmp_cpuinfo_file;\n\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n// This needs to be kept in sync with the values in omp.h !!!\ntypedef enum kmp_proc_bind_t {\n  proc_bind_false = 0,\n  proc_bind_true,\n  proc_bind_primary,\n  proc_bind_close,\n  proc_bind_spread,\n  proc_bind_intel, // use KMP_AFFINITY interface\n  proc_bind_default\n} kmp_proc_bind_t;\n\ntypedef struct kmp_nested_proc_bind_t {\n  kmp_proc_bind_t *bind_types;\n  int size;\n  int used;\n} kmp_nested_proc_bind_t;\n\nextern kmp_nested_proc_bind_t __kmp_nested_proc_bind;\n\nextern int __kmp_display_affinity;\nextern char *__kmp_affinity_format;\nstatic const size_t KMP_AFFINITY_FORMAT_SIZE = 512;\n\n#if KMP_AFFINITY_SUPPORTED\n#define KMP_PLACE_ALL (-1)\n#define KMP_PLACE_UNDEFINED (-2)\n// Is KMP_AFFINITY is being used instead of OMP_PROC_BIND/OMP_PLACES?\n#define KMP_AFFINITY_NON_PROC_BIND                                             \\\n  ((__kmp_nested_proc_bind.bind_types[0] == proc_bind_false ||                 \\\n    __kmp_nested_proc_bind.bind_types[0] == proc_bind_intel) &&                \\\n   (__kmp_affinity_num_masks > 0 || __kmp_affinity_type == affinity_balanced))\n#endif /* KMP_AFFINITY_SUPPORTED */\n\nextern int __kmp_affinity_num_places;\n\ntypedef enum kmp_cancel_kind_t {\n  cancel_noreq = 0,\n  cancel_parallel = 1,\n  cancel_loop = 2,\n  cancel_sections = 3,\n  cancel_taskgroup = 4\n} kmp_cancel_kind_t;\n\n// KMP_HW_SUBSET support:\ntypedef struct kmp_hws_item {\n  int num;\n  int offset;\n} kmp_hws_item_t;\n\nextern kmp_hws_item_t __kmp_hws_socket;\nextern kmp_hws_item_t __kmp_hws_die;\nextern kmp_hws_item_t __kmp_hws_node;\nextern kmp_hws_item_t __kmp_hws_tile;\nextern kmp_hws_item_t __kmp_hws_core;\nextern kmp_hws_item_t __kmp_hws_proc;\nextern int __kmp_hws_requested;\nextern int __kmp_hws_abs_flag; // absolute or per-item number requested\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_PAD(type, sz)                                                      \\\n  (sizeof(type) + (sz - ((sizeof(type) - 1) % (sz)) - 1))\n\n// We need to avoid using -1 as a GTID as +1 is added to the gtid\n// when storing it in a lock, and the value 0 is reserved.\n#define KMP_GTID_DNE (-2) /* Does not exist */\n#define KMP_GTID_SHUTDOWN (-3) /* Library is shutting down */\n#define KMP_GTID_MONITOR (-4) /* Monitor thread ID */\n#define KMP_GTID_UNKNOWN (-5) /* Is not known */\n#define KMP_GTID_MIN (-6) /* Minimal gtid for low bound check in DEBUG */\n\n/* OpenMP 5.0 Memory Management support */\n\n#ifndef __OMP_H\n// Duplicate type definitions from omp.h\ntypedef uintptr_t omp_uintptr_t;\n\ntypedef enum {\n  omp_atk_sync_hint = 1,\n  omp_atk_alignment = 2,\n  omp_atk_access = 3,\n  omp_atk_pool_size = 4,\n  omp_atk_fallback = 5,\n  omp_atk_fb_data = 6,\n  omp_atk_pinned = 7,\n  omp_atk_partition = 8\n} omp_alloctrait_key_t;\n\ntypedef enum {\n  omp_atv_false = 0,\n  omp_atv_true = 1,\n  omp_atv_contended = 3,\n  omp_atv_uncontended = 4,\n  omp_atv_serialized = 5,\n  omp_atv_sequential = omp_atv_serialized, // (deprecated)\n  omp_atv_private = 6,\n  omp_atv_all = 7,\n  omp_atv_thread = 8,\n  omp_atv_pteam = 9,\n  omp_atv_cgroup = 10,\n  omp_atv_default_mem_fb = 11,\n  omp_atv_null_fb = 12,\n  omp_atv_abort_fb = 13,\n  omp_atv_allocator_fb = 14,\n  omp_atv_environment = 15,\n  omp_atv_nearest = 16,\n  omp_atv_blocked = 17,\n  omp_atv_interleaved = 18\n} omp_alloctrait_value_t;\n#define omp_atv_default ((omp_uintptr_t)-1)\n\ntypedef void *omp_memspace_handle_t;\nextern omp_memspace_handle_t const omp_default_mem_space;\nextern omp_memspace_handle_t const omp_large_cap_mem_space;\nextern omp_memspace_handle_t const omp_const_mem_space;\nextern omp_memspace_handle_t const omp_high_bw_mem_space;\nextern omp_memspace_handle_t const omp_low_lat_mem_space;\n// Preview of target memory support\nextern omp_memspace_handle_t const llvm_omp_target_host_mem_space;\nextern omp_memspace_handle_t const llvm_omp_target_shared_mem_space;\nextern omp_memspace_handle_t const llvm_omp_target_device_mem_space;\n\ntypedef struct {\n  omp_alloctrait_key_t key;\n  omp_uintptr_t value;\n} omp_alloctrait_t;\n\ntypedef void *omp_allocator_handle_t;\nextern omp_allocator_handle_t const omp_null_allocator;\nextern omp_allocator_handle_t const omp_default_mem_alloc;\nextern omp_allocator_handle_t const omp_large_cap_mem_alloc;\nextern omp_allocator_handle_t const omp_const_mem_alloc;\nextern omp_allocator_handle_t const omp_high_bw_mem_alloc;\nextern omp_allocator_handle_t const omp_low_lat_mem_alloc;\nextern omp_allocator_handle_t const omp_cgroup_mem_alloc;\nextern omp_allocator_handle_t const omp_pteam_mem_alloc;\nextern omp_allocator_handle_t const omp_thread_mem_alloc;\n// Preview of target memory support\nextern omp_allocator_handle_t const llvm_omp_target_host_mem_alloc;\nextern omp_allocator_handle_t const llvm_omp_target_shared_mem_alloc;\nextern omp_allocator_handle_t const llvm_omp_target_device_mem_alloc;\nextern omp_allocator_handle_t const kmp_max_mem_alloc;\nextern omp_allocator_handle_t __kmp_def_allocator;\n\n// end of duplicate type definitions from omp.h\n#endif\n\nextern int __kmp_memkind_available;\n\ntypedef omp_memspace_handle_t kmp_memspace_t; // placeholder\n\ntypedef struct kmp_allocator_t {\n  omp_memspace_handle_t memspace;\n  void **memkind; // pointer to memkind\n  int alignment;\n  omp_alloctrait_value_t fb;\n  kmp_allocator_t *fb_data;\n  kmp_uint64 pool_size;\n  kmp_uint64 pool_used;\n} kmp_allocator_t;\n\nextern omp_allocator_handle_t __kmpc_init_allocator(int gtid,\n                                                    omp_memspace_handle_t,\n                                                    int ntraits,\n                                                    omp_alloctrait_t traits[]);\nextern void __kmpc_destroy_allocator(int gtid, omp_allocator_handle_t al);\nextern void __kmpc_set_default_allocator(int gtid, omp_allocator_handle_t al);\nextern omp_allocator_handle_t __kmpc_get_default_allocator(int gtid);\nextern void *__kmpc_alloc(int gtid, size_t sz, omp_allocator_handle_t al);\nextern void *__kmpc_calloc(int gtid, size_t nmemb, size_t sz,\n                           omp_allocator_handle_t al);\nextern void *__kmpc_realloc(int gtid, void *ptr, size_t sz,\n                            omp_allocator_handle_t al,\n                            omp_allocator_handle_t free_al);\nextern void __kmpc_free(int gtid, void *ptr, omp_allocator_handle_t al);\n\nextern void __kmp_init_memkind();\nextern void __kmp_fini_memkind();\nextern void __kmp_init_target_mem();\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_UINT64_MAX                                                         \\\n  (~((kmp_uint64)1 << ((sizeof(kmp_uint64) * (1 << 3)) - 1)))\n\n#define KMP_MIN_NTH 1\n\n#ifndef KMP_MAX_NTH\n#if defined(PTHREAD_THREADS_MAX) && PTHREAD_THREADS_MAX < INT_MAX\n#define KMP_MAX_NTH PTHREAD_THREADS_MAX\n#else\n#define KMP_MAX_NTH INT_MAX\n#endif\n#endif /* KMP_MAX_NTH */\n\n#ifdef PTHREAD_STACK_MIN\n#define KMP_MIN_STKSIZE PTHREAD_STACK_MIN\n#else\n#define KMP_MIN_STKSIZE ((size_t)(32 * 1024))\n#endif\n\n#define KMP_MAX_STKSIZE (~((size_t)1 << ((sizeof(size_t) * (1 << 3)) - 1)))\n\n#if KMP_ARCH_X86\n#define KMP_DEFAULT_STKSIZE ((size_t)(2 * 1024 * 1024))\n#elif KMP_ARCH_X86_64\n#define KMP_DEFAULT_STKSIZE ((size_t)(4 * 1024 * 1024))\n#define KMP_BACKUP_STKSIZE ((size_t)(2 * 1024 * 1024))\n#else\n#define KMP_DEFAULT_STKSIZE ((size_t)(1024 * 1024))\n#endif\n\n#define KMP_DEFAULT_MALLOC_POOL_INCR ((size_t)(1024 * 1024))\n#define KMP_MIN_MALLOC_POOL_INCR ((size_t)(4 * 1024))\n#define KMP_MAX_MALLOC_POOL_INCR                                               \\\n  (~((size_t)1 << ((sizeof(size_t) * (1 << 3)) - 1)))\n\n#define KMP_MIN_STKOFFSET (0)\n#define KMP_MAX_STKOFFSET KMP_MAX_STKSIZE\n#if KMP_OS_DARWIN\n#define KMP_DEFAULT_STKOFFSET KMP_MIN_STKOFFSET\n#else\n#define KMP_DEFAULT_STKOFFSET CACHE_LINE\n#endif\n\n#define KMP_MIN_STKPADDING (0)\n#define KMP_MAX_STKPADDING (2 * 1024 * 1024)\n\n#define KMP_BLOCKTIME_MULTIPLIER                                               \\\n  (1000) /* number of blocktime units per second */\n#define KMP_MIN_BLOCKTIME (0)\n#define KMP_MAX_BLOCKTIME                                                      \\\n  (INT_MAX) /* Must be this for \"infinite\" setting the work */\n#define KMP_DEFAULT_BLOCKTIME (200) /*  __kmp_blocktime is in milliseconds  */\n\n#if KMP_USE_MONITOR\n#define KMP_DEFAULT_MONITOR_STKSIZE ((size_t)(64 * 1024))\n#define KMP_MIN_MONITOR_WAKEUPS (1) // min times monitor wakes up per second\n#define KMP_MAX_MONITOR_WAKEUPS (1000) // max times monitor can wake up per sec\n\n/* Calculate new number of monitor wakeups for a specific block time based on\n   previous monitor_wakeups. Only allow increasing number of wakeups */\n#define KMP_WAKEUPS_FROM_BLOCKTIME(blocktime, monitor_wakeups)                 \\\n  (((blocktime) == KMP_MAX_BLOCKTIME)   ? (monitor_wakeups)                    \\\n   : ((blocktime) == KMP_MIN_BLOCKTIME) ? KMP_MAX_MONITOR_WAKEUPS              \\\n   : ((monitor_wakeups) > (KMP_BLOCKTIME_MULTIPLIER / (blocktime)))            \\\n       ? (monitor_wakeups)                                                     \\\n       : (KMP_BLOCKTIME_MULTIPLIER) / (blocktime))\n\n/* Calculate number of intervals for a specific block time based on\n   monitor_wakeups */\n#define KMP_INTERVALS_FROM_BLOCKTIME(blocktime, monitor_wakeups)               \\\n  (((blocktime) + (KMP_BLOCKTIME_MULTIPLIER / (monitor_wakeups)) - 1) /        \\\n   (KMP_BLOCKTIME_MULTIPLIER / (monitor_wakeups)))\n#else\n#define KMP_BLOCKTIME(team, tid)                                               \\\n  (get__bt_set(team, tid) ? get__blocktime(team, tid) : __kmp_dflt_blocktime)\n#if KMP_OS_UNIX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n// HW TSC is used to reduce overhead (clock tick instead of nanosecond).\nextern kmp_uint64 __kmp_ticks_per_msec;\n#if KMP_COMPILER_ICC\n#define KMP_NOW() ((kmp_uint64)_rdtsc())\n#else\n#define KMP_NOW() __kmp_hardware_timestamp()\n#endif\n#define KMP_NOW_MSEC() (KMP_NOW() / __kmp_ticks_per_msec)\n#define KMP_BLOCKTIME_INTERVAL(team, tid)                                      \\\n  (KMP_BLOCKTIME(team, tid) * __kmp_ticks_per_msec)\n#define KMP_BLOCKING(goal, count) ((goal) > KMP_NOW())\n#else\n// System time is retrieved sporadically while blocking.\nextern kmp_uint64 __kmp_now_nsec();\n#define KMP_NOW() __kmp_now_nsec()\n#define KMP_NOW_MSEC() (KMP_NOW() / KMP_USEC_PER_SEC)\n#define KMP_BLOCKTIME_INTERVAL(team, tid)                                      \\\n  (KMP_BLOCKTIME(team, tid) * KMP_USEC_PER_SEC)\n#define KMP_BLOCKING(goal, count) ((count) % 1000 != 0 || (goal) > KMP_NOW())\n#endif\n#endif // KMP_USE_MONITOR\n\n#define KMP_MIN_STATSCOLS 40\n#define KMP_MAX_STATSCOLS 4096\n#define KMP_DEFAULT_STATSCOLS 80\n\n#define KMP_MIN_INTERVAL 0\n#define KMP_MAX_INTERVAL (INT_MAX - 1)\n#define KMP_DEFAULT_INTERVAL 0\n\n#define KMP_MIN_CHUNK 1\n#define KMP_MAX_CHUNK (INT_MAX - 1)\n#define KMP_DEFAULT_CHUNK 1\n\n#define KMP_MIN_DISP_NUM_BUFF 1\n#define KMP_DFLT_DISP_NUM_BUFF 7\n#define KMP_MAX_DISP_NUM_BUFF 4096\n\n#define KMP_MAX_ORDERED 8\n\n#define KMP_MAX_FIELDS 32\n\n#define KMP_MAX_BRANCH_BITS 31\n\n#define KMP_MAX_ACTIVE_LEVELS_LIMIT INT_MAX\n\n#define KMP_MAX_DEFAULT_DEVICE_LIMIT INT_MAX\n\n#define KMP_MAX_TASK_PRIORITY_LIMIT INT_MAX\n\n/* Minimum number of threads before switch to TLS gtid (experimentally\n   determined) */\n/* josh TODO: what about OS X* tuning? */\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_TLS_GTID_MIN 5\n#else\n#define KMP_TLS_GTID_MIN INT_MAX\n#endif\n\n#define KMP_MASTER_TID(tid) (0 == (tid))\n#define KMP_WORKER_TID(tid) (0 != (tid))\n\n#define KMP_MASTER_GTID(gtid) (0 == __kmp_tid_from_gtid((gtid)))\n#define KMP_WORKER_GTID(gtid) (0 != __kmp_tid_from_gtid((gtid)))\n#define KMP_INITIAL_GTID(gtid) (0 == (gtid))\n\n#ifndef TRUE\n#define FALSE 0\n#define TRUE (!FALSE)\n#endif\n\n/* NOTE: all of the following constants must be even */\n\n#if KMP_OS_WINDOWS\n#define KMP_INIT_WAIT 64U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 32U /* susequent number of spin-tests */\n#elif KMP_OS_LINUX\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_DARWIN\n/* TODO: tune for KMP_OS_DARWIN */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_DRAGONFLY\n/* TODO: tune for KMP_OS_DRAGONFLY */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_FREEBSD\n/* TODO: tune for KMP_OS_FREEBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_NETBSD\n/* TODO: tune for KMP_OS_NETBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_HURD\n/* TODO: tune for KMP_OS_HURD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_OPENBSD\n/* TODO: tune for KMP_OS_OPENBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\ntypedef struct kmp_cpuid {\n  kmp_uint32 eax;\n  kmp_uint32 ebx;\n  kmp_uint32 ecx;\n  kmp_uint32 edx;\n} kmp_cpuid_t;\n\ntypedef struct kmp_cpuinfo {\n  int initialized; // If 0, other fields are not initialized.\n  int signature; // CPUID(1).EAX\n  int family; // CPUID(1).EAX[27:20]+CPUID(1).EAX[11:8] (Extended Family+Family)\n  int model; // ( CPUID(1).EAX[19:16] << 4 ) + CPUID(1).EAX[7:4] ( ( Extended\n  // Model << 4 ) + Model)\n  int stepping; // CPUID(1).EAX[3:0] ( Stepping )\n  int sse2; // 0 if SSE2 instructions are not supported, 1 otherwise.\n  int rtm; // 0 if RTM instructions are not supported, 1 otherwise.\n  int cpu_stackoffset;\n  int apic_id;\n  int physical_id;\n  int logical_id;\n  kmp_uint64 frequency; // Nominal CPU frequency in Hz.\n  char name[3 * sizeof(kmp_cpuid_t)]; // CPUID(0x80000002,0x80000003,0x80000004)\n} kmp_cpuinfo_t;\n\nextern void __kmp_query_cpuid(kmp_cpuinfo_t *p);\n\n#if KMP_OS_UNIX\n// subleaf is only needed for cache and topology discovery and can be set to\n// zero in most cases\nstatic inline void __kmp_x86_cpuid(int leaf, int subleaf, struct kmp_cpuid *p) {\n  __asm__ __volatile__(\"cpuid\"\n                       : \"=a\"(p->eax), \"=b\"(p->ebx), \"=c\"(p->ecx), \"=d\"(p->edx)\n                       : \"a\"(leaf), \"c\"(subleaf));\n}\n// Load p into FPU control word\nstatic inline void __kmp_load_x87_fpu_control_word(const kmp_int16 *p) {\n  __asm__ __volatile__(\"fldcw %0\" : : \"m\"(*p));\n}\n// Store FPU control word into p\nstatic inline void __kmp_store_x87_fpu_control_word(kmp_int16 *p) {\n  __asm__ __volatile__(\"fstcw %0\" : \"=m\"(*p));\n}\nstatic inline void __kmp_clear_x87_fpu_status_word() {\n#if KMP_MIC\n  // 32-bit protected mode x87 FPU state\n  struct x87_fpu_state {\n    unsigned cw;\n    unsigned sw;\n    unsigned tw;\n    unsigned fip;\n    unsigned fips;\n    unsigned fdp;\n    unsigned fds;\n  };\n  struct x87_fpu_state fpu_state = {0, 0, 0, 0, 0, 0, 0};\n  __asm__ __volatile__(\"fstenv %0\\n\\t\" // store FP env\n                       \"andw $0x7f00, %1\\n\\t\" // clear 0-7,15 bits of FP SW\n                       \"fldenv %0\\n\\t\" // load FP env back\n                       : \"+m\"(fpu_state), \"+m\"(fpu_state.sw));\n#else\n  __asm__ __volatile__(\"fnclex\");\n#endif // KMP_MIC\n}\n#if __SSE__\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) { _mm_setcsr(*p); }\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = _mm_getcsr(); }\n#else\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) {}\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = 0; }\n#endif\n#else\n// Windows still has these as external functions in assembly file\nextern void __kmp_x86_cpuid(int mode, int mode2, struct kmp_cpuid *p);\nextern void __kmp_load_x87_fpu_control_word(const kmp_int16 *p);\nextern void __kmp_store_x87_fpu_control_word(kmp_int16 *p);\nextern void __kmp_clear_x87_fpu_status_word();\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) { _mm_setcsr(*p); }\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = _mm_getcsr(); }\n#endif // KMP_OS_UNIX\n\n#define KMP_X86_MXCSR_MASK 0xffffffc0 /* ignore status flags (6 lsb) */\n\n#if KMP_ARCH_X86\nextern void __kmp_x86_pause(void);\n#elif KMP_MIC\n// Performance testing on KNC (C0QS-7120 P/A/X/D, 61-core, 16 GB Memory) showed\n// regression after removal of extra PAUSE from spin loops. Changing\n// the delay from 100 to 300 showed even better performance than double PAUSE\n// on Spec OMP2001 and LCPC tasking tests, no regressions on EPCC.\nstatic inline void __kmp_x86_pause(void) { _mm_delay_32(300); }\n#else\nstatic inline void __kmp_x86_pause(void) { _mm_pause(); }\n#endif\n#define KMP_CPU_PAUSE() __kmp_x86_pause()\n#elif KMP_ARCH_PPC64\n#define KMP_PPC64_PRI_LOW() __asm__ volatile(\"or 1, 1, 1\")\n#define KMP_PPC64_PRI_MED() __asm__ volatile(\"or 2, 2, 2\")\n#define KMP_PPC64_PRI_LOC_MB() __asm__ volatile(\"\" : : : \"memory\")\n#define KMP_CPU_PAUSE()                                                        \\\n  do {                                                                         \\\n    KMP_PPC64_PRI_LOW();                                                       \\\n    KMP_PPC64_PRI_MED();                                                       \\\n    KMP_PPC64_PRI_LOC_MB();                                                    \\\n  } while (0)\n#else\n#define KMP_CPU_PAUSE() /* nothing to do */\n#endif\n\n#define KMP_INIT_YIELD(count)                                                  \\\n  { (count) = __kmp_yield_init; }\n\n#define KMP_OVERSUBSCRIBED                                                     \\\n  (TCR_4(__kmp_nth) > (__kmp_avail_proc ? __kmp_avail_proc : __kmp_xproc))\n\n#define KMP_TRY_YIELD                                                          \\\n  ((__kmp_use_yield == 1) || (__kmp_use_yield == 2 && (KMP_OVERSUBSCRIBED)))\n\n#define KMP_TRY_YIELD_OVERSUB                                                  \\\n  ((__kmp_use_yield == 1 || __kmp_use_yield == 2) && (KMP_OVERSUBSCRIBED))\n\n#define KMP_YIELD(cond)                                                        \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((cond) && (KMP_TRY_YIELD))                                             \\\n      __kmp_yield();                                                           \\\n  }\n\n#define KMP_YIELD_OVERSUB()                                                    \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((KMP_TRY_YIELD_OVERSUB))                                               \\\n      __kmp_yield();                                                           \\\n  }\n\n// Note the decrement of 2 in the following Macros. With KMP_LIBRARY=turnaround,\n// there should be no yielding since initial value from KMP_INIT_YIELD() is odd.\n#define KMP_YIELD_SPIN(count)                                                  \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if (KMP_TRY_YIELD) {                                                       \\\n      (count) -= 2;                                                            \\\n      if (!(count)) {                                                          \\\n        __kmp_yield();                                                         \\\n        (count) = __kmp_yield_next;                                            \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n#define KMP_YIELD_OVERSUB_ELSE_SPIN(count)                                     \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((KMP_TRY_YIELD_OVERSUB))                                               \\\n      __kmp_yield();                                                           \\\n    else if (__kmp_use_yield == 1) {                                           \\\n      (count) -= 2;                                                            \\\n      if (!(count)) {                                                          \\\n        __kmp_yield();                                                         \\\n        (count) = __kmp_yield_next;                                            \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n// User-level Monitor/Mwait\n#if KMP_HAVE_UMWAIT\n// We always try for UMWAIT first\n#if KMP_HAVE_WAITPKG_INTRINSICS\n#if KMP_HAVE_IMMINTRIN_H\n#include <immintrin.h>\n#elif KMP_HAVE_INTRIN_H\n#include <intrin.h>\n#endif\n#endif // KMP_HAVE_WAITPKG_INTRINSICS\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline int __kmp_tpause(uint32_t hint, uint64_t counter) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  uint32_t timeHi = uint32_t(counter >> 32);\n  uint32_t timeLo = uint32_t(counter & 0xffffffff);\n  char flag;\n  __asm__ volatile(\"#tpause\\n.byte 0x66, 0x0F, 0xAE, 0xF1\\n\"\n                   \"setb   %0\"\n                   : \"=r\"(flag)\n                   : \"a\"(timeLo), \"d\"(timeHi), \"c\"(hint)\n                   :);\n  return flag;\n#else\n  return _tpause(hint, counter);\n#endif\n}\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline void __kmp_umonitor(void *cacheline) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  __asm__ volatile(\"# umonitor\\n.byte 0xF3, 0x0F, 0xAE, 0x01 \"\n                   :\n                   : \"a\"(cacheline)\n                   :);\n#else\n  _umonitor(cacheline);\n#endif\n}\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline int __kmp_umwait(uint32_t hint, uint64_t counter) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  uint32_t timeHi = uint32_t(counter >> 32);\n  uint32_t timeLo = uint32_t(counter & 0xffffffff);\n  char flag;\n  __asm__ volatile(\"#umwait\\n.byte 0xF2, 0x0F, 0xAE, 0xF1\\n\"\n                   \"setb   %0\"\n                   : \"=r\"(flag)\n                   : \"a\"(timeLo), \"d\"(timeHi), \"c\"(hint)\n                   :);\n  return flag;\n#else\n  return _umwait(hint, counter);\n#endif\n}\n#elif KMP_HAVE_MWAIT\n#if KMP_OS_UNIX\n#include <pmmintrin.h>\n#else\n#include <intrin.h>\n#endif\n#if KMP_OS_UNIX\n__attribute__((target(\"sse3\")))\n#endif\nstatic inline void\n__kmp_mm_monitor(void *cacheline, unsigned extensions, unsigned hints) {\n  _mm_monitor(cacheline, extensions, hints);\n}\n#if KMP_OS_UNIX\n__attribute__((target(\"sse3\")))\n#endif\nstatic inline void\n__kmp_mm_mwait(unsigned extensions, unsigned hints) {\n  _mm_mwait(extensions, hints);\n}\n#endif // KMP_HAVE_UMWAIT\n\n/* ------------------------------------------------------------------------ */\n/* Support datatypes for the orphaned construct nesting checks.             */\n/* ------------------------------------------------------------------------ */\n\nenum cons_type {\n  ct_none,\n  ct_parallel,\n  ct_pdo,\n  ct_pdo_ordered,\n  ct_psections,\n  ct_psingle,\n  ct_critical,\n  ct_ordered_in_parallel,\n  ct_ordered_in_pdo,\n  ct_master,\n  ct_reduce,\n  ct_barrier,\n  ct_masked\n};\n\n#define IS_CONS_TYPE_ORDERED(ct) ((ct) == ct_pdo_ordered)\n\nstruct cons_data {\n  ident_t const *ident;\n  enum cons_type type;\n  int prev;\n  kmp_user_lock_p\n      name; /* address exclusively for critical section name comparison */\n};\n\nstruct cons_header {\n  int p_top, w_top, s_top;\n  int stack_size, stack_top;\n  struct cons_data *stack_data;\n};\n\nstruct kmp_region_info {\n  char *text;\n  int offset[KMP_MAX_FIELDS];\n  int length[KMP_MAX_FIELDS];\n};\n\n/* ---------------------------------------------------------------------- */\n/* ---------------------------------------------------------------------- */\n\n#if KMP_OS_WINDOWS\ntypedef HANDLE kmp_thread_t;\ntypedef DWORD kmp_key_t;\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_OS_UNIX\ntypedef pthread_t kmp_thread_t;\ntypedef pthread_key_t kmp_key_t;\n#endif\n\nextern kmp_key_t __kmp_gtid_threadprivate_key;\n\ntypedef struct kmp_sys_info {\n  long maxrss; /* the maximum resident set size utilized (in kilobytes)     */\n  long minflt; /* the number of page faults serviced without any I/O        */\n  long majflt; /* the number of page faults serviced that required I/O      */\n  long nswap; /* the number of times a process was \"swapped\" out of memory */\n  long inblock; /* the number of times the file system had to perform input  */\n  long oublock; /* the number of times the file system had to perform output */\n  long nvcsw; /* the number of times a context switch was voluntarily      */\n  long nivcsw; /* the number of times a context switch was forced           */\n} kmp_sys_info_t;\n\n#if USE_ITT_BUILD\n// We cannot include \"kmp_itt.h\" due to circular dependency. Declare the only\n// required type here. Later we will check the type meets requirements.\ntypedef int kmp_itt_mark_t;\n#define KMP_ITT_DEBUG 0\n#endif /* USE_ITT_BUILD */\n\ntypedef kmp_int32 kmp_critical_name[8];\n\n/*!\n@ingroup PARALLEL\nThe type for a microtask which gets passed to @ref __kmpc_fork_call().\nThe arguments to the outlined function are\n@param global_tid the global thread identity of the thread executing the\nfunction.\n@param bound_tid  the local identity of the thread executing the function\n@param ... pointers to shared variables accessed by the function.\n*/\ntypedef void (*kmpc_micro)(kmp_int32 *global_tid, kmp_int32 *bound_tid, ...);\ntypedef void (*kmpc_micro_bound)(kmp_int32 *bound_tid, kmp_int32 *bound_nth,\n                                 ...);\n\n/*!\n@ingroup THREADPRIVATE\n@{\n*/\n/* ---------------------------------------------------------------------------\n */\n/* Threadprivate initialization/finalization function declarations */\n\n/*  for non-array objects:  __kmpc_threadprivate_register()  */\n\n/*!\n Pointer to the constructor function.\n The first argument is the <tt>this</tt> pointer\n*/\ntypedef void *(*kmpc_ctor)(void *);\n\n/*!\n Pointer to the destructor function.\n The first argument is the <tt>this</tt> pointer\n*/\ntypedef void (*kmpc_dtor)(\n    void * /*, size_t */); /* 2nd arg: magic number for KCC unused by Intel\n                              compiler */\n/*!\n Pointer to an alternate constructor.\n The first argument is the <tt>this</tt> pointer.\n*/\ntypedef void *(*kmpc_cctor)(void *, void *);\n\n/* for array objects: __kmpc_threadprivate_register_vec() */\n/* First arg: \"this\" pointer */\n/* Last arg: number of array elements */\n/*!\n Array constructor.\n First argument is the <tt>this</tt> pointer\n Second argument the number of array elements.\n*/\ntypedef void *(*kmpc_ctor_vec)(void *, size_t);\n/*!\n Pointer to the array destructor function.\n The first argument is the <tt>this</tt> pointer\n Second argument the number of array elements.\n*/\ntypedef void (*kmpc_dtor_vec)(void *, size_t);\n/*!\n Array constructor.\n First argument is the <tt>this</tt> pointer\n Third argument the number of array elements.\n*/\ntypedef void *(*kmpc_cctor_vec)(void *, void *,\n                                size_t); /* function unused by compiler */\n\n/*!\n@}\n*/\n\n/* keeps tracked of threadprivate cache allocations for cleanup later */\ntypedef struct kmp_cached_addr {\n  void **addr; /* address of allocated cache */\n  void ***compiler_cache; /* pointer to compiler's cache */\n  void *data; /* pointer to global data */\n  struct kmp_cached_addr *next; /* pointer to next cached address */\n} kmp_cached_addr_t;\n\nstruct private_data {\n  struct private_data *next; /* The next descriptor in the list      */\n  void *data; /* The data buffer for this descriptor  */\n  int more; /* The repeat count for this descriptor */\n  size_t size; /* The data size for this descriptor    */\n};\n\nstruct private_common {\n  struct private_common *next;\n  struct private_common *link;\n  void *gbl_addr;\n  void *par_addr; /* par_addr == gbl_addr for PRIMARY thread */\n  size_t cmn_size;\n};\n\nstruct shared_common {\n  struct shared_common *next;\n  struct private_data *pod_init;\n  void *obj_init;\n  void *gbl_addr;\n  union {\n    kmpc_ctor ctor;\n    kmpc_ctor_vec ctorv;\n  } ct;\n  union {\n    kmpc_cctor cctor;\n    kmpc_cctor_vec cctorv;\n  } cct;\n  union {\n    kmpc_dtor dtor;\n    kmpc_dtor_vec dtorv;\n  } dt;\n  size_t vec_len;\n  int is_vec;\n  size_t cmn_size;\n};\n\n#define KMP_HASH_TABLE_LOG2 9 /* log2 of the hash table size */\n#define KMP_HASH_TABLE_SIZE                                                    \\\n  (1 << KMP_HASH_TABLE_LOG2) /* size of the hash table */\n#define KMP_HASH_SHIFT 3 /* throw away this many low bits from the address */\n#define KMP_HASH(x)                                                            \\\n  ((((kmp_uintptr_t)x) >> KMP_HASH_SHIFT) & (KMP_HASH_TABLE_SIZE - 1))\n\nstruct common_table {\n  struct private_common *data[KMP_HASH_TABLE_SIZE];\n};\n\nstruct shared_table {\n  struct shared_common *data[KMP_HASH_TABLE_SIZE];\n};\n\n/* ------------------------------------------------------------------------ */\n\n#if KMP_USE_HIER_SCHED\n// Shared barrier data that exists inside a single unit of the scheduling\n// hierarchy\ntypedef struct kmp_hier_private_bdata_t {\n  kmp_int32 num_active;\n  kmp_uint64 index;\n  kmp_uint64 wait_val[2];\n} kmp_hier_private_bdata_t;\n#endif\n\ntypedef struct kmp_sched_flags {\n  unsigned ordered : 1;\n  unsigned nomerge : 1;\n  unsigned contains_last : 1;\n#if KMP_USE_HIER_SCHED\n  unsigned use_hier : 1;\n  unsigned unused : 28;\n#else\n  unsigned unused : 29;\n#endif\n} kmp_sched_flags_t;\n\nKMP_BUILD_ASSERT(sizeof(kmp_sched_flags_t) == 4);\n\n#if KMP_STATIC_STEAL_ENABLED\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info32 {\n  kmp_int32 count;\n  kmp_int32 ub;\n  /* Adding KMP_ALIGN_CACHE here doesn't help / can hurt performance */\n  kmp_int32 lb;\n  kmp_int32 st;\n  kmp_int32 tc;\n  kmp_int32 static_steal_counter; /* for static_steal only; maybe better to put\n                                     after ub */\n  kmp_lock_t *th_steal_lock; // lock used for chunk stealing\n  // KMP_ALIGN( 16 ) ensures ( if the KMP_ALIGN macro is turned on )\n  //    a) parm3 is properly aligned and\n  //    b) all parm1-4 are in the same cache line.\n  // Because of parm1-4 are used together, performance seems to be better\n  // if they are in the same line (not measured though).\n\n  struct KMP_ALIGN(32) { // AC: changed 16 to 32 in order to simplify template\n    kmp_int32 parm1; //     structures in kmp_dispatch.cpp. This should\n    kmp_int32 parm2; //     make no real change at least while padding is off.\n    kmp_int32 parm3;\n    kmp_int32 parm4;\n  };\n\n  kmp_uint32 ordered_lower;\n  kmp_uint32 ordered_upper;\n#if KMP_OS_WINDOWS\n  // This var can be placed in the hole between 'tc' and 'parm1', instead of\n  // 'static_steal_counter'. It would be nice to measure execution times.\n  // Conditional if/endif can be removed at all.\n  kmp_int32 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info32_t;\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info64 {\n  kmp_int64 count; // current chunk number for static & static-steal scheduling\n  kmp_int64 ub; /* upper-bound */\n  /* Adding KMP_ALIGN_CACHE here doesn't help / can hurt performance */\n  kmp_int64 lb; /* lower-bound */\n  kmp_int64 st; /* stride */\n  kmp_int64 tc; /* trip count (number of iterations) */\n  kmp_int64 static_steal_counter; /* for static_steal only; maybe better to put\n                                     after ub */\n  kmp_lock_t *th_steal_lock; // lock used for chunk stealing\n  /* parm[1-4] are used in different ways by different scheduling algorithms */\n\n  // KMP_ALIGN( 32 ) ensures ( if the KMP_ALIGN macro is turned on )\n  //    a) parm3 is properly aligned and\n  //    b) all parm1-4 are in the same cache line.\n  // Because of parm1-4 are used together, performance seems to be better\n  // if they are in the same line (not measured though).\n\n  struct KMP_ALIGN(32) {\n    kmp_int64 parm1;\n    kmp_int64 parm2;\n    kmp_int64 parm3;\n    kmp_int64 parm4;\n  };\n\n  kmp_uint64 ordered_lower;\n  kmp_uint64 ordered_upper;\n#if KMP_OS_WINDOWS\n  // This var can be placed in the hole between 'tc' and 'parm1', instead of\n  // 'static_steal_counter'. It would be nice to measure execution times.\n  // Conditional if/endif can be removed at all.\n  kmp_int64 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info64_t;\n#else /* KMP_STATIC_STEAL_ENABLED */\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info32 {\n  kmp_int32 lb;\n  kmp_int32 ub;\n  kmp_int32 st;\n  kmp_int32 tc;\n\n  kmp_int32 parm1;\n  kmp_int32 parm2;\n  kmp_int32 parm3;\n  kmp_int32 parm4;\n\n  kmp_int32 count;\n\n  kmp_uint32 ordered_lower;\n  kmp_uint32 ordered_upper;\n#if KMP_OS_WINDOWS\n  kmp_int32 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info32_t;\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info64 {\n  kmp_int64 lb; /* lower-bound */\n  kmp_int64 ub; /* upper-bound */\n  kmp_int64 st; /* stride */\n  kmp_int64 tc; /* trip count (number of iterations) */\n\n  /* parm[1-4] are used in different ways by different scheduling algorithms */\n  kmp_int64 parm1;\n  kmp_int64 parm2;\n  kmp_int64 parm3;\n  kmp_int64 parm4;\n\n  kmp_int64 count; /* current chunk number for static scheduling */\n\n  kmp_uint64 ordered_lower;\n  kmp_uint64 ordered_upper;\n#if KMP_OS_WINDOWS\n  kmp_int64 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info64_t;\n#endif /* KMP_STATIC_STEAL_ENABLED */\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info {\n  union private_info {\n    dispatch_private_info32_t p32;\n    dispatch_private_info64_t p64;\n  } u;\n  enum sched_type schedule; /* scheduling algorithm */\n  kmp_sched_flags_t flags; /* flags (e.g., ordered, nomerge, etc.) */\n  kmp_int32 ordered_bumped;\n  // To retain the structure size after making ordered_iteration scalar\n  kmp_int32 ordered_dummy[KMP_MAX_ORDERED - 3];\n  // Stack of buffers for nest of serial regions\n  struct dispatch_private_info *next;\n  kmp_int32 type_size; /* the size of types in private_info */\n#if KMP_USE_HIER_SCHED\n  kmp_int32 hier_id;\n  void *parent; /* hierarchical scheduling parent pointer */\n#endif\n  enum cons_type pushed_ws;\n} dispatch_private_info_t;\n\ntypedef struct dispatch_shared_info32 {\n  /* chunk index under dynamic, number of idle threads under static-steal;\n     iteration index otherwise */\n  volatile kmp_uint32 iteration;\n  volatile kmp_uint32 num_done;\n  volatile kmp_uint32 ordered_iteration;\n  // Dummy to retain the structure size after making ordered_iteration scalar\n  kmp_int32 ordered_dummy[KMP_MAX_ORDERED - 1];\n} dispatch_shared_info32_t;\n\ntypedef struct dispatch_shared_info64 {\n  /* chunk index under dynamic, number of idle threads under static-steal;\n     iteration index otherwise */\n  volatile kmp_uint64 iteration;\n  volatile kmp_uint64 num_done;\n  volatile kmp_uint64 ordered_iteration;\n  // Dummy to retain the structure size after making ordered_iteration scalar\n  kmp_int64 ordered_dummy[KMP_MAX_ORDERED - 3];\n} dispatch_shared_info64_t;\n\ntypedef struct dispatch_shared_info {\n  union shared_info {\n    dispatch_shared_info32_t s32;\n    dispatch_shared_info64_t s64;\n  } u;\n  volatile kmp_uint32 buffer_index;\n  volatile kmp_int32 doacross_buf_idx; // teamwise index\n  volatile kmp_uint32 *doacross_flags; // shared array of iteration flags (0/1)\n  kmp_int32 doacross_num_done; // count finished threads\n#if KMP_USE_HIER_SCHED\n  void *hier;\n#endif\n#if KMP_USE_HWLOC\n  // When linking with libhwloc, the ORDERED EPCC test slows down on big\n  // machines (> 48 cores). Performance analysis showed that a cache thrash\n  // was occurring and this padding helps alleviate the problem.\n  char padding[64];\n#endif\n} dispatch_shared_info_t;\n\ntypedef struct kmp_disp {\n  /* Vector for ORDERED SECTION */\n  void (*th_deo_fcn)(int *gtid, int *cid, ident_t *);\n  /* Vector for END ORDERED SECTION */\n  void (*th_dxo_fcn)(int *gtid, int *cid, ident_t *);\n\n  dispatch_shared_info_t *th_dispatch_sh_current;\n  dispatch_private_info_t *th_dispatch_pr_current;\n\n  dispatch_private_info_t *th_disp_buffer;\n  kmp_int32 th_disp_index;\n  kmp_int32 th_doacross_buf_idx; // thread's doacross buffer index\n  volatile kmp_uint32 *th_doacross_flags; // pointer to shared array of flags\n  kmp_int64 *th_doacross_info; // info on loop bounds\n#if KMP_USE_INTERNODE_ALIGNMENT\n  char more_padding[INTERNODE_CACHE_LINE];\n#endif\n} kmp_disp_t;\n\n/* ------------------------------------------------------------------------ */\n/* Barrier stuff */\n\n/* constants for barrier state update */\n#define KMP_INIT_BARRIER_STATE 0 /* should probably start from zero */\n#define KMP_BARRIER_SLEEP_BIT 0 /* bit used for suspend/sleep part of state */\n#define KMP_BARRIER_UNUSED_BIT 1 // bit that must never be set for valid state\n#define KMP_BARRIER_BUMP_BIT 2 /* lsb used for bump of go/arrived state */\n\n#define KMP_BARRIER_SLEEP_STATE (1 << KMP_BARRIER_SLEEP_BIT)\n#define KMP_BARRIER_UNUSED_STATE (1 << KMP_BARRIER_UNUSED_BIT)\n#define KMP_BARRIER_STATE_BUMP (1 << KMP_BARRIER_BUMP_BIT)\n\n#if (KMP_BARRIER_SLEEP_BIT >= KMP_BARRIER_BUMP_BIT)\n#error \"Barrier sleep bit must be smaller than barrier bump bit\"\n#endif\n#if (KMP_BARRIER_UNUSED_BIT >= KMP_BARRIER_BUMP_BIT)\n#error \"Barrier unused bit must be smaller than barrier bump bit\"\n#endif\n\n// Constants for release barrier wait state: currently, hierarchical only\n#define KMP_BARRIER_NOT_WAITING 0 // Normal state; worker not in wait_sleep\n#define KMP_BARRIER_OWN_FLAG                                                   \\\n  1 // Normal state; worker waiting on own b_go flag in release\n#define KMP_BARRIER_PARENT_FLAG                                                \\\n  2 // Special state; worker waiting on parent's b_go flag in release\n#define KMP_BARRIER_SWITCH_TO_OWN_FLAG                                         \\\n  3 // Special state; tells worker to shift from parent to own b_go\n#define KMP_BARRIER_SWITCHING                                                  \\\n  4 // Special state; worker resets appropriate flag on wake-up\n\n#define KMP_NOT_SAFE_TO_REAP                                                   \\\n  0 // Thread th_reap_state: not safe to reap (tasking)\n#define KMP_SAFE_TO_REAP 1 // Thread th_reap_state: safe to reap (not tasking)\n\nenum barrier_type {\n  bs_plain_barrier = 0, /* 0, All non-fork/join barriers (except reduction\n                           barriers if enabled) */\n  bs_forkjoin_barrier, /* 1, All fork/join (parallel region) barriers */\n#if KMP_FAST_REDUCTION_BARRIER\n  bs_reduction_barrier, /* 2, All barriers that are used in reduction */\n#endif // KMP_FAST_REDUCTION_BARRIER\n  bs_last_barrier /* Just a placeholder to mark the end */\n};\n\n// to work with reduction barriers just like with plain barriers\n#if !KMP_FAST_REDUCTION_BARRIER\n#define bs_reduction_barrier bs_plain_barrier\n#endif // KMP_FAST_REDUCTION_BARRIER\n\ntypedef enum kmp_bar_pat { /* Barrier communication patterns */\n                           bp_linear_bar =\n                               0, /* Single level (degenerate) tree */\n                           bp_tree_bar =\n                               1, /* Balanced tree with branching factor 2^n */\n                           bp_hyper_bar = 2, /* Hypercube-embedded tree with min\n                                                branching factor 2^n */\n                           bp_hierarchical_bar = 3, /* Machine hierarchy tree */\n                           bp_last_bar /* Placeholder to mark the end */\n} kmp_bar_pat_e;\n\n#define KMP_BARRIER_ICV_PUSH 1\n\n/* Record for holding the values of the internal controls stack records */\ntypedef struct kmp_internal_control {\n  int serial_nesting_level; /* corresponds to the value of the\n                               th_team_serialized field */\n  kmp_int8 dynamic; /* internal control for dynamic adjustment of threads (per\n                       thread) */\n  kmp_int8\n      bt_set; /* internal control for whether blocktime is explicitly set */\n  int blocktime; /* internal control for blocktime */\n#if KMP_USE_MONITOR\n  int bt_intervals; /* internal control for blocktime intervals */\n#endif\n  int nproc; /* internal control for #threads for next parallel region (per\n                thread) */\n  int thread_limit; /* internal control for thread-limit-var */\n  int max_active_levels; /* internal control for max_active_levels */\n  kmp_r_sched_t\n      sched; /* internal control for runtime schedule {sched,chunk} pair */\n  kmp_proc_bind_t proc_bind; /* internal control for affinity  */\n  kmp_int32 default_device; /* internal control for default device */\n  struct kmp_internal_control *next;\n} kmp_internal_control_t;\n\nstatic inline void copy_icvs(kmp_internal_control_t *dst,\n                             kmp_internal_control_t *src) {\n  *dst = *src;\n}\n\n/* Thread barrier needs volatile barrier fields */\ntypedef struct KMP_ALIGN_CACHE kmp_bstate {\n  // th_fixed_icvs is aligned by virtue of kmp_bstate being aligned (and all\n  // uses of it). It is not explicitly aligned below, because we *don't* want\n  // it to be padded -- instead, we fit b_go into the same cache line with\n  // th_fixed_icvs, enabling NGO cache lines stores in the hierarchical barrier.\n  kmp_internal_control_t th_fixed_icvs; // Initial ICVs for the thread\n  // Tuck b_go into end of th_fixed_icvs cache line, so it can be stored with\n  // same NGO store\n  volatile kmp_uint64 b_go; // STATE => task should proceed (hierarchical)\n  KMP_ALIGN_CACHE volatile kmp_uint64\n      b_arrived; // STATE => task reached synch point.\n  kmp_uint32 *skip_per_level;\n  kmp_uint32 my_level;\n  kmp_int32 parent_tid;\n  kmp_int32 old_tid;\n  kmp_uint32 depth;\n  struct kmp_bstate *parent_bar;\n  kmp_team_t *team;\n  kmp_uint64 leaf_state;\n  kmp_uint32 nproc;\n  kmp_uint8 base_leaf_kids;\n  kmp_uint8 leaf_kids;\n  kmp_uint8 offset;\n  kmp_uint8 wait_flag;\n  kmp_uint8 use_oncore_barrier;\n#if USE_DEBUGGER\n  // The following field is intended for the debugger solely. Only the worker\n  // thread itself accesses this field: the worker increases it by 1 when it\n  // arrives to a barrier.\n  KMP_ALIGN_CACHE kmp_uint b_worker_arrived;\n#endif /* USE_DEBUGGER */\n} kmp_bstate_t;\n\nunion KMP_ALIGN_CACHE kmp_barrier_union {\n  double b_align; /* use worst case alignment */\n  char b_pad[KMP_PAD(kmp_bstate_t, CACHE_LINE)];\n  kmp_bstate_t bb;\n};\n\ntypedef union kmp_barrier_union kmp_balign_t;\n\n/* Team barrier needs only non-volatile arrived counter */\nunion KMP_ALIGN_CACHE kmp_barrier_team_union {\n  double b_align; /* use worst case alignment */\n  char b_pad[CACHE_LINE];\n  struct {\n    kmp_uint64 b_arrived; /* STATE => task reached synch point. */\n#if USE_DEBUGGER\n    // The following two fields are indended for the debugger solely. Only\n    // primary thread of the team accesses these fields: the first one is\n    // increased by 1 when the primary thread arrives to a barrier, the second\n    // one is increased by one when all the threads arrived.\n    kmp_uint b_master_arrived;\n    kmp_uint b_team_arrived;\n#endif\n  };\n};\n\ntypedef union kmp_barrier_team_union kmp_balign_team_t;\n\n/* Padding for Linux* OS pthreads condition variables and mutexes used to signal\n   threads when a condition changes.  This is to workaround an NPTL bug where\n   padding was added to pthread_cond_t which caused the initialization routine\n   to write outside of the structure if compiled on pre-NPTL threads.  */\n#if KMP_OS_WINDOWS\ntypedef struct kmp_win32_mutex {\n  /* The Lock */\n  CRITICAL_SECTION cs;\n} kmp_win32_mutex_t;\n\ntypedef struct kmp_win32_cond {\n  /* Count of the number of waiters. */\n  int waiters_count_;\n\n  /* Serialize access to <waiters_count_> */\n  kmp_win32_mutex_t waiters_count_lock_;\n\n  /* Number of threads to release via a <cond_broadcast> or a <cond_signal> */\n  int release_count_;\n\n  /* Keeps track of the current \"generation\" so that we don't allow */\n  /* one thread to steal all the \"releases\" from the broadcast. */\n  int wait_generation_count_;\n\n  /* A manual-reset event that's used to block and release waiting threads. */\n  HANDLE event_;\n} kmp_win32_cond_t;\n#endif\n\n#if KMP_OS_UNIX\n\nunion KMP_ALIGN_CACHE kmp_cond_union {\n  double c_align;\n  char c_pad[CACHE_LINE];\n  pthread_cond_t c_cond;\n};\n\ntypedef union kmp_cond_union kmp_cond_align_t;\n\nunion KMP_ALIGN_CACHE kmp_mutex_union {\n  double m_align;\n  char m_pad[CACHE_LINE];\n  pthread_mutex_t m_mutex;\n};\n\ntypedef union kmp_mutex_union kmp_mutex_align_t;\n\n#endif /* KMP_OS_UNIX */\n\ntypedef struct kmp_desc_base {\n  void *ds_stackbase;\n  size_t ds_stacksize;\n  int ds_stackgrow;\n  kmp_thread_t ds_thread;\n  volatile int ds_tid;\n  int ds_gtid;\n#if KMP_OS_WINDOWS\n  volatile int ds_alive;\n  DWORD ds_thread_id;\n/* ds_thread keeps thread handle on Windows* OS. It is enough for RTL purposes.\n   However, debugger support (libomp_db) cannot work with handles, because they\n   uncomparable. For example, debugger requests info about thread with handle h.\n   h is valid within debugger process, and meaningless within debugee process.\n   Even if h is duped by call to DuplicateHandle(), so the result h' is valid\n   within debugee process, but it is a *new* handle which does *not* equal to\n   any other handle in debugee... The only way to compare handles is convert\n   them to system-wide ids. GetThreadId() function is available only in\n   Longhorn and Server 2003. :-( In contrast, GetCurrentThreadId() is available\n   on all Windows* OS flavours (including Windows* 95). Thus, we have to get\n   thread id by call to GetCurrentThreadId() from within the thread and save it\n   to let libomp_db identify threads.  */\n#endif /* KMP_OS_WINDOWS */\n} kmp_desc_base_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_desc {\n  double ds_align; /* use worst case alignment */\n  char ds_pad[KMP_PAD(kmp_desc_base_t, CACHE_LINE)];\n  kmp_desc_base_t ds;\n} kmp_desc_t;\n\ntypedef struct kmp_local {\n  volatile int this_construct; /* count of single's encountered by thread */\n  void *reduce_data;\n#if KMP_USE_BGET\n  void *bget_data;\n  void *bget_list;\n#if !USE_CMP_XCHG_FOR_BGET\n#ifdef USE_QUEUING_LOCK_FOR_BGET\n  kmp_lock_t bget_lock; /* Lock for accessing bget free list */\n#else\n  kmp_bootstrap_lock_t bget_lock; // Lock for accessing bget free list. Must be\n// bootstrap lock so we can use it at library\n// shutdown.\n#endif /* USE_LOCK_FOR_BGET */\n#endif /* ! USE_CMP_XCHG_FOR_BGET */\n#endif /* KMP_USE_BGET */\n\n  PACKED_REDUCTION_METHOD_T\n  packed_reduction_method; /* stored by __kmpc_reduce*(), used by\n                              __kmpc_end_reduce*() */\n\n} kmp_local_t;\n\n#define KMP_CHECK_UPDATE(a, b)                                                 \\\n  if ((a) != (b))                                                              \\\n  (a) = (b)\n#define KMP_CHECK_UPDATE_SYNC(a, b)                                            \\\n  if ((a) != (b))                                                              \\\n  TCW_SYNC_PTR((a), (b))\n\n#define get__blocktime(xteam, xtid)                                            \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.blocktime)\n#define get__bt_set(xteam, xtid)                                               \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_set)\n#if KMP_USE_MONITOR\n#define get__bt_intervals(xteam, xtid)                                         \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_intervals)\n#endif\n\n#define get__dynamic_2(xteam, xtid)                                            \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.dynamic)\n#define get__nproc_2(xteam, xtid)                                              \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.nproc)\n#define get__sched_2(xteam, xtid)                                              \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.sched)\n\n#define set__blocktime_team(xteam, xtid, xval)                                 \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.blocktime) =     \\\n       (xval))\n\n#if KMP_USE_MONITOR\n#define set__bt_intervals_team(xteam, xtid, xval)                              \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_intervals) =  \\\n       (xval))\n#endif\n\n#define set__bt_set_team(xteam, xtid, xval)                                    \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_set) = (xval))\n\n#define set__dynamic(xthread, xval)                                            \\\n  (((xthread)->th.th_current_task->td_icvs.dynamic) = (xval))\n#define get__dynamic(xthread)                                                  \\\n  (((xthread)->th.th_current_task->td_icvs.dynamic) ? (FTN_TRUE) : (FTN_FALSE))\n\n#define set__nproc(xthread, xval)                                              \\\n  (((xthread)->th.th_current_task->td_icvs.nproc) = (xval))\n\n#define set__thread_limit(xthread, xval)                                       \\\n  (((xthread)->th.th_current_task->td_icvs.thread_limit) = (xval))\n\n#define set__max_active_levels(xthread, xval)                                  \\\n  (((xthread)->th.th_current_task->td_icvs.max_active_levels) = (xval))\n\n#define get__max_active_levels(xthread)                                        \\\n  ((xthread)->th.th_current_task->td_icvs.max_active_levels)\n\n#define set__sched(xthread, xval)                                              \\\n  (((xthread)->th.th_current_task->td_icvs.sched) = (xval))\n\n#define set__proc_bind(xthread, xval)                                          \\\n  (((xthread)->th.th_current_task->td_icvs.proc_bind) = (xval))\n#define get__proc_bind(xthread)                                                \\\n  ((xthread)->th.th_current_task->td_icvs.proc_bind)\n\n// OpenMP tasking data structures\n\ntypedef enum kmp_tasking_mode {\n  tskm_immediate_exec = 0,\n  tskm_extra_barrier = 1,\n  tskm_task_teams = 2,\n  tskm_max = 2\n} kmp_tasking_mode_t;\n\nextern kmp_tasking_mode_t\n    __kmp_tasking_mode; /* determines how/when to execute tasks */\nextern int __kmp_task_stealing_constraint;\nextern int __kmp_enable_task_throttling;\nextern kmp_int32 __kmp_default_device; // Set via OMP_DEFAULT_DEVICE if\n// specified, defaults to 0 otherwise\n// Set via OMP_MAX_TASK_PRIORITY if specified, defaults to 0 otherwise\nextern kmp_int32 __kmp_max_task_priority;\n// Set via KMP_TASKLOOP_MIN_TASKS if specified, defaults to 0 otherwise\nextern kmp_uint64 __kmp_taskloop_min_tasks;\n\n/* NOTE: kmp_taskdata_t and kmp_task_t structures allocated in single block with\n   taskdata first */\n#define KMP_TASK_TO_TASKDATA(task) (((kmp_taskdata_t *)task) - 1)\n#define KMP_TASKDATA_TO_TASK(taskdata) (kmp_task_t *)(taskdata + 1)\n\n// The tt_found_tasks flag is a signal to all threads in the team that tasks\n// were spawned and queued since the previous barrier release.\n#define KMP_TASKING_ENABLED(task_team)                                         \\\n  (TRUE == TCR_SYNC_4((task_team)->tt.tt_found_tasks))\n/*!\n@ingroup BASIC_TYPES\n@{\n*/\n\n/*!\n */\ntypedef kmp_int32 (*kmp_routine_entry_t)(kmp_int32, void *);\n\ntypedef union kmp_cmplrdata {\n  kmp_int32 priority; /**< priority specified by user for the task */\n  kmp_routine_entry_t\n      destructors; /* pointer to function to invoke deconstructors of\n                      firstprivate C++ objects */\n  /* future data */\n} kmp_cmplrdata_t;\n\n/*  sizeof_kmp_task_t passed as arg to kmpc_omp_task call  */\n/*!\n */\ntypedef struct kmp_task { /* GEH: Shouldn't this be aligned somehow? */\n  void *shareds; /**< pointer to block of pointers to shared vars   */\n  kmp_routine_entry_t\n      routine; /**< pointer to routine to call for executing task */\n  kmp_int32 part_id; /**< part id for the task                          */\n  kmp_cmplrdata_t\n      data1; /* Two known optional additions: destructors and priority */\n  kmp_cmplrdata_t data2; /* Process destructors first, priority second */\n  /* future data */\n  /*  private vars  */\n} kmp_task_t;\n\n/*!\n@}\n*/\n\ntypedef struct kmp_taskgroup {\n  std::atomic<kmp_int32> count; // number of allocated and incomplete tasks\n  std::atomic<kmp_int32>\n      cancel_request; // request for cancellation of this taskgroup\n  struct kmp_taskgroup *parent; // parent taskgroup\n  // Block of data to perform task reduction\n  void *reduce_data; // reduction related info\n  kmp_int32 reduce_num_data; // number of data items to reduce\n} kmp_taskgroup_t;\n\n// forward declarations\ntypedef union kmp_depnode kmp_depnode_t;\ntypedef struct kmp_depnode_list kmp_depnode_list_t;\ntypedef struct kmp_dephash_entry kmp_dephash_entry_t;\n\n// Compiler sends us this info:\ntypedef struct kmp_depend_info {\n  kmp_intptr_t base_addr;\n  size_t len;\n  struct {\n    bool in : 1;\n    bool out : 1;\n    bool mtx : 1;\n  } flags;\n} kmp_depend_info_t;\n\n// Internal structures to work with task dependencies:\nstruct kmp_depnode_list {\n  kmp_depnode_t *node;\n  kmp_depnode_list_t *next;\n};\n\n// Max number of mutexinoutset dependencies per node\n#define MAX_MTX_DEPS 4\n\ntypedef struct kmp_base_depnode {\n  kmp_depnode_list_t *successors; /* used under lock */\n  kmp_task_t *task; /* non-NULL if depnode is active, used under lock */\n  kmp_lock_t *mtx_locks[MAX_MTX_DEPS]; /* lock mutexinoutset dependent tasks */\n  kmp_int32 mtx_num_locks; /* number of locks in mtx_locks array */\n  kmp_lock_t lock; /* guards shared fields: task, successors */\n#if KMP_SUPPORT_GRAPH_OUTPUT\n  kmp_uint32 id;\n#endif\n  std::atomic<kmp_int32> npredecessors;\n  std::atomic<kmp_int32> nrefs;\n} kmp_base_depnode_t;\n\nunion KMP_ALIGN_CACHE kmp_depnode {\n  double dn_align; /* use worst case alignment */\n  char dn_pad[KMP_PAD(kmp_base_depnode_t, CACHE_LINE)];\n  kmp_base_depnode_t dn;\n};\n\nstruct kmp_dephash_entry {\n  kmp_intptr_t addr;\n  kmp_depnode_t *last_out;\n  kmp_depnode_list_t *last_ins;\n  kmp_depnode_list_t *last_mtxs;\n  kmp_int32 last_flag;\n  kmp_lock_t *mtx_lock; /* is referenced by depnodes w/mutexinoutset dep */\n  kmp_dephash_entry_t *next_in_bucket;\n};\n\ntypedef struct kmp_dephash {\n  kmp_dephash_entry_t **buckets;\n  size_t size;\n  size_t generation;\n  kmp_uint32 nelements;\n  kmp_uint32 nconflicts;\n} kmp_dephash_t;\n\ntypedef struct kmp_task_affinity_info {\n  kmp_intptr_t base_addr;\n  size_t len;\n  struct {\n    bool flag1 : 1;\n    bool flag2 : 1;\n    kmp_int32 reserved : 30;\n  } flags;\n} kmp_task_affinity_info_t;\n\ntypedef enum kmp_event_type_t {\n  KMP_EVENT_UNINITIALIZED = 0,\n  KMP_EVENT_ALLOW_COMPLETION = 1\n} kmp_event_type_t;\n\ntypedef struct {\n  kmp_event_type_t type;\n  kmp_tas_lock_t lock;\n  union {\n    kmp_task_t *task;\n  } ed;\n} kmp_event_t;\n\n#ifdef BUILD_TIED_TASK_STACK\n\n/* Tied Task stack definitions */\ntypedef struct kmp_stack_block {\n  kmp_taskdata_t *sb_block[TASK_STACK_BLOCK_SIZE];\n  struct kmp_stack_block *sb_next;\n  struct kmp_stack_block *sb_prev;\n} kmp_stack_block_t;\n\ntypedef struct kmp_task_stack {\n  kmp_stack_block_t ts_first_block; // first block of stack entries\n  kmp_taskdata_t **ts_top; // pointer to the top of stack\n  kmp_int32 ts_entries; // number of entries on the stack\n} kmp_task_stack_t;\n\n#endif // BUILD_TIED_TASK_STACK\n\ntypedef struct kmp_tasking_flags { /* Total struct must be exactly 32 bits */\n  /* Compiler flags */ /* Total compiler flags must be 16 bits */\n  unsigned tiedness : 1; /* task is either tied (1) or untied (0) */\n  unsigned final : 1; /* task is final(1) so execute immediately */\n  unsigned merged_if0 : 1; /* no __kmpc_task_{begin/complete}_if0 calls in if0\n                              code path */\n  unsigned destructors_thunk : 1; /* set if the compiler creates a thunk to\n                                     invoke destructors from the runtime */\n  unsigned proxy : 1; /* task is a proxy task (it will be executed outside the\n                         context of the RTL) */\n  unsigned priority_specified : 1; /* set if the compiler provides priority\n                                      setting for the task */\n  unsigned detachable : 1; /* 1 == can detach */\n  unsigned hidden_helper : 1; /* 1 == hidden helper task */\n  unsigned reserved : 8; /* reserved for compiler use */\n\n  /* Library flags */ /* Total library flags must be 16 bits */\n  unsigned tasktype : 1; /* task is either explicit(1) or implicit (0) */\n  unsigned task_serial : 1; // task is executed immediately (1) or deferred (0)\n  unsigned tasking_ser : 1; // all tasks in team are either executed immediately\n  // (1) or may be deferred (0)\n  unsigned team_serial : 1; // entire team is serial (1) [1 thread] or parallel\n  // (0) [>= 2 threads]\n  /* If either team_serial or tasking_ser is set, task team may be NULL */\n  /* Task State Flags: */\n  unsigned started : 1; /* 1==started, 0==not started     */\n  unsigned executing : 1; /* 1==executing, 0==not executing */\n  unsigned complete : 1; /* 1==complete, 0==not complete   */\n  unsigned freed : 1; /* 1==freed, 0==allocated        */\n  unsigned native : 1; /* 1==gcc-compiled task, 0==intel */\n  unsigned reserved31 : 7; /* reserved for library use */\n\n} kmp_tasking_flags_t;\n\nstruct kmp_taskdata { /* aligned during dynamic allocation       */\n  kmp_int32 td_task_id; /* id, assigned by debugger                */\n  kmp_tasking_flags_t td_flags; /* task flags                              */\n  kmp_team_t *td_team; /* team for this task                      */\n  kmp_info_p *td_alloc_thread; /* thread that allocated data structures   */\n  /* Currently not used except for perhaps IDB */\n  kmp_taskdata_t *td_parent; /* parent task                             */\n  kmp_int32 td_level; /* task nesting level                      */\n  std::atomic<kmp_int32> td_untied_count; // untied task active parts counter\n  ident_t *td_ident; /* task identifier                         */\n  // Taskwait data.\n  ident_t *td_taskwait_ident;\n  kmp_uint32 td_taskwait_counter;\n  kmp_int32 td_taskwait_thread; /* gtid + 1 of thread encountered taskwait */\n  KMP_ALIGN_CACHE kmp_internal_control_t\n      td_icvs; /* Internal control variables for the task */\n  KMP_ALIGN_CACHE std::atomic<kmp_int32>\n      td_allocated_child_tasks; /* Child tasks (+ current task) not yet\n                                   deallocated */\n  std::atomic<kmp_int32>\n      td_incomplete_child_tasks; /* Child tasks not yet complete */\n  kmp_taskgroup_t\n      *td_taskgroup; // Each task keeps pointer to its current taskgroup\n  kmp_dephash_t\n      *td_dephash; // Dependencies for children tasks are tracked from here\n  kmp_depnode_t\n      *td_depnode; // Pointer to graph node if this task has dependencies\n  kmp_task_team_t *td_task_team;\n  // The global thread id of the encountering thread. We need it because when a\n  // regular task depends on a hidden helper task, and the hidden helper task\n  // is finished on a hidden helper thread, it will call __kmp_release_deps to\n  // release all dependences. If now the task is a regular task, we need to pass\n  // the encountering gtid such that the task will be picked up and executed by\n  // its encountering team instead of hidden helper team.\n  kmp_int32 encountering_gtid;\n  size_t td_size_alloc; // Size of task structure, including shareds etc.\n#if defined(KMP_GOMP_COMPAT)\n  // 4 or 8 byte integers for the loop bounds in GOMP_taskloop\n  kmp_int32 td_size_loop_bounds;\n#endif\n  kmp_taskdata_t *td_last_tied; // keep tied task for task scheduling constraint\n#if defined(KMP_GOMP_COMPAT)\n  // GOMP sends in a copy function for copy constructors\n  void (*td_copy_func)(void *, void *);\n#endif\n  kmp_event_t td_allow_completion_event;\n#if OMPT_SUPPORT\n  ompt_task_info_t ompt_task_info;\n#endif\n}; // struct kmp_taskdata\n\n// Make sure padding above worked\nKMP_BUILD_ASSERT(sizeof(kmp_taskdata_t) % sizeof(void *) == 0);\n\n// Data for task team but per thread\ntypedef struct kmp_base_thread_data {\n  kmp_info_p *td_thr; // Pointer back to thread info\n  // Used only in __kmp_execute_tasks_template, maybe not avail until task is\n  // queued?\n  kmp_bootstrap_lock_t td_deque_lock; // Lock for accessing deque\n  kmp_taskdata_t *\n      *td_deque; // Deque of tasks encountered by td_thr, dynamically allocated\n  kmp_int32 td_deque_size; // Size of deck\n  kmp_uint32 td_deque_head; // Head of deque (will wrap)\n  kmp_uint32 td_deque_tail; // Tail of deque (will wrap)\n  kmp_int32 td_deque_ntasks; // Number of tasks in deque\n  // GEH: shouldn't this be volatile since used in while-spin?\n  kmp_int32 td_deque_last_stolen; // Thread number of last successful steal\n#ifdef BUILD_TIED_TASK_STACK\n  kmp_task_stack_t td_susp_tied_tasks; // Stack of suspended tied tasks for task\n// scheduling constraint\n#endif // BUILD_TIED_TASK_STACK\n} kmp_base_thread_data_t;\n\n#define TASK_DEQUE_BITS 8 // Used solely to define INITIAL_TASK_DEQUE_SIZE\n#define INITIAL_TASK_DEQUE_SIZE (1 << TASK_DEQUE_BITS)\n\n#define TASK_DEQUE_SIZE(td) ((td).td_deque_size)\n#define TASK_DEQUE_MASK(td) ((td).td_deque_size - 1)\n\ntypedef union KMP_ALIGN_CACHE kmp_thread_data {\n  kmp_base_thread_data_t td;\n  double td_align; /* use worst case alignment */\n  char td_pad[KMP_PAD(kmp_base_thread_data_t, CACHE_LINE)];\n} kmp_thread_data_t;\n\n// Data for task teams which are used when tasking is enabled for the team\ntypedef struct kmp_base_task_team {\n  kmp_bootstrap_lock_t\n      tt_threads_lock; /* Lock used to allocate per-thread part of task team */\n  /* must be bootstrap lock since used at library shutdown*/\n  kmp_task_team_t *tt_next; /* For linking the task team free list */\n  kmp_thread_data_t\n      *tt_threads_data; /* Array of per-thread structures for task team */\n  /* Data survives task team deallocation */\n  kmp_int32 tt_found_tasks; /* Have we found tasks and queued them while\n                               executing this team? */\n  /* TRUE means tt_threads_data is set up and initialized */\n  kmp_int32 tt_nproc; /* #threads in team           */\n  kmp_int32 tt_max_threads; // # entries allocated for threads_data array\n  kmp_int32 tt_found_proxy_tasks; // found proxy tasks since last barrier\n  kmp_int32 tt_untied_task_encountered;\n  // There is hidden helper thread encountered in this task team so that we must\n  // wait when waiting on task team\n  kmp_int32 tt_hidden_helper_task_encountered;\n\n  KMP_ALIGN_CACHE\n  std::atomic<kmp_int32> tt_unfinished_threads; /* #threads still active */\n\n  KMP_ALIGN_CACHE\n  volatile kmp_uint32\n      tt_active; /* is the team still actively executing tasks */\n} kmp_base_task_team_t;\n\nunion KMP_ALIGN_CACHE kmp_task_team {\n  kmp_base_task_team_t tt;\n  double tt_align; /* use worst case alignment */\n  char tt_pad[KMP_PAD(kmp_base_task_team_t, CACHE_LINE)];\n};\n\n#if (USE_FAST_MEMORY == 3) || (USE_FAST_MEMORY == 5)\n// Free lists keep same-size free memory slots for fast memory allocation\n// routines\ntypedef struct kmp_free_list {\n  void *th_free_list_self; // Self-allocated tasks free list\n  void *th_free_list_sync; // Self-allocated tasks stolen/returned by other\n  // threads\n  void *th_free_list_other; // Non-self free list (to be returned to owner's\n  // sync list)\n} kmp_free_list_t;\n#endif\n#if KMP_NESTED_HOT_TEAMS\n// Hot teams array keeps hot teams and their sizes for given thread. Hot teams\n// are not put in teams pool, and they don't put threads in threads pool.\ntypedef struct kmp_hot_team_ptr {\n  kmp_team_p *hot_team; // pointer to hot_team of given nesting level\n  kmp_int32 hot_team_nth; // number of threads allocated for the hot_team\n} kmp_hot_team_ptr_t;\n#endif\ntypedef struct kmp_teams_size {\n  kmp_int32 nteams; // number of teams in a league\n  kmp_int32 nth; // number of threads in each team of the league\n} kmp_teams_size_t;\n\n// This struct stores a thread that acts as a \"root\" for a contention\n// group. Contention groups are rooted at kmp_root threads, but also at\n// each primary thread of each team created in the teams construct.\n// This struct therefore also stores a thread_limit associated with\n// that contention group, and a counter to track the number of threads\n// active in that contention group. Each thread has a list of these: CG\n// root threads have an entry in their list in which cg_root refers to\n// the thread itself, whereas other workers in the CG will have a\n// single entry where cg_root is same as the entry containing their CG\n// root. When a thread encounters a teams construct, it will add a new\n// entry to the front of its list, because it now roots a new CG.\ntypedef struct kmp_cg_root {\n  kmp_info_p *cg_root; // \"root\" thread for a contention group\n  // The CG root's limit comes from OMP_THREAD_LIMIT for root threads, or\n  // thread_limit clause for teams primary threads\n  kmp_int32 cg_thread_limit;\n  kmp_int32 cg_nthreads; // Count of active threads in CG rooted at cg_root\n  struct kmp_cg_root *up; // pointer to higher level CG root in list\n} kmp_cg_root_t;\n\n// OpenMP thread data structures\n\ntypedef struct KMP_ALIGN_CACHE kmp_base_info {\n  /* Start with the readonly data which is cache aligned and padded. This is\n     written before the thread starts working by the primary thread. Uber\n     masters may update themselves later. Usage does not consider serialized\n     regions.  */\n  kmp_desc_t th_info;\n  kmp_team_p *th_team; /* team we belong to */\n  kmp_root_p *th_root; /* pointer to root of task hierarchy */\n  kmp_info_p *th_next_pool; /* next available thread in the pool */\n  kmp_disp_t *th_dispatch; /* thread's dispatch data */\n  int th_in_pool; /* in thread pool (32 bits for TCR/TCW) */\n\n  /* The following are cached from the team info structure */\n  /* TODO use these in more places as determined to be needed via profiling */\n  int th_team_nproc; /* number of threads in a team */\n  kmp_info_p *th_team_master; /* the team's primary thread */\n  int th_team_serialized; /* team is serialized */\n  microtask_t th_teams_microtask; /* save entry address for teams construct */\n  int th_teams_level; /* save initial level of teams construct */\n/* it is 0 on device but may be any on host */\n\n/* The blocktime info is copied from the team struct to the thread struct */\n/* at the start of a barrier, and the values stored in the team are used  */\n/* at points in the code where the team struct is no longer guaranteed    */\n/* to exist (from the POV of worker threads).                             */\n#if KMP_USE_MONITOR\n  int th_team_bt_intervals;\n  int th_team_bt_set;\n#else\n  kmp_uint64 th_team_bt_intervals;\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n  kmp_affin_mask_t *th_affin_mask; /* thread's current affinity mask */\n#endif\n  omp_allocator_handle_t th_def_allocator; /* default allocator */\n  /* The data set by the primary thread at reinit, then R/W by the worker */\n  KMP_ALIGN_CACHE int\n      th_set_nproc; /* if > 0, then only use this request for the next fork */\n#if KMP_NESTED_HOT_TEAMS\n  kmp_hot_team_ptr_t *th_hot_teams; /* array of hot teams */\n#endif\n  kmp_proc_bind_t\n      th_set_proc_bind; /* if != proc_bind_default, use request for next fork */\n  kmp_teams_size_t\n      th_teams_size; /* number of teams/threads in teams construct */\n#if KMP_AFFINITY_SUPPORTED\n  int th_current_place; /* place currently bound to */\n  int th_new_place; /* place to bind to in par reg */\n  int th_first_place; /* first place in partition */\n  int th_last_place; /* last place in partition */\n#endif\n  int th_prev_level; /* previous level for affinity format */\n  int th_prev_num_threads; /* previous num_threads for affinity format */\n#if USE_ITT_BUILD\n  kmp_uint64 th_bar_arrive_time; /* arrival to barrier timestamp */\n  kmp_uint64 th_bar_min_time; /* minimum arrival time at the barrier */\n  kmp_uint64 th_frame_time; /* frame timestamp */\n#endif /* USE_ITT_BUILD */\n  kmp_local_t th_local;\n  struct private_common *th_pri_head;\n\n  /* Now the data only used by the worker (after initial allocation) */\n  /* TODO the first serial team should actually be stored in the info_t\n     structure.  this will help reduce initial allocation overhead */\n  KMP_ALIGN_CACHE kmp_team_p\n      *th_serial_team; /*serialized team held in reserve*/\n\n#if OMPT_SUPPORT\n  ompt_thread_info_t ompt_thread_info;\n#endif\n\n  /* The following are also read by the primary thread during reinit */\n  struct common_table *th_pri_common;\n\n  volatile kmp_uint32 th_spin_here; /* thread-local location for spinning */\n  /* while awaiting queuing lock acquire */\n\n  volatile void *th_sleep_loc; // this points at a kmp_flag<T>\n\n  ident_t *th_ident;\n  unsigned th_x; // Random number generator data\n  unsigned th_a; // Random number generator data\n\n  /* Tasking-related data for the thread */\n  kmp_task_team_t *th_task_team; // Task team struct\n  kmp_taskdata_t *th_current_task; // Innermost Task being executed\n  kmp_uint8 th_task_state; // alternating 0/1 for task team identification\n  kmp_uint8 *th_task_state_memo_stack; // Stack holding memos of th_task_state\n  // at nested levels\n  kmp_uint32 th_task_state_top; // Top element of th_task_state_memo_stack\n  kmp_uint32 th_task_state_stack_sz; // Size of th_task_state_memo_stack\n  kmp_uint32 th_reap_state; // Non-zero indicates thread is not\n  // tasking, thus safe to reap\n\n  /* More stuff for keeping track of active/sleeping threads (this part is\n     written by the worker thread) */\n  kmp_uint8 th_active_in_pool; // included in count of #active threads in pool\n  int th_active; // ! sleeping; 32 bits for TCR/TCW\n  struct cons_header *th_cons; // used for consistency check\n#if KMP_USE_HIER_SCHED\n  // used for hierarchical scheduling\n  kmp_hier_private_bdata_t *th_hier_bar_data;\n#endif\n\n  /* Add the syncronizing data which is cache aligned and padded. */\n  KMP_ALIGN_CACHE kmp_balign_t th_bar[bs_last_barrier];\n\n  KMP_ALIGN_CACHE volatile kmp_int32\n      th_next_waiting; /* gtid+1 of next thread on lock wait queue, 0 if none */\n\n#if (USE_FAST_MEMORY == 3) || (USE_FAST_MEMORY == 5)\n#define NUM_LISTS 4\n  kmp_free_list_t th_free_lists[NUM_LISTS]; // Free lists for fast memory\n// allocation routines\n#endif\n\n#if KMP_OS_WINDOWS\n  kmp_win32_cond_t th_suspend_cv;\n  kmp_win32_mutex_t th_suspend_mx;\n  std::atomic<int> th_suspend_init;\n#endif\n#if KMP_OS_UNIX\n  kmp_cond_align_t th_suspend_cv;\n  kmp_mutex_align_t th_suspend_mx;\n  std::atomic<int> th_suspend_init_count;\n#endif\n\n#if USE_ITT_BUILD\n  kmp_itt_mark_t th_itt_mark_single;\n// alignment ???\n#endif /* USE_ITT_BUILD */\n#if KMP_STATS_ENABLED\n  kmp_stats_list *th_stats;\n#endif\n#if KMP_OS_UNIX\n  std::atomic<bool> th_blocking;\n#endif\n  kmp_cg_root_t *th_cg_roots; // list of cg_roots associated with this thread\n} kmp_base_info_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_info {\n  double th_align; /* use worst case alignment */\n  char th_pad[KMP_PAD(kmp_base_info_t, CACHE_LINE)];\n  kmp_base_info_t th;\n} kmp_info_t;\n\n// OpenMP thread team data structures\n\ntypedef struct kmp_base_data {\n  volatile kmp_uint32 t_value;\n} kmp_base_data_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_sleep_team {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_sleep_team_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_ordered_team {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_ordered_team_t;\n\ntypedef int (*launch_t)(int gtid);\n\n/* Minimum number of ARGV entries to malloc if necessary */\n#define KMP_MIN_MALLOC_ARGV_ENTRIES 100\n\n// Set up how many argv pointers will fit in cache lines containing\n// t_inline_argv. Historically, we have supported at least 96 bytes. Using a\n// larger value for more space between the primary write/worker read section and\n// read/write by all section seems to buy more performance on EPCC PARALLEL.\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_INLINE_ARGV_BYTES                                                  \\\n  (4 * CACHE_LINE -                                                            \\\n   ((3 * KMP_PTR_SKIP + 2 * sizeof(int) + 2 * sizeof(kmp_int8) +               \\\n     sizeof(kmp_int16) + sizeof(kmp_uint32)) %                                 \\\n    CACHE_LINE))\n#else\n#define KMP_INLINE_ARGV_BYTES                                                  \\\n  (2 * CACHE_LINE - ((3 * KMP_PTR_SKIP + 2 * sizeof(int)) % CACHE_LINE))\n#endif\n#define KMP_INLINE_ARGV_ENTRIES (int)(KMP_INLINE_ARGV_BYTES / KMP_PTR_SKIP)\n\ntypedef struct KMP_ALIGN_CACHE kmp_base_team {\n  // Synchronization Data\n  // ---------------------------------------------------------------------------\n  KMP_ALIGN_CACHE kmp_ordered_team_t t_ordered;\n  kmp_balign_team_t t_bar[bs_last_barrier];\n  std::atomic<int> t_construct; // count of single directive encountered by team\n  char pad[sizeof(kmp_lock_t)]; // padding to maintain performance on big iron\n\n  // [0] - parallel / [1] - worksharing task reduction data shared by taskgroups\n  std::atomic<void *> t_tg_reduce_data[2]; // to support task modifier\n  std::atomic<int> t_tg_fini_counter[2]; // sync end of task reductions\n\n  // Primary thread only\n  // ---------------------------------------------------------------------------\n  KMP_ALIGN_CACHE int t_master_tid; // tid of primary thread in parent team\n  int t_master_this_cons; // \"this_construct\" single counter of primary thread\n  // in parent team\n  ident_t *t_ident; // if volatile, have to change too much other crud to\n  // volatile too\n  kmp_team_p *t_parent; // parent team\n  kmp_team_p *t_next_pool; // next free team in the team pool\n  kmp_disp_t *t_dispatch; // thread's dispatch data\n  kmp_task_team_t *t_task_team[2]; // Task team struct; switch between 2\n  kmp_proc_bind_t t_proc_bind; // bind type for par region\n#if USE_ITT_BUILD\n  kmp_uint64 t_region_time; // region begin timestamp\n#endif /* USE_ITT_BUILD */\n\n  // Primary thread write, workers read\n  // --------------------------------------------------------------------------\n  KMP_ALIGN_CACHE void **t_argv;\n  int t_argc;\n  int t_nproc; // number of threads in team\n  microtask_t t_pkfn;\n  launch_t t_invoke; // procedure to launch the microtask\n\n#if OMPT_SUPPORT\n  ompt_team_info_t ompt_team_info;\n  ompt_lw_taskteam_t *ompt_serialized_team_info;\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  kmp_int8 t_fp_control_saved;\n  kmp_int8 t_pad2b;\n  kmp_int16 t_x87_fpu_control_word; // FP control regs\n  kmp_uint32 t_mxcsr;\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n  void *t_inline_argv[KMP_INLINE_ARGV_ENTRIES];\n\n  KMP_ALIGN_CACHE kmp_info_t **t_threads;\n  kmp_taskdata_t\n      *t_implicit_task_taskdata; // Taskdata for the thread's implicit task\n  int t_level; // nested parallel level\n\n  KMP_ALIGN_CACHE int t_max_argc;\n  int t_max_nproc; // max threads this team can handle (dynamically expandable)\n  int t_serialized; // levels deep of serialized teams\n  dispatch_shared_info_t *t_disp_buffer; // buffers for dispatch system\n  int t_id; // team's id, assigned by debugger.\n  int t_active_level; // nested active parallel level\n  kmp_r_sched_t t_sched; // run-time schedule for the team\n#if KMP_AFFINITY_SUPPORTED\n  int t_first_place; // first & last place in parent thread's partition.\n  int t_last_place; // Restore these values to primary thread after par region.\n#endif // KMP_AFFINITY_SUPPORTED\n  int t_display_affinity;\n  int t_size_changed; // team size was changed?: 0: no, 1: yes, -1: changed via\n  // omp_set_num_threads() call\n  omp_allocator_handle_t t_def_allocator; /* default allocator */\n\n// Read/write by workers as well\n#if (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n  // Using CACHE_LINE=64 reduces memory footprint, but causes a big perf\n  // regression of epcc 'parallel' and 'barrier' on fxe256lin01. This extra\n  // padding serves to fix the performance of epcc 'parallel' and 'barrier' when\n  // CACHE_LINE=64. TODO: investigate more and get rid if this padding.\n  char dummy_padding[1024];\n#endif\n  // Internal control stack for additional nested teams.\n  KMP_ALIGN_CACHE kmp_internal_control_t *t_control_stack_top;\n  // for SERIALIZED teams nested 2 or more levels deep\n  // typed flag to store request state of cancellation\n  std::atomic<kmp_int32> t_cancel_request;\n  int t_master_active; // save on fork, restore on join\n  void *t_copypriv_data; // team specific pointer to copyprivate data array\n#if KMP_OS_WINDOWS\n  std::atomic<kmp_uint32> t_copyin_counter;\n#endif\n#if USE_ITT_BUILD\n  void *t_stack_id; // team specific stack stitching id (for ittnotify)\n#endif /* USE_ITT_BUILD */\n} kmp_base_team_t;\n\nunion KMP_ALIGN_CACHE kmp_team {\n  kmp_base_team_t t;\n  double t_align; /* use worst case alignment */\n  char t_pad[KMP_PAD(kmp_base_team_t, CACHE_LINE)];\n};\n\ntypedef union KMP_ALIGN_CACHE kmp_time_global {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_time_global_t;\n\ntypedef struct kmp_base_global {\n  /* cache-aligned */\n  kmp_time_global_t g_time;\n\n  /* non cache-aligned */\n  volatile int g_abort;\n  volatile int g_done;\n\n  int g_dynamic;\n  enum dynamic_mode g_dynamic_mode;\n} kmp_base_global_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_global {\n  kmp_base_global_t g;\n  double g_align; /* use worst case alignment */\n  char g_pad[KMP_PAD(kmp_base_global_t, CACHE_LINE)];\n} kmp_global_t;\n\ntypedef struct kmp_base_root {\n  // TODO: GEH - combine r_active with r_in_parallel then r_active ==\n  // (r_in_parallel>= 0)\n  // TODO: GEH - then replace r_active with t_active_levels if we can to reduce\n  // the synch overhead or keeping r_active\n  volatile int r_active; /* TRUE if some region in a nest has > 1 thread */\n  // keeps a count of active parallel regions per root\n  std::atomic<int> r_in_parallel;\n  // GEH: This is misnamed, should be r_active_levels\n  kmp_team_t *r_root_team;\n  kmp_team_t *r_hot_team;\n  kmp_info_t *r_uber_thread;\n  kmp_lock_t r_begin_lock;\n  volatile int r_begin;\n  int r_blocktime; /* blocktime for this root and descendants */\n} kmp_base_root_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_root {\n  kmp_base_root_t r;\n  double r_align; /* use worst case alignment */\n  char r_pad[KMP_PAD(kmp_base_root_t, CACHE_LINE)];\n} kmp_root_t;\n\nstruct fortran_inx_info {\n  kmp_int32 data;\n};\n\n/* ------------------------------------------------------------------------ */\n\nextern int __kmp_settings;\nextern int __kmp_duplicate_library_ok;\n#if USE_ITT_BUILD\nextern int __kmp_forkjoin_frames;\nextern int __kmp_forkjoin_frames_mode;\n#endif\nextern PACKED_REDUCTION_METHOD_T __kmp_force_reduction_method;\nextern int __kmp_determ_red;\n\n#ifdef KMP_DEBUG\nextern int kmp_a_debug;\nextern int kmp_b_debug;\nextern int kmp_c_debug;\nextern int kmp_d_debug;\nextern int kmp_e_debug;\nextern int kmp_f_debug;\n#endif /* KMP_DEBUG */\n\n/* For debug information logging using rotating buffer */\n#define KMP_DEBUG_BUF_LINES_INIT 512\n#define KMP_DEBUG_BUF_LINES_MIN 1\n\n#define KMP_DEBUG_BUF_CHARS_INIT 128\n#define KMP_DEBUG_BUF_CHARS_MIN 2\n\nextern int\n    __kmp_debug_buf; /* TRUE means use buffer, FALSE means print to stderr */\nextern int __kmp_debug_buf_lines; /* How many lines of debug stored in buffer */\nextern int\n    __kmp_debug_buf_chars; /* How many characters allowed per line in buffer */\nextern int __kmp_debug_buf_atomic; /* TRUE means use atomic update of buffer\n                                      entry pointer */\n\nextern char *__kmp_debug_buffer; /* Debug buffer itself */\nextern std::atomic<int> __kmp_debug_count; /* Counter for number of lines\n                                              printed in buffer so far */\nextern int __kmp_debug_buf_warn_chars; /* Keep track of char increase\n                                          recommended in warnings */\n/* end rotating debug buffer */\n\n#ifdef KMP_DEBUG\nextern int __kmp_par_range; /* +1 => only go par for constructs in range */\n\n#define KMP_PAR_RANGE_ROUTINE_LEN 1024\nextern char __kmp_par_range_routine[KMP_PAR_RANGE_ROUTINE_LEN];\n#define KMP_PAR_RANGE_FILENAME_LEN 1024\nextern char __kmp_par_range_filename[KMP_PAR_RANGE_FILENAME_LEN];\nextern int __kmp_par_range_lb;\nextern int __kmp_par_range_ub;\n#endif\n\n/* For printing out dynamic storage map for threads and teams */\nextern int\n    __kmp_storage_map; /* True means print storage map for threads and teams */\nextern int __kmp_storage_map_verbose; /* True means storage map includes\n                                         placement info */\nextern int __kmp_storage_map_verbose_specified;\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern kmp_cpuinfo_t __kmp_cpuinfo;\n#endif\n\nextern volatile int __kmp_init_serial;\nextern volatile int __kmp_init_gtid;\nextern volatile int __kmp_init_common;\nextern volatile int __kmp_init_middle;\nextern volatile int __kmp_init_parallel;\n#if KMP_USE_MONITOR\nextern volatile int __kmp_init_monitor;\n#endif\nextern volatile int __kmp_init_user_locks;\nextern volatile int __kmp_init_hidden_helper_threads;\nextern int __kmp_init_counter;\nextern int __kmp_root_counter;\nextern int __kmp_version;\n\n/* list of address of allocated caches for commons */\nextern kmp_cached_addr_t *__kmp_threadpriv_cache_list;\n\n/* Barrier algorithm types and options */\nextern kmp_uint32 __kmp_barrier_gather_bb_dflt;\nextern kmp_uint32 __kmp_barrier_release_bb_dflt;\nextern kmp_bar_pat_e __kmp_barrier_gather_pat_dflt;\nextern kmp_bar_pat_e __kmp_barrier_release_pat_dflt;\nextern kmp_uint32 __kmp_barrier_gather_branch_bits[bs_last_barrier];\nextern kmp_uint32 __kmp_barrier_release_branch_bits[bs_last_barrier];\nextern kmp_bar_pat_e __kmp_barrier_gather_pattern[bs_last_barrier];\nextern kmp_bar_pat_e __kmp_barrier_release_pattern[bs_last_barrier];\nextern char const *__kmp_barrier_branch_bit_env_name[bs_last_barrier];\nextern char const *__kmp_barrier_pattern_env_name[bs_last_barrier];\nextern char const *__kmp_barrier_type_name[bs_last_barrier];\nextern char const *__kmp_barrier_pattern_name[bp_last_bar];\n\n/* Global Locks */\nextern kmp_bootstrap_lock_t __kmp_initz_lock; /* control initialization */\nextern kmp_bootstrap_lock_t __kmp_forkjoin_lock; /* control fork/join access */\nextern kmp_bootstrap_lock_t __kmp_task_team_lock;\nextern kmp_bootstrap_lock_t\n    __kmp_exit_lock; /* exit() is not always thread-safe */\n#if KMP_USE_MONITOR\nextern kmp_bootstrap_lock_t\n    __kmp_monitor_lock; /* control monitor thread creation */\n#endif\nextern kmp_bootstrap_lock_t\n    __kmp_tp_cached_lock; /* used for the hack to allow threadprivate cache and\n                             __kmp_threads expansion to co-exist */\n\nextern kmp_lock_t __kmp_global_lock; /* control OS/global access  */\nextern kmp_queuing_lock_t __kmp_dispatch_lock; /* control dispatch access  */\nextern kmp_lock_t __kmp_debug_lock; /* control I/O access for KMP_DEBUG */\n\nextern enum library_type __kmp_library;\n\nextern enum sched_type __kmp_sched; /* default runtime scheduling */\nextern enum sched_type __kmp_static; /* default static scheduling method */\nextern enum sched_type __kmp_guided; /* default guided scheduling method */\nextern enum sched_type __kmp_auto; /* default auto scheduling method */\nextern int __kmp_chunk; /* default runtime chunk size */\nextern int __kmp_force_monotonic; /* whether monotonic scheduling forced */\n\nextern size_t __kmp_stksize; /* stack size per thread         */\n#if KMP_USE_MONITOR\nextern size_t __kmp_monitor_stksize; /* stack size for monitor thread */\n#endif\nextern size_t __kmp_stkoffset; /* stack offset per thread       */\nextern int __kmp_stkpadding; /* Should we pad root thread(s) stack */\n\nextern size_t\n    __kmp_malloc_pool_incr; /* incremental size of pool for kmp_malloc() */\nextern int __kmp_env_stksize; /* was KMP_STACKSIZE specified? */\nextern int __kmp_env_blocktime; /* was KMP_BLOCKTIME specified? */\nextern int __kmp_env_checks; /* was KMP_CHECKS specified?    */\nextern int __kmp_env_consistency_check; // was KMP_CONSISTENCY_CHECK specified?\nextern int __kmp_generate_warnings; /* should we issue warnings? */\nextern int __kmp_reserve_warn; /* have we issued reserve_threads warning? */\n\n#ifdef DEBUG_SUSPEND\nextern int __kmp_suspend_count; /* count inside __kmp_suspend_template() */\n#endif\n\nextern kmp_int32 __kmp_use_yield;\nextern kmp_int32 __kmp_use_yield_exp_set;\nextern kmp_uint32 __kmp_yield_init;\nextern kmp_uint32 __kmp_yield_next;\n\n/* ------------------------------------------------------------------------- */\nextern int __kmp_allThreadsSpecified;\n\nextern size_t __kmp_align_alloc;\n/* following data protected by initialization routines */\nextern int __kmp_xproc; /* number of processors in the system */\nextern int __kmp_avail_proc; /* number of processors available to the process */\nextern size_t __kmp_sys_min_stksize; /* system-defined minimum stack size */\nextern int __kmp_sys_max_nth; /* system-imposed maximum number of threads */\n// maximum total number of concurrently-existing threads on device\nextern int __kmp_max_nth;\n// maximum total number of concurrently-existing threads in a contention group\nextern int __kmp_cg_max_nth;\nextern int __kmp_teams_max_nth; // max threads used in a teams construct\nextern int __kmp_threads_capacity; /* capacity of the arrays __kmp_threads and\n                                      __kmp_root */\nextern int __kmp_dflt_team_nth; /* default number of threads in a parallel\n                                   region a la OMP_NUM_THREADS */\nextern int __kmp_dflt_team_nth_ub; /* upper bound on \"\" determined at serial\n                                      initialization */\nextern int __kmp_tp_capacity; /* capacity of __kmp_threads if threadprivate is\n                                 used (fixed) */\nextern int __kmp_tp_cached; /* whether threadprivate cache has been created\n                               (__kmpc_threadprivate_cached()) */\nextern int __kmp_dflt_blocktime; /* number of milliseconds to wait before\n                                    blocking (env setting) */\n#if KMP_USE_MONITOR\nextern int\n    __kmp_monitor_wakeups; /* number of times monitor wakes up per second */\nextern int __kmp_bt_intervals; /* number of monitor timestamp intervals before\n                                  blocking */\n#endif\n#ifdef KMP_ADJUST_BLOCKTIME\nextern int __kmp_zero_bt; /* whether blocktime has been forced to zero */\n#endif /* KMP_ADJUST_BLOCKTIME */\n#ifdef KMP_DFLT_NTH_CORES\nextern int __kmp_ncores; /* Total number of cores for threads placement */\n#endif\n/* Number of millisecs to delay on abort for Intel(R) VTune(TM) tools */\nextern int __kmp_abort_delay;\n\nextern int __kmp_need_register_atfork_specified;\nextern int __kmp_need_register_atfork; /* At initialization, call pthread_atfork\n                                          to install fork handler */\nextern int __kmp_gtid_mode; /* Method of getting gtid, values:\n                               0 - not set, will be set at runtime\n                               1 - using stack search\n                               2 - dynamic TLS (pthread_getspecific(Linux* OS/OS\n                                   X*) or TlsGetValue(Windows* OS))\n                               3 - static TLS (__declspec(thread) __kmp_gtid),\n                                   Linux* OS .so only.  */\nextern int\n    __kmp_adjust_gtid_mode; /* If true, adjust method based on #threads */\n#ifdef KMP_TDATA_GTID\nextern KMP_THREAD_LOCAL int __kmp_gtid;\n#endif\nextern int __kmp_tls_gtid_min; /* #threads below which use sp search for gtid */\nextern int __kmp_foreign_tp; // If true, separate TP var for each foreign thread\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern int __kmp_inherit_fp_control; // copy fp creg(s) parent->workers at fork\nextern kmp_int16 __kmp_init_x87_fpu_control_word; // init thread's FP ctrl reg\nextern kmp_uint32 __kmp_init_mxcsr; /* init thread's mxscr */\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n// max_active_levels for nested parallelism enabled by default via\n// OMP_MAX_ACTIVE_LEVELS, OMP_NESTED, OMP_NUM_THREADS, and OMP_PROC_BIND\nextern int __kmp_dflt_max_active_levels;\n// Indicates whether value of __kmp_dflt_max_active_levels was already\n// explicitly set by OMP_MAX_ACTIVE_LEVELS or OMP_NESTED=false\nextern bool __kmp_dflt_max_active_levels_set;\nextern int __kmp_dispatch_num_buffers; /* max possible dynamic loops in\n                                          concurrent execution per team */\n#if KMP_NESTED_HOT_TEAMS\nextern int __kmp_hot_teams_mode;\nextern int __kmp_hot_teams_max_level;\n#endif\n\n#if KMP_OS_LINUX\nextern enum clock_function_type __kmp_clock_function;\nextern int __kmp_clock_function_param;\n#endif /* KMP_OS_LINUX */\n\n#if KMP_MIC_SUPPORTED\nextern enum mic_type __kmp_mic_type;\n#endif\n\n#ifdef USE_LOAD_BALANCE\nextern double __kmp_load_balance_interval; // load balance algorithm interval\n#endif /* USE_LOAD_BALANCE */\n\n// OpenMP 3.1 - Nested num threads array\ntypedef struct kmp_nested_nthreads_t {\n  int *nth;\n  int size;\n  int used;\n} kmp_nested_nthreads_t;\n\nextern kmp_nested_nthreads_t __kmp_nested_nth;\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\n// Parameters for the speculative lock backoff system.\nstruct kmp_adaptive_backoff_params_t {\n  // Number of soft retries before it counts as a hard retry.\n  kmp_uint32 max_soft_retries;\n  // Badness is a bit mask : 0,1,3,7,15,... on each hard failure we move one to\n  // the right\n  kmp_uint32 max_badness;\n};\n\nextern kmp_adaptive_backoff_params_t __kmp_adaptive_backoff_params;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\nextern const char *__kmp_speculative_statsfile;\n#endif\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\nextern int __kmp_display_env; /* TRUE or FALSE */\nextern int __kmp_display_env_verbose; /* TRUE if OMP_DISPLAY_ENV=VERBOSE */\nextern int __kmp_omp_cancellation; /* TRUE or FALSE */\nextern int __kmp_nteams;\nextern int __kmp_teams_thread_limit;\n\n/* ------------------------------------------------------------------------- */\n\n/* the following are protected by the fork/join lock */\n/* write: lock  read: anytime */\nextern kmp_info_t **__kmp_threads; /* Descriptors for the threads */\n/* read/write: lock */\nextern volatile kmp_team_t *__kmp_team_pool;\nextern volatile kmp_info_t *__kmp_thread_pool;\nextern kmp_info_t *__kmp_thread_pool_insert_pt;\n\n// total num threads reachable from some root thread including all root threads\nextern volatile int __kmp_nth;\n/* total number of threads reachable from some root thread including all root\n   threads, and those in the thread pool */\nextern volatile int __kmp_all_nth;\nextern std::atomic<int> __kmp_thread_pool_active_nth;\n\nextern kmp_root_t **__kmp_root; /* root of thread hierarchy */\n/* end data protected by fork/join lock */\n/* ------------------------------------------------------------------------- */\n\n#define __kmp_get_gtid() __kmp_get_global_thread_id()\n#define __kmp_entry_gtid() __kmp_get_global_thread_id_reg()\n#define __kmp_get_tid() (__kmp_tid_from_gtid(__kmp_get_gtid()))\n#define __kmp_get_team() (__kmp_threads[(__kmp_get_gtid())]->th.th_team)\n#define __kmp_get_thread() (__kmp_thread_from_gtid(__kmp_get_gtid()))\n\n// AT: Which way is correct?\n// AT: 1. nproc = __kmp_threads[ ( gtid ) ] -> th.th_team -> t.t_nproc;\n// AT: 2. nproc = __kmp_threads[ ( gtid ) ] -> th.th_team_nproc;\n#define __kmp_get_team_num_threads(gtid)                                       \\\n  (__kmp_threads[(gtid)]->th.th_team->t.t_nproc)\n\nstatic inline bool KMP_UBER_GTID(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= KMP_GTID_MIN);\n  KMP_DEBUG_ASSERT(gtid < __kmp_threads_capacity);\n  return (gtid >= 0 && __kmp_root[gtid] && __kmp_threads[gtid] &&\n          __kmp_threads[gtid] == __kmp_root[gtid]->r.r_uber_thread);\n}\n\nstatic inline int __kmp_tid_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid]->th.th_info.ds.ds_tid;\n}\n\nstatic inline int __kmp_gtid_from_tid(int tid, const kmp_team_t *team) {\n  KMP_DEBUG_ASSERT(tid >= 0 && team);\n  return team->t.t_threads[tid]->th.th_info.ds.ds_gtid;\n}\n\nstatic inline int __kmp_gtid_from_thread(const kmp_info_t *thr) {\n  KMP_DEBUG_ASSERT(thr);\n  return thr->th.th_info.ds.ds_gtid;\n}\n\nstatic inline kmp_info_t *__kmp_thread_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid];\n}\n\nstatic inline kmp_team_t *__kmp_team_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid]->th.th_team;\n}\n\nstatic inline void __kmp_assert_valid_gtid(kmp_int32 gtid) {\n  if (UNLIKELY(gtid < 0 || gtid >= __kmp_threads_capacity))\n    KMP_FATAL(ThreadIdentInvalid);\n}\n\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\nextern int __kmp_user_level_mwait; // TRUE or FALSE; from KMP_USER_LEVEL_MWAIT\nextern int __kmp_umwait_enabled; // Runtime check if user-level mwait enabled\nextern int __kmp_mwait_enabled; // Runtime check if ring3 mwait is enabled\nextern int __kmp_mwait_hints; // Hints to pass in to mwait\n#endif\n\n/* ------------------------------------------------------------------------- */\n\nextern kmp_global_t __kmp_global; /* global status */\n\nextern kmp_info_t __kmp_monitor;\n// For Debugging Support Library\nextern std::atomic<kmp_int32> __kmp_team_counter;\n// For Debugging Support Library\nextern std::atomic<kmp_int32> __kmp_task_counter;\n\n#if USE_DEBUGGER\n#define _KMP_GEN_ID(counter)                                                   \\\n  (__kmp_debugging ? KMP_ATOMIC_INC(&counter) + 1 : ~0)\n#else\n#define _KMP_GEN_ID(counter) (~0)\n#endif /* USE_DEBUGGER */\n\n#define KMP_GEN_TASK_ID() _KMP_GEN_ID(__kmp_task_counter)\n#define KMP_GEN_TEAM_ID() _KMP_GEN_ID(__kmp_team_counter)\n\n/* ------------------------------------------------------------------------ */\n\nextern void __kmp_print_storage_map_gtid(int gtid, void *p1, void *p2,\n                                         size_t size, char const *format, ...);\n\nextern void __kmp_serial_initialize(void);\nextern void __kmp_middle_initialize(void);\nextern void __kmp_parallel_initialize(void);\n\nextern void __kmp_internal_begin(void);\nextern void __kmp_internal_end_library(int gtid);\nextern void __kmp_internal_end_thread(int gtid);\nextern void __kmp_internal_end_atexit(void);\nextern void __kmp_internal_end_dtor(void);\nextern void __kmp_internal_end_dest(void *);\n\nextern int __kmp_register_root(int initial_thread);\nextern void __kmp_unregister_root(int gtid);\nextern void __kmp_unregister_library(void); // called by __kmp_internal_end()\n\nextern int __kmp_ignore_mppbeg(void);\nextern int __kmp_ignore_mppend(void);\n\nextern int __kmp_enter_single(int gtid, ident_t *id_ref, int push_ws);\nextern void __kmp_exit_single(int gtid);\n\nextern void __kmp_parallel_deo(int *gtid_ref, int *cid_ref, ident_t *loc_ref);\nextern void __kmp_parallel_dxo(int *gtid_ref, int *cid_ref, ident_t *loc_ref);\n\n#ifdef USE_LOAD_BALANCE\nextern int __kmp_get_load_balance(int);\n#endif\n\nextern int __kmp_get_global_thread_id(void);\nextern int __kmp_get_global_thread_id_reg(void);\nextern void __kmp_exit_thread(int exit_status);\nextern void __kmp_abort(char const *format, ...);\nextern void __kmp_abort_thread(void);\nKMP_NORETURN extern void __kmp_abort_process(void);\nextern void __kmp_warn(char const *format, ...);\n\nextern void __kmp_set_num_threads(int new_nth, int gtid);\n\n// Returns current thread (pointer to kmp_info_t). Current thread *must* be\n// registered.\nstatic inline kmp_info_t *__kmp_entry_thread() {\n  int gtid = __kmp_entry_gtid();\n\n  return __kmp_threads[gtid];\n}\n\nextern void __kmp_set_max_active_levels(int gtid, int new_max_active_levels);\nextern int __kmp_get_max_active_levels(int gtid);\nextern int __kmp_get_ancestor_thread_num(int gtid, int level);\nextern int __kmp_get_team_size(int gtid, int level);\nextern void __kmp_set_schedule(int gtid, kmp_sched_t new_sched, int chunk);\nextern void __kmp_get_schedule(int gtid, kmp_sched_t *sched, int *chunk);\n\nextern unsigned short __kmp_get_random(kmp_info_t *thread);\nextern void __kmp_init_random(kmp_info_t *thread);\n\nextern kmp_r_sched_t __kmp_get_schedule_global(void);\nextern void __kmp_adjust_num_threads(int new_nproc);\nextern void __kmp_check_stksize(size_t *val);\n\nextern void *___kmp_allocate(size_t size KMP_SRC_LOC_DECL);\nextern void *___kmp_page_allocate(size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_free(void *ptr KMP_SRC_LOC_DECL);\n#define __kmp_allocate(size) ___kmp_allocate((size)KMP_SRC_LOC_CURR)\n#define __kmp_page_allocate(size) ___kmp_page_allocate((size)KMP_SRC_LOC_CURR)\n#define __kmp_free(ptr) ___kmp_free((ptr)KMP_SRC_LOC_CURR)\n\n#if USE_FAST_MEMORY\nextern void *___kmp_fast_allocate(kmp_info_t *this_thr,\n                                  size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_fast_free(kmp_info_t *this_thr, void *ptr KMP_SRC_LOC_DECL);\nextern void __kmp_free_fast_memory(kmp_info_t *this_thr);\nextern void __kmp_initialize_fast_memory(kmp_info_t *this_thr);\n#define __kmp_fast_allocate(this_thr, size)                                    \\\n  ___kmp_fast_allocate((this_thr), (size)KMP_SRC_LOC_CURR)\n#define __kmp_fast_free(this_thr, ptr)                                         \\\n  ___kmp_fast_free((this_thr), (ptr)KMP_SRC_LOC_CURR)\n#endif\n\nextern void *___kmp_thread_malloc(kmp_info_t *th, size_t size KMP_SRC_LOC_DECL);\nextern void *___kmp_thread_calloc(kmp_info_t *th, size_t nelem,\n                                  size_t elsize KMP_SRC_LOC_DECL);\nextern void *___kmp_thread_realloc(kmp_info_t *th, void *ptr,\n                                   size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_thread_free(kmp_info_t *th, void *ptr KMP_SRC_LOC_DECL);\n#define __kmp_thread_malloc(th, size)                                          \\\n  ___kmp_thread_malloc((th), (size)KMP_SRC_LOC_CURR)\n#define __kmp_thread_calloc(th, nelem, elsize)                                 \\\n  ___kmp_thread_calloc((th), (nelem), (elsize)KMP_SRC_LOC_CURR)\n#define __kmp_thread_realloc(th, ptr, size)                                    \\\n  ___kmp_thread_realloc((th), (ptr), (size)KMP_SRC_LOC_CURR)\n#define __kmp_thread_free(th, ptr)                                             \\\n  ___kmp_thread_free((th), (ptr)KMP_SRC_LOC_CURR)\n\n#define KMP_INTERNAL_MALLOC(sz) malloc(sz)\n#define KMP_INTERNAL_FREE(p) free(p)\n#define KMP_INTERNAL_REALLOC(p, sz) realloc((p), (sz))\n#define KMP_INTERNAL_CALLOC(n, sz) calloc((n), (sz))\n\nextern void __kmp_push_num_threads(ident_t *loc, int gtid, int num_threads);\n\nextern void __kmp_push_proc_bind(ident_t *loc, int gtid,\n                                 kmp_proc_bind_t proc_bind);\nextern void __kmp_push_num_teams(ident_t *loc, int gtid, int num_teams,\n                                 int num_threads);\nextern void __kmp_push_num_teams_51(ident_t *loc, int gtid, int num_teams_lb,\n                                    int num_teams_ub, int num_threads);\n\nextern void __kmp_yield();\n\nextern void __kmpc_dispatch_init_4(ident_t *loc, kmp_int32 gtid,\n                                   enum sched_type schedule, kmp_int32 lb,\n                                   kmp_int32 ub, kmp_int32 st, kmp_int32 chunk);\nextern void __kmpc_dispatch_init_4u(ident_t *loc, kmp_int32 gtid,\n                                    enum sched_type schedule, kmp_uint32 lb,\n                                    kmp_uint32 ub, kmp_int32 st,\n                                    kmp_int32 chunk);\nextern void __kmpc_dispatch_init_8(ident_t *loc, kmp_int32 gtid,\n                                   enum sched_type schedule, kmp_int64 lb,\n                                   kmp_int64 ub, kmp_int64 st, kmp_int64 chunk);\nextern void __kmpc_dispatch_init_8u(ident_t *loc, kmp_int32 gtid,\n                                    enum sched_type schedule, kmp_uint64 lb,\n                                    kmp_uint64 ub, kmp_int64 st,\n                                    kmp_int64 chunk);\n\nextern int __kmpc_dispatch_next_4(ident_t *loc, kmp_int32 gtid,\n                                  kmp_int32 *p_last, kmp_int32 *p_lb,\n                                  kmp_int32 *p_ub, kmp_int32 *p_st);\nextern int __kmpc_dispatch_next_4u(ident_t *loc, kmp_int32 gtid,\n                                   kmp_int32 *p_last, kmp_uint32 *p_lb,\n                                   kmp_uint32 *p_ub, kmp_int32 *p_st);\nextern int __kmpc_dispatch_next_8(ident_t *loc, kmp_int32 gtid,\n                                  kmp_int32 *p_last, kmp_int64 *p_lb,\n                                  kmp_int64 *p_ub, kmp_int64 *p_st);\nextern int __kmpc_dispatch_next_8u(ident_t *loc, kmp_int32 gtid,\n                                   kmp_int32 *p_last, kmp_uint64 *p_lb,\n                                   kmp_uint64 *p_ub, kmp_int64 *p_st);\n\nextern void __kmpc_dispatch_fini_4(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_8(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_4u(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_8u(ident_t *loc, kmp_int32 gtid);\n\n#ifdef KMP_GOMP_COMPAT\n\nextern void __kmp_aux_dispatch_init_4(ident_t *loc, kmp_int32 gtid,\n                                      enum sched_type schedule, kmp_int32 lb,\n                                      kmp_int32 ub, kmp_int32 st,\n                                      kmp_int32 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_4u(ident_t *loc, kmp_int32 gtid,\n                                       enum sched_type schedule, kmp_uint32 lb,\n                                       kmp_uint32 ub, kmp_int32 st,\n                                       kmp_int32 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_8(ident_t *loc, kmp_int32 gtid,\n                                      enum sched_type schedule, kmp_int64 lb,\n                                      kmp_int64 ub, kmp_int64 st,\n                                      kmp_int64 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_8u(ident_t *loc, kmp_int32 gtid,\n                                       enum sched_type schedule, kmp_uint64 lb,\n                                       kmp_uint64 ub, kmp_int64 st,\n                                       kmp_int64 chunk, int push_ws);\nextern void __kmp_aux_dispatch_fini_chunk_4(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_8(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_4u(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_8u(ident_t *loc, kmp_int32 gtid);\n\n#endif /* KMP_GOMP_COMPAT */\n\nextern kmp_uint32 __kmp_eq_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_neq_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_lt_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_ge_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_le_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_wait_4(kmp_uint32 volatile *spinner, kmp_uint32 checker,\n                               kmp_uint32 (*pred)(kmp_uint32, kmp_uint32),\n                               void *obj);\nextern void __kmp_wait_4_ptr(void *spinner, kmp_uint32 checker,\n                             kmp_uint32 (*pred)(void *, kmp_uint32), void *obj);\n\nextern void __kmp_wait_64(kmp_info_t *this_thr, kmp_flag_64<> *flag,\n                          int final_spin\n#if USE_ITT_BUILD\n                          ,\n                          void *itt_sync_obj\n#endif\n);\nextern void __kmp_release_64(kmp_flag_64<> *flag);\n\nextern void __kmp_infinite_loop(void);\n\nextern void __kmp_cleanup(void);\n\n#if KMP_HANDLE_SIGNALS\nextern int __kmp_handle_signals;\nextern void __kmp_install_signals(int parallel_init);\nextern void __kmp_remove_signals(void);\n#endif\n\nextern void __kmp_clear_system_time(void);\nextern void __kmp_read_system_time(double *delta);\n\nextern void __kmp_check_stack_overlap(kmp_info_t *thr);\n\nextern void __kmp_expand_host_name(char *buffer, size_t size);\nextern void __kmp_expand_file_name(char *result, size_t rlen, char *pattern);\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern void\n__kmp_initialize_system_tick(void); /* Initialize timer tick value */\n#endif\n\nextern void\n__kmp_runtime_initialize(void); /* machine specific initialization */\nextern void __kmp_runtime_destroy(void);\n\n#if KMP_AFFINITY_SUPPORTED\nextern char *__kmp_affinity_print_mask(char *buf, int buf_len,\n                                       kmp_affin_mask_t *mask);\nextern kmp_str_buf_t *__kmp_affinity_str_buf_mask(kmp_str_buf_t *buf,\n                                                  kmp_affin_mask_t *mask);\nextern void __kmp_affinity_initialize(void);\nextern void __kmp_affinity_uninitialize(void);\nextern void __kmp_affinity_set_init_mask(\n    int gtid, int isa_root); /* set affinity according to KMP_AFFINITY */\nextern void __kmp_affinity_set_place(int gtid);\nextern void __kmp_affinity_determine_capable(const char *env_var);\nextern int __kmp_aux_set_affinity(void **mask);\nextern int __kmp_aux_get_affinity(void **mask);\nextern int __kmp_aux_get_affinity_max_proc();\nextern int __kmp_aux_set_affinity_mask_proc(int proc, void **mask);\nextern int __kmp_aux_unset_affinity_mask_proc(int proc, void **mask);\nextern int __kmp_aux_get_affinity_mask_proc(int proc, void **mask);\nextern void __kmp_balanced_affinity(kmp_info_t *th, int team_size);\n#if KMP_OS_LINUX || KMP_OS_FREEBSD\nextern int kmp_set_thread_affinity_mask_initial(void);\n#endif\n#endif /* KMP_AFFINITY_SUPPORTED */\n// No need for KMP_AFFINITY_SUPPORTED guard as only one field in the\n// format string is for affinity, so platforms that do not support\n// affinity can still use the other fields, e.g., %n for num_threads\nextern size_t __kmp_aux_capture_affinity(int gtid, const char *format,\n                                         kmp_str_buf_t *buffer);\nextern void __kmp_aux_display_affinity(int gtid, const char *format);\n\nextern void __kmp_cleanup_hierarchy();\nextern void __kmp_get_hierarchy(kmp_uint32 nproc, kmp_bstate_t *thr_bar);\n\n#if KMP_USE_FUTEX\n\nextern int __kmp_futex_determine_capable(void);\n\n#endif // KMP_USE_FUTEX\n\nextern void __kmp_gtid_set_specific(int gtid);\nextern int __kmp_gtid_get_specific(void);\n\nextern double __kmp_read_cpu_time(void);\n\nextern int __kmp_read_system_info(struct kmp_sys_info *info);\n\n#if KMP_USE_MONITOR\nextern void __kmp_create_monitor(kmp_info_t *th);\n#endif\n\nextern void *__kmp_launch_thread(kmp_info_t *thr);\n\nextern void __kmp_create_worker(int gtid, kmp_info_t *th, size_t stack_size);\n\n#if KMP_OS_WINDOWS\nextern int __kmp_still_running(kmp_info_t *th);\nextern int __kmp_is_thread_alive(kmp_info_t *th, DWORD *exit_val);\nextern void __kmp_free_handle(kmp_thread_t tHandle);\n#endif\n\n#if KMP_USE_MONITOR\nextern void __kmp_reap_monitor(kmp_info_t *th);\n#endif\nextern void __kmp_reap_worker(kmp_info_t *th);\nextern void __kmp_terminate_thread(int gtid);\n\nextern int __kmp_try_suspend_mx(kmp_info_t *th);\nextern void __kmp_lock_suspend_mx(kmp_info_t *th);\nextern void __kmp_unlock_suspend_mx(kmp_info_t *th);\n\nextern void __kmp_elapsed(double *);\nextern void __kmp_elapsed_tick(double *);\n\nextern void __kmp_enable(int old_state);\nextern void __kmp_disable(int *old_state);\n\nextern void __kmp_thread_sleep(int millis);\n\nextern void __kmp_common_initialize(void);\nextern void __kmp_common_destroy(void);\nextern void __kmp_common_destroy_gtid(int gtid);\n\n#if KMP_OS_UNIX\nextern void __kmp_register_atfork(void);\n#endif\nextern void __kmp_suspend_initialize(void);\nextern void __kmp_suspend_initialize_thread(kmp_info_t *th);\nextern void __kmp_suspend_uninitialize_thread(kmp_info_t *th);\n\nextern kmp_info_t *__kmp_allocate_thread(kmp_root_t *root, kmp_team_t *team,\n                                         int tid);\nextern kmp_team_t *\n__kmp_allocate_team(kmp_root_t *root, int new_nproc, int max_nproc,\n#if OMPT_SUPPORT\n                    ompt_data_t ompt_parallel_data,\n#endif\n                    kmp_proc_bind_t proc_bind, kmp_internal_control_t *new_icvs,\n                    int argc USE_NESTED_HOT_ARG(kmp_info_t *thr));\nextern void __kmp_free_thread(kmp_info_t *);\nextern void __kmp_free_team(kmp_root_t *,\n                            kmp_team_t *USE_NESTED_HOT_ARG(kmp_info_t *));\nextern kmp_team_t *__kmp_reap_team(kmp_team_t *);\n\n/* ------------------------------------------------------------------------ */\n\nextern void __kmp_initialize_bget(kmp_info_t *th);\nextern void __kmp_finalize_bget(kmp_info_t *th);\n\nKMP_EXPORT void *kmpc_malloc(size_t size);\nKMP_EXPORT void *kmpc_aligned_malloc(size_t size, size_t alignment);\nKMP_EXPORT void *kmpc_calloc(size_t nelem, size_t elsize);\nKMP_EXPORT void *kmpc_realloc(void *ptr, size_t size);\nKMP_EXPORT void kmpc_free(void *ptr);\n\n/* declarations for internal use */\n\nextern int __kmp_barrier(enum barrier_type bt, int gtid, int is_split,\n                         size_t reduce_size, void *reduce_data,\n                         void (*reduce)(void *, void *));\nextern void __kmp_end_split_barrier(enum barrier_type bt, int gtid);\nextern int __kmp_barrier_gomp_cancel(int gtid);\n\n/*!\n * Tell the fork call which compiler generated the fork call, and therefore how\n * to deal with the call.\n */\nenum fork_context_e {\n  fork_context_gnu, /**< Called from GNU generated code, so must not invoke the\n                       microtask internally. */\n  fork_context_intel, /**< Called from Intel generated code.  */\n  fork_context_last\n};\nextern int __kmp_fork_call(ident_t *loc, int gtid,\n                           enum fork_context_e fork_context, kmp_int32 argc,\n                           microtask_t microtask, launch_t invoker,\n                           kmp_va_list ap);\n\nextern void __kmp_join_call(ident_t *loc, int gtid\n#if OMPT_SUPPORT\n                            ,\n                            enum fork_context_e fork_context\n#endif\n                            ,\n                            int exit_teams = 0);\n\nextern void __kmp_serialized_parallel(ident_t *id, kmp_int32 gtid);\nextern void __kmp_internal_fork(ident_t *id, int gtid, kmp_team_t *team);\nextern void __kmp_internal_join(ident_t *id, int gtid, kmp_team_t *team);\nextern int __kmp_invoke_task_func(int gtid);\nextern void __kmp_run_before_invoked_task(int gtid, int tid,\n                                          kmp_info_t *this_thr,\n                                          kmp_team_t *team);\nextern void __kmp_run_after_invoked_task(int gtid, int tid,\n                                         kmp_info_t *this_thr,\n                                         kmp_team_t *team);\n\n// should never have been exported\nKMP_EXPORT int __kmpc_invoke_task_func(int gtid);\nextern int __kmp_invoke_teams_master(int gtid);\nextern void __kmp_teams_master(int gtid);\nextern int __kmp_aux_get_team_num();\nextern int __kmp_aux_get_num_teams();\nextern void __kmp_save_internal_controls(kmp_info_t *thread);\nextern void __kmp_user_set_library(enum library_type arg);\nextern void __kmp_aux_set_library(enum library_type arg);\nextern void __kmp_aux_set_stacksize(size_t arg);\nextern void __kmp_aux_set_blocktime(int arg, kmp_info_t *thread, int tid);\nextern void __kmp_aux_set_defaults(char const *str, size_t len);\n\n/* Functions called from __kmp_aux_env_initialize() in kmp_settings.cpp */\nvoid kmpc_set_blocktime(int arg);\nvoid ompc_set_nested(int flag);\nvoid ompc_set_dynamic(int flag);\nvoid ompc_set_num_threads(int arg);\n\nextern void __kmp_push_current_task_to_thread(kmp_info_t *this_thr,\n                                              kmp_team_t *team, int tid);\nextern void __kmp_pop_current_task_from_thread(kmp_info_t *this_thr);\nextern kmp_task_t *__kmp_task_alloc(ident_t *loc_ref, kmp_int32 gtid,\n                                    kmp_tasking_flags_t *flags,\n                                    size_t sizeof_kmp_task_t,\n                                    size_t sizeof_shareds,\n                                    kmp_routine_entry_t task_entry);\nextern void __kmp_init_implicit_task(ident_t *loc_ref, kmp_info_t *this_thr,\n                                     kmp_team_t *team, int tid,\n                                     int set_curr_task);\nextern void __kmp_finish_implicit_task(kmp_info_t *this_thr);\nextern void __kmp_free_implicit_task(kmp_info_t *this_thr);\n\nextern kmp_event_t *__kmpc_task_allow_completion_event(ident_t *loc_ref,\n                                                       int gtid,\n                                                       kmp_task_t *task);\nextern void __kmp_fulfill_event(kmp_event_t *event);\n\nextern void __kmp_free_task_team(kmp_info_t *thread,\n                                 kmp_task_team_t *task_team);\nextern void __kmp_reap_task_teams(void);\nextern void __kmp_wait_to_unref_task_teams(void);\nextern void __kmp_task_team_setup(kmp_info_t *this_thr, kmp_team_t *team,\n                                  int always);\nextern void __kmp_task_team_sync(kmp_info_t *this_thr, kmp_team_t *team);\nextern void __kmp_task_team_wait(kmp_info_t *this_thr, kmp_team_t *team\n#if USE_ITT_BUILD\n                                 ,\n                                 void *itt_sync_obj\n#endif /* USE_ITT_BUILD */\n                                 ,\n                                 int wait = 1);\nextern void __kmp_tasking_barrier(kmp_team_t *team, kmp_info_t *thread,\n                                  int gtid);\n\nextern int __kmp_is_address_mapped(void *addr);\nextern kmp_uint64 __kmp_hardware_timestamp(void);\n\n#if KMP_OS_UNIX\nextern int __kmp_read_from_file(char const *path, char const *format, ...);\n#endif\n\n/* ------------------------------------------------------------------------ */\n//\n// Assembly routines that have no compiler intrinsic replacement\n//\n\nextern int __kmp_invoke_microtask(microtask_t pkfn, int gtid, int npr, int argc,\n                                  void *argv[]\n#if OMPT_SUPPORT\n                                  ,\n                                  void **exit_frame_ptr\n#endif\n);\n\n/* ------------------------------------------------------------------------ */\n\nKMP_EXPORT void __kmpc_begin(ident_t *, kmp_int32 flags);\nKMP_EXPORT void __kmpc_end(ident_t *);\n\nKMP_EXPORT void __kmpc_threadprivate_register_vec(ident_t *, void *data,\n                                                  kmpc_ctor_vec ctor,\n                                                  kmpc_cctor_vec cctor,\n                                                  kmpc_dtor_vec dtor,\n                                                  size_t vector_length);\nKMP_EXPORT void __kmpc_threadprivate_register(ident_t *, void *data,\n                                              kmpc_ctor ctor, kmpc_cctor cctor,\n                                              kmpc_dtor dtor);\nKMP_EXPORT void *__kmpc_threadprivate(ident_t *, kmp_int32 global_tid,\n                                      void *data, size_t size);\n\nKMP_EXPORT kmp_int32 __kmpc_global_thread_num(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_global_num_threads(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_bound_thread_num(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_bound_num_threads(ident_t *);\n\nKMP_EXPORT kmp_int32 __kmpc_ok_to_fork(ident_t *);\nKMP_EXPORT void __kmpc_fork_call(ident_t *, kmp_int32 nargs,\n                                 kmpc_micro microtask, ...);\n\nKMP_EXPORT void __kmpc_serialized_parallel(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_serialized_parallel(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT void __kmpc_flush(ident_t *);\nKMP_EXPORT void __kmpc_barrier(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT kmp_int32 __kmpc_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT kmp_int32 __kmpc_masked(ident_t *, kmp_int32 global_tid,\n                                   kmp_int32 filter);\nKMP_EXPORT void __kmpc_end_masked(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_ordered(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_ordered(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_critical(ident_t *, kmp_int32 global_tid,\n                                kmp_critical_name *);\nKMP_EXPORT void __kmpc_end_critical(ident_t *, kmp_int32 global_tid,\n                                    kmp_critical_name *);\nKMP_EXPORT void __kmpc_critical_with_hint(ident_t *, kmp_int32 global_tid,\n                                          kmp_critical_name *, uint32_t hint);\n\nKMP_EXPORT kmp_int32 __kmpc_barrier_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_barrier_master(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT kmp_int32 __kmpc_barrier_master_nowait(ident_t *,\n                                                  kmp_int32 global_tid);\n\nKMP_EXPORT kmp_int32 __kmpc_single(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_single(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT void KMPC_FOR_STATIC_INIT(ident_t *loc, kmp_int32 global_tid,\n                                     kmp_int32 schedtype, kmp_int32 *plastiter,\n                                     kmp_int *plower, kmp_int *pupper,\n                                     kmp_int *pstride, kmp_int incr,\n                                     kmp_int chunk);\n\nKMP_EXPORT void __kmpc_for_static_fini(ident_t *loc, kmp_int32 global_tid);\n\nKMP_EXPORT void __kmpc_copyprivate(ident_t *loc, kmp_int32 global_tid,\n                                   size_t cpy_size, void *cpy_data,\n                                   void (*cpy_func)(void *, void *),\n                                   kmp_int32 didit);\n\nextern void KMPC_SET_NUM_THREADS(int arg);\nextern void KMPC_SET_DYNAMIC(int flag);\nextern void KMPC_SET_NESTED(int flag);\n\n/* OMP 3.0 tasking interface routines */\nKMP_EXPORT kmp_int32 __kmpc_omp_task(ident_t *loc_ref, kmp_int32 gtid,\n                                     kmp_task_t *new_task);\nKMP_EXPORT kmp_task_t *__kmpc_omp_task_alloc(ident_t *loc_ref, kmp_int32 gtid,\n                                             kmp_int32 flags,\n                                             size_t sizeof_kmp_task_t,\n                                             size_t sizeof_shareds,\n                                             kmp_routine_entry_t task_entry);\nKMP_EXPORT kmp_task_t *__kmpc_omp_target_task_alloc(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_int32 flags, size_t sizeof_kmp_task_t,\n    size_t sizeof_shareds, kmp_routine_entry_t task_entry, kmp_int64 device_id);\nKMP_EXPORT void __kmpc_omp_task_begin_if0(ident_t *loc_ref, kmp_int32 gtid,\n                                          kmp_task_t *task);\nKMP_EXPORT void __kmpc_omp_task_complete_if0(ident_t *loc_ref, kmp_int32 gtid,\n                                             kmp_task_t *task);\nKMP_EXPORT kmp_int32 __kmpc_omp_task_parts(ident_t *loc_ref, kmp_int32 gtid,\n                                           kmp_task_t *new_task);\nKMP_EXPORT kmp_int32 __kmpc_omp_taskwait(ident_t *loc_ref, kmp_int32 gtid);\n\nKMP_EXPORT kmp_int32 __kmpc_omp_taskyield(ident_t *loc_ref, kmp_int32 gtid,\n                                          int end_part);\n\n#if TASK_UNUSED\nvoid __kmpc_omp_task_begin(ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *task);\nvoid __kmpc_omp_task_complete(ident_t *loc_ref, kmp_int32 gtid,\n                              kmp_task_t *task);\n#endif // TASK_UNUSED\n\n/* ------------------------------------------------------------------------ */\n\nKMP_EXPORT void __kmpc_taskgroup(ident_t *loc, int gtid);\nKMP_EXPORT void __kmpc_end_taskgroup(ident_t *loc, int gtid);\n\nKMP_EXPORT kmp_int32 __kmpc_omp_task_with_deps(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *new_task, kmp_int32 ndeps,\n    kmp_depend_info_t *dep_list, kmp_int32 ndeps_noalias,\n    kmp_depend_info_t *noalias_dep_list);\nKMP_EXPORT void __kmpc_omp_wait_deps(ident_t *loc_ref, kmp_int32 gtid,\n                                     kmp_int32 ndeps,\n                                     kmp_depend_info_t *dep_list,\n                                     kmp_int32 ndeps_noalias,\n                                     kmp_depend_info_t *noalias_dep_list);\nextern kmp_int32 __kmp_omp_task(kmp_int32 gtid, kmp_task_t *new_task,\n                                bool serialize_immediate);\n\nKMP_EXPORT kmp_int32 __kmpc_cancel(ident_t *loc_ref, kmp_int32 gtid,\n                                   kmp_int32 cncl_kind);\nKMP_EXPORT kmp_int32 __kmpc_cancellationpoint(ident_t *loc_ref, kmp_int32 gtid,\n                                              kmp_int32 cncl_kind);\nKMP_EXPORT kmp_int32 __kmpc_cancel_barrier(ident_t *loc_ref, kmp_int32 gtid);\nKMP_EXPORT int __kmp_get_cancellation_status(int cancel_kind);\n\nKMP_EXPORT void __kmpc_proxy_task_completed(kmp_int32 gtid, kmp_task_t *ptask);\nKMP_EXPORT void __kmpc_proxy_task_completed_ooo(kmp_task_t *ptask);\nKMP_EXPORT void __kmpc_taskloop(ident_t *loc, kmp_int32 gtid, kmp_task_t *task,\n                                kmp_int32 if_val, kmp_uint64 *lb,\n                                kmp_uint64 *ub, kmp_int64 st, kmp_int32 nogroup,\n                                kmp_int32 sched, kmp_uint64 grainsize,\n                                void *task_dup);\nKMP_EXPORT void __kmpc_taskloop_5(ident_t *loc, kmp_int32 gtid,\n                                  kmp_task_t *task, kmp_int32 if_val,\n                                  kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st,\n                                  kmp_int32 nogroup, kmp_int32 sched,\n                                  kmp_uint64 grainsize, kmp_int32 modifier,\n                                  void *task_dup);\nKMP_EXPORT void *__kmpc_task_reduction_init(int gtid, int num_data, void *data);\nKMP_EXPORT void *__kmpc_taskred_init(int gtid, int num_data, void *data);\nKMP_EXPORT void *__kmpc_task_reduction_get_th_data(int gtid, void *tg, void *d);\nKMP_EXPORT void *__kmpc_task_reduction_modifier_init(ident_t *loc, int gtid,\n                                                     int is_ws, int num,\n                                                     void *data);\nKMP_EXPORT void *__kmpc_taskred_modifier_init(ident_t *loc, int gtid, int is_ws,\n                                              int num, void *data);\nKMP_EXPORT void __kmpc_task_reduction_modifier_fini(ident_t *loc, int gtid,\n                                                    int is_ws);\nKMP_EXPORT kmp_int32 __kmpc_omp_reg_task_with_affinity(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *new_task, kmp_int32 naffins,\n    kmp_task_affinity_info_t *affin_list);\nKMP_EXPORT void __kmp_set_num_teams(int num_teams);\nKMP_EXPORT int __kmp_get_max_teams(void);\nKMP_EXPORT void __kmp_set_teams_thread_limit(int limit);\nKMP_EXPORT int __kmp_get_teams_thread_limit(void);\n\n/* Lock interface routines (fast versions with gtid passed in) */\nKMP_EXPORT void __kmpc_init_lock(ident_t *loc, kmp_int32 gtid,\n                                 void **user_lock);\nKMP_EXPORT void __kmpc_init_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                      void **user_lock);\nKMP_EXPORT void __kmpc_destroy_lock(ident_t *loc, kmp_int32 gtid,\n                                    void **user_lock);\nKMP_EXPORT void __kmpc_destroy_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                         void **user_lock);\nKMP_EXPORT void __kmpc_set_lock(ident_t *loc, kmp_int32 gtid, void **user_lock);\nKMP_EXPORT void __kmpc_set_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                     void **user_lock);\nKMP_EXPORT void __kmpc_unset_lock(ident_t *loc, kmp_int32 gtid,\n                                  void **user_lock);\nKMP_EXPORT void __kmpc_unset_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                       void **user_lock);\nKMP_EXPORT int __kmpc_test_lock(ident_t *loc, kmp_int32 gtid, void **user_lock);\nKMP_EXPORT int __kmpc_test_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                     void **user_lock);\n\nKMP_EXPORT void __kmpc_init_lock_with_hint(ident_t *loc, kmp_int32 gtid,\n                                           void **user_lock, uintptr_t hint);\nKMP_EXPORT void __kmpc_init_nest_lock_with_hint(ident_t *loc, kmp_int32 gtid,\n                                                void **user_lock,\n                                                uintptr_t hint);\n\n/* Interface to fast scalable reduce methods routines */\n\nKMP_EXPORT kmp_int32 __kmpc_reduce_nowait(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\nKMP_EXPORT void __kmpc_end_reduce_nowait(ident_t *loc, kmp_int32 global_tid,\n                                         kmp_critical_name *lck);\nKMP_EXPORT kmp_int32 __kmpc_reduce(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\nKMP_EXPORT void __kmpc_end_reduce(ident_t *loc, kmp_int32 global_tid,\n                                  kmp_critical_name *lck);\n\n/* Internal fast reduction routines */\n\nextern PACKED_REDUCTION_METHOD_T __kmp_determine_reduction_method(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\n\n// this function is for testing set/get/determine reduce method\nKMP_EXPORT kmp_int32 __kmp_get_reduce_method(void);\n\nKMP_EXPORT kmp_uint64 __kmpc_get_taskid();\nKMP_EXPORT kmp_uint64 __kmpc_get_parent_taskid();\n\n// C++ port\n// missing 'extern \"C\"' declarations\n\nKMP_EXPORT kmp_int32 __kmpc_in_parallel(ident_t *loc);\nKMP_EXPORT void __kmpc_pop_num_threads(ident_t *loc, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_push_num_threads(ident_t *loc, kmp_int32 global_tid,\n                                        kmp_int32 num_threads);\n\nKMP_EXPORT void __kmpc_push_proc_bind(ident_t *loc, kmp_int32 global_tid,\n                                      int proc_bind);\nKMP_EXPORT void __kmpc_push_num_teams(ident_t *loc, kmp_int32 global_tid,\n                                      kmp_int32 num_teams,\n                                      kmp_int32 num_threads);\n/* Function for OpenMP 5.1 num_teams clause */\nKMP_EXPORT void __kmpc_push_num_teams_51(ident_t *loc, kmp_int32 global_tid,\n                                         kmp_int32 num_teams_lb,\n                                         kmp_int32 num_teams_ub,\n                                         kmp_int32 num_threads);\nKMP_EXPORT void __kmpc_fork_teams(ident_t *loc, kmp_int32 argc,\n                                  kmpc_micro microtask, ...);\nstruct kmp_dim { // loop bounds info casted to kmp_int64\n  kmp_int64 lo; // lower\n  kmp_int64 up; // upper\n  kmp_int64 st; // stride\n};\nKMP_EXPORT void __kmpc_doacross_init(ident_t *loc, kmp_int32 gtid,\n                                     kmp_int32 num_dims,\n                                     const struct kmp_dim *dims);\nKMP_EXPORT void __kmpc_doacross_wait(ident_t *loc, kmp_int32 gtid,\n                                     const kmp_int64 *vec);\nKMP_EXPORT void __kmpc_doacross_post(ident_t *loc, kmp_int32 gtid,\n                                     const kmp_int64 *vec);\nKMP_EXPORT void __kmpc_doacross_fini(ident_t *loc, kmp_int32 gtid);\n\nKMP_EXPORT void *__kmpc_threadprivate_cached(ident_t *loc, kmp_int32 global_tid,\n                                             void *data, size_t size,\n                                             void ***cache);\n\n// Symbols for MS mutual detection.\nextern int _You_must_link_with_exactly_one_OpenMP_library;\nextern int _You_must_link_with_Intel_OpenMP_library;\n#if KMP_OS_WINDOWS && (KMP_VERSION_MAJOR > 4)\nextern int _You_must_link_with_Microsoft_OpenMP_library;\n#endif\n\n// The routines below are not exported.\n// Consider making them 'static' in corresponding source files.\nvoid kmp_threadprivate_insert_private_data(int gtid, void *pc_addr,\n                                           void *data_addr, size_t pc_size);\nstruct private_common *kmp_threadprivate_insert(int gtid, void *pc_addr,\n                                                void *data_addr,\n                                                size_t pc_size);\nvoid __kmp_threadprivate_resize_cache(int newCapacity);\nvoid __kmp_cleanup_threadprivate_caches();\n\n// ompc_, kmpc_ entries moved from omp.h.\n#if KMP_OS_WINDOWS\n#define KMPC_CONVENTION __cdecl\n#else\n#define KMPC_CONVENTION\n#endif\n\n#ifndef __OMP_H\ntypedef enum omp_sched_t {\n  omp_sched_static = 1,\n  omp_sched_dynamic = 2,\n  omp_sched_guided = 3,\n  omp_sched_auto = 4\n} omp_sched_t;\ntypedef void *kmp_affinity_mask_t;\n#endif\n\nKMP_EXPORT void KMPC_CONVENTION ompc_set_max_active_levels(int);\nKMP_EXPORT void KMPC_CONVENTION ompc_set_schedule(omp_sched_t, int);\nKMP_EXPORT int KMPC_CONVENTION ompc_get_ancestor_thread_num(int);\nKMP_EXPORT int KMPC_CONVENTION ompc_get_team_size(int);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_set_affinity_mask_proc(int, kmp_affinity_mask_t *);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_unset_affinity_mask_proc(int, kmp_affinity_mask_t *);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_get_affinity_mask_proc(int, kmp_affinity_mask_t *);\n\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_stacksize(int);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_stacksize_s(size_t);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_library(int);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_defaults(char const *);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_disp_num_buffers(int);\n\nenum kmp_target_offload_kind {\n  tgt_disabled = 0,\n  tgt_default = 1,\n  tgt_mandatory = 2\n};\ntypedef enum kmp_target_offload_kind kmp_target_offload_kind_t;\n// Set via OMP_TARGET_OFFLOAD if specified, defaults to tgt_default otherwise\nextern kmp_target_offload_kind_t __kmp_target_offload;\nextern int __kmpc_get_target_offload();\n\n// Constants used in libomptarget\n#define KMP_DEVICE_DEFAULT -1 // This is libomptarget's default device.\n#define KMP_DEVICE_ALL -11 // This is libomptarget's \"all devices\".\n\n// OMP Pause Resource\n\n// The following enum is used both to set the status in __kmp_pause_status, and\n// as the internal equivalent of the externally-visible omp_pause_resource_t.\ntypedef enum kmp_pause_status_t {\n  kmp_not_paused = 0, // status is not paused, or, requesting resume\n  kmp_soft_paused = 1, // status is soft-paused, or, requesting soft pause\n  kmp_hard_paused = 2 // status is hard-paused, or, requesting hard pause\n} kmp_pause_status_t;\n\n// This stores the pause state of the runtime\nextern kmp_pause_status_t __kmp_pause_status;\nextern int __kmpc_pause_resource(kmp_pause_status_t level);\nextern int __kmp_pause_resource(kmp_pause_status_t level);\n// Soft resume sets __kmp_pause_status, and wakes up all threads.\nextern void __kmp_resume_if_soft_paused();\n// Hard resume simply resets the status to not paused. Library will appear to\n// be uninitialized after hard pause. Let OMP constructs trigger required\n// initializations.\nstatic inline void __kmp_resume_if_hard_paused() {\n  if (__kmp_pause_status == kmp_hard_paused) {\n    __kmp_pause_status = kmp_not_paused;\n  }\n}\n\nextern void __kmp_omp_display_env(int verbose);\n\n// 1: it is initializing hidden helper team\nextern volatile int __kmp_init_hidden_helper;\n// 1: the hidden helper team is done\nextern volatile int __kmp_hidden_helper_team_done;\n// 1: enable hidden helper task\nextern kmp_int32 __kmp_enable_hidden_helper;\n// Main thread of hidden helper team\nextern kmp_info_t *__kmp_hidden_helper_main_thread;\n// Descriptors for the hidden helper threads\nextern kmp_info_t **__kmp_hidden_helper_threads;\n// Number of hidden helper threads\nextern kmp_int32 __kmp_hidden_helper_threads_num;\n// Number of hidden helper tasks that have not been executed yet\nextern std::atomic<kmp_int32> __kmp_unexecuted_hidden_helper_tasks;\n\nextern void __kmp_hidden_helper_initialize();\nextern void __kmp_hidden_helper_threads_initz_routine();\nextern void __kmp_do_initialize_hidden_helper_threads();\nextern void __kmp_hidden_helper_threads_initz_wait();\nextern void __kmp_hidden_helper_initz_release();\nextern void __kmp_hidden_helper_threads_deinitz_wait();\nextern void __kmp_hidden_helper_threads_deinitz_release();\nextern void __kmp_hidden_helper_main_thread_wait();\nextern void __kmp_hidden_helper_worker_thread_wait();\nextern void __kmp_hidden_helper_worker_thread_signal();\nextern void __kmp_hidden_helper_main_thread_release();\n\n// Check whether a given thread is a hidden helper thread\n#define KMP_HIDDEN_HELPER_THREAD(gtid)                                         \\\n  ((gtid) >= 1 && (gtid) <= __kmp_hidden_helper_threads_num)\n\n#define KMP_HIDDEN_HELPER_WORKER_THREAD(gtid)                                  \\\n  ((gtid) > 1 && (gtid) <= __kmp_hidden_helper_threads_num)\n\n// Map a gtid to a hidden helper thread. The first hidden helper thread, a.k.a\n// main thread, is skipped.\n#define KMP_GTID_TO_SHADOW_GTID(gtid)                                          \\\n  ((gtid) % (__kmp_hidden_helper_threads_num - 1) + 2)\n\n#ifdef __cplusplus\n}\n#endif\n\ntemplate <bool C, bool S>\nextern void __kmp_suspend_32(int th_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_suspend_64(int th_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_suspend_oncore(int th_gtid, kmp_flag_oncore *flag);\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\ntemplate <bool C, bool S>\nextern void __kmp_mwait_32(int th_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_mwait_64(int th_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_mwait_oncore(int th_gtid, kmp_flag_oncore *flag);\n#endif\ntemplate <bool C, bool S>\nextern void __kmp_resume_32(int target_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_resume_64(int target_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_resume_oncore(int target_gtid, kmp_flag_oncore *flag);\n\ntemplate <bool C, bool S>\nint __kmp_execute_tasks_32(kmp_info_t *thread, kmp_int32 gtid,\n                           kmp_flag_32<C, S> *flag, int final_spin,\n                           int *thread_finished,\n#if USE_ITT_BUILD\n                           void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                           kmp_int32 is_constrained);\ntemplate <bool C, bool S>\nint __kmp_execute_tasks_64(kmp_info_t *thread, kmp_int32 gtid,\n                           kmp_flag_64<C, S> *flag, int final_spin,\n                           int *thread_finished,\n#if USE_ITT_BUILD\n                           void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                           kmp_int32 is_constrained);\nint __kmp_execute_tasks_oncore(kmp_info_t *thread, kmp_int32 gtid,\n                               kmp_flag_oncore *flag, int final_spin,\n                               int *thread_finished,\n#if USE_ITT_BUILD\n                               void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                               kmp_int32 is_constrained);\n\n/// This class safely opens and closes a C-style FILE* object using RAII\n/// semantics. There are also methods which allow using stdout or stderr as\n/// the underlying FILE* object. With the implicit conversion operator to\n/// FILE*, an object with this type can be used in any function which takes\n/// a FILE* object e.g., fprintf().\n/// No close method is needed at use sites.\nclass kmp_safe_raii_file_t {\n  FILE *f;\n\n  void close() {\n    if (f && f != stdout && f != stderr) {\n      fclose(f);\n      f = nullptr;\n    }\n  }\n\npublic:\n  kmp_safe_raii_file_t() : f(nullptr) {}\n  kmp_safe_raii_file_t(const char *filename, const char *mode,\n                       const char *env_var = nullptr)\n      : f(nullptr) {\n    open(filename, mode, env_var);\n  }\n  ~kmp_safe_raii_file_t() { close(); }\n\n  /// Open filename using mode. This is automatically closed in the destructor.\n  /// The env_var parameter indicates the environment variable the filename\n  /// came from if != nullptr.\n  void open(const char *filename, const char *mode,\n            const char *env_var = nullptr) {\n    KMP_ASSERT(!f);\n    f = fopen(filename, mode);\n    if (!f) {\n      int code = errno;\n      if (env_var) {\n        __kmp_fatal(KMP_MSG(CantOpenFileForReading, filename), KMP_ERR(code),\n                    KMP_HNT(CheckEnvVar, env_var, filename), __kmp_msg_null);\n      } else {\n        __kmp_fatal(KMP_MSG(CantOpenFileForReading, filename), KMP_ERR(code),\n                    __kmp_msg_null);\n      }\n    }\n  }\n  /// Set the FILE* object to stdout and output there\n  /// No open call should happen before this call.\n  void set_stdout() {\n    KMP_ASSERT(!f);\n    f = stdout;\n  }\n  /// Set the FILE* object to stderr and output there\n  /// No open call should happen before this call.\n  void set_stderr() {\n    KMP_ASSERT(!f);\n    f = stderr;\n  }\n  operator bool() { return bool(f); }\n  operator FILE *() { return f; }\n};\n\ntemplate <typename SourceType, typename TargetType,\n          bool isSourceSmaller = (sizeof(SourceType) < sizeof(TargetType)),\n          bool isSourceEqual = (sizeof(SourceType) == sizeof(TargetType)),\n          bool isSourceSigned = std::is_signed<SourceType>::value,\n          bool isTargetSigned = std::is_signed<TargetType>::value>\nstruct kmp_convert {};\n\n// Both types are signed; Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, true, true> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, true, true> {\n  static TargetType to(SourceType src) { return src; }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, true, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    KMP_ASSERT(src >= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::min)()));\n    return (TargetType)src;\n  }\n};\n\n// Source signed, Target unsigned\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    return (TargetType)src;\n  }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    return (TargetType)src;\n  }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\n// Source unsigned, Target signed\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, false, true> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, false, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, false, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\n// Source unsigned, Target unsigned\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, false, false> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, false, false> {\n  static TargetType to(SourceType src) { return src; }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, false, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\ntemplate <typename T1, typename T2>\nstatic inline void __kmp_type_convert(T1 src, T2 *dest) {\n  *dest = kmp_convert<T1, T2>::to(src);\n}\n\n#endif /* KMP_H */\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_environment.h", "content": "/*\n * kmp_environment.h -- Handle environment variables OS-independently.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_ENVIRONMENT_H\n#define KMP_ENVIRONMENT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Return a copy of the value of environment variable or NULL if the variable\n// does not exist.\n// *Note*: Returned pointed *must* be freed after use with __kmp_env_free().\nchar *__kmp_env_get(char const *name);\nvoid __kmp_env_free(char const **value);\n\n// Return 1 if the environment variable exists or 0 if does not exist.\nint __kmp_env_exists(char const *name);\n\n// Set the environment variable.\nvoid __kmp_env_set(char const *name, char const *value, int overwrite);\n\n// Unset (remove) environment variable.\nvoid __kmp_env_unset(char const *name);\n\n// -----------------------------------------------------------------------------\n//  Working with environment blocks.\n\n/* kmp_env_blk_t is read-only collection of environment variables (or\n   environment-like). Usage:\n\nkmp_env_blk_t block;\n__kmp_env_blk_init( & block, NULL ); // Initialize block from process\n                                        // environment.\n// or\n__kmp_env_blk_init( & block, \"KMP_WARNING=1|KMP_AFFINITY=none\" ); // from string\n__kmp_env_blk_sort( & block ); // Optionally, sort list.\nfor ( i = 0; i < block.count; ++ i ) {\n    // Process block.vars[ i ].name and block.vars[ i ].value...\n}\n__kmp_env_block_free( & block );\n*/\n\nstruct __kmp_env_var {\n  char *name;\n  char *value;\n};\ntypedef struct __kmp_env_var kmp_env_var_t;\n\nstruct __kmp_env_blk {\n  char *bulk;\n  kmp_env_var_t *vars;\n  int count;\n};\ntypedef struct __kmp_env_blk kmp_env_blk_t;\n\nvoid __kmp_env_blk_init(kmp_env_blk_t *block, char const *bulk);\nvoid __kmp_env_blk_free(kmp_env_blk_t *block);\nvoid __kmp_env_blk_sort(kmp_env_blk_t *block);\nchar const *__kmp_env_blk_var(kmp_env_blk_t *block, char const *name);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // KMP_ENVIRONMENT_H\n\n// end of file //\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_i18n.h", "content": "/*\n * kmp_i18n.h\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_I18N_H\n#define KMP_I18N_H\n\n#include \"kmp_str.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n/* kmp_i18n_id.inc defines kmp_i18n_id_t type. It is an enumeration with\n   identifiers of all the messages in the catalog. There is one special\n   identifier: kmp_i18n_null, which denotes absence of message. */\n#include \"kmp_i18n_id.inc\" // Generated file. Do not edit it manually.\n\n/* Low-level functions handling message catalog. __kmp_i18n_open() opens message\n   catalog, __kmp_i18n_closes() it. Explicit opening is not required: if message\n   catalog is not yet open, __kmp_i18n_catgets() will open it implicitly.\n   However, catalog should be explicitly closed, otherwise resources (mamory,\n   handles) may leak.\n\n   __kmp_i18n_catgets() returns read-only string. It should not be freed.\n\n   KMP_I18N_STR macro simplifies access to strings in message catalog a bit.\n   Following two lines are equivalent:\n\n   __kmp_i18n_catgets( kmp_i18n_str_Warning )\n   KMP_I18N_STR( Warning )\n*/\n\nvoid __kmp_i18n_catopen();\nvoid __kmp_i18n_catclose();\nchar const *__kmp_i18n_catgets(kmp_i18n_id_t id);\n\n#define KMP_I18N_STR(id) __kmp_i18n_catgets(kmp_i18n_str_##id)\n\n/* High-level interface for printing strings targeted to the user.\n\n   All the strings are divided into 3 types:\n   * messages,\n   * hints,\n   * system errors.\n\n   There are 3 kind of message severities:\n   * informational messages,\n   * warnings (non-fatal errors),\n   * fatal errors.\n\n   For example:\n     OMP: Warning #2: Cannot open message catalog \"libguide.cat\":   (1)\n     OMP: System error #2: No such file or directory                (2)\n     OMP: Hint: Please check NLSPATH environment variable.          (3)\n     OMP: Info #3: Default messages will be used.                   (4)\n\n   where\n   (1) is a message of warning severity,\n   (2) is a system error caused the previous warning,\n   (3) is a hint for the user how to fix the problem,\n   (4) is a message of informational severity.\n\n   Usage in complex cases (message is accompanied with hints and system errors):\n\n   int error = errno; // We need save errno immediately, because it may\n                      // be changed.\n   __kmp_msg(\n       kmp_ms_warning,                        // Severity\n       KMP_MSG( CantOpenMessageCatalog, name ), // Primary message\n       KMP_ERR( error ),                      // System error\n       KMP_HNT( CheckNLSPATH ),               // Hint\n       __kmp_msg_null                         // Variadic argument list finisher\n   );\n\n   Usage in simple cases (just a message, no system errors or hints):\n   KMP_INFORM( WillUseDefaultMessages );\n   KMP_WARNING( CantOpenMessageCatalog, name );\n   KMP_FATAL( StackOverlap );\n   KMP_SYSFAIL( \"pthread_create\", status );\n   KMP_CHECK_SYSFAIL( \"pthread_create\", status );\n   KMP_CHECK_SYSFAIL_ERRNO( \"gettimeofday\", status );\n*/\n\nenum kmp_msg_type {\n  kmp_mt_dummy = 0, // Special type for internal purposes.\n  kmp_mt_mesg =\n      4, // Primary OpenMP message, could be information, warning, or fatal.\n  kmp_mt_hint = 5, // Hint to the user.\n  kmp_mt_syserr = -1 // System error message.\n}; // enum kmp_msg_type\ntypedef enum kmp_msg_type kmp_msg_type_t;\n\nstruct kmp_msg {\n  kmp_msg_type_t type;\n  int num;\n  char *str;\n  size_t len;\n}; // struct kmp_message\ntypedef struct kmp_msg kmp_msg_t;\n\n// Special message to denote the end of variadic list of arguments.\nextern kmp_msg_t __kmp_msg_null;\n\n// Helper functions. Creates messages either from message catalog or from\n// system. Note: these functions allocate memory. You should pass created\n// messages to __kmp_msg() function, it will print messages and destroy them.\nkmp_msg_t __kmp_msg_format(unsigned id_arg, ...);\nkmp_msg_t __kmp_msg_error_code(int code);\nkmp_msg_t __kmp_msg_error_mesg(char const *mesg);\n\n// Helper macros to make calls shorter.\n#define KMP_MSG(...) __kmp_msg_format(kmp_i18n_msg_##__VA_ARGS__)\n#define KMP_HNT(...) __kmp_msg_format(kmp_i18n_hnt_##__VA_ARGS__)\n#define KMP_SYSERRCODE(code) __kmp_msg_error_code(code)\n#define KMP_SYSERRMESG(mesg) __kmp_msg_error_mesg(mesg)\n#define KMP_ERR KMP_SYSERRCODE\n\n// Message severity.\nenum kmp_msg_severity {\n  kmp_ms_inform, // Just information for the user.\n  kmp_ms_warning, // Non-fatal error, execution continues.\n  kmp_ms_fatal // Fatal error, program aborts.\n}; // enum kmp_msg_severity\ntypedef enum kmp_msg_severity kmp_msg_severity_t;\n\n// Primary function for printing messages for the user. The first message is\n// mandatory. Any number of system errors and hints may be specified. Argument\n// list must be finished with __kmp_msg_null.\nvoid __kmp_msg(kmp_msg_severity_t severity, kmp_msg_t message, ...);\nKMP_NORETURN void __kmp_fatal(kmp_msg_t message, ...);\n\n// Helper macros to make calls shorter in simple cases.\n#define KMP_INFORM(...)                                                        \\\n  __kmp_msg(kmp_ms_inform, KMP_MSG(__VA_ARGS__), __kmp_msg_null)\n#define KMP_WARNING(...)                                                       \\\n  __kmp_msg(kmp_ms_warning, KMP_MSG(__VA_ARGS__), __kmp_msg_null)\n#define KMP_FATAL(...) __kmp_fatal(KMP_MSG(__VA_ARGS__), __kmp_msg_null)\n#define KMP_SYSFAIL(func, error)                                               \\\n  __kmp_fatal(KMP_MSG(FunctionError, func), KMP_SYSERRCODE(error),             \\\n              __kmp_msg_null)\n\n// Check error, if not zero, generate fatal error message.\n#define KMP_CHECK_SYSFAIL(func, error)                                         \\\n  {                                                                            \\\n    if (error) {                                                               \\\n      KMP_SYSFAIL(func, error);                                                \\\n    }                                                                          \\\n  }\n\n// Check status, if not zero, generate fatal error message using errno.\n#define KMP_CHECK_SYSFAIL_ERRNO(func, status)                                  \\\n  {                                                                            \\\n    if (status != 0) {                                                         \\\n      int error = errno;                                                       \\\n      KMP_SYSFAIL(func, error);                                                \\\n    }                                                                          \\\n  }\n\n#ifdef KMP_DEBUG\nvoid __kmp_i18n_dump_catalog(kmp_str_buf_t *buffer);\n#endif // KMP_DEBUG\n\n#ifdef __cplusplus\n}; // extern \"C\"\n#endif // __cplusplus\n\n#endif // KMP_I18N_H\n\n// end of file //\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_lock.h", "content": "/*\n * kmp_lock.h -- lock header file\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_LOCK_H\n#define KMP_LOCK_H\n\n#include <limits.h> // CHAR_BIT\n#include <stddef.h> // offsetof\n\n#include \"kmp_debug.h\"\n#include \"kmp_os.h\"\n\n#ifdef __cplusplus\n#include <atomic>\n\nextern \"C\" {\n#endif // __cplusplus\n\n// ----------------------------------------------------------------------------\n// Have to copy these definitions from kmp.h because kmp.h cannot be included\n// due to circular dependencies.  Will undef these at end of file.\n\n#define KMP_PAD(type, sz)                                                      \\\n  (sizeof(type) + (sz - ((sizeof(type) - 1) % (sz)) - 1))\n#define KMP_GTID_DNE (-2)\n\n// Forward declaration of ident and ident_t\n\nstruct ident;\ntypedef struct ident ident_t;\n\n// End of copied code.\n// ----------------------------------------------------------------------------\n\n// We need to know the size of the area we can assume that the compiler(s)\n// allocated for objects of type omp_lock_t and omp_nest_lock_t.  The Intel\n// compiler always allocates a pointer-sized area, as does visual studio.\n//\n// gcc however, only allocates 4 bytes for regular locks, even on 64-bit\n// intel archs.  It allocates at least 8 bytes for nested lock (more on\n// recent versions), but we are bounded by the pointer-sized chunks that\n// the Intel compiler allocates.\n\n#if KMP_OS_LINUX && defined(KMP_GOMP_COMPAT)\n#define OMP_LOCK_T_SIZE sizeof(int)\n#define OMP_NEST_LOCK_T_SIZE sizeof(void *)\n#else\n#define OMP_LOCK_T_SIZE sizeof(void *)\n#define OMP_NEST_LOCK_T_SIZE sizeof(void *)\n#endif\n\n// The Intel compiler allocates a 32-byte chunk for a critical section.\n// Both gcc and visual studio only allocate enough space for a pointer.\n// Sometimes we know that the space was allocated by the Intel compiler.\n#define OMP_CRITICAL_SIZE sizeof(void *)\n#define INTEL_CRITICAL_SIZE 32\n\n// lock flags\ntypedef kmp_uint32 kmp_lock_flags_t;\n\n#define kmp_lf_critical_section 1\n\n// When a lock table is used, the indices are of kmp_lock_index_t\ntypedef kmp_uint32 kmp_lock_index_t;\n\n// When memory allocated for locks are on the lock pool (free list),\n// it is treated as structs of this type.\nstruct kmp_lock_pool {\n  union kmp_user_lock *next;\n  kmp_lock_index_t index;\n};\n\ntypedef struct kmp_lock_pool kmp_lock_pool_t;\n\nextern void __kmp_validate_locks(void);\n\n// ----------------------------------------------------------------------------\n//  There are 5 lock implementations:\n//       1. Test and set locks.\n//       2. futex locks (Linux* OS on x86 and\n//          Intel(R) Many Integrated Core Architecture)\n//       3. Ticket (Lamport bakery) locks.\n//       4. Queuing locks (with separate spin fields).\n//       5. DRPA (Dynamically Reconfigurable Distributed Polling Area) locks\n//\n//   and 3 lock purposes:\n//       1. Bootstrap locks -- Used for a few locks available at library\n//       startup-shutdown time.\n//          These do not require non-negative global thread ID's.\n//       2. Internal RTL locks -- Used everywhere else in the RTL\n//       3. User locks (includes critical sections)\n// ----------------------------------------------------------------------------\n\n// ============================================================================\n// Lock implementations.\n//\n// Test and set locks.\n//\n// Non-nested test and set locks differ from the other lock kinds (except\n// futex) in that we use the memory allocated by the compiler for the lock,\n// rather than a pointer to it.\n//\n// On lin32, lin_32e, and win_32, the space allocated may be as small as 4\n// bytes, so we have to use a lock table for nested locks, and avoid accessing\n// the depth_locked field for non-nested locks.\n//\n// Information normally available to the tools, such as lock location, lock\n// usage (normal lock vs. critical section), etc. is not available with test and\n// set locks.\n// ----------------------------------------------------------------------------\n\nstruct kmp_base_tas_lock {\n  // KMP_LOCK_FREE(tas) => unlocked; locked: (gtid+1) of owning thread\n  std::atomic<kmp_int32> poll;\n  kmp_int32 depth_locked; // depth locked, for nested locks only\n};\n\ntypedef struct kmp_base_tas_lock kmp_base_tas_lock_t;\n\nunion kmp_tas_lock {\n  kmp_base_tas_lock_t lk;\n  kmp_lock_pool_t pool; // make certain struct is large enough\n  double lk_align; // use worst case alignment; no cache line padding\n};\n\ntypedef union kmp_tas_lock kmp_tas_lock_t;\n\n// Static initializer for test and set lock variables. Usage:\n//    kmp_tas_lock_t xlock = KMP_TAS_LOCK_INITIALIZER( xlock );\n#define KMP_TAS_LOCK_INITIALIZER(lock)                                         \\\n  {                                                                            \\\n    { ATOMIC_VAR_INIT(KMP_LOCK_FREE(tas)), 0 }                                 \\\n  }\n\nextern int __kmp_acquire_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_tas_lock(kmp_tas_lock_t *lck);\nextern void __kmp_destroy_tas_lock(kmp_tas_lock_t *lck);\n\nextern int __kmp_acquire_nested_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_nested_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_nested_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_nested_tas_lock(kmp_tas_lock_t *lck);\nextern void __kmp_destroy_nested_tas_lock(kmp_tas_lock_t *lck);\n\n#define KMP_LOCK_RELEASED 1\n#define KMP_LOCK_STILL_HELD 0\n#define KMP_LOCK_ACQUIRED_FIRST 1\n#define KMP_LOCK_ACQUIRED_NEXT 0\n#ifndef KMP_USE_FUTEX\n#define KMP_USE_FUTEX                                                          \\\n  (KMP_OS_LINUX &&                                                             \\\n   (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64))\n#endif\n#if KMP_USE_FUTEX\n\n// ----------------------------------------------------------------------------\n// futex locks.  futex locks are only available on Linux* OS.\n//\n// Like non-nested test and set lock, non-nested futex locks use the memory\n// allocated by the compiler for the lock, rather than a pointer to it.\n//\n// Information normally available to the tools, such as lock location, lock\n// usage (normal lock vs. critical section), etc. is not available with test and\n// set locks. With non-nested futex locks, the lock owner is not even available.\n// ----------------------------------------------------------------------------\n\nstruct kmp_base_futex_lock {\n  volatile kmp_int32 poll; // KMP_LOCK_FREE(futex) => unlocked\n  // 2*(gtid+1) of owning thread, 0 if unlocked\n  // locked: (gtid+1) of owning thread\n  kmp_int32 depth_locked; // depth locked, for nested locks only\n};\n\ntypedef struct kmp_base_futex_lock kmp_base_futex_lock_t;\n\nunion kmp_futex_lock {\n  kmp_base_futex_lock_t lk;\n  kmp_lock_pool_t pool; // make certain struct is large enough\n  double lk_align; // use worst case alignment\n  // no cache line padding\n};\n\ntypedef union kmp_futex_lock kmp_futex_lock_t;\n\n// Static initializer for futex lock variables. Usage:\n//    kmp_futex_lock_t xlock = KMP_FUTEX_LOCK_INITIALIZER( xlock );\n#define KMP_FUTEX_LOCK_INITIALIZER(lock)                                       \\\n  {                                                                            \\\n    { KMP_LOCK_FREE(futex), 0 }                                                \\\n  }\n\nextern int __kmp_acquire_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_futex_lock(kmp_futex_lock_t *lck);\nextern void __kmp_destroy_futex_lock(kmp_futex_lock_t *lck);\n\nextern int __kmp_acquire_nested_futex_lock(kmp_futex_lock_t *lck,\n                                           kmp_int32 gtid);\nextern int __kmp_test_nested_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_nested_futex_lock(kmp_futex_lock_t *lck,\n                                           kmp_int32 gtid);\nextern void __kmp_init_nested_futex_lock(kmp_futex_lock_t *lck);\nextern void __kmp_destroy_nested_futex_lock(kmp_futex_lock_t *lck);\n\n#endif // KMP_USE_FUTEX\n\n// ----------------------------------------------------------------------------\n// Ticket locks.\n\n#ifdef __cplusplus\n\n#ifdef _MSC_VER\n// MSVC won't allow use of std::atomic<> in a union since it has non-trivial\n// copy constructor.\n\nstruct kmp_base_ticket_lock {\n  // `initialized' must be the first entry in the lock data structure!\n  std::atomic_bool initialized;\n  volatile union kmp_ticket_lock *self; // points to the lock union\n  ident_t const *location; // Source code location of omp_init_lock().\n  std::atomic_uint\n      next_ticket; // ticket number to give to next thread which acquires\n  std::atomic_uint now_serving; // ticket number for thread which holds the lock\n  std::atomic_int owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  std::atomic_int depth_locked; // depth locked, for nested locks only\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n#else\nstruct kmp_base_ticket_lock {\n  // `initialized' must be the first entry in the lock data structure!\n  std::atomic<bool> initialized;\n  volatile union kmp_ticket_lock *self; // points to the lock union\n  ident_t const *location; // Source code location of omp_init_lock().\n  std::atomic<unsigned>\n      next_ticket; // ticket number to give to next thread which acquires\n  std::atomic<unsigned>\n      now_serving; // ticket number for thread which holds the lock\n  std::atomic<int> owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  std::atomic<int> depth_locked; // depth locked, for nested locks only\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n#endif\n\n#else // __cplusplus\n\nstruct kmp_base_ticket_lock;\n\n#endif // !__cplusplus\n\ntypedef struct kmp_base_ticket_lock kmp_base_ticket_lock_t;\n\nunion KMP_ALIGN_CACHE kmp_ticket_lock {\n  kmp_base_ticket_lock_t\n      lk; // This field must be first to allow static initializing.\n  kmp_lock_pool_t pool;\n  double lk_align; // use worst case alignment\n  char lk_pad[KMP_PAD(kmp_base_ticket_lock_t, CACHE_LINE)];\n};\n\ntypedef union kmp_ticket_lock kmp_ticket_lock_t;\n\n// Static initializer for simple ticket lock variables. Usage:\n//    kmp_ticket_lock_t xlock = KMP_TICKET_LOCK_INITIALIZER( xlock );\n// Note the macro argument. It is important to make var properly initialized.\n#define KMP_TICKET_LOCK_INITIALIZER(lock)                                      \\\n  {                                                                            \\\n    {                                                                          \\\n      ATOMIC_VAR_INIT(true)                                                    \\\n      , &(lock), NULL, ATOMIC_VAR_INIT(0U), ATOMIC_VAR_INIT(0U),               \\\n          ATOMIC_VAR_INIT(0), ATOMIC_VAR_INIT(-1)                              \\\n    }                                                                          \\\n  }\n\nextern int __kmp_acquire_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_ticket_lock_with_cheks(kmp_ticket_lock_t *lck,\n                                             kmp_int32 gtid);\nextern int __kmp_release_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_ticket_lock(kmp_ticket_lock_t *lck);\nextern void __kmp_destroy_ticket_lock(kmp_ticket_lock_t *lck);\n\nextern int __kmp_acquire_nested_ticket_lock(kmp_ticket_lock_t *lck,\n                                            kmp_int32 gtid);\nextern int __kmp_test_nested_ticket_lock(kmp_ticket_lock_t *lck,\n                                         kmp_int32 gtid);\nextern int __kmp_release_nested_ticket_lock(kmp_ticket_lock_t *lck,\n                                            kmp_int32 gtid);\nextern void __kmp_init_nested_ticket_lock(kmp_ticket_lock_t *lck);\nextern void __kmp_destroy_nested_ticket_lock(kmp_ticket_lock_t *lck);\n\n// ----------------------------------------------------------------------------\n// Queuing locks.\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\nstruct kmp_adaptive_lock_info;\n\ntypedef struct kmp_adaptive_lock_info kmp_adaptive_lock_info_t;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n\nstruct kmp_adaptive_lock_statistics {\n  /* So we can get stats from locks that haven't been destroyed. */\n  kmp_adaptive_lock_info_t *next;\n  kmp_adaptive_lock_info_t *prev;\n\n  /* Other statistics */\n  kmp_uint32 successfulSpeculations;\n  kmp_uint32 hardFailedSpeculations;\n  kmp_uint32 softFailedSpeculations;\n  kmp_uint32 nonSpeculativeAcquires;\n  kmp_uint32 nonSpeculativeAcquireAttempts;\n  kmp_uint32 lemmingYields;\n};\n\ntypedef struct kmp_adaptive_lock_statistics kmp_adaptive_lock_statistics_t;\n\nextern void __kmp_print_speculative_stats();\nextern void __kmp_init_speculative_stats();\n\n#endif // KMP_DEBUG_ADAPTIVE_LOCKS\n\nstruct kmp_adaptive_lock_info {\n  /* Values used for adaptivity.\n     Although these are accessed from multiple threads we don't access them\n     atomically, because if we miss updates it probably doesn't matter much. (It\n     just affects our decision about whether to try speculation on the lock). */\n  kmp_uint32 volatile badness;\n  kmp_uint32 volatile acquire_attempts;\n  /* Parameters of the lock. */\n  kmp_uint32 max_badness;\n  kmp_uint32 max_soft_retries;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n  kmp_adaptive_lock_statistics_t volatile stats;\n#endif\n};\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\nstruct kmp_base_queuing_lock {\n\n  //  `initialized' must be the first entry in the lock data structure!\n  volatile union kmp_queuing_lock\n      *initialized; // Points to the lock union if in initialized state.\n\n  ident_t const *location; // Source code location of omp_init_lock().\n\n  KMP_ALIGN(8) // tail_id  must be 8-byte aligned!\n\n  volatile kmp_int32\n      tail_id; // (gtid+1) of thread at tail of wait queue, 0 if empty\n  // Must be no padding here since head/tail used in 8-byte CAS\n  volatile kmp_int32\n      head_id; // (gtid+1) of thread at head of wait queue, 0 if empty\n  // Decl order assumes little endian\n  // bakery-style lock\n  volatile kmp_uint32\n      next_ticket; // ticket number to give to next thread which acquires\n  volatile kmp_uint32\n      now_serving; // ticket number for thread which holds the lock\n  volatile kmp_int32 owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  kmp_int32 depth_locked; // depth locked, for nested locks only\n\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n\ntypedef struct kmp_base_queuing_lock kmp_base_queuing_lock_t;\n\nKMP_BUILD_ASSERT(offsetof(kmp_base_queuing_lock_t, tail_id) % 8 == 0);\n\nunion KMP_ALIGN_CACHE kmp_queuing_lock {\n  kmp_base_queuing_lock_t\n      lk; // This field must be first to allow static initializing.\n  kmp_lock_pool_t pool;\n  double lk_align; // use worst case alignment\n  char lk_pad[KMP_PAD(kmp_base_queuing_lock_t, CACHE_LINE)];\n};\n\ntypedef union kmp_queuing_lock kmp_queuing_lock_t;\n\nextern int __kmp_acquire_queuing_lock(kmp_queuing_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_queuing_lock(kmp_queuing_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_queuing_lock(kmp_queuing_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_queuing_lock(kmp_queuing_lock_t *lck);\nextern void __kmp_destroy_queuing_lock(kmp_queuing_lock_t *lck);\n\nextern int __kmp_acquire_nested_queuing_lock(kmp_queuing_lock_t *lck,\n                                             kmp_int32 gtid);\nextern int __kmp_test_nested_queuing_lock(kmp_queuing_lock_t *lck,\n                                          kmp_int32 gtid);\nextern int __kmp_release_nested_queuing_lock(kmp_queuing_lock_t *lck,\n                                             kmp_int32 gtid);\nextern void __kmp_init_nested_queuing_lock(kmp_queuing_lock_t *lck);\nextern void __kmp_destroy_nested_queuing_lock(kmp_queuing_lock_t *lck);\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\n// ----------------------------------------------------------------------------\n// Adaptive locks.\nstruct kmp_base_adaptive_lock {\n  kmp_base_queuing_lock qlk;\n  KMP_ALIGN(CACHE_LINE)\n  kmp_adaptive_lock_info_t\n      adaptive; // Information for the speculative adaptive lock\n};\n\ntypedef struct kmp_base_adaptive_lock kmp_base_adaptive_lock_t;\n\nunion KMP_ALIGN_CACHE kmp_adaptive_lock {\n  kmp_base_adaptive_lock_t lk;\n  kmp_lock_pool_t pool;\n  double lk_align;\n  char lk_pad[KMP_PAD(kmp_base_adaptive_lock_t, CACHE_LINE)];\n};\ntypedef union kmp_adaptive_lock kmp_adaptive_lock_t;\n\n#define GET_QLK_PTR(l) ((kmp_queuing_lock_t *)&(l)->lk.qlk)\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\n// ----------------------------------------------------------------------------\n// DRDPA ticket locks.\nstruct kmp_base_drdpa_lock {\n  // All of the fields on the first cache line are only written when\n  // initializing or reconfiguring the lock.  These are relatively rare\n  // operations, so data from the first cache line will usually stay resident in\n  // the cache of each thread trying to acquire the lock.\n  //\n  // initialized must be the first entry in the lock data structure!\n  KMP_ALIGN_CACHE\n\n  volatile union kmp_drdpa_lock\n      *initialized; // points to the lock union if in initialized state\n  ident_t const *location; // Source code location of omp_init_lock().\n  std::atomic<std::atomic<kmp_uint64> *> polls;\n  std::atomic<kmp_uint64> mask; // is 2**num_polls-1 for mod op\n  kmp_uint64 cleanup_ticket; // thread with cleanup ticket\n  std::atomic<kmp_uint64> *old_polls; // will deallocate old_polls\n  kmp_uint32 num_polls; // must be power of 2\n\n  // next_ticket it needs to exist in a separate cache line, as it is\n  // invalidated every time a thread takes a new ticket.\n  KMP_ALIGN_CACHE\n\n  std::atomic<kmp_uint64> next_ticket;\n\n  // now_serving is used to store our ticket value while we hold the lock. It\n  // has a slightly different meaning in the DRDPA ticket locks (where it is\n  // written by the acquiring thread) than it does in the simple ticket locks\n  // (where it is written by the releasing thread).\n  //\n  // Since now_serving is only read and written in the critical section,\n  // it is non-volatile, but it needs to exist on a separate cache line,\n  // as it is invalidated at every lock acquire.\n  //\n  // Likewise, the vars used for nested locks (owner_id and depth_locked) are\n  // only written by the thread owning the lock, so they are put in this cache\n  // line.  owner_id is read by other threads, so it must be declared volatile.\n  KMP_ALIGN_CACHE\n  kmp_uint64 now_serving; // doesn't have to be volatile\n  volatile kmp_uint32 owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  kmp_int32 depth_locked; // depth locked\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n\ntypedef struct kmp_base_drdpa_lock kmp_base_drdpa_lock_t;\n\nunion KMP_ALIGN_CACHE kmp_drdpa_lock {\n  kmp_base_drdpa_lock_t\n      lk; // This field must be first to allow static initializing. */\n  kmp_lock_pool_t pool;\n  double lk_align; // use worst case alignment\n  char lk_pad[KMP_PAD(kmp_base_drdpa_lock_t, CACHE_LINE)];\n};\n\ntypedef union kmp_drdpa_lock kmp_drdpa_lock_t;\n\nextern int __kmp_acquire_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_drdpa_lock(kmp_drdpa_lock_t *lck);\nextern void __kmp_destroy_drdpa_lock(kmp_drdpa_lock_t *lck);\n\nextern int __kmp_acquire_nested_drdpa_lock(kmp_drdpa_lock_t *lck,\n                                           kmp_int32 gtid);\nextern int __kmp_test_nested_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_nested_drdpa_lock(kmp_drdpa_lock_t *lck,\n                                           kmp_int32 gtid);\nextern void __kmp_init_nested_drdpa_lock(kmp_drdpa_lock_t *lck);\nextern void __kmp_destroy_nested_drdpa_lock(kmp_drdpa_lock_t *lck);\n\n// ============================================================================\n// Lock purposes.\n// ============================================================================\n\n// Bootstrap locks.\n//\n// Bootstrap locks -- very few locks used at library initialization time.\n// Bootstrap locks are currently implemented as ticket locks.\n// They could also be implemented as test and set lock, but cannot be\n// implemented with other lock kinds as they require gtids which are not\n// available at initialization time.\n\ntypedef kmp_ticket_lock_t kmp_bootstrap_lock_t;\n\n#define KMP_BOOTSTRAP_LOCK_INITIALIZER(lock) KMP_TICKET_LOCK_INITIALIZER((lock))\n#define KMP_BOOTSTRAP_LOCK_INIT(lock)                                          \\\n  kmp_bootstrap_lock_t lock = KMP_TICKET_LOCK_INITIALIZER(lock)\n\nstatic inline int __kmp_acquire_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  return __kmp_acquire_ticket_lock(lck, KMP_GTID_DNE);\n}\n\nstatic inline int __kmp_test_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  return __kmp_test_ticket_lock(lck, KMP_GTID_DNE);\n}\n\nstatic inline void __kmp_release_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  __kmp_release_ticket_lock(lck, KMP_GTID_DNE);\n}\n\nstatic inline void __kmp_init_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  __kmp_init_ticket_lock(lck);\n}\n\nstatic inline void __kmp_destroy_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  __kmp_destroy_ticket_lock(lck);\n}\n\n// Internal RTL locks.\n//\n// Internal RTL locks are also implemented as ticket locks, for now.\n//\n// FIXME - We should go through and figure out which lock kind works best for\n// each internal lock, and use the type declaration and function calls for\n// that explicit lock kind (and get rid of this section).\n\ntypedef kmp_ticket_lock_t kmp_lock_t;\n\n#define KMP_LOCK_INIT(lock) kmp_lock_t lock = KMP_TICKET_LOCK_INITIALIZER(lock)\n\nstatic inline int __kmp_acquire_lock(kmp_lock_t *lck, kmp_int32 gtid) {\n  return __kmp_acquire_ticket_lock(lck, gtid);\n}\n\nstatic inline int __kmp_test_lock(kmp_lock_t *lck, kmp_int32 gtid) {\n  return __kmp_test_ticket_lock(lck, gtid);\n}\n\nstatic inline void __kmp_release_lock(kmp_lock_t *lck, kmp_int32 gtid) {\n  __kmp_release_ticket_lock(lck, gtid);\n}\n\nstatic inline void __kmp_init_lock(kmp_lock_t *lck) {\n  __kmp_init_ticket_lock(lck);\n}\n\nstatic inline void __kmp_destroy_lock(kmp_lock_t *lck) {\n  __kmp_destroy_ticket_lock(lck);\n}\n\n// User locks.\n//\n// Do not allocate objects of type union kmp_user_lock!!! This will waste space\n// unless __kmp_user_lock_kind == lk_drdpa. Instead, check the value of\n// __kmp_user_lock_kind and allocate objects of the type of the appropriate\n// union member, and cast their addresses to kmp_user_lock_p.\n\nenum kmp_lock_kind {\n  lk_default = 0,\n  lk_tas,\n#if KMP_USE_FUTEX\n  lk_futex,\n#endif\n#if KMP_USE_DYNAMIC_LOCK && KMP_USE_TSX\n  lk_hle,\n  lk_rtm_queuing,\n  lk_rtm_spin,\n#endif\n  lk_ticket,\n  lk_queuing,\n  lk_drdpa,\n#if KMP_USE_ADAPTIVE_LOCKS\n  lk_adaptive\n#endif // KMP_USE_ADAPTIVE_LOCKS\n};\n\ntypedef enum kmp_lock_kind kmp_lock_kind_t;\n\nextern kmp_lock_kind_t __kmp_user_lock_kind;\n\nunion kmp_user_lock {\n  kmp_tas_lock_t tas;\n#if KMP_USE_FUTEX\n  kmp_futex_lock_t futex;\n#endif\n  kmp_ticket_lock_t ticket;\n  kmp_queuing_lock_t queuing;\n  kmp_drdpa_lock_t drdpa;\n#if KMP_USE_ADAPTIVE_LOCKS\n  kmp_adaptive_lock_t adaptive;\n#endif // KMP_USE_ADAPTIVE_LOCKS\n  kmp_lock_pool_t pool;\n};\n\ntypedef union kmp_user_lock *kmp_user_lock_p;\n\n#if !KMP_USE_DYNAMIC_LOCK\n\nextern size_t __kmp_base_user_lock_size;\nextern size_t __kmp_user_lock_size;\n\nextern kmp_int32 (*__kmp_get_user_lock_owner_)(kmp_user_lock_p lck);\n\nstatic inline kmp_int32 __kmp_get_user_lock_owner(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_get_user_lock_owner_ != NULL);\n  return (*__kmp_get_user_lock_owner_)(lck);\n}\n\nextern int (*__kmp_acquire_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid);\n\n#if KMP_OS_LINUX &&                                                            \\\n    (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64)\n\n#define __kmp_acquire_user_lock_with_checks(lck, gtid)                         \\\n  if (__kmp_user_lock_kind == lk_tas) {                                        \\\n    if (__kmp_env_consistency_check) {                                         \\\n      char const *const func = \"omp_set_lock\";                                 \\\n      if ((sizeof(kmp_tas_lock_t) <= OMP_LOCK_T_SIZE) &&                       \\\n          lck->tas.lk.depth_locked != -1) {                                    \\\n        KMP_FATAL(LockNestableUsedAsSimple, func);                             \\\n      }                                                                        \\\n      if ((gtid >= 0) && (lck->tas.lk.poll - 1 == gtid)) {                     \\\n        KMP_FATAL(LockIsAlreadyOwned, func);                                   \\\n      }                                                                        \\\n    }                                                                          \\\n    if (lck->tas.lk.poll != 0 ||                                               \\\n        !__kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1)) {     \\\n      kmp_uint32 spins;                                                        \\\n      KMP_FSYNC_PREPARE(lck);                                                  \\\n      KMP_INIT_YIELD(spins);                                                   \\\n      do {                                                                     \\\n        KMP_YIELD_OVERSUB_ELSE_SPIN(spins);                                    \\\n      } while (lck->tas.lk.poll != 0 || !__kmp_atomic_compare_store_acq(       \\\n                                            &lck->tas.lk.poll, 0, gtid + 1));  \\\n    }                                                                          \\\n    KMP_FSYNC_ACQUIRED(lck);                                                   \\\n  } else {                                                                     \\\n    KMP_DEBUG_ASSERT(__kmp_acquire_user_lock_with_checks_ != NULL);            \\\n    (*__kmp_acquire_user_lock_with_checks_)(lck, gtid);                        \\\n  }\n\n#else\nstatic inline int __kmp_acquire_user_lock_with_checks(kmp_user_lock_p lck,\n                                                      kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_acquire_user_lock_with_checks_ != NULL);\n  return (*__kmp_acquire_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_test_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                kmp_int32 gtid);\n\n#if KMP_OS_LINUX &&                                                            \\\n    (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64)\n\n#include \"kmp_i18n.h\" /* AC: KMP_FATAL definition */\nextern int __kmp_env_consistency_check; /* AC: copy from kmp.h here */\nstatic inline int __kmp_test_user_lock_with_checks(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid) {\n  if (__kmp_user_lock_kind == lk_tas) {\n    if (__kmp_env_consistency_check) {\n      char const *const func = \"omp_test_lock\";\n      if ((sizeof(kmp_tas_lock_t) <= OMP_LOCK_T_SIZE) &&\n          lck->tas.lk.depth_locked != -1) {\n        KMP_FATAL(LockNestableUsedAsSimple, func);\n      }\n    }\n    return ((lck->tas.lk.poll == 0) &&\n            __kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1));\n  } else {\n    KMP_DEBUG_ASSERT(__kmp_test_user_lock_with_checks_ != NULL);\n    return (*__kmp_test_user_lock_with_checks_)(lck, gtid);\n  }\n}\n#else\nstatic inline int __kmp_test_user_lock_with_checks(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_test_user_lock_with_checks_ != NULL);\n  return (*__kmp_test_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_release_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid);\n\nstatic inline void __kmp_release_user_lock_with_checks(kmp_user_lock_p lck,\n                                                       kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_release_user_lock_with_checks_ != NULL);\n  (*__kmp_release_user_lock_with_checks_)(lck, gtid);\n}\n\nextern void (*__kmp_init_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void __kmp_init_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_init_user_lock_with_checks_ != NULL);\n  (*__kmp_init_user_lock_with_checks_)(lck);\n}\n\n// We need a non-checking version of destroy lock for when the RTL is\n// doing the cleanup as it can't always tell if the lock is nested or not.\nextern void (*__kmp_destroy_user_lock_)(kmp_user_lock_p lck);\n\nstatic inline void __kmp_destroy_user_lock(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_destroy_user_lock_ != NULL);\n  (*__kmp_destroy_user_lock_)(lck);\n}\n\nextern void (*__kmp_destroy_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void __kmp_destroy_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_destroy_user_lock_with_checks_ != NULL);\n  (*__kmp_destroy_user_lock_with_checks_)(lck);\n}\n\nextern int (*__kmp_acquire_nested_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid);\n\n#if KMP_OS_LINUX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n\n#define __kmp_acquire_nested_user_lock_with_checks(lck, gtid, depth)           \\\n  if (__kmp_user_lock_kind == lk_tas) {                                        \\\n    if (__kmp_env_consistency_check) {                                         \\\n      char const *const func = \"omp_set_nest_lock\";                            \\\n      if ((sizeof(kmp_tas_lock_t) <= OMP_NEST_LOCK_T_SIZE) &&                  \\\n          lck->tas.lk.depth_locked == -1) {                                    \\\n        KMP_FATAL(LockSimpleUsedAsNestable, func);                             \\\n      }                                                                        \\\n    }                                                                          \\\n    if (lck->tas.lk.poll - 1 == gtid) {                                        \\\n      lck->tas.lk.depth_locked += 1;                                           \\\n      *depth = KMP_LOCK_ACQUIRED_NEXT;                                         \\\n    } else {                                                                   \\\n      if ((lck->tas.lk.poll != 0) ||                                           \\\n          !__kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1)) {   \\\n        kmp_uint32 spins;                                                      \\\n        KMP_FSYNC_PREPARE(lck);                                                \\\n        KMP_INIT_YIELD(spins);                                                 \\\n        do {                                                                   \\\n          KMP_YIELD_OVERSUB_ELSE_SPIN(spins);                                  \\\n        } while (                                                              \\\n            (lck->tas.lk.poll != 0) ||                                         \\\n            !__kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1));  \\\n      }                                                                        \\\n      lck->tas.lk.depth_locked = 1;                                            \\\n      *depth = KMP_LOCK_ACQUIRED_FIRST;                                        \\\n    }                                                                          \\\n    KMP_FSYNC_ACQUIRED(lck);                                                   \\\n  } else {                                                                     \\\n    KMP_DEBUG_ASSERT(__kmp_acquire_nested_user_lock_with_checks_ != NULL);     \\\n    *depth = (*__kmp_acquire_nested_user_lock_with_checks_)(lck, gtid);        \\\n  }\n\n#else\nstatic inline void\n__kmp_acquire_nested_user_lock_with_checks(kmp_user_lock_p lck, kmp_int32 gtid,\n                                           int *depth) {\n  KMP_DEBUG_ASSERT(__kmp_acquire_nested_user_lock_with_checks_ != NULL);\n  *depth = (*__kmp_acquire_nested_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_test_nested_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                       kmp_int32 gtid);\n\n#if KMP_OS_LINUX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\nstatic inline int __kmp_test_nested_user_lock_with_checks(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid) {\n  if (__kmp_user_lock_kind == lk_tas) {\n    int retval;\n    if (__kmp_env_consistency_check) {\n      char const *const func = \"omp_test_nest_lock\";\n      if ((sizeof(kmp_tas_lock_t) <= OMP_NEST_LOCK_T_SIZE) &&\n          lck->tas.lk.depth_locked == -1) {\n        KMP_FATAL(LockSimpleUsedAsNestable, func);\n      }\n    }\n    KMP_DEBUG_ASSERT(gtid >= 0);\n    if (lck->tas.lk.poll - 1 ==\n        gtid) { /* __kmp_get_tas_lock_owner( lck ) == gtid */\n      return ++lck->tas.lk.depth_locked; /* same owner, depth increased */\n    }\n    retval = ((lck->tas.lk.poll == 0) &&\n              __kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1));\n    if (retval) {\n      KMP_MB();\n      lck->tas.lk.depth_locked = 1;\n    }\n    return retval;\n  } else {\n    KMP_DEBUG_ASSERT(__kmp_test_nested_user_lock_with_checks_ != NULL);\n    return (*__kmp_test_nested_user_lock_with_checks_)(lck, gtid);\n  }\n}\n#else\nstatic inline int __kmp_test_nested_user_lock_with_checks(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_test_nested_user_lock_with_checks_ != NULL);\n  return (*__kmp_test_nested_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_release_nested_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid);\n\nstatic inline int\n__kmp_release_nested_user_lock_with_checks(kmp_user_lock_p lck,\n                                           kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_release_nested_user_lock_with_checks_ != NULL);\n  return (*__kmp_release_nested_user_lock_with_checks_)(lck, gtid);\n}\n\nextern void (*__kmp_init_nested_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void\n__kmp_init_nested_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_init_nested_user_lock_with_checks_ != NULL);\n  (*__kmp_init_nested_user_lock_with_checks_)(lck);\n}\n\nextern void (*__kmp_destroy_nested_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void\n__kmp_destroy_nested_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_destroy_nested_user_lock_with_checks_ != NULL);\n  (*__kmp_destroy_nested_user_lock_with_checks_)(lck);\n}\n\n// user lock functions which do not necessarily exist for all lock kinds.\n//\n// The \"set\" functions usually have wrapper routines that check for a NULL set\n// function pointer and call it if non-NULL.\n//\n// In some cases, it makes sense to have a \"get\" wrapper function check for a\n// NULL get function pointer and return NULL / invalid value / error code if\n// the function pointer is NULL.\n//\n// In other cases, the calling code really should differentiate between an\n// unimplemented function and one that is implemented but returning NULL /\n// invalid value.  If this is the case, no get function wrapper exists.\n\nextern int (*__kmp_is_user_lock_initialized_)(kmp_user_lock_p lck);\n\n// no set function; fields set during local allocation\n\nextern const ident_t *(*__kmp_get_user_lock_location_)(kmp_user_lock_p lck);\n\nstatic inline const ident_t *__kmp_get_user_lock_location(kmp_user_lock_p lck) {\n  if (__kmp_get_user_lock_location_ != NULL) {\n    return (*__kmp_get_user_lock_location_)(lck);\n  } else {\n    return NULL;\n  }\n}\n\nextern void (*__kmp_set_user_lock_location_)(kmp_user_lock_p lck,\n                                             const ident_t *loc);\n\nstatic inline void __kmp_set_user_lock_location(kmp_user_lock_p lck,\n                                                const ident_t *loc) {\n  if (__kmp_set_user_lock_location_ != NULL) {\n    (*__kmp_set_user_lock_location_)(lck, loc);\n  }\n}\n\nextern kmp_lock_flags_t (*__kmp_get_user_lock_flags_)(kmp_user_lock_p lck);\n\nextern void (*__kmp_set_user_lock_flags_)(kmp_user_lock_p lck,\n                                          kmp_lock_flags_t flags);\n\nstatic inline void __kmp_set_user_lock_flags(kmp_user_lock_p lck,\n                                             kmp_lock_flags_t flags) {\n  if (__kmp_set_user_lock_flags_ != NULL) {\n    (*__kmp_set_user_lock_flags_)(lck, flags);\n  }\n}\n\n// The function which sets up all of the vtbl pointers for kmp_user_lock_t.\nextern void __kmp_set_user_lock_vptrs(kmp_lock_kind_t user_lock_kind);\n\n// Macros for binding user lock functions.\n#define KMP_BIND_USER_LOCK_TEMPLATE(nest, kind, suffix)                        \\\n  {                                                                            \\\n    __kmp_acquire##nest##user_lock_with_checks_ = (int (*)(                    \\\n        kmp_user_lock_p, kmp_int32))__kmp_acquire##nest##kind##_##suffix;      \\\n    __kmp_release##nest##user_lock_with_checks_ = (int (*)(                    \\\n        kmp_user_lock_p, kmp_int32))__kmp_release##nest##kind##_##suffix;      \\\n    __kmp_test##nest##user_lock_with_checks_ = (int (*)(                       \\\n        kmp_user_lock_p, kmp_int32))__kmp_test##nest##kind##_##suffix;         \\\n    __kmp_init##nest##user_lock_with_checks_ =                                 \\\n        (void (*)(kmp_user_lock_p))__kmp_init##nest##kind##_##suffix;          \\\n    __kmp_destroy##nest##user_lock_with_checks_ =                              \\\n        (void (*)(kmp_user_lock_p))__kmp_destroy##nest##kind##_##suffix;       \\\n  }\n\n#define KMP_BIND_USER_LOCK(kind) KMP_BIND_USER_LOCK_TEMPLATE(_, kind, lock)\n#define KMP_BIND_USER_LOCK_WITH_CHECKS(kind)                                   \\\n  KMP_BIND_USER_LOCK_TEMPLATE(_, kind, lock_with_checks)\n#define KMP_BIND_NESTED_USER_LOCK(kind)                                        \\\n  KMP_BIND_USER_LOCK_TEMPLATE(_nested_, kind, lock)\n#define KMP_BIND_NESTED_USER_LOCK_WITH_CHECKS(kind)                            \\\n  KMP_BIND_USER_LOCK_TEMPLATE(_nested_, kind, lock_with_checks)\n\n// User lock table & lock allocation\n/* On 64-bit Linux* OS (and OS X*) GNU compiler allocates only 4 bytems memory\n   for lock variable, which is not enough to store a pointer, so we have to use\n   lock indexes instead of pointers and maintain lock table to map indexes to\n   pointers.\n\n\n   Note: The first element of the table is not a pointer to lock! It is a\n   pointer to previously allocated table (or NULL if it is the first table).\n\n   Usage:\n\n   if ( OMP_LOCK_T_SIZE < sizeof( <lock> ) ) { // or OMP_NEST_LOCK_T_SIZE\n     Lock table is fully utilized. User locks are indexes, so table is used on\n     user lock operation.\n     Note: it may be the case (lin_32) that we don't need to use a lock\n     table for regular locks, but do need the table for nested locks.\n   }\n   else {\n     Lock table initialized but not actually used.\n   }\n*/\n\nstruct kmp_lock_table {\n  kmp_lock_index_t used; // Number of used elements\n  kmp_lock_index_t allocated; // Number of allocated elements\n  kmp_user_lock_p *table; // Lock table.\n};\n\ntypedef struct kmp_lock_table kmp_lock_table_t;\n\nextern kmp_lock_table_t __kmp_user_lock_table;\nextern kmp_user_lock_p __kmp_lock_pool;\n\nstruct kmp_block_of_locks {\n  struct kmp_block_of_locks *next_block;\n  void *locks;\n};\n\ntypedef struct kmp_block_of_locks kmp_block_of_locks_t;\n\nextern kmp_block_of_locks_t *__kmp_lock_blocks;\nextern int __kmp_num_locks_in_block;\n\nextern kmp_user_lock_p __kmp_user_lock_allocate(void **user_lock,\n                                                kmp_int32 gtid,\n                                                kmp_lock_flags_t flags);\nextern void __kmp_user_lock_free(void **user_lock, kmp_int32 gtid,\n                                 kmp_user_lock_p lck);\nextern kmp_user_lock_p __kmp_lookup_user_lock(void **user_lock,\n                                              char const *func);\nextern void __kmp_cleanup_user_locks();\n\n#define KMP_CHECK_USER_LOCK_INIT()                                             \\\n  {                                                                            \\\n    if (!TCR_4(__kmp_init_user_locks)) {                                       \\\n      __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);                         \\\n      if (!TCR_4(__kmp_init_user_locks)) {                                     \\\n        TCW_4(__kmp_init_user_locks, TRUE);                                    \\\n      }                                                                        \\\n      __kmp_release_bootstrap_lock(&__kmp_initz_lock);                         \\\n    }                                                                          \\\n  }\n\n#endif // KMP_USE_DYNAMIC_LOCK\n\n#undef KMP_PAD\n#undef KMP_GTID_DNE\n\n#if KMP_USE_DYNAMIC_LOCK\n// KMP_USE_DYNAMIC_LOCK enables dynamic dispatch of lock functions without\n// breaking the current compatibility. Essential functionality of this new code\n// is dynamic dispatch, but it also implements (or enables implementation of)\n// hinted user lock and critical section which will be part of OMP 4.5 soon.\n//\n// Lock type can be decided at creation time (i.e., lock initialization), and\n// subsequent lock function call on the created lock object requires type\n// extraction and call through jump table using the extracted type. This type\n// information is stored in two different ways depending on the size of the lock\n// object, and we differentiate lock types by this size requirement - direct and\n// indirect locks.\n//\n// Direct locks:\n// A direct lock object fits into the space created by the compiler for an\n// omp_lock_t object, and TAS/Futex lock falls into this category. We use low\n// one byte of the lock object as the storage for the lock type, and appropriate\n// bit operation is required to access the data meaningful to the lock\n// algorithms. Also, to differentiate direct lock from indirect lock, 1 is\n// written to LSB of the lock object. The newly introduced \"hle\" lock is also a\n// direct lock.\n//\n// Indirect locks:\n// An indirect lock object requires more space than the compiler-generated\n// space, and it should be allocated from heap. Depending on the size of the\n// compiler-generated space for the lock (i.e., size of omp_lock_t), this\n// omp_lock_t object stores either the address of the heap-allocated indirect\n// lock (void * fits in the object) or an index to the indirect lock table entry\n// that holds the address. Ticket/Queuing/DRDPA/Adaptive lock falls into this\n// category, and the newly introduced \"rtm\" lock is also an indirect lock which\n// was implemented on top of the Queuing lock. When the omp_lock_t object holds\n// an index (not lock address), 0 is written to LSB to differentiate the lock\n// from a direct lock, and the remaining part is the actual index to the\n// indirect lock table.\n\n#include <stdint.h> // for uintptr_t\n\n// Shortcuts\n#define KMP_USE_INLINED_TAS                                                    \\\n  (KMP_OS_LINUX && (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM)) && 1\n#define KMP_USE_INLINED_FUTEX KMP_USE_FUTEX && 0\n\n// List of lock definitions; all nested locks are indirect locks.\n// hle lock is xchg lock prefixed with XACQUIRE/XRELEASE.\n// All nested locks are indirect lock types.\n#if KMP_USE_TSX\n#if KMP_USE_FUTEX\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a) m(futex, a) m(hle, a) m(rtm_spin, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(adaptive, a) m(drdpa, a) m(rtm_queuing, a)      \\\n      m(nested_tas, a) m(nested_futex, a) m(nested_ticket, a)                  \\\n          m(nested_queuing, a) m(nested_drdpa, a)\n#else\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a) m(hle, a) m(rtm_spin, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(adaptive, a) m(drdpa, a) m(rtm_queuing, a)      \\\n      m(nested_tas, a) m(nested_ticket, a) m(nested_queuing, a)                \\\n          m(nested_drdpa, a)\n#endif // KMP_USE_FUTEX\n#define KMP_LAST_D_LOCK lockseq_rtm_spin\n#else\n#if KMP_USE_FUTEX\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a) m(futex, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(drdpa, a) m(nested_tas, a) m(nested_futex, a)   \\\n      m(nested_ticket, a) m(nested_queuing, a) m(nested_drdpa, a)\n#define KMP_LAST_D_LOCK lockseq_futex\n#else\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(drdpa, a) m(nested_tas, a) m(nested_ticket, a)  \\\n      m(nested_queuing, a) m(nested_drdpa, a)\n#define KMP_LAST_D_LOCK lockseq_tas\n#endif // KMP_USE_FUTEX\n#endif // KMP_USE_TSX\n\n// Information used in dynamic dispatch\n#define KMP_LOCK_SHIFT                                                         \\\n  8 // number of low bits to be used as tag for direct locks\n#define KMP_FIRST_D_LOCK lockseq_tas\n#define KMP_FIRST_I_LOCK lockseq_ticket\n#define KMP_LAST_I_LOCK lockseq_nested_drdpa\n#define KMP_NUM_I_LOCKS                                                        \\\n  (locktag_nested_drdpa + 1) // number of indirect lock types\n\n// Base type for dynamic locks.\ntypedef kmp_uint32 kmp_dyna_lock_t;\n\n// Lock sequence that enumerates all lock kinds. Always make this enumeration\n// consistent with kmp_lockseq_t in the include directory.\ntypedef enum {\n  lockseq_indirect = 0,\n#define expand_seq(l, a) lockseq_##l,\n  KMP_FOREACH_D_LOCK(expand_seq, 0) KMP_FOREACH_I_LOCK(expand_seq, 0)\n#undef expand_seq\n} kmp_dyna_lockseq_t;\n\n// Enumerates indirect lock tags.\ntypedef enum {\n#define expand_tag(l, a) locktag_##l,\n  KMP_FOREACH_I_LOCK(expand_tag, 0)\n#undef expand_tag\n} kmp_indirect_locktag_t;\n\n// Utility macros that extract information from lock sequences.\n#define KMP_IS_D_LOCK(seq)                                                     \\\n  ((seq) >= KMP_FIRST_D_LOCK && (seq) <= KMP_LAST_D_LOCK)\n#define KMP_IS_I_LOCK(seq)                                                     \\\n  ((seq) >= KMP_FIRST_I_LOCK && (seq) <= KMP_LAST_I_LOCK)\n#define KMP_GET_I_TAG(seq) (kmp_indirect_locktag_t)((seq)-KMP_FIRST_I_LOCK)\n#define KMP_GET_D_TAG(seq) ((seq) << 1 | 1)\n\n// Enumerates direct lock tags starting from indirect tag.\ntypedef enum {\n#define expand_tag(l, a) locktag_##l = KMP_GET_D_TAG(lockseq_##l),\n  KMP_FOREACH_D_LOCK(expand_tag, 0)\n#undef expand_tag\n} kmp_direct_locktag_t;\n\n// Indirect lock type\ntypedef struct {\n  kmp_user_lock_p lock;\n  kmp_indirect_locktag_t type;\n} kmp_indirect_lock_t;\n\n// Function tables for direct locks. Set/unset/test differentiate functions\n// with/without consistency checking.\nextern void (*__kmp_direct_init[])(kmp_dyna_lock_t *, kmp_dyna_lockseq_t);\nextern void (**__kmp_direct_destroy)(kmp_dyna_lock_t *);\nextern int (**__kmp_direct_set)(kmp_dyna_lock_t *, kmp_int32);\nextern int (**__kmp_direct_unset)(kmp_dyna_lock_t *, kmp_int32);\nextern int (**__kmp_direct_test)(kmp_dyna_lock_t *, kmp_int32);\n\n// Function tables for indirect locks. Set/unset/test differentiate functions\n// with/without consistency checking.\nextern void (*__kmp_indirect_init[])(kmp_user_lock_p);\nextern void (**__kmp_indirect_destroy)(kmp_user_lock_p);\nextern int (**__kmp_indirect_set)(kmp_user_lock_p, kmp_int32);\nextern int (**__kmp_indirect_unset)(kmp_user_lock_p, kmp_int32);\nextern int (**__kmp_indirect_test)(kmp_user_lock_p, kmp_int32);\n\n// Extracts direct lock tag from a user lock pointer\n#define KMP_EXTRACT_D_TAG(l)                                                   \\\n  (*((kmp_dyna_lock_t *)(l)) & ((1 << KMP_LOCK_SHIFT) - 1) &                   \\\n   -(*((kmp_dyna_lock_t *)(l)) & 1))\n\n// Extracts indirect lock index from a user lock pointer\n#define KMP_EXTRACT_I_INDEX(l) (*(kmp_lock_index_t *)(l) >> 1)\n\n// Returns function pointer to the direct lock function with l (kmp_dyna_lock_t\n// *) and op (operation type).\n#define KMP_D_LOCK_FUNC(l, op) __kmp_direct_##op[KMP_EXTRACT_D_TAG(l)]\n\n// Returns function pointer to the indirect lock function with l\n// (kmp_indirect_lock_t *) and op (operation type).\n#define KMP_I_LOCK_FUNC(l, op)                                                 \\\n  __kmp_indirect_##op[((kmp_indirect_lock_t *)(l))->type]\n\n// Initializes a direct lock with the given lock pointer and lock sequence.\n#define KMP_INIT_D_LOCK(l, seq)                                                \\\n  __kmp_direct_init[KMP_GET_D_TAG(seq)]((kmp_dyna_lock_t *)l, seq)\n\n// Initializes an indirect lock with the given lock pointer and lock sequence.\n#define KMP_INIT_I_LOCK(l, seq)                                                \\\n  __kmp_direct_init[0]((kmp_dyna_lock_t *)(l), seq)\n\n// Returns \"free\" lock value for the given lock type.\n#define KMP_LOCK_FREE(type) (locktag_##type)\n\n// Returns \"busy\" lock value for the given lock teyp.\n#define KMP_LOCK_BUSY(v, type) ((v) << KMP_LOCK_SHIFT | locktag_##type)\n\n// Returns lock value after removing (shifting) lock tag.\n#define KMP_LOCK_STRIP(v) ((v) >> KMP_LOCK_SHIFT)\n\n// Initializes global states and data structures for managing dynamic user\n// locks.\nextern void __kmp_init_dynamic_user_locks();\n\n// Allocates and returns an indirect lock with the given indirect lock tag.\nextern kmp_indirect_lock_t *\n__kmp_allocate_indirect_lock(void **, kmp_int32, kmp_indirect_locktag_t);\n\n// Cleans up global states and data structures for managing dynamic user locks.\nextern void __kmp_cleanup_indirect_user_locks();\n\n// Default user lock sequence when not using hinted locks.\nextern kmp_dyna_lockseq_t __kmp_user_lock_seq;\n\n// Jump table for \"set lock location\", available only for indirect locks.\nextern void (*__kmp_indirect_set_location[KMP_NUM_I_LOCKS])(kmp_user_lock_p,\n                                                            const ident_t *);\n#define KMP_SET_I_LOCK_LOCATION(lck, loc)                                      \\\n  {                                                                            \\\n    if (__kmp_indirect_set_location[(lck)->type] != NULL)                      \\\n      __kmp_indirect_set_location[(lck)->type]((lck)->lock, loc);              \\\n  }\n\n// Jump table for \"set lock flags\", available only for indirect locks.\nextern void (*__kmp_indirect_set_flags[KMP_NUM_I_LOCKS])(kmp_user_lock_p,\n                                                         kmp_lock_flags_t);\n#define KMP_SET_I_LOCK_FLAGS(lck, flag)                                        \\\n  {                                                                            \\\n    if (__kmp_indirect_set_flags[(lck)->type] != NULL)                         \\\n      __kmp_indirect_set_flags[(lck)->type]((lck)->lock, flag);                \\\n  }\n\n// Jump table for \"get lock location\", available only for indirect locks.\nextern const ident_t *(*__kmp_indirect_get_location[KMP_NUM_I_LOCKS])(\n    kmp_user_lock_p);\n#define KMP_GET_I_LOCK_LOCATION(lck)                                           \\\n  (__kmp_indirect_get_location[(lck)->type] != NULL                            \\\n       ? __kmp_indirect_get_location[(lck)->type]((lck)->lock)                 \\\n       : NULL)\n\n// Jump table for \"get lock flags\", available only for indirect locks.\nextern kmp_lock_flags_t (*__kmp_indirect_get_flags[KMP_NUM_I_LOCKS])(\n    kmp_user_lock_p);\n#define KMP_GET_I_LOCK_FLAGS(lck)                                              \\\n  (__kmp_indirect_get_flags[(lck)->type] != NULL                               \\\n       ? __kmp_indirect_get_flags[(lck)->type]((lck)->lock)                    \\\n       : NULL)\n\n#define KMP_I_LOCK_CHUNK                                                       \\\n  1024 // number of kmp_indirect_lock_t objects to be allocated together\n\n// Lock table for indirect locks.\ntypedef struct kmp_indirect_lock_table {\n  kmp_indirect_lock_t **table; // blocks of indirect locks allocated\n  kmp_lock_index_t size; // size of the indirect lock table\n  kmp_lock_index_t next; // index to the next lock to be allocated\n} kmp_indirect_lock_table_t;\n\nextern kmp_indirect_lock_table_t __kmp_i_lock_table;\n\n// Returns the indirect lock associated with the given index.\n#define KMP_GET_I_LOCK(index)                                                  \\\n  (*(__kmp_i_lock_table.table + (index) / KMP_I_LOCK_CHUNK) +                  \\\n   (index) % KMP_I_LOCK_CHUNK)\n\n// Number of locks in a lock block, which is fixed to \"1\" now.\n// TODO: No lock block implementation now. If we do support, we need to manage\n// lock block data structure for each indirect lock type.\nextern int __kmp_num_locks_in_block;\n\n// Fast lock table lookup without consistency checking\n#define KMP_LOOKUP_I_LOCK(l)                                                   \\\n  ((OMP_LOCK_T_SIZE < sizeof(void *)) ? KMP_GET_I_LOCK(KMP_EXTRACT_I_INDEX(l)) \\\n                                      : *((kmp_indirect_lock_t **)(l)))\n\n// Used once in kmp_error.cpp\nextern kmp_int32 __kmp_get_user_lock_owner(kmp_user_lock_p, kmp_uint32);\n\n#else // KMP_USE_DYNAMIC_LOCK\n\n#define KMP_LOCK_BUSY(v, type) (v)\n#define KMP_LOCK_FREE(type) 0\n#define KMP_LOCK_STRIP(v) (v)\n\n#endif // KMP_USE_DYNAMIC_LOCK\n\n// data structure for using backoff within spin locks.\ntypedef struct {\n  kmp_uint32 step; // current step\n  kmp_uint32 max_backoff; // upper bound of outer delay loop\n  kmp_uint32 min_tick; // size of inner delay loop in ticks (machine-dependent)\n} kmp_backoff_t;\n\n// Runtime's default backoff parameters\nextern kmp_backoff_t __kmp_spin_backoff_params;\n\n// Backoff function\nextern void __kmp_spin_backoff(kmp_backoff_t *);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n#endif /* KMP_LOCK_H */\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_settings.cpp", "content": "/*\n * kmp_settings.cpp -- Initialize environment variables\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"kmp.h\"\n#include \"kmp_affinity.h\"\n#include \"kmp_atomic.h\"\n#if KMP_USE_HIER_SCHED\n#include \"kmp_dispatch_hier.h\"\n#endif\n#include \"kmp_environment.h\"\n#include \"kmp_i18n.h\"\n#include \"kmp_io.h\"\n#include \"kmp_itt.h\"\n#include \"kmp_lock.h\"\n#include \"kmp_settings.h\"\n#include \"kmp_str.h\"\n#include \"kmp_wrapper_getpid.h\"\n#include <ctype.h> // toupper()\n\nstatic int __kmp_env_toPrint(char const *name, int flag);\n\nbool __kmp_env_format = 0; // 0 - old format; 1 - new format\n\n// -----------------------------------------------------------------------------\n// Helper string functions. Subject to move to kmp_str.\n\n#ifdef USE_LOAD_BALANCE\nstatic double __kmp_convert_to_double(char const *s) {\n  double result;\n\n  if (KMP_SSCANF(s, \"%lf\", &result) < 1) {\n    result = 0.0;\n  }\n\n  return result;\n}\n#endif\n\n#ifdef KMP_DEBUG\nstatic unsigned int __kmp_readstr_with_sentinel(char *dest, char const *src,\n                                                size_t len, char sentinel) {\n  unsigned int i;\n  for (i = 0; i < len; i++) {\n    if ((*src == '\\0') || (*src == sentinel)) {\n      break;\n    }\n    *(dest++) = *(src++);\n  }\n  *dest = '\\0';\n  return i;\n}\n#endif\n\nstatic int __kmp_match_with_sentinel(char const *a, char const *b, size_t len,\n                                     char sentinel) {\n  size_t l = 0;\n\n  if (a == NULL)\n    a = \"\";\n  if (b == NULL)\n    b = \"\";\n  while (*a && *b && *b != sentinel) {\n    char ca = *a, cb = *b;\n\n    if (ca >= 'a' && ca <= 'z')\n      ca -= 'a' - 'A';\n    if (cb >= 'a' && cb <= 'z')\n      cb -= 'a' - 'A';\n    if (ca != cb)\n      return FALSE;\n    ++l;\n    ++a;\n    ++b;\n  }\n  return l >= len;\n}\n\n// Expected usage:\n//     token is the token to check for.\n//     buf is the string being parsed.\n//     *end returns the char after the end of the token.\n//        it is not modified unless a match occurs.\n//\n// Example 1:\n//\n//     if (__kmp_match_str(\"token\", buf, *end) {\n//         <do something>\n//         buf = end;\n//     }\n//\n//  Example 2:\n//\n//     if (__kmp_match_str(\"token\", buf, *end) {\n//         char *save = **end;\n//         **end = sentinel;\n//         <use any of the __kmp*_with_sentinel() functions>\n//         **end = save;\n//         buf = end;\n//     }\n\nstatic int __kmp_match_str(char const *token, char const *buf,\n                           const char **end) {\n\n  KMP_ASSERT(token != NULL);\n  KMP_ASSERT(buf != NULL);\n  KMP_ASSERT(end != NULL);\n\n  while (*token && *buf) {\n    char ct = *token, cb = *buf;\n\n    if (ct >= 'a' && ct <= 'z')\n      ct -= 'a' - 'A';\n    if (cb >= 'a' && cb <= 'z')\n      cb -= 'a' - 'A';\n    if (ct != cb)\n      return FALSE;\n    ++token;\n    ++buf;\n  }\n  if (*token) {\n    return FALSE;\n  }\n  *end = buf;\n  return TRUE;\n}\n\n#if KMP_OS_DARWIN\nstatic size_t __kmp_round4k(size_t size) {\n  size_t _4k = 4 * 1024;\n  if (size & (_4k - 1)) {\n    size &= ~(_4k - 1);\n    if (size <= KMP_SIZE_T_MAX - _4k) {\n      size += _4k; // Round up if there is no overflow.\n    }\n  }\n  return size;\n} // __kmp_round4k\n#endif\n\n/* Here, multipliers are like __kmp_convert_to_seconds, but floating-point\n   values are allowed, and the return value is in milliseconds.  The default\n   multiplier is milliseconds.  Returns INT_MAX only if the value specified\n   matches \"infinit*\".  Returns -1 if specified string is invalid. */\nint __kmp_convert_to_milliseconds(char const *data) {\n  int ret, nvalues, factor;\n  char mult, extra;\n  double value;\n\n  if (data == NULL)\n    return (-1);\n  if (__kmp_str_match(\"infinit\", -1, data))\n    return (INT_MAX);\n  value = (double)0.0;\n  mult = '\\0';\n  nvalues = KMP_SSCANF(data, \"%lf%c%c\", &value, &mult, &extra);\n  if (nvalues < 1)\n    return (-1);\n  if (nvalues == 1)\n    mult = '\\0';\n  if (nvalues == 3)\n    return (-1);\n\n  if (value < 0)\n    return (-1);\n\n  switch (mult) {\n  case '\\0':\n    /*  default is milliseconds  */\n    factor = 1;\n    break;\n  case 's':\n  case 'S':\n    factor = 1000;\n    break;\n  case 'm':\n  case 'M':\n    factor = 1000 * 60;\n    break;\n  case 'h':\n  case 'H':\n    factor = 1000 * 60 * 60;\n    break;\n  case 'd':\n  case 'D':\n    factor = 1000 * 24 * 60 * 60;\n    break;\n  default:\n    return (-1);\n  }\n\n  if (value >= ((INT_MAX - 1) / factor))\n    ret = INT_MAX - 1; /* Don't allow infinite value here */\n  else\n    ret = (int)(value * (double)factor); /* truncate to int  */\n\n  return ret;\n}\n\nstatic int __kmp_strcasecmp_with_sentinel(char const *a, char const *b,\n                                          char sentinel) {\n  if (a == NULL)\n    a = \"\";\n  if (b == NULL)\n    b = \"\";\n  while (*a && *b && *b != sentinel) {\n    char ca = *a, cb = *b;\n\n    if (ca >= 'a' && ca <= 'z')\n      ca -= 'a' - 'A';\n    if (cb >= 'a' && cb <= 'z')\n      cb -= 'a' - 'A';\n    if (ca != cb)\n      return (int)(unsigned char)*a - (int)(unsigned char)*b;\n    ++a;\n    ++b;\n  }\n  return *a                       ? (*b && *b != sentinel)\n                                        ? (int)(unsigned char)*a - (int)(unsigned char)*b\n                                        : 1\n         : (*b && *b != sentinel) ? -1\n                                  : 0;\n}\n\n// =============================================================================\n// Table structures and helper functions.\n\ntypedef struct __kmp_setting kmp_setting_t;\ntypedef struct __kmp_stg_ss_data kmp_stg_ss_data_t;\ntypedef struct __kmp_stg_wp_data kmp_stg_wp_data_t;\ntypedef struct __kmp_stg_fr_data kmp_stg_fr_data_t;\n\ntypedef void (*kmp_stg_parse_func_t)(char const *name, char const *value,\n                                     void *data);\ntypedef void (*kmp_stg_print_func_t)(kmp_str_buf_t *buffer, char const *name,\n                                     void *data);\n\nstruct __kmp_setting {\n  char const *name; // Name of setting (environment variable).\n  kmp_stg_parse_func_t parse; // Parser function.\n  kmp_stg_print_func_t print; // Print function.\n  void *data; // Data passed to parser and printer.\n  int set; // Variable set during this \"session\"\n  //     (__kmp_env_initialize() or kmp_set_defaults() call).\n  int defined; // Variable set in any \"session\".\n}; // struct __kmp_setting\n\nstruct __kmp_stg_ss_data {\n  size_t factor; // Default factor: 1 for KMP_STACKSIZE, 1024 for others.\n  kmp_setting_t **rivals; // Array of pointers to rivals (including itself).\n}; // struct __kmp_stg_ss_data\n\nstruct __kmp_stg_wp_data {\n  int omp; // 0 -- KMP_LIBRARY, 1 -- OMP_WAIT_POLICY.\n  kmp_setting_t **rivals; // Array of pointers to rivals (including itself).\n}; // struct __kmp_stg_wp_data\n\nstruct __kmp_stg_fr_data {\n  int force; // 0 -- KMP_DETERMINISTIC_REDUCTION, 1 -- KMP_FORCE_REDUCTION.\n  kmp_setting_t **rivals; // Array of pointers to rivals (including itself).\n}; // struct __kmp_stg_fr_data\n\nstatic int __kmp_stg_check_rivals( // 0 -- Ok, 1 -- errors found.\n    char const *name, // Name of variable.\n    char const *value, // Value of the variable.\n    kmp_setting_t **rivals // List of rival settings (must include current one).\n);\n\n// -----------------------------------------------------------------------------\n// Helper parse functions.\n\nstatic void __kmp_stg_parse_bool(char const *name, char const *value,\n                                 int *out) {\n  if (__kmp_str_match_true(value)) {\n    *out = TRUE;\n  } else if (__kmp_str_match_false(value)) {\n    *out = FALSE;\n  } else {\n    __kmp_msg(kmp_ms_warning, KMP_MSG(BadBoolValue, name, value),\n              KMP_HNT(ValidBoolValues), __kmp_msg_null);\n  }\n} // __kmp_stg_parse_bool\n\n// placed here in order to use __kmp_round4k static function\nvoid __kmp_check_stksize(size_t *val) {\n  // if system stack size is too big then limit the size for worker threads\n  if (*val > KMP_DEFAULT_STKSIZE * 16) // just a heuristics...\n    *val = KMP_DEFAULT_STKSIZE * 16;\n  if (*val < KMP_MIN_STKSIZE)\n    *val = KMP_MIN_STKSIZE;\n  if (*val > KMP_MAX_STKSIZE)\n    *val = KMP_MAX_STKSIZE; // dead code currently, but may work in future\n#if KMP_OS_DARWIN\n  *val = __kmp_round4k(*val);\n#endif // KMP_OS_DARWIN\n}\n\nstatic void __kmp_stg_parse_size(char const *name, char const *value,\n                                 size_t size_min, size_t size_max,\n                                 int *is_specified, size_t *out,\n                                 size_t factor) {\n  char const *msg = NULL;\n#if KMP_OS_DARWIN\n  size_min = __kmp_round4k(size_min);\n  size_max = __kmp_round4k(size_max);\n#endif // KMP_OS_DARWIN\n  if (value) {\n    if (is_specified != NULL) {\n      *is_specified = 1;\n    }\n    __kmp_str_to_size(value, out, factor, &msg);\n    if (msg == NULL) {\n      if (*out > size_max) {\n        *out = size_max;\n        msg = KMP_I18N_STR(ValueTooLarge);\n      } else if (*out < size_min) {\n        *out = size_min;\n        msg = KMP_I18N_STR(ValueTooSmall);\n      } else {\n#if KMP_OS_DARWIN\n        size_t round4k = __kmp_round4k(*out);\n        if (*out != round4k) {\n          *out = round4k;\n          msg = KMP_I18N_STR(NotMultiple4K);\n        }\n#endif\n      }\n    } else {\n      // If integer overflow occurred, * out == KMP_SIZE_T_MAX. Cut it to\n      // size_max silently.\n      if (*out < size_min) {\n        *out = size_max;\n      } else if (*out > size_max) {\n        *out = size_max;\n      }\n    }\n    if (msg != NULL) {\n      // Message is not empty. Print warning.\n      kmp_str_buf_t buf;\n      __kmp_str_buf_init(&buf);\n      __kmp_str_buf_print_size(&buf, *out);\n      KMP_WARNING(ParseSizeIntWarn, name, value, msg);\n      KMP_INFORM(Using_str_Value, name, buf.str);\n      __kmp_str_buf_free(&buf);\n    }\n  }\n} // __kmp_stg_parse_size\n\nstatic void __kmp_stg_parse_str(char const *name, char const *value,\n                                char **out) {\n  __kmp_str_free(out);\n  *out = __kmp_str_format(\"%s\", value);\n} // __kmp_stg_parse_str\n\nstatic void __kmp_stg_parse_int(\n    char const\n        *name, // I: Name of environment variable (used in warning messages).\n    char const *value, // I: Value of environment variable to parse.\n    int min, // I: Minimum allowed value.\n    int max, // I: Maximum allowed value.\n    int *out // O: Output (parsed) value.\n) {\n  char const *msg = NULL;\n  kmp_uint64 uint = *out;\n  __kmp_str_to_uint(value, &uint, &msg);\n  if (msg == NULL) {\n    if (uint < (unsigned int)min) {\n      msg = KMP_I18N_STR(ValueTooSmall);\n      uint = min;\n    } else if (uint > (unsigned int)max) {\n      msg = KMP_I18N_STR(ValueTooLarge);\n      uint = max;\n    }\n  } else {\n    // If overflow occurred msg contains error message and uint is very big. Cut\n    // tmp it to INT_MAX.\n    if (uint < (unsigned int)min) {\n      uint = min;\n    } else if (uint > (unsigned int)max) {\n      uint = max;\n    }\n  }\n  if (msg != NULL) {\n    // Message is not empty. Print warning.\n    kmp_str_buf_t buf;\n    KMP_WARNING(ParseSizeIntWarn, name, value, msg);\n    __kmp_str_buf_init(&buf);\n    __kmp_str_buf_print(&buf, \"%\" KMP_UINT64_SPEC \"\", uint);\n    KMP_INFORM(Using_uint64_Value, name, buf.str);\n    __kmp_str_buf_free(&buf);\n  }\n  __kmp_type_convert(uint, out);\n} // __kmp_stg_parse_int\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\nstatic void __kmp_stg_parse_file(char const *name, char const *value,\n                                 const char *suffix, char **out) {\n  char buffer[256];\n  char *t;\n  int hasSuffix;\n  __kmp_str_free(out);\n  t = (char *)strrchr(value, '.');\n  hasSuffix = t && __kmp_str_eqf(t, suffix);\n  t = __kmp_str_format(\"%s%s\", value, hasSuffix ? \"\" : suffix);\n  __kmp_expand_file_name(buffer, sizeof(buffer), t);\n  __kmp_str_free(&t);\n  *out = __kmp_str_format(\"%s\", buffer);\n} // __kmp_stg_parse_file\n#endif\n\n#ifdef KMP_DEBUG\nstatic char *par_range_to_print = NULL;\n\nstatic void __kmp_stg_parse_par_range(char const *name, char const *value,\n                                      int *out_range, char *out_routine,\n                                      char *out_file, int *out_lb,\n                                      int *out_ub) {\n  size_t len = KMP_STRLEN(value) + 1;\n  par_range_to_print = (char *)KMP_INTERNAL_MALLOC(len + 1);\n  KMP_STRNCPY_S(par_range_to_print, len + 1, value, len + 1);\n  __kmp_par_range = +1;\n  __kmp_par_range_lb = 0;\n  __kmp_par_range_ub = INT_MAX;\n  for (;;) {\n    unsigned int len;\n    if (*value == '\\0') {\n      break;\n    }\n    if (!__kmp_strcasecmp_with_sentinel(\"routine\", value, '=')) {\n      value = strchr(value, '=') + 1;\n      len = __kmp_readstr_with_sentinel(out_routine, value,\n                                        KMP_PAR_RANGE_ROUTINE_LEN - 1, ',');\n      if (len == 0) {\n        goto par_range_error;\n      }\n      value = strchr(value, ',');\n      if (value != NULL) {\n        value++;\n      }\n      continue;\n    }\n    if (!__kmp_strcasecmp_with_sentinel(\"filename\", value, '=')) {\n      value = strchr(value, '=') + 1;\n      len = __kmp_readstr_with_sentinel(out_file, value,\n                                        KMP_PAR_RANGE_FILENAME_LEN - 1, ',');\n      if (len == 0) {\n        goto par_range_error;\n      }\n      value = strchr(value, ',');\n      if (value != NULL) {\n        value++;\n      }\n      continue;\n    }\n    if ((!__kmp_strcasecmp_with_sentinel(\"range\", value, '=')) ||\n        (!__kmp_strcasecmp_with_sentinel(\"incl_range\", value, '='))) {\n      value = strchr(value, '=') + 1;\n      if (KMP_SSCANF(value, \"%d:%d\", out_lb, out_ub) != 2) {\n        goto par_range_error;\n      }\n      *out_range = +1;\n      value = strchr(value, ',');\n      if (value != NULL) {\n        value++;\n      }\n      continue;\n    }\n    if (!__kmp_strcasecmp_with_sentinel(\"excl_range\", value, '=')) {\n      value = strchr(value, '=') + 1;\n      if (KMP_SSCANF(value, \"%d:%d\", out_lb, out_ub) != 2) {\n        goto par_range_error;\n      }\n      *out_range = -1;\n      value = strchr(value, ',');\n      if (value != NULL) {\n        value++;\n      }\n      continue;\n    }\n  par_range_error:\n    KMP_WARNING(ParRangeSyntax, name);\n    __kmp_par_range = 0;\n    break;\n  }\n} // __kmp_stg_parse_par_range\n#endif\n\nint __kmp_initial_threads_capacity(int req_nproc) {\n  int nth = 32;\n\n  /* MIN( MAX( 32, 4 * $OMP_NUM_THREADS, 4 * omp_get_num_procs() ),\n   * __kmp_max_nth) */\n  if (nth < (4 * req_nproc))\n    nth = (4 * req_nproc);\n  if (nth < (4 * __kmp_xproc))\n    nth = (4 * __kmp_xproc);\n\n  // If hidden helper task is enabled, we initialize the thread capacity with\n  // extra\n  // __kmp_hidden_helper_threads_num.\n  nth += __kmp_hidden_helper_threads_num;\n\n  if (nth > __kmp_max_nth)\n    nth = __kmp_max_nth;\n\n  return nth;\n}\n\nint __kmp_default_tp_capacity(int req_nproc, int max_nth,\n                              int all_threads_specified) {\n  int nth = 128;\n\n  if (all_threads_specified)\n    return max_nth;\n  /* MIN( MAX (128, 4 * $OMP_NUM_THREADS, 4 * omp_get_num_procs() ),\n   * __kmp_max_nth ) */\n  if (nth < (4 * req_nproc))\n    nth = (4 * req_nproc);\n  if (nth < (4 * __kmp_xproc))\n    nth = (4 * __kmp_xproc);\n\n  if (nth > __kmp_max_nth)\n    nth = __kmp_max_nth;\n\n  return nth;\n}\n\n// -----------------------------------------------------------------------------\n// Helper print functions.\n\nstatic void __kmp_stg_print_bool(kmp_str_buf_t *buffer, char const *name,\n                                 int value) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_BOOL;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=%s\\n\", name, value ? \"true\" : \"false\");\n  }\n} // __kmp_stg_print_bool\n\nstatic void __kmp_stg_print_int(kmp_str_buf_t *buffer, char const *name,\n                                int value) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_INT;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=%d\\n\", name, value);\n  }\n} // __kmp_stg_print_int\n\nstatic void __kmp_stg_print_uint64(kmp_str_buf_t *buffer, char const *name,\n                                   kmp_uint64 value) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_UINT64;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=%\" KMP_UINT64_SPEC \"\\n\", name, value);\n  }\n} // __kmp_stg_print_uint64\n\nstatic void __kmp_stg_print_str(kmp_str_buf_t *buffer, char const *name,\n                                char const *value) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_STR;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=%s\\n\", name, value);\n  }\n} // __kmp_stg_print_str\n\nstatic void __kmp_stg_print_size(kmp_str_buf_t *buffer, char const *name,\n                                 size_t value) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n    __kmp_str_buf_print_size(buffer, value);\n    __kmp_str_buf_print(buffer, \"'\\n\");\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=\", name);\n    __kmp_str_buf_print_size(buffer, value);\n    __kmp_str_buf_print(buffer, \"\\n\");\n    return;\n  }\n} // __kmp_stg_print_size\n\n// =============================================================================\n// Parse and print functions.\n\n// -----------------------------------------------------------------------------\n// KMP_DEVICE_THREAD_LIMIT, KMP_ALL_THREADS\n\nstatic void __kmp_stg_parse_device_thread_limit(char const *name,\n                                                char const *value, void *data) {\n  kmp_setting_t **rivals = (kmp_setting_t **)data;\n  int rc;\n  if (strcmp(name, \"KMP_ALL_THREADS\") == 0) {\n    KMP_INFORM(EnvVarDeprecated, name, \"KMP_DEVICE_THREAD_LIMIT\");\n  }\n  rc = __kmp_stg_check_rivals(name, value, rivals);\n  if (rc) {\n    return;\n  }\n  if (!__kmp_strcasecmp_with_sentinel(\"all\", value, 0)) {\n    __kmp_max_nth = __kmp_xproc;\n    __kmp_allThreadsSpecified = 1;\n  } else {\n    __kmp_stg_parse_int(name, value, 1, __kmp_sys_max_nth, &__kmp_max_nth);\n    __kmp_allThreadsSpecified = 0;\n  }\n  K_DIAG(1, (\"__kmp_max_nth == %d\\n\", __kmp_max_nth));\n\n} // __kmp_stg_parse_device_thread_limit\n\nstatic void __kmp_stg_print_device_thread_limit(kmp_str_buf_t *buffer,\n                                                char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_max_nth);\n} // __kmp_stg_print_device_thread_limit\n\n// -----------------------------------------------------------------------------\n// OMP_THREAD_LIMIT\nstatic void __kmp_stg_parse_thread_limit(char const *name, char const *value,\n                                         void *data) {\n  __kmp_stg_parse_int(name, value, 1, __kmp_sys_max_nth, &__kmp_cg_max_nth);\n  K_DIAG(1, (\"__kmp_cg_max_nth == %d\\n\", __kmp_cg_max_nth));\n\n} // __kmp_stg_parse_thread_limit\n\nstatic void __kmp_stg_print_thread_limit(kmp_str_buf_t *buffer,\n                                         char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_cg_max_nth);\n} // __kmp_stg_print_thread_limit\n\n// -----------------------------------------------------------------------------\n// OMP_NUM_TEAMS\nstatic void __kmp_stg_parse_nteams(char const *name, char const *value,\n                                   void *data) {\n  __kmp_stg_parse_int(name, value, 1, __kmp_sys_max_nth, &__kmp_nteams);\n  K_DIAG(1, (\"__kmp_nteams == %d\\n\", __kmp_nteams));\n} // __kmp_stg_parse_nteams\n\nstatic void __kmp_stg_print_nteams(kmp_str_buf_t *buffer, char const *name,\n                                   void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_nteams);\n} // __kmp_stg_print_nteams\n\n// -----------------------------------------------------------------------------\n// OMP_TEAMS_THREAD_LIMIT\nstatic void __kmp_stg_parse_teams_th_limit(char const *name, char const *value,\n                                           void *data) {\n  __kmp_stg_parse_int(name, value, 1, __kmp_sys_max_nth,\n                      &__kmp_teams_thread_limit);\n  K_DIAG(1, (\"__kmp_teams_thread_limit == %d\\n\", __kmp_teams_thread_limit));\n} // __kmp_stg_parse_teams_th_limit\n\nstatic void __kmp_stg_print_teams_th_limit(kmp_str_buf_t *buffer,\n                                           char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_teams_thread_limit);\n} // __kmp_stg_print_teams_th_limit\n\n// -----------------------------------------------------------------------------\n// KMP_TEAMS_THREAD_LIMIT\nstatic void __kmp_stg_parse_teams_thread_limit(char const *name,\n                                               char const *value, void *data) {\n  __kmp_stg_parse_int(name, value, 1, __kmp_sys_max_nth, &__kmp_teams_max_nth);\n} // __kmp_stg_teams_thread_limit\n\nstatic void __kmp_stg_print_teams_thread_limit(kmp_str_buf_t *buffer,\n                                               char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_teams_max_nth);\n} // __kmp_stg_print_teams_thread_limit\n\n// -----------------------------------------------------------------------------\n// KMP_USE_YIELD\nstatic void __kmp_stg_parse_use_yield(char const *name, char const *value,\n                                      void *data) {\n  __kmp_stg_parse_int(name, value, 0, 2, &__kmp_use_yield);\n  __kmp_use_yield_exp_set = 1;\n} // __kmp_stg_parse_use_yield\n\nstatic void __kmp_stg_print_use_yield(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_use_yield);\n} // __kmp_stg_print_use_yield\n\n// -----------------------------------------------------------------------------\n// KMP_BLOCKTIME\n\nstatic void __kmp_stg_parse_blocktime(char const *name, char const *value,\n                                      void *data) {\n  __kmp_dflt_blocktime = __kmp_convert_to_milliseconds(value);\n  if (__kmp_dflt_blocktime < 0) {\n    __kmp_dflt_blocktime = KMP_DEFAULT_BLOCKTIME;\n    __kmp_msg(kmp_ms_warning, KMP_MSG(InvalidValue, name, value),\n              __kmp_msg_null);\n    KMP_INFORM(Using_int_Value, name, __kmp_dflt_blocktime);\n    __kmp_env_blocktime = FALSE; // Revert to default as if var not set.\n  } else {\n    if (__kmp_dflt_blocktime < KMP_MIN_BLOCKTIME) {\n      __kmp_dflt_blocktime = KMP_MIN_BLOCKTIME;\n      __kmp_msg(kmp_ms_warning, KMP_MSG(SmallValue, name, value),\n                __kmp_msg_null);\n      KMP_INFORM(MinValueUsing, name, __kmp_dflt_blocktime);\n    } else if (__kmp_dflt_blocktime > KMP_MAX_BLOCKTIME) {\n      __kmp_dflt_blocktime = KMP_MAX_BLOCKTIME;\n      __kmp_msg(kmp_ms_warning, KMP_MSG(LargeValue, name, value),\n                __kmp_msg_null);\n      KMP_INFORM(MaxValueUsing, name, __kmp_dflt_blocktime);\n    }\n    __kmp_env_blocktime = TRUE; // KMP_BLOCKTIME was specified.\n  }\n#if KMP_USE_MONITOR\n  // calculate number of monitor thread wakeup intervals corresponding to\n  // blocktime.\n  __kmp_monitor_wakeups =\n      KMP_WAKEUPS_FROM_BLOCKTIME(__kmp_dflt_blocktime, __kmp_monitor_wakeups);\n  __kmp_bt_intervals =\n      KMP_INTERVALS_FROM_BLOCKTIME(__kmp_dflt_blocktime, __kmp_monitor_wakeups);\n#endif\n  K_DIAG(1, (\"__kmp_env_blocktime == %d\\n\", __kmp_env_blocktime));\n  if (__kmp_env_blocktime) {\n    K_DIAG(1, (\"__kmp_dflt_blocktime == %d\\n\", __kmp_dflt_blocktime));\n  }\n} // __kmp_stg_parse_blocktime\n\nstatic void __kmp_stg_print_blocktime(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_dflt_blocktime);\n} // __kmp_stg_print_blocktime\n\n// -----------------------------------------------------------------------------\n// KMP_DUPLICATE_LIB_OK\n\nstatic void __kmp_stg_parse_duplicate_lib_ok(char const *name,\n                                             char const *value, void *data) {\n  /* actually this variable is not supported, put here for compatibility with\n     earlier builds and for static/dynamic combination */\n  __kmp_stg_parse_bool(name, value, &__kmp_duplicate_library_ok);\n} // __kmp_stg_parse_duplicate_lib_ok\n\nstatic void __kmp_stg_print_duplicate_lib_ok(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_duplicate_library_ok);\n} // __kmp_stg_print_duplicate_lib_ok\n\n// -----------------------------------------------------------------------------\n// KMP_INHERIT_FP_CONTROL\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n\nstatic void __kmp_stg_parse_inherit_fp_control(char const *name,\n                                               char const *value, void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_inherit_fp_control);\n} // __kmp_stg_parse_inherit_fp_control\n\nstatic void __kmp_stg_print_inherit_fp_control(kmp_str_buf_t *buffer,\n                                               char const *name, void *data) {\n#if KMP_DEBUG\n  __kmp_stg_print_bool(buffer, name, __kmp_inherit_fp_control);\n#endif /* KMP_DEBUG */\n} // __kmp_stg_print_inherit_fp_control\n\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n// Used for OMP_WAIT_POLICY\nstatic char const *blocktime_str = NULL;\n\n// -----------------------------------------------------------------------------\n// KMP_LIBRARY, OMP_WAIT_POLICY\n\nstatic void __kmp_stg_parse_wait_policy(char const *name, char const *value,\n                                        void *data) {\n\n  kmp_stg_wp_data_t *wait = (kmp_stg_wp_data_t *)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, wait->rivals);\n  if (rc) {\n    return;\n  }\n\n  if (wait->omp) {\n    if (__kmp_str_match(\"ACTIVE\", 1, value)) {\n      __kmp_library = library_turnaround;\n      if (blocktime_str == NULL) {\n        // KMP_BLOCKTIME not specified, so set default to \"infinite\".\n        __kmp_dflt_blocktime = KMP_MAX_BLOCKTIME;\n      }\n    } else if (__kmp_str_match(\"PASSIVE\", 1, value)) {\n      __kmp_library = library_throughput;\n      if (blocktime_str == NULL) {\n        // KMP_BLOCKTIME not specified, so set default to 0.\n        __kmp_dflt_blocktime = 0;\n      }\n    } else {\n      KMP_WARNING(StgInvalidValue, name, value);\n    }\n  } else {\n    if (__kmp_str_match(\"serial\", 1, value)) { /* S */\n      __kmp_library = library_serial;\n    } else if (__kmp_str_match(\"throughput\", 2, value)) { /* TH */\n      __kmp_library = library_throughput;\n      if (blocktime_str == NULL) {\n        // KMP_BLOCKTIME not specified, so set default to 0.\n        __kmp_dflt_blocktime = 0;\n      }\n    } else if (__kmp_str_match(\"turnaround\", 2, value)) { /* TU */\n      __kmp_library = library_turnaround;\n    } else if (__kmp_str_match(\"dedicated\", 1, value)) { /* D */\n      __kmp_library = library_turnaround;\n    } else if (__kmp_str_match(\"multiuser\", 1, value)) { /* M */\n      __kmp_library = library_throughput;\n      if (blocktime_str == NULL) {\n        // KMP_BLOCKTIME not specified, so set default to 0.\n        __kmp_dflt_blocktime = 0;\n      }\n    } else {\n      KMP_WARNING(StgInvalidValue, name, value);\n    }\n  }\n} // __kmp_stg_parse_wait_policy\n\nstatic void __kmp_stg_print_wait_policy(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n\n  kmp_stg_wp_data_t *wait = (kmp_stg_wp_data_t *)data;\n  char const *value = NULL;\n\n  if (wait->omp) {\n    switch (__kmp_library) {\n    case library_turnaround: {\n      value = \"ACTIVE\";\n    } break;\n    case library_throughput: {\n      value = \"PASSIVE\";\n    } break;\n    }\n  } else {\n    switch (__kmp_library) {\n    case library_serial: {\n      value = \"serial\";\n    } break;\n    case library_turnaround: {\n      value = \"turnaround\";\n    } break;\n    case library_throughput: {\n      value = \"throughput\";\n    } break;\n    }\n  }\n  if (value != NULL) {\n    __kmp_stg_print_str(buffer, name, value);\n  }\n\n} // __kmp_stg_print_wait_policy\n\n#if KMP_USE_MONITOR\n// -----------------------------------------------------------------------------\n// KMP_MONITOR_STACKSIZE\n\nstatic void __kmp_stg_parse_monitor_stacksize(char const *name,\n                                              char const *value, void *data) {\n  __kmp_stg_parse_size(name, value, __kmp_sys_min_stksize, KMP_MAX_STKSIZE,\n                       NULL, &__kmp_monitor_stksize, 1);\n} // __kmp_stg_parse_monitor_stacksize\n\nstatic void __kmp_stg_print_monitor_stacksize(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n  if (__kmp_env_format) {\n    if (__kmp_monitor_stksize > 0)\n      KMP_STR_BUF_PRINT_NAME_EX(name);\n    else\n      KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  if (__kmp_monitor_stksize > 0) {\n    __kmp_str_buf_print_size(buffer, __kmp_monitor_stksize);\n  } else {\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  }\n  if (__kmp_env_format && __kmp_monitor_stksize) {\n    __kmp_str_buf_print(buffer, \"'\\n\");\n  }\n} // __kmp_stg_print_monitor_stacksize\n#endif // KMP_USE_MONITOR\n\n// -----------------------------------------------------------------------------\n// KMP_SETTINGS\n\nstatic void __kmp_stg_parse_settings(char const *name, char const *value,\n                                     void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_settings);\n} // __kmp_stg_parse_settings\n\nstatic void __kmp_stg_print_settings(kmp_str_buf_t *buffer, char const *name,\n                                     void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_settings);\n} // __kmp_stg_print_settings\n\n// -----------------------------------------------------------------------------\n// KMP_STACKPAD\n\nstatic void __kmp_stg_parse_stackpad(char const *name, char const *value,\n                                     void *data) {\n  __kmp_stg_parse_int(name, // Env var name\n                      value, // Env var value\n                      KMP_MIN_STKPADDING, // Min value\n                      KMP_MAX_STKPADDING, // Max value\n                      &__kmp_stkpadding // Var to initialize\n  );\n} // __kmp_stg_parse_stackpad\n\nstatic void __kmp_stg_print_stackpad(kmp_str_buf_t *buffer, char const *name,\n                                     void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_stkpadding);\n} // __kmp_stg_print_stackpad\n\n// -----------------------------------------------------------------------------\n// KMP_STACKOFFSET\n\nstatic void __kmp_stg_parse_stackoffset(char const *name, char const *value,\n                                        void *data) {\n  __kmp_stg_parse_size(name, // Env var name\n                       value, // Env var value\n                       KMP_MIN_STKOFFSET, // Min value\n                       KMP_MAX_STKOFFSET, // Max value\n                       NULL, //\n                       &__kmp_stkoffset, // Var to initialize\n                       1);\n} // __kmp_stg_parse_stackoffset\n\nstatic void __kmp_stg_print_stackoffset(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  __kmp_stg_print_size(buffer, name, __kmp_stkoffset);\n} // __kmp_stg_print_stackoffset\n\n// -----------------------------------------------------------------------------\n// KMP_STACKSIZE, OMP_STACKSIZE, GOMP_STACKSIZE\n\nstatic void __kmp_stg_parse_stacksize(char const *name, char const *value,\n                                      void *data) {\n\n  kmp_stg_ss_data_t *stacksize = (kmp_stg_ss_data_t *)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, stacksize->rivals);\n  if (rc) {\n    return;\n  }\n  __kmp_stg_parse_size(name, // Env var name\n                       value, // Env var value\n                       __kmp_sys_min_stksize, // Min value\n                       KMP_MAX_STKSIZE, // Max value\n                       &__kmp_env_stksize, //\n                       &__kmp_stksize, // Var to initialize\n                       stacksize->factor);\n\n} // __kmp_stg_parse_stacksize\n\n// This function is called for printing both KMP_STACKSIZE (factor is 1) and\n// OMP_STACKSIZE (factor is 1024). Currently it is not possible to print\n// OMP_STACKSIZE value in bytes. We can consider adding this possibility by a\n// customer request in future.\nstatic void __kmp_stg_print_stacksize(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  kmp_stg_ss_data_t *stacksize = (kmp_stg_ss_data_t *)data;\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n    __kmp_str_buf_print_size(buffer, (__kmp_stksize % 1024)\n                                         ? __kmp_stksize / stacksize->factor\n                                         : __kmp_stksize);\n    __kmp_str_buf_print(buffer, \"'\\n\");\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=\", name);\n    __kmp_str_buf_print_size(buffer, (__kmp_stksize % 1024)\n                                         ? __kmp_stksize / stacksize->factor\n                                         : __kmp_stksize);\n    __kmp_str_buf_print(buffer, \"\\n\");\n  }\n} // __kmp_stg_print_stacksize\n\n// -----------------------------------------------------------------------------\n// KMP_VERSION\n\nstatic void __kmp_stg_parse_version(char const *name, char const *value,\n                                    void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_version);\n} // __kmp_stg_parse_version\n\nstatic void __kmp_stg_print_version(kmp_str_buf_t *buffer, char const *name,\n                                    void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_version);\n} // __kmp_stg_print_version\n\n// -----------------------------------------------------------------------------\n// KMP_WARNINGS\n\nstatic void __kmp_stg_parse_warnings(char const *name, char const *value,\n                                     void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_generate_warnings);\n  if (__kmp_generate_warnings != kmp_warnings_off) {\n    // AC: only 0/1 values documented, so reset to explicit to distinguish from\n    // default setting\n    __kmp_generate_warnings = kmp_warnings_explicit;\n  }\n} // __kmp_stg_parse_warnings\n\nstatic void __kmp_stg_print_warnings(kmp_str_buf_t *buffer, char const *name,\n                                     void *data) {\n  // AC: TODO: change to print_int? (needs documentation change)\n  __kmp_stg_print_bool(buffer, name, __kmp_generate_warnings);\n} // __kmp_stg_print_warnings\n\n// -----------------------------------------------------------------------------\n// OMP_NESTED, OMP_NUM_THREADS\n\nstatic void __kmp_stg_parse_nested(char const *name, char const *value,\n                                   void *data) {\n  int nested;\n  KMP_INFORM(EnvVarDeprecated, name, \"OMP_MAX_ACTIVE_LEVELS\");\n  __kmp_stg_parse_bool(name, value, &nested);\n  if (nested) {\n    if (!__kmp_dflt_max_active_levels_set)\n      __kmp_dflt_max_active_levels = KMP_MAX_ACTIVE_LEVELS_LIMIT;\n  } else { // nesting explicitly turned off\n    __kmp_dflt_max_active_levels = 1;\n    __kmp_dflt_max_active_levels_set = true;\n  }\n} // __kmp_stg_parse_nested\n\nstatic void __kmp_stg_print_nested(kmp_str_buf_t *buffer, char const *name,\n                                   void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  __kmp_str_buf_print(buffer, \": deprecated; max-active-levels-var=%d\\n\",\n                      __kmp_dflt_max_active_levels);\n} // __kmp_stg_print_nested\n\nstatic void __kmp_parse_nested_num_threads(const char *var, const char *env,\n                                           kmp_nested_nthreads_t *nth_array) {\n  const char *next = env;\n  const char *scan = next;\n\n  int total = 0; // Count elements that were set. It'll be used as an array size\n  int prev_comma = FALSE; // For correct processing sequential commas\n\n  // Count the number of values in the env. var string\n  for (;;) {\n    SKIP_WS(next);\n\n    if (*next == '\\0') {\n      break;\n    }\n    // Next character is not an integer or not a comma => end of list\n    if (((*next < '0') || (*next > '9')) && (*next != ',')) {\n      KMP_WARNING(NthSyntaxError, var, env);\n      return;\n    }\n    // The next character is ','\n    if (*next == ',') {\n      // ',' is the first character\n      if (total == 0 || prev_comma) {\n        total++;\n      }\n      prev_comma = TRUE;\n      next++; // skip ','\n      SKIP_WS(next);\n    }\n    // Next character is a digit\n    if (*next >= '0' && *next <= '9') {\n      prev_comma = FALSE;\n      SKIP_DIGITS(next);\n      total++;\n      const char *tmp = next;\n      SKIP_WS(tmp);\n      if ((*next == ' ' || *next == '\\t') && (*tmp >= '0' && *tmp <= '9')) {\n        KMP_WARNING(NthSpacesNotAllowed, var, env);\n        return;\n      }\n    }\n  }\n  if (!__kmp_dflt_max_active_levels_set && total > 1)\n    __kmp_dflt_max_active_levels = KMP_MAX_ACTIVE_LEVELS_LIMIT;\n  KMP_DEBUG_ASSERT(total > 0);\n  if (total <= 0) {\n    KMP_WARNING(NthSyntaxError, var, env);\n    return;\n  }\n\n  // Check if the nested nthreads array exists\n  if (!nth_array->nth) {\n    // Allocate an array of double size\n    nth_array->nth = (int *)KMP_INTERNAL_MALLOC(sizeof(int) * total * 2);\n    if (nth_array->nth == NULL) {\n      KMP_FATAL(MemoryAllocFailed);\n    }\n    nth_array->size = total * 2;\n  } else {\n    if (nth_array->size < total) {\n      // Increase the array size\n      do {\n        nth_array->size *= 2;\n      } while (nth_array->size < total);\n\n      nth_array->nth = (int *)KMP_INTERNAL_REALLOC(\n          nth_array->nth, sizeof(int) * nth_array->size);\n      if (nth_array->nth == NULL) {\n        KMP_FATAL(MemoryAllocFailed);\n      }\n    }\n  }\n  nth_array->used = total;\n  int i = 0;\n\n  prev_comma = FALSE;\n  total = 0;\n  // Save values in the array\n  for (;;) {\n    SKIP_WS(scan);\n    if (*scan == '\\0') {\n      break;\n    }\n    // The next character is ','\n    if (*scan == ',') {\n      // ',' in the beginning of the list\n      if (total == 0) {\n        // The value is supposed to be equal to __kmp_avail_proc but it is\n        // unknown at the moment.\n        // So let's put a placeholder (#threads = 0) to correct it later.\n        nth_array->nth[i++] = 0;\n        total++;\n      } else if (prev_comma) {\n        // Num threads is inherited from the previous level\n        nth_array->nth[i] = nth_array->nth[i - 1];\n        i++;\n        total++;\n      }\n      prev_comma = TRUE;\n      scan++; // skip ','\n      SKIP_WS(scan);\n    }\n    // Next character is a digit\n    if (*scan >= '0' && *scan <= '9') {\n      int num;\n      const char *buf = scan;\n      char const *msg = NULL;\n      prev_comma = FALSE;\n      SKIP_DIGITS(scan);\n      total++;\n\n      num = __kmp_str_to_int(buf, *scan);\n      if (num < KMP_MIN_NTH) {\n        msg = KMP_I18N_STR(ValueTooSmall);\n        num = KMP_MIN_NTH;\n      } else if (num > __kmp_sys_max_nth) {\n        msg = KMP_I18N_STR(ValueTooLarge);\n        num = __kmp_sys_max_nth;\n      }\n      if (msg != NULL) {\n        // Message is not empty. Print warning.\n        KMP_WARNING(ParseSizeIntWarn, var, env, msg);\n        KMP_INFORM(Using_int_Value, var, num);\n      }\n      nth_array->nth[i++] = num;\n    }\n  }\n}\n\nstatic void __kmp_stg_parse_num_threads(char const *name, char const *value,\n                                        void *data) {\n  // TODO: Remove this option. OMP_NUM_THREADS is a list of positive integers!\n  if (!__kmp_strcasecmp_with_sentinel(\"all\", value, 0)) {\n    // The array of 1 element\n    __kmp_nested_nth.nth = (int *)KMP_INTERNAL_MALLOC(sizeof(int));\n    __kmp_nested_nth.size = __kmp_nested_nth.used = 1;\n    __kmp_nested_nth.nth[0] = __kmp_dflt_team_nth = __kmp_dflt_team_nth_ub =\n        __kmp_xproc;\n  } else {\n    __kmp_parse_nested_num_threads(name, value, &__kmp_nested_nth);\n    if (__kmp_nested_nth.nth) {\n      __kmp_dflt_team_nth = __kmp_nested_nth.nth[0];\n      if (__kmp_dflt_team_nth_ub < __kmp_dflt_team_nth) {\n        __kmp_dflt_team_nth_ub = __kmp_dflt_team_nth;\n      }\n    }\n  }\n  K_DIAG(1, (\"__kmp_dflt_team_nth == %d\\n\", __kmp_dflt_team_nth));\n} // __kmp_stg_parse_num_threads\n\nstatic void __kmp_stg_parse_num_hidden_helper_threads(char const *name,\n                                                      char const *value,\n                                                      void *data) {\n  __kmp_stg_parse_int(name, value, 0, 16, &__kmp_hidden_helper_threads_num);\n  // If the number of hidden helper threads is zero, we disable hidden helper\n  // task\n  if (__kmp_hidden_helper_threads_num == 0) {\n    __kmp_enable_hidden_helper = FALSE;\n  }\n} // __kmp_stg_parse_num_hidden_helper_threads\n\nstatic void __kmp_stg_print_num_hidden_helper_threads(kmp_str_buf_t *buffer,\n                                                      char const *name,\n                                                      void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_hidden_helper_threads_num);\n} // __kmp_stg_print_num_hidden_helper_threads\n\nstatic void __kmp_stg_parse_use_hidden_helper(char const *name,\n                                              char const *value, void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_enable_hidden_helper);\n#if !KMP_OS_LINUX\n  __kmp_enable_hidden_helper = FALSE;\n  K_DIAG(1,\n         (\"__kmp_stg_parse_use_hidden_helper: Disable hidden helper task on \"\n          \"non-Linux platform although it is enabled by user explicitly.\\n\"));\n#endif\n} // __kmp_stg_parse_use_hidden_helper\n\nstatic void __kmp_stg_print_use_hidden_helper(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_enable_hidden_helper);\n} // __kmp_stg_print_use_hidden_helper\n\nstatic void __kmp_stg_print_num_threads(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  if (__kmp_nested_nth.used) {\n    kmp_str_buf_t buf;\n    __kmp_str_buf_init(&buf);\n    for (int i = 0; i < __kmp_nested_nth.used; i++) {\n      __kmp_str_buf_print(&buf, \"%d\", __kmp_nested_nth.nth[i]);\n      if (i < __kmp_nested_nth.used - 1) {\n        __kmp_str_buf_print(&buf, \",\");\n      }\n    }\n    __kmp_str_buf_print(buffer, \"='%s'\\n\", buf.str);\n    __kmp_str_buf_free(&buf);\n  } else {\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  }\n} // __kmp_stg_print_num_threads\n\n// -----------------------------------------------------------------------------\n// OpenMP 3.0: KMP_TASKING, OMP_MAX_ACTIVE_LEVELS,\n\nstatic void __kmp_stg_parse_tasking(char const *name, char const *value,\n                                    void *data) {\n  __kmp_stg_parse_int(name, value, 0, (int)tskm_max,\n                      (int *)&__kmp_tasking_mode);\n} // __kmp_stg_parse_tasking\n\nstatic void __kmp_stg_print_tasking(kmp_str_buf_t *buffer, char const *name,\n                                    void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_tasking_mode);\n} // __kmp_stg_print_tasking\n\nstatic void __kmp_stg_parse_task_stealing(char const *name, char const *value,\n                                          void *data) {\n  __kmp_stg_parse_int(name, value, 0, 1,\n                      (int *)&__kmp_task_stealing_constraint);\n} // __kmp_stg_parse_task_stealing\n\nstatic void __kmp_stg_print_task_stealing(kmp_str_buf_t *buffer,\n                                          char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_task_stealing_constraint);\n} // __kmp_stg_print_task_stealing\n\nstatic void __kmp_stg_parse_max_active_levels(char const *name,\n                                              char const *value, void *data) {\n  kmp_uint64 tmp_dflt = 0;\n  char const *msg = NULL;\n  if (!__kmp_dflt_max_active_levels_set) {\n    // Don't overwrite __kmp_dflt_max_active_levels if we get an invalid setting\n    __kmp_str_to_uint(value, &tmp_dflt, &msg);\n    if (msg != NULL) { // invalid setting; print warning and ignore\n      KMP_WARNING(ParseSizeIntWarn, name, value, msg);\n    } else if (tmp_dflt > KMP_MAX_ACTIVE_LEVELS_LIMIT) {\n      // invalid setting; print warning and ignore\n      msg = KMP_I18N_STR(ValueTooLarge);\n      KMP_WARNING(ParseSizeIntWarn, name, value, msg);\n    } else { // valid setting\n      __kmp_type_convert(tmp_dflt, &(__kmp_dflt_max_active_levels));\n      __kmp_dflt_max_active_levels_set = true;\n    }\n  }\n} // __kmp_stg_parse_max_active_levels\n\nstatic void __kmp_stg_print_max_active_levels(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_dflt_max_active_levels);\n} // __kmp_stg_print_max_active_levels\n\n// -----------------------------------------------------------------------------\n// OpenMP 4.0: OMP_DEFAULT_DEVICE\nstatic void __kmp_stg_parse_default_device(char const *name, char const *value,\n                                           void *data) {\n  __kmp_stg_parse_int(name, value, 0, KMP_MAX_DEFAULT_DEVICE_LIMIT,\n                      &__kmp_default_device);\n} // __kmp_stg_parse_default_device\n\nstatic void __kmp_stg_print_default_device(kmp_str_buf_t *buffer,\n                                           char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_default_device);\n} // __kmp_stg_print_default_device\n\n// -----------------------------------------------------------------------------\n// OpenMP 5.0: OMP_TARGET_OFFLOAD\nstatic void __kmp_stg_parse_target_offload(char const *name, char const *value,\n                                           void *data) {\n  const char *next = value;\n  const char *scan = next;\n\n  __kmp_target_offload = tgt_default;\n  SKIP_WS(next);\n  if (*next == '\\0')\n    return;\n  scan = next;\n  if (!__kmp_strcasecmp_with_sentinel(\"mandatory\", scan, 0)) {\n    __kmp_target_offload = tgt_mandatory;\n  } else if (!__kmp_strcasecmp_with_sentinel(\"disabled\", scan, 0)) {\n    __kmp_target_offload = tgt_disabled;\n  } else if (!__kmp_strcasecmp_with_sentinel(\"default\", scan, 0)) {\n    __kmp_target_offload = tgt_default;\n  } else {\n    KMP_WARNING(SyntaxErrorUsing, name, \"DEFAULT\");\n  }\n\n} // __kmp_stg_parse_target_offload\n\nstatic void __kmp_stg_print_target_offload(kmp_str_buf_t *buffer,\n                                           char const *name, void *data) {\n  const char *value = NULL;\n  if (__kmp_target_offload == tgt_default)\n    value = \"DEFAULT\";\n  else if (__kmp_target_offload == tgt_mandatory)\n    value = \"MANDATORY\";\n  else if (__kmp_target_offload == tgt_disabled)\n    value = \"DISABLED\";\n  KMP_DEBUG_ASSERT(value);\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  __kmp_str_buf_print(buffer, \"=%s\\n\", value);\n} // __kmp_stg_print_target_offload\n\n// -----------------------------------------------------------------------------\n// OpenMP 4.5: OMP_MAX_TASK_PRIORITY\nstatic void __kmp_stg_parse_max_task_priority(char const *name,\n                                              char const *value, void *data) {\n  __kmp_stg_parse_int(name, value, 0, KMP_MAX_TASK_PRIORITY_LIMIT,\n                      &__kmp_max_task_priority);\n} // __kmp_stg_parse_max_task_priority\n\nstatic void __kmp_stg_print_max_task_priority(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_max_task_priority);\n} // __kmp_stg_print_max_task_priority\n\n// KMP_TASKLOOP_MIN_TASKS\n// taskloop threshold to switch from recursive to linear tasks creation\nstatic void __kmp_stg_parse_taskloop_min_tasks(char const *name,\n                                               char const *value, void *data) {\n  int tmp;\n  __kmp_stg_parse_int(name, value, 0, INT_MAX, &tmp);\n  __kmp_taskloop_min_tasks = tmp;\n} // __kmp_stg_parse_taskloop_min_tasks\n\nstatic void __kmp_stg_print_taskloop_min_tasks(kmp_str_buf_t *buffer,\n                                               char const *name, void *data) {\n  __kmp_stg_print_uint64(buffer, name, __kmp_taskloop_min_tasks);\n} // __kmp_stg_print_taskloop_min_tasks\n\n// -----------------------------------------------------------------------------\n// KMP_DISP_NUM_BUFFERS\nstatic void __kmp_stg_parse_disp_buffers(char const *name, char const *value,\n                                         void *data) {\n  if (TCR_4(__kmp_init_serial)) {\n    KMP_WARNING(EnvSerialWarn, name);\n    return;\n  } // read value before serial initialization only\n  __kmp_stg_parse_int(name, value, KMP_MIN_DISP_NUM_BUFF, KMP_MAX_DISP_NUM_BUFF,\n                      &__kmp_dispatch_num_buffers);\n} // __kmp_stg_parse_disp_buffers\n\nstatic void __kmp_stg_print_disp_buffers(kmp_str_buf_t *buffer,\n                                         char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_dispatch_num_buffers);\n} // __kmp_stg_print_disp_buffers\n\n#if KMP_NESTED_HOT_TEAMS\n// -----------------------------------------------------------------------------\n// KMP_HOT_TEAMS_MAX_LEVEL, KMP_HOT_TEAMS_MODE\n\nstatic void __kmp_stg_parse_hot_teams_level(char const *name, char const *value,\n                                            void *data) {\n  if (TCR_4(__kmp_init_parallel)) {\n    KMP_WARNING(EnvParallelWarn, name);\n    return;\n  } // read value before first parallel only\n  __kmp_stg_parse_int(name, value, 0, KMP_MAX_ACTIVE_LEVELS_LIMIT,\n                      &__kmp_hot_teams_max_level);\n} // __kmp_stg_parse_hot_teams_level\n\nstatic void __kmp_stg_print_hot_teams_level(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_hot_teams_max_level);\n} // __kmp_stg_print_hot_teams_level\n\nstatic void __kmp_stg_parse_hot_teams_mode(char const *name, char const *value,\n                                           void *data) {\n  if (TCR_4(__kmp_init_parallel)) {\n    KMP_WARNING(EnvParallelWarn, name);\n    return;\n  } // read value before first parallel only\n  __kmp_stg_parse_int(name, value, 0, KMP_MAX_ACTIVE_LEVELS_LIMIT,\n                      &__kmp_hot_teams_mode);\n} // __kmp_stg_parse_hot_teams_mode\n\nstatic void __kmp_stg_print_hot_teams_mode(kmp_str_buf_t *buffer,\n                                           char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_hot_teams_mode);\n} // __kmp_stg_print_hot_teams_mode\n\n#endif // KMP_NESTED_HOT_TEAMS\n\n// -----------------------------------------------------------------------------\n// KMP_HANDLE_SIGNALS\n\n#if KMP_HANDLE_SIGNALS\n\nstatic void __kmp_stg_parse_handle_signals(char const *name, char const *value,\n                                           void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_handle_signals);\n} // __kmp_stg_parse_handle_signals\n\nstatic void __kmp_stg_print_handle_signals(kmp_str_buf_t *buffer,\n                                           char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_handle_signals);\n} // __kmp_stg_print_handle_signals\n\n#endif // KMP_HANDLE_SIGNALS\n\n// -----------------------------------------------------------------------------\n// KMP_X_DEBUG, KMP_DEBUG, KMP_DEBUG_BUF_*, KMP_DIAG\n\n#ifdef KMP_DEBUG\n\n#define KMP_STG_X_DEBUG(x)                                                     \\\n  static void __kmp_stg_parse_##x##_debug(char const *name, char const *value, \\\n                                          void *data) {                        \\\n    __kmp_stg_parse_int(name, value, 0, INT_MAX, &kmp_##x##_debug);            \\\n  } /* __kmp_stg_parse_x_debug */                                              \\\n  static void __kmp_stg_print_##x##_debug(kmp_str_buf_t *buffer,               \\\n                                          char const *name, void *data) {      \\\n    __kmp_stg_print_int(buffer, name, kmp_##x##_debug);                        \\\n  } /* __kmp_stg_print_x_debug */\n\nKMP_STG_X_DEBUG(a)\nKMP_STG_X_DEBUG(b)\nKMP_STG_X_DEBUG(c)\nKMP_STG_X_DEBUG(d)\nKMP_STG_X_DEBUG(e)\nKMP_STG_X_DEBUG(f)\n\n#undef KMP_STG_X_DEBUG\n\nstatic void __kmp_stg_parse_debug(char const *name, char const *value,\n                                  void *data) {\n  int debug = 0;\n  __kmp_stg_parse_int(name, value, 0, INT_MAX, &debug);\n  if (kmp_a_debug < debug) {\n    kmp_a_debug = debug;\n  }\n  if (kmp_b_debug < debug) {\n    kmp_b_debug = debug;\n  }\n  if (kmp_c_debug < debug) {\n    kmp_c_debug = debug;\n  }\n  if (kmp_d_debug < debug) {\n    kmp_d_debug = debug;\n  }\n  if (kmp_e_debug < debug) {\n    kmp_e_debug = debug;\n  }\n  if (kmp_f_debug < debug) {\n    kmp_f_debug = debug;\n  }\n} // __kmp_stg_parse_debug\n\nstatic void __kmp_stg_parse_debug_buf(char const *name, char const *value,\n                                      void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_debug_buf);\n  // !!! TODO: Move buffer initialization of of this file! It may works\n  // incorrectly if KMP_DEBUG_BUF is parsed before KMP_DEBUG_BUF_LINES or\n  // KMP_DEBUG_BUF_CHARS.\n  if (__kmp_debug_buf) {\n    int i;\n    int elements = __kmp_debug_buf_lines * __kmp_debug_buf_chars;\n\n    /* allocate and initialize all entries in debug buffer to empty */\n    __kmp_debug_buffer = (char *)__kmp_page_allocate(elements * sizeof(char));\n    for (i = 0; i < elements; i += __kmp_debug_buf_chars)\n      __kmp_debug_buffer[i] = '\\0';\n\n    __kmp_debug_count = 0;\n  }\n  K_DIAG(1, (\"__kmp_debug_buf = %d\\n\", __kmp_debug_buf));\n} // __kmp_stg_parse_debug_buf\n\nstatic void __kmp_stg_print_debug_buf(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_debug_buf);\n} // __kmp_stg_print_debug_buf\n\nstatic void __kmp_stg_parse_debug_buf_atomic(char const *name,\n                                             char const *value, void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_debug_buf_atomic);\n} // __kmp_stg_parse_debug_buf_atomic\n\nstatic void __kmp_stg_print_debug_buf_atomic(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_debug_buf_atomic);\n} // __kmp_stg_print_debug_buf_atomic\n\nstatic void __kmp_stg_parse_debug_buf_chars(char const *name, char const *value,\n                                            void *data) {\n  __kmp_stg_parse_int(name, value, KMP_DEBUG_BUF_CHARS_MIN, INT_MAX,\n                      &__kmp_debug_buf_chars);\n} // __kmp_stg_debug_parse_buf_chars\n\nstatic void __kmp_stg_print_debug_buf_chars(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_debug_buf_chars);\n} // __kmp_stg_print_debug_buf_chars\n\nstatic void __kmp_stg_parse_debug_buf_lines(char const *name, char const *value,\n                                            void *data) {\n  __kmp_stg_parse_int(name, value, KMP_DEBUG_BUF_LINES_MIN, INT_MAX,\n                      &__kmp_debug_buf_lines);\n} // __kmp_stg_parse_debug_buf_lines\n\nstatic void __kmp_stg_print_debug_buf_lines(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_debug_buf_lines);\n} // __kmp_stg_print_debug_buf_lines\n\nstatic void __kmp_stg_parse_diag(char const *name, char const *value,\n                                 void *data) {\n  __kmp_stg_parse_int(name, value, 0, INT_MAX, &kmp_diag);\n} // __kmp_stg_parse_diag\n\nstatic void __kmp_stg_print_diag(kmp_str_buf_t *buffer, char const *name,\n                                 void *data) {\n  __kmp_stg_print_int(buffer, name, kmp_diag);\n} // __kmp_stg_print_diag\n\n#endif // KMP_DEBUG\n\n// -----------------------------------------------------------------------------\n// KMP_ALIGN_ALLOC\n\nstatic void __kmp_stg_parse_align_alloc(char const *name, char const *value,\n                                        void *data) {\n  __kmp_stg_parse_size(name, value, CACHE_LINE, INT_MAX, NULL,\n                       &__kmp_align_alloc, 1);\n} // __kmp_stg_parse_align_alloc\n\nstatic void __kmp_stg_print_align_alloc(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  __kmp_stg_print_size(buffer, name, __kmp_align_alloc);\n} // __kmp_stg_print_align_alloc\n\n// -----------------------------------------------------------------------------\n// KMP_PLAIN_BARRIER, KMP_FORKJOIN_BARRIER, KMP_REDUCTION_BARRIER\n\n// TODO: Remove __kmp_barrier_branch_bit_env_name varibale, remove loops from\n// parse and print functions, pass required info through data argument.\n\nstatic void __kmp_stg_parse_barrier_branch_bit(char const *name,\n                                               char const *value, void *data) {\n  const char *var;\n\n  /* ---------- Barrier branch bit control ------------ */\n  for (int i = bs_plain_barrier; i < bs_last_barrier; i++) {\n    var = __kmp_barrier_branch_bit_env_name[i];\n    if ((strcmp(var, name) == 0) && (value != 0)) {\n      char *comma;\n\n      comma = CCAST(char *, strchr(value, ','));\n      __kmp_barrier_gather_branch_bits[i] =\n          (kmp_uint32)__kmp_str_to_int(value, ',');\n      /* is there a specified release parameter? */\n      if (comma == NULL) {\n        __kmp_barrier_release_branch_bits[i] = __kmp_barrier_release_bb_dflt;\n      } else {\n        __kmp_barrier_release_branch_bits[i] =\n            (kmp_uint32)__kmp_str_to_int(comma + 1, 0);\n\n        if (__kmp_barrier_release_branch_bits[i] > KMP_MAX_BRANCH_BITS) {\n          __kmp_msg(kmp_ms_warning,\n                    KMP_MSG(BarrReleaseValueInvalid, name, comma + 1),\n                    __kmp_msg_null);\n          __kmp_barrier_release_branch_bits[i] = __kmp_barrier_release_bb_dflt;\n        }\n      }\n      if (__kmp_barrier_gather_branch_bits[i] > KMP_MAX_BRANCH_BITS) {\n        KMP_WARNING(BarrGatherValueInvalid, name, value);\n        KMP_INFORM(Using_uint_Value, name, __kmp_barrier_gather_bb_dflt);\n        __kmp_barrier_gather_branch_bits[i] = __kmp_barrier_gather_bb_dflt;\n      }\n    }\n    K_DIAG(1, (\"%s == %d,%d\\n\", __kmp_barrier_branch_bit_env_name[i],\n               __kmp_barrier_gather_branch_bits[i],\n               __kmp_barrier_release_branch_bits[i]))\n  }\n} // __kmp_stg_parse_barrier_branch_bit\n\nstatic void __kmp_stg_print_barrier_branch_bit(kmp_str_buf_t *buffer,\n                                               char const *name, void *data) {\n  const char *var;\n  for (int i = bs_plain_barrier; i < bs_last_barrier; i++) {\n    var = __kmp_barrier_branch_bit_env_name[i];\n    if (strcmp(var, name) == 0) {\n      if (__kmp_env_format) {\n        KMP_STR_BUF_PRINT_NAME_EX(__kmp_barrier_branch_bit_env_name[i]);\n      } else {\n        __kmp_str_buf_print(buffer, \"   %s='\",\n                            __kmp_barrier_branch_bit_env_name[i]);\n      }\n      __kmp_str_buf_print(buffer, \"%d,%d'\\n\",\n                          __kmp_barrier_gather_branch_bits[i],\n                          __kmp_barrier_release_branch_bits[i]);\n    }\n  }\n} // __kmp_stg_print_barrier_branch_bit\n\n// ----------------------------------------------------------------------------\n// KMP_PLAIN_BARRIER_PATTERN, KMP_FORKJOIN_BARRIER_PATTERN,\n// KMP_REDUCTION_BARRIER_PATTERN\n\n// TODO: Remove __kmp_barrier_pattern_name variable, remove loops from parse and\n// print functions, pass required data to functions through data argument.\n\nstatic void __kmp_stg_parse_barrier_pattern(char const *name, char const *value,\n                                            void *data) {\n  const char *var;\n  /* ---------- Barrier method control ------------ */\n\n  for (int i = bs_plain_barrier; i < bs_last_barrier; i++) {\n    var = __kmp_barrier_pattern_env_name[i];\n\n    if ((strcmp(var, name) == 0) && (value != 0)) {\n      int j;\n      char *comma = CCAST(char *, strchr(value, ','));\n\n      /* handle first parameter: gather pattern */\n      for (j = bp_linear_bar; j < bp_last_bar; j++) {\n        if (__kmp_match_with_sentinel(__kmp_barrier_pattern_name[j], value, 1,\n                                      ',')) {\n          __kmp_barrier_gather_pattern[i] = (kmp_bar_pat_e)j;\n          break;\n        }\n      }\n      if (j == bp_last_bar) {\n        KMP_WARNING(BarrGatherValueInvalid, name, value);\n        KMP_INFORM(Using_str_Value, name,\n                   __kmp_barrier_pattern_name[bp_linear_bar]);\n      }\n\n      /* handle second parameter: release pattern */\n      if (comma != NULL) {\n        for (j = bp_linear_bar; j < bp_last_bar; j++) {\n          if (__kmp_str_match(__kmp_barrier_pattern_name[j], 1, comma + 1)) {\n            __kmp_barrier_release_pattern[i] = (kmp_bar_pat_e)j;\n            break;\n          }\n        }\n        if (j == bp_last_bar) {\n          __kmp_msg(kmp_ms_warning,\n                    KMP_MSG(BarrReleaseValueInvalid, name, comma + 1),\n                    __kmp_msg_null);\n          KMP_INFORM(Using_str_Value, name,\n                     __kmp_barrier_pattern_name[bp_linear_bar]);\n        }\n      }\n    }\n  }\n} // __kmp_stg_parse_barrier_pattern\n\nstatic void __kmp_stg_print_barrier_pattern(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  const char *var;\n  for (int i = bs_plain_barrier; i < bs_last_barrier; i++) {\n    var = __kmp_barrier_pattern_env_name[i];\n    if (strcmp(var, name) == 0) {\n      int j = __kmp_barrier_gather_pattern[i];\n      int k = __kmp_barrier_release_pattern[i];\n      if (__kmp_env_format) {\n        KMP_STR_BUF_PRINT_NAME_EX(__kmp_barrier_pattern_env_name[i]);\n      } else {\n        __kmp_str_buf_print(buffer, \"   %s='\",\n                            __kmp_barrier_pattern_env_name[i]);\n      }\n      __kmp_str_buf_print(buffer, \"%s,%s'\\n\", __kmp_barrier_pattern_name[j],\n                          __kmp_barrier_pattern_name[k]);\n    }\n  }\n} // __kmp_stg_print_barrier_pattern\n\n// -----------------------------------------------------------------------------\n// KMP_ABORT_DELAY\n\nstatic void __kmp_stg_parse_abort_delay(char const *name, char const *value,\n                                        void *data) {\n  // Units of KMP_DELAY_ABORT are seconds, units of __kmp_abort_delay is\n  // milliseconds.\n  int delay = __kmp_abort_delay / 1000;\n  __kmp_stg_parse_int(name, value, 0, INT_MAX / 1000, &delay);\n  __kmp_abort_delay = delay * 1000;\n} // __kmp_stg_parse_abort_delay\n\nstatic void __kmp_stg_print_abort_delay(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_abort_delay);\n} // __kmp_stg_print_abort_delay\n\n// -----------------------------------------------------------------------------\n// KMP_CPUINFO_FILE\n\nstatic void __kmp_stg_parse_cpuinfo_file(char const *name, char const *value,\n                                         void *data) {\n#if KMP_AFFINITY_SUPPORTED\n  __kmp_stg_parse_str(name, value, &__kmp_cpuinfo_file);\n  K_DIAG(1, (\"__kmp_cpuinfo_file == %s\\n\", __kmp_cpuinfo_file));\n#endif\n} //__kmp_stg_parse_cpuinfo_file\n\nstatic void __kmp_stg_print_cpuinfo_file(kmp_str_buf_t *buffer,\n                                         char const *name, void *data) {\n#if KMP_AFFINITY_SUPPORTED\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  if (__kmp_cpuinfo_file) {\n    __kmp_str_buf_print(buffer, \"='%s'\\n\", __kmp_cpuinfo_file);\n  } else {\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  }\n#endif\n} //__kmp_stg_print_cpuinfo_file\n\n// -----------------------------------------------------------------------------\n// KMP_FORCE_REDUCTION, KMP_DETERMINISTIC_REDUCTION\n\nstatic void __kmp_stg_parse_force_reduction(char const *name, char const *value,\n                                            void *data) {\n  kmp_stg_fr_data_t *reduction = (kmp_stg_fr_data_t *)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, reduction->rivals);\n  if (rc) {\n    return;\n  }\n  if (reduction->force) {\n    if (value != 0) {\n      if (__kmp_str_match(\"critical\", 0, value))\n        __kmp_force_reduction_method = critical_reduce_block;\n      else if (__kmp_str_match(\"atomic\", 0, value))\n        __kmp_force_reduction_method = atomic_reduce_block;\n      else if (__kmp_str_match(\"tree\", 0, value))\n        __kmp_force_reduction_method = tree_reduce_block;\n      else {\n        KMP_FATAL(UnknownForceReduction, name, value);\n      }\n    }\n  } else {\n    __kmp_stg_parse_bool(name, value, &__kmp_determ_red);\n    if (__kmp_determ_red) {\n      __kmp_force_reduction_method = tree_reduce_block;\n    } else {\n      __kmp_force_reduction_method = reduction_method_not_defined;\n    }\n  }\n  K_DIAG(1, (\"__kmp_force_reduction_method == %d\\n\",\n             __kmp_force_reduction_method));\n} // __kmp_stg_parse_force_reduction\n\nstatic void __kmp_stg_print_force_reduction(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n\n  kmp_stg_fr_data_t *reduction = (kmp_stg_fr_data_t *)data;\n  if (reduction->force) {\n    if (__kmp_force_reduction_method == critical_reduce_block) {\n      __kmp_stg_print_str(buffer, name, \"critical\");\n    } else if (__kmp_force_reduction_method == atomic_reduce_block) {\n      __kmp_stg_print_str(buffer, name, \"atomic\");\n    } else if (__kmp_force_reduction_method == tree_reduce_block) {\n      __kmp_stg_print_str(buffer, name, \"tree\");\n    } else {\n      if (__kmp_env_format) {\n        KMP_STR_BUF_PRINT_NAME;\n      } else {\n        __kmp_str_buf_print(buffer, \"   %s\", name);\n      }\n      __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n    }\n  } else {\n    __kmp_stg_print_bool(buffer, name, __kmp_determ_red);\n  }\n\n} // __kmp_stg_print_force_reduction\n\n// -----------------------------------------------------------------------------\n// KMP_STORAGE_MAP\n\nstatic void __kmp_stg_parse_storage_map(char const *name, char const *value,\n                                        void *data) {\n  if (__kmp_str_match(\"verbose\", 1, value)) {\n    __kmp_storage_map = TRUE;\n    __kmp_storage_map_verbose = TRUE;\n    __kmp_storage_map_verbose_specified = TRUE;\n\n  } else {\n    __kmp_storage_map_verbose = FALSE;\n    __kmp_stg_parse_bool(name, value, &__kmp_storage_map); // !!!\n  }\n} // __kmp_stg_parse_storage_map\n\nstatic void __kmp_stg_print_storage_map(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  if (__kmp_storage_map_verbose || __kmp_storage_map_verbose_specified) {\n    __kmp_stg_print_str(buffer, name, \"verbose\");\n  } else {\n    __kmp_stg_print_bool(buffer, name, __kmp_storage_map);\n  }\n} // __kmp_stg_print_storage_map\n\n// -----------------------------------------------------------------------------\n// KMP_ALL_THREADPRIVATE\n\nstatic void __kmp_stg_parse_all_threadprivate(char const *name,\n                                              char const *value, void *data) {\n  __kmp_stg_parse_int(name, value,\n                      __kmp_allThreadsSpecified ? __kmp_max_nth : 1,\n                      __kmp_max_nth, &__kmp_tp_capacity);\n} // __kmp_stg_parse_all_threadprivate\n\nstatic void __kmp_stg_print_all_threadprivate(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_tp_capacity);\n}\n\n// -----------------------------------------------------------------------------\n// KMP_FOREIGN_THREADS_THREADPRIVATE\n\nstatic void __kmp_stg_parse_foreign_threads_threadprivate(char const *name,\n                                                          char const *value,\n                                                          void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_foreign_tp);\n} // __kmp_stg_parse_foreign_threads_threadprivate\n\nstatic void __kmp_stg_print_foreign_threads_threadprivate(kmp_str_buf_t *buffer,\n                                                          char const *name,\n                                                          void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_foreign_tp);\n} // __kmp_stg_print_foreign_threads_threadprivate\n\n// -----------------------------------------------------------------------------\n// KMP_AFFINITY, GOMP_CPU_AFFINITY, KMP_TOPOLOGY_METHOD\n\n#if KMP_AFFINITY_SUPPORTED\n// Parse the proc id list.  Return TRUE if successful, FALSE otherwise.\nstatic int __kmp_parse_affinity_proc_id_list(const char *var, const char *env,\n                                             const char **nextEnv,\n                                             char **proclist) {\n  const char *scan = env;\n  const char *next = scan;\n  int empty = TRUE;\n\n  *proclist = NULL;\n\n  for (;;) {\n    int start, end, stride;\n\n    SKIP_WS(scan);\n    next = scan;\n    if (*next == '\\0') {\n      break;\n    }\n\n    if (*next == '{') {\n      int num;\n      next++; // skip '{'\n      SKIP_WS(next);\n      scan = next;\n\n      // Read the first integer in the set.\n      if ((*next < '0') || (*next > '9')) {\n        KMP_WARNING(AffSyntaxError, var);\n        return FALSE;\n      }\n      SKIP_DIGITS(next);\n      num = __kmp_str_to_int(scan, *next);\n      KMP_ASSERT(num >= 0);\n\n      for (;;) {\n        // Check for end of set.\n        SKIP_WS(next);\n        if (*next == '}') {\n          next++; // skip '}'\n          break;\n        }\n\n        // Skip optional comma.\n        if (*next == ',') {\n          next++;\n        }\n        SKIP_WS(next);\n\n        // Read the next integer in the set.\n        scan = next;\n        if ((*next < '0') || (*next > '9')) {\n          KMP_WARNING(AffSyntaxError, var);\n          return FALSE;\n        }\n\n        SKIP_DIGITS(next);\n        num = __kmp_str_to_int(scan, *next);\n        KMP_ASSERT(num >= 0);\n      }\n      empty = FALSE;\n\n      SKIP_WS(next);\n      if (*next == ',') {\n        next++;\n      }\n      scan = next;\n      continue;\n    }\n\n    // Next character is not an integer => end of list\n    if ((*next < '0') || (*next > '9')) {\n      if (empty) {\n        KMP_WARNING(AffSyntaxError, var);\n        return FALSE;\n      }\n      break;\n    }\n\n    // Read the first integer.\n    SKIP_DIGITS(next);\n    start = __kmp_str_to_int(scan, *next);\n    KMP_ASSERT(start >= 0);\n    SKIP_WS(next);\n\n    // If this isn't a range, then go on.\n    if (*next != '-') {\n      empty = FALSE;\n\n      // Skip optional comma.\n      if (*next == ',') {\n        next++;\n      }\n      scan = next;\n      continue;\n    }\n\n    // This is a range.  Skip over the '-' and read in the 2nd int.\n    next++; // skip '-'\n    SKIP_WS(next);\n    scan = next;\n    if ((*next < '0') || (*next > '9')) {\n      KMP_WARNING(AffSyntaxError, var);\n      return FALSE;\n    }\n    SKIP_DIGITS(next);\n    end = __kmp_str_to_int(scan, *next);\n    KMP_ASSERT(end >= 0);\n\n    // Check for a stride parameter\n    stride = 1;\n    SKIP_WS(next);\n    if (*next == ':') {\n      // A stride is specified.  Skip over the ':\" and read the 3rd int.\n      int sign = +1;\n      next++; // skip ':'\n      SKIP_WS(next);\n      scan = next;\n      if (*next == '-') {\n        sign = -1;\n        next++;\n        SKIP_WS(next);\n        scan = next;\n      }\n      if ((*next < '0') || (*next > '9')) {\n        KMP_WARNING(AffSyntaxError, var);\n        return FALSE;\n      }\n      SKIP_DIGITS(next);\n      stride = __kmp_str_to_int(scan, *next);\n      KMP_ASSERT(stride >= 0);\n      stride *= sign;\n    }\n\n    // Do some range checks.\n    if (stride == 0) {\n      KMP_WARNING(AffZeroStride, var);\n      return FALSE;\n    }\n    if (stride > 0) {\n      if (start > end) {\n        KMP_WARNING(AffStartGreaterEnd, var, start, end);\n        return FALSE;\n      }\n    } else {\n      if (start < end) {\n        KMP_WARNING(AffStrideLessZero, var, start, end);\n        return FALSE;\n      }\n    }\n    if ((end - start) / stride > 65536) {\n      KMP_WARNING(AffRangeTooBig, var, end, start, stride);\n      return FALSE;\n    }\n\n    empty = FALSE;\n\n    // Skip optional comma.\n    SKIP_WS(next);\n    if (*next == ',') {\n      next++;\n    }\n    scan = next;\n  }\n\n  *nextEnv = next;\n\n  {\n    ptrdiff_t len = next - env;\n    char *retlist = (char *)__kmp_allocate((len + 1) * sizeof(char));\n    KMP_MEMCPY_S(retlist, (len + 1) * sizeof(char), env, len * sizeof(char));\n    retlist[len] = '\\0';\n    *proclist = retlist;\n  }\n  return TRUE;\n}\n\n// If KMP_AFFINITY is specified without a type, then\n// __kmp_affinity_notype should point to its setting.\nstatic kmp_setting_t *__kmp_affinity_notype = NULL;\n\nstatic void __kmp_parse_affinity_env(char const *name, char const *value,\n                                     enum affinity_type *out_type,\n                                     char **out_proclist, int *out_verbose,\n                                     int *out_warn, int *out_respect,\n                                     enum affinity_gran *out_gran,\n                                     int *out_gran_levels, int *out_dups,\n                                     int *out_compact, int *out_offset) {\n  char *buffer = NULL; // Copy of env var value.\n  char *buf = NULL; // Buffer for strtok_r() function.\n  char *next = NULL; // end of token / start of next.\n  const char *start; // start of current token (for err msgs)\n  int count = 0; // Counter of parsed integer numbers.\n  int number[2]; // Parsed numbers.\n\n  // Guards.\n  int type = 0;\n  int proclist = 0;\n  int verbose = 0;\n  int warnings = 0;\n  int respect = 0;\n  int gran = 0;\n  int dups = 0;\n\n  KMP_ASSERT(value != NULL);\n\n  if (TCR_4(__kmp_init_middle)) {\n    KMP_WARNING(EnvMiddleWarn, name);\n    __kmp_env_toPrint(name, 0);\n    return;\n  }\n  __kmp_env_toPrint(name, 1);\n\n  buffer =\n      __kmp_str_format(\"%s\", value); // Copy env var to keep original intact.\n  buf = buffer;\n  SKIP_WS(buf);\n\n// Helper macros.\n\n// If we see a parse error, emit a warning and scan to the next \",\".\n//\n// FIXME - there's got to be a better way to print an error\n// message, hopefully without overwriting peices of buf.\n#define EMIT_WARN(skip, errlist)                                               \\\n  {                                                                            \\\n    char ch;                                                                   \\\n    if (skip) {                                                                \\\n      SKIP_TO(next, ',');                                                      \\\n    }                                                                          \\\n    ch = *next;                                                                \\\n    *next = '\\0';                                                              \\\n    KMP_WARNING errlist;                                                       \\\n    *next = ch;                                                                \\\n    if (skip) {                                                                \\\n      if (ch == ',')                                                           \\\n        next++;                                                                \\\n    }                                                                          \\\n    buf = next;                                                                \\\n  }\n\n#define _set_param(_guard, _var, _val)                                         \\\n  {                                                                            \\\n    if (_guard == 0) {                                                         \\\n      _var = _val;                                                             \\\n    } else {                                                                   \\\n      EMIT_WARN(FALSE, (AffParamDefined, name, start));                        \\\n    }                                                                          \\\n    ++_guard;                                                                  \\\n  }\n\n#define set_type(val) _set_param(type, *out_type, val)\n#define set_verbose(val) _set_param(verbose, *out_verbose, val)\n#define set_warnings(val) _set_param(warnings, *out_warn, val)\n#define set_respect(val) _set_param(respect, *out_respect, val)\n#define set_dups(val) _set_param(dups, *out_dups, val)\n#define set_proclist(val) _set_param(proclist, *out_proclist, val)\n\n#define set_gran(val, levels)                                                  \\\n  {                                                                            \\\n    if (gran == 0) {                                                           \\\n      *out_gran = val;                                                         \\\n      *out_gran_levels = levels;                                               \\\n    } else {                                                                   \\\n      EMIT_WARN(FALSE, (AffParamDefined, name, start));                        \\\n    }                                                                          \\\n    ++gran;                                                                    \\\n  }\n\n  KMP_DEBUG_ASSERT((__kmp_nested_proc_bind.bind_types != NULL) &&\n                   (__kmp_nested_proc_bind.used > 0));\n\n  while (*buf != '\\0') {\n    start = next = buf;\n\n    if (__kmp_match_str(\"none\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_none);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n      buf = next;\n    } else if (__kmp_match_str(\"scatter\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_scatter);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n      buf = next;\n    } else if (__kmp_match_str(\"compact\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_compact);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n      buf = next;\n    } else if (__kmp_match_str(\"logical\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_logical);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n      buf = next;\n    } else if (__kmp_match_str(\"physical\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_physical);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n      buf = next;\n    } else if (__kmp_match_str(\"explicit\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_explicit);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n      buf = next;\n    } else if (__kmp_match_str(\"balanced\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_balanced);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n      buf = next;\n    } else if (__kmp_match_str(\"disabled\", buf, CCAST(const char **, &next))) {\n      set_type(affinity_disabled);\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n      buf = next;\n    } else if (__kmp_match_str(\"verbose\", buf, CCAST(const char **, &next))) {\n      set_verbose(TRUE);\n      buf = next;\n    } else if (__kmp_match_str(\"noverbose\", buf, CCAST(const char **, &next))) {\n      set_verbose(FALSE);\n      buf = next;\n    } else if (__kmp_match_str(\"warnings\", buf, CCAST(const char **, &next))) {\n      set_warnings(TRUE);\n      buf = next;\n    } else if (__kmp_match_str(\"nowarnings\", buf,\n                               CCAST(const char **, &next))) {\n      set_warnings(FALSE);\n      buf = next;\n    } else if (__kmp_match_str(\"respect\", buf, CCAST(const char **, &next))) {\n      set_respect(TRUE);\n      buf = next;\n    } else if (__kmp_match_str(\"norespect\", buf, CCAST(const char **, &next))) {\n      set_respect(FALSE);\n      buf = next;\n    } else if (__kmp_match_str(\"duplicates\", buf,\n                               CCAST(const char **, &next)) ||\n               __kmp_match_str(\"dups\", buf, CCAST(const char **, &next))) {\n      set_dups(TRUE);\n      buf = next;\n    } else if (__kmp_match_str(\"noduplicates\", buf,\n                               CCAST(const char **, &next)) ||\n               __kmp_match_str(\"nodups\", buf, CCAST(const char **, &next))) {\n      set_dups(FALSE);\n      buf = next;\n    } else if (__kmp_match_str(\"granularity\", buf,\n                               CCAST(const char **, &next)) ||\n               __kmp_match_str(\"gran\", buf, CCAST(const char **, &next))) {\n      SKIP_WS(next);\n      if (*next != '=') {\n        EMIT_WARN(TRUE, (AffInvalidParam, name, start));\n        continue;\n      }\n      next++; // skip '='\n      SKIP_WS(next);\n\n      buf = next;\n      if (__kmp_match_str(\"fine\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_fine, -1);\n        buf = next;\n      } else if (__kmp_match_str(\"thread\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_thread, -1);\n        buf = next;\n      } else if (__kmp_match_str(\"core\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_core, -1);\n        buf = next;\n#if KMP_USE_HWLOC\n      } else if (__kmp_match_str(\"tile\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_tile, -1);\n        buf = next;\n#endif\n      } else if (__kmp_match_str(\"die\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_die, -1);\n        buf = next;\n      } else if (__kmp_match_str(\"package\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_package, -1);\n        buf = next;\n      } else if (__kmp_match_str(\"node\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_node, -1);\n        buf = next;\n#if KMP_GROUP_AFFINITY\n      } else if (__kmp_match_str(\"group\", buf, CCAST(const char **, &next))) {\n        set_gran(affinity_gran_group, -1);\n        buf = next;\n#endif /* KMP_GROUP AFFINITY */\n      } else if ((*buf >= '0') && (*buf <= '9')) {\n        int n;\n        next = buf;\n        SKIP_DIGITS(next);\n        n = __kmp_str_to_int(buf, *next);\n        KMP_ASSERT(n >= 0);\n        buf = next;\n        set_gran(affinity_gran_default, n);\n      } else {\n        EMIT_WARN(TRUE, (AffInvalidParam, name, start));\n        continue;\n      }\n    } else if (__kmp_match_str(\"proclist\", buf, CCAST(const char **, &next))) {\n      char *temp_proclist;\n\n      SKIP_WS(next);\n      if (*next != '=') {\n        EMIT_WARN(TRUE, (AffInvalidParam, name, start));\n        continue;\n      }\n      next++; // skip '='\n      SKIP_WS(next);\n      if (*next != '[') {\n        EMIT_WARN(TRUE, (AffInvalidParam, name, start));\n        continue;\n      }\n      next++; // skip '['\n      buf = next;\n      if (!__kmp_parse_affinity_proc_id_list(\n              name, buf, CCAST(const char **, &next), &temp_proclist)) {\n        // warning already emitted.\n        SKIP_TO(next, ']');\n        if (*next == ']')\n          next++;\n        SKIP_TO(next, ',');\n        if (*next == ',')\n          next++;\n        buf = next;\n        continue;\n      }\n      if (*next != ']') {\n        EMIT_WARN(TRUE, (AffInvalidParam, name, start));\n        continue;\n      }\n      next++; // skip ']'\n      set_proclist(temp_proclist);\n    } else if ((*buf >= '0') && (*buf <= '9')) {\n      // Parse integer numbers -- permute and offset.\n      int n;\n      next = buf;\n      SKIP_DIGITS(next);\n      n = __kmp_str_to_int(buf, *next);\n      KMP_ASSERT(n >= 0);\n      buf = next;\n      if (count < 2) {\n        number[count] = n;\n      } else {\n        KMP_WARNING(AffManyParams, name, start);\n      }\n      ++count;\n    } else {\n      EMIT_WARN(TRUE, (AffInvalidParam, name, start));\n      continue;\n    }\n\n    SKIP_WS(next);\n    if (*next == ',') {\n      next++;\n      SKIP_WS(next);\n    } else if (*next != '\\0') {\n      const char *temp = next;\n      EMIT_WARN(TRUE, (ParseExtraCharsWarn, name, temp));\n      continue;\n    }\n    buf = next;\n  } // while\n\n#undef EMIT_WARN\n#undef _set_param\n#undef set_type\n#undef set_verbose\n#undef set_warnings\n#undef set_respect\n#undef set_granularity\n\n  __kmp_str_free(&buffer);\n\n  if (proclist) {\n    if (!type) {\n      KMP_WARNING(AffProcListNoType, name);\n      *out_type = affinity_explicit;\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n    } else if (*out_type != affinity_explicit) {\n      KMP_WARNING(AffProcListNotExplicit, name);\n      KMP_ASSERT(*out_proclist != NULL);\n      KMP_INTERNAL_FREE(*out_proclist);\n      *out_proclist = NULL;\n    }\n  }\n  switch (*out_type) {\n  case affinity_logical:\n  case affinity_physical: {\n    if (count > 0) {\n      *out_offset = number[0];\n    }\n    if (count > 1) {\n      KMP_WARNING(AffManyParamsForLogic, name, number[1]);\n    }\n  } break;\n  case affinity_balanced: {\n    if (count > 0) {\n      *out_compact = number[0];\n    }\n    if (count > 1) {\n      *out_offset = number[1];\n    }\n\n    if (__kmp_affinity_gran == affinity_gran_default) {\n#if KMP_MIC_SUPPORTED\n      if (__kmp_mic_type != non_mic) {\n        if (__kmp_affinity_verbose || __kmp_affinity_warnings) {\n          KMP_WARNING(AffGranUsing, \"KMP_AFFINITY\", \"fine\");\n        }\n        __kmp_affinity_gran = affinity_gran_fine;\n      } else\n#endif\n      {\n        if (__kmp_affinity_verbose || __kmp_affinity_warnings) {\n          KMP_WARNING(AffGranUsing, \"KMP_AFFINITY\", \"core\");\n        }\n        __kmp_affinity_gran = affinity_gran_core;\n      }\n    }\n  } break;\n  case affinity_scatter:\n  case affinity_compact: {\n    if (count > 0) {\n      *out_compact = number[0];\n    }\n    if (count > 1) {\n      *out_offset = number[1];\n    }\n  } break;\n  case affinity_explicit: {\n    if (*out_proclist == NULL) {\n      KMP_WARNING(AffNoProcList, name);\n      __kmp_affinity_type = affinity_none;\n    }\n    if (count > 0) {\n      KMP_WARNING(AffNoParam, name, \"explicit\");\n    }\n  } break;\n  case affinity_none: {\n    if (count > 0) {\n      KMP_WARNING(AffNoParam, name, \"none\");\n    }\n  } break;\n  case affinity_disabled: {\n    if (count > 0) {\n      KMP_WARNING(AffNoParam, name, \"disabled\");\n    }\n  } break;\n  case affinity_default: {\n    if (count > 0) {\n      KMP_WARNING(AffNoParam, name, \"default\");\n    }\n  } break;\n  default: {\n    KMP_ASSERT(0);\n  }\n  }\n} // __kmp_parse_affinity_env\n\nstatic void __kmp_stg_parse_affinity(char const *name, char const *value,\n                                     void *data) {\n  kmp_setting_t **rivals = (kmp_setting_t **)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, rivals);\n  if (rc) {\n    return;\n  }\n\n  __kmp_parse_affinity_env(name, value, &__kmp_affinity_type,\n                           &__kmp_affinity_proclist, &__kmp_affinity_verbose,\n                           &__kmp_affinity_warnings,\n                           &__kmp_affinity_respect_mask, &__kmp_affinity_gran,\n                           &__kmp_affinity_gran_levels, &__kmp_affinity_dups,\n                           &__kmp_affinity_compact, &__kmp_affinity_offset);\n\n} // __kmp_stg_parse_affinity\n\nstatic void __kmp_stg_print_affinity(kmp_str_buf_t *buffer, char const *name,\n                                     void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s='\", name);\n  }\n  if (__kmp_affinity_verbose) {\n    __kmp_str_buf_print(buffer, \"%s,\", \"verbose\");\n  } else {\n    __kmp_str_buf_print(buffer, \"%s,\", \"noverbose\");\n  }\n  if (__kmp_affinity_warnings) {\n    __kmp_str_buf_print(buffer, \"%s,\", \"warnings\");\n  } else {\n    __kmp_str_buf_print(buffer, \"%s,\", \"nowarnings\");\n  }\n  if (KMP_AFFINITY_CAPABLE()) {\n    if (__kmp_affinity_respect_mask) {\n      __kmp_str_buf_print(buffer, \"%s,\", \"respect\");\n    } else {\n      __kmp_str_buf_print(buffer, \"%s,\", \"norespect\");\n    }\n    switch (__kmp_affinity_gran) {\n    case affinity_gran_default:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=default,\");\n      break;\n    case affinity_gran_fine:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=fine,\");\n      break;\n    case affinity_gran_thread:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=thread,\");\n      break;\n    case affinity_gran_core:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=core,\");\n      break;\n    case affinity_gran_package:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=package,\");\n      break;\n    case affinity_gran_node:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=node,\");\n      break;\n#if KMP_GROUP_AFFINITY\n    case affinity_gran_group:\n      __kmp_str_buf_print(buffer, \"%s\", \"granularity=group,\");\n      break;\n#endif /* KMP_GROUP_AFFINITY */\n    }\n  }\n  if (!KMP_AFFINITY_CAPABLE()) {\n    __kmp_str_buf_print(buffer, \"%s\", \"disabled\");\n  } else\n    switch (__kmp_affinity_type) {\n    case affinity_none:\n      __kmp_str_buf_print(buffer, \"%s\", \"none\");\n      break;\n    case affinity_physical:\n      __kmp_str_buf_print(buffer, \"%s,%d\", \"physical\", __kmp_affinity_offset);\n      break;\n    case affinity_logical:\n      __kmp_str_buf_print(buffer, \"%s,%d\", \"logical\", __kmp_affinity_offset);\n      break;\n    case affinity_compact:\n      __kmp_str_buf_print(buffer, \"%s,%d,%d\", \"compact\", __kmp_affinity_compact,\n                          __kmp_affinity_offset);\n      break;\n    case affinity_scatter:\n      __kmp_str_buf_print(buffer, \"%s,%d,%d\", \"scatter\", __kmp_affinity_compact,\n                          __kmp_affinity_offset);\n      break;\n    case affinity_explicit:\n      __kmp_str_buf_print(buffer, \"%s=[%s],%s\", \"proclist\",\n                          __kmp_affinity_proclist, \"explicit\");\n      break;\n    case affinity_balanced:\n      __kmp_str_buf_print(buffer, \"%s,%d,%d\", \"balanced\",\n                          __kmp_affinity_compact, __kmp_affinity_offset);\n      break;\n    case affinity_disabled:\n      __kmp_str_buf_print(buffer, \"%s\", \"disabled\");\n      break;\n    case affinity_default:\n      __kmp_str_buf_print(buffer, \"%s\", \"default\");\n      break;\n    default:\n      __kmp_str_buf_print(buffer, \"%s\", \"<unknown>\");\n      break;\n    }\n  __kmp_str_buf_print(buffer, \"'\\n\");\n} //__kmp_stg_print_affinity\n\n#ifdef KMP_GOMP_COMPAT\n\nstatic void __kmp_stg_parse_gomp_cpu_affinity(char const *name,\n                                              char const *value, void *data) {\n  const char *next = NULL;\n  char *temp_proclist;\n  kmp_setting_t **rivals = (kmp_setting_t **)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, rivals);\n  if (rc) {\n    return;\n  }\n\n  if (TCR_4(__kmp_init_middle)) {\n    KMP_WARNING(EnvMiddleWarn, name);\n    __kmp_env_toPrint(name, 0);\n    return;\n  }\n\n  __kmp_env_toPrint(name, 1);\n\n  if (__kmp_parse_affinity_proc_id_list(name, value, &next, &temp_proclist)) {\n    SKIP_WS(next);\n    if (*next == '\\0') {\n      // GOMP_CPU_AFFINITY => granularity=fine,explicit,proclist=...\n      __kmp_affinity_proclist = temp_proclist;\n      __kmp_affinity_type = affinity_explicit;\n      __kmp_affinity_gran = affinity_gran_fine;\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n    } else {\n      KMP_WARNING(AffSyntaxError, name);\n      if (temp_proclist != NULL) {\n        KMP_INTERNAL_FREE((void *)temp_proclist);\n      }\n    }\n  } else {\n    // Warning already emitted\n    __kmp_affinity_type = affinity_none;\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n  }\n} // __kmp_stg_parse_gomp_cpu_affinity\n\n#endif /* KMP_GOMP_COMPAT */\n\n/*-----------------------------------------------------------------------------\nThe OMP_PLACES proc id list parser. Here is the grammar:\n\nplace_list := place\nplace_list := place , place_list\nplace := num\nplace := place : num\nplace := place : num : signed\nplace := { subplacelist }\nplace := ! place                  // (lowest priority)\nsubplace_list := subplace\nsubplace_list := subplace , subplace_list\nsubplace := num\nsubplace := num : num\nsubplace := num : num : signed\nsigned := num\nsigned := + signed\nsigned := - signed\n-----------------------------------------------------------------------------*/\n\n// Warning to issue for syntax error during parsing of OMP_PLACES\nstatic inline void __kmp_omp_places_syntax_warn(const char *var) {\n  KMP_WARNING(SyntaxErrorUsing, var, \"\\\"cores\\\"\");\n}\n\nstatic int __kmp_parse_subplace_list(const char *var, const char **scan) {\n  const char *next;\n\n  for (;;) {\n    int start, count, stride;\n\n    //\n    // Read in the starting proc id\n    //\n    SKIP_WS(*scan);\n    if ((**scan < '0') || (**scan > '9')) {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    next = *scan;\n    SKIP_DIGITS(next);\n    start = __kmp_str_to_int(*scan, *next);\n    KMP_ASSERT(start >= 0);\n    *scan = next;\n\n    // valid follow sets are ',' ':' and '}'\n    SKIP_WS(*scan);\n    if (**scan == '}') {\n      break;\n    }\n    if (**scan == ',') {\n      (*scan)++; // skip ','\n      continue;\n    }\n    if (**scan != ':') {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    (*scan)++; // skip ':'\n\n    // Read count parameter\n    SKIP_WS(*scan);\n    if ((**scan < '0') || (**scan > '9')) {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    next = *scan;\n    SKIP_DIGITS(next);\n    count = __kmp_str_to_int(*scan, *next);\n    KMP_ASSERT(count >= 0);\n    *scan = next;\n\n    // valid follow sets are ',' ':' and '}'\n    SKIP_WS(*scan);\n    if (**scan == '}') {\n      break;\n    }\n    if (**scan == ',') {\n      (*scan)++; // skip ','\n      continue;\n    }\n    if (**scan != ':') {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    (*scan)++; // skip ':'\n\n    // Read stride parameter\n    int sign = +1;\n    for (;;) {\n      SKIP_WS(*scan);\n      if (**scan == '+') {\n        (*scan)++; // skip '+'\n        continue;\n      }\n      if (**scan == '-') {\n        sign *= -1;\n        (*scan)++; // skip '-'\n        continue;\n      }\n      break;\n    }\n    SKIP_WS(*scan);\n    if ((**scan < '0') || (**scan > '9')) {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    next = *scan;\n    SKIP_DIGITS(next);\n    stride = __kmp_str_to_int(*scan, *next);\n    KMP_ASSERT(stride >= 0);\n    *scan = next;\n    stride *= sign;\n\n    // valid follow sets are ',' and '}'\n    SKIP_WS(*scan);\n    if (**scan == '}') {\n      break;\n    }\n    if (**scan == ',') {\n      (*scan)++; // skip ','\n      continue;\n    }\n\n    __kmp_omp_places_syntax_warn(var);\n    return FALSE;\n  }\n  return TRUE;\n}\n\nstatic int __kmp_parse_place(const char *var, const char **scan) {\n  const char *next;\n\n  // valid follow sets are '{' '!' and num\n  SKIP_WS(*scan);\n  if (**scan == '{') {\n    (*scan)++; // skip '{'\n    if (!__kmp_parse_subplace_list(var, scan)) {\n      return FALSE;\n    }\n    if (**scan != '}') {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    (*scan)++; // skip '}'\n  } else if (**scan == '!') {\n    (*scan)++; // skip '!'\n    return __kmp_parse_place(var, scan); //'!' has lower precedence than ':'\n  } else if ((**scan >= '0') && (**scan <= '9')) {\n    next = *scan;\n    SKIP_DIGITS(next);\n    int proc = __kmp_str_to_int(*scan, *next);\n    KMP_ASSERT(proc >= 0);\n    *scan = next;\n  } else {\n    __kmp_omp_places_syntax_warn(var);\n    return FALSE;\n  }\n  return TRUE;\n}\n\nstatic int __kmp_parse_place_list(const char *var, const char *env,\n                                  char **place_list) {\n  const char *scan = env;\n  const char *next = scan;\n\n  for (;;) {\n    int count, stride;\n\n    if (!__kmp_parse_place(var, &scan)) {\n      return FALSE;\n    }\n\n    // valid follow sets are ',' ':' and EOL\n    SKIP_WS(scan);\n    if (*scan == '\\0') {\n      break;\n    }\n    if (*scan == ',') {\n      scan++; // skip ','\n      continue;\n    }\n    if (*scan != ':') {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    scan++; // skip ':'\n\n    // Read count parameter\n    SKIP_WS(scan);\n    if ((*scan < '0') || (*scan > '9')) {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    next = scan;\n    SKIP_DIGITS(next);\n    count = __kmp_str_to_int(scan, *next);\n    KMP_ASSERT(count >= 0);\n    scan = next;\n\n    // valid follow sets are ',' ':' and EOL\n    SKIP_WS(scan);\n    if (*scan == '\\0') {\n      break;\n    }\n    if (*scan == ',') {\n      scan++; // skip ','\n      continue;\n    }\n    if (*scan != ':') {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    scan++; // skip ':'\n\n    // Read stride parameter\n    int sign = +1;\n    for (;;) {\n      SKIP_WS(scan);\n      if (*scan == '+') {\n        scan++; // skip '+'\n        continue;\n      }\n      if (*scan == '-') {\n        sign *= -1;\n        scan++; // skip '-'\n        continue;\n      }\n      break;\n    }\n    SKIP_WS(scan);\n    if ((*scan < '0') || (*scan > '9')) {\n      __kmp_omp_places_syntax_warn(var);\n      return FALSE;\n    }\n    next = scan;\n    SKIP_DIGITS(next);\n    stride = __kmp_str_to_int(scan, *next);\n    KMP_ASSERT(stride >= 0);\n    scan = next;\n    stride *= sign;\n\n    // valid follow sets are ',' and EOL\n    SKIP_WS(scan);\n    if (*scan == '\\0') {\n      break;\n    }\n    if (*scan == ',') {\n      scan++; // skip ','\n      continue;\n    }\n\n    __kmp_omp_places_syntax_warn(var);\n    return FALSE;\n  }\n\n  {\n    ptrdiff_t len = scan - env;\n    char *retlist = (char *)__kmp_allocate((len + 1) * sizeof(char));\n    KMP_MEMCPY_S(retlist, (len + 1) * sizeof(char), env, len * sizeof(char));\n    retlist[len] = '\\0';\n    *place_list = retlist;\n  }\n  return TRUE;\n}\n\nstatic void __kmp_stg_parse_places(char const *name, char const *value,\n                                   void *data) {\n  int count;\n  const char *scan = value;\n  const char *next = scan;\n  const char *kind = \"\\\"threads\\\"\";\n  kmp_setting_t **rivals = (kmp_setting_t **)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, rivals);\n  if (rc) {\n    return;\n  }\n\n  if (__kmp_match_str(\"threads\", scan, &next)) {\n    scan = next;\n    __kmp_affinity_type = affinity_compact;\n    __kmp_affinity_gran = affinity_gran_thread;\n    __kmp_affinity_dups = FALSE;\n    kind = \"\\\"threads\\\"\";\n  } else if (__kmp_match_str(\"cores\", scan, &next)) {\n    scan = next;\n    __kmp_affinity_type = affinity_compact;\n    __kmp_affinity_gran = affinity_gran_core;\n    __kmp_affinity_dups = FALSE;\n    kind = \"\\\"cores\\\"\";\n#if KMP_USE_HWLOC\n  } else if (__kmp_match_str(\"tiles\", scan, &next)) {\n    scan = next;\n    __kmp_affinity_type = affinity_compact;\n    __kmp_affinity_gran = affinity_gran_tile;\n    __kmp_affinity_dups = FALSE;\n    kind = \"\\\"tiles\\\"\";\n#endif\n  } else if (__kmp_match_str(\"dice\", scan, &next) ||\n             __kmp_match_str(\"dies\", scan, &next)) {\n    scan = next;\n    __kmp_affinity_type = affinity_compact;\n    __kmp_affinity_gran = affinity_gran_die;\n    __kmp_affinity_dups = FALSE;\n    kind = \"\\\"dice\\\"\";\n  } else if (__kmp_match_str(\"sockets\", scan, &next)) {\n    scan = next;\n    __kmp_affinity_type = affinity_compact;\n    __kmp_affinity_gran = affinity_gran_package;\n    __kmp_affinity_dups = FALSE;\n    kind = \"\\\"sockets\\\"\";\n  } else {\n    if (__kmp_affinity_proclist != NULL) {\n      KMP_INTERNAL_FREE((void *)__kmp_affinity_proclist);\n      __kmp_affinity_proclist = NULL;\n    }\n    if (__kmp_parse_place_list(name, value, &__kmp_affinity_proclist)) {\n      __kmp_affinity_type = affinity_explicit;\n      __kmp_affinity_gran = affinity_gran_fine;\n      __kmp_affinity_dups = FALSE;\n    } else {\n      // Syntax error fallback\n      __kmp_affinity_type = affinity_compact;\n      __kmp_affinity_gran = affinity_gran_core;\n      __kmp_affinity_dups = FALSE;\n    }\n    if (__kmp_nested_proc_bind.bind_types[0] == proc_bind_default) {\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_true;\n    }\n    return;\n  }\n\n  if (__kmp_nested_proc_bind.bind_types[0] == proc_bind_default) {\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_true;\n  }\n\n  SKIP_WS(scan);\n  if (*scan == '\\0') {\n    return;\n  }\n\n  // Parse option count parameter in parentheses\n  if (*scan != '(') {\n    KMP_WARNING(SyntaxErrorUsing, name, kind);\n    return;\n  }\n  scan++; // skip '('\n\n  SKIP_WS(scan);\n  next = scan;\n  SKIP_DIGITS(next);\n  count = __kmp_str_to_int(scan, *next);\n  KMP_ASSERT(count >= 0);\n  scan = next;\n\n  SKIP_WS(scan);\n  if (*scan != ')') {\n    KMP_WARNING(SyntaxErrorUsing, name, kind);\n    return;\n  }\n  scan++; // skip ')'\n\n  SKIP_WS(scan);\n  if (*scan != '\\0') {\n    KMP_WARNING(ParseExtraCharsWarn, name, scan);\n  }\n  __kmp_affinity_num_places = count;\n}\n\nstatic void __kmp_stg_print_places(kmp_str_buf_t *buffer, char const *name,\n                                   void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  if ((__kmp_nested_proc_bind.used == 0) ||\n      (__kmp_nested_proc_bind.bind_types == NULL) ||\n      (__kmp_nested_proc_bind.bind_types[0] == proc_bind_false)) {\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  } else if (__kmp_affinity_type == affinity_explicit) {\n    if (__kmp_affinity_proclist != NULL) {\n      __kmp_str_buf_print(buffer, \"='%s'\\n\", __kmp_affinity_proclist);\n    } else {\n      __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n    }\n  } else if (__kmp_affinity_type == affinity_compact) {\n    int num;\n    if (__kmp_affinity_num_masks > 0) {\n      num = __kmp_affinity_num_masks;\n    } else if (__kmp_affinity_num_places > 0) {\n      num = __kmp_affinity_num_places;\n    } else {\n      num = 0;\n    }\n    if (__kmp_affinity_gran == affinity_gran_thread) {\n      if (num > 0) {\n        __kmp_str_buf_print(buffer, \"='threads(%d)'\\n\", num);\n      } else {\n        __kmp_str_buf_print(buffer, \"='threads'\\n\");\n      }\n    } else if (__kmp_affinity_gran == affinity_gran_core) {\n      if (num > 0) {\n        __kmp_str_buf_print(buffer, \"='cores(%d)' \\n\", num);\n      } else {\n        __kmp_str_buf_print(buffer, \"='cores'\\n\");\n      }\n#if KMP_USE_HWLOC\n    } else if (__kmp_affinity_gran == affinity_gran_tile) {\n      if (num > 0) {\n        __kmp_str_buf_print(buffer, \"='tiles(%d)' \\n\", num);\n      } else {\n        __kmp_str_buf_print(buffer, \"='tiles'\\n\");\n      }\n#endif\n    } else if (__kmp_affinity_gran == affinity_gran_package) {\n      if (num > 0) {\n        __kmp_str_buf_print(buffer, \"='sockets(%d)'\\n\", num);\n      } else {\n        __kmp_str_buf_print(buffer, \"='sockets'\\n\");\n      }\n    } else {\n      __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n    }\n  } else {\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  }\n}\n\nstatic void __kmp_stg_parse_topology_method(char const *name, char const *value,\n                                            void *data) {\n  if (__kmp_str_match(\"all\", 1, value)) {\n    __kmp_affinity_top_method = affinity_top_method_all;\n  }\n#if KMP_USE_HWLOC\n  else if (__kmp_str_match(\"hwloc\", 1, value)) {\n    __kmp_affinity_top_method = affinity_top_method_hwloc;\n  }\n#endif\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  else if (__kmp_str_match(\"cpuid_leaf31\", 12, value) ||\n           __kmp_str_match(\"cpuid 1f\", 8, value) ||\n           __kmp_str_match(\"cpuid 31\", 8, value) ||\n           __kmp_str_match(\"cpuid1f\", 7, value) ||\n           __kmp_str_match(\"cpuid31\", 7, value) ||\n           __kmp_str_match(\"leaf 1f\", 7, value) ||\n           __kmp_str_match(\"leaf 31\", 7, value) ||\n           __kmp_str_match(\"leaf1f\", 6, value) ||\n           __kmp_str_match(\"leaf31\", 6, value)) {\n    __kmp_affinity_top_method = affinity_top_method_x2apicid_1f;\n  } else if (__kmp_str_match(\"x2apic id\", 9, value) ||\n             __kmp_str_match(\"x2apic_id\", 9, value) ||\n             __kmp_str_match(\"x2apic-id\", 9, value) ||\n             __kmp_str_match(\"x2apicid\", 8, value) ||\n             __kmp_str_match(\"cpuid leaf 11\", 13, value) ||\n             __kmp_str_match(\"cpuid_leaf_11\", 13, value) ||\n             __kmp_str_match(\"cpuid-leaf-11\", 13, value) ||\n             __kmp_str_match(\"cpuid leaf11\", 12, value) ||\n             __kmp_str_match(\"cpuid_leaf11\", 12, value) ||\n             __kmp_str_match(\"cpuid-leaf11\", 12, value) ||\n             __kmp_str_match(\"cpuidleaf 11\", 12, value) ||\n             __kmp_str_match(\"cpuidleaf_11\", 12, value) ||\n             __kmp_str_match(\"cpuidleaf-11\", 12, value) ||\n             __kmp_str_match(\"cpuidleaf11\", 11, value) ||\n             __kmp_str_match(\"cpuid 11\", 8, value) ||\n             __kmp_str_match(\"cpuid_11\", 8, value) ||\n             __kmp_str_match(\"cpuid-11\", 8, value) ||\n             __kmp_str_match(\"cpuid11\", 7, value) ||\n             __kmp_str_match(\"leaf 11\", 7, value) ||\n             __kmp_str_match(\"leaf_11\", 7, value) ||\n             __kmp_str_match(\"leaf-11\", 7, value) ||\n             __kmp_str_match(\"leaf11\", 6, value)) {\n    __kmp_affinity_top_method = affinity_top_method_x2apicid;\n  } else if (__kmp_str_match(\"apic id\", 7, value) ||\n             __kmp_str_match(\"apic_id\", 7, value) ||\n             __kmp_str_match(\"apic-id\", 7, value) ||\n             __kmp_str_match(\"apicid\", 6, value) ||\n             __kmp_str_match(\"cpuid leaf 4\", 12, value) ||\n             __kmp_str_match(\"cpuid_leaf_4\", 12, value) ||\n             __kmp_str_match(\"cpuid-leaf-4\", 12, value) ||\n             __kmp_str_match(\"cpuid leaf4\", 11, value) ||\n             __kmp_str_match(\"cpuid_leaf4\", 11, value) ||\n             __kmp_str_match(\"cpuid-leaf4\", 11, value) ||\n             __kmp_str_match(\"cpuidleaf 4\", 11, value) ||\n             __kmp_str_match(\"cpuidleaf_4\", 11, value) ||\n             __kmp_str_match(\"cpuidleaf-4\", 11, value) ||\n             __kmp_str_match(\"cpuidleaf4\", 10, value) ||\n             __kmp_str_match(\"cpuid 4\", 7, value) ||\n             __kmp_str_match(\"cpuid_4\", 7, value) ||\n             __kmp_str_match(\"cpuid-4\", 7, value) ||\n             __kmp_str_match(\"cpuid4\", 6, value) ||\n             __kmp_str_match(\"leaf 4\", 6, value) ||\n             __kmp_str_match(\"leaf_4\", 6, value) ||\n             __kmp_str_match(\"leaf-4\", 6, value) ||\n             __kmp_str_match(\"leaf4\", 5, value)) {\n    __kmp_affinity_top_method = affinity_top_method_apicid;\n  }\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n  else if (__kmp_str_match(\"/proc/cpuinfo\", 2, value) ||\n           __kmp_str_match(\"cpuinfo\", 5, value)) {\n    __kmp_affinity_top_method = affinity_top_method_cpuinfo;\n  }\n#if KMP_GROUP_AFFINITY\n  else if (__kmp_str_match(\"group\", 1, value)) {\n    __kmp_affinity_top_method = affinity_top_method_group;\n  }\n#endif /* KMP_GROUP_AFFINITY */\n  else if (__kmp_str_match(\"flat\", 1, value)) {\n    __kmp_affinity_top_method = affinity_top_method_flat;\n  } else {\n    KMP_WARNING(StgInvalidValue, name, value);\n  }\n} // __kmp_stg_parse_topology_method\n\nstatic void __kmp_stg_print_topology_method(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  char const *value = NULL;\n\n  switch (__kmp_affinity_top_method) {\n  case affinity_top_method_default:\n    value = \"default\";\n    break;\n\n  case affinity_top_method_all:\n    value = \"all\";\n    break;\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  case affinity_top_method_x2apicid:\n    value = \"x2APIC id\";\n    break;\n\n  case affinity_top_method_apicid:\n    value = \"APIC id\";\n    break;\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n#if KMP_USE_HWLOC\n  case affinity_top_method_hwloc:\n    value = \"hwloc\";\n    break;\n#endif\n\n  case affinity_top_method_cpuinfo:\n    value = \"cpuinfo\";\n    break;\n\n#if KMP_GROUP_AFFINITY\n  case affinity_top_method_group:\n    value = \"group\";\n    break;\n#endif /* KMP_GROUP_AFFINITY */\n\n  case affinity_top_method_flat:\n    value = \"flat\";\n    break;\n  }\n\n  if (value != NULL) {\n    __kmp_stg_print_str(buffer, name, value);\n  }\n} // __kmp_stg_print_topology_method\n\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n// OMP_PROC_BIND / bind-var is functional on all 4.0 builds, including OS X*\n// OMP_PLACES / place-partition-var is not.\nstatic void __kmp_stg_parse_proc_bind(char const *name, char const *value,\n                                      void *data) {\n  kmp_setting_t **rivals = (kmp_setting_t **)data;\n  int rc;\n\n  rc = __kmp_stg_check_rivals(name, value, rivals);\n  if (rc) {\n    return;\n  }\n\n  // In OMP 4.0 OMP_PROC_BIND is a vector of proc_bind types.\n  KMP_DEBUG_ASSERT((__kmp_nested_proc_bind.bind_types != NULL) &&\n                   (__kmp_nested_proc_bind.used > 0));\n\n  const char *buf = value;\n  const char *next;\n  int num;\n  SKIP_WS(buf);\n  if ((*buf >= '0') && (*buf <= '9')) {\n    next = buf;\n    SKIP_DIGITS(next);\n    num = __kmp_str_to_int(buf, *next);\n    KMP_ASSERT(num >= 0);\n    buf = next;\n    SKIP_WS(buf);\n  } else {\n    num = -1;\n  }\n\n  next = buf;\n  if (__kmp_match_str(\"disabled\", buf, &next)) {\n    buf = next;\n    SKIP_WS(buf);\n#if KMP_AFFINITY_SUPPORTED\n    __kmp_affinity_type = affinity_disabled;\n#endif /* KMP_AFFINITY_SUPPORTED */\n    __kmp_nested_proc_bind.used = 1;\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n  } else if ((num == (int)proc_bind_false) ||\n             __kmp_match_str(\"false\", buf, &next)) {\n    buf = next;\n    SKIP_WS(buf);\n#if KMP_AFFINITY_SUPPORTED\n    __kmp_affinity_type = affinity_none;\n#endif /* KMP_AFFINITY_SUPPORTED */\n    __kmp_nested_proc_bind.used = 1;\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n  } else if ((num == (int)proc_bind_true) ||\n             __kmp_match_str(\"true\", buf, &next)) {\n    buf = next;\n    SKIP_WS(buf);\n    __kmp_nested_proc_bind.used = 1;\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_true;\n  } else {\n    // Count the number of values in the env var string\n    const char *scan;\n    int nelem = 1;\n    for (scan = buf; *scan != '\\0'; scan++) {\n      if (*scan == ',') {\n        nelem++;\n      }\n    }\n\n    // Create / expand the nested proc_bind array as needed\n    if (__kmp_nested_proc_bind.size < nelem) {\n      __kmp_nested_proc_bind.bind_types =\n          (kmp_proc_bind_t *)KMP_INTERNAL_REALLOC(\n              __kmp_nested_proc_bind.bind_types,\n              sizeof(kmp_proc_bind_t) * nelem);\n      if (__kmp_nested_proc_bind.bind_types == NULL) {\n        KMP_FATAL(MemoryAllocFailed);\n      }\n      __kmp_nested_proc_bind.size = nelem;\n    }\n    __kmp_nested_proc_bind.used = nelem;\n\n    if (nelem > 1 && !__kmp_dflt_max_active_levels_set)\n      __kmp_dflt_max_active_levels = KMP_MAX_ACTIVE_LEVELS_LIMIT;\n\n    // Save values in the nested proc_bind array\n    int i = 0;\n    for (;;) {\n      enum kmp_proc_bind_t bind;\n\n      if ((num == (int)proc_bind_primary) ||\n          __kmp_match_str(\"master\", buf, &next) ||\n          __kmp_match_str(\"primary\", buf, &next)) {\n        buf = next;\n        SKIP_WS(buf);\n        bind = proc_bind_primary;\n      } else if ((num == (int)proc_bind_close) ||\n                 __kmp_match_str(\"close\", buf, &next)) {\n        buf = next;\n        SKIP_WS(buf);\n        bind = proc_bind_close;\n      } else if ((num == (int)proc_bind_spread) ||\n                 __kmp_match_str(\"spread\", buf, &next)) {\n        buf = next;\n        SKIP_WS(buf);\n        bind = proc_bind_spread;\n      } else {\n        KMP_WARNING(StgInvalidValue, name, value);\n        __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n        __kmp_nested_proc_bind.used = 1;\n        return;\n      }\n\n      __kmp_nested_proc_bind.bind_types[i++] = bind;\n      if (i >= nelem) {\n        break;\n      }\n      KMP_DEBUG_ASSERT(*buf == ',');\n      buf++;\n      SKIP_WS(buf);\n\n      // Read next value if it was specified as an integer\n      if ((*buf >= '0') && (*buf <= '9')) {\n        next = buf;\n        SKIP_DIGITS(next);\n        num = __kmp_str_to_int(buf, *next);\n        KMP_ASSERT(num >= 0);\n        buf = next;\n        SKIP_WS(buf);\n      } else {\n        num = -1;\n      }\n    }\n    SKIP_WS(buf);\n  }\n  if (*buf != '\\0') {\n    KMP_WARNING(ParseExtraCharsWarn, name, buf);\n  }\n}\n\nstatic void __kmp_stg_print_proc_bind(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  int nelem = __kmp_nested_proc_bind.used;\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME;\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s\", name);\n  }\n  if (nelem == 0) {\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  } else {\n    int i;\n    __kmp_str_buf_print(buffer, \"='\", name);\n    for (i = 0; i < nelem; i++) {\n      switch (__kmp_nested_proc_bind.bind_types[i]) {\n      case proc_bind_false:\n        __kmp_str_buf_print(buffer, \"false\");\n        break;\n\n      case proc_bind_true:\n        __kmp_str_buf_print(buffer, \"true\");\n        break;\n\n      case proc_bind_primary:\n        __kmp_str_buf_print(buffer, \"primary\");\n        break;\n\n      case proc_bind_close:\n        __kmp_str_buf_print(buffer, \"close\");\n        break;\n\n      case proc_bind_spread:\n        __kmp_str_buf_print(buffer, \"spread\");\n        break;\n\n      case proc_bind_intel:\n        __kmp_str_buf_print(buffer, \"intel\");\n        break;\n\n      case proc_bind_default:\n        __kmp_str_buf_print(buffer, \"default\");\n        break;\n      }\n      if (i < nelem - 1) {\n        __kmp_str_buf_print(buffer, \",\");\n      }\n    }\n    __kmp_str_buf_print(buffer, \"'\\n\");\n  }\n}\n\nstatic void __kmp_stg_parse_display_affinity(char const *name,\n                                             char const *value, void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_display_affinity);\n}\nstatic void __kmp_stg_print_display_affinity(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_display_affinity);\n}\nstatic void __kmp_stg_parse_affinity_format(char const *name, char const *value,\n                                            void *data) {\n  size_t length = KMP_STRLEN(value);\n  __kmp_strncpy_truncate(__kmp_affinity_format, KMP_AFFINITY_FORMAT_SIZE, value,\n                         length);\n}\nstatic void __kmp_stg_print_affinity_format(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s='\", name);\n  }\n  __kmp_str_buf_print(buffer, \"%s'\\n\", __kmp_affinity_format);\n}\n\n/*-----------------------------------------------------------------------------\nOMP_ALLOCATOR sets default allocator. Here is the grammar:\n\n<allocator>        |= <predef-allocator> | <predef-mem-space> |\n                      <predef-mem-space>:<traits>\n<traits>           |= <trait>=<value> | <trait>=<value>,<traits>\n<predef-allocator> |= omp_default_mem_alloc | omp_large_cap_mem_alloc |\n                      omp_const_mem_alloc | omp_high_bw_mem_alloc |\n                      omp_low_lat_mem_alloc | omp_cgroup_mem_alloc |\n                      omp_pteam_mem_alloc | omp_thread_mem_alloc\n<predef-mem-space> |= omp_default_mem_space | omp_large_cap_mem_space |\n                      omp_const_mem_space | omp_high_bw_mem_space |\n                      omp_low_lat_mem_space\n<trait>            |= sync_hint | alignment | access | pool_size | fallback |\n                      fb_data | pinned | partition\n<value>            |= one of the allowed values of trait |\n                      non-negative integer | <predef-allocator>\n-----------------------------------------------------------------------------*/\n\nstatic void __kmp_stg_parse_allocator(char const *name, char const *value,\n                                      void *data) {\n  const char *buf = value;\n  const char *next, *scan, *start;\n  char *key;\n  omp_allocator_handle_t al;\n  omp_memspace_handle_t ms = omp_default_mem_space;\n  bool is_memspace = false;\n  int ntraits = 0, count = 0;\n\n  SKIP_WS(buf);\n  next = buf;\n  const char *delim = strchr(buf, ':');\n  const char *predef_mem_space = strstr(buf, \"mem_space\");\n\n  bool is_memalloc = (!predef_mem_space && !delim) ? true : false;\n\n  // Count the number of traits in the env var string\n  if (delim) {\n    ntraits = 1;\n    for (scan = buf; *scan != '\\0'; scan++) {\n      if (*scan == ',')\n        ntraits++;\n    }\n  }\n  omp_alloctrait_t *traits =\n      (omp_alloctrait_t *)KMP_ALLOCA(ntraits * sizeof(omp_alloctrait_t));\n\n// Helper macros\n#define IS_POWER_OF_TWO(n) (((n) & ((n)-1)) == 0)\n\n#define GET_NEXT(sentinel)                                                     \\\n  {                                                                            \\\n    SKIP_WS(next);                                                             \\\n    if (*next == sentinel)                                                     \\\n      next++;                                                                  \\\n    SKIP_WS(next);                                                             \\\n    scan = next;                                                               \\\n  }\n\n#define SKIP_PAIR(key)                                                         \\\n  {                                                                            \\\n    char const str_delimiter[] = {',', 0};                                     \\\n    char *value = __kmp_str_token(CCAST(char *, scan), str_delimiter,          \\\n                                  CCAST(char **, &next));                      \\\n    KMP_WARNING(StgInvalidValue, key, value);                                  \\\n    ntraits--;                                                                 \\\n    SKIP_WS(next);                                                             \\\n    scan = next;                                                               \\\n  }\n\n#define SET_KEY()                                                              \\\n  {                                                                            \\\n    char const str_delimiter[] = {'=', 0};                                     \\\n    key = __kmp_str_token(CCAST(char *, start), str_delimiter,                 \\\n                          CCAST(char **, &next));                              \\\n    scan = next;                                                               \\\n  }\n\n  scan = next;\n  while (*next != '\\0') {\n    if (is_memalloc ||\n        __kmp_match_str(\"fb_data\", scan, &next)) { // allocator check\n      start = scan;\n      GET_NEXT('=');\n      // check HBW and LCAP first as the only non-default supported\n      if (__kmp_match_str(\"omp_high_bw_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          if (__kmp_memkind_available) {\n            __kmp_def_allocator = omp_high_bw_mem_alloc;\n            return;\n          } else {\n            KMP_WARNING(OmpNoAllocator, \"omp_high_bw_mem_alloc\");\n          }\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_high_bw_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_large_cap_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          if (__kmp_memkind_available) {\n            __kmp_def_allocator = omp_large_cap_mem_alloc;\n            return;\n          } else {\n            KMP_WARNING(OmpNoAllocator, \"omp_large_cap_mem_alloc\");\n          }\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_large_cap_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_default_mem_alloc\", scan, &next)) {\n        // default requested\n        SKIP_WS(next);\n        if (!is_memalloc) {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_default_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_const_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          KMP_WARNING(OmpNoAllocator, \"omp_const_mem_alloc\");\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_const_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_low_lat_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          KMP_WARNING(OmpNoAllocator, \"omp_low_lat_mem_alloc\");\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_low_lat_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_cgroup_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          KMP_WARNING(OmpNoAllocator, \"omp_cgroup_mem_alloc\");\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_cgroup_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_pteam_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          KMP_WARNING(OmpNoAllocator, \"omp_pteam_mem_alloc\");\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_pteam_mem_alloc);\n        }\n      } else if (__kmp_match_str(\"omp_thread_mem_alloc\", scan, &next)) {\n        SKIP_WS(next);\n        if (is_memalloc) {\n          KMP_WARNING(OmpNoAllocator, \"omp_thread_mem_alloc\");\n        } else {\n          traits[count].key = omp_atk_fb_data;\n          traits[count].value = RCAST(omp_uintptr_t, omp_thread_mem_alloc);\n        }\n      } else {\n        if (!is_memalloc) {\n          SET_KEY();\n          SKIP_PAIR(key);\n          continue;\n        }\n      }\n      if (is_memalloc) {\n        __kmp_def_allocator = omp_default_mem_alloc;\n        if (next == buf || *next != '\\0') {\n          // either no match or extra symbols present after the matched token\n          KMP_WARNING(StgInvalidValue, name, value);\n        }\n        return;\n      } else {\n        ++count;\n        if (count == ntraits)\n          break;\n        GET_NEXT(',');\n      }\n    } else { // memspace\n      if (!is_memspace) {\n        if (__kmp_match_str(\"omp_default_mem_space\", scan, &next)) {\n          SKIP_WS(next);\n          ms = omp_default_mem_space;\n        } else if (__kmp_match_str(\"omp_large_cap_mem_space\", scan, &next)) {\n          SKIP_WS(next);\n          ms = omp_large_cap_mem_space;\n        } else if (__kmp_match_str(\"omp_const_mem_space\", scan, &next)) {\n          SKIP_WS(next);\n          ms = omp_const_mem_space;\n        } else if (__kmp_match_str(\"omp_high_bw_mem_space\", scan, &next)) {\n          SKIP_WS(next);\n          ms = omp_high_bw_mem_space;\n        } else if (__kmp_match_str(\"omp_low_lat_mem_space\", scan, &next)) {\n          SKIP_WS(next);\n          ms = omp_low_lat_mem_space;\n        } else {\n          __kmp_def_allocator = omp_default_mem_alloc;\n          if (next == buf || *next != '\\0') {\n            // either no match or extra symbols present after the matched token\n            KMP_WARNING(StgInvalidValue, name, value);\n          }\n          return;\n        }\n        is_memspace = true;\n      }\n      if (delim) { // traits\n        GET_NEXT(':');\n        start = scan;\n        if (__kmp_match_str(\"sync_hint\", scan, &next)) {\n          GET_NEXT('=');\n          traits[count].key = omp_atk_sync_hint;\n          if (__kmp_match_str(\"contended\", scan, &next)) {\n            traits[count].value = omp_atv_contended;\n          } else if (__kmp_match_str(\"uncontended\", scan, &next)) {\n            traits[count].value = omp_atv_uncontended;\n          } else if (__kmp_match_str(\"serialized\", scan, &next)) {\n            traits[count].value = omp_atv_serialized;\n          } else if (__kmp_match_str(\"private\", scan, &next)) {\n            traits[count].value = omp_atv_private;\n          } else {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n        } else if (__kmp_match_str(\"alignment\", scan, &next)) {\n          GET_NEXT('=');\n          if (!isdigit(*next)) {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n          SKIP_DIGITS(next);\n          int n = __kmp_str_to_int(scan, ',');\n          if (n < 0 || !IS_POWER_OF_TWO(n)) {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n          traits[count].key = omp_atk_alignment;\n          traits[count].value = n;\n        } else if (__kmp_match_str(\"access\", scan, &next)) {\n          GET_NEXT('=');\n          traits[count].key = omp_atk_access;\n          if (__kmp_match_str(\"all\", scan, &next)) {\n            traits[count].value = omp_atv_all;\n          } else if (__kmp_match_str(\"cgroup\", scan, &next)) {\n            traits[count].value = omp_atv_cgroup;\n          } else if (__kmp_match_str(\"pteam\", scan, &next)) {\n            traits[count].value = omp_atv_pteam;\n          } else if (__kmp_match_str(\"thread\", scan, &next)) {\n            traits[count].value = omp_atv_thread;\n          } else {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n        } else if (__kmp_match_str(\"pool_size\", scan, &next)) {\n          GET_NEXT('=');\n          if (!isdigit(*next)) {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n          SKIP_DIGITS(next);\n          int n = __kmp_str_to_int(scan, ',');\n          if (n < 0) {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n          traits[count].key = omp_atk_pool_size;\n          traits[count].value = n;\n        } else if (__kmp_match_str(\"fallback\", scan, &next)) {\n          GET_NEXT('=');\n          traits[count].key = omp_atk_fallback;\n          if (__kmp_match_str(\"default_mem_fb\", scan, &next)) {\n            traits[count].value = omp_atv_default_mem_fb;\n          } else if (__kmp_match_str(\"null_fb\", scan, &next)) {\n            traits[count].value = omp_atv_null_fb;\n          } else if (__kmp_match_str(\"abort_fb\", scan, &next)) {\n            traits[count].value = omp_atv_abort_fb;\n          } else if (__kmp_match_str(\"allocator_fb\", scan, &next)) {\n            traits[count].value = omp_atv_allocator_fb;\n          } else {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n        } else if (__kmp_match_str(\"pinned\", scan, &next)) {\n          GET_NEXT('=');\n          traits[count].key = omp_atk_pinned;\n          if (__kmp_str_match_true(next)) {\n            traits[count].value = omp_atv_true;\n          } else if (__kmp_str_match_false(next)) {\n            traits[count].value = omp_atv_false;\n          } else {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n        } else if (__kmp_match_str(\"partition\", scan, &next)) {\n          GET_NEXT('=');\n          traits[count].key = omp_atk_partition;\n          if (__kmp_match_str(\"environment\", scan, &next)) {\n            traits[count].value = omp_atv_environment;\n          } else if (__kmp_match_str(\"nearest\", scan, &next)) {\n            traits[count].value = omp_atv_nearest;\n          } else if (__kmp_match_str(\"blocked\", scan, &next)) {\n            traits[count].value = omp_atv_blocked;\n          } else if (__kmp_match_str(\"interleaved\", scan, &next)) {\n            traits[count].value = omp_atv_interleaved;\n          } else {\n            SET_KEY();\n            SKIP_PAIR(key);\n            continue;\n          }\n        } else {\n          SET_KEY();\n          SKIP_PAIR(key);\n          continue;\n        }\n        SKIP_WS(next);\n        ++count;\n        if (count == ntraits)\n          break;\n        GET_NEXT(',');\n      } // traits\n    } // memspace\n  } // while\n  al = __kmpc_init_allocator(__kmp_get_gtid(), ms, ntraits, traits);\n  __kmp_def_allocator = (al == omp_null_allocator) ? omp_default_mem_alloc : al;\n}\n\nstatic void __kmp_stg_print_allocator(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  if (__kmp_def_allocator == omp_default_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_default_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_high_bw_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_high_bw_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_large_cap_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_large_cap_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_const_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_const_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_low_lat_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_low_lat_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_cgroup_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_cgroup_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_pteam_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_pteam_mem_alloc\");\n  } else if (__kmp_def_allocator == omp_thread_mem_alloc) {\n    __kmp_stg_print_str(buffer, name, \"omp_thread_mem_alloc\");\n  }\n}\n\n// -----------------------------------------------------------------------------\n// OMP_DYNAMIC\n\nstatic void __kmp_stg_parse_omp_dynamic(char const *name, char const *value,\n                                        void *data) {\n  __kmp_stg_parse_bool(name, value, &(__kmp_global.g.g_dynamic));\n} // __kmp_stg_parse_omp_dynamic\n\nstatic void __kmp_stg_print_omp_dynamic(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_global.g.g_dynamic);\n} // __kmp_stg_print_omp_dynamic\n\nstatic void __kmp_stg_parse_kmp_dynamic_mode(char const *name,\n                                             char const *value, void *data) {\n  if (TCR_4(__kmp_init_parallel)) {\n    KMP_WARNING(EnvParallelWarn, name);\n    __kmp_env_toPrint(name, 0);\n    return;\n  }\n#ifdef USE_LOAD_BALANCE\n  else if (__kmp_str_match(\"load balance\", 2, value) ||\n           __kmp_str_match(\"load_balance\", 2, value) ||\n           __kmp_str_match(\"load-balance\", 2, value) ||\n           __kmp_str_match(\"loadbalance\", 2, value) ||\n           __kmp_str_match(\"balance\", 1, value)) {\n    __kmp_global.g.g_dynamic_mode = dynamic_load_balance;\n  }\n#endif /* USE_LOAD_BALANCE */\n  else if (__kmp_str_match(\"thread limit\", 1, value) ||\n           __kmp_str_match(\"thread_limit\", 1, value) ||\n           __kmp_str_match(\"thread-limit\", 1, value) ||\n           __kmp_str_match(\"threadlimit\", 1, value) ||\n           __kmp_str_match(\"limit\", 2, value)) {\n    __kmp_global.g.g_dynamic_mode = dynamic_thread_limit;\n  } else if (__kmp_str_match(\"random\", 1, value)) {\n    __kmp_global.g.g_dynamic_mode = dynamic_random;\n  } else {\n    KMP_WARNING(StgInvalidValue, name, value);\n  }\n} //__kmp_stg_parse_kmp_dynamic_mode\n\nstatic void __kmp_stg_print_kmp_dynamic_mode(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n#if KMP_DEBUG\n  if (__kmp_global.g.g_dynamic_mode == dynamic_default) {\n    __kmp_str_buf_print(buffer, \"   %s: %s \\n\", name, KMP_I18N_STR(NotDefined));\n  }\n#ifdef USE_LOAD_BALANCE\n  else if (__kmp_global.g.g_dynamic_mode == dynamic_load_balance) {\n    __kmp_stg_print_str(buffer, name, \"load balance\");\n  }\n#endif /* USE_LOAD_BALANCE */\n  else if (__kmp_global.g.g_dynamic_mode == dynamic_thread_limit) {\n    __kmp_stg_print_str(buffer, name, \"thread limit\");\n  } else if (__kmp_global.g.g_dynamic_mode == dynamic_random) {\n    __kmp_stg_print_str(buffer, name, \"random\");\n  } else {\n    KMP_ASSERT(0);\n  }\n#endif /* KMP_DEBUG */\n} // __kmp_stg_print_kmp_dynamic_mode\n\n#ifdef USE_LOAD_BALANCE\n\n// -----------------------------------------------------------------------------\n// KMP_LOAD_BALANCE_INTERVAL\n\nstatic void __kmp_stg_parse_ld_balance_interval(char const *name,\n                                                char const *value, void *data) {\n  double interval = __kmp_convert_to_double(value);\n  if (interval >= 0) {\n    __kmp_load_balance_interval = interval;\n  } else {\n    KMP_WARNING(StgInvalidValue, name, value);\n  }\n} // __kmp_stg_parse_load_balance_interval\n\nstatic void __kmp_stg_print_ld_balance_interval(kmp_str_buf_t *buffer,\n                                                char const *name, void *data) {\n#if KMP_DEBUG\n  __kmp_str_buf_print(buffer, \"   %s=%8.6f\\n\", name,\n                      __kmp_load_balance_interval);\n#endif /* KMP_DEBUG */\n} // __kmp_stg_print_load_balance_interval\n\n#endif /* USE_LOAD_BALANCE */\n\n// -----------------------------------------------------------------------------\n// KMP_INIT_AT_FORK\n\nstatic void __kmp_stg_parse_init_at_fork(char const *name, char const *value,\n                                         void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_need_register_atfork);\n  if (__kmp_need_register_atfork) {\n    __kmp_need_register_atfork_specified = TRUE;\n  }\n} // __kmp_stg_parse_init_at_fork\n\nstatic void __kmp_stg_print_init_at_fork(kmp_str_buf_t *buffer,\n                                         char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_need_register_atfork_specified);\n} // __kmp_stg_print_init_at_fork\n\n// -----------------------------------------------------------------------------\n// KMP_SCHEDULE\n\nstatic void __kmp_stg_parse_schedule(char const *name, char const *value,\n                                     void *data) {\n\n  if (value != NULL) {\n    size_t length = KMP_STRLEN(value);\n    if (length > INT_MAX) {\n      KMP_WARNING(LongValue, name);\n    } else {\n      const char *semicolon;\n      if (value[length - 1] == '\"' || value[length - 1] == '\\'')\n        KMP_WARNING(UnbalancedQuotes, name);\n      do {\n        char sentinel;\n\n        semicolon = strchr(value, ';');\n        if (*value && semicolon != value) {\n          const char *comma = strchr(value, ',');\n\n          if (comma) {\n            ++comma;\n            sentinel = ',';\n          } else\n            sentinel = ';';\n          if (!__kmp_strcasecmp_with_sentinel(\"static\", value, sentinel)) {\n            if (!__kmp_strcasecmp_with_sentinel(\"greedy\", comma, ';')) {\n              __kmp_static = kmp_sch_static_greedy;\n              continue;\n            } else if (!__kmp_strcasecmp_with_sentinel(\"balanced\", comma,\n                                                       ';')) {\n              __kmp_static = kmp_sch_static_balanced;\n              continue;\n            }\n          } else if (!__kmp_strcasecmp_with_sentinel(\"guided\", value,\n                                                     sentinel)) {\n            if (!__kmp_strcasecmp_with_sentinel(\"iterative\", comma, ';')) {\n              __kmp_guided = kmp_sch_guided_iterative_chunked;\n              continue;\n            } else if (!__kmp_strcasecmp_with_sentinel(\"analytical\", comma,\n                                                       ';')) {\n              /* analytical not allowed for too many threads */\n              __kmp_guided = kmp_sch_guided_analytical_chunked;\n              continue;\n            }\n          }\n          KMP_WARNING(InvalidClause, name, value);\n        } else\n          KMP_WARNING(EmptyClause, name);\n      } while ((value = semicolon ? semicolon + 1 : NULL));\n    }\n  }\n\n} // __kmp_stg_parse__schedule\n\nstatic void __kmp_stg_print_schedule(kmp_str_buf_t *buffer, char const *name,\n                                     void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s='\", name);\n  }\n  if (__kmp_static == kmp_sch_static_greedy) {\n    __kmp_str_buf_print(buffer, \"%s\", \"static,greedy\");\n  } else if (__kmp_static == kmp_sch_static_balanced) {\n    __kmp_str_buf_print(buffer, \"%s\", \"static,balanced\");\n  }\n  if (__kmp_guided == kmp_sch_guided_iterative_chunked) {\n    __kmp_str_buf_print(buffer, \";%s'\\n\", \"guided,iterative\");\n  } else if (__kmp_guided == kmp_sch_guided_analytical_chunked) {\n    __kmp_str_buf_print(buffer, \";%s'\\n\", \"guided,analytical\");\n  }\n} // __kmp_stg_print_schedule\n\n// -----------------------------------------------------------------------------\n// OMP_SCHEDULE\n\nstatic inline void __kmp_omp_schedule_restore() {\n#if KMP_USE_HIER_SCHED\n  __kmp_hier_scheds.deallocate();\n#endif\n  __kmp_chunk = 0;\n  __kmp_sched = kmp_sch_default;\n}\n\n// if parse_hier = true:\n//    Parse [HW,][modifier:]kind[,chunk]\n// else:\n//    Parse [modifier:]kind[,chunk]\nstatic const char *__kmp_parse_single_omp_schedule(const char *name,\n                                                   const char *value,\n                                                   bool parse_hier = false) {\n  /* get the specified scheduling style */\n  const char *ptr = value;\n  const char *delim;\n  int chunk = 0;\n  enum sched_type sched = kmp_sch_default;\n  if (*ptr == '\\0')\n    return NULL;\n  delim = ptr;\n  while (*delim != ',' && *delim != ':' && *delim != '\\0')\n    delim++;\n#if KMP_USE_HIER_SCHED\n  kmp_hier_layer_e layer = kmp_hier_layer_e::LAYER_THREAD;\n  if (parse_hier) {\n    if (*delim == ',') {\n      if (!__kmp_strcasecmp_with_sentinel(\"L1\", ptr, ',')) {\n        layer = kmp_hier_layer_e::LAYER_L1;\n      } else if (!__kmp_strcasecmp_with_sentinel(\"L2\", ptr, ',')) {\n        layer = kmp_hier_layer_e::LAYER_L2;\n      } else if (!__kmp_strcasecmp_with_sentinel(\"L3\", ptr, ',')) {\n        layer = kmp_hier_layer_e::LAYER_L3;\n      } else if (!__kmp_strcasecmp_with_sentinel(\"NUMA\", ptr, ',')) {\n        layer = kmp_hier_layer_e::LAYER_NUMA;\n      }\n    }\n    if (layer != kmp_hier_layer_e::LAYER_THREAD && *delim != ',') {\n      // If there is no comma after the layer, then this schedule is invalid\n      KMP_WARNING(StgInvalidValue, name, value);\n      __kmp_omp_schedule_restore();\n      return NULL;\n    } else if (layer != kmp_hier_layer_e::LAYER_THREAD) {\n      ptr = ++delim;\n      while (*delim != ',' && *delim != ':' && *delim != '\\0')\n        delim++;\n    }\n  }\n#endif // KMP_USE_HIER_SCHED\n  // Read in schedule modifier if specified\n  enum sched_type sched_modifier = (enum sched_type)0;\n  if (*delim == ':') {\n    if (!__kmp_strcasecmp_with_sentinel(\"monotonic\", ptr, *delim)) {\n      sched_modifier = sched_type::kmp_sch_modifier_monotonic;\n      ptr = ++delim;\n      while (*delim != ',' && *delim != ':' && *delim != '\\0')\n        delim++;\n    } else if (!__kmp_strcasecmp_with_sentinel(\"nonmonotonic\", ptr, *delim)) {\n      sched_modifier = sched_type::kmp_sch_modifier_nonmonotonic;\n      ptr = ++delim;\n      while (*delim != ',' && *delim != ':' && *delim != '\\0')\n        delim++;\n    } else if (!parse_hier) {\n      // If there is no proper schedule modifier, then this schedule is invalid\n      KMP_WARNING(StgInvalidValue, name, value);\n      __kmp_omp_schedule_restore();\n      return NULL;\n    }\n  }\n  // Read in schedule kind (required)\n  if (!__kmp_strcasecmp_with_sentinel(\"dynamic\", ptr, *delim))\n    sched = kmp_sch_dynamic_chunked;\n  else if (!__kmp_strcasecmp_with_sentinel(\"guided\", ptr, *delim))\n    sched = kmp_sch_guided_chunked;\n  // AC: TODO: probably remove TRAPEZOIDAL (OMP 3.0 does not allow it)\n  else if (!__kmp_strcasecmp_with_sentinel(\"auto\", ptr, *delim))\n    sched = kmp_sch_auto;\n  else if (!__kmp_strcasecmp_with_sentinel(\"trapezoidal\", ptr, *delim))\n    sched = kmp_sch_trapezoidal;\n  else if (!__kmp_strcasecmp_with_sentinel(\"static\", ptr, *delim))\n    sched = kmp_sch_static;\n#if KMP_STATIC_STEAL_ENABLED\n  else if (!__kmp_strcasecmp_with_sentinel(\"static_steal\", ptr, *delim))\n    sched = kmp_sch_static_steal;\n#endif\n  else {\n    // If there is no proper schedule kind, then this schedule is invalid\n    KMP_WARNING(StgInvalidValue, name, value);\n    __kmp_omp_schedule_restore();\n    return NULL;\n  }\n\n  // Read in schedule chunk size if specified\n  if (*delim == ',') {\n    ptr = delim + 1;\n    SKIP_WS(ptr);\n    if (!isdigit(*ptr)) {\n      // If there is no chunk after comma, then this schedule is invalid\n      KMP_WARNING(StgInvalidValue, name, value);\n      __kmp_omp_schedule_restore();\n      return NULL;\n    }\n    SKIP_DIGITS(ptr);\n    // auto schedule should not specify chunk size\n    if (sched == kmp_sch_auto) {\n      __kmp_msg(kmp_ms_warning, KMP_MSG(IgnoreChunk, name, delim),\n                __kmp_msg_null);\n    } else {\n      if (sched == kmp_sch_static)\n        sched = kmp_sch_static_chunked;\n      chunk = __kmp_str_to_int(delim + 1, *ptr);\n      if (chunk < 1) {\n        chunk = KMP_DEFAULT_CHUNK;\n        __kmp_msg(kmp_ms_warning, KMP_MSG(InvalidChunk, name, delim),\n                  __kmp_msg_null);\n        KMP_INFORM(Using_int_Value, name, __kmp_chunk);\n        // AC: next block commented out until KMP_DEFAULT_CHUNK != KMP_MIN_CHUNK\n        // (to improve code coverage :)\n        // The default chunk size is 1 according to standard, thus making\n        // KMP_MIN_CHUNK not 1 we would introduce mess:\n        // wrong chunk becomes 1, but it will be impossible to explicitly set\n        // to 1 because it becomes KMP_MIN_CHUNK...\n        // } else if ( chunk < KMP_MIN_CHUNK ) {\n        //   chunk = KMP_MIN_CHUNK;\n      } else if (chunk > KMP_MAX_CHUNK) {\n        chunk = KMP_MAX_CHUNK;\n        __kmp_msg(kmp_ms_warning, KMP_MSG(LargeChunk, name, delim),\n                  __kmp_msg_null);\n        KMP_INFORM(Using_int_Value, name, chunk);\n      }\n    }\n  } else {\n    ptr = delim;\n  }\n\n  SCHEDULE_SET_MODIFIERS(sched, sched_modifier);\n\n#if KMP_USE_HIER_SCHED\n  if (layer != kmp_hier_layer_e::LAYER_THREAD) {\n    __kmp_hier_scheds.append(sched, chunk, layer);\n  } else\n#endif\n  {\n    __kmp_chunk = chunk;\n    __kmp_sched = sched;\n  }\n  return ptr;\n}\n\nstatic void __kmp_stg_parse_omp_schedule(char const *name, char const *value,\n                                         void *data) {\n  size_t length;\n  const char *ptr = value;\n  SKIP_WS(ptr);\n  if (value) {\n    length = KMP_STRLEN(value);\n    if (length) {\n      if (value[length - 1] == '\"' || value[length - 1] == '\\'')\n        KMP_WARNING(UnbalancedQuotes, name);\n/* get the specified scheduling style */\n#if KMP_USE_HIER_SCHED\n      if (!__kmp_strcasecmp_with_sentinel(\"EXPERIMENTAL\", ptr, ' ')) {\n        SKIP_TOKEN(ptr);\n        SKIP_WS(ptr);\n        while ((ptr = __kmp_parse_single_omp_schedule(name, ptr, true))) {\n          while (*ptr == ' ' || *ptr == '\\t' || *ptr == ':')\n            ptr++;\n          if (*ptr == '\\0')\n            break;\n        }\n      } else\n#endif\n        __kmp_parse_single_omp_schedule(name, ptr);\n    } else\n      KMP_WARNING(EmptyString, name);\n  }\n#if KMP_USE_HIER_SCHED\n  __kmp_hier_scheds.sort();\n#endif\n  K_DIAG(1, (\"__kmp_static == %d\\n\", __kmp_static))\n  K_DIAG(1, (\"__kmp_guided == %d\\n\", __kmp_guided))\n  K_DIAG(1, (\"__kmp_sched == %d\\n\", __kmp_sched))\n  K_DIAG(1, (\"__kmp_chunk == %d\\n\", __kmp_chunk))\n} // __kmp_stg_parse_omp_schedule\n\nstatic void __kmp_stg_print_omp_schedule(kmp_str_buf_t *buffer,\n                                         char const *name, void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s='\", name);\n  }\n  enum sched_type sched = SCHEDULE_WITHOUT_MODIFIERS(__kmp_sched);\n  if (SCHEDULE_HAS_MONOTONIC(__kmp_sched)) {\n    __kmp_str_buf_print(buffer, \"monotonic:\");\n  } else if (SCHEDULE_HAS_NONMONOTONIC(__kmp_sched)) {\n    __kmp_str_buf_print(buffer, \"nonmonotonic:\");\n  }\n  if (__kmp_chunk) {\n    switch (sched) {\n    case kmp_sch_dynamic_chunked:\n      __kmp_str_buf_print(buffer, \"%s,%d'\\n\", \"dynamic\", __kmp_chunk);\n      break;\n    case kmp_sch_guided_iterative_chunked:\n    case kmp_sch_guided_analytical_chunked:\n      __kmp_str_buf_print(buffer, \"%s,%d'\\n\", \"guided\", __kmp_chunk);\n      break;\n    case kmp_sch_trapezoidal:\n      __kmp_str_buf_print(buffer, \"%s,%d'\\n\", \"trapezoidal\", __kmp_chunk);\n      break;\n    case kmp_sch_static:\n    case kmp_sch_static_chunked:\n    case kmp_sch_static_balanced:\n    case kmp_sch_static_greedy:\n      __kmp_str_buf_print(buffer, \"%s,%d'\\n\", \"static\", __kmp_chunk);\n      break;\n    case kmp_sch_static_steal:\n      __kmp_str_buf_print(buffer, \"%s,%d'\\n\", \"static_steal\", __kmp_chunk);\n      break;\n    case kmp_sch_auto:\n      __kmp_str_buf_print(buffer, \"%s,%d'\\n\", \"auto\", __kmp_chunk);\n      break;\n    }\n  } else {\n    switch (sched) {\n    case kmp_sch_dynamic_chunked:\n      __kmp_str_buf_print(buffer, \"%s'\\n\", \"dynamic\");\n      break;\n    case kmp_sch_guided_iterative_chunked:\n    case kmp_sch_guided_analytical_chunked:\n      __kmp_str_buf_print(buffer, \"%s'\\n\", \"guided\");\n      break;\n    case kmp_sch_trapezoidal:\n      __kmp_str_buf_print(buffer, \"%s'\\n\", \"trapezoidal\");\n      break;\n    case kmp_sch_static:\n    case kmp_sch_static_chunked:\n    case kmp_sch_static_balanced:\n    case kmp_sch_static_greedy:\n      __kmp_str_buf_print(buffer, \"%s'\\n\", \"static\");\n      break;\n    case kmp_sch_static_steal:\n      __kmp_str_buf_print(buffer, \"%s'\\n\", \"static_steal\");\n      break;\n    case kmp_sch_auto:\n      __kmp_str_buf_print(buffer, \"%s'\\n\", \"auto\");\n      break;\n    }\n  }\n} // __kmp_stg_print_omp_schedule\n\n#if KMP_USE_HIER_SCHED\n// -----------------------------------------------------------------------------\n// KMP_DISP_HAND_THREAD\nstatic void __kmp_stg_parse_kmp_hand_thread(char const *name, char const *value,\n                                            void *data) {\n  __kmp_stg_parse_bool(name, value, &(__kmp_dispatch_hand_threading));\n} // __kmp_stg_parse_kmp_hand_thread\n\nstatic void __kmp_stg_print_kmp_hand_thread(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_dispatch_hand_threading);\n} // __kmp_stg_print_kmp_hand_thread\n#endif\n\n// -----------------------------------------------------------------------------\n// KMP_FORCE_MONOTONIC_DYNAMIC_SCHEDULE\nstatic void __kmp_stg_parse_kmp_force_monotonic(char const *name,\n                                                char const *value, void *data) {\n  __kmp_stg_parse_bool(name, value, &(__kmp_force_monotonic));\n} // __kmp_stg_parse_kmp_force_monotonic\n\nstatic void __kmp_stg_print_kmp_force_monotonic(kmp_str_buf_t *buffer,\n                                                char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_force_monotonic);\n} // __kmp_stg_print_kmp_force_monotonic\n\n// -----------------------------------------------------------------------------\n// KMP_ATOMIC_MODE\n\nstatic void __kmp_stg_parse_atomic_mode(char const *name, char const *value,\n                                        void *data) {\n  // Modes: 0 -- do not change default; 1 -- Intel perf mode, 2 -- GOMP\n  // compatibility mode.\n  int mode = 0;\n  int max = 1;\n#ifdef KMP_GOMP_COMPAT\n  max = 2;\n#endif /* KMP_GOMP_COMPAT */\n  __kmp_stg_parse_int(name, value, 0, max, &mode);\n  // TODO; parse_int is not very suitable for this case. In case of overflow it\n  // is better to use\n  // 0 rather that max value.\n  if (mode > 0) {\n    __kmp_atomic_mode = mode;\n  }\n} // __kmp_stg_parse_atomic_mode\n\nstatic void __kmp_stg_print_atomic_mode(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_atomic_mode);\n} // __kmp_stg_print_atomic_mode\n\n// -----------------------------------------------------------------------------\n// KMP_CONSISTENCY_CHECK\n\nstatic void __kmp_stg_parse_consistency_check(char const *name,\n                                              char const *value, void *data) {\n  if (!__kmp_strcasecmp_with_sentinel(\"all\", value, 0)) {\n    // Note, this will not work from kmp_set_defaults because th_cons stack was\n    // not allocated\n    // for existed thread(s) thus the first __kmp_push_<construct> will break\n    // with assertion.\n    // TODO: allocate th_cons if called from kmp_set_defaults.\n    __kmp_env_consistency_check = TRUE;\n  } else if (!__kmp_strcasecmp_with_sentinel(\"none\", value, 0)) {\n    __kmp_env_consistency_check = FALSE;\n  } else {\n    KMP_WARNING(StgInvalidValue, name, value);\n  }\n} // __kmp_stg_parse_consistency_check\n\nstatic void __kmp_stg_print_consistency_check(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n#if KMP_DEBUG\n  const char *value = NULL;\n\n  if (__kmp_env_consistency_check) {\n    value = \"all\";\n  } else {\n    value = \"none\";\n  }\n\n  if (value != NULL) {\n    __kmp_stg_print_str(buffer, name, value);\n  }\n#endif /* KMP_DEBUG */\n} // __kmp_stg_print_consistency_check\n\n#if USE_ITT_BUILD\n// -----------------------------------------------------------------------------\n// KMP_ITT_PREPARE_DELAY\n\n#if USE_ITT_NOTIFY\n\nstatic void __kmp_stg_parse_itt_prepare_delay(char const *name,\n                                              char const *value, void *data) {\n  // Experimental code: KMP_ITT_PREPARE_DELAY specifies numbert of loop\n  // iterations.\n  int delay = 0;\n  __kmp_stg_parse_int(name, value, 0, INT_MAX, &delay);\n  __kmp_itt_prepare_delay = delay;\n} // __kmp_str_parse_itt_prepare_delay\n\nstatic void __kmp_stg_print_itt_prepare_delay(kmp_str_buf_t *buffer,\n                                              char const *name, void *data) {\n  __kmp_stg_print_uint64(buffer, name, __kmp_itt_prepare_delay);\n\n} // __kmp_str_print_itt_prepare_delay\n\n#endif // USE_ITT_NOTIFY\n#endif /* USE_ITT_BUILD */\n\n// -----------------------------------------------------------------------------\n// KMP_MALLOC_POOL_INCR\n\nstatic void __kmp_stg_parse_malloc_pool_incr(char const *name,\n                                             char const *value, void *data) {\n  __kmp_stg_parse_size(name, value, KMP_MIN_MALLOC_POOL_INCR,\n                       KMP_MAX_MALLOC_POOL_INCR, NULL, &__kmp_malloc_pool_incr,\n                       1);\n} // __kmp_stg_parse_malloc_pool_incr\n\nstatic void __kmp_stg_print_malloc_pool_incr(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n  __kmp_stg_print_size(buffer, name, __kmp_malloc_pool_incr);\n\n} // _kmp_stg_print_malloc_pool_incr\n\n#ifdef KMP_DEBUG\n\n// -----------------------------------------------------------------------------\n// KMP_PAR_RANGE\n\nstatic void __kmp_stg_parse_par_range_env(char const *name, char const *value,\n                                          void *data) {\n  __kmp_stg_parse_par_range(name, value, &__kmp_par_range,\n                            __kmp_par_range_routine, __kmp_par_range_filename,\n                            &__kmp_par_range_lb, &__kmp_par_range_ub);\n} // __kmp_stg_parse_par_range_env\n\nstatic void __kmp_stg_print_par_range_env(kmp_str_buf_t *buffer,\n                                          char const *name, void *data) {\n  if (__kmp_par_range != 0) {\n    __kmp_stg_print_str(buffer, name, par_range_to_print);\n  }\n} // __kmp_stg_print_par_range_env\n\n#endif\n\n// -----------------------------------------------------------------------------\n// KMP_GTID_MODE\n\nstatic void __kmp_stg_parse_gtid_mode(char const *name, char const *value,\n                                      void *data) {\n  // Modes:\n  //   0 -- do not change default\n  //   1 -- sp search\n  //   2 -- use \"keyed\" TLS var, i.e.\n  //        pthread_getspecific(Linux* OS/OS X*) or TlsGetValue(Windows* OS)\n  //   3 -- __declspec(thread) TLS var in tdata section\n  int mode = 0;\n  int max = 2;\n#ifdef KMP_TDATA_GTID\n  max = 3;\n#endif /* KMP_TDATA_GTID */\n  __kmp_stg_parse_int(name, value, 0, max, &mode);\n  // TODO; parse_int is not very suitable for this case. In case of overflow it\n  // is better to use 0 rather that max value.\n  if (mode == 0) {\n    __kmp_adjust_gtid_mode = TRUE;\n  } else {\n    __kmp_gtid_mode = mode;\n    __kmp_adjust_gtid_mode = FALSE;\n  }\n} // __kmp_str_parse_gtid_mode\n\nstatic void __kmp_stg_print_gtid_mode(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  if (__kmp_adjust_gtid_mode) {\n    __kmp_stg_print_int(buffer, name, 0);\n  } else {\n    __kmp_stg_print_int(buffer, name, __kmp_gtid_mode);\n  }\n} // __kmp_stg_print_gtid_mode\n\n// -----------------------------------------------------------------------------\n// KMP_NUM_LOCKS_IN_BLOCK\n\nstatic void __kmp_stg_parse_lock_block(char const *name, char const *value,\n                                       void *data) {\n  __kmp_stg_parse_int(name, value, 0, KMP_INT_MAX, &__kmp_num_locks_in_block);\n} // __kmp_str_parse_lock_block\n\nstatic void __kmp_stg_print_lock_block(kmp_str_buf_t *buffer, char const *name,\n                                       void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_num_locks_in_block);\n} // __kmp_stg_print_lock_block\n\n// -----------------------------------------------------------------------------\n// KMP_LOCK_KIND\n\n#if KMP_USE_DYNAMIC_LOCK\n#define KMP_STORE_LOCK_SEQ(a) (__kmp_user_lock_seq = lockseq_##a)\n#else\n#define KMP_STORE_LOCK_SEQ(a)\n#endif\n\nstatic void __kmp_stg_parse_lock_kind(char const *name, char const *value,\n                                      void *data) {\n  if (__kmp_init_user_locks) {\n    KMP_WARNING(EnvLockWarn, name);\n    return;\n  }\n\n  if (__kmp_str_match(\"tas\", 2, value) ||\n      __kmp_str_match(\"test and set\", 2, value) ||\n      __kmp_str_match(\"test_and_set\", 2, value) ||\n      __kmp_str_match(\"test-and-set\", 2, value) ||\n      __kmp_str_match(\"test andset\", 2, value) ||\n      __kmp_str_match(\"test_andset\", 2, value) ||\n      __kmp_str_match(\"test-andset\", 2, value) ||\n      __kmp_str_match(\"testand set\", 2, value) ||\n      __kmp_str_match(\"testand_set\", 2, value) ||\n      __kmp_str_match(\"testand-set\", 2, value) ||\n      __kmp_str_match(\"testandset\", 2, value)) {\n    __kmp_user_lock_kind = lk_tas;\n    KMP_STORE_LOCK_SEQ(tas);\n  }\n#if KMP_USE_FUTEX\n  else if (__kmp_str_match(\"futex\", 1, value)) {\n    if (__kmp_futex_determine_capable()) {\n      __kmp_user_lock_kind = lk_futex;\n      KMP_STORE_LOCK_SEQ(futex);\n    } else {\n      KMP_WARNING(FutexNotSupported, name, value);\n    }\n  }\n#endif\n  else if (__kmp_str_match(\"ticket\", 2, value)) {\n    __kmp_user_lock_kind = lk_ticket;\n    KMP_STORE_LOCK_SEQ(ticket);\n  } else if (__kmp_str_match(\"queuing\", 1, value) ||\n             __kmp_str_match(\"queue\", 1, value)) {\n    __kmp_user_lock_kind = lk_queuing;\n    KMP_STORE_LOCK_SEQ(queuing);\n  } else if (__kmp_str_match(\"drdpa ticket\", 1, value) ||\n             __kmp_str_match(\"drdpa_ticket\", 1, value) ||\n             __kmp_str_match(\"drdpa-ticket\", 1, value) ||\n             __kmp_str_match(\"drdpaticket\", 1, value) ||\n             __kmp_str_match(\"drdpa\", 1, value)) {\n    __kmp_user_lock_kind = lk_drdpa;\n    KMP_STORE_LOCK_SEQ(drdpa);\n  }\n#if KMP_USE_ADAPTIVE_LOCKS\n  else if (__kmp_str_match(\"adaptive\", 1, value)) {\n    if (__kmp_cpuinfo.rtm) { // ??? Is cpuinfo available here?\n      __kmp_user_lock_kind = lk_adaptive;\n      KMP_STORE_LOCK_SEQ(adaptive);\n    } else {\n      KMP_WARNING(AdaptiveNotSupported, name, value);\n      __kmp_user_lock_kind = lk_queuing;\n      KMP_STORE_LOCK_SEQ(queuing);\n    }\n  }\n#endif // KMP_USE_ADAPTIVE_LOCKS\n#if KMP_USE_DYNAMIC_LOCK && KMP_USE_TSX\n  else if (__kmp_str_match(\"rtm_queuing\", 1, value)) {\n    if (__kmp_cpuinfo.rtm) {\n      __kmp_user_lock_kind = lk_rtm_queuing;\n      KMP_STORE_LOCK_SEQ(rtm_queuing);\n    } else {\n      KMP_WARNING(AdaptiveNotSupported, name, value);\n      __kmp_user_lock_kind = lk_queuing;\n      KMP_STORE_LOCK_SEQ(queuing);\n    }\n  } else if (__kmp_str_match(\"rtm_spin\", 1, value)) {\n    if (__kmp_cpuinfo.rtm) {\n      __kmp_user_lock_kind = lk_rtm_spin;\n      KMP_STORE_LOCK_SEQ(rtm_spin);\n    } else {\n      KMP_WARNING(AdaptiveNotSupported, name, value);\n      __kmp_user_lock_kind = lk_tas;\n      KMP_STORE_LOCK_SEQ(queuing);\n    }\n  } else if (__kmp_str_match(\"hle\", 1, value)) {\n    __kmp_user_lock_kind = lk_hle;\n    KMP_STORE_LOCK_SEQ(hle);\n  }\n#endif\n  else {\n    KMP_WARNING(StgInvalidValue, name, value);\n  }\n}\n\nstatic void __kmp_stg_print_lock_kind(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  const char *value = NULL;\n\n  switch (__kmp_user_lock_kind) {\n  case lk_default:\n    value = \"default\";\n    break;\n\n  case lk_tas:\n    value = \"tas\";\n    break;\n\n#if KMP_USE_FUTEX\n  case lk_futex:\n    value = \"futex\";\n    break;\n#endif\n\n#if KMP_USE_DYNAMIC_LOCK && KMP_USE_TSX\n  case lk_rtm_queuing:\n    value = \"rtm_queuing\";\n    break;\n\n  case lk_rtm_spin:\n    value = \"rtm_spin\";\n    break;\n\n  case lk_hle:\n    value = \"hle\";\n    break;\n#endif\n\n  case lk_ticket:\n    value = \"ticket\";\n    break;\n\n  case lk_queuing:\n    value = \"queuing\";\n    break;\n\n  case lk_drdpa:\n    value = \"drdpa\";\n    break;\n#if KMP_USE_ADAPTIVE_LOCKS\n  case lk_adaptive:\n    value = \"adaptive\";\n    break;\n#endif\n  }\n\n  if (value != NULL) {\n    __kmp_stg_print_str(buffer, name, value);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// KMP_SPIN_BACKOFF_PARAMS\n\n// KMP_SPIN_BACKOFF_PARAMS=max_backoff[,min_tick] (max backoff size, min tick\n// for machine pause)\nstatic void __kmp_stg_parse_spin_backoff_params(const char *name,\n                                                const char *value, void *data) {\n  const char *next = value;\n\n  int total = 0; // Count elements that were set. It'll be used as an array size\n  int prev_comma = FALSE; // For correct processing sequential commas\n  int i;\n\n  kmp_uint32 max_backoff = __kmp_spin_backoff_params.max_backoff;\n  kmp_uint32 min_tick = __kmp_spin_backoff_params.min_tick;\n\n  // Run only 3 iterations because it is enough to read two values or find a\n  // syntax error\n  for (i = 0; i < 3; i++) {\n    SKIP_WS(next);\n\n    if (*next == '\\0') {\n      break;\n    }\n    // Next character is not an integer or not a comma OR number of values > 2\n    // => end of list\n    if (((*next < '0' || *next > '9') && *next != ',') || total > 2) {\n      KMP_WARNING(EnvSyntaxError, name, value);\n      return;\n    }\n    // The next character is ','\n    if (*next == ',') {\n      // ',' is the first character\n      if (total == 0 || prev_comma) {\n        total++;\n      }\n      prev_comma = TRUE;\n      next++; // skip ','\n      SKIP_WS(next);\n    }\n    // Next character is a digit\n    if (*next >= '0' && *next <= '9') {\n      int num;\n      const char *buf = next;\n      char const *msg = NULL;\n      prev_comma = FALSE;\n      SKIP_DIGITS(next);\n      total++;\n\n      const char *tmp = next;\n      SKIP_WS(tmp);\n      if ((*next == ' ' || *next == '\\t') && (*tmp >= '0' && *tmp <= '9')) {\n        KMP_WARNING(EnvSpacesNotAllowed, name, value);\n        return;\n      }\n\n      num = __kmp_str_to_int(buf, *next);\n      if (num <= 0) { // The number of retries should be > 0\n        msg = KMP_I18N_STR(ValueTooSmall);\n        num = 1;\n      } else if (num > KMP_INT_MAX) {\n        msg = KMP_I18N_STR(ValueTooLarge);\n        num = KMP_INT_MAX;\n      }\n      if (msg != NULL) {\n        // Message is not empty. Print warning.\n        KMP_WARNING(ParseSizeIntWarn, name, value, msg);\n        KMP_INFORM(Using_int_Value, name, num);\n      }\n      if (total == 1) {\n        max_backoff = num;\n      } else if (total == 2) {\n        min_tick = num;\n      }\n    }\n  }\n  KMP_DEBUG_ASSERT(total > 0);\n  if (total <= 0) {\n    KMP_WARNING(EnvSyntaxError, name, value);\n    return;\n  }\n  __kmp_spin_backoff_params.max_backoff = max_backoff;\n  __kmp_spin_backoff_params.min_tick = min_tick;\n}\n\nstatic void __kmp_stg_print_spin_backoff_params(kmp_str_buf_t *buffer,\n                                                char const *name, void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s='\", name);\n  }\n  __kmp_str_buf_print(buffer, \"%d,%d'\\n\", __kmp_spin_backoff_params.max_backoff,\n                      __kmp_spin_backoff_params.min_tick);\n}\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\n// -----------------------------------------------------------------------------\n// KMP_ADAPTIVE_LOCK_PROPS, KMP_SPECULATIVE_STATSFILE\n\n// Parse out values for the tunable parameters from a string of the form\n// KMP_ADAPTIVE_LOCK_PROPS=max_soft_retries[,max_badness]\nstatic void __kmp_stg_parse_adaptive_lock_props(const char *name,\n                                                const char *value, void *data) {\n  int max_retries = 0;\n  int max_badness = 0;\n\n  const char *next = value;\n\n  int total = 0; // Count elements that were set. It'll be used as an array size\n  int prev_comma = FALSE; // For correct processing sequential commas\n  int i;\n\n  // Save values in the structure __kmp_speculative_backoff_params\n  // Run only 3 iterations because it is enough to read two values or find a\n  // syntax error\n  for (i = 0; i < 3; i++) {\n    SKIP_WS(next);\n\n    if (*next == '\\0') {\n      break;\n    }\n    // Next character is not an integer or not a comma OR number of values > 2\n    // => end of list\n    if (((*next < '0' || *next > '9') && *next != ',') || total > 2) {\n      KMP_WARNING(EnvSyntaxError, name, value);\n      return;\n    }\n    // The next character is ','\n    if (*next == ',') {\n      // ',' is the first character\n      if (total == 0 || prev_comma) {\n        total++;\n      }\n      prev_comma = TRUE;\n      next++; // skip ','\n      SKIP_WS(next);\n    }\n    // Next character is a digit\n    if (*next >= '0' && *next <= '9') {\n      int num;\n      const char *buf = next;\n      char const *msg = NULL;\n      prev_comma = FALSE;\n      SKIP_DIGITS(next);\n      total++;\n\n      const char *tmp = next;\n      SKIP_WS(tmp);\n      if ((*next == ' ' || *next == '\\t') && (*tmp >= '0' && *tmp <= '9')) {\n        KMP_WARNING(EnvSpacesNotAllowed, name, value);\n        return;\n      }\n\n      num = __kmp_str_to_int(buf, *next);\n      if (num < 0) { // The number of retries should be >= 0\n        msg = KMP_I18N_STR(ValueTooSmall);\n        num = 1;\n      } else if (num > KMP_INT_MAX) {\n        msg = KMP_I18N_STR(ValueTooLarge);\n        num = KMP_INT_MAX;\n      }\n      if (msg != NULL) {\n        // Message is not empty. Print warning.\n        KMP_WARNING(ParseSizeIntWarn, name, value, msg);\n        KMP_INFORM(Using_int_Value, name, num);\n      }\n      if (total == 1) {\n        max_retries = num;\n      } else if (total == 2) {\n        max_badness = num;\n      }\n    }\n  }\n  KMP_DEBUG_ASSERT(total > 0);\n  if (total <= 0) {\n    KMP_WARNING(EnvSyntaxError, name, value);\n    return;\n  }\n  __kmp_adaptive_backoff_params.max_soft_retries = max_retries;\n  __kmp_adaptive_backoff_params.max_badness = max_badness;\n}\n\nstatic void __kmp_stg_print_adaptive_lock_props(kmp_str_buf_t *buffer,\n                                                char const *name, void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_NAME_EX(name);\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s='\", name);\n  }\n  __kmp_str_buf_print(buffer, \"%d,%d'\\n\",\n                      __kmp_adaptive_backoff_params.max_soft_retries,\n                      __kmp_adaptive_backoff_params.max_badness);\n} // __kmp_stg_print_adaptive_lock_props\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n\nstatic void __kmp_stg_parse_speculative_statsfile(char const *name,\n                                                  char const *value,\n                                                  void *data) {\n  __kmp_stg_parse_file(name, value, \"\",\n                       CCAST(char **, &__kmp_speculative_statsfile));\n} // __kmp_stg_parse_speculative_statsfile\n\nstatic void __kmp_stg_print_speculative_statsfile(kmp_str_buf_t *buffer,\n                                                  char const *name,\n                                                  void *data) {\n  if (__kmp_str_match(\"-\", 0, __kmp_speculative_statsfile)) {\n    __kmp_stg_print_str(buffer, name, \"stdout\");\n  } else {\n    __kmp_stg_print_str(buffer, name, __kmp_speculative_statsfile);\n  }\n\n} // __kmp_stg_print_speculative_statsfile\n\n#endif // KMP_DEBUG_ADAPTIVE_LOCKS\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\n// -----------------------------------------------------------------------------\n// KMP_HW_SUBSET (was KMP_PLACE_THREADS)\n\n// The longest observable sequence of items is\n// Socket-Node-Tile-Core-Thread\n// So, let's limit to 5 levels for now\n// The input string is usually short enough, let's use 512 limit for now\n#define MAX_T_LEVEL 5\n#define MAX_STR_LEN 512\nstatic void __kmp_stg_parse_hw_subset(char const *name, char const *value,\n                                      void *data) {\n  // Value example: 1s,5c@3,2T\n  // Which means \"use 1 socket, 5 cores with offset 3, 2 threads per core\"\n  kmp_setting_t **rivals = (kmp_setting_t **)data;\n  if (strcmp(name, \"KMP_PLACE_THREADS\") == 0) {\n    KMP_INFORM(EnvVarDeprecated, name, \"KMP_HW_SUBSET\");\n  }\n  if (__kmp_stg_check_rivals(name, value, rivals)) {\n    return;\n  }\n\n  char *components[MAX_T_LEVEL];\n  char const *digits = \"0123456789\";\n  char input[MAX_STR_LEN];\n  size_t len = 0, mlen = MAX_STR_LEN;\n  int level = 0;\n  // Canonize the string (remove spaces, unify delimiters, etc.)\n  char *pos = CCAST(char *, value);\n  while (*pos && mlen) {\n    if (*pos != ' ') { // skip spaces\n      if (len == 0 && *pos == ':') {\n        __kmp_hws_abs_flag = 1; // if the first symbol is \":\", skip it\n      } else {\n        input[len] = (char)(toupper(*pos));\n        if (input[len] == 'X')\n          input[len] = ','; // unify delimiters of levels\n        if (input[len] == 'O' && strchr(digits, *(pos + 1)))\n          input[len] = '@'; // unify delimiters of offset\n        len++;\n      }\n    }\n    mlen--;\n    pos++;\n  }\n  if (len == 0 || mlen == 0)\n    goto err; // contents is either empty or too long\n  input[len] = '\\0';\n  __kmp_hws_requested = 1; // mark that subset requested\n  // Split by delimiter\n  pos = input;\n  components[level++] = pos;\n  while ((pos = strchr(pos, ','))) {\n    if (level >= MAX_T_LEVEL)\n      goto err; // too many components provided\n    *pos = '\\0'; // modify input and avoid more copying\n    components[level++] = ++pos; // expect something after \",\"\n  }\n  // Check each component\n  for (int i = 0; i < level; ++i) {\n    int offset = 0;\n    int num = atoi(components[i]); // each component should start with a number\n    if ((pos = strchr(components[i], '@'))) {\n      offset = atoi(pos + 1); // save offset\n      *pos = '\\0'; // cut the offset from the component\n    }\n    pos = components[i] + strspn(components[i], digits);\n    if (pos == components[i])\n      goto err;\n    // detect the component type\n    switch (*pos) {\n    case 'S': // Socket\n      if (__kmp_hws_socket.num > 0)\n        goto err; // duplicate is not allowed\n      __kmp_hws_socket.num = num;\n      __kmp_hws_socket.offset = offset;\n      break;\n    case 'N': // NUMA Node\n      if (__kmp_hws_node.num > 0)\n        goto err; // duplicate is not allowed\n      __kmp_hws_node.num = num;\n      __kmp_hws_node.offset = offset;\n      break;\n    case 'D': // Die\n      if (__kmp_hws_die.num > 0)\n        goto err; // duplicate is not allowed\n      __kmp_hws_die.num = num;\n      __kmp_hws_die.offset = offset;\n      break;\n    case 'L': // Cache\n      if (*(pos + 1) == '2') { // L2 - Tile\n        if (__kmp_hws_tile.num > 0)\n          goto err; // duplicate is not allowed\n        __kmp_hws_tile.num = num;\n        __kmp_hws_tile.offset = offset;\n      } else if (*(pos + 1) == '3') { // L3 - Socket\n        if (__kmp_hws_socket.num > 0 || __kmp_hws_die.num > 0)\n          goto err; // duplicate is not allowed\n        __kmp_hws_socket.num = num;\n        __kmp_hws_socket.offset = offset;\n      } else if (*(pos + 1) == '1') { // L1 - Core\n        if (__kmp_hws_core.num > 0)\n          goto err; // duplicate is not allowed\n        __kmp_hws_core.num = num;\n        __kmp_hws_core.offset = offset;\n      }\n      break;\n    case 'C': // Core (or Cache?)\n      if (*(pos + 1) != 'A') {\n        if (__kmp_hws_core.num > 0)\n          goto err; // duplicate is not allowed\n        __kmp_hws_core.num = num;\n        __kmp_hws_core.offset = offset;\n      } else { // Cache\n        char *d = pos + strcspn(pos, digits); // find digit\n        if (*d == '2') { // L2 - Tile\n          if (__kmp_hws_tile.num > 0)\n            goto err; // duplicate is not allowed\n          __kmp_hws_tile.num = num;\n          __kmp_hws_tile.offset = offset;\n        } else if (*d == '3') { // L3 - Socket\n          if (__kmp_hws_socket.num > 0 || __kmp_hws_die.num > 0)\n            goto err; // duplicate is not allowed\n          __kmp_hws_socket.num = num;\n          __kmp_hws_socket.offset = offset;\n        } else if (*d == '1') { // L1 - Core\n          if (__kmp_hws_core.num > 0)\n            goto err; // duplicate is not allowed\n          __kmp_hws_core.num = num;\n          __kmp_hws_core.offset = offset;\n        } else {\n          goto err;\n        }\n      }\n      break;\n    case 'T': // Thread\n      if (__kmp_hws_proc.num > 0)\n        goto err; // duplicate is not allowed\n      __kmp_hws_proc.num = num;\n      __kmp_hws_proc.offset = offset;\n      break;\n    default:\n      goto err;\n    }\n  }\n  return;\nerr:\n  KMP_WARNING(AffHWSubsetInvalid, name, value);\n  __kmp_hws_requested = 0; // mark that subset not requested\n  return;\n}\n\nstatic void __kmp_stg_print_hw_subset(kmp_str_buf_t *buffer, char const *name,\n                                      void *data) {\n  if (__kmp_hws_requested) {\n    int comma = 0;\n    kmp_str_buf_t buf;\n    __kmp_str_buf_init(&buf);\n    if (__kmp_env_format)\n      KMP_STR_BUF_PRINT_NAME_EX(name);\n    else\n      __kmp_str_buf_print(buffer, \"   %s='\", name);\n    if (__kmp_hws_socket.num) {\n      __kmp_str_buf_print(&buf, \"%ds\", __kmp_hws_socket.num);\n      if (__kmp_hws_socket.offset)\n        __kmp_str_buf_print(&buf, \"@%d\", __kmp_hws_socket.offset);\n      comma = 1;\n    }\n    if (__kmp_hws_die.num) {\n      __kmp_str_buf_print(&buf, \"%s%dd\", comma ? \",\" : \"\", __kmp_hws_die.num);\n      if (__kmp_hws_die.offset)\n        __kmp_str_buf_print(&buf, \"@%d\", __kmp_hws_die.offset);\n      comma = 1;\n    }\n    if (__kmp_hws_node.num) {\n      __kmp_str_buf_print(&buf, \"%s%dn\", comma ? \",\" : \"\", __kmp_hws_node.num);\n      if (__kmp_hws_node.offset)\n        __kmp_str_buf_print(&buf, \"@%d\", __kmp_hws_node.offset);\n      comma = 1;\n    }\n    if (__kmp_hws_tile.num) {\n      __kmp_str_buf_print(&buf, \"%s%dL2\", comma ? \",\" : \"\", __kmp_hws_tile.num);\n      if (__kmp_hws_tile.offset)\n        __kmp_str_buf_print(&buf, \"@%d\", __kmp_hws_tile.offset);\n      comma = 1;\n    }\n    if (__kmp_hws_core.num) {\n      __kmp_str_buf_print(&buf, \"%s%dc\", comma ? \",\" : \"\", __kmp_hws_core.num);\n      if (__kmp_hws_core.offset)\n        __kmp_str_buf_print(&buf, \"@%d\", __kmp_hws_core.offset);\n      comma = 1;\n    }\n    if (__kmp_hws_proc.num)\n      __kmp_str_buf_print(&buf, \"%s%dt\", comma ? \",\" : \"\", __kmp_hws_proc.num);\n    __kmp_str_buf_print(buffer, \"%s'\\n\", buf.str);\n    __kmp_str_buf_free(&buf);\n  }\n}\n\n#if USE_ITT_BUILD\n// -----------------------------------------------------------------------------\n// KMP_FORKJOIN_FRAMES\n\nstatic void __kmp_stg_parse_forkjoin_frames(char const *name, char const *value,\n                                            void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_forkjoin_frames);\n} // __kmp_stg_parse_forkjoin_frames\n\nstatic void __kmp_stg_print_forkjoin_frames(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_forkjoin_frames);\n} // __kmp_stg_print_forkjoin_frames\n\n// -----------------------------------------------------------------------------\n// KMP_FORKJOIN_FRAMES_MODE\n\nstatic void __kmp_stg_parse_forkjoin_frames_mode(char const *name,\n                                                 char const *value,\n                                                 void *data) {\n  __kmp_stg_parse_int(name, value, 0, 3, &__kmp_forkjoin_frames_mode);\n} // __kmp_stg_parse_forkjoin_frames\n\nstatic void __kmp_stg_print_forkjoin_frames_mode(kmp_str_buf_t *buffer,\n                                                 char const *name, void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_forkjoin_frames_mode);\n} // __kmp_stg_print_forkjoin_frames\n#endif /* USE_ITT_BUILD */\n\n// -----------------------------------------------------------------------------\n// KMP_ENABLE_TASK_THROTTLING\n\nstatic void __kmp_stg_parse_task_throttling(char const *name, char const *value,\n                                            void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_enable_task_throttling);\n} // __kmp_stg_parse_task_throttling\n\nstatic void __kmp_stg_print_task_throttling(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_enable_task_throttling);\n} // __kmp_stg_print_task_throttling\n\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\n// -----------------------------------------------------------------------------\n// KMP_USER_LEVEL_MWAIT\n\nstatic void __kmp_stg_parse_user_level_mwait(char const *name,\n                                             char const *value, void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_user_level_mwait);\n} // __kmp_stg_parse_user_level_mwait\n\nstatic void __kmp_stg_print_user_level_mwait(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_user_level_mwait);\n} // __kmp_stg_print_user_level_mwait\n\n// -----------------------------------------------------------------------------\n// KMP_MWAIT_HINTS\n\nstatic void __kmp_stg_parse_mwait_hints(char const *name, char const *value,\n                                        void *data) {\n  __kmp_stg_parse_int(name, value, 0, INT_MAX, &__kmp_mwait_hints);\n} // __kmp_stg_parse_mwait_hints\n\nstatic void __kmp_stg_print_mwait_hints(kmp_str_buf_t *buffer, char const *name,\n                                        void *data) {\n  __kmp_stg_print_int(buffer, name, __kmp_mwait_hints);\n} // __kmp_stg_print_mwait_hints\n\n#endif // KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\n\n// -----------------------------------------------------------------------------\n// OMP_DISPLAY_ENV\n\nstatic void __kmp_stg_parse_omp_display_env(char const *name, char const *value,\n                                            void *data) {\n  if (__kmp_str_match(\"VERBOSE\", 1, value)) {\n    __kmp_display_env_verbose = TRUE;\n  } else {\n    __kmp_stg_parse_bool(name, value, &__kmp_display_env);\n  }\n} // __kmp_stg_parse_omp_display_env\n\nstatic void __kmp_stg_print_omp_display_env(kmp_str_buf_t *buffer,\n                                            char const *name, void *data) {\n  if (__kmp_display_env_verbose) {\n    __kmp_stg_print_str(buffer, name, \"VERBOSE\");\n  } else {\n    __kmp_stg_print_bool(buffer, name, __kmp_display_env);\n  }\n} // __kmp_stg_print_omp_display_env\n\nstatic void __kmp_stg_parse_omp_cancellation(char const *name,\n                                             char const *value, void *data) {\n  if (TCR_4(__kmp_init_parallel)) {\n    KMP_WARNING(EnvParallelWarn, name);\n    return;\n  } // read value before first parallel only\n  __kmp_stg_parse_bool(name, value, &__kmp_omp_cancellation);\n} // __kmp_stg_parse_omp_cancellation\n\nstatic void __kmp_stg_print_omp_cancellation(kmp_str_buf_t *buffer,\n                                             char const *name, void *data) {\n  __kmp_stg_print_bool(buffer, name, __kmp_omp_cancellation);\n} // __kmp_stg_print_omp_cancellation\n\n#if OMPT_SUPPORT\nstatic int __kmp_tool = 1;\n\nstatic void __kmp_stg_parse_omp_tool(char const *name, char const *value,\n                                     void *data) {\n  __kmp_stg_parse_bool(name, value, &__kmp_tool);\n} // __kmp_stg_parse_omp_tool\n\nstatic void __kmp_stg_print_omp_tool(kmp_str_buf_t *buffer, char const *name,\n                                     void *data) {\n  if (__kmp_env_format) {\n    KMP_STR_BUF_PRINT_BOOL_EX(name, __kmp_tool, \"enabled\", \"disabled\");\n  } else {\n    __kmp_str_buf_print(buffer, \"   %s=%s\\n\", name,\n                        __kmp_tool ? \"enabled\" : \"disabled\");\n  }\n} // __kmp_stg_print_omp_tool\n\nstatic char *__kmp_tool_libraries = NULL;\n\nstatic void __kmp_stg_parse_omp_tool_libraries(char const *name,\n                                               char const *value, void *data) {\n  __kmp_stg_parse_str(name, value, &__kmp_tool_libraries);\n} // __kmp_stg_parse_omp_tool_libraries\n\nstatic void __kmp_stg_print_omp_tool_libraries(kmp_str_buf_t *buffer,\n                                               char const *name, void *data) {\n  if (__kmp_tool_libraries)\n    __kmp_stg_print_str(buffer, name, __kmp_tool_libraries);\n  else {\n    if (__kmp_env_format) {\n      KMP_STR_BUF_PRINT_NAME;\n    } else {\n      __kmp_str_buf_print(buffer, \"   %s\", name);\n    }\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  }\n} // __kmp_stg_print_omp_tool_libraries\n\nstatic char *__kmp_tool_verbose_init = NULL;\n\nstatic void __kmp_stg_parse_omp_tool_verbose_init(char const *name,\n                                                  char const *value,\n                                                  void *data) {\n  __kmp_stg_parse_str(name, value, &__kmp_tool_verbose_init);\n} // __kmp_stg_parse_omp_tool_libraries\n\nstatic void __kmp_stg_print_omp_tool_verbose_init(kmp_str_buf_t *buffer,\n                                                  char const *name,\n                                                  void *data) {\n  if (__kmp_tool_verbose_init)\n    __kmp_stg_print_str(buffer, name, __kmp_tool_libraries);\n  else {\n    if (__kmp_env_format) {\n      KMP_STR_BUF_PRINT_NAME;\n    } else {\n      __kmp_str_buf_print(buffer, \"   %s\", name);\n    }\n    __kmp_str_buf_print(buffer, \": %s\\n\", KMP_I18N_STR(NotDefined));\n  }\n} // __kmp_stg_print_omp_tool_verbose_init\n\n#endif\n\n// Table.\n\nstatic kmp_setting_t __kmp_stg_table[] = {\n\n    {\"KMP_ALL_THREADS\", __kmp_stg_parse_device_thread_limit, NULL, NULL, 0, 0},\n    {\"KMP_BLOCKTIME\", __kmp_stg_parse_blocktime, __kmp_stg_print_blocktime,\n     NULL, 0, 0},\n    {\"KMP_USE_YIELD\", __kmp_stg_parse_use_yield, __kmp_stg_print_use_yield,\n     NULL, 0, 0},\n    {\"KMP_DUPLICATE_LIB_OK\", __kmp_stg_parse_duplicate_lib_ok,\n     __kmp_stg_print_duplicate_lib_ok, NULL, 0, 0},\n    {\"KMP_LIBRARY\", __kmp_stg_parse_wait_policy, __kmp_stg_print_wait_policy,\n     NULL, 0, 0},\n    {\"KMP_DEVICE_THREAD_LIMIT\", __kmp_stg_parse_device_thread_limit,\n     __kmp_stg_print_device_thread_limit, NULL, 0, 0},\n#if KMP_USE_MONITOR\n    {\"KMP_MONITOR_STACKSIZE\", __kmp_stg_parse_monitor_stacksize,\n     __kmp_stg_print_monitor_stacksize, NULL, 0, 0},\n#endif\n    {\"KMP_SETTINGS\", __kmp_stg_parse_settings, __kmp_stg_print_settings, NULL,\n     0, 0},\n    {\"KMP_STACKOFFSET\", __kmp_stg_parse_stackoffset,\n     __kmp_stg_print_stackoffset, NULL, 0, 0},\n    {\"KMP_STACKSIZE\", __kmp_stg_parse_stacksize, __kmp_stg_print_stacksize,\n     NULL, 0, 0},\n    {\"KMP_STACKPAD\", __kmp_stg_parse_stackpad, __kmp_stg_print_stackpad, NULL,\n     0, 0},\n    {\"KMP_VERSION\", __kmp_stg_parse_version, __kmp_stg_print_version, NULL, 0,\n     0},\n    {\"KMP_WARNINGS\", __kmp_stg_parse_warnings, __kmp_stg_print_warnings, NULL,\n     0, 0},\n\n    {\"OMP_NESTED\", __kmp_stg_parse_nested, __kmp_stg_print_nested, NULL, 0, 0},\n    {\"OMP_NUM_THREADS\", __kmp_stg_parse_num_threads,\n     __kmp_stg_print_num_threads, NULL, 0, 0},\n    {\"OMP_STACKSIZE\", __kmp_stg_parse_stacksize, __kmp_stg_print_stacksize,\n     NULL, 0, 0},\n\n    {\"KMP_TASKING\", __kmp_stg_parse_tasking, __kmp_stg_print_tasking, NULL, 0,\n     0},\n    {\"KMP_TASK_STEALING_CONSTRAINT\", __kmp_stg_parse_task_stealing,\n     __kmp_stg_print_task_stealing, NULL, 0, 0},\n    {\"OMP_MAX_ACTIVE_LEVELS\", __kmp_stg_parse_max_active_levels,\n     __kmp_stg_print_max_active_levels, NULL, 0, 0},\n    {\"OMP_DEFAULT_DEVICE\", __kmp_stg_parse_default_device,\n     __kmp_stg_print_default_device, NULL, 0, 0},\n    {\"OMP_TARGET_OFFLOAD\", __kmp_stg_parse_target_offload,\n     __kmp_stg_print_target_offload, NULL, 0, 0},\n    {\"OMP_MAX_TASK_PRIORITY\", __kmp_stg_parse_max_task_priority,\n     __kmp_stg_print_max_task_priority, NULL, 0, 0},\n    {\"KMP_TASKLOOP_MIN_TASKS\", __kmp_stg_parse_taskloop_min_tasks,\n     __kmp_stg_print_taskloop_min_tasks, NULL, 0, 0},\n    {\"OMP_THREAD_LIMIT\", __kmp_stg_parse_thread_limit,\n     __kmp_stg_print_thread_limit, NULL, 0, 0},\n    {\"KMP_TEAMS_THREAD_LIMIT\", __kmp_stg_parse_teams_thread_limit,\n     __kmp_stg_print_teams_thread_limit, NULL, 0, 0},\n    {\"OMP_NUM_TEAMS\", __kmp_stg_parse_nteams, __kmp_stg_print_nteams, NULL, 0,\n     0},\n    {\"OMP_TEAMS_THREAD_LIMIT\", __kmp_stg_parse_teams_th_limit,\n     __kmp_stg_print_teams_th_limit, NULL, 0, 0},\n    {\"OMP_WAIT_POLICY\", __kmp_stg_parse_wait_policy,\n     __kmp_stg_print_wait_policy, NULL, 0, 0},\n    {\"KMP_DISP_NUM_BUFFERS\", __kmp_stg_parse_disp_buffers,\n     __kmp_stg_print_disp_buffers, NULL, 0, 0},\n#if KMP_NESTED_HOT_TEAMS\n    {\"KMP_HOT_TEAMS_MAX_LEVEL\", __kmp_stg_parse_hot_teams_level,\n     __kmp_stg_print_hot_teams_level, NULL, 0, 0},\n    {\"KMP_HOT_TEAMS_MODE\", __kmp_stg_parse_hot_teams_mode,\n     __kmp_stg_print_hot_teams_mode, NULL, 0, 0},\n#endif // KMP_NESTED_HOT_TEAMS\n\n#if KMP_HANDLE_SIGNALS\n    {\"KMP_HANDLE_SIGNALS\", __kmp_stg_parse_handle_signals,\n     __kmp_stg_print_handle_signals, NULL, 0, 0},\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n    {\"KMP_INHERIT_FP_CONTROL\", __kmp_stg_parse_inherit_fp_control,\n     __kmp_stg_print_inherit_fp_control, NULL, 0, 0},\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n#ifdef KMP_GOMP_COMPAT\n    {\"GOMP_STACKSIZE\", __kmp_stg_parse_stacksize, NULL, NULL, 0, 0},\n#endif\n\n#ifdef KMP_DEBUG\n    {\"KMP_A_DEBUG\", __kmp_stg_parse_a_debug, __kmp_stg_print_a_debug, NULL, 0,\n     0},\n    {\"KMP_B_DEBUG\", __kmp_stg_parse_b_debug, __kmp_stg_print_b_debug, NULL, 0,\n     0},\n    {\"KMP_C_DEBUG\", __kmp_stg_parse_c_debug, __kmp_stg_print_c_debug, NULL, 0,\n     0},\n    {\"KMP_D_DEBUG\", __kmp_stg_parse_d_debug, __kmp_stg_print_d_debug, NULL, 0,\n     0},\n    {\"KMP_E_DEBUG\", __kmp_stg_parse_e_debug, __kmp_stg_print_e_debug, NULL, 0,\n     0},\n    {\"KMP_F_DEBUG\", __kmp_stg_parse_f_debug, __kmp_stg_print_f_debug, NULL, 0,\n     0},\n    {\"KMP_DEBUG\", __kmp_stg_parse_debug, NULL, /* no print */ NULL, 0, 0},\n    {\"KMP_DEBUG_BUF\", __kmp_stg_parse_debug_buf, __kmp_stg_print_debug_buf,\n     NULL, 0, 0},\n    {\"KMP_DEBUG_BUF_ATOMIC\", __kmp_stg_parse_debug_buf_atomic,\n     __kmp_stg_print_debug_buf_atomic, NULL, 0, 0},\n    {\"KMP_DEBUG_BUF_CHARS\", __kmp_stg_parse_debug_buf_chars,\n     __kmp_stg_print_debug_buf_chars, NULL, 0, 0},\n    {\"KMP_DEBUG_BUF_LINES\", __kmp_stg_parse_debug_buf_lines,\n     __kmp_stg_print_debug_buf_lines, NULL, 0, 0},\n    {\"KMP_DIAG\", __kmp_stg_parse_diag, __kmp_stg_print_diag, NULL, 0, 0},\n\n    {\"KMP_PAR_RANGE\", __kmp_stg_parse_par_range_env,\n     __kmp_stg_print_par_range_env, NULL, 0, 0},\n#endif // KMP_DEBUG\n\n    {\"KMP_ALIGN_ALLOC\", __kmp_stg_parse_align_alloc,\n     __kmp_stg_print_align_alloc, NULL, 0, 0},\n\n    {\"KMP_PLAIN_BARRIER\", __kmp_stg_parse_barrier_branch_bit,\n     __kmp_stg_print_barrier_branch_bit, NULL, 0, 0},\n    {\"KMP_PLAIN_BARRIER_PATTERN\", __kmp_stg_parse_barrier_pattern,\n     __kmp_stg_print_barrier_pattern, NULL, 0, 0},\n    {\"KMP_FORKJOIN_BARRIER\", __kmp_stg_parse_barrier_branch_bit,\n     __kmp_stg_print_barrier_branch_bit, NULL, 0, 0},\n    {\"KMP_FORKJOIN_BARRIER_PATTERN\", __kmp_stg_parse_barrier_pattern,\n     __kmp_stg_print_barrier_pattern, NULL, 0, 0},\n#if KMP_FAST_REDUCTION_BARRIER\n    {\"KMP_REDUCTION_BARRIER\", __kmp_stg_parse_barrier_branch_bit,\n     __kmp_stg_print_barrier_branch_bit, NULL, 0, 0},\n    {\"KMP_REDUCTION_BARRIER_PATTERN\", __kmp_stg_parse_barrier_pattern,\n     __kmp_stg_print_barrier_pattern, NULL, 0, 0},\n#endif\n\n    {\"KMP_ABORT_DELAY\", __kmp_stg_parse_abort_delay,\n     __kmp_stg_print_abort_delay, NULL, 0, 0},\n    {\"KMP_CPUINFO_FILE\", __kmp_stg_parse_cpuinfo_file,\n     __kmp_stg_print_cpuinfo_file, NULL, 0, 0},\n    {\"KMP_FORCE_REDUCTION\", __kmp_stg_parse_force_reduction,\n     __kmp_stg_print_force_reduction, NULL, 0, 0},\n    {\"KMP_DETERMINISTIC_REDUCTION\", __kmp_stg_parse_force_reduction,\n     __kmp_stg_print_force_reduction, NULL, 0, 0},\n    {\"KMP_STORAGE_MAP\", __kmp_stg_parse_storage_map,\n     __kmp_stg_print_storage_map, NULL, 0, 0},\n    {\"KMP_ALL_THREADPRIVATE\", __kmp_stg_parse_all_threadprivate,\n     __kmp_stg_print_all_threadprivate, NULL, 0, 0},\n    {\"KMP_FOREIGN_THREADS_THREADPRIVATE\",\n     __kmp_stg_parse_foreign_threads_threadprivate,\n     __kmp_stg_print_foreign_threads_threadprivate, NULL, 0, 0},\n\n#if KMP_AFFINITY_SUPPORTED\n    {\"KMP_AFFINITY\", __kmp_stg_parse_affinity, __kmp_stg_print_affinity, NULL,\n     0, 0},\n#ifdef KMP_GOMP_COMPAT\n    {\"GOMP_CPU_AFFINITY\", __kmp_stg_parse_gomp_cpu_affinity, NULL,\n     /* no print */ NULL, 0, 0},\n#endif /* KMP_GOMP_COMPAT */\n    {\"OMP_PROC_BIND\", __kmp_stg_parse_proc_bind, __kmp_stg_print_proc_bind,\n     NULL, 0, 0},\n    {\"OMP_PLACES\", __kmp_stg_parse_places, __kmp_stg_print_places, NULL, 0, 0},\n    {\"KMP_TOPOLOGY_METHOD\", __kmp_stg_parse_topology_method,\n     __kmp_stg_print_topology_method, NULL, 0, 0},\n\n#else\n\n    // KMP_AFFINITY is not supported on OS X*, nor is OMP_PLACES.\n    // OMP_PROC_BIND and proc-bind-var are supported, however.\n    {\"OMP_PROC_BIND\", __kmp_stg_parse_proc_bind, __kmp_stg_print_proc_bind,\n     NULL, 0, 0},\n\n#endif // KMP_AFFINITY_SUPPORTED\n    {\"OMP_DISPLAY_AFFINITY\", __kmp_stg_parse_display_affinity,\n     __kmp_stg_print_display_affinity, NULL, 0, 0},\n    {\"OMP_AFFINITY_FORMAT\", __kmp_stg_parse_affinity_format,\n     __kmp_stg_print_affinity_format, NULL, 0, 0},\n    {\"KMP_INIT_AT_FORK\", __kmp_stg_parse_init_at_fork,\n     __kmp_stg_print_init_at_fork, NULL, 0, 0},\n    {\"KMP_SCHEDULE\", __kmp_stg_parse_schedule, __kmp_stg_print_schedule, NULL,\n     0, 0},\n    {\"OMP_SCHEDULE\", __kmp_stg_parse_omp_schedule, __kmp_stg_print_omp_schedule,\n     NULL, 0, 0},\n#if KMP_USE_HIER_SCHED\n    {\"KMP_DISP_HAND_THREAD\", __kmp_stg_parse_kmp_hand_thread,\n     __kmp_stg_print_kmp_hand_thread, NULL, 0, 0},\n#endif\n    {\"KMP_FORCE_MONOTONIC_DYNAMIC_SCHEDULE\",\n     __kmp_stg_parse_kmp_force_monotonic, __kmp_stg_print_kmp_force_monotonic,\n     NULL, 0, 0},\n    {\"KMP_ATOMIC_MODE\", __kmp_stg_parse_atomic_mode,\n     __kmp_stg_print_atomic_mode, NULL, 0, 0},\n    {\"KMP_CONSISTENCY_CHECK\", __kmp_stg_parse_consistency_check,\n     __kmp_stg_print_consistency_check, NULL, 0, 0},\n\n#if USE_ITT_BUILD && USE_ITT_NOTIFY\n    {\"KMP_ITT_PREPARE_DELAY\", __kmp_stg_parse_itt_prepare_delay,\n     __kmp_stg_print_itt_prepare_delay, NULL, 0, 0},\n#endif /* USE_ITT_BUILD && USE_ITT_NOTIFY */\n    {\"KMP_MALLOC_POOL_INCR\", __kmp_stg_parse_malloc_pool_incr,\n     __kmp_stg_print_malloc_pool_incr, NULL, 0, 0},\n    {\"KMP_GTID_MODE\", __kmp_stg_parse_gtid_mode, __kmp_stg_print_gtid_mode,\n     NULL, 0, 0},\n    {\"OMP_DYNAMIC\", __kmp_stg_parse_omp_dynamic, __kmp_stg_print_omp_dynamic,\n     NULL, 0, 0},\n    {\"KMP_DYNAMIC_MODE\", __kmp_stg_parse_kmp_dynamic_mode,\n     __kmp_stg_print_kmp_dynamic_mode, NULL, 0, 0},\n\n#ifdef USE_LOAD_BALANCE\n    {\"KMP_LOAD_BALANCE_INTERVAL\", __kmp_stg_parse_ld_balance_interval,\n     __kmp_stg_print_ld_balance_interval, NULL, 0, 0},\n#endif\n\n    {\"KMP_NUM_LOCKS_IN_BLOCK\", __kmp_stg_parse_lock_block,\n     __kmp_stg_print_lock_block, NULL, 0, 0},\n    {\"KMP_LOCK_KIND\", __kmp_stg_parse_lock_kind, __kmp_stg_print_lock_kind,\n     NULL, 0, 0},\n    {\"KMP_SPIN_BACKOFF_PARAMS\", __kmp_stg_parse_spin_backoff_params,\n     __kmp_stg_print_spin_backoff_params, NULL, 0, 0},\n#if KMP_USE_ADAPTIVE_LOCKS\n    {\"KMP_ADAPTIVE_LOCK_PROPS\", __kmp_stg_parse_adaptive_lock_props,\n     __kmp_stg_print_adaptive_lock_props, NULL, 0, 0},\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n    {\"KMP_SPECULATIVE_STATSFILE\", __kmp_stg_parse_speculative_statsfile,\n     __kmp_stg_print_speculative_statsfile, NULL, 0, 0},\n#endif\n#endif // KMP_USE_ADAPTIVE_LOCKS\n    {\"KMP_PLACE_THREADS\", __kmp_stg_parse_hw_subset, __kmp_stg_print_hw_subset,\n     NULL, 0, 0},\n    {\"KMP_HW_SUBSET\", __kmp_stg_parse_hw_subset, __kmp_stg_print_hw_subset,\n     NULL, 0, 0},\n#if USE_ITT_BUILD\n    {\"KMP_FORKJOIN_FRAMES\", __kmp_stg_parse_forkjoin_frames,\n     __kmp_stg_print_forkjoin_frames, NULL, 0, 0},\n    {\"KMP_FORKJOIN_FRAMES_MODE\", __kmp_stg_parse_forkjoin_frames_mode,\n     __kmp_stg_print_forkjoin_frames_mode, NULL, 0, 0},\n#endif\n    {\"KMP_ENABLE_TASK_THROTTLING\", __kmp_stg_parse_task_throttling,\n     __kmp_stg_print_task_throttling, NULL, 0, 0},\n\n    {\"OMP_DISPLAY_ENV\", __kmp_stg_parse_omp_display_env,\n     __kmp_stg_print_omp_display_env, NULL, 0, 0},\n    {\"OMP_CANCELLATION\", __kmp_stg_parse_omp_cancellation,\n     __kmp_stg_print_omp_cancellation, NULL, 0, 0},\n    {\"OMP_ALLOCATOR\", __kmp_stg_parse_allocator, __kmp_stg_print_allocator,\n     NULL, 0, 0},\n    {\"LIBOMP_USE_HIDDEN_HELPER_TASK\", __kmp_stg_parse_use_hidden_helper,\n     __kmp_stg_print_use_hidden_helper, NULL, 0, 0},\n    {\"LIBOMP_NUM_HIDDEN_HELPER_THREADS\",\n     __kmp_stg_parse_num_hidden_helper_threads,\n     __kmp_stg_print_num_hidden_helper_threads, NULL, 0, 0},\n\n#if OMPT_SUPPORT\n    {\"OMP_TOOL\", __kmp_stg_parse_omp_tool, __kmp_stg_print_omp_tool, NULL, 0,\n     0},\n    {\"OMP_TOOL_LIBRARIES\", __kmp_stg_parse_omp_tool_libraries,\n     __kmp_stg_print_omp_tool_libraries, NULL, 0, 0},\n    {\"OMP_TOOL_VERBOSE_INIT\", __kmp_stg_parse_omp_tool_verbose_init,\n     __kmp_stg_print_omp_tool_verbose_init, NULL, 0, 0},\n#endif\n\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\n    {\"KMP_USER_LEVEL_MWAIT\", __kmp_stg_parse_user_level_mwait,\n     __kmp_stg_print_user_level_mwait, NULL, 0, 0},\n    {\"KMP_MWAIT_HINTS\", __kmp_stg_parse_mwait_hints,\n     __kmp_stg_print_mwait_hints, NULL, 0, 0},\n#endif\n    {\"\", NULL, NULL, NULL, 0, 0}}; // settings\n\nstatic int const __kmp_stg_count =\n    sizeof(__kmp_stg_table) / sizeof(kmp_setting_t);\n\nstatic inline kmp_setting_t *__kmp_stg_find(char const *name) {\n\n  int i;\n  if (name != NULL) {\n    for (i = 0; i < __kmp_stg_count; ++i) {\n      if (strcmp(__kmp_stg_table[i].name, name) == 0) {\n        return &__kmp_stg_table[i];\n      }\n    }\n  }\n  return NULL;\n\n} // __kmp_stg_find\n\nstatic int __kmp_stg_cmp(void const *_a, void const *_b) {\n  const kmp_setting_t *a = RCAST(const kmp_setting_t *, _a);\n  const kmp_setting_t *b = RCAST(const kmp_setting_t *, _b);\n\n  // Process KMP_AFFINITY last.\n  // It needs to come after OMP_PLACES and GOMP_CPU_AFFINITY.\n  if (strcmp(a->name, \"KMP_AFFINITY\") == 0) {\n    if (strcmp(b->name, \"KMP_AFFINITY\") == 0) {\n      return 0;\n    }\n    return 1;\n  } else if (strcmp(b->name, \"KMP_AFFINITY\") == 0) {\n    return -1;\n  }\n  return strcmp(a->name, b->name);\n} // __kmp_stg_cmp\n\nstatic void __kmp_stg_init(void) {\n\n  static int initialized = 0;\n\n  if (!initialized) {\n\n    // Sort table.\n    qsort(__kmp_stg_table, __kmp_stg_count - 1, sizeof(kmp_setting_t),\n          __kmp_stg_cmp);\n\n    { // Initialize *_STACKSIZE data.\n      kmp_setting_t *kmp_stacksize =\n          __kmp_stg_find(\"KMP_STACKSIZE\"); // 1st priority.\n#ifdef KMP_GOMP_COMPAT\n      kmp_setting_t *gomp_stacksize =\n          __kmp_stg_find(\"GOMP_STACKSIZE\"); // 2nd priority.\n#endif\n      kmp_setting_t *omp_stacksize =\n          __kmp_stg_find(\"OMP_STACKSIZE\"); // 3rd priority.\n\n      // !!! volatile keyword is Intel(R) C Compiler bug CQ49908 workaround.\n      // !!! Compiler does not understand rivals is used and optimizes out\n      // assignments\n      // !!!     rivals[ i ++ ] = ...;\n      static kmp_setting_t *volatile rivals[4];\n      static kmp_stg_ss_data_t kmp_data = {1, CCAST(kmp_setting_t **, rivals)};\n#ifdef KMP_GOMP_COMPAT\n      static kmp_stg_ss_data_t gomp_data = {1024,\n                                            CCAST(kmp_setting_t **, rivals)};\n#endif\n      static kmp_stg_ss_data_t omp_data = {1024,\n                                           CCAST(kmp_setting_t **, rivals)};\n      int i = 0;\n\n      rivals[i++] = kmp_stacksize;\n#ifdef KMP_GOMP_COMPAT\n      if (gomp_stacksize != NULL) {\n        rivals[i++] = gomp_stacksize;\n      }\n#endif\n      rivals[i++] = omp_stacksize;\n      rivals[i++] = NULL;\n\n      kmp_stacksize->data = &kmp_data;\n#ifdef KMP_GOMP_COMPAT\n      if (gomp_stacksize != NULL) {\n        gomp_stacksize->data = &gomp_data;\n      }\n#endif\n      omp_stacksize->data = &omp_data;\n    }\n\n    { // Initialize KMP_LIBRARY and OMP_WAIT_POLICY data.\n      kmp_setting_t *kmp_library =\n          __kmp_stg_find(\"KMP_LIBRARY\"); // 1st priority.\n      kmp_setting_t *omp_wait_policy =\n          __kmp_stg_find(\"OMP_WAIT_POLICY\"); // 2nd priority.\n\n      // !!! volatile keyword is Intel(R) C Compiler bug CQ49908 workaround.\n      static kmp_setting_t *volatile rivals[3];\n      static kmp_stg_wp_data_t kmp_data = {0, CCAST(kmp_setting_t **, rivals)};\n      static kmp_stg_wp_data_t omp_data = {1, CCAST(kmp_setting_t **, rivals)};\n      int i = 0;\n\n      rivals[i++] = kmp_library;\n      if (omp_wait_policy != NULL) {\n        rivals[i++] = omp_wait_policy;\n      }\n      rivals[i++] = NULL;\n\n      kmp_library->data = &kmp_data;\n      if (omp_wait_policy != NULL) {\n        omp_wait_policy->data = &omp_data;\n      }\n    }\n\n    { // Initialize KMP_DEVICE_THREAD_LIMIT and KMP_ALL_THREADS\n      kmp_setting_t *kmp_device_thread_limit =\n          __kmp_stg_find(\"KMP_DEVICE_THREAD_LIMIT\"); // 1st priority.\n      kmp_setting_t *kmp_all_threads =\n          __kmp_stg_find(\"KMP_ALL_THREADS\"); // 2nd priority.\n\n      // !!! volatile keyword is Intel(R) C Compiler bug CQ49908 workaround.\n      static kmp_setting_t *volatile rivals[3];\n      int i = 0;\n\n      rivals[i++] = kmp_device_thread_limit;\n      rivals[i++] = kmp_all_threads;\n      rivals[i++] = NULL;\n\n      kmp_device_thread_limit->data = CCAST(kmp_setting_t **, rivals);\n      kmp_all_threads->data = CCAST(kmp_setting_t **, rivals);\n    }\n\n    { // Initialize KMP_HW_SUBSET and KMP_PLACE_THREADS\n      // 1st priority\n      kmp_setting_t *kmp_hw_subset = __kmp_stg_find(\"KMP_HW_SUBSET\");\n      // 2nd priority\n      kmp_setting_t *kmp_place_threads = __kmp_stg_find(\"KMP_PLACE_THREADS\");\n\n      // !!! volatile keyword is Intel(R) C Compiler bug CQ49908 workaround.\n      static kmp_setting_t *volatile rivals[3];\n      int i = 0;\n\n      rivals[i++] = kmp_hw_subset;\n      rivals[i++] = kmp_place_threads;\n      rivals[i++] = NULL;\n\n      kmp_hw_subset->data = CCAST(kmp_setting_t **, rivals);\n      kmp_place_threads->data = CCAST(kmp_setting_t **, rivals);\n    }\n\n#if KMP_AFFINITY_SUPPORTED\n    { // Initialize KMP_AFFINITY, GOMP_CPU_AFFINITY, and OMP_PROC_BIND data.\n      kmp_setting_t *kmp_affinity =\n          __kmp_stg_find(\"KMP_AFFINITY\"); // 1st priority.\n      KMP_DEBUG_ASSERT(kmp_affinity != NULL);\n\n#ifdef KMP_GOMP_COMPAT\n      kmp_setting_t *gomp_cpu_affinity =\n          __kmp_stg_find(\"GOMP_CPU_AFFINITY\"); // 2nd priority.\n      KMP_DEBUG_ASSERT(gomp_cpu_affinity != NULL);\n#endif\n\n      kmp_setting_t *omp_proc_bind =\n          __kmp_stg_find(\"OMP_PROC_BIND\"); // 3rd priority.\n      KMP_DEBUG_ASSERT(omp_proc_bind != NULL);\n\n      // !!! volatile keyword is Intel(R) C Compiler bug CQ49908 workaround.\n      static kmp_setting_t *volatile rivals[4];\n      int i = 0;\n\n      rivals[i++] = kmp_affinity;\n\n#ifdef KMP_GOMP_COMPAT\n      rivals[i++] = gomp_cpu_affinity;\n      gomp_cpu_affinity->data = CCAST(kmp_setting_t **, rivals);\n#endif\n\n      rivals[i++] = omp_proc_bind;\n      omp_proc_bind->data = CCAST(kmp_setting_t **, rivals);\n      rivals[i++] = NULL;\n\n      static kmp_setting_t *volatile places_rivals[4];\n      i = 0;\n\n      kmp_setting_t *omp_places = __kmp_stg_find(\"OMP_PLACES\"); // 3rd priority.\n      KMP_DEBUG_ASSERT(omp_places != NULL);\n\n      places_rivals[i++] = kmp_affinity;\n#ifdef KMP_GOMP_COMPAT\n      places_rivals[i++] = gomp_cpu_affinity;\n#endif\n      places_rivals[i++] = omp_places;\n      omp_places->data = CCAST(kmp_setting_t **, places_rivals);\n      places_rivals[i++] = NULL;\n    }\n#else\n// KMP_AFFINITY not supported, so OMP_PROC_BIND has no rivals.\n// OMP_PLACES not supported yet.\n#endif // KMP_AFFINITY_SUPPORTED\n\n    { // Initialize KMP_DETERMINISTIC_REDUCTION and KMP_FORCE_REDUCTION data.\n      kmp_setting_t *kmp_force_red =\n          __kmp_stg_find(\"KMP_FORCE_REDUCTION\"); // 1st priority.\n      kmp_setting_t *kmp_determ_red =\n          __kmp_stg_find(\"KMP_DETERMINISTIC_REDUCTION\"); // 2nd priority.\n\n      // !!! volatile keyword is Intel(R) C Compiler bug CQ49908 workaround.\n      static kmp_setting_t *volatile rivals[3];\n      static kmp_stg_fr_data_t force_data = {1,\n                                             CCAST(kmp_setting_t **, rivals)};\n      static kmp_stg_fr_data_t determ_data = {0,\n                                              CCAST(kmp_setting_t **, rivals)};\n      int i = 0;\n\n      rivals[i++] = kmp_force_red;\n      if (kmp_determ_red != NULL) {\n        rivals[i++] = kmp_determ_red;\n      }\n      rivals[i++] = NULL;\n\n      kmp_force_red->data = &force_data;\n      if (kmp_determ_red != NULL) {\n        kmp_determ_red->data = &determ_data;\n      }\n    }\n\n    initialized = 1;\n  }\n\n  // Reset flags.\n  int i;\n  for (i = 0; i < __kmp_stg_count; ++i) {\n    __kmp_stg_table[i].set = 0;\n  }\n\n} // __kmp_stg_init\n\nstatic void __kmp_stg_parse(char const *name, char const *value) {\n  // On Windows* OS there are some nameless variables like \"C:=C:\\\" (yeah,\n  // really nameless, they are presented in environment block as\n  // \"=C:=C\\\\\\x00=D:=D:\\\\\\x00...\", so let us skip them.\n  if (name[0] == 0) {\n    return;\n  }\n\n  if (value != NULL) {\n    kmp_setting_t *setting = __kmp_stg_find(name);\n    if (setting != NULL) {\n      setting->parse(name, value, setting->data);\n      setting->defined = 1;\n    }\n  }\n\n} // __kmp_stg_parse\n\nstatic int __kmp_stg_check_rivals( // 0 -- Ok, 1 -- errors found.\n    char const *name, // Name of variable.\n    char const *value, // Value of the variable.\n    kmp_setting_t **rivals // List of rival settings (must include current one).\n) {\n\n  if (rivals == NULL) {\n    return 0;\n  }\n\n  // Loop thru higher priority settings (listed before current).\n  int i = 0;\n  for (; strcmp(rivals[i]->name, name) != 0; i++) {\n    KMP_DEBUG_ASSERT(rivals[i] != NULL);\n\n#if KMP_AFFINITY_SUPPORTED\n    if (rivals[i] == __kmp_affinity_notype) {\n      // If KMP_AFFINITY is specified without a type name,\n      // it does not rival OMP_PROC_BIND or GOMP_CPU_AFFINITY.\n      continue;\n    }\n#endif\n\n    if (rivals[i]->set) {\n      KMP_WARNING(StgIgnored, name, rivals[i]->name);\n      return 1;\n    }\n  }\n\n  ++i; // Skip current setting.\n  return 0;\n\n} // __kmp_stg_check_rivals\n\nstatic int __kmp_env_toPrint(char const *name, int flag) {\n  int rc = 0;\n  kmp_setting_t *setting = __kmp_stg_find(name);\n  if (setting != NULL) {\n    rc = setting->defined;\n    if (flag >= 0) {\n      setting->defined = flag;\n    }\n  }\n  return rc;\n}\n\nstatic void __kmp_aux_env_initialize(kmp_env_blk_t *block) {\n\n  char const *value;\n\n  /* OMP_NUM_THREADS */\n  value = __kmp_env_blk_var(block, \"OMP_NUM_THREADS\");\n  if (value) {\n    ompc_set_num_threads(__kmp_dflt_team_nth);\n  }\n\n  /* KMP_BLOCKTIME */\n  value = __kmp_env_blk_var(block, \"KMP_BLOCKTIME\");\n  if (value) {\n    kmpc_set_blocktime(__kmp_dflt_blocktime);\n  }\n\n  /* OMP_NESTED */\n  value = __kmp_env_blk_var(block, \"OMP_NESTED\");\n  if (value) {\n    ompc_set_nested(__kmp_dflt_max_active_levels > 1);\n  }\n\n  /* OMP_DYNAMIC */\n  value = __kmp_env_blk_var(block, \"OMP_DYNAMIC\");\n  if (value) {\n    ompc_set_dynamic(__kmp_global.g.g_dynamic);\n  }\n}\n\nvoid __kmp_env_initialize(char const *string) {\n\n  kmp_env_blk_t block;\n  int i;\n\n  __kmp_stg_init();\n\n  // Hack!!!\n  if (string == NULL) {\n    // __kmp_max_nth = __kmp_sys_max_nth;\n    __kmp_threads_capacity =\n        __kmp_initial_threads_capacity(__kmp_dflt_team_nth_ub);\n  }\n  __kmp_env_blk_init(&block, string);\n\n  // update the set flag on all entries that have an env var\n  for (i = 0; i < block.count; ++i) {\n    if ((block.vars[i].name == NULL) || (*block.vars[i].name == '\\0')) {\n      continue;\n    }\n    if (block.vars[i].value == NULL) {\n      continue;\n    }\n    kmp_setting_t *setting = __kmp_stg_find(block.vars[i].name);\n    if (setting != NULL) {\n      setting->set = 1;\n    }\n  }\n\n  // We need to know if blocktime was set when processing OMP_WAIT_POLICY\n  blocktime_str = __kmp_env_blk_var(&block, \"KMP_BLOCKTIME\");\n\n  // Special case. If we parse environment, not a string, process KMP_WARNINGS\n  // first.\n  if (string == NULL) {\n    char const *name = \"KMP_WARNINGS\";\n    char const *value = __kmp_env_blk_var(&block, name);\n    __kmp_stg_parse(name, value);\n  }\n\n#if KMP_AFFINITY_SUPPORTED\n  // Special case. KMP_AFFINITY is not a rival to other affinity env vars\n  // if no affinity type is specified.  We want to allow\n  // KMP_AFFINITY=[no],verbose/[no]warnings/etc.  to be enabled when\n  // specifying the affinity type via GOMP_CPU_AFFINITY or the OMP 4.0\n  // affinity mechanism.\n  __kmp_affinity_notype = NULL;\n  char const *aff_str = __kmp_env_blk_var(&block, \"KMP_AFFINITY\");\n  if (aff_str != NULL) {\n    // Check if the KMP_AFFINITY type is specified in the string.\n    // We just search the string for \"compact\", \"scatter\", etc.\n    // without really parsing the string.  The syntax of the\n    // KMP_AFFINITY env var is such that none of the affinity\n    // type names can appear anywhere other that the type\n    // specifier, even as substrings.\n    //\n    // I can't find a case-insensitive version of strstr on Windows* OS.\n    // Use the case-sensitive version for now.\n\n#if KMP_OS_WINDOWS\n#define FIND strstr\n#else\n#define FIND strcasestr\n#endif\n\n    if ((FIND(aff_str, \"none\") == NULL) &&\n        (FIND(aff_str, \"physical\") == NULL) &&\n        (FIND(aff_str, \"logical\") == NULL) &&\n        (FIND(aff_str, \"compact\") == NULL) &&\n        (FIND(aff_str, \"scatter\") == NULL) &&\n        (FIND(aff_str, \"explicit\") == NULL) &&\n        (FIND(aff_str, \"balanced\") == NULL) &&\n        (FIND(aff_str, \"disabled\") == NULL)) {\n      __kmp_affinity_notype = __kmp_stg_find(\"KMP_AFFINITY\");\n    } else {\n      // A new affinity type is specified.\n      // Reset the affinity flags to their default values,\n      // in case this is called from kmp_set_defaults().\n      __kmp_affinity_type = affinity_default;\n      __kmp_affinity_gran = affinity_gran_default;\n      __kmp_affinity_top_method = affinity_top_method_default;\n      __kmp_affinity_respect_mask = affinity_respect_mask_default;\n    }\n#undef FIND\n\n    // Also reset the affinity flags if OMP_PROC_BIND is specified.\n    aff_str = __kmp_env_blk_var(&block, \"OMP_PROC_BIND\");\n    if (aff_str != NULL) {\n      __kmp_affinity_type = affinity_default;\n      __kmp_affinity_gran = affinity_gran_default;\n      __kmp_affinity_top_method = affinity_top_method_default;\n      __kmp_affinity_respect_mask = affinity_respect_mask_default;\n    }\n  }\n\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n  // Set up the nested proc bind type vector.\n  if (__kmp_nested_proc_bind.bind_types == NULL) {\n    __kmp_nested_proc_bind.bind_types =\n        (kmp_proc_bind_t *)KMP_INTERNAL_MALLOC(sizeof(kmp_proc_bind_t));\n    if (__kmp_nested_proc_bind.bind_types == NULL) {\n      KMP_FATAL(MemoryAllocFailed);\n    }\n    __kmp_nested_proc_bind.size = 1;\n    __kmp_nested_proc_bind.used = 1;\n#if KMP_AFFINITY_SUPPORTED\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_default;\n#else\n    // default proc bind is false if affinity not supported\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n#endif\n  }\n\n  // Set up the affinity format ICV\n  // Grab the default affinity format string from the message catalog\n  kmp_msg_t m =\n      __kmp_msg_format(kmp_i18n_msg_AffFormatDefault, \"%P\", \"%i\", \"%n\", \"%A\");\n  KMP_DEBUG_ASSERT(KMP_STRLEN(m.str) < KMP_AFFINITY_FORMAT_SIZE);\n\n  if (__kmp_affinity_format == NULL) {\n    __kmp_affinity_format =\n        (char *)KMP_INTERNAL_MALLOC(sizeof(char) * KMP_AFFINITY_FORMAT_SIZE);\n  }\n  KMP_STRCPY_S(__kmp_affinity_format, KMP_AFFINITY_FORMAT_SIZE, m.str);\n  __kmp_str_free(&m.str);\n\n  // Now process all of the settings.\n  for (i = 0; i < block.count; ++i) {\n    __kmp_stg_parse(block.vars[i].name, block.vars[i].value);\n  }\n\n  // If user locks have been allocated yet, don't reset the lock vptr table.\n  if (!__kmp_init_user_locks) {\n    if (__kmp_user_lock_kind == lk_default) {\n      __kmp_user_lock_kind = lk_queuing;\n    }\n#if KMP_USE_DYNAMIC_LOCK\n    __kmp_init_dynamic_user_locks();\n#else\n    __kmp_set_user_lock_vptrs(__kmp_user_lock_kind);\n#endif\n  } else {\n    KMP_DEBUG_ASSERT(string != NULL); // kmp_set_defaults() was called\n    KMP_DEBUG_ASSERT(__kmp_user_lock_kind != lk_default);\n// Binds lock functions again to follow the transition between different\n// KMP_CONSISTENCY_CHECK values. Calling this again is harmless as long\n// as we do not allow lock kind changes after making a call to any\n// user lock functions (true).\n#if KMP_USE_DYNAMIC_LOCK\n    __kmp_init_dynamic_user_locks();\n#else\n    __kmp_set_user_lock_vptrs(__kmp_user_lock_kind);\n#endif\n  }\n\n#if KMP_AFFINITY_SUPPORTED\n\n  if (!TCR_4(__kmp_init_middle)) {\n#if KMP_USE_HWLOC\n    // Force using hwloc when either tiles or numa nodes requested within\n    // KMP_HW_SUBSET and no other topology method is requested\n    if ((__kmp_hws_node.num > 0 || __kmp_hws_tile.num > 0 ||\n         __kmp_affinity_gran == affinity_gran_tile) &&\n        (__kmp_affinity_top_method == affinity_top_method_default)) {\n      __kmp_affinity_top_method = affinity_top_method_hwloc;\n    }\n#endif\n    // Determine if the machine/OS is actually capable of supporting\n    // affinity.\n    const char *var = \"KMP_AFFINITY\";\n    KMPAffinity::pick_api();\n#if KMP_USE_HWLOC\n    // If Hwloc topology discovery was requested but affinity was also disabled,\n    // then tell user that Hwloc request is being ignored and use default\n    // topology discovery method.\n    if (__kmp_affinity_top_method == affinity_top_method_hwloc &&\n        __kmp_affinity_dispatch->get_api_type() != KMPAffinity::HWLOC) {\n      KMP_WARNING(AffIgnoringHwloc, var);\n      __kmp_affinity_top_method = affinity_top_method_all;\n    }\n#endif\n    if (__kmp_affinity_type == affinity_disabled) {\n      KMP_AFFINITY_DISABLE();\n    } else if (!KMP_AFFINITY_CAPABLE()) {\n      __kmp_affinity_dispatch->determine_capable(var);\n      if (!KMP_AFFINITY_CAPABLE()) {\n        if (__kmp_affinity_verbose ||\n            (__kmp_affinity_warnings &&\n             (__kmp_affinity_type != affinity_default) &&\n             (__kmp_affinity_type != affinity_none) &&\n             (__kmp_affinity_type != affinity_disabled))) {\n          KMP_WARNING(AffNotSupported, var);\n        }\n        __kmp_affinity_type = affinity_disabled;\n        __kmp_affinity_respect_mask = 0;\n        __kmp_affinity_gran = affinity_gran_fine;\n      }\n    }\n\n    if (__kmp_affinity_type == affinity_disabled) {\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n    } else if (__kmp_nested_proc_bind.bind_types[0] == proc_bind_true) {\n      // OMP_PROC_BIND=true maps to OMP_PROC_BIND=spread.\n      __kmp_nested_proc_bind.bind_types[0] = proc_bind_spread;\n    }\n\n    if (KMP_AFFINITY_CAPABLE()) {\n\n#if KMP_GROUP_AFFINITY\n      // This checks to see if the initial affinity mask is equal\n      // to a single windows processor group.  If it is, then we do\n      // not respect the initial affinity mask and instead, use the\n      // entire machine.\n      bool exactly_one_group = false;\n      if (__kmp_num_proc_groups > 1) {\n        int group;\n        bool within_one_group;\n        // Get the initial affinity mask and determine if it is\n        // contained within a single group.\n        kmp_affin_mask_t *init_mask;\n        KMP_CPU_ALLOC(init_mask);\n        __kmp_get_system_affinity(init_mask, TRUE);\n        group = __kmp_get_proc_group(init_mask);\n        within_one_group = (group >= 0);\n        // If the initial affinity is within a single group,\n        // then determine if it is equal to that single group.\n        if (within_one_group) {\n          DWORD num_bits_in_group = __kmp_GetActiveProcessorCount(group);\n          DWORD num_bits_in_mask = 0;\n          for (int bit = init_mask->begin(); bit != init_mask->end();\n               bit = init_mask->next(bit))\n            num_bits_in_mask++;\n          exactly_one_group = (num_bits_in_group == num_bits_in_mask);\n        }\n        KMP_CPU_FREE(init_mask);\n      }\n\n      // Handle the Win 64 group affinity stuff if there are multiple\n      // processor groups, or if the user requested it, and OMP 4.0\n      // affinity is not in effect.\n      if (((__kmp_num_proc_groups > 1) &&\n           (__kmp_affinity_type == affinity_default) &&\n           (__kmp_nested_proc_bind.bind_types[0] == proc_bind_default)) ||\n          (__kmp_affinity_top_method == affinity_top_method_group)) {\n        if (__kmp_affinity_respect_mask == affinity_respect_mask_default &&\n            exactly_one_group) {\n          __kmp_affinity_respect_mask = FALSE;\n        }\n        if (__kmp_affinity_type == affinity_default) {\n          __kmp_affinity_type = affinity_compact;\n          __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n        }\n        if (__kmp_affinity_top_method == affinity_top_method_default) {\n          if (__kmp_affinity_gran == affinity_gran_default) {\n            __kmp_affinity_top_method = affinity_top_method_group;\n            __kmp_affinity_gran = affinity_gran_group;\n          } else if (__kmp_affinity_gran == affinity_gran_group) {\n            __kmp_affinity_top_method = affinity_top_method_group;\n          } else {\n            __kmp_affinity_top_method = affinity_top_method_all;\n          }\n        } else if (__kmp_affinity_top_method == affinity_top_method_group) {\n          if (__kmp_affinity_gran == affinity_gran_default) {\n            __kmp_affinity_gran = affinity_gran_group;\n          } else if ((__kmp_affinity_gran != affinity_gran_group) &&\n                     (__kmp_affinity_gran != affinity_gran_fine) &&\n                     (__kmp_affinity_gran != affinity_gran_thread)) {\n            const char *str = NULL;\n            switch (__kmp_affinity_gran) {\n            case affinity_gran_core:\n              str = \"core\";\n              break;\n            case affinity_gran_package:\n              str = \"package\";\n              break;\n            case affinity_gran_node:\n              str = \"node\";\n              break;\n            case affinity_gran_tile:\n              str = \"tile\";\n              break;\n            default:\n              KMP_DEBUG_ASSERT(0);\n            }\n            KMP_WARNING(AffGranTopGroup, var, str);\n            __kmp_affinity_gran = affinity_gran_fine;\n          }\n        } else {\n          if (__kmp_affinity_gran == affinity_gran_default) {\n            __kmp_affinity_gran = affinity_gran_core;\n          } else if (__kmp_affinity_gran == affinity_gran_group) {\n            const char *str = NULL;\n            switch (__kmp_affinity_type) {\n            case affinity_physical:\n              str = \"physical\";\n              break;\n            case affinity_logical:\n              str = \"logical\";\n              break;\n            case affinity_compact:\n              str = \"compact\";\n              break;\n            case affinity_scatter:\n              str = \"scatter\";\n              break;\n            case affinity_explicit:\n              str = \"explicit\";\n              break;\n            // No MIC on windows, so no affinity_balanced case\n            default:\n              KMP_DEBUG_ASSERT(0);\n            }\n            KMP_WARNING(AffGranGroupType, var, str);\n            __kmp_affinity_gran = affinity_gran_core;\n          }\n        }\n      } else\n\n#endif /* KMP_GROUP_AFFINITY */\n\n      {\n        if (__kmp_affinity_respect_mask == affinity_respect_mask_default) {\n#if KMP_GROUP_AFFINITY\n          if (__kmp_num_proc_groups > 1 && exactly_one_group) {\n            __kmp_affinity_respect_mask = FALSE;\n          } else\n#endif /* KMP_GROUP_AFFINITY */\n          {\n            __kmp_affinity_respect_mask = TRUE;\n          }\n        }\n        if ((__kmp_nested_proc_bind.bind_types[0] != proc_bind_intel) &&\n            (__kmp_nested_proc_bind.bind_types[0] != proc_bind_default)) {\n          if (__kmp_affinity_type == affinity_default) {\n            __kmp_affinity_type = affinity_compact;\n            __kmp_affinity_dups = FALSE;\n          }\n        } else if (__kmp_affinity_type == affinity_default) {\n#if KMP_MIC_SUPPORTED\n          if (__kmp_mic_type != non_mic) {\n            __kmp_nested_proc_bind.bind_types[0] = proc_bind_intel;\n          } else\n#endif\n          {\n            __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n          }\n#if KMP_MIC_SUPPORTED\n          if (__kmp_mic_type != non_mic) {\n            __kmp_affinity_type = affinity_scatter;\n          } else\n#endif\n          {\n            __kmp_affinity_type = affinity_none;\n          }\n        }\n        if ((__kmp_affinity_gran == affinity_gran_default) &&\n            (__kmp_affinity_gran_levels < 0)) {\n#if KMP_MIC_SUPPORTED\n          if (__kmp_mic_type != non_mic) {\n            __kmp_affinity_gran = affinity_gran_fine;\n          } else\n#endif\n          {\n            __kmp_affinity_gran = affinity_gran_core;\n          }\n        }\n        if (__kmp_affinity_top_method == affinity_top_method_default) {\n          __kmp_affinity_top_method = affinity_top_method_all;\n        }\n      }\n    }\n\n    K_DIAG(1, (\"__kmp_affinity_type         == %d\\n\", __kmp_affinity_type));\n    K_DIAG(1, (\"__kmp_affinity_compact      == %d\\n\", __kmp_affinity_compact));\n    K_DIAG(1, (\"__kmp_affinity_offset       == %d\\n\", __kmp_affinity_offset));\n    K_DIAG(1, (\"__kmp_affinity_verbose      == %d\\n\", __kmp_affinity_verbose));\n    K_DIAG(1, (\"__kmp_affinity_warnings     == %d\\n\", __kmp_affinity_warnings));\n    K_DIAG(1, (\"__kmp_affinity_respect_mask == %d\\n\",\n               __kmp_affinity_respect_mask));\n    K_DIAG(1, (\"__kmp_affinity_gran         == %d\\n\", __kmp_affinity_gran));\n\n    KMP_DEBUG_ASSERT(__kmp_affinity_type != affinity_default);\n    KMP_DEBUG_ASSERT(__kmp_nested_proc_bind.bind_types[0] != proc_bind_default);\n    K_DIAG(1, (\"__kmp_nested_proc_bind.bind_types[0] == %d\\n\",\n               __kmp_nested_proc_bind.bind_types[0]));\n  }\n\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n  if (__kmp_version) {\n    __kmp_print_version_1();\n  }\n\n  // Post-initialization step: some env. vars need their value's further\n  // processing\n  if (string != NULL) { // kmp_set_defaults() was called\n    __kmp_aux_env_initialize(&block);\n  }\n\n  __kmp_env_blk_free(&block);\n\n  KMP_MB();\n\n} // __kmp_env_initialize\n\nvoid __kmp_env_print() {\n\n  kmp_env_blk_t block;\n  int i;\n  kmp_str_buf_t buffer;\n\n  __kmp_stg_init();\n  __kmp_str_buf_init(&buffer);\n\n  __kmp_env_blk_init(&block, NULL);\n  __kmp_env_blk_sort(&block);\n\n  // Print real environment values.\n  __kmp_str_buf_print(&buffer, \"\\n%s\\n\\n\", KMP_I18N_STR(UserSettings));\n  for (i = 0; i < block.count; ++i) {\n    char const *name = block.vars[i].name;\n    char const *value = block.vars[i].value;\n    if ((KMP_STRLEN(name) > 4 && strncmp(name, \"KMP_\", 4) == 0) ||\n        strncmp(name, \"OMP_\", 4) == 0\n#ifdef KMP_GOMP_COMPAT\n        || strncmp(name, \"GOMP_\", 5) == 0\n#endif // KMP_GOMP_COMPAT\n    ) {\n      __kmp_str_buf_print(&buffer, \"   %s=%s\\n\", name, value);\n    }\n  }\n  __kmp_str_buf_print(&buffer, \"\\n\");\n\n  // Print internal (effective) settings.\n  __kmp_str_buf_print(&buffer, \"%s\\n\\n\", KMP_I18N_STR(EffectiveSettings));\n  for (int i = 0; i < __kmp_stg_count; ++i) {\n    if (__kmp_stg_table[i].print != NULL) {\n      __kmp_stg_table[i].print(&buffer, __kmp_stg_table[i].name,\n                               __kmp_stg_table[i].data);\n    }\n  }\n\n  __kmp_printf(\"%s\", buffer.str);\n\n  __kmp_env_blk_free(&block);\n  __kmp_str_buf_free(&buffer);\n\n  __kmp_printf(\"\\n\");\n\n} // __kmp_env_print\n\nvoid __kmp_env_print_2() {\n  __kmp_display_env_impl(__kmp_display_env, __kmp_display_env_verbose);\n} // __kmp_env_print_2\n\nvoid __kmp_display_env_impl(int display_env, int display_env_verbose) {\n  kmp_env_blk_t block;\n  kmp_str_buf_t buffer;\n\n  __kmp_env_format = 1;\n\n  __kmp_stg_init();\n  __kmp_str_buf_init(&buffer);\n\n  __kmp_env_blk_init(&block, NULL);\n  __kmp_env_blk_sort(&block);\n\n  __kmp_str_buf_print(&buffer, \"\\n%s\\n\", KMP_I18N_STR(DisplayEnvBegin));\n  __kmp_str_buf_print(&buffer, \"   _OPENMP='%d'\\n\", __kmp_openmp_version);\n\n  for (int i = 0; i < __kmp_stg_count; ++i) {\n    if (__kmp_stg_table[i].print != NULL &&\n        ((display_env && strncmp(__kmp_stg_table[i].name, \"OMP_\", 4) == 0) ||\n         display_env_verbose)) {\n      __kmp_stg_table[i].print(&buffer, __kmp_stg_table[i].name,\n                               __kmp_stg_table[i].data);\n    }\n  }\n\n  __kmp_str_buf_print(&buffer, \"%s\\n\", KMP_I18N_STR(DisplayEnvEnd));\n  __kmp_str_buf_print(&buffer, \"\\n\");\n\n  __kmp_printf(\"%s\", buffer.str);\n\n  __kmp_env_blk_free(&block);\n  __kmp_str_buf_free(&buffer);\n\n  __kmp_printf(\"\\n\");\n}\n\n// end of file\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "content": "/*\n * kmp_str.h -- String manipulation routines.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_STR_H\n#define KMP_STR_H\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"kmp_os.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#if KMP_OS_WINDOWS\n#define strdup _strdup\n#endif\n\n/*  some macros to replace ctype.h functions  */\n#define TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) + 'a' - 'A') : (c))\n\nstruct kmp_str_buf {\n  char *str; // Pointer to buffer content, read only.\n  unsigned int size; // Do not change this field!\n  int used; // Number of characters printed to buffer, read only.\n  char bulk[512]; // Do not use this field!\n}; // struct kmp_str_buf\ntypedef struct kmp_str_buf kmp_str_buf_t;\n\n#define __kmp_str_buf_init(b)                                                  \\\n  {                                                                            \\\n    (b)->str = (b)->bulk;                                                      \\\n    (b)->size = sizeof((b)->bulk);                                             \\\n    (b)->used = 0;                                                             \\\n    (b)->bulk[0] = 0;                                                          \\\n  }\n\nvoid __kmp_str_buf_clear(kmp_str_buf_t *buffer);\nvoid __kmp_str_buf_reserve(kmp_str_buf_t *buffer, size_t size);\nvoid __kmp_str_buf_detach(kmp_str_buf_t *buffer);\nvoid __kmp_str_buf_free(kmp_str_buf_t *buffer);\nvoid __kmp_str_buf_cat(kmp_str_buf_t *buffer, char const *str, size_t len);\nvoid __kmp_str_buf_catbuf(kmp_str_buf_t *dest, const kmp_str_buf_t *src);\nint __kmp_str_buf_vprint(kmp_str_buf_t *buffer, char const *format,\n                         va_list args);\nint __kmp_str_buf_print(kmp_str_buf_t *buffer, char const *format, ...);\nvoid __kmp_str_buf_print_size(kmp_str_buf_t *buffer, size_t size);\n\n/* File name parser.\n   Usage:\n\n   kmp_str_fname_t fname = __kmp_str_fname_init( path );\n   // Use fname.path (copy of original path ), fname.dir, fname.base.\n   // Note fname.dir concatenated with fname.base gives exact copy of path.\n   __kmp_str_fname_free( & fname );\n*/\nstruct kmp_str_fname {\n  char *path;\n  char *dir;\n  char *base;\n}; // struct kmp_str_fname\ntypedef struct kmp_str_fname kmp_str_fname_t;\nvoid __kmp_str_fname_init(kmp_str_fname_t *fname, char const *path);\nvoid __kmp_str_fname_free(kmp_str_fname_t *fname);\n// Compares file name with specified pattern. If pattern is NULL, any fname\n// matched.\nint __kmp_str_fname_match(kmp_str_fname_t const *fname, char const *pattern);\n\n/* The compiler provides source locations in string form\n   \";file;func;line;col;;\". It is not convenient for manipulation. This\n   structure keeps source location in more convenient form.\n   Usage:\n\n   kmp_str_loc_t loc = __kmp_str_loc_init(ident->psource, false);\n   // use loc.file, loc.func, loc.line, loc.col.\n   // loc.fname is available if second argument of __kmp_str_loc_init is true.\n   __kmp_str_loc_free( & loc );\n\n   If psource is NULL or does not follow format above, file and/or func may be\n   NULL pointers.\n*/\nstruct kmp_str_loc {\n  char *_bulk; // Do not use thid field.\n  kmp_str_fname_t fname; // Will be initialized if init_fname is true.\n  char *file;\n  char *func;\n  int line;\n  int col;\n}; // struct kmp_str_loc\ntypedef struct kmp_str_loc kmp_str_loc_t;\nkmp_str_loc_t __kmp_str_loc_init(char const *psource, bool init_fname);\nvoid __kmp_str_loc_numbers(char const *Psource, int *Line, int *Col);\nvoid __kmp_str_loc_free(kmp_str_loc_t *loc);\n\nint __kmp_str_eqf(char const *lhs, char const *rhs);\nchar *__kmp_str_format(char const *format, ...);\nvoid __kmp_str_free(char **str);\nint __kmp_str_match(char const *target, int len, char const *data);\nint __kmp_str_match_false(char const *data);\nint __kmp_str_match_true(char const *data);\nvoid __kmp_str_replace(char *str, char search_for, char replace_with);\nvoid __kmp_str_split(char *str, char delim, char **head, char **tail);\nchar *__kmp_str_token(char *str, char const *delim, char **buf);\nint __kmp_str_to_int(char const *str, char sentinel);\n\nvoid __kmp_str_to_size(char const *str, size_t *out, size_t dfactor,\n                       char const **error);\nvoid __kmp_str_to_uint(char const *str, kmp_uint64 *out, char const **error);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n#endif // KMP_STR_H\n\n// end of file //\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/thirdparty/ittnotify/ittnotify.h", "content": "\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _ITTNOTIFY_H_\n#define _ITTNOTIFY_H_\n\n/**\n@file\n@brief Public User API functions and types\n@mainpage\n\nThe ITT API is used to annotate a user's program with additional information\nthat can be used by correctness and performance tools. The user inserts\ncalls in their program. Those calls generate information that is collected\nat runtime, and used by Intel(R) Threading Tools.\n\n@section API Concepts\nThe following general concepts are used throughout the API.\n\n@subsection Unicode Support\nMany API functions take character string arguments. On Windows, there\nare two versions of each such function. The function name is suffixed\nby W if Unicode support is enabled, and by A otherwise. Any API function\nthat takes a character string argument adheres to this convention.\n\n@subsection Conditional Compilation\nMany users prefer having an option to modify ITT API code when linking it\ninside their runtimes. ITT API header file provides a mechanism to replace\nITT API function names inside your code with empty strings. To do this,\ndefine the macros INTEL_NO_ITTNOTIFY_API during compilation and remove the\nstatic library from the linker script.\n\n@subsection Domains\n[see domains]\nDomains provide a way to separate notification for different modules or\nlibraries in a program. Domains are specified by dotted character strings,\ne.g. TBB.Internal.Control.\n\nA mechanism (to be specified) is provided to enable and disable\ndomains. By default, all domains are enabled.\n@subsection Named Entities and Instances\nNamed entities (frames, regions, tasks, and markers) communicate\ninformation about the program to the analysis tools. A named entity often\nrefers to a section of program code, or to some set of logical concepts\nthat the programmer wants to group together.\n\nNamed entities relate to the programmer's static view of the program. When\nthe program actually executes, many instances of a given named entity\nmay be created.\n\nThe API annotations denote instances of named entities. The actual\nnamed entities are displayed using the analysis tools. In other words,\nthe named entities come into existence when instances are created.\n\nInstances of named entities may have instance identifiers (IDs). Some\nAPI calls use instance identifiers to create relationships between\ndifferent instances of named entities. Other API calls associate data\nwith instances of named entities.\n\nSome named entities must always have instance IDs. In particular, regions\nand frames always have IDs. Task and markers need IDs only if the ID is\nneeded in another API call (such as adding a relation or metadata).\n\nThe lifetime of instance IDs is distinct from the lifetime of\ninstances. This allows various relationships to be specified separate\nfrom the actual execution of instances. This flexibility comes at the\nexpense of extra API calls.\n\nThe same ID may not be reused for different instances, unless a previous\n[ref] __itt_id_destroy call for that ID has been issued.\n*/\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#define ITT_OS_WIN 1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#define ITT_OS_MAC 3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS_FREEBSD\n#define ITT_OS_FREEBSD 4\n#endif /* ITT_OS_FREEBSD */\n\n#ifndef ITT_OS\n#if defined WIN32 || defined _WIN32\n#define ITT_OS ITT_OS_WIN\n#elif defined(__APPLE__) && defined(__MACH__)\n#define ITT_OS ITT_OS_MAC\n#elif defined(__FreeBSD__)\n#define ITT_OS ITT_OS_FREEBSD\n#else\n#define ITT_OS ITT_OS_LINUX\n#endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM_MAC\n#define ITT_PLATFORM_MAC 3\n#endif /* ITT_PLATFORM_MAC */\n\n#ifndef ITT_PLATFORM_FREEBSD\n#define ITT_PLATFORM_FREEBSD 4\n#endif /* ITT_PLATFORM_FREEBSD */\n\n#ifndef ITT_PLATFORM\n#if ITT_OS == ITT_OS_WIN\n#define ITT_PLATFORM ITT_PLATFORM_WIN\n#elif ITT_OS == ITT_OS_MAC\n#define ITT_PLATFORM ITT_PLATFORM_MAC\n#elif ITT_OS == ITT_OS_FREEBSD\n#define ITT_PLATFORM ITT_PLATFORM_FREEBSD\n#else\n#define ITT_PLATFORM ITT_PLATFORM_POSIX\n#endif\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#include <tchar.h>\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef ITTAPI_CDECL\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define ITTAPI_CDECL __cdecl\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if defined _M_IX86 || defined __i386__\n#define ITTAPI_CDECL __attribute__((cdecl))\n#else /* _M_IX86 || __i386__ */\n#define ITTAPI_CDECL /* actual only on x86 platform */\n#endif /* _M_IX86 || __i386__ */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* ITTAPI_CDECL */\n\n#ifndef STDCALL\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define STDCALL __stdcall\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if defined _M_IX86 || defined __i386__\n#define STDCALL __attribute__((stdcall))\n#else /* _M_IX86 || __i386__ */\n#define STDCALL /* supported only on x86 platform */\n#endif /* _M_IX86 || __i386__ */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI ITTAPI_CDECL\n#define LIBITTAPI ITTAPI_CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL ITTAPI_CDECL\n#define LIBITTAPI_CALL ITTAPI_CDECL\n\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE static\n#define ITT_INLINE_ATTRIBUTE __attribute__((unused))\n#else /* __STRICT_ANSI__ */\n#define ITT_INLINE static inline\n#define ITT_INLINE_ATTRIBUTE __attribute__((always_inline, unused))\n#endif /* __STRICT_ANSI__ */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifdef INTEL_ITTNOTIFY_ENABLE_LEGACY\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#pragma message(                                                               \\\n    \"WARNING!!! Deprecated API is used. Please undefine INTEL_ITTNOTIFY_ENABLE_LEGACY macro\")\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#warning                                                                       \\\n    \"Deprecated API is used. Please undefine INTEL_ITTNOTIFY_ENABLE_LEGACY macro\"\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include \"legacy/ittnotify.h\"\n#endif /* INTEL_ITTNOTIFY_ENABLE_LEGACY */\n\n/** @cond exclude_from_documentation */\n/* Helper macro for joining tokens */\n#define ITT_JOIN_AUX(p, n) p##n\n#define ITT_JOIN(p, n) ITT_JOIN_AUX(p, n)\n\n#ifdef ITT_MAJOR\n#undef ITT_MAJOR\n#endif\n#ifdef ITT_MINOR\n#undef ITT_MINOR\n#endif\n#define ITT_MAJOR 3\n#define ITT_MINOR 0\n\n/* Standard versioning of a token with major and minor version numbers */\n#define ITT_VERSIONIZE(x)                                                      \\\n  ITT_JOIN(x, ITT_JOIN(_, ITT_JOIN(ITT_MAJOR, ITT_JOIN(_, ITT_MINOR))))\n\n#ifndef INTEL_ITTNOTIFY_PREFIX\n#define INTEL_ITTNOTIFY_PREFIX __itt_\n#endif /* INTEL_ITTNOTIFY_PREFIX */\n#ifndef INTEL_ITTNOTIFY_POSTFIX\n#define INTEL_ITTNOTIFY_POSTFIX _ptr_\n#endif /* INTEL_ITTNOTIFY_POSTFIX */\n\n#define ITTNOTIFY_NAME_AUX(n) ITT_JOIN(INTEL_ITTNOTIFY_PREFIX, n)\n#define ITTNOTIFY_NAME(n)                                                      \\\n  ITT_VERSIONIZE(ITTNOTIFY_NAME_AUX(ITT_JOIN(n, INTEL_ITTNOTIFY_POSTFIX)))\n\n#define ITTNOTIFY_VOID(n) (!ITTNOTIFY_NAME(n)) ? (void)0 : ITTNOTIFY_NAME(n)\n#define ITTNOTIFY_DATA(n) (!ITTNOTIFY_NAME(n)) ? 0 : ITTNOTIFY_NAME(n)\n\n#define ITTNOTIFY_VOID_D0(n, d)                                                \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d)\n#define ITTNOTIFY_VOID_D1(n, d, x)                                             \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d, x)\n#define ITTNOTIFY_VOID_D2(n, d, x, y)                                          \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d, x, y)\n#define ITTNOTIFY_VOID_D3(n, d, x, y, z)                                       \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z)\n#define ITTNOTIFY_VOID_D4(n, d, x, y, z, a)                                    \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z, a)\n#define ITTNOTIFY_VOID_D5(n, d, x, y, z, a, b)                                 \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z, a, b)\n#define ITTNOTIFY_VOID_D6(n, d, x, y, z, a, b, c)                              \\\n  (!(d)->flags)          ? (void)0                                             \\\n  : (!ITTNOTIFY_NAME(n)) ? (void)0                                             \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z, a, b, c)\n#define ITTNOTIFY_DATA_D0(n, d)                                                \\\n  (!(d)->flags) ? 0 : (!ITTNOTIFY_NAME(n)) ? 0 : ITTNOTIFY_NAME(n)(d)\n#define ITTNOTIFY_DATA_D1(n, d, x)                                             \\\n  (!(d)->flags) ? 0 : (!ITTNOTIFY_NAME(n)) ? 0 : ITTNOTIFY_NAME(n)(d, x)\n#define ITTNOTIFY_DATA_D2(n, d, x, y)                                          \\\n  (!(d)->flags) ? 0 : (!ITTNOTIFY_NAME(n)) ? 0 : ITTNOTIFY_NAME(n)(d, x, y)\n#define ITTNOTIFY_DATA_D3(n, d, x, y, z)                                       \\\n  (!(d)->flags) ? 0 : (!ITTNOTIFY_NAME(n)) ? 0 : ITTNOTIFY_NAME(n)(d, x, y, z)\n#define ITTNOTIFY_DATA_D4(n, d, x, y, z, a)                                    \\\n  (!(d)->flags)          ? 0                                                   \\\n  : (!ITTNOTIFY_NAME(n)) ? 0                                                   \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z, a)\n#define ITTNOTIFY_DATA_D5(n, d, x, y, z, a, b)                                 \\\n  (!(d)->flags)          ? 0                                                   \\\n  : (!ITTNOTIFY_NAME(n)) ? 0                                                   \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z, a, b)\n#define ITTNOTIFY_DATA_D6(n, d, x, y, z, a, b, c)                              \\\n  (!(d)->flags)          ? 0                                                   \\\n  : (!ITTNOTIFY_NAME(n)) ? 0                                                   \\\n                         : ITTNOTIFY_NAME(n)(d, x, y, z, a, b, c)\n\n#ifdef ITT_STUB\n#undef ITT_STUB\n#endif\n#ifdef ITT_STUBV\n#undef ITT_STUBV\n#endif\n#define ITT_STUBV(api, type, name, args)                                       \\\n  typedef type(api *ITT_JOIN(ITTNOTIFY_NAME(name), _t)) args;                  \\\n  extern ITT_JOIN(ITTNOTIFY_NAME(name), _t) ITTNOTIFY_NAME(name);\n#define ITT_STUB ITT_STUBV\n/** @endcond */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/** @cond exclude_from_gpa_documentation */\n/**\n * @defgroup public Public API\n * @{\n * @}\n */\n\n/**\n * @defgroup control Collection Control\n * @ingroup public\n * General behavior: application continues to run, but no profiling information\n * is being collected\n *\n * Pausing occurs not only for the current thread but for all process as well as\n * spawned processes\n * - Intel(R) Parallel Inspector and Intel(R) Inspector XE:\n *   - Does not analyze or report errors that involve memory access.\n *   - Other errors are reported as usual. Pausing data collection in\n *     Intel(R) Parallel Inspector and Intel(R) Inspector XE\n *     only pauses tracing and analyzing memory access.\n *     It does not pause tracing or analyzing threading APIs.\n *   .\n * - Intel(R) Parallel Amplifier and Intel(R) VTune(TM) Amplifier XE:\n *   - Does continue to record when new threads are started.\n *   .\n * - Other effects:\n *   - Possible reduction of runtime overhead.\n *   .\n * @{\n */\n/** @brief Pause collection */\nvoid ITTAPI __itt_pause(void);\n/** @brief Resume collection */\nvoid ITTAPI __itt_resume(void);\n/** @brief Detach collection */\nvoid ITTAPI __itt_detach(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, pause, (void))\nITT_STUBV(ITTAPI, void, resume, (void))\nITT_STUBV(ITTAPI, void, detach, (void))\n#define __itt_pause ITTNOTIFY_VOID(pause)\n#define __itt_pause_ptr ITTNOTIFY_NAME(pause)\n#define __itt_resume ITTNOTIFY_VOID(resume)\n#define __itt_resume_ptr ITTNOTIFY_NAME(resume)\n#define __itt_detach ITTNOTIFY_VOID(detach)\n#define __itt_detach_ptr ITTNOTIFY_NAME(detach)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_pause()\n#define __itt_pause_ptr 0\n#define __itt_resume()\n#define __itt_resume_ptr 0\n#define __itt_detach()\n#define __itt_detach_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_pause_ptr 0\n#define __itt_resume_ptr 0\n#define __itt_detach_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} control group */\n/** @endcond */\n\n/**\n * @defgroup threads Threads\n * @ingroup public\n * Give names to threads\n * @{\n */\n/**\n * @brief Sets thread name of calling thread\n * @param[in] name - name of thread\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_thread_set_nameA(const char *name);\nvoid ITTAPI __itt_thread_set_nameW(const wchar_t *name);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_thread_set_name __itt_thread_set_nameW\n#define __itt_thread_set_name_ptr __itt_thread_set_nameW_ptr\n#else /* UNICODE */\n#define __itt_thread_set_name __itt_thread_set_nameA\n#define __itt_thread_set_name_ptr __itt_thread_set_nameA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nvoid ITTAPI __itt_thread_set_name(const char *name);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, thread_set_nameA, (const char *name))\nITT_STUBV(ITTAPI, void, thread_set_nameW, (const wchar_t *name))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUBV(ITTAPI, void, thread_set_name, (const char *name))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_thread_set_nameA ITTNOTIFY_VOID(thread_set_nameA)\n#define __itt_thread_set_nameA_ptr ITTNOTIFY_NAME(thread_set_nameA)\n#define __itt_thread_set_nameW ITTNOTIFY_VOID(thread_set_nameW)\n#define __itt_thread_set_nameW_ptr ITTNOTIFY_NAME(thread_set_nameW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_thread_set_name ITTNOTIFY_VOID(thread_set_name)\n#define __itt_thread_set_name_ptr ITTNOTIFY_NAME(thread_set_name)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_thread_set_nameA(name)\n#define __itt_thread_set_nameA_ptr 0\n#define __itt_thread_set_nameW(name)\n#define __itt_thread_set_nameW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_thread_set_name(name)\n#define __itt_thread_set_name_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_thread_set_nameA_ptr 0\n#define __itt_thread_set_nameW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_thread_set_name_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @cond exclude_from_gpa_documentation */\n\n/**\n * @brief Mark current thread as ignored from this point on, for the duration of\n * its existence.\n */\nvoid ITTAPI __itt_thread_ignore(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, thread_ignore, (void))\n#define __itt_thread_ignore ITTNOTIFY_VOID(thread_ignore)\n#define __itt_thread_ignore_ptr ITTNOTIFY_NAME(thread_ignore)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_thread_ignore()\n#define __itt_thread_ignore_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_thread_ignore_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} threads group */\n\n/**\n * @defgroup suppress Error suppression\n * @ingroup public\n * General behavior: application continues to run, but errors are suppressed\n *\n * @{\n */\n\n// clang-format off\n/*****************************************************************//**\n * @name group of functions used for error suppression in correctness tools\n *********************************************************************/\n// clang-format on\n/** @{ */\n/**\n * @hideinitializer\n * @brief possible value for suppression mask\n */\n#define __itt_suppress_all_errors 0x7fffffff\n\n/**\n * @hideinitializer\n * @brief possible value for suppression mask (suppresses errors from threading\n * analysis)\n */\n#define __itt_suppress_threading_errors 0x000000ff\n\n/**\n * @hideinitializer\n * @brief possible value for suppression mask (suppresses errors from memory\n * analysis)\n */\n#define __itt_suppress_memory_errors 0x0000ff00\n\n/**\n * @brief Start suppressing errors identified in mask on this thread\n */\nvoid ITTAPI __itt_suppress_push(unsigned int mask);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, suppress_push, (unsigned int mask))\n#define __itt_suppress_push ITTNOTIFY_VOID(suppress_push)\n#define __itt_suppress_push_ptr ITTNOTIFY_NAME(suppress_push)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_suppress_push(mask)\n#define __itt_suppress_push_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_suppress_push_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Undo the effects of the matching call to __itt_suppress_push\n */\nvoid ITTAPI __itt_suppress_pop(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, suppress_pop, (void))\n#define __itt_suppress_pop ITTNOTIFY_VOID(suppress_pop)\n#define __itt_suppress_pop_ptr ITTNOTIFY_NAME(suppress_pop)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_suppress_pop()\n#define __itt_suppress_pop_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_suppress_pop_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @enum __itt_model_disable\n * @brief Enumerator for the disable methods\n */\ntypedef enum __itt_suppress_mode {\n  __itt_unsuppress_range,\n  __itt_suppress_range\n} __itt_suppress_mode_t;\n\n/**\n * @brief Mark a range of memory for error suppression or unsuppression for\n * error types included in mask\n */\nvoid ITTAPI __itt_suppress_mark_range(__itt_suppress_mode_t mode,\n                                      unsigned int mask, void *address,\n                                      size_t size);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, suppress_mark_range,\n          (__itt_suppress_mode_t mode, unsigned int mask, void *address,\n           size_t size))\n#define __itt_suppress_mark_range ITTNOTIFY_VOID(suppress_mark_range)\n#define __itt_suppress_mark_range_ptr ITTNOTIFY_NAME(suppress_mark_range)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_suppress_mark_range(mask)\n#define __itt_suppress_mark_range_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_suppress_mark_range_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Undo the effect of a matching call to __itt_suppress_mark_range.   If\n * not matching call is found, nothing is changed.\n */\nvoid ITTAPI __itt_suppress_clear_range(__itt_suppress_mode_t mode,\n                                       unsigned int mask, void *address,\n                                       size_t size);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, suppress_clear_range,\n          (__itt_suppress_mode_t mode, unsigned int mask, void *address,\n           size_t size))\n#define __itt_suppress_clear_range ITTNOTIFY_VOID(suppress_clear_range)\n#define __itt_suppress_clear_range_ptr ITTNOTIFY_NAME(suppress_clear_range)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_suppress_clear_range(mask)\n#define __itt_suppress_clear_range_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_suppress_clear_range_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} */\n/** @} suppress group */\n\n/**\n * @defgroup sync Synchronization\n * @ingroup public\n * Indicate user-written synchronization code\n * @{\n */\n/**\n * @hideinitializer\n * @brief possible value of attribute argument for sync object type\n */\n#define __itt_attr_barrier 1\n\n/**\n * @hideinitializer\n * @brief possible value of attribute argument for sync object type\n */\n#define __itt_attr_mutex 2\n\n/**\n@brief Name a synchronization object\n@param[in] addr       Handle for the synchronization object. You should\nuse a real address to uniquely identify the synchronization object.\n@param[in] objtype    null-terminated object type string. If NULL is\npassed, the name will be \"User Synchronization\".\n@param[in] objname    null-terminated object name string. If NULL,\nno name will be assigned to the object.\n@param[in] attribute  one of [#__itt_attr_barrier, #__itt_attr_mutex]\n */\n\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_sync_createA(void *addr, const char *objtype,\n                               const char *objname, int attribute);\nvoid ITTAPI __itt_sync_createW(void *addr, const wchar_t *objtype,\n                               const wchar_t *objname, int attribute);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_sync_create __itt_sync_createW\n#define __itt_sync_create_ptr __itt_sync_createW_ptr\n#else /* UNICODE */\n#define __itt_sync_create __itt_sync_createA\n#define __itt_sync_create_ptr __itt_sync_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nvoid ITTAPI __itt_sync_create(void *addr, const char *objtype,\n                              const char *objname, int attribute);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, sync_createA,\n          (void *addr, const char *objtype, const char *objname, int attribute))\nITT_STUBV(ITTAPI, void, sync_createW,\n          (void *addr, const wchar_t *objtype, const wchar_t *objname,\n           int attribute))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUBV(ITTAPI, void, sync_create,\n          (void *addr, const char *objtype, const char *objname, int attribute))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_sync_createA ITTNOTIFY_VOID(sync_createA)\n#define __itt_sync_createA_ptr ITTNOTIFY_NAME(sync_createA)\n#define __itt_sync_createW ITTNOTIFY_VOID(sync_createW)\n#define __itt_sync_createW_ptr ITTNOTIFY_NAME(sync_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_sync_create ITTNOTIFY_VOID(sync_create)\n#define __itt_sync_create_ptr ITTNOTIFY_NAME(sync_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_sync_createA(addr, objtype, objname, attribute)\n#define __itt_sync_createA_ptr 0\n#define __itt_sync_createW(addr, objtype, objname, attribute)\n#define __itt_sync_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_sync_create(addr, objtype, objname, attribute)\n#define __itt_sync_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_sync_createA_ptr 0\n#define __itt_sync_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_sync_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n@brief Rename a synchronization object\n\nYou can use the rename call to assign or reassign a name to a given\nsynchronization object.\n@param[in] addr  handle for the synchronization object.\n@param[in] name  null-terminated object name string.\n*/\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_sync_renameA(void *addr, const char *name);\nvoid ITTAPI __itt_sync_renameW(void *addr, const wchar_t *name);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_sync_rename __itt_sync_renameW\n#define __itt_sync_rename_ptr __itt_sync_renameW_ptr\n#else /* UNICODE */\n#define __itt_sync_rename __itt_sync_renameA\n#define __itt_sync_rename_ptr __itt_sync_renameA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nvoid ITTAPI __itt_sync_rename(void *addr, const char *name);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, sync_renameA, (void *addr, const char *name))\nITT_STUBV(ITTAPI, void, sync_renameW, (void *addr, const wchar_t *name))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUBV(ITTAPI, void, sync_rename, (void *addr, const char *name))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_sync_renameA ITTNOTIFY_VOID(sync_renameA)\n#define __itt_sync_renameA_ptr ITTNOTIFY_NAME(sync_renameA)\n#define __itt_sync_renameW ITTNOTIFY_VOID(sync_renameW)\n#define __itt_sync_renameW_ptr ITTNOTIFY_NAME(sync_renameW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_sync_rename ITTNOTIFY_VOID(sync_rename)\n#define __itt_sync_rename_ptr ITTNOTIFY_NAME(sync_rename)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_sync_renameA(addr, name)\n#define __itt_sync_renameA_ptr 0\n#define __itt_sync_renameW(addr, name)\n#define __itt_sync_renameW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_sync_rename(addr, name)\n#define __itt_sync_rename_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_sync_renameA_ptr 0\n#define __itt_sync_renameW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_sync_rename_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n @brief Destroy a synchronization object.\n @param addr Handle for the synchronization object.\n */\nvoid ITTAPI __itt_sync_destroy(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, sync_destroy, (void *addr))\n#define __itt_sync_destroy ITTNOTIFY_VOID(sync_destroy)\n#define __itt_sync_destroy_ptr ITTNOTIFY_NAME(sync_destroy)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_sync_destroy(addr)\n#define __itt_sync_destroy_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_sync_destroy_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n// clang-format off\n/*****************************************************************//**\n * @name group of functions is used for performance measurement tools\n *********************************************************************/\n// clang-format on\n/** @{ */\n/**\n * @brief Enter spin loop on user-defined sync object\n */\nvoid ITTAPI __itt_sync_prepare(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, sync_prepare, (void *addr))\n#define __itt_sync_prepare ITTNOTIFY_VOID(sync_prepare)\n#define __itt_sync_prepare_ptr ITTNOTIFY_NAME(sync_prepare)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_sync_prepare(addr)\n#define __itt_sync_prepare_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_sync_prepare_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Quit spin loop without acquiring spin object\n */\nvoid ITTAPI __itt_sync_cancel(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, sync_cancel, (void *addr))\n#define __itt_sync_cancel ITTNOTIFY_VOID(sync_cancel)\n#define __itt_sync_cancel_ptr ITTNOTIFY_NAME(sync_cancel)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_sync_cancel(addr)\n#define __itt_sync_cancel_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_sync_cancel_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Successful spin loop completion (sync object acquired)\n */\nvoid ITTAPI __itt_sync_acquired(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, sync_acquired, (void *addr))\n#define __itt_sync_acquired ITTNOTIFY_VOID(sync_acquired)\n#define __itt_sync_acquired_ptr ITTNOTIFY_NAME(sync_acquired)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_sync_acquired(addr)\n#define __itt_sync_acquired_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_sync_acquired_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Start sync object releasing code. Is called before the lock release\n * call.\n */\nvoid ITTAPI __itt_sync_releasing(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, sync_releasing, (void *addr))\n#define __itt_sync_releasing ITTNOTIFY_VOID(sync_releasing)\n#define __itt_sync_releasing_ptr ITTNOTIFY_NAME(sync_releasing)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_sync_releasing(addr)\n#define __itt_sync_releasing_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_sync_releasing_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} */\n\n/** @} sync group */\n\n// clang-format off\n/**************************************************************//**\n * @name group of functions is used for correctness checking tools\n ******************************************************************/\n// clang-format on\n/** @{ */\n/**\n * @ingroup legacy\n * @deprecated Legacy API\n * @brief Fast synchronization which does no require spinning.\n * - This special function is to be used by TBB and OpenMP libraries only when\n * they know there is no spin but they need to suppress TC warnings about shared\n * variable modifications.\n * - It only has corresponding pointers in static library and does not have\n * corresponding function in dynamic library.\n * @see void __itt_sync_prepare(void* addr);\n */\nvoid ITTAPI __itt_fsync_prepare(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, fsync_prepare, (void *addr))\n#define __itt_fsync_prepare ITTNOTIFY_VOID(fsync_prepare)\n#define __itt_fsync_prepare_ptr ITTNOTIFY_NAME(fsync_prepare)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_fsync_prepare(addr)\n#define __itt_fsync_prepare_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_fsync_prepare_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup legacy\n * @deprecated Legacy API\n * @brief Fast synchronization which does no require spinning.\n * - This special function is to be used by TBB and OpenMP libraries only when\n * they know there is no spin but they need to suppress TC warnings about shared\n * variable modifications.\n * - It only has corresponding pointers in static library and does not have\n * corresponding function in dynamic library.\n * @see void __itt_sync_cancel(void *addr);\n */\nvoid ITTAPI __itt_fsync_cancel(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, fsync_cancel, (void *addr))\n#define __itt_fsync_cancel ITTNOTIFY_VOID(fsync_cancel)\n#define __itt_fsync_cancel_ptr ITTNOTIFY_NAME(fsync_cancel)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_fsync_cancel(addr)\n#define __itt_fsync_cancel_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_fsync_cancel_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup legacy\n * @deprecated Legacy API\n * @brief Fast synchronization which does no require spinning.\n * - This special function is to be used by TBB and OpenMP libraries only when\n * they know there is no spin but they need to suppress TC warnings about shared\n * variable modifications.\n * - It only has corresponding pointers in static library and does not have\n * corresponding function in dynamic library.\n * @see void __itt_sync_acquired(void *addr);\n */\nvoid ITTAPI __itt_fsync_acquired(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, fsync_acquired, (void *addr))\n#define __itt_fsync_acquired ITTNOTIFY_VOID(fsync_acquired)\n#define __itt_fsync_acquired_ptr ITTNOTIFY_NAME(fsync_acquired)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_fsync_acquired(addr)\n#define __itt_fsync_acquired_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_fsync_acquired_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup legacy\n * @deprecated Legacy API\n * @brief Fast synchronization which does no require spinning.\n * - This special function is to be used by TBB and OpenMP libraries only when\n * they know there is no spin but they need to suppress TC warnings about shared\n * variable modifications.\n * - It only has corresponding pointers in static library and does not have\n * corresponding function in dynamic library.\n * @see void __itt_sync_releasing(void* addr);\n */\nvoid ITTAPI __itt_fsync_releasing(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, fsync_releasing, (void *addr))\n#define __itt_fsync_releasing ITTNOTIFY_VOID(fsync_releasing)\n#define __itt_fsync_releasing_ptr ITTNOTIFY_NAME(fsync_releasing)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_fsync_releasing(addr)\n#define __itt_fsync_releasing_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_fsync_releasing_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} */\n\n/**\n * @defgroup model Modeling by Intel(R) Parallel Advisor\n * @ingroup public\n * This is the subset of itt used for modeling by Intel(R) Parallel Advisor.\n * This API is called ONLY using annotate.h, by \"Annotation\" macros\n * the user places in their sources during the parallelism modeling steps.\n *\n * site_begin/end and task_begin/end take the address of handle variables,\n * which are writeable by the API.  Handles must be 0 initialized prior\n * to the first call to begin, or may cause a run-time failure.\n * The handles are initialized in a multi-thread safe way by the API if\n * the handle is 0.  The commonly expected idiom is one static handle to\n * identify a site or task.  If a site or task of the same name has already\n * been started during this collection, the same handle MAY be returned,\n * but is not required to be - it is unspecified if data merging is done\n * based on name.  These routines also take an instance variable.  Like\n * the lexical instance, these must be 0 initialized.  Unlike the lexical\n * instance, this is used to track a single dynamic instance.\n *\n * API used by the Intel(R) Parallel Advisor to describe potential concurrency\n * and related activities. User-added source annotations expand to calls\n * to these procedures to enable modeling of a hypothetical concurrent\n * execution serially.\n * @{\n */\n#if !defined(_ADVISOR_ANNOTATE_H_) || defined(ANNOTATE_EXPAND_NULL)\n\ntypedef void *__itt_model_site; /*!< @brief handle for lexical site     */\ntypedef void\n    *__itt_model_site_instance; /*!< @brief handle for dynamic instance */\ntypedef void *__itt_model_task; /*!< @brief handle for lexical site     */\ntypedef void\n    *__itt_model_task_instance; /*!< @brief handle for dynamic instance */\n\n/**\n * @enum __itt_model_disable\n * @brief Enumerator for the disable methods\n */\ntypedef enum {\n  __itt_model_disable_observation,\n  __itt_model_disable_collection\n} __itt_model_disable;\n\n#endif /* !_ADVISOR_ANNOTATE_H_ || ANNOTATE_EXPAND_NULL */\n\n/**\n * @brief ANNOTATE_SITE_BEGIN/ANNOTATE_SITE_END support.\n *\n * site_begin/end model a potential concurrency site.\n * site instances may be recursively nested with themselves.\n * site_end exits the most recently started but unended site for the current\n * thread.  The handle passed to end may be used to validate structure.\n * Instances of a site encountered on different threads concurrently\n * are considered completely distinct. If the site name for two different\n * lexical sites match, it is unspecified whether they are treated as the\n * same or different for data presentation.\n */\nvoid ITTAPI __itt_model_site_begin(__itt_model_site *site,\n                                   __itt_model_site_instance *instance,\n                                   const char *name);\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_model_site_beginW(const wchar_t *name);\n#endif\nvoid ITTAPI __itt_model_site_beginA(const char *name);\nvoid ITTAPI __itt_model_site_beginAL(const char *name, size_t siteNameLen);\nvoid ITTAPI __itt_model_site_end(__itt_model_site *site,\n                                 __itt_model_site_instance *instance);\nvoid ITTAPI __itt_model_site_end_2(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_site_begin,\n          (__itt_model_site * site, __itt_model_site_instance *instance,\n           const char *name))\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, model_site_beginW, (const wchar_t *name))\n#endif\nITT_STUBV(ITTAPI, void, model_site_beginA, (const char *name))\nITT_STUBV(ITTAPI, void, model_site_beginAL,\n          (const char *name, size_t siteNameLen))\nITT_STUBV(ITTAPI, void, model_site_end,\n          (__itt_model_site * site, __itt_model_site_instance *instance))\nITT_STUBV(ITTAPI, void, model_site_end_2, (void))\n#define __itt_model_site_begin ITTNOTIFY_VOID(model_site_begin)\n#define __itt_model_site_begin_ptr ITTNOTIFY_NAME(model_site_begin)\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_model_site_beginW ITTNOTIFY_VOID(model_site_beginW)\n#define __itt_model_site_beginW_ptr ITTNOTIFY_NAME(model_site_beginW)\n#endif\n#define __itt_model_site_beginA ITTNOTIFY_VOID(model_site_beginA)\n#define __itt_model_site_beginA_ptr ITTNOTIFY_NAME(model_site_beginA)\n#define __itt_model_site_beginAL ITTNOTIFY_VOID(model_site_beginAL)\n#define __itt_model_site_beginAL_ptr ITTNOTIFY_NAME(model_site_beginAL)\n#define __itt_model_site_end ITTNOTIFY_VOID(model_site_end)\n#define __itt_model_site_end_ptr ITTNOTIFY_NAME(model_site_end)\n#define __itt_model_site_end_2 ITTNOTIFY_VOID(model_site_end_2)\n#define __itt_model_site_end_2_ptr ITTNOTIFY_NAME(model_site_end_2)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_site_begin(site, instance, name)\n#define __itt_model_site_begin_ptr 0\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_model_site_beginW(name)\n#define __itt_model_site_beginW_ptr 0\n#endif\n#define __itt_model_site_beginA(name)\n#define __itt_model_site_beginA_ptr 0\n#define __itt_model_site_beginAL(name, siteNameLen)\n#define __itt_model_site_beginAL_ptr 0\n#define __itt_model_site_end(site, instance)\n#define __itt_model_site_end_ptr 0\n#define __itt_model_site_end_2()\n#define __itt_model_site_end_2_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_site_begin_ptr 0\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_model_site_beginW_ptr 0\n#endif\n#define __itt_model_site_beginA_ptr 0\n#define __itt_model_site_beginAL_ptr 0\n#define __itt_model_site_end_ptr 0\n#define __itt_model_site_end_2_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_TASK_BEGIN/ANNOTATE_TASK_END support\n *\n * task_begin/end model a potential task, which is contained within the most\n * closely enclosing dynamic site.  task_end exits the most recently started\n * but unended task.  The handle passed to end may be used to validate\n * structure.  It is unspecified if bad dynamic nesting is detected.  If it\n * is, it should be encoded in the resulting data collection.  The collector\n * should not fail due to construct nesting issues, nor attempt to directly\n * indicate the problem.\n */\nvoid ITTAPI __itt_model_task_begin(__itt_model_task *task,\n                                   __itt_model_task_instance *instance,\n                                   const char *name);\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_model_task_beginW(const wchar_t *name);\nvoid ITTAPI __itt_model_iteration_taskW(const wchar_t *name);\n#endif\nvoid ITTAPI __itt_model_task_beginA(const char *name);\nvoid ITTAPI __itt_model_task_beginAL(const char *name, size_t taskNameLen);\nvoid ITTAPI __itt_model_iteration_taskA(const char *name);\nvoid ITTAPI __itt_model_iteration_taskAL(const char *name, size_t taskNameLen);\nvoid ITTAPI __itt_model_task_end(__itt_model_task *task,\n                                 __itt_model_task_instance *instance);\nvoid ITTAPI __itt_model_task_end_2(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_task_begin,\n          (__itt_model_task * task, __itt_model_task_instance *instance,\n           const char *name))\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, model_task_beginW, (const wchar_t *name))\nITT_STUBV(ITTAPI, void, model_iteration_taskW, (const wchar_t *name))\n#endif\nITT_STUBV(ITTAPI, void, model_task_beginA, (const char *name))\nITT_STUBV(ITTAPI, void, model_task_beginAL,\n          (const char *name, size_t taskNameLen))\nITT_STUBV(ITTAPI, void, model_iteration_taskA, (const char *name))\nITT_STUBV(ITTAPI, void, model_iteration_taskAL,\n          (const char *name, size_t taskNameLen))\nITT_STUBV(ITTAPI, void, model_task_end,\n          (__itt_model_task * task, __itt_model_task_instance *instance))\nITT_STUBV(ITTAPI, void, model_task_end_2, (void))\n#define __itt_model_task_begin ITTNOTIFY_VOID(model_task_begin)\n#define __itt_model_task_begin_ptr ITTNOTIFY_NAME(model_task_begin)\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_model_task_beginW ITTNOTIFY_VOID(model_task_beginW)\n#define __itt_model_task_beginW_ptr ITTNOTIFY_NAME(model_task_beginW)\n#define __itt_model_iteration_taskW ITTNOTIFY_VOID(model_iteration_taskW)\n#define __itt_model_iteration_taskW_ptr ITTNOTIFY_NAME(model_iteration_taskW)\n#endif\n#define __itt_model_task_beginA ITTNOTIFY_VOID(model_task_beginA)\n#define __itt_model_task_beginA_ptr ITTNOTIFY_NAME(model_task_beginA)\n#define __itt_model_task_beginAL ITTNOTIFY_VOID(model_task_beginAL)\n#define __itt_model_task_beginAL_ptr ITTNOTIFY_NAME(model_task_beginAL)\n#define __itt_model_iteration_taskA ITTNOTIFY_VOID(model_iteration_taskA)\n#define __itt_model_iteration_taskA_ptr ITTNOTIFY_NAME(model_iteration_taskA)\n#define __itt_model_iteration_taskAL ITTNOTIFY_VOID(model_iteration_taskAL)\n#define __itt_model_iteration_taskAL_ptr ITTNOTIFY_NAME(model_iteration_taskAL)\n#define __itt_model_task_end ITTNOTIFY_VOID(model_task_end)\n#define __itt_model_task_end_ptr ITTNOTIFY_NAME(model_task_end)\n#define __itt_model_task_end_2 ITTNOTIFY_VOID(model_task_end_2)\n#define __itt_model_task_end_2_ptr ITTNOTIFY_NAME(model_task_end_2)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_task_begin(task, instance, name)\n#define __itt_model_task_begin_ptr 0\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_model_task_beginW(name)\n#define __itt_model_task_beginW_ptr 0\n#endif\n#define __itt_model_task_beginA(name)\n#define __itt_model_task_beginA_ptr 0\n#define __itt_model_task_beginAL(name, siteNameLen)\n#define __itt_model_task_beginAL_ptr 0\n#define __itt_model_iteration_taskA(name)\n#define __itt_model_iteration_taskA_ptr 0\n#define __itt_model_iteration_taskAL(name, siteNameLen)\n#define __itt_model_iteration_taskAL_ptr 0\n#define __itt_model_task_end(task, instance)\n#define __itt_model_task_end_ptr 0\n#define __itt_model_task_end_2()\n#define __itt_model_task_end_2_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_task_begin_ptr 0\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_model_task_beginW_ptr 0\n#endif\n#define __itt_model_task_beginA_ptr 0\n#define __itt_model_task_beginAL_ptr 0\n#define __itt_model_iteration_taskA_ptr 0\n#define __itt_model_iteration_taskAL_ptr 0\n#define __itt_model_task_end_ptr 0\n#define __itt_model_task_end_2_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_LOCK_ACQUIRE/ANNOTATE_LOCK_RELEASE support\n *\n * lock_acquire/release model a potential lock for both lockset and\n * performance modeling.  Each unique address is modeled as a separate\n * lock, with invalid addresses being valid lock IDs.  Specifically:\n * no storage is accessed by the API at the specified address - it is only\n * used for lock identification.  Lock acquires may be self-nested and are\n * unlocked by a corresponding number of releases.\n * (These closely correspond to __itt_sync_acquired/__itt_sync_releasing,\n * but may not have identical semantics.)\n */\nvoid ITTAPI __itt_model_lock_acquire(void *lock);\nvoid ITTAPI __itt_model_lock_acquire_2(void *lock);\nvoid ITTAPI __itt_model_lock_release(void *lock);\nvoid ITTAPI __itt_model_lock_release_2(void *lock);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_lock_acquire, (void *lock))\nITT_STUBV(ITTAPI, void, model_lock_acquire_2, (void *lock))\nITT_STUBV(ITTAPI, void, model_lock_release, (void *lock))\nITT_STUBV(ITTAPI, void, model_lock_release_2, (void *lock))\n#define __itt_model_lock_acquire ITTNOTIFY_VOID(model_lock_acquire)\n#define __itt_model_lock_acquire_ptr ITTNOTIFY_NAME(model_lock_acquire)\n#define __itt_model_lock_acquire_2 ITTNOTIFY_VOID(model_lock_acquire_2)\n#define __itt_model_lock_acquire_2_ptr ITTNOTIFY_NAME(model_lock_acquire_2)\n#define __itt_model_lock_release ITTNOTIFY_VOID(model_lock_release)\n#define __itt_model_lock_release_ptr ITTNOTIFY_NAME(model_lock_release)\n#define __itt_model_lock_release_2 ITTNOTIFY_VOID(model_lock_release_2)\n#define __itt_model_lock_release_2_ptr ITTNOTIFY_NAME(model_lock_release_2)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_lock_acquire(lock)\n#define __itt_model_lock_acquire_ptr 0\n#define __itt_model_lock_acquire_2(lock)\n#define __itt_model_lock_acquire_2_ptr 0\n#define __itt_model_lock_release(lock)\n#define __itt_model_lock_release_ptr 0\n#define __itt_model_lock_release_2(lock)\n#define __itt_model_lock_release_2_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_lock_acquire_ptr 0\n#define __itt_model_lock_acquire_2_ptr 0\n#define __itt_model_lock_release_ptr 0\n#define __itt_model_lock_release_2_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_RECORD_ALLOCATION/ANNOTATE_RECORD_DEALLOCATION support\n *\n * record_allocation/deallocation describe user-defined memory allocator\n * behavior, which may be required for correctness modeling to understand\n * when storage is not expected to be actually reused across threads.\n */\nvoid ITTAPI __itt_model_record_allocation(void *addr, size_t size);\nvoid ITTAPI __itt_model_record_deallocation(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_record_allocation, (void *addr, size_t size))\nITT_STUBV(ITTAPI, void, model_record_deallocation, (void *addr))\n#define __itt_model_record_allocation ITTNOTIFY_VOID(model_record_allocation)\n#define __itt_model_record_allocation_ptr                                      \\\n  ITTNOTIFY_NAME(model_record_allocation)\n#define __itt_model_record_deallocation                                        \\\n  ITTNOTIFY_VOID(model_record_deallocation)\n#define __itt_model_record_deallocation_ptr                                    \\\n  ITTNOTIFY_NAME(model_record_deallocation)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_record_allocation(addr, size)\n#define __itt_model_record_allocation_ptr 0\n#define __itt_model_record_deallocation(addr)\n#define __itt_model_record_deallocation_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_record_allocation_ptr 0\n#define __itt_model_record_deallocation_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_INDUCTION_USES support\n *\n * Note particular storage is inductive through the end of the current site\n */\nvoid ITTAPI __itt_model_induction_uses(void *addr, size_t size);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_induction_uses, (void *addr, size_t size))\n#define __itt_model_induction_uses ITTNOTIFY_VOID(model_induction_uses)\n#define __itt_model_induction_uses_ptr ITTNOTIFY_NAME(model_induction_uses)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_induction_uses(addr, size)\n#define __itt_model_induction_uses_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_induction_uses_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_REDUCTION_USES support\n *\n * Note particular storage is used for reduction through the end\n * of the current site\n */\nvoid ITTAPI __itt_model_reduction_uses(void *addr, size_t size);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_reduction_uses, (void *addr, size_t size))\n#define __itt_model_reduction_uses ITTNOTIFY_VOID(model_reduction_uses)\n#define __itt_model_reduction_uses_ptr ITTNOTIFY_NAME(model_reduction_uses)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_reduction_uses(addr, size)\n#define __itt_model_reduction_uses_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_reduction_uses_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_OBSERVE_USES support\n *\n * Have correctness modeling record observations about uses of storage\n * through the end of the current site\n */\nvoid ITTAPI __itt_model_observe_uses(void *addr, size_t size);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_observe_uses, (void *addr, size_t size))\n#define __itt_model_observe_uses ITTNOTIFY_VOID(model_observe_uses)\n#define __itt_model_observe_uses_ptr ITTNOTIFY_NAME(model_observe_uses)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_observe_uses(addr, size)\n#define __itt_model_observe_uses_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_observe_uses_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_CLEAR_USES support\n *\n * Clear the special handling of a piece of storage related to induction,\n * reduction or observe_uses\n */\nvoid ITTAPI __itt_model_clear_uses(void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_clear_uses, (void *addr))\n#define __itt_model_clear_uses ITTNOTIFY_VOID(model_clear_uses)\n#define __itt_model_clear_uses_ptr ITTNOTIFY_NAME(model_clear_uses)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_clear_uses(addr)\n#define __itt_model_clear_uses_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_clear_uses_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief ANNOTATE_DISABLE_*_PUSH/ANNOTATE_DISABLE_*_POP support\n *\n * disable_push/disable_pop push and pop disabling based on a parameter.\n * Disabling observations stops processing of memory references during\n * correctness modeling, and all annotations that occur in the disabled\n * region.  This allows description of code that is expected to be handled\n * specially during conversion to parallelism or that is not recognized\n * by tools (e.g. some kinds of synchronization operations.)\n * This mechanism causes all annotations in the disabled region, other\n * than disable_push and disable_pop, to be ignored.  (For example, this\n * might validly be used to disable an entire parallel site and the contained\n * tasks and locking in it for data collection purposes.)\n * The disable for collection is a more expensive operation, but reduces\n * collector overhead significantly.  This applies to BOTH correctness data\n * collection and performance data collection.  For example, a site\n * containing a task might only enable data collection for the first 10\n * iterations.  Both performance and correctness data should reflect this,\n * and the program should run as close to full speed as possible when\n * collection is disabled.\n */\nvoid ITTAPI __itt_model_disable_push(__itt_model_disable x);\nvoid ITTAPI __itt_model_disable_pop(void);\nvoid ITTAPI __itt_model_aggregate_task(size_t x);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, model_disable_push, (__itt_model_disable x))\nITT_STUBV(ITTAPI, void, model_disable_pop, (void))\nITT_STUBV(ITTAPI, void, model_aggregate_task, (size_t x))\n#define __itt_model_disable_push ITTNOTIFY_VOID(model_disable_push)\n#define __itt_model_disable_push_ptr ITTNOTIFY_NAME(model_disable_push)\n#define __itt_model_disable_pop ITTNOTIFY_VOID(model_disable_pop)\n#define __itt_model_disable_pop_ptr ITTNOTIFY_NAME(model_disable_pop)\n#define __itt_model_aggregate_task ITTNOTIFY_VOID(model_aggregate_task)\n#define __itt_model_aggregate_task_ptr ITTNOTIFY_NAME(model_aggregate_task)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_model_disable_push(x)\n#define __itt_model_disable_push_ptr 0\n#define __itt_model_disable_pop()\n#define __itt_model_disable_pop_ptr 0\n#define __itt_model_aggregate_task(x)\n#define __itt_model_aggregate_task_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_model_disable_push_ptr 0\n#define __itt_model_disable_pop_ptr 0\n#define __itt_model_aggregate_task_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} model group */\n\n/**\n * @defgroup heap Heap\n * @ingroup public\n * Heap group\n * @{\n */\n\ntypedef void *__itt_heap_function;\n\n/**\n * @brief Create an identification for heap function\n * @return non-zero identifier or NULL\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_heap_function ITTAPI __itt_heap_function_createA(const char *name,\n                                                       const char *domain);\n__itt_heap_function ITTAPI __itt_heap_function_createW(const wchar_t *name,\n                                                       const wchar_t *domain);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_heap_function_create __itt_heap_function_createW\n#define __itt_heap_function_create_ptr __itt_heap_function_createW_ptr\n#else\n#define __itt_heap_function_create __itt_heap_function_createA\n#define __itt_heap_function_create_ptr __itt_heap_function_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_heap_function ITTAPI __itt_heap_function_create(const char *name,\n                                                      const char *domain);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, __itt_heap_function, heap_function_createA,\n         (const char *name, const char *domain))\nITT_STUB(ITTAPI, __itt_heap_function, heap_function_createW,\n         (const wchar_t *name, const wchar_t *domain))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, __itt_heap_function, heap_function_create,\n         (const char *name, const char *domain))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_heap_function_createA ITTNOTIFY_DATA(heap_function_createA)\n#define __itt_heap_function_createA_ptr ITTNOTIFY_NAME(heap_function_createA)\n#define __itt_heap_function_createW ITTNOTIFY_DATA(heap_function_createW)\n#define __itt_heap_function_createW_ptr ITTNOTIFY_NAME(heap_function_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_heap_function_create ITTNOTIFY_DATA(heap_function_create)\n#define __itt_heap_function_create_ptr ITTNOTIFY_NAME(heap_function_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_heap_function_createA(name, domain) (__itt_heap_function)0\n#define __itt_heap_function_createA_ptr 0\n#define __itt_heap_function_createW(name, domain) (__itt_heap_function)0\n#define __itt_heap_function_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_heap_function_create(name, domain) (__itt_heap_function)0\n#define __itt_heap_function_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_heap_function_createA_ptr 0\n#define __itt_heap_function_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_heap_function_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record an allocation begin occurrence.\n */\nvoid ITTAPI __itt_heap_allocate_begin(__itt_heap_function h, size_t size,\n                                      int initialized);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_allocate_begin,\n          (__itt_heap_function h, size_t size, int initialized))\n#define __itt_heap_allocate_begin ITTNOTIFY_VOID(heap_allocate_begin)\n#define __itt_heap_allocate_begin_ptr ITTNOTIFY_NAME(heap_allocate_begin)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_allocate_begin(h, size, initialized)\n#define __itt_heap_allocate_begin_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_allocate_begin_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record an allocation end occurrence.\n */\nvoid ITTAPI __itt_heap_allocate_end(__itt_heap_function h, void **addr,\n                                    size_t size, int initialized);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_allocate_end,\n          (__itt_heap_function h, void **addr, size_t size, int initialized))\n#define __itt_heap_allocate_end ITTNOTIFY_VOID(heap_allocate_end)\n#define __itt_heap_allocate_end_ptr ITTNOTIFY_NAME(heap_allocate_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_allocate_end(h, addr, size, initialized)\n#define __itt_heap_allocate_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_allocate_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record a free begin occurrence.\n */\nvoid ITTAPI __itt_heap_free_begin(__itt_heap_function h, void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_free_begin, (__itt_heap_function h, void *addr))\n#define __itt_heap_free_begin ITTNOTIFY_VOID(heap_free_begin)\n#define __itt_heap_free_begin_ptr ITTNOTIFY_NAME(heap_free_begin)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_free_begin(h, addr)\n#define __itt_heap_free_begin_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_free_begin_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record a free end occurrence.\n */\nvoid ITTAPI __itt_heap_free_end(__itt_heap_function h, void *addr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_free_end, (__itt_heap_function h, void *addr))\n#define __itt_heap_free_end ITTNOTIFY_VOID(heap_free_end)\n#define __itt_heap_free_end_ptr ITTNOTIFY_NAME(heap_free_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_free_end(h, addr)\n#define __itt_heap_free_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_free_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record a reallocation begin occurrence.\n */\nvoid ITTAPI __itt_heap_reallocate_begin(__itt_heap_function h, void *addr,\n                                        size_t new_size, int initialized);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_reallocate_begin,\n          (__itt_heap_function h, void *addr, size_t new_size, int initialized))\n#define __itt_heap_reallocate_begin ITTNOTIFY_VOID(heap_reallocate_begin)\n#define __itt_heap_reallocate_begin_ptr ITTNOTIFY_NAME(heap_reallocate_begin)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_reallocate_begin(h, addr, new_size, initialized)\n#define __itt_heap_reallocate_begin_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_reallocate_begin_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record a reallocation end occurrence.\n */\nvoid ITTAPI __itt_heap_reallocate_end(__itt_heap_function h, void *addr,\n                                      void **new_addr, size_t new_size,\n                                      int initialized);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_reallocate_end,\n          (__itt_heap_function h, void *addr, void **new_addr, size_t new_size,\n           int initialized))\n#define __itt_heap_reallocate_end ITTNOTIFY_VOID(heap_reallocate_end)\n#define __itt_heap_reallocate_end_ptr ITTNOTIFY_NAME(heap_reallocate_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_reallocate_end(h, addr, new_addr, new_size, initialized)\n#define __itt_heap_reallocate_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_reallocate_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @brief internal access begin */\nvoid ITTAPI __itt_heap_internal_access_begin(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_internal_access_begin, (void))\n#define __itt_heap_internal_access_begin                                       \\\n  ITTNOTIFY_VOID(heap_internal_access_begin)\n#define __itt_heap_internal_access_begin_ptr                                   \\\n  ITTNOTIFY_NAME(heap_internal_access_begin)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_internal_access_begin()\n#define __itt_heap_internal_access_begin_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_internal_access_begin_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @brief internal access end */\nvoid ITTAPI __itt_heap_internal_access_end(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_internal_access_end, (void))\n#define __itt_heap_internal_access_end ITTNOTIFY_VOID(heap_internal_access_end)\n#define __itt_heap_internal_access_end_ptr                                     \\\n  ITTNOTIFY_NAME(heap_internal_access_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_internal_access_end()\n#define __itt_heap_internal_access_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_internal_access_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @brief record memory growth begin */\nvoid ITTAPI __itt_heap_record_memory_growth_begin(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_record_memory_growth_begin, (void))\n#define __itt_heap_record_memory_growth_begin                                  \\\n  ITTNOTIFY_VOID(heap_record_memory_growth_begin)\n#define __itt_heap_record_memory_growth_begin_ptr                              \\\n  ITTNOTIFY_NAME(heap_record_memory_growth_begin)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_record_memory_growth_begin()\n#define __itt_heap_record_memory_growth_begin_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_record_memory_growth_begin_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @brief record memory growth end */\nvoid ITTAPI __itt_heap_record_memory_growth_end(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_record_memory_growth_end, (void))\n#define __itt_heap_record_memory_growth_end                                    \\\n  ITTNOTIFY_VOID(heap_record_memory_growth_end)\n#define __itt_heap_record_memory_growth_end_ptr                                \\\n  ITTNOTIFY_NAME(heap_record_memory_growth_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_record_memory_growth_end()\n#define __itt_heap_record_memory_growth_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_record_memory_growth_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Specify the type of heap detection/reporting to modify.\n */\n/**\n * @hideinitializer\n * @brief Report on memory leaks.\n */\n#define __itt_heap_leaks 0x00000001\n\n/**\n * @hideinitializer\n * @brief Report on memory growth.\n */\n#define __itt_heap_growth 0x00000002\n\n/** @brief heap reset detection */\nvoid ITTAPI __itt_heap_reset_detection(unsigned int reset_mask);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_reset_detection, (unsigned int reset_mask))\n#define __itt_heap_reset_detection ITTNOTIFY_VOID(heap_reset_detection)\n#define __itt_heap_reset_detection_ptr ITTNOTIFY_NAME(heap_reset_detection)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_reset_detection()\n#define __itt_heap_reset_detection_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_reset_detection_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @brief report */\nvoid ITTAPI __itt_heap_record(unsigned int record_mask);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, heap_record, (unsigned int record_mask))\n#define __itt_heap_record ITTNOTIFY_VOID(heap_record)\n#define __itt_heap_record_ptr ITTNOTIFY_NAME(heap_record)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_heap_record()\n#define __itt_heap_record_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_heap_record_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @} heap group */\n/** @endcond */\n/* ========================================================================== */\n\n/**\n * @defgroup domains Domains\n * @ingroup public\n * Domains group\n * @{\n */\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_domain {\n  volatile int flags; /*!< Zero if disabled, non-zero if enabled. The meaning of\n                         different non-zero values is reserved to the runtime */\n  const char *nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n  const wchar_t *nameW; /*!< Copy of original name in UNICODE. */\n#else /* UNICODE || _UNICODE */\n  void *nameW;\n#endif /* UNICODE || _UNICODE */\n  int extra1; /*!< Reserved to the runtime */\n  void *extra2; /*!< Reserved to the runtime */\n  struct ___itt_domain *next;\n} __itt_domain;\n\n#pragma pack(pop)\n/** @endcond */\n\n/**\n * @ingroup domains\n * @brief Create a domain.\n * Create domain using some domain name: the URI naming style is recommended.\n * Because the set of domains is expected to be static over the application's\n * execution time, there is no mechanism to destroy a domain.\n * Any domain can be accessed by any thread in the process, regardless of\n * which thread created the domain. This call is thread-safe.\n * @param[in] name name of domain\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_domain *ITTAPI __itt_domain_createA(const char *name);\n__itt_domain *ITTAPI __itt_domain_createW(const wchar_t *name);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_domain_create __itt_domain_createW\n#define __itt_domain_create_ptr __itt_domain_createW_ptr\n#else /* UNICODE */\n#define __itt_domain_create __itt_domain_createA\n#define __itt_domain_create_ptr __itt_domain_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_domain *ITTAPI __itt_domain_create(const char *name);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, __itt_domain *, domain_createA, (const char *name))\nITT_STUB(ITTAPI, __itt_domain *, domain_createW, (const wchar_t *name))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, __itt_domain *, domain_create, (const char *name))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_domain_createA ITTNOTIFY_DATA(domain_createA)\n#define __itt_domain_createA_ptr ITTNOTIFY_NAME(domain_createA)\n#define __itt_domain_createW ITTNOTIFY_DATA(domain_createW)\n#define __itt_domain_createW_ptr ITTNOTIFY_NAME(domain_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_domain_create ITTNOTIFY_DATA(domain_create)\n#define __itt_domain_create_ptr ITTNOTIFY_NAME(domain_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_domain_createA(name) (__itt_domain *)0\n#define __itt_domain_createA_ptr 0\n#define __itt_domain_createW(name) (__itt_domain *)0\n#define __itt_domain_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_domain_create(name) (__itt_domain *)0\n#define __itt_domain_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_domain_createA_ptr 0\n#define __itt_domain_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_domain_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} domains group */\n\n/**\n * @defgroup ids IDs\n * @ingroup public\n * IDs group\n * @{\n */\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_id {\n  unsigned long long d1, d2, d3;\n} __itt_id;\n\n#pragma pack(pop)\n/** @endcond */\n\nstatic const __itt_id __itt_null = {0, 0, 0};\n\n/**\n * @ingroup ids\n * @brief A convenience function is provided to create an ID without domain\n * control.\n * @brief This is a convenience function to initialize an __itt_id structure.\n * This function does not affect the collector runtime in any way. After you\n * make the ID with this function, you still must create it with the\n * __itt_id_create function before using the ID to identify a named entity.\n * @param[in] addr The address of object; high QWORD of the ID value.\n * @param[in] extra The extra data to unique identify object; low QWORD of the\n * ID value.\n */\n\nITT_INLINE __itt_id ITTAPI __itt_id_make(void *addr, unsigned long long extra)\n    ITT_INLINE_ATTRIBUTE;\nITT_INLINE __itt_id ITTAPI __itt_id_make(void *addr, unsigned long long extra) {\n  __itt_id id = __itt_null;\n  id.d1 = (unsigned long long)((uintptr_t)addr);\n  id.d2 = (unsigned long long)extra;\n  id.d3 = (unsigned long long)0; /* Reserved. Must be zero */\n  return id;\n}\n\n/**\n * @ingroup ids\n * @brief Create an instance of identifier.\n * This establishes the beginning of the lifetime of an instance of\n * the given ID in the trace. Once this lifetime starts, the ID\n * can be used to tag named entity instances in calls such as\n * __itt_task_begin, and to specify relationships among\n * identified named entity instances, using the \\ref relations APIs.\n * Instance IDs are not domain specific!\n * @param[in] domain The domain controlling the execution of this call.\n * @param[in] id The ID to create.\n */\nvoid ITTAPI __itt_id_create(const __itt_domain *domain, __itt_id id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, id_create, (const __itt_domain *domain, __itt_id id))\n#define __itt_id_create(d, x) ITTNOTIFY_VOID_D1(id_create, d, x)\n#define __itt_id_create_ptr ITTNOTIFY_NAME(id_create)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_id_create(domain, id)\n#define __itt_id_create_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_id_create_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup ids\n * @brief Destroy an instance of identifier.\n * This ends the lifetime of the current instance of the given ID value in the\n * trace. Any relationships that are established after this lifetime ends are\n * invalid. This call must be performed before the given ID value can be reused\n * for a different named entity instance.\n * @param[in] domain The domain controlling the execution of this call.\n * @param[in] id The ID to destroy.\n */\nvoid ITTAPI __itt_id_destroy(const __itt_domain *domain, __itt_id id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, id_destroy, (const __itt_domain *domain, __itt_id id))\n#define __itt_id_destroy(d, x) ITTNOTIFY_VOID_D1(id_destroy, d, x)\n#define __itt_id_destroy_ptr ITTNOTIFY_NAME(id_destroy)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_id_destroy(domain, id)\n#define __itt_id_destroy_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_id_destroy_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} ids group */\n\n/**\n * @defgroup handless String Handles\n * @ingroup public\n * String Handles group\n * @{\n */\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_string_handle {\n  const char *strA; /*!< Copy of original string in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n  const wchar_t *strW; /*!< Copy of original string in UNICODE. */\n#else /* UNICODE || _UNICODE */\n  void *strW;\n#endif /* UNICODE || _UNICODE */\n  int extra1; /*!< Reserved. Must be zero   */\n  void *extra2; /*!< Reserved. Must be zero   */\n  struct ___itt_string_handle *next;\n} __itt_string_handle;\n\n#pragma pack(pop)\n/** @endcond */\n\n/**\n * @ingroup handles\n * @brief Create a string handle.\n * Create and return handle value that can be associated with a string.\n * Consecutive calls to __itt_string_handle_create with the same name\n * return the same value. Because the set of string handles is expected to\n * remain static during the application's execution time, there is no mechanism\n * to destroy a string handle. Any string handle can be accessed by any thread\n * in the process, regardless of which thread created the string handle. This\n * call is thread-safe.\n * @param[in] name The input string\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_string_handle *ITTAPI __itt_string_handle_createA(const char *name);\n__itt_string_handle *ITTAPI __itt_string_handle_createW(const wchar_t *name);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_string_handle_create __itt_string_handle_createW\n#define __itt_string_handle_create_ptr __itt_string_handle_createW_ptr\n#else /* UNICODE */\n#define __itt_string_handle_create __itt_string_handle_createA\n#define __itt_string_handle_create_ptr __itt_string_handle_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_string_handle *ITTAPI __itt_string_handle_create(const char *name);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, __itt_string_handle *, string_handle_createA,\n         (const char *name))\nITT_STUB(ITTAPI, __itt_string_handle *, string_handle_createW,\n         (const wchar_t *name))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, __itt_string_handle *, string_handle_create,\n         (const char *name))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_string_handle_createA ITTNOTIFY_DATA(string_handle_createA)\n#define __itt_string_handle_createA_ptr ITTNOTIFY_NAME(string_handle_createA)\n#define __itt_string_handle_createW ITTNOTIFY_DATA(string_handle_createW)\n#define __itt_string_handle_createW_ptr ITTNOTIFY_NAME(string_handle_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_string_handle_create ITTNOTIFY_DATA(string_handle_create)\n#define __itt_string_handle_create_ptr ITTNOTIFY_NAME(string_handle_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_string_handle_createA(name) (__itt_string_handle *)0\n#define __itt_string_handle_createA_ptr 0\n#define __itt_string_handle_createW(name) (__itt_string_handle *)0\n#define __itt_string_handle_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_string_handle_create(name) (__itt_string_handle *)0\n#define __itt_string_handle_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_string_handle_createA_ptr 0\n#define __itt_string_handle_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_string_handle_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} handles group */\n\n/** @cond exclude_from_documentation */\ntypedef unsigned long long __itt_timestamp;\n/** @endcond */\n\n#define __itt_timestamp_none ((__itt_timestamp)-1LL)\n\n/** @cond exclude_from_gpa_documentation */\n\n/**\n * @ingroup timestamps\n * @brief Return timestamp corresponding to the current moment.\n * This returns the timestamp in the format that is the most relevant for the\n * current host or platform (RDTSC, QPC, and others). You can use the \"<\"\n * operator to compare __itt_timestamp values.\n */\n__itt_timestamp ITTAPI __itt_get_timestamp(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, __itt_timestamp, get_timestamp, (void))\n#define __itt_get_timestamp ITTNOTIFY_DATA(get_timestamp)\n#define __itt_get_timestamp_ptr ITTNOTIFY_NAME(get_timestamp)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_get_timestamp()\n#define __itt_get_timestamp_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_get_timestamp_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} timestamps */\n/** @endcond */\n\n/** @cond exclude_from_gpa_documentation */\n\n/**\n * @defgroup regions Regions\n * @ingroup public\n * Regions group\n * @{\n */\n/**\n * @ingroup regions\n * @brief Begin of region instance.\n * Successive calls to __itt_region_begin with the same ID are ignored\n * until a call to __itt_region_end with the same ID\n * @param[in] domain The domain for this region instance\n * @param[in] id The instance ID for this region instance. Must not be\n * __itt_null\n * @param[in] parentid The instance ID for the parent of this region instance,\n * or __itt_null\n * @param[in] name The name of this region\n */\nvoid ITTAPI __itt_region_begin(const __itt_domain *domain, __itt_id id,\n                               __itt_id parentid, __itt_string_handle *name);\n\n/**\n * @ingroup regions\n * @brief End of region instance.\n * The first call to __itt_region_end with a given ID ends the\n * region. Successive calls with the same ID are ignored, as are\n * calls that do not have a matching __itt_region_begin call.\n * @param[in] domain The domain for this region instance\n * @param[in] id The instance ID for this region instance\n */\nvoid ITTAPI __itt_region_end(const __itt_domain *domain, __itt_id id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, region_begin,\n          (const __itt_domain *domain, __itt_id id, __itt_id parentid,\n           __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, region_end, (const __itt_domain *domain, __itt_id id))\n#define __itt_region_begin(d, x, y, z)                                         \\\n  ITTNOTIFY_VOID_D3(region_begin, d, x, y, z)\n#define __itt_region_begin_ptr ITTNOTIFY_NAME(region_begin)\n#define __itt_region_end(d, x) ITTNOTIFY_VOID_D1(region_end, d, x)\n#define __itt_region_end_ptr ITTNOTIFY_NAME(region_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_region_begin(d, x, y, z)\n#define __itt_region_begin_ptr 0\n#define __itt_region_end(d, x)\n#define __itt_region_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_region_begin_ptr 0\n#define __itt_region_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} regions group */\n\n/**\n * @defgroup frames Frames\n * @ingroup public\n * Frames are similar to regions, but are intended to be easier to use and to\n * implement. In particular:\n * - Frames always represent periods of elapsed time\n * - By default, frames have no nesting relationships\n * @{\n */\n\n/**\n * @ingroup frames\n * @brief Begin a frame instance.\n * Successive calls to __itt_frame_begin with the\n * same ID are ignored until a call to __itt_frame_end with the same ID.\n * @param[in] domain The domain for this frame instance\n * @param[in] id The instance ID for this frame instance or NULL\n */\nvoid ITTAPI __itt_frame_begin_v3(const __itt_domain *domain, __itt_id *id);\n\n/**\n * @ingroup frames\n * @brief End a frame instance.\n * The first call to __itt_frame_end with a given ID\n * ends the frame. Successive calls with the same ID are ignored, as are\n * calls that do not have a matching __itt_frame_begin call.\n * @param[in] domain The domain for this frame instance\n * @param[in] id The instance ID for this frame instance or NULL for current\n */\nvoid ITTAPI __itt_frame_end_v3(const __itt_domain *domain, __itt_id *id);\n\n/**\n * @ingroup frames\n * @brief Submits a frame instance.\n * Successive calls to __itt_frame_begin or __itt_frame_submit with the\n * same ID are ignored until a call to __itt_frame_end or __itt_frame_submit\n * with the same ID.\n * Passing special __itt_timestamp_none value as \"end\" argument means\n * take the current timestamp as the end timestamp.\n * @param[in] domain The domain for this frame instance\n * @param[in] id The instance ID for this frame instance or NULL\n * @param[in] begin Timestamp of the beginning of the frame\n * @param[in] end Timestamp of the end of the frame\n */\nvoid ITTAPI __itt_frame_submit_v3(const __itt_domain *domain, __itt_id *id,\n                                  __itt_timestamp begin, __itt_timestamp end);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, frame_begin_v3,\n          (const __itt_domain *domain, __itt_id *id))\nITT_STUBV(ITTAPI, void, frame_end_v3,\n          (const __itt_domain *domain, __itt_id *id))\nITT_STUBV(ITTAPI, void, frame_submit_v3,\n          (const __itt_domain *domain, __itt_id *id, __itt_timestamp begin,\n           __itt_timestamp end))\n#define __itt_frame_begin_v3(d, x) ITTNOTIFY_VOID_D1(frame_begin_v3, d, x)\n#define __itt_frame_begin_v3_ptr ITTNOTIFY_NAME(frame_begin_v3)\n#define __itt_frame_end_v3(d, x) ITTNOTIFY_VOID_D1(frame_end_v3, d, x)\n#define __itt_frame_end_v3_ptr ITTNOTIFY_NAME(frame_end_v3)\n#define __itt_frame_submit_v3(d, x, b, e)                                      \\\n  ITTNOTIFY_VOID_D3(frame_submit_v3, d, x, b, e)\n#define __itt_frame_submit_v3_ptr ITTNOTIFY_NAME(frame_submit_v3)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_frame_begin_v3(domain, id)\n#define __itt_frame_begin_v3_ptr 0\n#define __itt_frame_end_v3(domain, id)\n#define __itt_frame_end_v3_ptr 0\n#define __itt_frame_submit_v3(domain, id, begin, end)\n#define __itt_frame_submit_v3_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_frame_begin_v3_ptr 0\n#define __itt_frame_end_v3_ptr 0\n#define __itt_frame_submit_v3_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} frames group */\n/** @endcond */\n\n/**\n * @defgroup taskgroup Task Group\n * @ingroup public\n * Task Group\n * @{\n */\n/**\n * @ingroup task_groups\n * @brief Denotes a task_group instance.\n * Successive calls to __itt_task_group with the same ID are ignored.\n * @param[in] domain The domain for this task_group instance\n * @param[in] id The instance ID for this task_group instance. Must not be\n * __itt_null.\n * @param[in] parentid The instance ID for the parent of this task_group\n * instance, or __itt_null.\n * @param[in] name The name of this task_group\n */\nvoid ITTAPI __itt_task_group(const __itt_domain *domain, __itt_id id,\n                             __itt_id parentid, __itt_string_handle *name);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, task_group,\n          (const __itt_domain *domain, __itt_id id, __itt_id parentid,\n           __itt_string_handle *name))\n#define __itt_task_group(d, x, y, z) ITTNOTIFY_VOID_D3(task_group, d, x, y, z)\n#define __itt_task_group_ptr ITTNOTIFY_NAME(task_group)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_task_group(d, x, y, z)\n#define __itt_task_group_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_task_group_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} taskgroup group */\n\n/**\n * @defgroup tasks Tasks\n * @ingroup public\n * A task instance represents a piece of work performed by a particular\n * thread for a period of time. A call to __itt_task_begin creates a\n * task instance. This becomes the current instance for that task on that\n * thread. A following call to __itt_task_end on the same thread ends the\n * instance. There may be multiple simultaneous instances of tasks with the\n * same name on different threads. If an ID is specified, the task instance\n * receives that ID. Nested tasks are allowed.\n *\n * Note: The task is defined by the bracketing of __itt_task_begin and\n * __itt_task_end on the same thread. If some scheduling mechanism causes\n * task switching (the thread executes a different user task) or task\n * switching (the user task switches to a different thread) then this breaks\n * the notion of  current instance. Additional API calls are required to\n * deal with that possibility.\n * @{\n */\n\n/**\n * @ingroup tasks\n * @brief Begin a task instance.\n * @param[in] domain The domain for this task\n * @param[in] taskid The instance ID for this task instance, or __itt_null\n * @param[in] parentid The parent instance to which this task instance belongs,\n * or __itt_null\n * @param[in] name The name of this task\n */\nvoid ITTAPI __itt_task_begin(const __itt_domain *domain, __itt_id taskid,\n                             __itt_id parentid, __itt_string_handle *name);\n\n/**\n * @ingroup tasks\n * @brief Begin a task instance.\n * @param[in] domain The domain for this task\n * @param[in] taskid The identifier for this task instance (may be 0)\n * @param[in] parentid The parent of this task (may be 0)\n * @param[in] fn The pointer to the function you are tracing\n */\nvoid ITTAPI __itt_task_begin_fn(const __itt_domain *domain, __itt_id taskid,\n                                __itt_id parentid, void *fn);\n\n/**\n * @ingroup tasks\n * @brief End the current task instance.\n * @param[in] domain The domain for this task\n */\nvoid ITTAPI __itt_task_end(const __itt_domain *domain);\n\n/**\n * @ingroup tasks\n * @brief Begin an overlapped task instance.\n * @param[in] domain The domain for this task.\n * @param[in] taskid The identifier for this task instance, *cannot* be\n * __itt_null.\n * @param[in] parentid The parent of this task, or __itt_null.\n * @param[in] name The name of this task.\n */\nvoid ITTAPI __itt_task_begin_overlapped(const __itt_domain *domain,\n                                        __itt_id taskid, __itt_id parentid,\n                                        __itt_string_handle *name);\n\n/**\n * @ingroup tasks\n * @brief End an overlapped task instance.\n * @param[in] domain The domain for this task\n * @param[in] taskid Explicit ID of finished task\n */\nvoid ITTAPI __itt_task_end_overlapped(const __itt_domain *domain,\n                                      __itt_id taskid);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, task_begin,\n          (const __itt_domain *domain, __itt_id id, __itt_id parentid,\n           __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, task_begin_fn,\n          (const __itt_domain *domain, __itt_id id, __itt_id parentid,\n           void *fn))\nITT_STUBV(ITTAPI, void, task_end, (const __itt_domain *domain))\nITT_STUBV(ITTAPI, void, task_begin_overlapped,\n          (const __itt_domain *domain, __itt_id taskid, __itt_id parentid,\n           __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, task_end_overlapped,\n          (const __itt_domain *domain, __itt_id taskid))\n#define __itt_task_begin(d, x, y, z) ITTNOTIFY_VOID_D3(task_begin, d, x, y, z)\n#define __itt_task_begin_ptr ITTNOTIFY_NAME(task_begin)\n#define __itt_task_begin_fn(d, x, y, z)                                        \\\n  ITTNOTIFY_VOID_D3(task_begin_fn, d, x, y, z)\n#define __itt_task_begin_fn_ptr ITTNOTIFY_NAME(task_begin_fn)\n#define __itt_task_end(d) ITTNOTIFY_VOID_D0(task_end, d)\n#define __itt_task_end_ptr ITTNOTIFY_NAME(task_end)\n#define __itt_task_begin_overlapped(d, x, y, z)                                \\\n  ITTNOTIFY_VOID_D3(task_begin_overlapped, d, x, y, z)\n#define __itt_task_begin_overlapped_ptr ITTNOTIFY_NAME(task_begin_overlapped)\n#define __itt_task_end_overlapped(d, x)                                        \\\n  ITTNOTIFY_VOID_D1(task_end_overlapped, d, x)\n#define __itt_task_end_overlapped_ptr ITTNOTIFY_NAME(task_end_overlapped)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_task_begin(domain, id, parentid, name)\n#define __itt_task_begin_ptr 0\n#define __itt_task_begin_fn(domain, id, parentid, fn)\n#define __itt_task_begin_fn_ptr 0\n#define __itt_task_end(domain)\n#define __itt_task_end_ptr 0\n#define __itt_task_begin_overlapped(domain, taskid, parentid, name)\n#define __itt_task_begin_overlapped_ptr 0\n#define __itt_task_end_overlapped(domain, taskid)\n#define __itt_task_end_overlapped_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_task_begin_ptr 0\n#define __itt_task_begin_fn_ptr 0\n#define __itt_task_end_ptr 0\n#define __itt_task_begin_overlapped_ptr 0\n#define __itt_task_end_overlapped_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} tasks group */\n\n/**\n * @defgroup markers Markers\n * Markers represent a single discreet event in time. Markers have a scope,\n * described by an enumerated type __itt_scope. Markers are created by\n * the API call __itt_marker. A marker instance can be given an ID for use in\n * adding metadata.\n * @{\n */\n\n/**\n * @brief Describes the scope of an event object in the trace.\n */\ntypedef enum {\n  __itt_scope_unknown = 0,\n  __itt_scope_global,\n  __itt_scope_track_group,\n  __itt_scope_track,\n  __itt_scope_task,\n  __itt_scope_marker\n} __itt_scope;\n\n/** @cond exclude_from_documentation */\n#define __itt_marker_scope_unknown __itt_scope_unknown\n#define __itt_marker_scope_global __itt_scope_global\n#define __itt_marker_scope_process __itt_scope_track_group\n#define __itt_marker_scope_thread __itt_scope_track\n#define __itt_marker_scope_task __itt_scope_task\n/** @endcond */\n\n/**\n * @ingroup markers\n * @brief Create a marker instance\n * @param[in] domain The domain for this marker\n * @param[in] id The instance ID for this marker or __itt_null\n * @param[in] name The name for this marker\n * @param[in] scope The scope for this marker\n */\nvoid ITTAPI __itt_marker(const __itt_domain *domain, __itt_id id,\n                         __itt_string_handle *name, __itt_scope scope);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, marker,\n          (const __itt_domain *domain, __itt_id id, __itt_string_handle *name,\n           __itt_scope scope))\n#define __itt_marker(d, x, y, z) ITTNOTIFY_VOID_D3(marker, d, x, y, z)\n#define __itt_marker_ptr ITTNOTIFY_NAME(marker)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_marker(domain, id, name, scope)\n#define __itt_marker_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_marker_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} markers group */\n\n/**\n * @defgroup metadata Metadata\n * The metadata API is used to attach extra information to named\n * entities. Metadata can be attached to an identified named entity by ID,\n * or to the current entity (which is always a task).\n *\n * Conceptually metadata has a type (what kind of metadata), a key (the\n * name of the metadata), and a value (the actual data). The encoding of\n * the value depends on the type of the metadata.\n *\n * The type of metadata is specified by an enumerated type __itt_metadata_type.\n * @{\n */\n\n/**\n * @ingroup parameters\n * @brief describes the type of metadata\n */\ntypedef enum {\n  __itt_metadata_unknown = 0,\n  __itt_metadata_u64, /**< Unsigned 64-bit integer */\n  __itt_metadata_s64, /**< Signed 64-bit integer */\n  __itt_metadata_u32, /**< Unsigned 32-bit integer */\n  __itt_metadata_s32, /**< Signed 32-bit integer */\n  __itt_metadata_u16, /**< Unsigned 16-bit integer */\n  __itt_metadata_s16, /**< Signed 16-bit integer */\n  __itt_metadata_float, /**< Signed 32-bit floating-point */\n  __itt_metadata_double /**< SIgned 64-bit floating-point */\n} __itt_metadata_type;\n\n/**\n * @ingroup parameters\n * @brief Add metadata to an instance of a named entity.\n * @param[in] domain The domain controlling the call\n * @param[in] id The identifier of the instance to which the metadata is to be\n * added, or __itt_null to add to the current task\n * @param[in] key The name of the metadata\n * @param[in] type The type of the metadata\n * @param[in] count The number of elements of the given type. If count == 0, no\n * metadata will be added.\n * @param[in] data The metadata itself\n */\nvoid ITTAPI __itt_metadata_add(const __itt_domain *domain, __itt_id id,\n                               __itt_string_handle *key,\n                               __itt_metadata_type type, size_t count,\n                               void *data);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, metadata_add,\n          (const __itt_domain *domain, __itt_id id, __itt_string_handle *key,\n           __itt_metadata_type type, size_t count, void *data))\n#define __itt_metadata_add(d, x, y, z, a, b)                                   \\\n  ITTNOTIFY_VOID_D5(metadata_add, d, x, y, z, a, b)\n#define __itt_metadata_add_ptr ITTNOTIFY_NAME(metadata_add)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_metadata_add(d, x, y, z, a, b)\n#define __itt_metadata_add_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_metadata_add_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup parameters\n * @brief Add string metadata to an instance of a named entity.\n * @param[in] domain The domain controlling the call\n * @param[in] id The identifier of the instance to which the metadata is to be\n * added, or __itt_null to add to the current task\n * @param[in] key The name of the metadata\n * @param[in] data The metadata itself\n * @param[in] length The number of characters in the string, or -1 if the length\n * is unknown but the string is null-terminated\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_metadata_str_addA(const __itt_domain *domain, __itt_id id,\n                                    __itt_string_handle *key, const char *data,\n                                    size_t length);\nvoid ITTAPI __itt_metadata_str_addW(const __itt_domain *domain, __itt_id id,\n                                    __itt_string_handle *key,\n                                    const wchar_t *data, size_t length);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_metadata_str_add __itt_metadata_str_addW\n#define __itt_metadata_str_add_ptr __itt_metadata_str_addW_ptr\n#else /* UNICODE */\n#define __itt_metadata_str_add __itt_metadata_str_addA\n#define __itt_metadata_str_add_ptr __itt_metadata_str_addA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nvoid ITTAPI __itt_metadata_str_add(const __itt_domain *domain, __itt_id id,\n                                   __itt_string_handle *key, const char *data,\n                                   size_t length);\n#endif\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, metadata_str_addA,\n          (const __itt_domain *domain, __itt_id id, __itt_string_handle *key,\n           const char *data, size_t length))\nITT_STUBV(ITTAPI, void, metadata_str_addW,\n          (const __itt_domain *domain, __itt_id id, __itt_string_handle *key,\n           const wchar_t *data, size_t length))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUBV(ITTAPI, void, metadata_str_add,\n          (const __itt_domain *domain, __itt_id id, __itt_string_handle *key,\n           const char *data, size_t length))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_metadata_str_addA(d, x, y, z, a)                                 \\\n  ITTNOTIFY_VOID_D4(metadata_str_addA, d, x, y, z, a)\n#define __itt_metadata_str_addA_ptr ITTNOTIFY_NAME(metadata_str_addA)\n#define __itt_metadata_str_addW(d, x, y, z, a)                                 \\\n  ITTNOTIFY_VOID_D4(metadata_str_addW, d, x, y, z, a)\n#define __itt_metadata_str_addW_ptr ITTNOTIFY_NAME(metadata_str_addW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_metadata_str_add(d, x, y, z, a)                                  \\\n  ITTNOTIFY_VOID_D4(metadata_str_add, d, x, y, z, a)\n#define __itt_metadata_str_add_ptr ITTNOTIFY_NAME(metadata_str_add)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_metadata_str_addA(d, x, y, z, a)\n#define __itt_metadata_str_addA_ptr 0\n#define __itt_metadata_str_addW(d, x, y, z, a)\n#define __itt_metadata_str_addW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_metadata_str_add(d, x, y, z, a)\n#define __itt_metadata_str_add_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_metadata_str_addA_ptr 0\n#define __itt_metadata_str_addW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_metadata_str_add_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup parameters\n * @brief Add metadata to an instance of a named entity.\n * @param[in] domain The domain controlling the call\n * @param[in] scope The scope of the instance to which the metadata is to be\n added\n\n * @param[in] id The identifier of the instance to which the metadata is to be\n added, or __itt_null to add to the current task\n\n * @param[in] key The name of the metadata\n * @param[in] type The type of the metadata\n * @param[in] count The number of elements of the given type. If count == 0, no\n metadata will be added.\n * @param[in] data The metadata itself\n*/\nvoid ITTAPI __itt_metadata_add_with_scope(const __itt_domain *domain,\n                                          __itt_scope scope,\n                                          __itt_string_handle *key,\n                                          __itt_metadata_type type,\n                                          size_t count, void *data);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, metadata_add_with_scope,\n          (const __itt_domain *domain, __itt_scope scope,\n           __itt_string_handle *key, __itt_metadata_type type, size_t count,\n           void *data))\n#define __itt_metadata_add_with_scope(d, x, y, z, a, b)                        \\\n  ITTNOTIFY_VOID_D5(metadata_add_with_scope, d, x, y, z, a, b)\n#define __itt_metadata_add_with_scope_ptr                                      \\\n  ITTNOTIFY_NAME(metadata_add_with_scope)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_metadata_add_with_scope(d, x, y, z, a, b)\n#define __itt_metadata_add_with_scope_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_metadata_add_with_scope_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup parameters\n * @brief Add string metadata to an instance of a named entity.\n * @param[in] domain The domain controlling the call\n * @param[in] scope The scope of the instance to which the metadata is to be\n added\n\n * @param[in] id The identifier of the instance to which the metadata is to be\n added, or __itt_null to add to the current task\n\n * @param[in] key The name of the metadata\n * @param[in] data The metadata itself\n * @param[in] length The number of characters in the string, or -1 if the length\n is unknown but the string is null-terminated\n*/\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_metadata_str_add_with_scopeA(const __itt_domain *domain,\n                                               __itt_scope scope,\n                                               __itt_string_handle *key,\n                                               const char *data, size_t length);\nvoid ITTAPI __itt_metadata_str_add_with_scopeW(const __itt_domain *domain,\n                                               __itt_scope scope,\n                                               __itt_string_handle *key,\n                                               const wchar_t *data,\n                                               size_t length);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_metadata_str_add_with_scope __itt_metadata_str_add_with_scopeW\n#define __itt_metadata_str_add_with_scope_ptr                                  \\\n  __itt_metadata_str_add_with_scopeW_ptr\n#else /* UNICODE */\n#define __itt_metadata_str_add_with_scope __itt_metadata_str_add_with_scopeA\n#define __itt_metadata_str_add_with_scope_ptr                                  \\\n  __itt_metadata_str_add_with_scopeA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nvoid ITTAPI __itt_metadata_str_add_with_scope(const __itt_domain *domain,\n                                              __itt_scope scope,\n                                              __itt_string_handle *key,\n                                              const char *data, size_t length);\n#endif\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUBV(ITTAPI, void, metadata_str_add_with_scopeA,\n          (const __itt_domain *domain, __itt_scope scope,\n           __itt_string_handle *key, const char *data, size_t length))\nITT_STUBV(ITTAPI, void, metadata_str_add_with_scopeW,\n          (const __itt_domain *domain, __itt_scope scope,\n           __itt_string_handle *key, const wchar_t *data, size_t length))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUBV(ITTAPI, void, metadata_str_add_with_scope,\n          (const __itt_domain *domain, __itt_scope scope,\n           __itt_string_handle *key, const char *data, size_t length))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_metadata_str_add_with_scopeA(d, x, y, z, a)                      \\\n  ITTNOTIFY_VOID_D4(metadata_str_add_with_scopeA, d, x, y, z, a)\n#define __itt_metadata_str_add_with_scopeA_ptr                                 \\\n  ITTNOTIFY_NAME(metadata_str_add_with_scopeA)\n#define __itt_metadata_str_add_with_scopeW(d, x, y, z, a)                      \\\n  ITTNOTIFY_VOID_D4(metadata_str_add_with_scopeW, d, x, y, z, a)\n#define __itt_metadata_str_add_with_scopeW_ptr                                 \\\n  ITTNOTIFY_NAME(metadata_str_add_with_scopeW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_metadata_str_add_with_scope(d, x, y, z, a)                       \\\n  ITTNOTIFY_VOID_D4(metadata_str_add_with_scope, d, x, y, z, a)\n#define __itt_metadata_str_add_with_scope_ptr                                  \\\n  ITTNOTIFY_NAME(metadata_str_add_with_scope)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_metadata_str_add_with_scopeA(d, x, y, z, a)\n#define __itt_metadata_str_add_with_scopeA_ptr 0\n#define __itt_metadata_str_add_with_scopeW(d, x, y, z, a)\n#define __itt_metadata_str_add_with_scopeW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_metadata_str_add_with_scope(d, x, y, z, a)\n#define __itt_metadata_str_add_with_scope_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_metadata_str_add_with_scopeA_ptr 0\n#define __itt_metadata_str_add_with_scopeW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_metadata_str_add_with_scope_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @} metadata group */\n\n/**\n * @defgroup relations Relations\n * Instances of named entities can be explicitly associated with other\n * instances using instance IDs and the relationship API calls.\n *\n * @{\n */\n\n/**\n * @ingroup relations\n * @brief The kind of relation between two instances is specified by the\n * enumerated type __itt_relation. Relations between instances can be added with\n * an API call. The relation API uses instance IDs. Relations can be added\n * before or after the actual instances are created and persist independently of\n * the instances. This is the motivation for having different lifetimes for\n * instance IDs and the actual instances.\n */\ntypedef enum {\n  __itt_relation_is_unknown = 0,\n  __itt_relation_is_dependent_on, /**< \"A is dependent on B\" means that A cannot\n                                     start until B completes */\n  __itt_relation_is_sibling_of, /**< \"A is sibling of B\" means that A and B were\n                                   created as a group */\n  __itt_relation_is_parent_of, /**< \"A is parent of B\" means that A created B */\n  __itt_relation_is_continuation_of, /**< \"A is continuation of B\" means that A\n                                        assumes the dependencies of B */\n  __itt_relation_is_child_of, /**< \"A is child of B\" means that A was created by\n                                 B (inverse of is_parent_of) */\n  __itt_relation_is_continued_by, /**< \"A is continued by B\" means that B\n                                     assumes the dependencies of A (inverse of\n                                     is_continuation_of) */\n  __itt_relation_is_predecessor_to /**< \"A is predecessor to B\" means that B\n                                      cannot start until A completes (inverse of\n                                      is_dependent_on) */\n} __itt_relation;\n\n/**\n * @ingroup relations\n * @brief Add a relation to the current task instance.\n * The current task instance is the head of the relation.\n * @param[in] domain The domain controlling this call\n * @param[in] relation The kind of relation\n * @param[in] tail The ID for the tail of the relation\n */\nvoid ITTAPI __itt_relation_add_to_current(const __itt_domain *domain,\n                                          __itt_relation relation,\n                                          __itt_id tail);\n\n/**\n * @ingroup relations\n * @brief Add a relation between two instance identifiers.\n * @param[in] domain The domain controlling this call\n * @param[in] head The ID for the head of the relation\n * @param[in] relation The kind of relation\n * @param[in] tail The ID for the tail of the relation\n */\nvoid ITTAPI __itt_relation_add(const __itt_domain *domain, __itt_id head,\n                               __itt_relation relation, __itt_id tail);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, relation_add_to_current,\n          (const __itt_domain *domain, __itt_relation relation, __itt_id tail))\nITT_STUBV(ITTAPI, void, relation_add,\n          (const __itt_domain *domain, __itt_id head, __itt_relation relation,\n           __itt_id tail))\n#define __itt_relation_add_to_current(d, x, y)                                 \\\n  ITTNOTIFY_VOID_D2(relation_add_to_current, d, x, y)\n#define __itt_relation_add_to_current_ptr                                      \\\n  ITTNOTIFY_NAME(relation_add_to_current)\n#define __itt_relation_add(d, x, y, z)                                         \\\n  ITTNOTIFY_VOID_D3(relation_add, d, x, y, z)\n#define __itt_relation_add_ptr ITTNOTIFY_NAME(relation_add)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_relation_add_to_current(d, x, y)\n#define __itt_relation_add_to_current_ptr 0\n#define __itt_relation_add(d, x, y, z)\n#define __itt_relation_add_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_relation_add_to_current_ptr 0\n#define __itt_relation_add_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} relations group */\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_clock_info {\n  unsigned long long clock_freq; /*!< Clock domain frequency */\n  unsigned long long clock_base; /*!< Clock domain base timestamp */\n} __itt_clock_info;\n\n#pragma pack(pop)\n/** @endcond */\n\n/** @cond exclude_from_documentation */\ntypedef void(ITTAPI *__itt_get_clock_info_fn)(__itt_clock_info *clock_info,\n                                              void *data);\n/** @endcond */\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_clock_domain {\n  __itt_clock_info info; /*!< Most recent clock domain info */\n  __itt_get_clock_info_fn fn; /*!< Callback function pointer */\n  void *fn_data; /*!< Input argument for the callback function */\n  int extra1; /*!< Reserved. Must be zero */\n  void *extra2; /*!< Reserved. Must be zero */\n  struct ___itt_clock_domain *next;\n} __itt_clock_domain;\n\n#pragma pack(pop)\n/** @endcond */\n\n/**\n * @ingroup clockdomains\n * @brief Create a clock domain.\n * Certain applications require the capability to trace their application using\n * a clock domain different than the CPU, for instance the instrumentation of\n * events that occur on a GPU. Because the set of domains is expected to be\n * static over the application's execution time, there is no mechanism to\n * destroy a domain. Any domain can be accessed by any thread in the process,\n * regardless of which thread created the domain. This call is thread-safe.\n * @param[in] fn A pointer to a callback function which retrieves alternative\n * CPU timestamps\n * @param[in] fn_data Argument for a callback function; may be NULL\n */\n__itt_clock_domain *ITTAPI __itt_clock_domain_create(__itt_get_clock_info_fn fn,\n                                                     void *fn_data);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, __itt_clock_domain *, clock_domain_create,\n         (__itt_get_clock_info_fn fn, void *fn_data))\n#define __itt_clock_domain_create ITTNOTIFY_DATA(clock_domain_create)\n#define __itt_clock_domain_create_ptr ITTNOTIFY_NAME(clock_domain_create)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_clock_domain_create(fn, fn_data) (__itt_clock_domain *)0\n#define __itt_clock_domain_create_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_clock_domain_create_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup clockdomains\n * @brief Recalculate clock domains frequencies and clock base timestamps.\n */\nvoid ITTAPI __itt_clock_domain_reset(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, clock_domain_reset, (void))\n#define __itt_clock_domain_reset ITTNOTIFY_VOID(clock_domain_reset)\n#define __itt_clock_domain_reset_ptr ITTNOTIFY_NAME(clock_domain_reset)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_clock_domain_reset()\n#define __itt_clock_domain_reset_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_clock_domain_reset_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup clockdomain\n * @brief Create an instance of identifier. This establishes the beginning of\n * the lifetime of an instance of the given ID in the trace. Once this lifetime\n * starts, the ID can be used to tag named entity instances in calls such as\n * __itt_task_begin, and to specify relationships among identified named entity\n * instances, using the \\ref relations APIs.\n * @param[in] domain The domain controlling the execution of this call.\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] id The ID to create.\n */\nvoid ITTAPI __itt_id_create_ex(const __itt_domain *domain,\n                               __itt_clock_domain *clock_domain,\n                               unsigned long long timestamp, __itt_id id);\n\n/**\n * @ingroup clockdomain\n * @brief Destroy an instance of identifier. This ends the lifetime of the\n * current instance of the given ID value in the trace. Any relationships that\n * are established after this lifetime ends are invalid. This call must be\n * performed before the given ID value can be reused for a different named\n * entity instance.\n * @param[in] domain The domain controlling the execution of this call.\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] id The ID to destroy.\n */\nvoid ITTAPI __itt_id_destroy_ex(const __itt_domain *domain,\n                                __itt_clock_domain *clock_domain,\n                                unsigned long long timestamp, __itt_id id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, id_create_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id id))\nITT_STUBV(ITTAPI, void, id_destroy_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id id))\n#define __itt_id_create_ex(d, x, y, z)                                         \\\n  ITTNOTIFY_VOID_D3(id_create_ex, d, x, y, z)\n#define __itt_id_create_ex_ptr ITTNOTIFY_NAME(id_create_ex)\n#define __itt_id_destroy_ex(d, x, y, z)                                        \\\n  ITTNOTIFY_VOID_D3(id_destroy_ex, d, x, y, z)\n#define __itt_id_destroy_ex_ptr ITTNOTIFY_NAME(id_destroy_ex)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_id_create_ex(domain, clock_domain, timestamp, id)\n#define __itt_id_create_ex_ptr 0\n#define __itt_id_destroy_ex(domain, clock_domain, timestamp, id)\n#define __itt_id_destroy_ex_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_id_create_ex_ptr 0\n#define __itt_id_destroy_ex_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup clockdomain\n * @brief Begin a task instance.\n * @param[in] domain The domain for this task\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] taskid The instance ID for this task instance, or __itt_null\n * @param[in] parentid The parent instance to which this task instance belongs,\n * or __itt_null\n * @param[in] name The name of this task\n */\nvoid ITTAPI __itt_task_begin_ex(const __itt_domain *domain,\n                                __itt_clock_domain *clock_domain,\n                                unsigned long long timestamp, __itt_id taskid,\n                                __itt_id parentid, __itt_string_handle *name);\n\n/**\n * @ingroup clockdomain\n * @brief Begin a task instance.\n * @param[in] domain The domain for this task\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] taskid The identifier for this task instance, or __itt_null\n * @param[in] parentid The parent of this task, or __itt_null\n * @param[in] fn The pointer to the function you are tracing\n */\nvoid ITTAPI __itt_task_begin_fn_ex(const __itt_domain *domain,\n                                   __itt_clock_domain *clock_domain,\n                                   unsigned long long timestamp,\n                                   __itt_id taskid, __itt_id parentid,\n                                   void *fn);\n\n/**\n * @ingroup clockdomain\n * @brief End the current task instance.\n * @param[in] domain The domain for this task\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n */\nvoid ITTAPI __itt_task_end_ex(const __itt_domain *domain,\n                              __itt_clock_domain *clock_domain,\n                              unsigned long long timestamp);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, task_begin_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id id, __itt_id parentid,\n           __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, task_begin_fn_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id id, __itt_id parentid,\n           void *fn))\nITT_STUBV(ITTAPI, void, task_end_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp))\n#define __itt_task_begin_ex(d, x, y, z, a, b)                                  \\\n  ITTNOTIFY_VOID_D5(task_begin_ex, d, x, y, z, a, b)\n#define __itt_task_begin_ex_ptr ITTNOTIFY_NAME(task_begin_ex)\n#define __itt_task_begin_fn_ex(d, x, y, z, a, b)                               \\\n  ITTNOTIFY_VOID_D5(task_begin_fn_ex, d, x, y, z, a, b)\n#define __itt_task_begin_fn_ex_ptr ITTNOTIFY_NAME(task_begin_fn_ex)\n#define __itt_task_end_ex(d, x, y) ITTNOTIFY_VOID_D2(task_end_ex, d, x, y)\n#define __itt_task_end_ex_ptr ITTNOTIFY_NAME(task_end_ex)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_task_begin_ex(domain, clock_domain, timestamp, id, parentid, name)\n#define __itt_task_begin_ex_ptr 0\n#define __itt_task_begin_fn_ex(domain, clock_domain, timestamp, id, parentid,  \\\n                               fn)\n#define __itt_task_begin_fn_ex_ptr 0\n#define __itt_task_end_ex(domain, clock_domain, timestamp)\n#define __itt_task_end_ex_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_task_begin_ex_ptr 0\n#define __itt_task_begin_fn_ex_ptr 0\n#define __itt_task_end_ex_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @defgroup counters Counters\n * @ingroup public\n * Counters are user-defined objects with a monotonically increasing\n * value. Counter values are 64-bit unsigned integers.\n * Counters have names that can be displayed in\n * the tools.\n * @{\n */\n\n/**\n * @brief opaque structure for counter identification\n */\n/** @cond exclude_from_documentation */\n\ntypedef struct ___itt_counter *__itt_counter;\n\n/**\n * @brief Create an unsigned 64 bits integer counter with given name/domain\n *\n * After __itt_counter_create() is called, __itt_counter_inc(id),\n * __itt_counter_inc_delta(id, delta),\n * __itt_counter_set_value(id, value_ptr) or __itt_counter_set_value_ex(id,\n * clock_domain, timestamp, value_ptr) can be used to change the value of the\n * counter, where value_ptr is a pointer to an unsigned 64 bits integer\n *\n * The call is equal to __itt_counter_create_typed(name, domain,\n * __itt_metadata_u64)\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_counter ITTAPI __itt_counter_createA(const char *name,\n                                           const char *domain);\n__itt_counter ITTAPI __itt_counter_createW(const wchar_t *name,\n                                           const wchar_t *domain);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_counter_create __itt_counter_createW\n#define __itt_counter_create_ptr __itt_counter_createW_ptr\n#else /* UNICODE */\n#define __itt_counter_create __itt_counter_createA\n#define __itt_counter_create_ptr __itt_counter_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_counter ITTAPI __itt_counter_create(const char *name, const char *domain);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, __itt_counter, counter_createA,\n         (const char *name, const char *domain))\nITT_STUB(ITTAPI, __itt_counter, counter_createW,\n         (const wchar_t *name, const wchar_t *domain))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, __itt_counter, counter_create,\n         (const char *name, const char *domain))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_counter_createA ITTNOTIFY_DATA(counter_createA)\n#define __itt_counter_createA_ptr ITTNOTIFY_NAME(counter_createA)\n#define __itt_counter_createW ITTNOTIFY_DATA(counter_createW)\n#define __itt_counter_createW_ptr ITTNOTIFY_NAME(counter_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_counter_create ITTNOTIFY_DATA(counter_create)\n#define __itt_counter_create_ptr ITTNOTIFY_NAME(counter_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_counter_createA(name, domain)\n#define __itt_counter_createA_ptr 0\n#define __itt_counter_createW(name, domain)\n#define __itt_counter_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_counter_create(name, domain)\n#define __itt_counter_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_counter_createA_ptr 0\n#define __itt_counter_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_counter_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Increment the unsigned 64 bits integer counter value\n *\n * Calling this function to non-unsigned 64 bits integer counters has no effect\n */\nvoid ITTAPI __itt_counter_inc(__itt_counter id);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_inc, (__itt_counter id))\n#define __itt_counter_inc ITTNOTIFY_VOID(counter_inc)\n#define __itt_counter_inc_ptr ITTNOTIFY_NAME(counter_inc)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_inc(id)\n#define __itt_counter_inc_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_inc_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/**\n * @brief Increment the unsigned 64 bits integer counter value with x\n *\n * Calling this function to non-unsigned 64 bits integer counters has no effect\n */\nvoid ITTAPI __itt_counter_inc_delta(__itt_counter id, unsigned long long value);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_inc_delta,\n          (__itt_counter id, unsigned long long value))\n#define __itt_counter_inc_delta ITTNOTIFY_VOID(counter_inc_delta)\n#define __itt_counter_inc_delta_ptr ITTNOTIFY_NAME(counter_inc_delta)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_inc_delta(id, value)\n#define __itt_counter_inc_delta_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_inc_delta_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Decrement the unsigned 64 bits integer counter value\n *\n * Calling this function to non-unsigned 64 bits integer counters has no effect\n */\nvoid ITTAPI __itt_counter_dec(__itt_counter id);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_dec, (__itt_counter id))\n#define __itt_counter_dec ITTNOTIFY_VOID(counter_dec)\n#define __itt_counter_dec_ptr ITTNOTIFY_NAME(counter_dec)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_dec(id)\n#define __itt_counter_dec_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_dec_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/**\n * @brief Decrement the unsigned 64 bits integer counter value with x\n *\n * Calling this function to non-unsigned 64 bits integer counters has no effect\n */\nvoid ITTAPI __itt_counter_dec_delta(__itt_counter id, unsigned long long value);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_dec_delta,\n          (__itt_counter id, unsigned long long value))\n#define __itt_counter_dec_delta ITTNOTIFY_VOID(counter_dec_delta)\n#define __itt_counter_dec_delta_ptr ITTNOTIFY_NAME(counter_dec_delta)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_dec_delta(id, value)\n#define __itt_counter_dec_delta_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_dec_delta_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup counters\n * @brief Increment a counter by one.\n * The first call with a given name creates a counter by that name and sets its\n * value to zero. Successive calls increment the counter value.\n * @param[in] domain The domain controlling the call. Counter names are not\n * domain specific. The domain argument is used only to enable or disable the\n * API calls.\n * @param[in] name The name of the counter\n */\nvoid ITTAPI __itt_counter_inc_v3(const __itt_domain *domain,\n                                 __itt_string_handle *name);\n\n/**\n * @ingroup counters\n * @brief Increment a counter by the value specified in delta.\n * @param[in] domain The domain controlling the call. Counter names are not\n * domain specific. The domain argument is used only to enable or disable the\n * API calls.\n * @param[in] name The name of the counter\n * @param[in] delta The amount by which to increment the counter\n */\nvoid ITTAPI __itt_counter_inc_delta_v3(const __itt_domain *domain,\n                                       __itt_string_handle *name,\n                                       unsigned long long delta);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_inc_v3,\n          (const __itt_domain *domain, __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, counter_inc_delta_v3,\n          (const __itt_domain *domain, __itt_string_handle *name,\n           unsigned long long delta))\n#define __itt_counter_inc_v3(d, x) ITTNOTIFY_VOID_D1(counter_inc_v3, d, x)\n#define __itt_counter_inc_v3_ptr ITTNOTIFY_NAME(counter_inc_v3)\n#define __itt_counter_inc_delta_v3(d, x, y)                                    \\\n  ITTNOTIFY_VOID_D2(counter_inc_delta_v3, d, x, y)\n#define __itt_counter_inc_delta_v3_ptr ITTNOTIFY_NAME(counter_inc_delta_v3)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_inc_v3(domain, name)\n#define __itt_counter_inc_v3_ptr 0\n#define __itt_counter_inc_delta_v3(domain, name, delta)\n#define __itt_counter_inc_delta_v3_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_inc_v3_ptr 0\n#define __itt_counter_inc_delta_v3_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup counters\n * @brief Decrement a counter by one.\n * The first call with a given name creates a counter by that name and sets its\n * value to zero. Successive calls decrement the counter value.\n * @param[in] domain The domain controlling the call. Counter names are not\n * domain specific. The domain argument is used only to enable or disable the\n * API calls.\n * @param[in] name The name of the counter\n */\nvoid ITTAPI __itt_counter_dec_v3(const __itt_domain *domain,\n                                 __itt_string_handle *name);\n\n/**\n * @ingroup counters\n * @brief Decrement a counter by the value specified in delta.\n * @param[in] domain The domain controlling the call. Counter names are not\n * domain specific. The domain argument is used only to enable or disable the\n * API calls.\n * @param[in] name The name of the counter\n * @param[in] delta The amount by which to decrement the counter\n */\nvoid ITTAPI __itt_counter_dec_delta_v3(const __itt_domain *domain,\n                                       __itt_string_handle *name,\n                                       unsigned long long delta);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_dec_v3,\n          (const __itt_domain *domain, __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, counter_dec_delta_v3,\n          (const __itt_domain *domain, __itt_string_handle *name,\n           unsigned long long delta))\n#define __itt_counter_dec_v3(d, x) ITTNOTIFY_VOID_D1(counter_dec_v3, d, x)\n#define __itt_counter_dec_v3_ptr ITTNOTIFY_NAME(counter_dec_v3)\n#define __itt_counter_dec_delta_v3(d, x, y)                                    \\\n  ITTNOTIFY_VOID_D2(counter_dec_delta_v3, d, x, y)\n#define __itt_counter_dec_delta_v3_ptr ITTNOTIFY_NAME(counter_dec_delta_v3)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_dec_v3(domain, name)\n#define __itt_counter_dec_v3_ptr 0\n#define __itt_counter_dec_delta_v3(domain, name, delta)\n#define __itt_counter_dec_delta_v3_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_dec_v3_ptr 0\n#define __itt_counter_dec_delta_v3_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @} counters group */\n\n/**\n * @brief Set the counter value\n */\nvoid ITTAPI __itt_counter_set_value(__itt_counter id, void *value_ptr);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_set_value, (__itt_counter id, void *value_ptr))\n#define __itt_counter_set_value ITTNOTIFY_VOID(counter_set_value)\n#define __itt_counter_set_value_ptr ITTNOTIFY_NAME(counter_set_value)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_set_value(id, value_ptr)\n#define __itt_counter_set_value_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_set_value_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Set the counter value\n */\nvoid ITTAPI __itt_counter_set_value_ex(__itt_counter id,\n                                       __itt_clock_domain *clock_domain,\n                                       unsigned long long timestamp,\n                                       void *value_ptr);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_set_value_ex,\n          (__itt_counter id, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, void *value_ptr))\n#define __itt_counter_set_value_ex ITTNOTIFY_VOID(counter_set_value_ex)\n#define __itt_counter_set_value_ex_ptr ITTNOTIFY_NAME(counter_set_value_ex)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_set_value_ex(id, clock_domain, timestamp, value_ptr)\n#define __itt_counter_set_value_ex_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_set_value_ex_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Create a typed counter with given name/domain\n *\n * After __itt_counter_create_typed() is called, __itt_counter_inc(id),\n * __itt_counter_inc_delta(id, delta),\n * __itt_counter_set_value(id, value_ptr) or __itt_counter_set_value_ex(id,\n * clock_domain, timestamp, value_ptr) can be used to change the value of the\n * counter\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_counter ITTAPI __itt_counter_create_typedA(const char *name,\n                                                 const char *domain,\n                                                 __itt_metadata_type type);\n__itt_counter ITTAPI __itt_counter_create_typedW(const wchar_t *name,\n                                                 const wchar_t *domain,\n                                                 __itt_metadata_type type);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_counter_create_typed __itt_counter_create_typedW\n#define __itt_counter_create_typed_ptr __itt_counter_create_typedW_ptr\n#else /* UNICODE */\n#define __itt_counter_create_typed __itt_counter_create_typedA\n#define __itt_counter_create_typed_ptr __itt_counter_create_typedA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_counter ITTAPI __itt_counter_create_typed(const char *name,\n                                                const char *domain,\n                                                __itt_metadata_type type);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, __itt_counter, counter_create_typedA,\n         (const char *name, const char *domain, __itt_metadata_type type))\nITT_STUB(ITTAPI, __itt_counter, counter_create_typedW,\n         (const wchar_t *name, const wchar_t *domain, __itt_metadata_type type))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, __itt_counter, counter_create_typed,\n         (const char *name, const char *domain, __itt_metadata_type type))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_counter_create_typedA ITTNOTIFY_DATA(counter_create_typedA)\n#define __itt_counter_create_typedA_ptr ITTNOTIFY_NAME(counter_create_typedA)\n#define __itt_counter_create_typedW ITTNOTIFY_DATA(counter_create_typedW)\n#define __itt_counter_create_typedW_ptr ITTNOTIFY_NAME(counter_create_typedW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_counter_create_typed ITTNOTIFY_DATA(counter_create_typed)\n#define __itt_counter_create_typed_ptr ITTNOTIFY_NAME(counter_create_typed)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_counter_create_typedA(name, domain, type)\n#define __itt_counter_create_typedA_ptr 0\n#define __itt_counter_create_typedW(name, domain, type)\n#define __itt_counter_create_typedW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_counter_create_typed(name, domain, type)\n#define __itt_counter_create_typed_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_counter_create_typedA_ptr 0\n#define __itt_counter_create_typedW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_counter_create_typed_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Destroy the counter identified by the pointer previously returned by\n * __itt_counter_create() or\n * __itt_counter_create_typed()\n */\nvoid ITTAPI __itt_counter_destroy(__itt_counter id);\n\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, counter_destroy, (__itt_counter id))\n#define __itt_counter_destroy ITTNOTIFY_VOID(counter_destroy)\n#define __itt_counter_destroy_ptr ITTNOTIFY_NAME(counter_destroy)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_counter_destroy(id)\n#define __itt_counter_destroy_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_counter_destroy_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} counters group */\n\n/**\n * @ingroup markers\n * @brief Create a marker instance.\n * @param[in] domain The domain for this marker\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] id The instance ID for this marker, or __itt_null\n * @param[in] name The name for this marker\n * @param[in] scope The scope for this marker\n */\nvoid ITTAPI __itt_marker_ex(const __itt_domain *domain,\n                            __itt_clock_domain *clock_domain,\n                            unsigned long long timestamp, __itt_id id,\n                            __itt_string_handle *name, __itt_scope scope);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, marker_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id id, __itt_string_handle *name,\n           __itt_scope scope))\n#define __itt_marker_ex(d, x, y, z, a, b)                                      \\\n  ITTNOTIFY_VOID_D5(marker_ex, d, x, y, z, a, b)\n#define __itt_marker_ex_ptr ITTNOTIFY_NAME(marker_ex)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_marker_ex(domain, clock_domain, timestamp, id, name, scope)\n#define __itt_marker_ex_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_marker_ex_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @ingroup clockdomain\n * @brief Add a relation to the current task instance.\n * The current task instance is the head of the relation.\n * @param[in] domain The domain controlling this call\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] relation The kind of relation\n * @param[in] tail The ID for the tail of the relation\n */\nvoid ITTAPI __itt_relation_add_to_current_ex(const __itt_domain *domain,\n                                             __itt_clock_domain *clock_domain,\n                                             unsigned long long timestamp,\n                                             __itt_relation relation,\n                                             __itt_id tail);\n\n/**\n * @ingroup clockdomain\n * @brief Add a relation between two instance identifiers.\n * @param[in] domain The domain controlling this call\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] head The ID for the head of the relation\n * @param[in] relation The kind of relation\n * @param[in] tail The ID for the tail of the relation\n */\nvoid ITTAPI __itt_relation_add_ex(const __itt_domain *domain,\n                                  __itt_clock_domain *clock_domain,\n                                  unsigned long long timestamp, __itt_id head,\n                                  __itt_relation relation, __itt_id tail);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, relation_add_to_current_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_relation relation,\n           __itt_id tail))\nITT_STUBV(ITTAPI, void, relation_add_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id head, __itt_relation relation,\n           __itt_id tail))\n#define __itt_relation_add_to_current_ex(d, x, y, z, a)                        \\\n  ITTNOTIFY_VOID_D4(relation_add_to_current_ex, d, x, y, z, a)\n#define __itt_relation_add_to_current_ex_ptr                                   \\\n  ITTNOTIFY_NAME(relation_add_to_current_ex)\n#define __itt_relation_add_ex(d, x, y, z, a, b)                                \\\n  ITTNOTIFY_VOID_D5(relation_add_ex, d, x, y, z, a, b)\n#define __itt_relation_add_ex_ptr ITTNOTIFY_NAME(relation_add_ex)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_relation_add_to_current_ex(domain, clock_domain, timestamp,      \\\n                                         relation, tail)\n#define __itt_relation_add_to_current_ex_ptr 0\n#define __itt_relation_add_ex(domain, clock_domain, timestamp, head, relation, \\\n                              tail)\n#define __itt_relation_add_ex_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_relation_add_to_current_ex_ptr 0\n#define __itt_relation_add_ex_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @cond exclude_from_documentation */\ntypedef enum ___itt_track_group_type {\n  __itt_track_group_type_normal = 0\n} __itt_track_group_type;\n/** @endcond */\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_track_group {\n  __itt_string_handle *name; /*!< Name of the track group */\n  struct ___itt_track *track; /*!< List of child tracks    */\n  __itt_track_group_type tgtype; /*!< Type of the track group */\n  int extra1; /*!< Reserved. Must be zero  */\n  void *extra2; /*!< Reserved. Must be zero  */\n  struct ___itt_track_group *next;\n} __itt_track_group;\n\n#pragma pack(pop)\n/** @endcond */\n\n/**\n * @brief Placeholder for custom track types. Currently, \"normal\" custom track\n * is the only available track type.\n */\ntypedef enum ___itt_track_type {\n  __itt_track_type_normal = 0\n#ifdef INTEL_ITTNOTIFY_API_PRIVATE\n  ,\n  __itt_track_type_queue\n#endif /* INTEL_ITTNOTIFY_API_PRIVATE */\n} __itt_track_type;\n\n/** @cond exclude_from_documentation */\n#pragma pack(push, 8)\n\ntypedef struct ___itt_track {\n  __itt_string_handle *name; /*!< Name of the track group */\n  __itt_track_group *group; /*!< Parent group to a track */\n  __itt_track_type ttype; /*!< Type of the track       */\n  int extra1; /*!< Reserved. Must be zero  */\n  void *extra2; /*!< Reserved. Must be zero  */\n  struct ___itt_track *next;\n} __itt_track;\n\n#pragma pack(pop)\n/** @endcond */\n\n/**\n * @brief Create logical track group.\n */\n__itt_track_group *ITTAPI __itt_track_group_create(\n    __itt_string_handle *name, __itt_track_group_type track_group_type);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, __itt_track_group *, track_group_create,\n         (__itt_string_handle * name, __itt_track_group_type track_group_type))\n#define __itt_track_group_create ITTNOTIFY_DATA(track_group_create)\n#define __itt_track_group_create_ptr ITTNOTIFY_NAME(track_group_create)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_track_group_create(name) (__itt_track_group *)0\n#define __itt_track_group_create_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_track_group_create_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Create logical track.\n */\n__itt_track *ITTAPI __itt_track_create(__itt_track_group *track_group,\n                                       __itt_string_handle *name,\n                                       __itt_track_type track_type);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, __itt_track *, track_create,\n         (__itt_track_group * track_group, __itt_string_handle *name,\n          __itt_track_type track_type))\n#define __itt_track_create ITTNOTIFY_DATA(track_create)\n#define __itt_track_create_ptr ITTNOTIFY_NAME(track_create)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_track_create(track_group, name, track_type) (__itt_track *)0\n#define __itt_track_create_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_track_create_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Set the logical track.\n */\nvoid ITTAPI __itt_set_track(__itt_track *track);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, set_track, (__itt_track * track))\n#define __itt_set_track ITTNOTIFY_VOID(set_track)\n#define __itt_set_track_ptr ITTNOTIFY_NAME(set_track)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_set_track(track)\n#define __itt_set_track_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_set_track_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/* ========================================================================== */\n/** @cond exclude_from_gpa_documentation */\n/**\n * @defgroup events Events\n * @ingroup public\n * Events group\n * @{\n */\n/** @brief user event type */\ntypedef int __itt_event;\n\n/**\n * @brief Create an event notification\n * @note name or namelen being null/name and namelen not matching, user event\n * feature not enabled\n * @return non-zero event identifier upon success and __itt_err otherwise\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_event LIBITTAPI __itt_event_createA(const char *name, int namelen);\n__itt_event LIBITTAPI __itt_event_createW(const wchar_t *name, int namelen);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_event_create __itt_event_createW\n#define __itt_event_create_ptr __itt_event_createW_ptr\n#else\n#define __itt_event_create __itt_event_createA\n#define __itt_event_create_ptr __itt_event_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_event LIBITTAPI __itt_event_create(const char *name, int namelen);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(LIBITTAPI, __itt_event, event_createA, (const char *name, int namelen))\nITT_STUB(LIBITTAPI, __itt_event, event_createW,\n         (const wchar_t *name, int namelen))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(LIBITTAPI, __itt_event, event_create, (const char *name, int namelen))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_event_createA ITTNOTIFY_DATA(event_createA)\n#define __itt_event_createA_ptr ITTNOTIFY_NAME(event_createA)\n#define __itt_event_createW ITTNOTIFY_DATA(event_createW)\n#define __itt_event_createW_ptr ITTNOTIFY_NAME(event_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_event_create ITTNOTIFY_DATA(event_create)\n#define __itt_event_create_ptr ITTNOTIFY_NAME(event_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_event_createA(name, namelen) (__itt_event)0\n#define __itt_event_createA_ptr 0\n#define __itt_event_createW(name, namelen) (__itt_event)0\n#define __itt_event_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_event_create(name, namelen) (__itt_event)0\n#define __itt_event_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_event_createA_ptr 0\n#define __itt_event_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_event_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record an event occurrence.\n * @return __itt_err upon failure (invalid event id/user event feature not\n * enabled)\n */\nint LIBITTAPI __itt_event_start(__itt_event event);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(LIBITTAPI, int, event_start, (__itt_event event))\n#define __itt_event_start ITTNOTIFY_DATA(event_start)\n#define __itt_event_start_ptr ITTNOTIFY_NAME(event_start)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_event_start(event) (int)0\n#define __itt_event_start_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_event_start_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Record an event end occurrence.\n * @note It is optional if events do not have durations.\n * @return __itt_err upon failure (invalid event id/user event feature not\n * enabled)\n */\nint LIBITTAPI __itt_event_end(__itt_event event);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(LIBITTAPI, int, event_end, (__itt_event event))\n#define __itt_event_end ITTNOTIFY_DATA(event_end)\n#define __itt_event_end_ptr ITTNOTIFY_NAME(event_end)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_event_end(event) (int)0\n#define __itt_event_end_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_event_end_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} events group */\n\n/**\n * @defgroup arrays Arrays Visualizer\n * @ingroup public\n * Visualize arrays\n * @{\n */\n\n/**\n * @enum __itt_av_data_type\n * @brief Defines types of arrays data (for C/C++ intrinsic types)\n */\ntypedef enum {\n  __itt_e_first = 0,\n  __itt_e_char = 0, /* 1-byte integer */\n  __itt_e_uchar, /* 1-byte unsigned integer */\n  __itt_e_int16, /* 2-byte integer */\n  __itt_e_uint16, /* 2-byte unsigned integer  */\n  __itt_e_int32, /* 4-byte integer */\n  __itt_e_uint32, /* 4-byte unsigned integer */\n  __itt_e_int64, /* 8-byte integer */\n  __itt_e_uint64, /* 8-byte unsigned integer */\n  __itt_e_float, /* 4-byte floating */\n  __itt_e_double, /* 8-byte floating */\n  __itt_e_last = __itt_e_double\n} __itt_av_data_type;\n\n/**\n * @brief Save an array data to a file.\n * Output format is defined by the file extension. The csv and bmp formats are\n * supported (bmp - for 2-dimensional array only).\n * @param[in] data - pointer to the array data\n * @param[in] rank - the rank of the array\n * @param[in] dimensions - pointer to an array of integers, which specifies the\n * array dimensions. The size of dimensions must be equal to the rank\n * @param[in] type - the type of the array, specified as one of the\n * __itt_av_data_type values (for intrinsic types)\n * @param[in] filePath - the file path; the output format is defined by the file\n * extension\n * @param[in] columnOrder - defines how the array is stored in the linear\n * memory. It should be 1 for column-major order (e.g. in FORTRAN) or 0 - for\n * row-major order (e.g. in C).\n */\n\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nint ITTAPI __itt_av_saveA(void *data, int rank, const int *dimensions, int type,\n                          const char *filePath, int columnOrder);\nint ITTAPI __itt_av_saveW(void *data, int rank, const int *dimensions, int type,\n                          const wchar_t *filePath, int columnOrder);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_av_save __itt_av_saveW\n#define __itt_av_save_ptr __itt_av_saveW_ptr\n#else /* UNICODE */\n#define __itt_av_save __itt_av_saveA\n#define __itt_av_save_ptr __itt_av_saveA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nint ITTAPI __itt_av_save(void *data, int rank, const int *dimensions, int type,\n                         const char *filePath, int columnOrder);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, int, av_saveA,\n         (void *data, int rank, const int *dimensions, int type,\n          const char *filePath, int columnOrder))\nITT_STUB(ITTAPI, int, av_saveW,\n         (void *data, int rank, const int *dimensions, int type,\n          const wchar_t *filePath, int columnOrder))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, int, av_save,\n         (void *data, int rank, const int *dimensions, int type,\n          const char *filePath, int columnOrder))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_av_saveA ITTNOTIFY_DATA(av_saveA)\n#define __itt_av_saveA_ptr ITTNOTIFY_NAME(av_saveA)\n#define __itt_av_saveW ITTNOTIFY_DATA(av_saveW)\n#define __itt_av_saveW_ptr ITTNOTIFY_NAME(av_saveW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_av_save ITTNOTIFY_DATA(av_save)\n#define __itt_av_save_ptr ITTNOTIFY_NAME(av_save)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_av_saveA(name)\n#define __itt_av_saveA_ptr 0\n#define __itt_av_saveW(name)\n#define __itt_av_saveW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_av_save(name)\n#define __itt_av_save_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_av_saveA_ptr 0\n#define __itt_av_saveW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_av_save_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\nvoid ITTAPI __itt_enable_attach(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, enable_attach, (void))\n#define __itt_enable_attach ITTNOTIFY_VOID(enable_attach)\n#define __itt_enable_attach_ptr ITTNOTIFY_NAME(enable_attach)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_enable_attach()\n#define __itt_enable_attach_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_enable_attach_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @cond exclude_from_gpa_documentation */\n\n/** @} arrays group */\n\n/** @endcond */\n\n/**\n * @brief Module load info\n * This API is used to report necessary information in case of module relocation\n * @param[in] start_addr - relocated module start address\n * @param[in] end_addr - relocated module end address\n * @param[in] path - file system path to the module\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nvoid ITTAPI __itt_module_loadA(void *start_addr, void *end_addr,\n                               const char *path);\nvoid ITTAPI __itt_module_loadW(void *start_addr, void *end_addr,\n                               const wchar_t *path);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_module_load __itt_module_loadW\n#define __itt_module_load_ptr __itt_module_loadW_ptr\n#else /* UNICODE */\n#define __itt_module_load __itt_module_loadA\n#define __itt_module_load_ptr __itt_module_loadA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nvoid ITTAPI __itt_module_load(void *start_addr, void *end_addr,\n                              const char *path);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, void, module_loadA,\n         (void *start_addr, void *end_addr, const char *path))\nITT_STUB(ITTAPI, void, module_loadW,\n         (void *start_addr, void *end_addr, const wchar_t *path))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, void, module_load,\n         (void *start_addr, void *end_addr, const char *path))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_module_loadA ITTNOTIFY_VOID(module_loadA)\n#define __itt_module_loadA_ptr ITTNOTIFY_NAME(module_loadA)\n#define __itt_module_loadW ITTNOTIFY_VOID(module_loadW)\n#define __itt_module_loadW_ptr ITTNOTIFY_NAME(module_loadW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_module_load ITTNOTIFY_VOID(module_load)\n#define __itt_module_load_ptr ITTNOTIFY_NAME(module_load)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_module_loadA(start_addr, end_addr, path)\n#define __itt_module_loadA_ptr 0\n#define __itt_module_loadW(start_addr, end_addr, path)\n#define __itt_module_loadW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_module_load(start_addr, end_addr, path)\n#define __itt_module_load_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_module_loadA_ptr 0\n#define __itt_module_loadW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_module_load_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _ITTNOTIFY_H_ */\n\n#ifdef INTEL_ITTNOTIFY_API_PRIVATE\n\n#ifndef _ITTNOTIFY_PRIVATE_\n#define _ITTNOTIFY_PRIVATE_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/**\n * @ingroup clockdomain\n * @brief Begin an overlapped task instance.\n * @param[in] domain The domain for this task\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] taskid The identifier for this task instance, *cannot* be\n * __itt_null.\n * @param[in] parentid The parent of this task, or __itt_null.\n * @param[in] name The name of this task.\n */\nvoid ITTAPI __itt_task_begin_overlapped_ex(const __itt_domain *domain,\n                                           __itt_clock_domain *clock_domain,\n                                           unsigned long long timestamp,\n                                           __itt_id taskid, __itt_id parentid,\n                                           __itt_string_handle *name);\n\n/**\n * @ingroup clockdomain\n * @brief End an overlapped task instance.\n * @param[in] domain The domain for this task\n * @param[in] clock_domain The clock domain controlling the execution of this\n * call.\n * @param[in] timestamp The user defined timestamp.\n * @param[in] taskid Explicit ID of finished task\n */\nvoid ITTAPI __itt_task_end_overlapped_ex(const __itt_domain *domain,\n                                         __itt_clock_domain *clock_domain,\n                                         unsigned long long timestamp,\n                                         __itt_id taskid);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, task_begin_overlapped_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id taskid, __itt_id parentid,\n           __itt_string_handle *name))\nITT_STUBV(ITTAPI, void, task_end_overlapped_ex,\n          (const __itt_domain *domain, __itt_clock_domain *clock_domain,\n           unsigned long long timestamp, __itt_id taskid))\n#define __itt_task_begin_overlapped_ex(d, x, y, z, a, b)                       \\\n  ITTNOTIFY_VOID_D5(task_begin_overlapped_ex, d, x, y, z, a, b)\n#define __itt_task_begin_overlapped_ex_ptr                                     \\\n  ITTNOTIFY_NAME(task_begin_overlapped_ex)\n#define __itt_task_end_overlapped_ex(d, x, y, z)                               \\\n  ITTNOTIFY_VOID_D3(task_end_overlapped_ex, d, x, y, z)\n#define __itt_task_end_overlapped_ex_ptr ITTNOTIFY_NAME(task_end_overlapped_ex)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_task_begin_overlapped_ex(domain, clock_domain, timestamp,        \\\n                                       taskid, parentid, name)\n#define __itt_task_begin_overlapped_ex_ptr 0\n#define __itt_task_end_overlapped_ex(domain, clock_domain, timestamp, taskid)\n#define __itt_task_end_overlapped_ex_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_task_begin_overlapped_ex_ptr 0\n#define __itt_task_end_overlapped_ptr 0\n#define __itt_task_end_overlapped_ex_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @defgroup makrs_internal Marks\n * @ingroup internal\n * Marks group\n * @warning Internal API:\n *   - It is not shipped to outside of Intel\n *   - It is delivered to internal Intel teams using e-mail or SVN access only\n * @{\n */\n/** @brief user mark type */\ntypedef int __itt_mark_type;\n\n/**\n * @brief Creates a user mark type with the specified name using char or Unicode\n * string.\n * @param[in] name - name of mark to create\n * @return Returns a handle to the mark type\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n__itt_mark_type ITTAPI __itt_mark_createA(const char *name);\n__itt_mark_type ITTAPI __itt_mark_createW(const wchar_t *name);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_mark_create __itt_mark_createW\n#define __itt_mark_create_ptr __itt_mark_createW_ptr\n#else /* UNICODE */\n#define __itt_mark_create __itt_mark_createA\n#define __itt_mark_create_ptr __itt_mark_createA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n__itt_mark_type ITTAPI __itt_mark_create(const char *name);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, __itt_mark_type, mark_createA, (const char *name))\nITT_STUB(ITTAPI, __itt_mark_type, mark_createW, (const wchar_t *name))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, __itt_mark_type, mark_create, (const char *name))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_mark_createA ITTNOTIFY_DATA(mark_createA)\n#define __itt_mark_createA_ptr ITTNOTIFY_NAME(mark_createA)\n#define __itt_mark_createW ITTNOTIFY_DATA(mark_createW)\n#define __itt_mark_createW_ptr ITTNOTIFY_NAME(mark_createW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_create ITTNOTIFY_DATA(mark_create)\n#define __itt_mark_create_ptr ITTNOTIFY_NAME(mark_create)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_mark_createA(name) (__itt_mark_type)0\n#define __itt_mark_createA_ptr 0\n#define __itt_mark_createW(name) (__itt_mark_type)0\n#define __itt_mark_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_create(name) (__itt_mark_type)0\n#define __itt_mark_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_mark_createA_ptr 0\n#define __itt_mark_createW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_create_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Creates a \"discrete\" user mark type of the specified type and an\n * optional parameter using char or Unicode string.\n *\n * - The mark of \"discrete\" type is placed to collection results in case of\n * success. It appears in overtime view(s) as a special tick sign.\n * - The call is \"synchronous\" - function returns after mark is actually added\n * to results.\n * - This function is useful, for example, to mark different phases of\n * application (beginning of the next mark automatically meand end of current\n * region).\n * - Can be used together with \"continuous\" marks (see below) at the same\n * collection session\n * @param[in] mt - mark, created by __itt_mark_create(const char* name) function\n * @param[in] parameter - string parameter of mark\n * @return Returns zero value in case of success, non-zero value otherwise.\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nint ITTAPI __itt_markA(__itt_mark_type mt, const char *parameter);\nint ITTAPI __itt_markW(__itt_mark_type mt, const wchar_t *parameter);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_mark __itt_markW\n#define __itt_mark_ptr __itt_markW_ptr\n#else /* UNICODE  */\n#define __itt_mark __itt_markA\n#define __itt_mark_ptr __itt_markA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nint ITTAPI __itt_mark(__itt_mark_type mt, const char *parameter);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, int, markA, (__itt_mark_type mt, const char *parameter))\nITT_STUB(ITTAPI, int, markW, (__itt_mark_type mt, const wchar_t *parameter))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, int, mark, (__itt_mark_type mt, const char *parameter))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_markA ITTNOTIFY_DATA(markA)\n#define __itt_markA_ptr ITTNOTIFY_NAME(markA)\n#define __itt_markW ITTNOTIFY_DATA(markW)\n#define __itt_markW_ptr ITTNOTIFY_NAME(markW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark ITTNOTIFY_DATA(mark)\n#define __itt_mark_ptr ITTNOTIFY_NAME(mark)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_markA(mt, parameter) (int)0\n#define __itt_markA_ptr 0\n#define __itt_markW(mt, parameter) (int)0\n#define __itt_markW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark(mt, parameter) (int)0\n#define __itt_mark_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_markA_ptr 0\n#define __itt_markW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Use this if necessary to create a \"discrete\" user event type (mark)\n * for process rather then for one thread\n * @see int __itt_mark(__itt_mark_type mt, const char* parameter);\n */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nint ITTAPI __itt_mark_globalA(__itt_mark_type mt, const char *parameter);\nint ITTAPI __itt_mark_globalW(__itt_mark_type mt, const wchar_t *parameter);\n#if defined(UNICODE) || defined(_UNICODE)\n#define __itt_mark_global __itt_mark_globalW\n#define __itt_mark_global_ptr __itt_mark_globalW_ptr\n#else /* UNICODE  */\n#define __itt_mark_global __itt_mark_globalA\n#define __itt_mark_global_ptr __itt_mark_globalA_ptr\n#endif /* UNICODE */\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nint ITTAPI __itt_mark_global(__itt_mark_type mt, const char *parameter);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\nITT_STUB(ITTAPI, int, mark_globalA, (__itt_mark_type mt, const char *parameter))\nITT_STUB(ITTAPI, int, mark_globalW,\n         (__itt_mark_type mt, const wchar_t *parameter))\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nITT_STUB(ITTAPI, int, mark_global, (__itt_mark_type mt, const char *parameter))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_mark_globalA ITTNOTIFY_DATA(mark_globalA)\n#define __itt_mark_globalA_ptr ITTNOTIFY_NAME(mark_globalA)\n#define __itt_mark_globalW ITTNOTIFY_DATA(mark_globalW)\n#define __itt_mark_globalW_ptr ITTNOTIFY_NAME(mark_globalW)\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_global ITTNOTIFY_DATA(mark_global)\n#define __itt_mark_global_ptr ITTNOTIFY_NAME(mark_global)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#else /* INTEL_NO_ITTNOTIFY_API */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_mark_globalA(mt, parameter) (int)0\n#define __itt_mark_globalA_ptr 0\n#define __itt_mark_globalW(mt, parameter) (int)0\n#define __itt_mark_globalW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_global(mt, parameter) (int)0\n#define __itt_mark_global_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#if ITT_PLATFORM == ITT_PLATFORM_WIN\n#define __itt_mark_globalA_ptr 0\n#define __itt_mark_globalW_ptr 0\n#else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define __itt_mark_global_ptr 0\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Creates an \"end\" point for \"continuous\" mark with specified name.\n *\n * - Returns zero value in case of success, non-zero value otherwise.\n *   Also returns non-zero value when preceding \"begin\" point for the\n *   mark with the same name failed to be created or not created.\n * - The mark of \"continuous\" type is placed to collection results in\n *   case of success. It appears in overtime view(s) as a special tick\n *   sign (different from \"discrete\" mark) together with line from\n *   corresponding \"begin\" mark to \"end\" mark.\n * @note Continuous marks can overlap and be nested inside each other.\n * Discrete mark can be nested inside marked region\n * @param[in] mt - mark, created by __itt_mark_create(const char* name) function\n * @return Returns zero value in case of success, non-zero value otherwise.\n */\nint ITTAPI __itt_mark_off(__itt_mark_type mt);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, int, mark_off, (__itt_mark_type mt))\n#define __itt_mark_off ITTNOTIFY_DATA(mark_off)\n#define __itt_mark_off_ptr ITTNOTIFY_NAME(mark_off)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_mark_off(mt) (int)0\n#define __itt_mark_off_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_mark_off_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Use this if necessary to create an \"end\" point for mark of process\n * @see int __itt_mark_off(__itt_mark_type mt);\n */\nint ITTAPI __itt_mark_global_off(__itt_mark_type mt);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, int, mark_global_off, (__itt_mark_type mt))\n#define __itt_mark_global_off ITTNOTIFY_DATA(mark_global_off)\n#define __itt_mark_global_off_ptr ITTNOTIFY_NAME(mark_global_off)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_mark_global_off(mt) (int)0\n#define __itt_mark_global_off_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_mark_global_off_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n/** @} marks group */\n\n/**\n * @defgroup counters_internal Counters\n * @ingroup internal\n * Counters group\n * @{\n */\n\n/**\n * @defgroup stitch Stack Stitching\n * @ingroup internal\n * Stack Stitching group\n * @{\n */\n/**\n * @brief opaque structure for counter identification\n */\ntypedef struct ___itt_caller *__itt_caller;\n\n/**\n * @brief Create the stitch point e.g. a point in call stack where other stacks\n * should be stitched to. The function returns a unique identifier which is used\n * to match the cut points with corresponding stitch points.\n */\n__itt_caller ITTAPI __itt_stack_caller_create(void);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUB(ITTAPI, __itt_caller, stack_caller_create, (void))\n#define __itt_stack_caller_create ITTNOTIFY_DATA(stack_caller_create)\n#define __itt_stack_caller_create_ptr ITTNOTIFY_NAME(stack_caller_create)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_stack_caller_create() (__itt_caller)0\n#define __itt_stack_caller_create_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_stack_caller_create_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Destroy the information about stitch point identified by the pointer\n * previously returned by __itt_stack_caller_create()\n */\nvoid ITTAPI __itt_stack_caller_destroy(__itt_caller id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, stack_caller_destroy, (__itt_caller id))\n#define __itt_stack_caller_destroy ITTNOTIFY_VOID(stack_caller_destroy)\n#define __itt_stack_caller_destroy_ptr ITTNOTIFY_NAME(stack_caller_destroy)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_stack_caller_destroy(id)\n#define __itt_stack_caller_destroy_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_stack_caller_destroy_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief Sets the cut point. Stack from each event which occurs after this call\n * will be cut at the same stack level the function was called and stitched to\n * the corresponding stitch point.\n */\nvoid ITTAPI __itt_stack_callee_enter(__itt_caller id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, stack_callee_enter, (__itt_caller id))\n#define __itt_stack_callee_enter ITTNOTIFY_VOID(stack_callee_enter)\n#define __itt_stack_callee_enter_ptr ITTNOTIFY_NAME(stack_callee_enter)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_stack_callee_enter(id)\n#define __itt_stack_callee_enter_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_stack_callee_enter_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/**\n * @brief This function eliminates the cut point which was set by latest\n * __itt_stack_callee_enter().\n */\nvoid ITTAPI __itt_stack_callee_leave(__itt_caller id);\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\nITT_STUBV(ITTAPI, void, stack_callee_leave, (__itt_caller id))\n#define __itt_stack_callee_leave ITTNOTIFY_VOID(stack_callee_leave)\n#define __itt_stack_callee_leave_ptr ITTNOTIFY_NAME(stack_callee_leave)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_stack_callee_leave(id)\n#define __itt_stack_callee_leave_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_stack_callee_leave_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n/** @} stitch group */\n\n/* *****************************************************************************************************************************\n */\n\n#include <stdarg.h>\n\n/** @cond exclude_from_documentation */\ntypedef enum __itt_error_code {\n  __itt_error_success = 0, /*!< no error */\n  __itt_error_no_module = 1, /*!< module can't be loaded */\n  /* %1$s -- library name; win: %2$d -- system error code; unx: %2$s -- system\n     error message. */\n  __itt_error_no_symbol = 2, /*!< symbol not found */\n  /* %1$s -- library name, %2$s -- symbol name. */\n  __itt_error_unknown_group = 3, /*!< unknown group specified */\n  /* %1$s -- env var name, %2$s -- group name. */\n  __itt_error_cant_read_env = 4, /*!< GetEnvironmentVariable() failed */\n  /* %1$s -- env var name, %2$d -- system error. */\n  __itt_error_env_too_long = 5, /*!< variable value too long */\n  /* %1$s -- env var name, %2$d -- actual length of the var, %3$d -- max allowed\n     length. */\n  __itt_error_system =\n      6 /*!< pthread_mutexattr_init or pthread_mutex_init failed */\n  /* %1$s -- function name, %2$d -- errno. */\n} __itt_error_code;\n\ntypedef void(__itt_error_handler_t)(__itt_error_code code, va_list);\n__itt_error_handler_t *__itt_set_error_handler(__itt_error_handler_t *);\n\nconst char *ITTAPI __itt_api_version(void);\n/** @endcond */\n\n/** @cond exclude_from_documentation */\n#ifndef INTEL_NO_MACRO_BODY\n#ifndef INTEL_NO_ITTNOTIFY_API\n#define __itt_error_handler ITT_JOIN(INTEL_ITTNOTIFY_PREFIX, error_handler)\nvoid __itt_error_handler(__itt_error_code code, va_list args);\nextern const int ITTNOTIFY_NAME(err);\n#define __itt_err ITTNOTIFY_NAME(err)\nITT_STUB(ITTAPI, const char *, api_version, (void))\n#define __itt_api_version ITTNOTIFY_DATA(api_version)\n#define __itt_api_version_ptr ITTNOTIFY_NAME(api_version)\n#else /* INTEL_NO_ITTNOTIFY_API */\n#define __itt_api_version() (const char *)0\n#define __itt_api_version_ptr 0\n#endif /* INTEL_NO_ITTNOTIFY_API */\n#else /* INTEL_NO_MACRO_BODY */\n#define __itt_api_version_ptr 0\n#endif /* INTEL_NO_MACRO_BODY */\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _ITTNOTIFY_PRIVATE_ */\n\n#endif /* INTEL_ITTNOTIFY_API_PRIVATE */\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 697}, "message": "default constructor 'Mask' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "7681381f9f7ddd4b69170ef2bd7b589b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 59}, "message": "default constructor '__kmp_env_blk' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_environment.h", "reportHash": "0a7f4d6ae7dbeb55975c0d5dfa656c65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 2, "line": 25}, "message": "'kmp_i18n_id.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_i18n.h", "reportHash": "6b951533a0dc70ca14d1dd8494b70722", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 8, "file": 2, "line": 102}, "message": "destructor '~kmp_msg' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_i18n.h", "reportHash": "970092d28bdb7e4ae8439997193a0dc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 77}, "message": "destructor '~kmp_lock_pool' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_lock.h", "reportHash": "527b24d5158b3e06b039fa9d236d1685", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 241}, "message": "destructor '~kmp_base_ticket_lock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_lock.h", "reportHash": "0ec18e955f57bb044163a753729fb06e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 4, "line": 246}, "message": "destructor '~__kmp_setting' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_settings.cpp", "reportHash": "1ee0d543cc0383825a592852b13addbc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 32}, "message": "default constructor 'kmp_str_buf' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "reportHash": "3d62abd327bd38a761d8a6f2f3daf2be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 67}, "message": "destructor '~kmp_str_fname' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "reportHash": "a074c4763c64ed78cfa2f111b86c1f04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 67}, "message": "move constructor 'kmp_str_fname' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "reportHash": "ccd030f54c9a141c6714661a80d39cff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 92}, "message": "destructor '~kmp_str_loc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "reportHash": "3a669f3101c32af3307af97d009b49a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 92}, "message": "move constructor 'kmp_str_loc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "reportHash": "22f8753d1450a7c618f3188aceba0f34", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 1867}, "message": "destructor '~___itt_id' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/thirdparty/ittnotify/ittnotify.h", "reportHash": "9c9508c545df4119b2c119677a68c864", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 1867}, "message": "move constructor '___itt_id' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/thirdparty/ittnotify/ittnotify.h", "reportHash": "d6bac4845ea766a2b2e56d0c4e3cb857", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
