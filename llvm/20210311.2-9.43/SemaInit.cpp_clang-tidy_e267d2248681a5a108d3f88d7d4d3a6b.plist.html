<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "content": "//===--- SemaInit.cpp - Semantic Analysis for Initializers ----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements semantic analysis for initializers.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Sema/Designator.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace clang;\n\n//===----------------------------------------------------------------------===//\n// Sema Initialization Checking\n//===----------------------------------------------------------------------===//\n\n/// Check whether T is compatible with a wide character type (wchar_t,\n/// char16_t or char32_t).\nstatic bool IsWideCharCompatible(QualType T, ASTContext &Context) {\n  if (Context.typesAreCompatible(Context.getWideCharType(), T))\n    return true;\n  if (Context.getLangOpts().CPlusPlus || Context.getLangOpts().C11) {\n    return Context.typesAreCompatible(Context.Char16Ty, T) ||\n           Context.typesAreCompatible(Context.Char32Ty, T);\n  }\n  return false;\n}\n\nenum StringInitFailureKind {\n  SIF_None,\n  SIF_NarrowStringIntoWideChar,\n  SIF_WideStringIntoChar,\n  SIF_IncompatWideStringIntoWideChar,\n  SIF_UTF8StringIntoPlainChar,\n  SIF_PlainStringIntoUTF8Char,\n  SIF_Other\n};\n\n/// Check whether the array of type AT can be initialized by the Init\n/// expression by means of string initialization. Returns SIF_None if so,\n/// otherwise returns a StringInitFailureKind that describes why the\n/// initialization would not work.\nstatic StringInitFailureKind IsStringInit(Expr *Init, const ArrayType *AT,\n                                          ASTContext &Context) {\n  if (!isa<ConstantArrayType>(AT) && !isa<IncompleteArrayType>(AT))\n    return SIF_Other;\n\n  // See if this is a string literal or @encode.\n  Init = Init->IgnoreParens();\n\n  // Handle @encode, which is a narrow string.\n  if (isa<ObjCEncodeExpr>(Init) && AT->getElementType()->isCharType())\n    return SIF_None;\n\n  // Otherwise we can only handle string literals.\n  StringLiteral *SL = dyn_cast<StringLiteral>(Init);\n  if (!SL)\n    return SIF_Other;\n\n  const QualType ElemTy =\n      Context.getCanonicalType(AT->getElementType()).getUnqualifiedType();\n\n  switch (SL->getKind()) {\n  case StringLiteral::UTF8:\n    // char8_t array can be initialized with a UTF-8 string.\n    if (ElemTy->isChar8Type())\n      return SIF_None;\n    LLVM_FALLTHROUGH;\n  case StringLiteral::Ascii:\n    // char array can be initialized with a narrow string.\n    // Only allow char x[] = \"foo\";  not char x[] = L\"foo\";\n    if (ElemTy->isCharType())\n      return (SL->getKind() == StringLiteral::UTF8 &&\n              Context.getLangOpts().Char8)\n                 ? SIF_UTF8StringIntoPlainChar\n                 : SIF_None;\n    if (ElemTy->isChar8Type())\n      return SIF_PlainStringIntoUTF8Char;\n    if (IsWideCharCompatible(ElemTy, Context))\n      return SIF_NarrowStringIntoWideChar;\n    return SIF_Other;\n  // C99 6.7.8p15 (with correction from DR343), or C11 6.7.9p15:\n  // \"An array with element type compatible with a qualified or unqualified\n  // version of wchar_t, char16_t, or char32_t may be initialized by a wide\n  // string literal with the corresponding encoding prefix (L, u, or U,\n  // respectively), optionally enclosed in braces.\n  case StringLiteral::UTF16:\n    if (Context.typesAreCompatible(Context.Char16Ty, ElemTy))\n      return SIF_None;\n    if (ElemTy->isCharType() || ElemTy->isChar8Type())\n      return SIF_WideStringIntoChar;\n    if (IsWideCharCompatible(ElemTy, Context))\n      return SIF_IncompatWideStringIntoWideChar;\n    return SIF_Other;\n  case StringLiteral::UTF32:\n    if (Context.typesAreCompatible(Context.Char32Ty, ElemTy))\n      return SIF_None;\n    if (ElemTy->isCharType() || ElemTy->isChar8Type())\n      return SIF_WideStringIntoChar;\n    if (IsWideCharCompatible(ElemTy, Context))\n      return SIF_IncompatWideStringIntoWideChar;\n    return SIF_Other;\n  case StringLiteral::Wide:\n    if (Context.typesAreCompatible(Context.getWideCharType(), ElemTy))\n      return SIF_None;\n    if (ElemTy->isCharType() || ElemTy->isChar8Type())\n      return SIF_WideStringIntoChar;\n    if (IsWideCharCompatible(ElemTy, Context))\n      return SIF_IncompatWideStringIntoWideChar;\n    return SIF_Other;\n  }\n\n  llvm_unreachable(\"missed a StringLiteral kind?\");\n}\n\nstatic StringInitFailureKind IsStringInit(Expr *init, QualType declType,\n                                          ASTContext &Context) {\n  const ArrayType *arrayType = Context.getAsArrayType(declType);\n  if (!arrayType)\n    return SIF_Other;\n  return IsStringInit(init, arrayType, Context);\n}\n\nbool Sema::IsStringInit(Expr *Init, const ArrayType *AT) {\n  return ::IsStringInit(Init, AT, Context) == SIF_None;\n}\n\n/// Update the type of a string literal, including any surrounding parentheses,\n/// to match the type of the object which it is initializing.\nstatic void updateStringLiteralType(Expr *E, QualType Ty) {\n  while (true) {\n    E->setType(Ty);\n    E->setValueKind(VK_RValue);\n    if (isa<StringLiteral>(E) || isa<ObjCEncodeExpr>(E)) {\n      break;\n    } else if (ParenExpr *PE = dyn_cast<ParenExpr>(E)) {\n      E = PE->getSubExpr();\n    } else if (UnaryOperator *UO = dyn_cast<UnaryOperator>(E)) {\n      assert(UO->getOpcode() == UO_Extension);\n      E = UO->getSubExpr();\n    } else if (GenericSelectionExpr *GSE = dyn_cast<GenericSelectionExpr>(E)) {\n      E = GSE->getResultExpr();\n    } else if (ChooseExpr *CE = dyn_cast<ChooseExpr>(E)) {\n      E = CE->getChosenSubExpr();\n    } else {\n      llvm_unreachable(\"unexpected expr in string literal init\");\n    }\n  }\n}\n\n/// Fix a compound literal initializing an array so it's correctly marked\n/// as an rvalue.\nstatic void updateGNUCompoundLiteralRValue(Expr *E) {\n  while (true) {\n    E->setValueKind(VK_RValue);\n    if (isa<CompoundLiteralExpr>(E)) {\n      break;\n    } else if (ParenExpr *PE = dyn_cast<ParenExpr>(E)) {\n      E = PE->getSubExpr();\n    } else if (UnaryOperator *UO = dyn_cast<UnaryOperator>(E)) {\n      assert(UO->getOpcode() == UO_Extension);\n      E = UO->getSubExpr();\n    } else if (GenericSelectionExpr *GSE = dyn_cast<GenericSelectionExpr>(E)) {\n      E = GSE->getResultExpr();\n    } else if (ChooseExpr *CE = dyn_cast<ChooseExpr>(E)) {\n      E = CE->getChosenSubExpr();\n    } else {\n      llvm_unreachable(\"unexpected expr in array compound literal init\");\n    }\n  }\n}\n\nstatic void CheckStringInit(Expr *Str, QualType &DeclT, const ArrayType *AT,\n                            Sema &S) {\n  // Get the length of the string as parsed.\n  auto *ConstantArrayTy =\n      cast<ConstantArrayType>(Str->getType()->getAsArrayTypeUnsafe());\n  uint64_t StrLength = ConstantArrayTy->getSize().getZExtValue();\n\n  if (const IncompleteArrayType *IAT = dyn_cast<IncompleteArrayType>(AT)) {\n    // C99 6.7.8p14. We have an array of character type with unknown size\n    // being initialized to a string literal.\n    llvm::APInt ConstVal(32, StrLength);\n    // Return a new array type (C99 6.7.8p22).\n    DeclT = S.Context.getConstantArrayType(IAT->getElementType(),\n                                           ConstVal, nullptr,\n                                           ArrayType::Normal, 0);\n    updateStringLiteralType(Str, DeclT);\n    return;\n  }\n\n  const ConstantArrayType *CAT = cast<ConstantArrayType>(AT);\n\n  // We have an array of character type with known size.  However,\n  // the size may be smaller or larger than the string we are initializing.\n  // FIXME: Avoid truncation for 64-bit length strings.\n  if (S.getLangOpts().CPlusPlus) {\n    if (StringLiteral *SL = dyn_cast<StringLiteral>(Str->IgnoreParens())) {\n      // For Pascal strings it's OK to strip off the terminating null character,\n      // so the example below is valid:\n      //\n      // unsigned char a[2] = \"\\pa\";\n      if (SL->isPascal())\n        StrLength--;\n    }\n\n    // [dcl.init.string]p2\n    if (StrLength > CAT->getSize().getZExtValue())\n      S.Diag(Str->getBeginLoc(),\n             diag::err_initializer_string_for_char_array_too_long)\n          << Str->getSourceRange();\n  } else {\n    // C99 6.7.8p14.\n    if (StrLength-1 > CAT->getSize().getZExtValue())\n      S.Diag(Str->getBeginLoc(),\n             diag::ext_initializer_string_for_char_array_too_long)\n          << Str->getSourceRange();\n  }\n\n  // Set the type to the actual size that we are initializing.  If we have\n  // something like:\n  //   char x[1] = \"foo\";\n  // then this will set the string literal's type to char[1].\n  updateStringLiteralType(Str, DeclT);\n}\n\n//===----------------------------------------------------------------------===//\n// Semantic checking for initializer lists.\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\n/// Semantic checking for initializer lists.\n///\n/// The InitListChecker class contains a set of routines that each\n/// handle the initialization of a certain kind of entity, e.g.,\n/// arrays, vectors, struct/union types, scalars, etc. The\n/// InitListChecker itself performs a recursive walk of the subobject\n/// structure of the type to be initialized, while stepping through\n/// the initializer list one element at a time. The IList and Index\n/// parameters to each of the Check* routines contain the active\n/// (syntactic) initializer list and the index into that initializer\n/// list that represents the current initializer. Each routine is\n/// responsible for moving that Index forward as it consumes elements.\n///\n/// Each Check* routine also has a StructuredList/StructuredIndex\n/// arguments, which contains the current \"structured\" (semantic)\n/// initializer list and the index into that initializer list where we\n/// are copying initializers as we map them over to the semantic\n/// list. Once we have completed our recursive walk of the subobject\n/// structure, we will have constructed a full semantic initializer\n/// list.\n///\n/// C99 designators cause changes in the initializer list traversal,\n/// because they make the initialization \"jump\" into a specific\n/// subobject and then continue the initialization from that\n/// point. CheckDesignatedInitializer() recursively steps into the\n/// designated subobject and manages backing out the recursion to\n/// initialize the subobjects after the one designated.\n///\n/// If an initializer list contains any designators, we build a placeholder\n/// structured list even in 'verify only' mode, so that we can track which\n/// elements need 'empty' initializtion.\nclass InitListChecker {\n  Sema &SemaRef;\n  bool hadError = false;\n  bool VerifyOnly; // No diagnostics.\n  bool TreatUnavailableAsInvalid; // Used only in VerifyOnly mode.\n  bool InOverloadResolution;\n  InitListExpr *FullyStructuredList = nullptr;\n  NoInitExpr *DummyExpr = nullptr;\n\n  NoInitExpr *getDummyInit() {\n    if (!DummyExpr)\n      DummyExpr = new (SemaRef.Context) NoInitExpr(SemaRef.Context.VoidTy);\n    return DummyExpr;\n  }\n\n  void CheckImplicitInitList(const InitializedEntity &Entity,\n                             InitListExpr *ParentIList, QualType T,\n                             unsigned &Index, InitListExpr *StructuredList,\n                             unsigned &StructuredIndex);\n  void CheckExplicitInitList(const InitializedEntity &Entity,\n                             InitListExpr *IList, QualType &T,\n                             InitListExpr *StructuredList,\n                             bool TopLevelObject = false);\n  void CheckListElementTypes(const InitializedEntity &Entity,\n                             InitListExpr *IList, QualType &DeclType,\n                             bool SubobjectIsDesignatorContext,\n                             unsigned &Index,\n                             InitListExpr *StructuredList,\n                             unsigned &StructuredIndex,\n                             bool TopLevelObject = false);\n  void CheckSubElementType(const InitializedEntity &Entity,\n                           InitListExpr *IList, QualType ElemType,\n                           unsigned &Index,\n                           InitListExpr *StructuredList,\n                           unsigned &StructuredIndex,\n                           bool DirectlyDesignated = false);\n  void CheckComplexType(const InitializedEntity &Entity,\n                        InitListExpr *IList, QualType DeclType,\n                        unsigned &Index,\n                        InitListExpr *StructuredList,\n                        unsigned &StructuredIndex);\n  void CheckScalarType(const InitializedEntity &Entity,\n                       InitListExpr *IList, QualType DeclType,\n                       unsigned &Index,\n                       InitListExpr *StructuredList,\n                       unsigned &StructuredIndex);\n  void CheckReferenceType(const InitializedEntity &Entity,\n                          InitListExpr *IList, QualType DeclType,\n                          unsigned &Index,\n                          InitListExpr *StructuredList,\n                          unsigned &StructuredIndex);\n  void CheckVectorType(const InitializedEntity &Entity,\n                       InitListExpr *IList, QualType DeclType, unsigned &Index,\n                       InitListExpr *StructuredList,\n                       unsigned &StructuredIndex);\n  void CheckStructUnionTypes(const InitializedEntity &Entity,\n                             InitListExpr *IList, QualType DeclType,\n                             CXXRecordDecl::base_class_range Bases,\n                             RecordDecl::field_iterator Field,\n                             bool SubobjectIsDesignatorContext, unsigned &Index,\n                             InitListExpr *StructuredList,\n                             unsigned &StructuredIndex,\n                             bool TopLevelObject = false);\n  void CheckArrayType(const InitializedEntity &Entity,\n                      InitListExpr *IList, QualType &DeclType,\n                      llvm::APSInt elementIndex,\n                      bool SubobjectIsDesignatorContext, unsigned &Index,\n                      InitListExpr *StructuredList,\n                      unsigned &StructuredIndex);\n  bool CheckDesignatedInitializer(const InitializedEntity &Entity,\n                                  InitListExpr *IList, DesignatedInitExpr *DIE,\n                                  unsigned DesigIdx,\n                                  QualType &CurrentObjectType,\n                                  RecordDecl::field_iterator *NextField,\n                                  llvm::APSInt *NextElementIndex,\n                                  unsigned &Index,\n                                  InitListExpr *StructuredList,\n                                  unsigned &StructuredIndex,\n                                  bool FinishSubobjectInit,\n                                  bool TopLevelObject);\n  InitListExpr *getStructuredSubobjectInit(InitListExpr *IList, unsigned Index,\n                                           QualType CurrentObjectType,\n                                           InitListExpr *StructuredList,\n                                           unsigned StructuredIndex,\n                                           SourceRange InitRange,\n                                           bool IsFullyOverwritten = false);\n  void UpdateStructuredListElement(InitListExpr *StructuredList,\n                                   unsigned &StructuredIndex,\n                                   Expr *expr);\n  InitListExpr *createInitListExpr(QualType CurrentObjectType,\n                                   SourceRange InitRange,\n                                   unsigned ExpectedNumInits);\n  int numArrayElements(QualType DeclType);\n  int numStructUnionElements(QualType DeclType);\n\n  ExprResult PerformEmptyInit(SourceLocation Loc,\n                              const InitializedEntity &Entity);\n\n  /// Diagnose that OldInit (or part thereof) has been overridden by NewInit.\n  void diagnoseInitOverride(Expr *OldInit, SourceRange NewInitRange,\n                            bool FullyOverwritten = true) {\n    // Overriding an initializer via a designator is valid with C99 designated\n    // initializers, but ill-formed with C++20 designated initializers.\n    unsigned DiagID = SemaRef.getLangOpts().CPlusPlus\n                          ? diag::ext_initializer_overrides\n                          : diag::warn_initializer_overrides;\n\n    if (InOverloadResolution && SemaRef.getLangOpts().CPlusPlus) {\n      // In overload resolution, we have to strictly enforce the rules, and so\n      // don't allow any overriding of prior initializers. This matters for a\n      // case such as:\n      //\n      //   union U { int a, b; };\n      //   struct S { int a, b; };\n      //   void f(U), f(S);\n      //\n      // Here, f({.a = 1, .b = 2}) is required to call the struct overload. For\n      // consistency, we disallow all overriding of prior initializers in\n      // overload resolution, not only overriding of union members.\n      hadError = true;\n    } else if (OldInit->getType().isDestructedType() && !FullyOverwritten) {\n      // If we'll be keeping around the old initializer but overwriting part of\n      // the object it initialized, and that object is not trivially\n      // destructible, this can leak. Don't allow that, not even as an\n      // extension.\n      //\n      // FIXME: It might be reasonable to allow this in cases where the part of\n      // the initializer that we're overriding has trivial destruction.\n      DiagID = diag::err_initializer_overrides_destructed;\n    } else if (!OldInit->getSourceRange().isValid()) {\n      // We need to check on source range validity because the previous\n      // initializer does not have to be an explicit initializer. e.g.,\n      //\n      // struct P { int a, b; };\n      // struct PP { struct P p } l = { { .a = 2 }, .p.b = 3 };\n      //\n      // There is an overwrite taking place because the first braced initializer\n      // list \"{ .a = 2 }\" already provides value for .p.b (which is zero).\n      //\n      // Such overwrites are harmless, so we don't diagnose them. (Note that in\n      // C++, this cannot be reached unless we've already seen and diagnosed a\n      // different conformance issue, such as a mixture of designated and\n      // non-designated initializers or a multi-level designator.)\n      return;\n    }\n\n    if (!VerifyOnly) {\n      SemaRef.Diag(NewInitRange.getBegin(), DiagID)\n          << NewInitRange << FullyOverwritten << OldInit->getType();\n      SemaRef.Diag(OldInit->getBeginLoc(), diag::note_previous_initializer)\n          << (OldInit->HasSideEffects(SemaRef.Context) && FullyOverwritten)\n          << OldInit->getSourceRange();\n    }\n  }\n\n  // Explanation on the \"FillWithNoInit\" mode:\n  //\n  // Assume we have the following definitions (Case#1):\n  // struct P { char x[6][6]; } xp = { .x[1] = \"bar\" };\n  // struct PP { struct P lp; } l = { .lp = xp, .lp.x[1][2] = 'f' };\n  //\n  // l.lp.x[1][0..1] should not be filled with implicit initializers because the\n  // \"base\" initializer \"xp\" will provide values for them; l.lp.x[1] will be \"baf\".\n  //\n  // But if we have (Case#2):\n  // struct PP l = { .lp = xp, .lp.x[1] = { [2] = 'f' } };\n  //\n  // l.lp.x[1][0..1] are implicitly initialized and do not use values from the\n  // \"base\" initializer; l.lp.x[1] will be \"\\0\\0f\\0\\0\\0\".\n  //\n  // To distinguish Case#1 from Case#2, and also to avoid leaving many \"holes\"\n  // in the InitListExpr, the \"holes\" in Case#1 are filled not with empty\n  // initializers but with special \"NoInitExpr\" place holders, which tells the\n  // CodeGen not to generate any initializers for these parts.\n  void FillInEmptyInitForBase(unsigned Init, const CXXBaseSpecifier &Base,\n                              const InitializedEntity &ParentEntity,\n                              InitListExpr *ILE, bool &RequiresSecondPass,\n                              bool FillWithNoInit);\n  void FillInEmptyInitForField(unsigned Init, FieldDecl *Field,\n                               const InitializedEntity &ParentEntity,\n                               InitListExpr *ILE, bool &RequiresSecondPass,\n                               bool FillWithNoInit = false);\n  void FillInEmptyInitializations(const InitializedEntity &Entity,\n                                  InitListExpr *ILE, bool &RequiresSecondPass,\n                                  InitListExpr *OuterILE, unsigned OuterIndex,\n                                  bool FillWithNoInit = false);\n  bool CheckFlexibleArrayInit(const InitializedEntity &Entity,\n                              Expr *InitExpr, FieldDecl *Field,\n                              bool TopLevelObject);\n  void CheckEmptyInitializable(const InitializedEntity &Entity,\n                               SourceLocation Loc);\n\npublic:\n  InitListChecker(Sema &S, const InitializedEntity &Entity, InitListExpr *IL,\n                  QualType &T, bool VerifyOnly, bool TreatUnavailableAsInvalid,\n                  bool InOverloadResolution = false);\n  bool HadError() { return hadError; }\n\n  // Retrieves the fully-structured initializer list used for\n  // semantic analysis and code generation.\n  InitListExpr *getFullyStructuredList() const { return FullyStructuredList; }\n};\n\n} // end anonymous namespace\n\nExprResult InitListChecker::PerformEmptyInit(SourceLocation Loc,\n                                             const InitializedEntity &Entity) {\n  InitializationKind Kind = InitializationKind::CreateValue(Loc, Loc, Loc,\n                                                            true);\n  MultiExprArg SubInit;\n  Expr *InitExpr;\n  InitListExpr DummyInitList(SemaRef.Context, Loc, None, Loc);\n\n  // C++ [dcl.init.aggr]p7:\n  //   If there are fewer initializer-clauses in the list than there are\n  //   members in the aggregate, then each member not explicitly initialized\n  //   ...\n  bool EmptyInitList = SemaRef.getLangOpts().CPlusPlus11 &&\n      Entity.getType()->getBaseElementTypeUnsafe()->isRecordType();\n  if (EmptyInitList) {\n    // C++1y / DR1070:\n    //   shall be initialized [...] from an empty initializer list.\n    //\n    // We apply the resolution of this DR to C++11 but not C++98, since C++98\n    // does not have useful semantics for initialization from an init list.\n    // We treat this as copy-initialization, because aggregate initialization\n    // always performs copy-initialization on its elements.\n    //\n    // Only do this if we're initializing a class type, to avoid filling in\n    // the initializer list where possible.\n    InitExpr = VerifyOnly ? &DummyInitList : new (SemaRef.Context)\n                   InitListExpr(SemaRef.Context, Loc, None, Loc);\n    InitExpr->setType(SemaRef.Context.VoidTy);\n    SubInit = InitExpr;\n    Kind = InitializationKind::CreateCopy(Loc, Loc);\n  } else {\n    // C++03:\n    //   shall be value-initialized.\n  }\n\n  InitializationSequence InitSeq(SemaRef, Entity, Kind, SubInit);\n  // libstdc++4.6 marks the vector default constructor as explicit in\n  // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.\n  // stlport does so too. Look for std::__debug for libstdc++, and for\n  // std:: for stlport.  This is effectively a compiler-side implementation of\n  // LWG2193.\n  if (!InitSeq && EmptyInitList && InitSeq.getFailureKind() ==\n          InitializationSequence::FK_ExplicitConstructor) {\n    OverloadCandidateSet::iterator Best;\n    OverloadingResult O =\n        InitSeq.getFailedCandidateSet()\n            .BestViableFunction(SemaRef, Kind.getLocation(), Best);\n    (void)O;\n    assert(O == OR_Success && \"Inconsistent overload resolution\");\n    CXXConstructorDecl *CtorDecl = cast<CXXConstructorDecl>(Best->Function);\n    CXXRecordDecl *R = CtorDecl->getParent();\n\n    if (CtorDecl->getMinRequiredArguments() == 0 &&\n        CtorDecl->isExplicit() && R->getDeclName() &&\n        SemaRef.SourceMgr.isInSystemHeader(CtorDecl->getLocation())) {\n      bool IsInStd = false;\n      for (NamespaceDecl *ND = dyn_cast<NamespaceDecl>(R->getDeclContext());\n           ND && !IsInStd; ND = dyn_cast<NamespaceDecl>(ND->getParent())) {\n        if (SemaRef.getStdNamespace()->InEnclosingNamespaceSetOf(ND))\n          IsInStd = true;\n      }\n\n      if (IsInStd && llvm::StringSwitch<bool>(R->getName())\n              .Cases(\"basic_string\", \"deque\", \"forward_list\", true)\n              .Cases(\"list\", \"map\", \"multimap\", \"multiset\", true)\n              .Cases(\"priority_queue\", \"queue\", \"set\", \"stack\", true)\n              .Cases(\"unordered_map\", \"unordered_set\", \"vector\", true)\n              .Default(false)) {\n        InitSeq.InitializeFrom(\n            SemaRef, Entity,\n            InitializationKind::CreateValue(Loc, Loc, Loc, true),\n            MultiExprArg(), /*TopLevelOfInitList=*/false,\n            TreatUnavailableAsInvalid);\n        // Emit a warning for this.  System header warnings aren't shown\n        // by default, but people working on system headers should see it.\n        if (!VerifyOnly) {\n          SemaRef.Diag(CtorDecl->getLocation(),\n                       diag::warn_invalid_initializer_from_system_header);\n          if (Entity.getKind() == InitializedEntity::EK_Member)\n            SemaRef.Diag(Entity.getDecl()->getLocation(),\n                         diag::note_used_in_initialization_here);\n          else if (Entity.getKind() == InitializedEntity::EK_ArrayElement)\n            SemaRef.Diag(Loc, diag::note_used_in_initialization_here);\n        }\n      }\n    }\n  }\n  if (!InitSeq) {\n    if (!VerifyOnly) {\n      InitSeq.Diagnose(SemaRef, Entity, Kind, SubInit);\n      if (Entity.getKind() == InitializedEntity::EK_Member)\n        SemaRef.Diag(Entity.getDecl()->getLocation(),\n                     diag::note_in_omitted_aggregate_initializer)\n          << /*field*/1 << Entity.getDecl();\n      else if (Entity.getKind() == InitializedEntity::EK_ArrayElement) {\n        bool IsTrailingArrayNewMember =\n            Entity.getParent() &&\n            Entity.getParent()->isVariableLengthArrayNew();\n        SemaRef.Diag(Loc, diag::note_in_omitted_aggregate_initializer)\n          << (IsTrailingArrayNewMember ? 2 : /*array element*/0)\n          << Entity.getElementIndex();\n      }\n    }\n    hadError = true;\n    return ExprError();\n  }\n\n  return VerifyOnly ? ExprResult()\n                    : InitSeq.Perform(SemaRef, Entity, Kind, SubInit);\n}\n\nvoid InitListChecker::CheckEmptyInitializable(const InitializedEntity &Entity,\n                                              SourceLocation Loc) {\n  // If we're building a fully-structured list, we'll check this at the end\n  // once we know which elements are actually initialized. Otherwise, we know\n  // that there are no designators so we can just check now.\n  if (FullyStructuredList)\n    return;\n  PerformEmptyInit(Loc, Entity);\n}\n\nvoid InitListChecker::FillInEmptyInitForBase(\n    unsigned Init, const CXXBaseSpecifier &Base,\n    const InitializedEntity &ParentEntity, InitListExpr *ILE,\n    bool &RequiresSecondPass, bool FillWithNoInit) {\n  InitializedEntity BaseEntity = InitializedEntity::InitializeBase(\n      SemaRef.Context, &Base, false, &ParentEntity);\n\n  if (Init >= ILE->getNumInits() || !ILE->getInit(Init)) {\n    ExprResult BaseInit = FillWithNoInit\n                              ? new (SemaRef.Context) NoInitExpr(Base.getType())\n                              : PerformEmptyInit(ILE->getEndLoc(), BaseEntity);\n    if (BaseInit.isInvalid()) {\n      hadError = true;\n      return;\n    }\n\n    if (!VerifyOnly) {\n      assert(Init < ILE->getNumInits() && \"should have been expanded\");\n      ILE->setInit(Init, BaseInit.getAs<Expr>());\n    }\n  } else if (InitListExpr *InnerILE =\n                 dyn_cast<InitListExpr>(ILE->getInit(Init))) {\n    FillInEmptyInitializations(BaseEntity, InnerILE, RequiresSecondPass,\n                               ILE, Init, FillWithNoInit);\n  } else if (DesignatedInitUpdateExpr *InnerDIUE =\n               dyn_cast<DesignatedInitUpdateExpr>(ILE->getInit(Init))) {\n    FillInEmptyInitializations(BaseEntity, InnerDIUE->getUpdater(),\n                               RequiresSecondPass, ILE, Init,\n                               /*FillWithNoInit =*/true);\n  }\n}\n\nvoid InitListChecker::FillInEmptyInitForField(unsigned Init, FieldDecl *Field,\n                                        const InitializedEntity &ParentEntity,\n                                              InitListExpr *ILE,\n                                              bool &RequiresSecondPass,\n                                              bool FillWithNoInit) {\n  SourceLocation Loc = ILE->getEndLoc();\n  unsigned NumInits = ILE->getNumInits();\n  InitializedEntity MemberEntity\n    = InitializedEntity::InitializeMember(Field, &ParentEntity);\n\n  if (Init >= NumInits || !ILE->getInit(Init)) {\n    if (const RecordType *RType = ILE->getType()->getAs<RecordType>())\n      if (!RType->getDecl()->isUnion())\n        assert((Init < NumInits || VerifyOnly) &&\n               \"This ILE should have been expanded\");\n\n    if (FillWithNoInit) {\n      assert(!VerifyOnly && \"should not fill with no-init in verify-only mode\");\n      Expr *Filler = new (SemaRef.Context) NoInitExpr(Field->getType());\n      if (Init < NumInits)\n        ILE->setInit(Init, Filler);\n      else\n        ILE->updateInit(SemaRef.Context, Init, Filler);\n      return;\n    }\n    // C++1y [dcl.init.aggr]p7:\n    //   If there are fewer initializer-clauses in the list than there are\n    //   members in the aggregate, then each member not explicitly initialized\n    //   shall be initialized from its brace-or-equal-initializer [...]\n    if (Field->hasInClassInitializer()) {\n      if (VerifyOnly)\n        return;\n\n      ExprResult DIE = SemaRef.BuildCXXDefaultInitExpr(Loc, Field);\n      if (DIE.isInvalid()) {\n        hadError = true;\n        return;\n      }\n      SemaRef.checkInitializerLifetime(MemberEntity, DIE.get());\n      if (Init < NumInits)\n        ILE->setInit(Init, DIE.get());\n      else {\n        ILE->updateInit(SemaRef.Context, Init, DIE.get());\n        RequiresSecondPass = true;\n      }\n      return;\n    }\n\n    if (Field->getType()->isReferenceType()) {\n      if (!VerifyOnly) {\n        // C++ [dcl.init.aggr]p9:\n        //   If an incomplete or empty initializer-list leaves a\n        //   member of reference type uninitialized, the program is\n        //   ill-formed.\n        SemaRef.Diag(Loc, diag::err_init_reference_member_uninitialized)\n          << Field->getType()\n          << ILE->getSyntacticForm()->getSourceRange();\n        SemaRef.Diag(Field->getLocation(),\n                     diag::note_uninit_reference_member);\n      }\n      hadError = true;\n      return;\n    }\n\n    ExprResult MemberInit = PerformEmptyInit(Loc, MemberEntity);\n    if (MemberInit.isInvalid()) {\n      hadError = true;\n      return;\n    }\n\n    if (hadError || VerifyOnly) {\n      // Do nothing\n    } else if (Init < NumInits) {\n      ILE->setInit(Init, MemberInit.getAs<Expr>());\n    } else if (!isa<ImplicitValueInitExpr>(MemberInit.get())) {\n      // Empty initialization requires a constructor call, so\n      // extend the initializer list to include the constructor\n      // call and make a note that we'll need to take another pass\n      // through the initializer list.\n      ILE->updateInit(SemaRef.Context, Init, MemberInit.getAs<Expr>());\n      RequiresSecondPass = true;\n    }\n  } else if (InitListExpr *InnerILE\n               = dyn_cast<InitListExpr>(ILE->getInit(Init))) {\n    FillInEmptyInitializations(MemberEntity, InnerILE,\n                               RequiresSecondPass, ILE, Init, FillWithNoInit);\n  } else if (DesignatedInitUpdateExpr *InnerDIUE =\n                 dyn_cast<DesignatedInitUpdateExpr>(ILE->getInit(Init))) {\n    FillInEmptyInitializations(MemberEntity, InnerDIUE->getUpdater(),\n                               RequiresSecondPass, ILE, Init,\n                               /*FillWithNoInit =*/true);\n  }\n}\n\n/// Recursively replaces NULL values within the given initializer list\n/// with expressions that perform value-initialization of the\n/// appropriate type, and finish off the InitListExpr formation.\nvoid\nInitListChecker::FillInEmptyInitializations(const InitializedEntity &Entity,\n                                            InitListExpr *ILE,\n                                            bool &RequiresSecondPass,\n                                            InitListExpr *OuterILE,\n                                            unsigned OuterIndex,\n                                            bool FillWithNoInit) {\n  assert((ILE->getType() != SemaRef.Context.VoidTy) &&\n         \"Should not have void type\");\n\n  // We don't need to do any checks when just filling NoInitExprs; that can't\n  // fail.\n  if (FillWithNoInit && VerifyOnly)\n    return;\n\n  // If this is a nested initializer list, we might have changed its contents\n  // (and therefore some of its properties, such as instantiation-dependence)\n  // while filling it in. Inform the outer initializer list so that its state\n  // can be updated to match.\n  // FIXME: We should fully build the inner initializers before constructing\n  // the outer InitListExpr instead of mutating AST nodes after they have\n  // been used as subexpressions of other nodes.\n  struct UpdateOuterILEWithUpdatedInit {\n    InitListExpr *Outer;\n    unsigned OuterIndex;\n    ~UpdateOuterILEWithUpdatedInit() {\n      if (Outer)\n        Outer->setInit(OuterIndex, Outer->getInit(OuterIndex));\n    }\n  } UpdateOuterRAII = {OuterILE, OuterIndex};\n\n  // A transparent ILE is not performing aggregate initialization and should\n  // not be filled in.\n  if (ILE->isTransparent())\n    return;\n\n  if (const RecordType *RType = ILE->getType()->getAs<RecordType>()) {\n    const RecordDecl *RDecl = RType->getDecl();\n    if (RDecl->isUnion() && ILE->getInitializedFieldInUnion())\n      FillInEmptyInitForField(0, ILE->getInitializedFieldInUnion(),\n                              Entity, ILE, RequiresSecondPass, FillWithNoInit);\n    else if (RDecl->isUnion() && isa<CXXRecordDecl>(RDecl) &&\n             cast<CXXRecordDecl>(RDecl)->hasInClassInitializer()) {\n      for (auto *Field : RDecl->fields()) {\n        if (Field->hasInClassInitializer()) {\n          FillInEmptyInitForField(0, Field, Entity, ILE, RequiresSecondPass,\n                                  FillWithNoInit);\n          break;\n        }\n      }\n    } else {\n      // The fields beyond ILE->getNumInits() are default initialized, so in\n      // order to leave them uninitialized, the ILE is expanded and the extra\n      // fields are then filled with NoInitExpr.\n      unsigned NumElems = numStructUnionElements(ILE->getType());\n      if (RDecl->hasFlexibleArrayMember())\n        ++NumElems;\n      if (!VerifyOnly && ILE->getNumInits() < NumElems)\n        ILE->resizeInits(SemaRef.Context, NumElems);\n\n      unsigned Init = 0;\n\n      if (auto *CXXRD = dyn_cast<CXXRecordDecl>(RDecl)) {\n        for (auto &Base : CXXRD->bases()) {\n          if (hadError)\n            return;\n\n          FillInEmptyInitForBase(Init, Base, Entity, ILE, RequiresSecondPass,\n                                 FillWithNoInit);\n          ++Init;\n        }\n      }\n\n      for (auto *Field : RDecl->fields()) {\n        if (Field->isUnnamedBitfield())\n          continue;\n\n        if (hadError)\n          return;\n\n        FillInEmptyInitForField(Init, Field, Entity, ILE, RequiresSecondPass,\n                                FillWithNoInit);\n        if (hadError)\n          return;\n\n        ++Init;\n\n        // Only look at the first initialization of a union.\n        if (RDecl->isUnion())\n          break;\n      }\n    }\n\n    return;\n  }\n\n  QualType ElementType;\n\n  InitializedEntity ElementEntity = Entity;\n  unsigned NumInits = ILE->getNumInits();\n  unsigned NumElements = NumInits;\n  if (const ArrayType *AType = SemaRef.Context.getAsArrayType(ILE->getType())) {\n    ElementType = AType->getElementType();\n    if (const auto *CAType = dyn_cast<ConstantArrayType>(AType))\n      NumElements = CAType->getSize().getZExtValue();\n    // For an array new with an unknown bound, ask for one additional element\n    // in order to populate the array filler.\n    if (Entity.isVariableLengthArrayNew())\n      ++NumElements;\n    ElementEntity = InitializedEntity::InitializeElement(SemaRef.Context,\n                                                         0, Entity);\n  } else if (const VectorType *VType = ILE->getType()->getAs<VectorType>()) {\n    ElementType = VType->getElementType();\n    NumElements = VType->getNumElements();\n    ElementEntity = InitializedEntity::InitializeElement(SemaRef.Context,\n                                                         0, Entity);\n  } else\n    ElementType = ILE->getType();\n\n  bool SkipEmptyInitChecks = false;\n  for (unsigned Init = 0; Init != NumElements; ++Init) {\n    if (hadError)\n      return;\n\n    if (ElementEntity.getKind() == InitializedEntity::EK_ArrayElement ||\n        ElementEntity.getKind() == InitializedEntity::EK_VectorElement)\n      ElementEntity.setElementIndex(Init);\n\n    if (Init >= NumInits && (ILE->hasArrayFiller() || SkipEmptyInitChecks))\n      return;\n\n    Expr *InitExpr = (Init < NumInits ? ILE->getInit(Init) : nullptr);\n    if (!InitExpr && Init < NumInits && ILE->hasArrayFiller())\n      ILE->setInit(Init, ILE->getArrayFiller());\n    else if (!InitExpr && !ILE->hasArrayFiller()) {\n      // In VerifyOnly mode, there's no point performing empty initialization\n      // more than once.\n      if (SkipEmptyInitChecks)\n        continue;\n\n      Expr *Filler = nullptr;\n\n      if (FillWithNoInit)\n        Filler = new (SemaRef.Context) NoInitExpr(ElementType);\n      else {\n        ExprResult ElementInit =\n            PerformEmptyInit(ILE->getEndLoc(), ElementEntity);\n        if (ElementInit.isInvalid()) {\n          hadError = true;\n          return;\n        }\n\n        Filler = ElementInit.getAs<Expr>();\n      }\n\n      if (hadError) {\n        // Do nothing\n      } else if (VerifyOnly) {\n        SkipEmptyInitChecks = true;\n      } else if (Init < NumInits) {\n        // For arrays, just set the expression used for value-initialization\n        // of the \"holes\" in the array.\n        if (ElementEntity.getKind() == InitializedEntity::EK_ArrayElement)\n          ILE->setArrayFiller(Filler);\n        else\n          ILE->setInit(Init, Filler);\n      } else {\n        // For arrays, just set the expression used for value-initialization\n        // of the rest of elements and exit.\n        if (ElementEntity.getKind() == InitializedEntity::EK_ArrayElement) {\n          ILE->setArrayFiller(Filler);\n          return;\n        }\n\n        if (!isa<ImplicitValueInitExpr>(Filler) && !isa<NoInitExpr>(Filler)) {\n          // Empty initialization requires a constructor call, so\n          // extend the initializer list to include the constructor\n          // call and make a note that we'll need to take another pass\n          // through the initializer list.\n          ILE->updateInit(SemaRef.Context, Init, Filler);\n          RequiresSecondPass = true;\n        }\n      }\n    } else if (InitListExpr *InnerILE\n                 = dyn_cast_or_null<InitListExpr>(InitExpr)) {\n      FillInEmptyInitializations(ElementEntity, InnerILE, RequiresSecondPass,\n                                 ILE, Init, FillWithNoInit);\n    } else if (DesignatedInitUpdateExpr *InnerDIUE =\n                   dyn_cast_or_null<DesignatedInitUpdateExpr>(InitExpr)) {\n      FillInEmptyInitializations(ElementEntity, InnerDIUE->getUpdater(),\n                                 RequiresSecondPass, ILE, Init,\n                                 /*FillWithNoInit =*/true);\n    }\n  }\n}\n\nstatic bool hasAnyDesignatedInits(const InitListExpr *IL) {\n  for (const Stmt *Init : *IL)\n    if (Init && isa<DesignatedInitExpr>(Init))\n      return true;\n  return false;\n}\n\nInitListChecker::InitListChecker(Sema &S, const InitializedEntity &Entity,\n                                 InitListExpr *IL, QualType &T, bool VerifyOnly,\n                                 bool TreatUnavailableAsInvalid,\n                                 bool InOverloadResolution)\n    : SemaRef(S), VerifyOnly(VerifyOnly),\n      TreatUnavailableAsInvalid(TreatUnavailableAsInvalid),\n      InOverloadResolution(InOverloadResolution) {\n  if (!VerifyOnly || hasAnyDesignatedInits(IL)) {\n    FullyStructuredList =\n        createInitListExpr(T, IL->getSourceRange(), IL->getNumInits());\n\n    // FIXME: Check that IL isn't already the semantic form of some other\n    // InitListExpr. If it is, we'd create a broken AST.\n    if (!VerifyOnly)\n      FullyStructuredList->setSyntacticForm(IL);\n  }\n\n  CheckExplicitInitList(Entity, IL, T, FullyStructuredList,\n                        /*TopLevelObject=*/true);\n\n  if (!hadError && FullyStructuredList) {\n    bool RequiresSecondPass = false;\n    FillInEmptyInitializations(Entity, FullyStructuredList, RequiresSecondPass,\n                               /*OuterILE=*/nullptr, /*OuterIndex=*/0);\n    if (RequiresSecondPass && !hadError)\n      FillInEmptyInitializations(Entity, FullyStructuredList,\n                                 RequiresSecondPass, nullptr, 0);\n  }\n  if (hadError && FullyStructuredList)\n    FullyStructuredList->markError();\n}\n\nint InitListChecker::numArrayElements(QualType DeclType) {\n  // FIXME: use a proper constant\n  int maxElements = 0x7FFFFFFF;\n  if (const ConstantArrayType *CAT =\n        SemaRef.Context.getAsConstantArrayType(DeclType)) {\n    maxElements = static_cast<int>(CAT->getSize().getZExtValue());\n  }\n  return maxElements;\n}\n\nint InitListChecker::numStructUnionElements(QualType DeclType) {\n  RecordDecl *structDecl = DeclType->castAs<RecordType>()->getDecl();\n  int InitializableMembers = 0;\n  if (auto *CXXRD = dyn_cast<CXXRecordDecl>(structDecl))\n    InitializableMembers += CXXRD->getNumBases();\n  for (const auto *Field : structDecl->fields())\n    if (!Field->isUnnamedBitfield())\n      ++InitializableMembers;\n\n  if (structDecl->isUnion())\n    return std::min(InitializableMembers, 1);\n  return InitializableMembers - structDecl->hasFlexibleArrayMember();\n}\n\n/// Determine whether Entity is an entity for which it is idiomatic to elide\n/// the braces in aggregate initialization.\nstatic bool isIdiomaticBraceElisionEntity(const InitializedEntity &Entity) {\n  // Recursive initialization of the one and only field within an aggregate\n  // class is considered idiomatic. This case arises in particular for\n  // initialization of std::array, where the C++ standard suggests the idiom of\n  //\n  //   std::array<T, N> arr = {1, 2, 3};\n  //\n  // (where std::array is an aggregate struct containing a single array field.\n\n  // FIXME: Should aggregate initialization of a struct with a single\n  // base class and no members also suppress the warning?\n  if (Entity.getKind() != InitializedEntity::EK_Member || !Entity.getParent())\n    return false;\n\n  auto *ParentRD =\n      Entity.getParent()->getType()->castAs<RecordType>()->getDecl();\n  if (CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(ParentRD))\n    if (CXXRD->getNumBases())\n      return false;\n\n  auto FieldIt = ParentRD->field_begin();\n  assert(FieldIt != ParentRD->field_end() &&\n         \"no fields but have initializer for member?\");\n  return ++FieldIt == ParentRD->field_end();\n}\n\n/// Check whether the range of the initializer \\p ParentIList from element\n/// \\p Index onwards can be used to initialize an object of type \\p T. Update\n/// \\p Index to indicate how many elements of the list were consumed.\n///\n/// This also fills in \\p StructuredList, from element \\p StructuredIndex\n/// onwards, with the fully-braced, desugared form of the initialization.\nvoid InitListChecker::CheckImplicitInitList(const InitializedEntity &Entity,\n                                            InitListExpr *ParentIList,\n                                            QualType T, unsigned &Index,\n                                            InitListExpr *StructuredList,\n                                            unsigned &StructuredIndex) {\n  int maxElements = 0;\n\n  if (T->isArrayType())\n    maxElements = numArrayElements(T);\n  else if (T->isRecordType())\n    maxElements = numStructUnionElements(T);\n  else if (T->isVectorType())\n    maxElements = T->castAs<VectorType>()->getNumElements();\n  else\n    llvm_unreachable(\"CheckImplicitInitList(): Illegal type\");\n\n  if (maxElements == 0) {\n    if (!VerifyOnly)\n      SemaRef.Diag(ParentIList->getInit(Index)->getBeginLoc(),\n                   diag::err_implicit_empty_initializer);\n    ++Index;\n    hadError = true;\n    return;\n  }\n\n  // Build a structured initializer list corresponding to this subobject.\n  InitListExpr *StructuredSubobjectInitList = getStructuredSubobjectInit(\n      ParentIList, Index, T, StructuredList, StructuredIndex,\n      SourceRange(ParentIList->getInit(Index)->getBeginLoc(),\n                  ParentIList->getSourceRange().getEnd()));\n  unsigned StructuredSubobjectInitIndex = 0;\n\n  // Check the element types and build the structural subobject.\n  unsigned StartIndex = Index;\n  CheckListElementTypes(Entity, ParentIList, T,\n                        /*SubobjectIsDesignatorContext=*/false, Index,\n                        StructuredSubobjectInitList,\n                        StructuredSubobjectInitIndex);\n\n  if (StructuredSubobjectInitList) {\n    StructuredSubobjectInitList->setType(T);\n\n    unsigned EndIndex = (Index == StartIndex? StartIndex : Index - 1);\n    // Update the structured sub-object initializer so that it's ending\n    // range corresponds with the end of the last initializer it used.\n    if (EndIndex < ParentIList->getNumInits() &&\n        ParentIList->getInit(EndIndex)) {\n      SourceLocation EndLoc\n        = ParentIList->getInit(EndIndex)->getSourceRange().getEnd();\n      StructuredSubobjectInitList->setRBraceLoc(EndLoc);\n    }\n\n    // Complain about missing braces.\n    if (!VerifyOnly && (T->isArrayType() || T->isRecordType()) &&\n        !ParentIList->isIdiomaticZeroInitializer(SemaRef.getLangOpts()) &&\n        !isIdiomaticBraceElisionEntity(Entity)) {\n      SemaRef.Diag(StructuredSubobjectInitList->getBeginLoc(),\n                   diag::warn_missing_braces)\n          << StructuredSubobjectInitList->getSourceRange()\n          << FixItHint::CreateInsertion(\n                 StructuredSubobjectInitList->getBeginLoc(), \"{\")\n          << FixItHint::CreateInsertion(\n                 SemaRef.getLocForEndOfToken(\n                     StructuredSubobjectInitList->getEndLoc()),\n                 \"}\");\n    }\n\n    // Warn if this type won't be an aggregate in future versions of C++.\n    auto *CXXRD = T->getAsCXXRecordDecl();\n    if (!VerifyOnly && CXXRD && CXXRD->hasUserDeclaredConstructor()) {\n      SemaRef.Diag(StructuredSubobjectInitList->getBeginLoc(),\n                   diag::warn_cxx20_compat_aggregate_init_with_ctors)\n          << StructuredSubobjectInitList->getSourceRange() << T;\n    }\n  }\n}\n\n/// Warn that \\p Entity was of scalar type and was initialized by a\n/// single-element braced initializer list.\nstatic void warnBracedScalarInit(Sema &S, const InitializedEntity &Entity,\n                                 SourceRange Braces) {\n  // Don't warn during template instantiation. If the initialization was\n  // non-dependent, we warned during the initial parse; otherwise, the\n  // type might not be scalar in some uses of the template.\n  if (S.inTemplateInstantiation())\n    return;\n\n  unsigned DiagID = 0;\n\n  switch (Entity.getKind()) {\n  case InitializedEntity::EK_VectorElement:\n  case InitializedEntity::EK_ComplexElement:\n  case InitializedEntity::EK_ArrayElement:\n  case InitializedEntity::EK_Parameter:\n  case InitializedEntity::EK_Parameter_CF_Audited:\n  case InitializedEntity::EK_TemplateParameter:\n  case InitializedEntity::EK_Result:\n    // Extra braces here are suspicious.\n    DiagID = diag::warn_braces_around_init;\n    break;\n\n  case InitializedEntity::EK_Member:\n    // Warn on aggregate initialization but not on ctor init list or\n    // default member initializer.\n    if (Entity.getParent())\n      DiagID = diag::warn_braces_around_init;\n    break;\n\n  case InitializedEntity::EK_Variable:\n  case InitializedEntity::EK_LambdaCapture:\n    // No warning, might be direct-list-initialization.\n    // FIXME: Should we warn for copy-list-initialization in these cases?\n    break;\n\n  case InitializedEntity::EK_New:\n  case InitializedEntity::EK_Temporary:\n  case InitializedEntity::EK_CompoundLiteralInit:\n    // No warning, braces are part of the syntax of the underlying construct.\n    break;\n\n  case InitializedEntity::EK_RelatedResult:\n    // No warning, we already warned when initializing the result.\n    break;\n\n  case InitializedEntity::EK_Exception:\n  case InitializedEntity::EK_Base:\n  case InitializedEntity::EK_Delegating:\n  case InitializedEntity::EK_BlockElement:\n  case InitializedEntity::EK_LambdaToBlockConversionBlockElement:\n  case InitializedEntity::EK_Binding:\n  case InitializedEntity::EK_StmtExprResult:\n    llvm_unreachable(\"unexpected braced scalar init\");\n  }\n\n  if (DiagID) {\n    S.Diag(Braces.getBegin(), DiagID)\n        << Entity.getType()->isSizelessBuiltinType() << Braces\n        << FixItHint::CreateRemoval(Braces.getBegin())\n        << FixItHint::CreateRemoval(Braces.getEnd());\n  }\n}\n\n/// Check whether the initializer \\p IList (that was written with explicit\n/// braces) can be used to initialize an object of type \\p T.\n///\n/// This also fills in \\p StructuredList with the fully-braced, desugared\n/// form of the initialization.\nvoid InitListChecker::CheckExplicitInitList(const InitializedEntity &Entity,\n                                            InitListExpr *IList, QualType &T,\n                                            InitListExpr *StructuredList,\n                                            bool TopLevelObject) {\n  unsigned Index = 0, StructuredIndex = 0;\n  CheckListElementTypes(Entity, IList, T, /*SubobjectIsDesignatorContext=*/true,\n                        Index, StructuredList, StructuredIndex, TopLevelObject);\n  if (StructuredList) {\n    QualType ExprTy = T;\n    if (!ExprTy->isArrayType())\n      ExprTy = ExprTy.getNonLValueExprType(SemaRef.Context);\n    if (!VerifyOnly)\n      IList->setType(ExprTy);\n    StructuredList->setType(ExprTy);\n  }\n  if (hadError)\n    return;\n\n  // Don't complain for incomplete types, since we'll get an error elsewhere.\n  if (Index < IList->getNumInits() && !T->isIncompleteType()) {\n    // We have leftover initializers\n    bool ExtraInitsIsError = SemaRef.getLangOpts().CPlusPlus ||\n          (SemaRef.getLangOpts().OpenCL && T->isVectorType());\n    hadError = ExtraInitsIsError;\n    if (VerifyOnly) {\n      return;\n    } else if (StructuredIndex == 1 &&\n               IsStringInit(StructuredList->getInit(0), T, SemaRef.Context) ==\n                   SIF_None) {\n      unsigned DK =\n          ExtraInitsIsError\n              ? diag::err_excess_initializers_in_char_array_initializer\n              : diag::ext_excess_initializers_in_char_array_initializer;\n      SemaRef.Diag(IList->getInit(Index)->getBeginLoc(), DK)\n          << IList->getInit(Index)->getSourceRange();\n    } else if (T->isSizelessBuiltinType()) {\n      unsigned DK = ExtraInitsIsError\n                        ? diag::err_excess_initializers_for_sizeless_type\n                        : diag::ext_excess_initializers_for_sizeless_type;\n      SemaRef.Diag(IList->getInit(Index)->getBeginLoc(), DK)\n          << T << IList->getInit(Index)->getSourceRange();\n    } else {\n      int initKind = T->isArrayType() ? 0 :\n                     T->isVectorType() ? 1 :\n                     T->isScalarType() ? 2 :\n                     T->isUnionType() ? 3 :\n                     4;\n\n      unsigned DK = ExtraInitsIsError ? diag::err_excess_initializers\n                                      : diag::ext_excess_initializers;\n      SemaRef.Diag(IList->getInit(Index)->getBeginLoc(), DK)\n          << initKind << IList->getInit(Index)->getSourceRange();\n    }\n  }\n\n  if (!VerifyOnly) {\n    if (T->isScalarType() && IList->getNumInits() == 1 &&\n        !isa<InitListExpr>(IList->getInit(0)))\n      warnBracedScalarInit(SemaRef, Entity, IList->getSourceRange());\n\n    // Warn if this is a class type that won't be an aggregate in future\n    // versions of C++.\n    auto *CXXRD = T->getAsCXXRecordDecl();\n    if (CXXRD && CXXRD->hasUserDeclaredConstructor()) {\n      // Don't warn if there's an equivalent default constructor that would be\n      // used instead.\n      bool HasEquivCtor = false;\n      if (IList->getNumInits() == 0) {\n        auto *CD = SemaRef.LookupDefaultConstructor(CXXRD);\n        HasEquivCtor = CD && !CD->isDeleted();\n      }\n\n      if (!HasEquivCtor) {\n        SemaRef.Diag(IList->getBeginLoc(),\n                     diag::warn_cxx20_compat_aggregate_init_with_ctors)\n            << IList->getSourceRange() << T;\n      }\n    }\n  }\n}\n\nvoid InitListChecker::CheckListElementTypes(const InitializedEntity &Entity,\n                                            InitListExpr *IList,\n                                            QualType &DeclType,\n                                            bool SubobjectIsDesignatorContext,\n                                            unsigned &Index,\n                                            InitListExpr *StructuredList,\n                                            unsigned &StructuredIndex,\n                                            bool TopLevelObject) {\n  if (DeclType->isAnyComplexType() && SubobjectIsDesignatorContext) {\n    // Explicitly braced initializer for complex type can be real+imaginary\n    // parts.\n    CheckComplexType(Entity, IList, DeclType, Index,\n                     StructuredList, StructuredIndex);\n  } else if (DeclType->isScalarType()) {\n    CheckScalarType(Entity, IList, DeclType, Index,\n                    StructuredList, StructuredIndex);\n  } else if (DeclType->isVectorType()) {\n    CheckVectorType(Entity, IList, DeclType, Index,\n                    StructuredList, StructuredIndex);\n  } else if (DeclType->isRecordType()) {\n    assert(DeclType->isAggregateType() &&\n           \"non-aggregate records should be handed in CheckSubElementType\");\n    RecordDecl *RD = DeclType->castAs<RecordType>()->getDecl();\n    auto Bases =\n        CXXRecordDecl::base_class_range(CXXRecordDecl::base_class_iterator(),\n                                        CXXRecordDecl::base_class_iterator());\n    if (auto *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n      Bases = CXXRD->bases();\n    CheckStructUnionTypes(Entity, IList, DeclType, Bases, RD->field_begin(),\n                          SubobjectIsDesignatorContext, Index, StructuredList,\n                          StructuredIndex, TopLevelObject);\n  } else if (DeclType->isArrayType()) {\n    llvm::APSInt Zero(\n                    SemaRef.Context.getTypeSize(SemaRef.Context.getSizeType()),\n                    false);\n    CheckArrayType(Entity, IList, DeclType, Zero,\n                   SubobjectIsDesignatorContext, Index,\n                   StructuredList, StructuredIndex);\n  } else if (DeclType->isVoidType() || DeclType->isFunctionType()) {\n    // This type is invalid, issue a diagnostic.\n    ++Index;\n    if (!VerifyOnly)\n      SemaRef.Diag(IList->getBeginLoc(), diag::err_illegal_initializer_type)\n          << DeclType;\n    hadError = true;\n  } else if (DeclType->isReferenceType()) {\n    CheckReferenceType(Entity, IList, DeclType, Index,\n                       StructuredList, StructuredIndex);\n  } else if (DeclType->isObjCObjectType()) {\n    if (!VerifyOnly)\n      SemaRef.Diag(IList->getBeginLoc(), diag::err_init_objc_class) << DeclType;\n    hadError = true;\n  } else if (DeclType->isOCLIntelSubgroupAVCType() ||\n             DeclType->isSizelessBuiltinType()) {\n    // Checks for scalar type are sufficient for these types too.\n    CheckScalarType(Entity, IList, DeclType, Index, StructuredList,\n                    StructuredIndex);\n  } else {\n    if (!VerifyOnly)\n      SemaRef.Diag(IList->getBeginLoc(), diag::err_illegal_initializer_type)\n          << DeclType;\n    hadError = true;\n  }\n}\n\nvoid InitListChecker::CheckSubElementType(const InitializedEntity &Entity,\n                                          InitListExpr *IList,\n                                          QualType ElemType,\n                                          unsigned &Index,\n                                          InitListExpr *StructuredList,\n                                          unsigned &StructuredIndex,\n                                          bool DirectlyDesignated) {\n  Expr *expr = IList->getInit(Index);\n\n  if (ElemType->isReferenceType())\n    return CheckReferenceType(Entity, IList, ElemType, Index,\n                              StructuredList, StructuredIndex);\n\n  if (InitListExpr *SubInitList = dyn_cast<InitListExpr>(expr)) {\n    if (SubInitList->getNumInits() == 1 &&\n        IsStringInit(SubInitList->getInit(0), ElemType, SemaRef.Context) ==\n        SIF_None) {\n      // FIXME: It would be more faithful and no less correct to include an\n      // InitListExpr in the semantic form of the initializer list in this case.\n      expr = SubInitList->getInit(0);\n    }\n    // Nested aggregate initialization and C++ initialization are handled later.\n  } else if (isa<ImplicitValueInitExpr>(expr)) {\n    // This happens during template instantiation when we see an InitListExpr\n    // that we've already checked once.\n    assert(SemaRef.Context.hasSameType(expr->getType(), ElemType) &&\n           \"found implicit initialization for the wrong type\");\n    UpdateStructuredListElement(StructuredList, StructuredIndex, expr);\n    ++Index;\n    return;\n  }\n\n  if (SemaRef.getLangOpts().CPlusPlus || isa<InitListExpr>(expr)) {\n    // C++ [dcl.init.aggr]p2:\n    //   Each member is copy-initialized from the corresponding\n    //   initializer-clause.\n\n    // FIXME: Better EqualLoc?\n    InitializationKind Kind =\n        InitializationKind::CreateCopy(expr->getBeginLoc(), SourceLocation());\n\n    // Vector elements can be initialized from other vectors in which case\n    // we need initialization entity with a type of a vector (and not a vector\n    // element!) initializing multiple vector elements.\n    auto TmpEntity =\n        (ElemType->isExtVectorType() && !Entity.getType()->isExtVectorType())\n            ? InitializedEntity::InitializeTemporary(ElemType)\n            : Entity;\n\n    InitializationSequence Seq(SemaRef, TmpEntity, Kind, expr,\n                               /*TopLevelOfInitList*/ true);\n\n    // C++14 [dcl.init.aggr]p13:\n    //   If the assignment-expression can initialize a member, the member is\n    //   initialized. Otherwise [...] brace elision is assumed\n    //\n    // Brace elision is never performed if the element is not an\n    // assignment-expression.\n    if (Seq || isa<InitListExpr>(expr)) {\n      if (!VerifyOnly) {\n        ExprResult Result = Seq.Perform(SemaRef, TmpEntity, Kind, expr);\n        if (Result.isInvalid())\n          hadError = true;\n\n        UpdateStructuredListElement(StructuredList, StructuredIndex,\n                                    Result.getAs<Expr>());\n      } else if (!Seq) {\n        hadError = true;\n      } else if (StructuredList) {\n        UpdateStructuredListElement(StructuredList, StructuredIndex,\n                                    getDummyInit());\n      }\n      ++Index;\n      return;\n    }\n\n    // Fall through for subaggregate initialization\n  } else if (ElemType->isScalarType() || ElemType->isAtomicType()) {\n    // FIXME: Need to handle atomic aggregate types with implicit init lists.\n    return CheckScalarType(Entity, IList, ElemType, Index,\n                           StructuredList, StructuredIndex);\n  } else if (const ArrayType *arrayType =\n                 SemaRef.Context.getAsArrayType(ElemType)) {\n    // arrayType can be incomplete if we're initializing a flexible\n    // array member.  There's nothing we can do with the completed\n    // type here, though.\n\n    if (IsStringInit(expr, arrayType, SemaRef.Context) == SIF_None) {\n      // FIXME: Should we do this checking in verify-only mode?\n      if (!VerifyOnly)\n        CheckStringInit(expr, ElemType, arrayType, SemaRef);\n      if (StructuredList)\n        UpdateStructuredListElement(StructuredList, StructuredIndex, expr);\n      ++Index;\n      return;\n    }\n\n    // Fall through for subaggregate initialization.\n\n  } else {\n    assert((ElemType->isRecordType() || ElemType->isVectorType() ||\n            ElemType->isOpenCLSpecificType()) && \"Unexpected type\");\n\n    // C99 6.7.8p13:\n    //\n    //   The initializer for a structure or union object that has\n    //   automatic storage duration shall be either an initializer\n    //   list as described below, or a single expression that has\n    //   compatible structure or union type. In the latter case, the\n    //   initial value of the object, including unnamed members, is\n    //   that of the expression.\n    ExprResult ExprRes = expr;\n    if (SemaRef.CheckSingleAssignmentConstraints(\n            ElemType, ExprRes, !VerifyOnly) != Sema::Incompatible) {\n      if (ExprRes.isInvalid())\n        hadError = true;\n      else {\n        ExprRes = SemaRef.DefaultFunctionArrayLvalueConversion(ExprRes.get());\n        if (ExprRes.isInvalid())\n          hadError = true;\n      }\n      UpdateStructuredListElement(StructuredList, StructuredIndex,\n                                  ExprRes.getAs<Expr>());\n      ++Index;\n      return;\n    }\n    ExprRes.get();\n    // Fall through for subaggregate initialization\n  }\n\n  // C++ [dcl.init.aggr]p12:\n  //\n  //   [...] Otherwise, if the member is itself a non-empty\n  //   subaggregate, brace elision is assumed and the initializer is\n  //   considered for the initialization of the first member of\n  //   the subaggregate.\n  // OpenCL vector initializer is handled elsewhere.\n  if ((!SemaRef.getLangOpts().OpenCL && ElemType->isVectorType()) ||\n      ElemType->isAggregateType()) {\n    CheckImplicitInitList(Entity, IList, ElemType, Index, StructuredList,\n                          StructuredIndex);\n    ++StructuredIndex;\n\n    // In C++20, brace elision is not permitted for a designated initializer.\n    if (DirectlyDesignated && SemaRef.getLangOpts().CPlusPlus && !hadError) {\n      if (InOverloadResolution)\n        hadError = true;\n      if (!VerifyOnly) {\n        SemaRef.Diag(expr->getBeginLoc(),\n                     diag::ext_designated_init_brace_elision)\n            << expr->getSourceRange()\n            << FixItHint::CreateInsertion(expr->getBeginLoc(), \"{\")\n            << FixItHint::CreateInsertion(\n                   SemaRef.getLocForEndOfToken(expr->getEndLoc()), \"}\");\n      }\n    }\n  } else {\n    if (!VerifyOnly) {\n      // We cannot initialize this element, so let PerformCopyInitialization\n      // produce the appropriate diagnostic. We already checked that this\n      // initialization will fail.\n      ExprResult Copy =\n          SemaRef.PerformCopyInitialization(Entity, SourceLocation(), expr,\n                                            /*TopLevelOfInitList=*/true);\n      (void)Copy;\n      assert(Copy.isInvalid() &&\n             \"expected non-aggregate initialization to fail\");\n    }\n    hadError = true;\n    ++Index;\n    ++StructuredIndex;\n  }\n}\n\nvoid InitListChecker::CheckComplexType(const InitializedEntity &Entity,\n                                       InitListExpr *IList, QualType DeclType,\n                                       unsigned &Index,\n                                       InitListExpr *StructuredList,\n                                       unsigned &StructuredIndex) {\n  assert(Index == 0 && \"Index in explicit init list must be zero\");\n\n  // As an extension, clang supports complex initializers, which initialize\n  // a complex number component-wise.  When an explicit initializer list for\n  // a complex number contains two two initializers, this extension kicks in:\n  // it exepcts the initializer list to contain two elements convertible to\n  // the element type of the complex type. The first element initializes\n  // the real part, and the second element intitializes the imaginary part.\n\n  if (IList->getNumInits() != 2)\n    return CheckScalarType(Entity, IList, DeclType, Index, StructuredList,\n                           StructuredIndex);\n\n  // This is an extension in C.  (The builtin _Complex type does not exist\n  // in the C++ standard.)\n  if (!SemaRef.getLangOpts().CPlusPlus && !VerifyOnly)\n    SemaRef.Diag(IList->getBeginLoc(), diag::ext_complex_component_init)\n        << IList->getSourceRange();\n\n  // Initialize the complex number.\n  QualType elementType = DeclType->castAs<ComplexType>()->getElementType();\n  InitializedEntity ElementEntity =\n    InitializedEntity::InitializeElement(SemaRef.Context, 0, Entity);\n\n  for (unsigned i = 0; i < 2; ++i) {\n    ElementEntity.setElementIndex(Index);\n    CheckSubElementType(ElementEntity, IList, elementType, Index,\n                        StructuredList, StructuredIndex);\n  }\n}\n\nvoid InitListChecker::CheckScalarType(const InitializedEntity &Entity,\n                                      InitListExpr *IList, QualType DeclType,\n                                      unsigned &Index,\n                                      InitListExpr *StructuredList,\n                                      unsigned &StructuredIndex) {\n  if (Index >= IList->getNumInits()) {\n    if (!VerifyOnly) {\n      if (DeclType->isSizelessBuiltinType())\n        SemaRef.Diag(IList->getBeginLoc(),\n                     SemaRef.getLangOpts().CPlusPlus11\n                         ? diag::warn_cxx98_compat_empty_sizeless_initializer\n                         : diag::err_empty_sizeless_initializer)\n            << DeclType << IList->getSourceRange();\n      else\n        SemaRef.Diag(IList->getBeginLoc(),\n                     SemaRef.getLangOpts().CPlusPlus11\n                         ? diag::warn_cxx98_compat_empty_scalar_initializer\n                         : diag::err_empty_scalar_initializer)\n            << IList->getSourceRange();\n    }\n    hadError = !SemaRef.getLangOpts().CPlusPlus11;\n    ++Index;\n    ++StructuredIndex;\n    return;\n  }\n\n  Expr *expr = IList->getInit(Index);\n  if (InitListExpr *SubIList = dyn_cast<InitListExpr>(expr)) {\n    // FIXME: This is invalid, and accepting it causes overload resolution\n    // to pick the wrong overload in some corner cases.\n    if (!VerifyOnly)\n      SemaRef.Diag(SubIList->getBeginLoc(), diag::ext_many_braces_around_init)\n          << DeclType->isSizelessBuiltinType() << SubIList->getSourceRange();\n\n    CheckScalarType(Entity, SubIList, DeclType, Index, StructuredList,\n                    StructuredIndex);\n    return;\n  } else if (isa<DesignatedInitExpr>(expr)) {\n    if (!VerifyOnly)\n      SemaRef.Diag(expr->getBeginLoc(),\n                   diag::err_designator_for_scalar_or_sizeless_init)\n          << DeclType->isSizelessBuiltinType() << DeclType\n          << expr->getSourceRange();\n    hadError = true;\n    ++Index;\n    ++StructuredIndex;\n    return;\n  }\n\n  ExprResult Result;\n  if (VerifyOnly) {\n    if (SemaRef.CanPerformCopyInitialization(Entity, expr))\n      Result = getDummyInit();\n    else\n      Result = ExprError();\n  } else {\n    Result =\n        SemaRef.PerformCopyInitialization(Entity, expr->getBeginLoc(), expr,\n                                          /*TopLevelOfInitList=*/true);\n  }\n\n  Expr *ResultExpr = nullptr;\n\n  if (Result.isInvalid())\n    hadError = true; // types weren't compatible.\n  else {\n    ResultExpr = Result.getAs<Expr>();\n\n    if (ResultExpr != expr && !VerifyOnly) {\n      // The type was promoted, update initializer list.\n      // FIXME: Why are we updating the syntactic init list?\n      IList->setInit(Index, ResultExpr);\n    }\n  }\n  UpdateStructuredListElement(StructuredList, StructuredIndex, ResultExpr);\n  ++Index;\n}\n\nvoid InitListChecker::CheckReferenceType(const InitializedEntity &Entity,\n                                         InitListExpr *IList, QualType DeclType,\n                                         unsigned &Index,\n                                         InitListExpr *StructuredList,\n                                         unsigned &StructuredIndex) {\n  if (Index >= IList->getNumInits()) {\n    // FIXME: It would be wonderful if we could point at the actual member. In\n    // general, it would be useful to pass location information down the stack,\n    // so that we know the location (or decl) of the \"current object\" being\n    // initialized.\n    if (!VerifyOnly)\n      SemaRef.Diag(IList->getBeginLoc(),\n                   diag::err_init_reference_member_uninitialized)\n          << DeclType << IList->getSourceRange();\n    hadError = true;\n    ++Index;\n    ++StructuredIndex;\n    return;\n  }\n\n  Expr *expr = IList->getInit(Index);\n  if (isa<InitListExpr>(expr) && !SemaRef.getLangOpts().CPlusPlus11) {\n    if (!VerifyOnly)\n      SemaRef.Diag(IList->getBeginLoc(), diag::err_init_non_aggr_init_list)\n          << DeclType << IList->getSourceRange();\n    hadError = true;\n    ++Index;\n    ++StructuredIndex;\n    return;\n  }\n\n  ExprResult Result;\n  if (VerifyOnly) {\n    if (SemaRef.CanPerformCopyInitialization(Entity,expr))\n      Result = getDummyInit();\n    else\n      Result = ExprError();\n  } else {\n    Result =\n        SemaRef.PerformCopyInitialization(Entity, expr->getBeginLoc(), expr,\n                                          /*TopLevelOfInitList=*/true);\n  }\n\n  if (Result.isInvalid())\n    hadError = true;\n\n  expr = Result.getAs<Expr>();\n  // FIXME: Why are we updating the syntactic init list?\n  if (!VerifyOnly && expr)\n    IList->setInit(Index, expr);\n\n  UpdateStructuredListElement(StructuredList, StructuredIndex, expr);\n  ++Index;\n}\n\nvoid InitListChecker::CheckVectorType(const InitializedEntity &Entity,\n                                      InitListExpr *IList, QualType DeclType,\n                                      unsigned &Index,\n                                      InitListExpr *StructuredList,\n                                      unsigned &StructuredIndex) {\n  const VectorType *VT = DeclType->castAs<VectorType>();\n  unsigned maxElements = VT->getNumElements();\n  unsigned numEltsInit = 0;\n  QualType elementType = VT->getElementType();\n\n  if (Index >= IList->getNumInits()) {\n    // Make sure the element type can be value-initialized.\n    CheckEmptyInitializable(\n        InitializedEntity::InitializeElement(SemaRef.Context, 0, Entity),\n        IList->getEndLoc());\n    return;\n  }\n\n  if (!SemaRef.getLangOpts().OpenCL) {\n    // If the initializing element is a vector, try to copy-initialize\n    // instead of breaking it apart (which is doomed to failure anyway).\n    Expr *Init = IList->getInit(Index);\n    if (!isa<InitListExpr>(Init) && Init->getType()->isVectorType()) {\n      ExprResult Result;\n      if (VerifyOnly) {\n        if (SemaRef.CanPerformCopyInitialization(Entity, Init))\n          Result = getDummyInit();\n        else\n          Result = ExprError();\n      } else {\n        Result =\n            SemaRef.PerformCopyInitialization(Entity, Init->getBeginLoc(), Init,\n                                              /*TopLevelOfInitList=*/true);\n      }\n\n      Expr *ResultExpr = nullptr;\n      if (Result.isInvalid())\n        hadError = true; // types weren't compatible.\n      else {\n        ResultExpr = Result.getAs<Expr>();\n\n        if (ResultExpr != Init && !VerifyOnly) {\n          // The type was promoted, update initializer list.\n          // FIXME: Why are we updating the syntactic init list?\n          IList->setInit(Index, ResultExpr);\n        }\n      }\n      UpdateStructuredListElement(StructuredList, StructuredIndex, ResultExpr);\n      ++Index;\n      return;\n    }\n\n    InitializedEntity ElementEntity =\n      InitializedEntity::InitializeElement(SemaRef.Context, 0, Entity);\n\n    for (unsigned i = 0; i < maxElements; ++i, ++numEltsInit) {\n      // Don't attempt to go past the end of the init list\n      if (Index >= IList->getNumInits()) {\n        CheckEmptyInitializable(ElementEntity, IList->getEndLoc());\n        break;\n      }\n\n      ElementEntity.setElementIndex(Index);\n      CheckSubElementType(ElementEntity, IList, elementType, Index,\n                          StructuredList, StructuredIndex);\n    }\n\n    if (VerifyOnly)\n      return;\n\n    bool isBigEndian = SemaRef.Context.getTargetInfo().isBigEndian();\n    const VectorType *T = Entity.getType()->castAs<VectorType>();\n    if (isBigEndian && (T->getVectorKind() == VectorType::NeonVector ||\n                        T->getVectorKind() == VectorType::NeonPolyVector)) {\n      // The ability to use vector initializer lists is a GNU vector extension\n      // and is unrelated to the NEON intrinsics in arm_neon.h. On little\n      // endian machines it works fine, however on big endian machines it\n      // exhibits surprising behaviour:\n      //\n      //   uint32x2_t x = {42, 64};\n      //   return vget_lane_u32(x, 0); // Will return 64.\n      //\n      // Because of this, explicitly call out that it is non-portable.\n      //\n      SemaRef.Diag(IList->getBeginLoc(),\n                   diag::warn_neon_vector_initializer_non_portable);\n\n      const char *typeCode;\n      unsigned typeSize = SemaRef.Context.getTypeSize(elementType);\n\n      if (elementType->isFloatingType())\n        typeCode = \"f\";\n      else if (elementType->isSignedIntegerType())\n        typeCode = \"s\";\n      else if (elementType->isUnsignedIntegerType())\n        typeCode = \"u\";\n      else\n        llvm_unreachable(\"Invalid element type!\");\n\n      SemaRef.Diag(IList->getBeginLoc(),\n                   SemaRef.Context.getTypeSize(VT) > 64\n                       ? diag::note_neon_vector_initializer_non_portable_q\n                       : diag::note_neon_vector_initializer_non_portable)\n          << typeCode << typeSize;\n    }\n\n    return;\n  }\n\n  InitializedEntity ElementEntity =\n    InitializedEntity::InitializeElement(SemaRef.Context, 0, Entity);\n\n  // OpenCL initializers allows vectors to be constructed from vectors.\n  for (unsigned i = 0; i < maxElements; ++i) {\n    // Don't attempt to go past the end of the init list\n    if (Index >= IList->getNumInits())\n      break;\n\n    ElementEntity.setElementIndex(Index);\n\n    QualType IType = IList->getInit(Index)->getType();\n    if (!IType->isVectorType()) {\n      CheckSubElementType(ElementEntity, IList, elementType, Index,\n                          StructuredList, StructuredIndex);\n      ++numEltsInit;\n    } else {\n      QualType VecType;\n      const VectorType *IVT = IType->castAs<VectorType>();\n      unsigned numIElts = IVT->getNumElements();\n\n      if (IType->isExtVectorType())\n        VecType = SemaRef.Context.getExtVectorType(elementType, numIElts);\n      else\n        VecType = SemaRef.Context.getVectorType(elementType, numIElts,\n                                                IVT->getVectorKind());\n      CheckSubElementType(ElementEntity, IList, VecType, Index,\n                          StructuredList, StructuredIndex);\n      numEltsInit += numIElts;\n    }\n  }\n\n  // OpenCL requires all elements to be initialized.\n  if (numEltsInit != maxElements) {\n    if (!VerifyOnly)\n      SemaRef.Diag(IList->getBeginLoc(),\n                   diag::err_vector_incorrect_num_initializers)\n          << (numEltsInit < maxElements) << maxElements << numEltsInit;\n    hadError = true;\n  }\n}\n\n/// Check if the type of a class element has an accessible destructor, and marks\n/// it referenced. Returns true if we shouldn't form a reference to the\n/// destructor.\n///\n/// Aggregate initialization requires a class element's destructor be\n/// accessible per 11.6.1 [dcl.init.aggr]:\n///\n/// The destructor for each element of class type is potentially invoked\n/// (15.4 [class.dtor]) from the context where the aggregate initialization\n/// occurs.\nstatic bool checkDestructorReference(QualType ElementType, SourceLocation Loc,\n                                     Sema &SemaRef) {\n  auto *CXXRD = ElementType->getAsCXXRecordDecl();\n  if (!CXXRD)\n    return false;\n\n  CXXDestructorDecl *Destructor = SemaRef.LookupDestructor(CXXRD);\n  SemaRef.CheckDestructorAccess(Loc, Destructor,\n                                SemaRef.PDiag(diag::err_access_dtor_temp)\n                                << ElementType);\n  SemaRef.MarkFunctionReferenced(Loc, Destructor);\n  return SemaRef.DiagnoseUseOfDecl(Destructor, Loc);\n}\n\nvoid InitListChecker::CheckArrayType(const InitializedEntity &Entity,\n                                     InitListExpr *IList, QualType &DeclType,\n                                     llvm::APSInt elementIndex,\n                                     bool SubobjectIsDesignatorContext,\n                                     unsigned &Index,\n                                     InitListExpr *StructuredList,\n                                     unsigned &StructuredIndex) {\n  const ArrayType *arrayType = SemaRef.Context.getAsArrayType(DeclType);\n\n  if (!VerifyOnly) {\n    if (checkDestructorReference(arrayType->getElementType(),\n                                 IList->getEndLoc(), SemaRef)) {\n      hadError = true;\n      return;\n    }\n  }\n\n  // Check for the special-case of initializing an array with a string.\n  if (Index < IList->getNumInits()) {\n    if (IsStringInit(IList->getInit(Index), arrayType, SemaRef.Context) ==\n        SIF_None) {\n      // We place the string literal directly into the resulting\n      // initializer list. This is the only place where the structure\n      // of the structured initializer list doesn't match exactly,\n      // because doing so would involve allocating one character\n      // constant for each string.\n      // FIXME: Should we do these checks in verify-only mode too?\n      if (!VerifyOnly)\n        CheckStringInit(IList->getInit(Index), DeclType, arrayType, SemaRef);\n      if (StructuredList) {\n        UpdateStructuredListElement(StructuredList, StructuredIndex,\n                                    IList->getInit(Index));\n        StructuredList->resizeInits(SemaRef.Context, StructuredIndex);\n      }\n      ++Index;\n      return;\n    }\n  }\n  if (const VariableArrayType *VAT = dyn_cast<VariableArrayType>(arrayType)) {\n    // Check for VLAs; in standard C it would be possible to check this\n    // earlier, but I don't know where clang accepts VLAs (gcc accepts\n    // them in all sorts of strange places).\n    if (!VerifyOnly)\n      SemaRef.Diag(VAT->getSizeExpr()->getBeginLoc(),\n                   diag::err_variable_object_no_init)\n          << VAT->getSizeExpr()->getSourceRange();\n    hadError = true;\n    ++Index;\n    ++StructuredIndex;\n    return;\n  }\n\n  // We might know the maximum number of elements in advance.\n  llvm::APSInt maxElements(elementIndex.getBitWidth(),\n                           elementIndex.isUnsigned());\n  bool maxElementsKnown = false;\n  if (const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(arrayType)) {\n    maxElements = CAT->getSize();\n    elementIndex = elementIndex.extOrTrunc(maxElements.getBitWidth());\n    elementIndex.setIsUnsigned(maxElements.isUnsigned());\n    maxElementsKnown = true;\n  }\n\n  QualType elementType = arrayType->getElementType();\n  while (Index < IList->getNumInits()) {\n    Expr *Init = IList->getInit(Index);\n    if (DesignatedInitExpr *DIE = dyn_cast<DesignatedInitExpr>(Init)) {\n      // If we're not the subobject that matches up with the '{' for\n      // the designator, we shouldn't be handling the\n      // designator. Return immediately.\n      if (!SubobjectIsDesignatorContext)\n        return;\n\n      // Handle this designated initializer. elementIndex will be\n      // updated to be the next array element we'll initialize.\n      if (CheckDesignatedInitializer(Entity, IList, DIE, 0,\n                                     DeclType, nullptr, &elementIndex, Index,\n                                     StructuredList, StructuredIndex, true,\n                                     false)) {\n        hadError = true;\n        continue;\n      }\n\n      if (elementIndex.getBitWidth() > maxElements.getBitWidth())\n        maxElements = maxElements.extend(elementIndex.getBitWidth());\n      else if (elementIndex.getBitWidth() < maxElements.getBitWidth())\n        elementIndex = elementIndex.extend(maxElements.getBitWidth());\n      elementIndex.setIsUnsigned(maxElements.isUnsigned());\n\n      // If the array is of incomplete type, keep track of the number of\n      // elements in the initializer.\n      if (!maxElementsKnown && elementIndex > maxElements)\n        maxElements = elementIndex;\n\n      continue;\n    }\n\n    // If we know the maximum number of elements, and we've already\n    // hit it, stop consuming elements in the initializer list.\n    if (maxElementsKnown && elementIndex == maxElements)\n      break;\n\n    InitializedEntity ElementEntity =\n      InitializedEntity::InitializeElement(SemaRef.Context, StructuredIndex,\n                                           Entity);\n    // Check this element.\n    CheckSubElementType(ElementEntity, IList, elementType, Index,\n                        StructuredList, StructuredIndex);\n    ++elementIndex;\n\n    // If the array is of incomplete type, keep track of the number of\n    // elements in the initializer.\n    if (!maxElementsKnown && elementIndex > maxElements)\n      maxElements = elementIndex;\n  }\n  if (!hadError && DeclType->isIncompleteArrayType() && !VerifyOnly) {\n    // If this is an incomplete array type, the actual type needs to\n    // be calculated here.\n    llvm::APSInt Zero(maxElements.getBitWidth(), maxElements.isUnsigned());\n    if (maxElements == Zero && !Entity.isVariableLengthArrayNew()) {\n      // Sizing an array implicitly to zero is not allowed by ISO C,\n      // but is supported by GNU.\n      SemaRef.Diag(IList->getBeginLoc(), diag::ext_typecheck_zero_array_size);\n    }\n\n    DeclType = SemaRef.Context.getConstantArrayType(\n        elementType, maxElements, nullptr, ArrayType::Normal, 0);\n  }\n  if (!hadError) {\n    // If there are any members of the array that get value-initialized, check\n    // that is possible. That happens if we know the bound and don't have\n    // enough elements, or if we're performing an array new with an unknown\n    // bound.\n    if ((maxElementsKnown && elementIndex < maxElements) ||\n        Entity.isVariableLengthArrayNew())\n      CheckEmptyInitializable(\n          InitializedEntity::InitializeElement(SemaRef.Context, 0, Entity),\n          IList->getEndLoc());\n  }\n}\n\nbool InitListChecker::CheckFlexibleArrayInit(const InitializedEntity &Entity,\n                                             Expr *InitExpr,\n                                             FieldDecl *Field,\n                                             bool TopLevelObject) {\n  // Handle GNU flexible array initializers.\n  unsigned FlexArrayDiag;\n  if (isa<InitListExpr>(InitExpr) &&\n      cast<InitListExpr>(InitExpr)->getNumInits() == 0) {\n    // Empty flexible array init always allowed as an extension\n    FlexArrayDiag = diag::ext_flexible_array_init;\n  } else if (SemaRef.getLangOpts().CPlusPlus) {\n    // Disallow flexible array init in C++; it is not required for gcc\n    // compatibility, and it needs work to IRGen correctly in general.\n    FlexArrayDiag = diag::err_flexible_array_init;\n  } else if (!TopLevelObject) {\n    // Disallow flexible array init on non-top-level object\n    FlexArrayDiag = diag::err_flexible_array_init;\n  } else if (Entity.getKind() != InitializedEntity::EK_Variable) {\n    // Disallow flexible array init on anything which is not a variable.\n    FlexArrayDiag = diag::err_flexible_array_init;\n  } else if (cast<VarDecl>(Entity.getDecl())->hasLocalStorage()) {\n    // Disallow flexible array init on local variables.\n    FlexArrayDiag = diag::err_flexible_array_init;\n  } else {\n    // Allow other cases.\n    FlexArrayDiag = diag::ext_flexible_array_init;\n  }\n\n  if (!VerifyOnly) {\n    SemaRef.Diag(InitExpr->getBeginLoc(), FlexArrayDiag)\n        << InitExpr->getBeginLoc();\n    SemaRef.Diag(Field->getLocation(), diag::note_flexible_array_member)\n      << Field;\n  }\n\n  return FlexArrayDiag != diag::ext_flexible_array_init;\n}\n\nvoid InitListChecker::CheckStructUnionTypes(\n    const InitializedEntity &Entity, InitListExpr *IList, QualType DeclType,\n    CXXRecordDecl::base_class_range Bases, RecordDecl::field_iterator Field,\n    bool SubobjectIsDesignatorContext, unsigned &Index,\n    InitListExpr *StructuredList, unsigned &StructuredIndex,\n    bool TopLevelObject) {\n  RecordDecl *structDecl = DeclType->castAs<RecordType>()->getDecl();\n\n  // If the record is invalid, some of it's members are invalid. To avoid\n  // confusion, we forgo checking the intializer for the entire record.\n  if (structDecl->isInvalidDecl()) {\n    // Assume it was supposed to consume a single initializer.\n    ++Index;\n    hadError = true;\n    return;\n  }\n\n  if (DeclType->isUnionType() && IList->getNumInits() == 0) {\n    RecordDecl *RD = DeclType->castAs<RecordType>()->getDecl();\n\n    if (!VerifyOnly)\n      for (FieldDecl *FD : RD->fields()) {\n        QualType ET = SemaRef.Context.getBaseElementType(FD->getType());\n        if (checkDestructorReference(ET, IList->getEndLoc(), SemaRef)) {\n          hadError = true;\n          return;\n        }\n      }\n\n    // If there's a default initializer, use it.\n    if (isa<CXXRecordDecl>(RD) &&\n        cast<CXXRecordDecl>(RD)->hasInClassInitializer()) {\n      if (!StructuredList)\n        return;\n      for (RecordDecl::field_iterator FieldEnd = RD->field_end();\n           Field != FieldEnd; ++Field) {\n        if (Field->hasInClassInitializer()) {\n          StructuredList->setInitializedFieldInUnion(*Field);\n          // FIXME: Actually build a CXXDefaultInitExpr?\n          return;\n        }\n      }\n    }\n\n    // Value-initialize the first member of the union that isn't an unnamed\n    // bitfield.\n    for (RecordDecl::field_iterator FieldEnd = RD->field_end();\n         Field != FieldEnd; ++Field) {\n      if (!Field->isUnnamedBitfield()) {\n        CheckEmptyInitializable(\n            InitializedEntity::InitializeMember(*Field, &Entity),\n            IList->getEndLoc());\n        if (StructuredList)\n          StructuredList->setInitializedFieldInUnion(*Field);\n        break;\n      }\n    }\n    return;\n  }\n\n  bool InitializedSomething = false;\n\n  // If we have any base classes, they are initialized prior to the fields.\n  for (auto &Base : Bases) {\n    Expr *Init = Index < IList->getNumInits() ? IList->getInit(Index) : nullptr;\n\n    // Designated inits always initialize fields, so if we see one, all\n    // remaining base classes have no explicit initializer.\n    if (Init && isa<DesignatedInitExpr>(Init))\n      Init = nullptr;\n\n    SourceLocation InitLoc = Init ? Init->getBeginLoc() : IList->getEndLoc();\n    InitializedEntity BaseEntity = InitializedEntity::InitializeBase(\n        SemaRef.Context, &Base, false, &Entity);\n    if (Init) {\n      CheckSubElementType(BaseEntity, IList, Base.getType(), Index,\n                          StructuredList, StructuredIndex);\n      InitializedSomething = true;\n    } else {\n      CheckEmptyInitializable(BaseEntity, InitLoc);\n    }\n\n    if (!VerifyOnly)\n      if (checkDestructorReference(Base.getType(), InitLoc, SemaRef)) {\n        hadError = true;\n        return;\n      }\n  }\n\n  // If structDecl is a forward declaration, this loop won't do\n  // anything except look at designated initializers; That's okay,\n  // because an error should get printed out elsewhere. It might be\n  // worthwhile to skip over the rest of the initializer, though.\n  RecordDecl *RD = DeclType->castAs<RecordType>()->getDecl();\n  RecordDecl::field_iterator FieldEnd = RD->field_end();\n  bool CheckForMissingFields =\n    !IList->isIdiomaticZeroInitializer(SemaRef.getLangOpts());\n  bool HasDesignatedInit = false;\n\n  while (Index < IList->getNumInits()) {\n    Expr *Init = IList->getInit(Index);\n    SourceLocation InitLoc = Init->getBeginLoc();\n\n    if (DesignatedInitExpr *DIE = dyn_cast<DesignatedInitExpr>(Init)) {\n      // If we're not the subobject that matches up with the '{' for\n      // the designator, we shouldn't be handling the\n      // designator. Return immediately.\n      if (!SubobjectIsDesignatorContext)\n        return;\n\n      HasDesignatedInit = true;\n\n      // Handle this designated initializer. Field will be updated to\n      // the next field that we'll be initializing.\n      if (CheckDesignatedInitializer(Entity, IList, DIE, 0,\n                                     DeclType, &Field, nullptr, Index,\n                                     StructuredList, StructuredIndex,\n                                     true, TopLevelObject))\n        hadError = true;\n      else if (!VerifyOnly) {\n        // Find the field named by the designated initializer.\n        RecordDecl::field_iterator F = RD->field_begin();\n        while (std::next(F) != Field)\n          ++F;\n        QualType ET = SemaRef.Context.getBaseElementType(F->getType());\n        if (checkDestructorReference(ET, InitLoc, SemaRef)) {\n          hadError = true;\n          return;\n        }\n      }\n\n      InitializedSomething = true;\n\n      // Disable check for missing fields when designators are used.\n      // This matches gcc behaviour.\n      CheckForMissingFields = false;\n      continue;\n    }\n\n    if (Field == FieldEnd) {\n      // We've run out of fields. We're done.\n      break;\n    }\n\n    // We've already initialized a member of a union. We're done.\n    if (InitializedSomething && DeclType->isUnionType())\n      break;\n\n    // If we've hit the flexible array member at the end, we're done.\n    if (Field->getType()->isIncompleteArrayType())\n      break;\n\n    if (Field->isUnnamedBitfield()) {\n      // Don't initialize unnamed bitfields, e.g. \"int : 20;\"\n      ++Field;\n      continue;\n    }\n\n    // Make sure we can use this declaration.\n    bool InvalidUse;\n    if (VerifyOnly)\n      InvalidUse = !SemaRef.CanUseDecl(*Field, TreatUnavailableAsInvalid);\n    else\n      InvalidUse = SemaRef.DiagnoseUseOfDecl(\n          *Field, IList->getInit(Index)->getBeginLoc());\n    if (InvalidUse) {\n      ++Index;\n      ++Field;\n      hadError = true;\n      continue;\n    }\n\n    if (!VerifyOnly) {\n      QualType ET = SemaRef.Context.getBaseElementType(Field->getType());\n      if (checkDestructorReference(ET, InitLoc, SemaRef)) {\n        hadError = true;\n        return;\n      }\n    }\n\n    InitializedEntity MemberEntity =\n      InitializedEntity::InitializeMember(*Field, &Entity);\n    CheckSubElementType(MemberEntity, IList, Field->getType(), Index,\n                        StructuredList, StructuredIndex);\n    InitializedSomething = true;\n\n    if (DeclType->isUnionType() && StructuredList) {\n      // Initialize the first field within the union.\n      StructuredList->setInitializedFieldInUnion(*Field);\n    }\n\n    ++Field;\n  }\n\n  // Emit warnings for missing struct field initializers.\n  if (!VerifyOnly && InitializedSomething && CheckForMissingFields &&\n      Field != FieldEnd && !Field->getType()->isIncompleteArrayType() &&\n      !DeclType->isUnionType()) {\n    // It is possible we have one or more unnamed bitfields remaining.\n    // Find first (if any) named field and emit warning.\n    for (RecordDecl::field_iterator it = Field, end = RD->field_end();\n         it != end; ++it) {\n      if (!it->isUnnamedBitfield() && !it->hasInClassInitializer()) {\n        SemaRef.Diag(IList->getSourceRange().getEnd(),\n                     diag::warn_missing_field_initializers) << *it;\n        break;\n      }\n    }\n  }\n\n  // Check that any remaining fields can be value-initialized if we're not\n  // building a structured list. (If we are, we'll check this later.)\n  if (!StructuredList && Field != FieldEnd && !DeclType->isUnionType() &&\n      !Field->getType()->isIncompleteArrayType()) {\n    for (; Field != FieldEnd && !hadError; ++Field) {\n      if (!Field->isUnnamedBitfield() && !Field->hasInClassInitializer())\n        CheckEmptyInitializable(\n            InitializedEntity::InitializeMember(*Field, &Entity),\n            IList->getEndLoc());\n    }\n  }\n\n  // Check that the types of the remaining fields have accessible destructors.\n  if (!VerifyOnly) {\n    // If the initializer expression has a designated initializer, check the\n    // elements for which a designated initializer is not provided too.\n    RecordDecl::field_iterator I = HasDesignatedInit ? RD->field_begin()\n                                                     : Field;\n    for (RecordDecl::field_iterator E = RD->field_end(); I != E; ++I) {\n      QualType ET = SemaRef.Context.getBaseElementType(I->getType());\n      if (checkDestructorReference(ET, IList->getEndLoc(), SemaRef)) {\n        hadError = true;\n        return;\n      }\n    }\n  }\n\n  if (Field == FieldEnd || !Field->getType()->isIncompleteArrayType() ||\n      Index >= IList->getNumInits())\n    return;\n\n  if (CheckFlexibleArrayInit(Entity, IList->getInit(Index), *Field,\n                             TopLevelObject)) {\n    hadError = true;\n    ++Index;\n    return;\n  }\n\n  InitializedEntity MemberEntity =\n    InitializedEntity::InitializeMember(*Field, &Entity);\n\n  if (isa<InitListExpr>(IList->getInit(Index)))\n    CheckSubElementType(MemberEntity, IList, Field->getType(), Index,\n                        StructuredList, StructuredIndex);\n  else\n    CheckImplicitInitList(MemberEntity, IList, Field->getType(), Index,\n                          StructuredList, StructuredIndex);\n}\n\n/// Expand a field designator that refers to a member of an\n/// anonymous struct or union into a series of field designators that\n/// refers to the field within the appropriate subobject.\n///\nstatic void ExpandAnonymousFieldDesignator(Sema &SemaRef,\n                                           DesignatedInitExpr *DIE,\n                                           unsigned DesigIdx,\n                                           IndirectFieldDecl *IndirectField) {\n  typedef DesignatedInitExpr::Designator Designator;\n\n  // Build the replacement designators.\n  SmallVector<Designator, 4> Replacements;\n  for (IndirectFieldDecl::chain_iterator PI = IndirectField->chain_begin(),\n       PE = IndirectField->chain_end(); PI != PE; ++PI) {\n    if (PI + 1 == PE)\n      Replacements.push_back(Designator((IdentifierInfo *)nullptr,\n                                    DIE->getDesignator(DesigIdx)->getDotLoc(),\n                                DIE->getDesignator(DesigIdx)->getFieldLoc()));\n    else\n      Replacements.push_back(Designator((IdentifierInfo *)nullptr,\n                                        SourceLocation(), SourceLocation()));\n    assert(isa<FieldDecl>(*PI));\n    Replacements.back().setField(cast<FieldDecl>(*PI));\n  }\n\n  // Expand the current designator into the set of replacement\n  // designators, so we have a full subobject path down to where the\n  // member of the anonymous struct/union is actually stored.\n  DIE->ExpandDesignator(SemaRef.Context, DesigIdx, &Replacements[0],\n                        &Replacements[0] + Replacements.size());\n}\n\nstatic DesignatedInitExpr *CloneDesignatedInitExpr(Sema &SemaRef,\n                                                   DesignatedInitExpr *DIE) {\n  unsigned NumIndexExprs = DIE->getNumSubExprs() - 1;\n  SmallVector<Expr*, 4> IndexExprs(NumIndexExprs);\n  for (unsigned I = 0; I < NumIndexExprs; ++I)\n    IndexExprs[I] = DIE->getSubExpr(I + 1);\n  return DesignatedInitExpr::Create(SemaRef.Context, DIE->designators(),\n                                    IndexExprs,\n                                    DIE->getEqualOrColonLoc(),\n                                    DIE->usesGNUSyntax(), DIE->getInit());\n}\n\nnamespace {\n\n// Callback to only accept typo corrections that are for field members of\n// the given struct or union.\nclass FieldInitializerValidatorCCC final : public CorrectionCandidateCallback {\n public:\n  explicit FieldInitializerValidatorCCC(RecordDecl *RD)\n      : Record(RD) {}\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    FieldDecl *FD = candidate.getCorrectionDeclAs<FieldDecl>();\n    return FD && FD->getDeclContext()->getRedeclContext()->Equals(Record);\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<FieldInitializerValidatorCCC>(*this);\n  }\n\n private:\n  RecordDecl *Record;\n};\n\n} // end anonymous namespace\n\n/// Check the well-formedness of a C99 designated initializer.\n///\n/// Determines whether the designated initializer @p DIE, which\n/// resides at the given @p Index within the initializer list @p\n/// IList, is well-formed for a current object of type @p DeclType\n/// (C99 6.7.8). The actual subobject that this designator refers to\n/// within the current subobject is returned in either\n/// @p NextField or @p NextElementIndex (whichever is appropriate).\n///\n/// @param IList  The initializer list in which this designated\n/// initializer occurs.\n///\n/// @param DIE The designated initializer expression.\n///\n/// @param DesigIdx  The index of the current designator.\n///\n/// @param CurrentObjectType The type of the \"current object\" (C99 6.7.8p17),\n/// into which the designation in @p DIE should refer.\n///\n/// @param NextField  If non-NULL and the first designator in @p DIE is\n/// a field, this will be set to the field declaration corresponding\n/// to the field named by the designator. On input, this is expected to be\n/// the next field that would be initialized in the absence of designation,\n/// if the complete object being initialized is a struct.\n///\n/// @param NextElementIndex  If non-NULL and the first designator in @p\n/// DIE is an array designator or GNU array-range designator, this\n/// will be set to the last index initialized by this designator.\n///\n/// @param Index  Index into @p IList where the designated initializer\n/// @p DIE occurs.\n///\n/// @param StructuredList  The initializer list expression that\n/// describes all of the subobject initializers in the order they'll\n/// actually be initialized.\n///\n/// @returns true if there was an error, false otherwise.\nbool\nInitListChecker::CheckDesignatedInitializer(const InitializedEntity &Entity,\n                                            InitListExpr *IList,\n                                            DesignatedInitExpr *DIE,\n                                            unsigned DesigIdx,\n                                            QualType &CurrentObjectType,\n                                          RecordDecl::field_iterator *NextField,\n                                            llvm::APSInt *NextElementIndex,\n                                            unsigned &Index,\n                                            InitListExpr *StructuredList,\n                                            unsigned &StructuredIndex,\n                                            bool FinishSubobjectInit,\n                                            bool TopLevelObject) {\n  if (DesigIdx == DIE->size()) {\n    // C++20 designated initialization can result in direct-list-initialization\n    // of the designated subobject. This is the only way that we can end up\n    // performing direct initialization as part of aggregate initialization, so\n    // it needs special handling.\n    if (DIE->isDirectInit()) {\n      Expr *Init = DIE->getInit();\n      assert(isa<InitListExpr>(Init) &&\n             \"designator result in direct non-list initialization?\");\n      InitializationKind Kind = InitializationKind::CreateDirectList(\n          DIE->getBeginLoc(), Init->getBeginLoc(), Init->getEndLoc());\n      InitializationSequence Seq(SemaRef, Entity, Kind, Init,\n                                 /*TopLevelOfInitList*/ true);\n      if (StructuredList) {\n        ExprResult Result = VerifyOnly\n                                ? getDummyInit()\n                                : Seq.Perform(SemaRef, Entity, Kind, Init);\n        UpdateStructuredListElement(StructuredList, StructuredIndex,\n                                    Result.get());\n      }\n      ++Index;\n      return !Seq;\n    }\n\n    // Check the actual initialization for the designated object type.\n    bool prevHadError = hadError;\n\n    // Temporarily remove the designator expression from the\n    // initializer list that the child calls see, so that we don't try\n    // to re-process the designator.\n    unsigned OldIndex = Index;\n    IList->setInit(OldIndex, DIE->getInit());\n\n    CheckSubElementType(Entity, IList, CurrentObjectType, Index, StructuredList,\n                        StructuredIndex, /*DirectlyDesignated=*/true);\n\n    // Restore the designated initializer expression in the syntactic\n    // form of the initializer list.\n    if (IList->getInit(OldIndex) != DIE->getInit())\n      DIE->setInit(IList->getInit(OldIndex));\n    IList->setInit(OldIndex, DIE);\n\n    return hadError && !prevHadError;\n  }\n\n  DesignatedInitExpr::Designator *D = DIE->getDesignator(DesigIdx);\n  bool IsFirstDesignator = (DesigIdx == 0);\n  if (IsFirstDesignator ? FullyStructuredList : StructuredList) {\n    // Determine the structural initializer list that corresponds to the\n    // current subobject.\n    if (IsFirstDesignator)\n      StructuredList = FullyStructuredList;\n    else {\n      Expr *ExistingInit = StructuredIndex < StructuredList->getNumInits() ?\n          StructuredList->getInit(StructuredIndex) : nullptr;\n      if (!ExistingInit && StructuredList->hasArrayFiller())\n        ExistingInit = StructuredList->getArrayFiller();\n\n      if (!ExistingInit)\n        StructuredList = getStructuredSubobjectInit(\n            IList, Index, CurrentObjectType, StructuredList, StructuredIndex,\n            SourceRange(D->getBeginLoc(), DIE->getEndLoc()));\n      else if (InitListExpr *Result = dyn_cast<InitListExpr>(ExistingInit))\n        StructuredList = Result;\n      else {\n        // We are creating an initializer list that initializes the\n        // subobjects of the current object, but there was already an\n        // initialization that completely initialized the current\n        // subobject, e.g., by a compound literal:\n        //\n        // struct X { int a, b; };\n        // struct X xs[] = { [0] = (struct X) { 1, 2 }, [0].b = 3 };\n        //\n        // Here, xs[0].a == 1 and xs[0].b == 3, since the second,\n        // designated initializer re-initializes only its current object\n        // subobject [0].b.\n        diagnoseInitOverride(ExistingInit,\n                             SourceRange(D->getBeginLoc(), DIE->getEndLoc()),\n                             /*FullyOverwritten=*/false);\n\n        if (!VerifyOnly) {\n          if (DesignatedInitUpdateExpr *E =\n                  dyn_cast<DesignatedInitUpdateExpr>(ExistingInit))\n            StructuredList = E->getUpdater();\n          else {\n            DesignatedInitUpdateExpr *DIUE = new (SemaRef.Context)\n                DesignatedInitUpdateExpr(SemaRef.Context, D->getBeginLoc(),\n                                         ExistingInit, DIE->getEndLoc());\n            StructuredList->updateInit(SemaRef.Context, StructuredIndex, DIUE);\n            StructuredList = DIUE->getUpdater();\n          }\n        } else {\n          // We don't need to track the structured representation of a\n          // designated init update of an already-fully-initialized object in\n          // verify-only mode. The only reason we would need the structure is\n          // to determine where the uninitialized \"holes\" are, and in this\n          // case, we know there aren't any and we can't introduce any.\n          StructuredList = nullptr;\n        }\n      }\n    }\n  }\n\n  if (D->isFieldDesignator()) {\n    // C99 6.7.8p7:\n    //\n    //   If a designator has the form\n    //\n    //      . identifier\n    //\n    //   then the current object (defined below) shall have\n    //   structure or union type and the identifier shall be the\n    //   name of a member of that type.\n    const RecordType *RT = CurrentObjectType->getAs<RecordType>();\n    if (!RT) {\n      SourceLocation Loc = D->getDotLoc();\n      if (Loc.isInvalid())\n        Loc = D->getFieldLoc();\n      if (!VerifyOnly)\n        SemaRef.Diag(Loc, diag::err_field_designator_non_aggr)\n          << SemaRef.getLangOpts().CPlusPlus << CurrentObjectType;\n      ++Index;\n      return true;\n    }\n\n    FieldDecl *KnownField = D->getField();\n    if (!KnownField) {\n      IdentifierInfo *FieldName = D->getFieldName();\n      DeclContext::lookup_result Lookup = RT->getDecl()->lookup(FieldName);\n      for (NamedDecl *ND : Lookup) {\n        if (auto *FD = dyn_cast<FieldDecl>(ND)) {\n          KnownField = FD;\n          break;\n        }\n        if (auto *IFD = dyn_cast<IndirectFieldDecl>(ND)) {\n          // In verify mode, don't modify the original.\n          if (VerifyOnly)\n            DIE = CloneDesignatedInitExpr(SemaRef, DIE);\n          ExpandAnonymousFieldDesignator(SemaRef, DIE, DesigIdx, IFD);\n          D = DIE->getDesignator(DesigIdx);\n          KnownField = cast<FieldDecl>(*IFD->chain_begin());\n          break;\n        }\n      }\n      if (!KnownField) {\n        if (VerifyOnly) {\n          ++Index;\n          return true;  // No typo correction when just trying this out.\n        }\n\n        // Name lookup found something, but it wasn't a field.\n        if (!Lookup.empty()) {\n          SemaRef.Diag(D->getFieldLoc(), diag::err_field_designator_nonfield)\n            << FieldName;\n          SemaRef.Diag(Lookup.front()->getLocation(),\n                       diag::note_field_designator_found);\n          ++Index;\n          return true;\n        }\n\n        // Name lookup didn't find anything.\n        // Determine whether this was a typo for another field name.\n        FieldInitializerValidatorCCC CCC(RT->getDecl());\n        if (TypoCorrection Corrected = SemaRef.CorrectTypo(\n                DeclarationNameInfo(FieldName, D->getFieldLoc()),\n                Sema::LookupMemberName, /*Scope=*/nullptr, /*SS=*/nullptr, CCC,\n                Sema::CTK_ErrorRecovery, RT->getDecl())) {\n          SemaRef.diagnoseTypo(\n              Corrected,\n              SemaRef.PDiag(diag::err_field_designator_unknown_suggest)\n                << FieldName << CurrentObjectType);\n          KnownField = Corrected.getCorrectionDeclAs<FieldDecl>();\n          hadError = true;\n        } else {\n          // Typo correction didn't find anything.\n          SemaRef.Diag(D->getFieldLoc(), diag::err_field_designator_unknown)\n            << FieldName << CurrentObjectType;\n          ++Index;\n          return true;\n        }\n      }\n    }\n\n    unsigned NumBases = 0;\n    if (auto *CXXRD = dyn_cast<CXXRecordDecl>(RT->getDecl()))\n      NumBases = CXXRD->getNumBases();\n\n    unsigned FieldIndex = NumBases;\n\n    for (auto *FI : RT->getDecl()->fields()) {\n      if (FI->isUnnamedBitfield())\n        continue;\n      if (declaresSameEntity(KnownField, FI)) {\n        KnownField = FI;\n        break;\n      }\n      ++FieldIndex;\n    }\n\n    RecordDecl::field_iterator Field =\n        RecordDecl::field_iterator(DeclContext::decl_iterator(KnownField));\n\n    // All of the fields of a union are located at the same place in\n    // the initializer list.\n    if (RT->getDecl()->isUnion()) {\n      FieldIndex = 0;\n      if (StructuredList) {\n        FieldDecl *CurrentField = StructuredList->getInitializedFieldInUnion();\n        if (CurrentField && !declaresSameEntity(CurrentField, *Field)) {\n          assert(StructuredList->getNumInits() == 1\n                 && \"A union should never have more than one initializer!\");\n\n          Expr *ExistingInit = StructuredList->getInit(0);\n          if (ExistingInit) {\n            // We're about to throw away an initializer, emit warning.\n            diagnoseInitOverride(\n                ExistingInit, SourceRange(D->getBeginLoc(), DIE->getEndLoc()));\n          }\n\n          // remove existing initializer\n          StructuredList->resizeInits(SemaRef.Context, 0);\n          StructuredList->setInitializedFieldInUnion(nullptr);\n        }\n\n        StructuredList->setInitializedFieldInUnion(*Field);\n      }\n    }\n\n    // Make sure we can use this declaration.\n    bool InvalidUse;\n    if (VerifyOnly)\n      InvalidUse = !SemaRef.CanUseDecl(*Field, TreatUnavailableAsInvalid);\n    else\n      InvalidUse = SemaRef.DiagnoseUseOfDecl(*Field, D->getFieldLoc());\n    if (InvalidUse) {\n      ++Index;\n      return true;\n    }\n\n    // C++20 [dcl.init.list]p3:\n    //   The ordered identifiers in the designators of the designated-\n    //   initializer-list shall form a subsequence of the ordered identifiers\n    //   in the direct non-static data members of T.\n    //\n    // Note that this is not a condition on forming the aggregate\n    // initialization, only on actually performing initialization,\n    // so it is not checked in VerifyOnly mode.\n    //\n    // FIXME: This is the only reordering diagnostic we produce, and it only\n    // catches cases where we have a top-level field designator that jumps\n    // backwards. This is the only such case that is reachable in an\n    // otherwise-valid C++20 program, so is the only case that's required for\n    // conformance, but for consistency, we should diagnose all the other\n    // cases where a designator takes us backwards too.\n    if (IsFirstDesignator && !VerifyOnly && SemaRef.getLangOpts().CPlusPlus &&\n        NextField &&\n        (*NextField == RT->getDecl()->field_end() ||\n         (*NextField)->getFieldIndex() > Field->getFieldIndex() + 1)) {\n      // Find the field that we just initialized.\n      FieldDecl *PrevField = nullptr;\n      for (auto FI = RT->getDecl()->field_begin();\n           FI != RT->getDecl()->field_end(); ++FI) {\n        if (FI->isUnnamedBitfield())\n          continue;\n        if (*NextField != RT->getDecl()->field_end() &&\n            declaresSameEntity(*FI, **NextField))\n          break;\n        PrevField = *FI;\n      }\n\n      if (PrevField &&\n          PrevField->getFieldIndex() > KnownField->getFieldIndex()) {\n        SemaRef.Diag(DIE->getBeginLoc(), diag::ext_designated_init_reordered)\n            << KnownField << PrevField << DIE->getSourceRange();\n\n        unsigned OldIndex = NumBases + PrevField->getFieldIndex();\n        if (StructuredList && OldIndex <= StructuredList->getNumInits()) {\n          if (Expr *PrevInit = StructuredList->getInit(OldIndex)) {\n            SemaRef.Diag(PrevInit->getBeginLoc(),\n                         diag::note_previous_field_init)\n                << PrevField << PrevInit->getSourceRange();\n          }\n        }\n      }\n    }\n\n\n    // Update the designator with the field declaration.\n    if (!VerifyOnly)\n      D->setField(*Field);\n\n    // Make sure that our non-designated initializer list has space\n    // for a subobject corresponding to this field.\n    if (StructuredList && FieldIndex >= StructuredList->getNumInits())\n      StructuredList->resizeInits(SemaRef.Context, FieldIndex + 1);\n\n    // This designator names a flexible array member.\n    if (Field->getType()->isIncompleteArrayType()) {\n      bool Invalid = false;\n      if ((DesigIdx + 1) != DIE->size()) {\n        // We can't designate an object within the flexible array\n        // member (because GCC doesn't allow it).\n        if (!VerifyOnly) {\n          DesignatedInitExpr::Designator *NextD\n            = DIE->getDesignator(DesigIdx + 1);\n          SemaRef.Diag(NextD->getBeginLoc(),\n                       diag::err_designator_into_flexible_array_member)\n              << SourceRange(NextD->getBeginLoc(), DIE->getEndLoc());\n          SemaRef.Diag(Field->getLocation(), diag::note_flexible_array_member)\n            << *Field;\n        }\n        Invalid = true;\n      }\n\n      if (!hadError && !isa<InitListExpr>(DIE->getInit()) &&\n          !isa<StringLiteral>(DIE->getInit())) {\n        // The initializer is not an initializer list.\n        if (!VerifyOnly) {\n          SemaRef.Diag(DIE->getInit()->getBeginLoc(),\n                       diag::err_flexible_array_init_needs_braces)\n              << DIE->getInit()->getSourceRange();\n          SemaRef.Diag(Field->getLocation(), diag::note_flexible_array_member)\n            << *Field;\n        }\n        Invalid = true;\n      }\n\n      // Check GNU flexible array initializer.\n      if (!Invalid && CheckFlexibleArrayInit(Entity, DIE->getInit(), *Field,\n                                             TopLevelObject))\n        Invalid = true;\n\n      if (Invalid) {\n        ++Index;\n        return true;\n      }\n\n      // Initialize the array.\n      bool prevHadError = hadError;\n      unsigned newStructuredIndex = FieldIndex;\n      unsigned OldIndex = Index;\n      IList->setInit(Index, DIE->getInit());\n\n      InitializedEntity MemberEntity =\n        InitializedEntity::InitializeMember(*Field, &Entity);\n      CheckSubElementType(MemberEntity, IList, Field->getType(), Index,\n                          StructuredList, newStructuredIndex);\n\n      IList->setInit(OldIndex, DIE);\n      if (hadError && !prevHadError) {\n        ++Field;\n        ++FieldIndex;\n        if (NextField)\n          *NextField = Field;\n        StructuredIndex = FieldIndex;\n        return true;\n      }\n    } else {\n      // Recurse to check later designated subobjects.\n      QualType FieldType = Field->getType();\n      unsigned newStructuredIndex = FieldIndex;\n\n      InitializedEntity MemberEntity =\n        InitializedEntity::InitializeMember(*Field, &Entity);\n      if (CheckDesignatedInitializer(MemberEntity, IList, DIE, DesigIdx + 1,\n                                     FieldType, nullptr, nullptr, Index,\n                                     StructuredList, newStructuredIndex,\n                                     FinishSubobjectInit, false))\n        return true;\n    }\n\n    // Find the position of the next field to be initialized in this\n    // subobject.\n    ++Field;\n    ++FieldIndex;\n\n    // If this the first designator, our caller will continue checking\n    // the rest of this struct/class/union subobject.\n    if (IsFirstDesignator) {\n      if (NextField)\n        *NextField = Field;\n      StructuredIndex = FieldIndex;\n      return false;\n    }\n\n    if (!FinishSubobjectInit)\n      return false;\n\n    // We've already initialized something in the union; we're done.\n    if (RT->getDecl()->isUnion())\n      return hadError;\n\n    // Check the remaining fields within this class/struct/union subobject.\n    bool prevHadError = hadError;\n\n    auto NoBases =\n        CXXRecordDecl::base_class_range(CXXRecordDecl::base_class_iterator(),\n                                        CXXRecordDecl::base_class_iterator());\n    CheckStructUnionTypes(Entity, IList, CurrentObjectType, NoBases, Field,\n                          false, Index, StructuredList, FieldIndex);\n    return hadError && !prevHadError;\n  }\n\n  // C99 6.7.8p6:\n  //\n  //   If a designator has the form\n  //\n  //      [ constant-expression ]\n  //\n  //   then the current object (defined below) shall have array\n  //   type and the expression shall be an integer constant\n  //   expression. If the array is of unknown size, any\n  //   nonnegative value is valid.\n  //\n  // Additionally, cope with the GNU extension that permits\n  // designators of the form\n  //\n  //      [ constant-expression ... constant-expression ]\n  const ArrayType *AT = SemaRef.Context.getAsArrayType(CurrentObjectType);\n  if (!AT) {\n    if (!VerifyOnly)\n      SemaRef.Diag(D->getLBracketLoc(), diag::err_array_designator_non_array)\n        << CurrentObjectType;\n    ++Index;\n    return true;\n  }\n\n  Expr *IndexExpr = nullptr;\n  llvm::APSInt DesignatedStartIndex, DesignatedEndIndex;\n  if (D->isArrayDesignator()) {\n    IndexExpr = DIE->getArrayIndex(*D);\n    DesignatedStartIndex = IndexExpr->EvaluateKnownConstInt(SemaRef.Context);\n    DesignatedEndIndex = DesignatedStartIndex;\n  } else {\n    assert(D->isArrayRangeDesignator() && \"Need array-range designator\");\n\n    DesignatedStartIndex =\n      DIE->getArrayRangeStart(*D)->EvaluateKnownConstInt(SemaRef.Context);\n    DesignatedEndIndex =\n      DIE->getArrayRangeEnd(*D)->EvaluateKnownConstInt(SemaRef.Context);\n    IndexExpr = DIE->getArrayRangeEnd(*D);\n\n    // Codegen can't handle evaluating array range designators that have side\n    // effects, because we replicate the AST value for each initialized element.\n    // As such, set the sawArrayRangeDesignator() bit if we initialize multiple\n    // elements with something that has a side effect, so codegen can emit an\n    // \"error unsupported\" error instead of miscompiling the app.\n    if (DesignatedStartIndex.getZExtValue()!=DesignatedEndIndex.getZExtValue()&&\n        DIE->getInit()->HasSideEffects(SemaRef.Context) && !VerifyOnly)\n      FullyStructuredList->sawArrayRangeDesignator();\n  }\n\n  if (isa<ConstantArrayType>(AT)) {\n    llvm::APSInt MaxElements(cast<ConstantArrayType>(AT)->getSize(), false);\n    DesignatedStartIndex\n      = DesignatedStartIndex.extOrTrunc(MaxElements.getBitWidth());\n    DesignatedStartIndex.setIsUnsigned(MaxElements.isUnsigned());\n    DesignatedEndIndex\n      = DesignatedEndIndex.extOrTrunc(MaxElements.getBitWidth());\n    DesignatedEndIndex.setIsUnsigned(MaxElements.isUnsigned());\n    if (DesignatedEndIndex >= MaxElements) {\n      if (!VerifyOnly)\n        SemaRef.Diag(IndexExpr->getBeginLoc(),\n                     diag::err_array_designator_too_large)\n            << DesignatedEndIndex.toString(10) << MaxElements.toString(10)\n            << IndexExpr->getSourceRange();\n      ++Index;\n      return true;\n    }\n  } else {\n    unsigned DesignatedIndexBitWidth =\n      ConstantArrayType::getMaxSizeBits(SemaRef.Context);\n    DesignatedStartIndex =\n      DesignatedStartIndex.extOrTrunc(DesignatedIndexBitWidth);\n    DesignatedEndIndex =\n      DesignatedEndIndex.extOrTrunc(DesignatedIndexBitWidth);\n    DesignatedStartIndex.setIsUnsigned(true);\n    DesignatedEndIndex.setIsUnsigned(true);\n  }\n\n  bool IsStringLiteralInitUpdate =\n      StructuredList && StructuredList->isStringLiteralInit();\n  if (IsStringLiteralInitUpdate && VerifyOnly) {\n    // We're just verifying an update to a string literal init. We don't need\n    // to split the string up into individual characters to do that.\n    StructuredList = nullptr;\n  } else if (IsStringLiteralInitUpdate) {\n    // We're modifying a string literal init; we have to decompose the string\n    // so we can modify the individual characters.\n    ASTContext &Context = SemaRef.Context;\n    Expr *SubExpr = StructuredList->getInit(0)->IgnoreParens();\n\n    // Compute the character type\n    QualType CharTy = AT->getElementType();\n\n    // Compute the type of the integer literals.\n    QualType PromotedCharTy = CharTy;\n    if (CharTy->isPromotableIntegerType())\n      PromotedCharTy = Context.getPromotedIntegerType(CharTy);\n    unsigned PromotedCharTyWidth = Context.getTypeSize(PromotedCharTy);\n\n    if (StringLiteral *SL = dyn_cast<StringLiteral>(SubExpr)) {\n      // Get the length of the string.\n      uint64_t StrLen = SL->getLength();\n      if (cast<ConstantArrayType>(AT)->getSize().ult(StrLen))\n        StrLen = cast<ConstantArrayType>(AT)->getSize().getZExtValue();\n      StructuredList->resizeInits(Context, StrLen);\n\n      // Build a literal for each character in the string, and put them into\n      // the init list.\n      for (unsigned i = 0, e = StrLen; i != e; ++i) {\n        llvm::APInt CodeUnit(PromotedCharTyWidth, SL->getCodeUnit(i));\n        Expr *Init = new (Context) IntegerLiteral(\n            Context, CodeUnit, PromotedCharTy, SubExpr->getExprLoc());\n        if (CharTy != PromotedCharTy)\n          Init =\n              ImplicitCastExpr::Create(Context, CharTy, CK_IntegralCast, Init,\n                                       nullptr, VK_RValue, FPOptionsOverride());\n        StructuredList->updateInit(Context, i, Init);\n      }\n    } else {\n      ObjCEncodeExpr *E = cast<ObjCEncodeExpr>(SubExpr);\n      std::string Str;\n      Context.getObjCEncodingForType(E->getEncodedType(), Str);\n\n      // Get the length of the string.\n      uint64_t StrLen = Str.size();\n      if (cast<ConstantArrayType>(AT)->getSize().ult(StrLen))\n        StrLen = cast<ConstantArrayType>(AT)->getSize().getZExtValue();\n      StructuredList->resizeInits(Context, StrLen);\n\n      // Build a literal for each character in the string, and put them into\n      // the init list.\n      for (unsigned i = 0, e = StrLen; i != e; ++i) {\n        llvm::APInt CodeUnit(PromotedCharTyWidth, Str[i]);\n        Expr *Init = new (Context) IntegerLiteral(\n            Context, CodeUnit, PromotedCharTy, SubExpr->getExprLoc());\n        if (CharTy != PromotedCharTy)\n          Init =\n              ImplicitCastExpr::Create(Context, CharTy, CK_IntegralCast, Init,\n                                       nullptr, VK_RValue, FPOptionsOverride());\n        StructuredList->updateInit(Context, i, Init);\n      }\n    }\n  }\n\n  // Make sure that our non-designated initializer list has space\n  // for a subobject corresponding to this array element.\n  if (StructuredList &&\n      DesignatedEndIndex.getZExtValue() >= StructuredList->getNumInits())\n    StructuredList->resizeInits(SemaRef.Context,\n                                DesignatedEndIndex.getZExtValue() + 1);\n\n  // Repeatedly perform subobject initializations in the range\n  // [DesignatedStartIndex, DesignatedEndIndex].\n\n  // Move to the next designator\n  unsigned ElementIndex = DesignatedStartIndex.getZExtValue();\n  unsigned OldIndex = Index;\n\n  InitializedEntity ElementEntity =\n    InitializedEntity::InitializeElement(SemaRef.Context, 0, Entity);\n\n  while (DesignatedStartIndex <= DesignatedEndIndex) {\n    // Recurse to check later designated subobjects.\n    QualType ElementType = AT->getElementType();\n    Index = OldIndex;\n\n    ElementEntity.setElementIndex(ElementIndex);\n    if (CheckDesignatedInitializer(\n            ElementEntity, IList, DIE, DesigIdx + 1, ElementType, nullptr,\n            nullptr, Index, StructuredList, ElementIndex,\n            FinishSubobjectInit && (DesignatedStartIndex == DesignatedEndIndex),\n            false))\n      return true;\n\n    // Move to the next index in the array that we'll be initializing.\n    ++DesignatedStartIndex;\n    ElementIndex = DesignatedStartIndex.getZExtValue();\n  }\n\n  // If this the first designator, our caller will continue checking\n  // the rest of this array subobject.\n  if (IsFirstDesignator) {\n    if (NextElementIndex)\n      *NextElementIndex = DesignatedStartIndex;\n    StructuredIndex = ElementIndex;\n    return false;\n  }\n\n  if (!FinishSubobjectInit)\n    return false;\n\n  // Check the remaining elements within this array subobject.\n  bool prevHadError = hadError;\n  CheckArrayType(Entity, IList, CurrentObjectType, DesignatedStartIndex,\n                 /*SubobjectIsDesignatorContext=*/false, Index,\n                 StructuredList, ElementIndex);\n  return hadError && !prevHadError;\n}\n\n// Get the structured initializer list for a subobject of type\n// @p CurrentObjectType.\nInitListExpr *\nInitListChecker::getStructuredSubobjectInit(InitListExpr *IList, unsigned Index,\n                                            QualType CurrentObjectType,\n                                            InitListExpr *StructuredList,\n                                            unsigned StructuredIndex,\n                                            SourceRange InitRange,\n                                            bool IsFullyOverwritten) {\n  if (!StructuredList)\n    return nullptr;\n\n  Expr *ExistingInit = nullptr;\n  if (StructuredIndex < StructuredList->getNumInits())\n    ExistingInit = StructuredList->getInit(StructuredIndex);\n\n  if (InitListExpr *Result = dyn_cast_or_null<InitListExpr>(ExistingInit))\n    // There might have already been initializers for subobjects of the current\n    // object, but a subsequent initializer list will overwrite the entirety\n    // of the current object. (See DR 253 and C99 6.7.8p21). e.g.,\n    //\n    // struct P { char x[6]; };\n    // struct P l = { .x[2] = 'x', .x = { [0] = 'f' } };\n    //\n    // The first designated initializer is ignored, and l.x is just \"f\".\n    if (!IsFullyOverwritten)\n      return Result;\n\n  if (ExistingInit) {\n    // We are creating an initializer list that initializes the\n    // subobjects of the current object, but there was already an\n    // initialization that completely initialized the current\n    // subobject:\n    //\n    // struct X { int a, b; };\n    // struct X xs[] = { [0] = { 1, 2 }, [0].b = 3 };\n    //\n    // Here, xs[0].a == 1 and xs[0].b == 3, since the second,\n    // designated initializer overwrites the [0].b initializer\n    // from the prior initialization.\n    //\n    // When the existing initializer is an expression rather than an\n    // initializer list, we cannot decompose and update it in this way.\n    // For example:\n    //\n    // struct X xs[] = { [0] = (struct X) { 1, 2 }, [0].b = 3 };\n    //\n    // This case is handled by CheckDesignatedInitializer.\n    diagnoseInitOverride(ExistingInit, InitRange);\n  }\n\n  unsigned ExpectedNumInits = 0;\n  if (Index < IList->getNumInits()) {\n    if (auto *Init = dyn_cast_or_null<InitListExpr>(IList->getInit(Index)))\n      ExpectedNumInits = Init->getNumInits();\n    else\n      ExpectedNumInits = IList->getNumInits() - Index;\n  }\n\n  InitListExpr *Result =\n      createInitListExpr(CurrentObjectType, InitRange, ExpectedNumInits);\n\n  // Link this new initializer list into the structured initializer\n  // lists.\n  StructuredList->updateInit(SemaRef.Context, StructuredIndex, Result);\n  return Result;\n}\n\nInitListExpr *\nInitListChecker::createInitListExpr(QualType CurrentObjectType,\n                                    SourceRange InitRange,\n                                    unsigned ExpectedNumInits) {\n  InitListExpr *Result\n    = new (SemaRef.Context) InitListExpr(SemaRef.Context,\n                                         InitRange.getBegin(), None,\n                                         InitRange.getEnd());\n\n  QualType ResultType = CurrentObjectType;\n  if (!ResultType->isArrayType())\n    ResultType = ResultType.getNonLValueExprType(SemaRef.Context);\n  Result->setType(ResultType);\n\n  // Pre-allocate storage for the structured initializer list.\n  unsigned NumElements = 0;\n\n  if (const ArrayType *AType\n      = SemaRef.Context.getAsArrayType(CurrentObjectType)) {\n    if (const ConstantArrayType *CAType = dyn_cast<ConstantArrayType>(AType)) {\n      NumElements = CAType->getSize().getZExtValue();\n      // Simple heuristic so that we don't allocate a very large\n      // initializer with many empty entries at the end.\n      if (NumElements > ExpectedNumInits)\n        NumElements = 0;\n    }\n  } else if (const VectorType *VType = CurrentObjectType->getAs<VectorType>()) {\n    NumElements = VType->getNumElements();\n  } else if (CurrentObjectType->isRecordType()) {\n    NumElements = numStructUnionElements(CurrentObjectType);\n  }\n\n  Result->reserveInits(SemaRef.Context, NumElements);\n\n  return Result;\n}\n\n/// Update the initializer at index @p StructuredIndex within the\n/// structured initializer list to the value @p expr.\nvoid InitListChecker::UpdateStructuredListElement(InitListExpr *StructuredList,\n                                                  unsigned &StructuredIndex,\n                                                  Expr *expr) {\n  // No structured initializer list to update\n  if (!StructuredList)\n    return;\n\n  if (Expr *PrevInit = StructuredList->updateInit(SemaRef.Context,\n                                                  StructuredIndex, expr)) {\n    // This initializer overwrites a previous initializer.\n    // No need to diagnose when `expr` is nullptr because a more relevant\n    // diagnostic has already been issued and this diagnostic is potentially\n    // noise.\n    if (expr)\n      diagnoseInitOverride(PrevInit, expr->getSourceRange());\n  }\n\n  ++StructuredIndex;\n}\n\n/// Determine whether we can perform aggregate initialization for the purposes\n/// of overload resolution.\nbool Sema::CanPerformAggregateInitializationForOverloadResolution(\n    const InitializedEntity &Entity, InitListExpr *From) {\n  QualType Type = Entity.getType();\n  InitListChecker Check(*this, Entity, From, Type, /*VerifyOnly=*/true,\n                        /*TreatUnavailableAsInvalid=*/false,\n                        /*InOverloadResolution=*/true);\n  return !Check.HadError();\n}\n\n/// Check that the given Index expression is a valid array designator\n/// value. This is essentially just a wrapper around\n/// VerifyIntegerConstantExpression that also checks for negative values\n/// and produces a reasonable diagnostic if there is a\n/// failure. Returns the index expression, possibly with an implicit cast\n/// added, on success.  If everything went okay, Value will receive the\n/// value of the constant expression.\nstatic ExprResult\nCheckArrayDesignatorExpr(Sema &S, Expr *Index, llvm::APSInt &Value) {\n  SourceLocation Loc = Index->getBeginLoc();\n\n  // Make sure this is an integer constant expression.\n  ExprResult Result =\n      S.VerifyIntegerConstantExpression(Index, &Value, Sema::AllowFold);\n  if (Result.isInvalid())\n    return Result;\n\n  if (Value.isSigned() && Value.isNegative())\n    return S.Diag(Loc, diag::err_array_designator_negative)\n      << Value.toString(10) << Index->getSourceRange();\n\n  Value.setIsUnsigned(true);\n  return Result;\n}\n\nExprResult Sema::ActOnDesignatedInitializer(Designation &Desig,\n                                            SourceLocation EqualOrColonLoc,\n                                            bool GNUSyntax,\n                                            ExprResult Init) {\n  typedef DesignatedInitExpr::Designator ASTDesignator;\n\n  bool Invalid = false;\n  SmallVector<ASTDesignator, 32> Designators;\n  SmallVector<Expr *, 32> InitExpressions;\n\n  // Build designators and check array designator expressions.\n  for (unsigned Idx = 0; Idx < Desig.getNumDesignators(); ++Idx) {\n    const Designator &D = Desig.getDesignator(Idx);\n    switch (D.getKind()) {\n    case Designator::FieldDesignator:\n      Designators.push_back(ASTDesignator(D.getField(), D.getDotLoc(),\n                                          D.getFieldLoc()));\n      break;\n\n    case Designator::ArrayDesignator: {\n      Expr *Index = static_cast<Expr *>(D.getArrayIndex());\n      llvm::APSInt IndexValue;\n      if (!Index->isTypeDependent() && !Index->isValueDependent())\n        Index = CheckArrayDesignatorExpr(*this, Index, IndexValue).get();\n      if (!Index)\n        Invalid = true;\n      else {\n        Designators.push_back(ASTDesignator(InitExpressions.size(),\n                                            D.getLBracketLoc(),\n                                            D.getRBracketLoc()));\n        InitExpressions.push_back(Index);\n      }\n      break;\n    }\n\n    case Designator::ArrayRangeDesignator: {\n      Expr *StartIndex = static_cast<Expr *>(D.getArrayRangeStart());\n      Expr *EndIndex = static_cast<Expr *>(D.getArrayRangeEnd());\n      llvm::APSInt StartValue;\n      llvm::APSInt EndValue;\n      bool StartDependent = StartIndex->isTypeDependent() ||\n                            StartIndex->isValueDependent();\n      bool EndDependent = EndIndex->isTypeDependent() ||\n                          EndIndex->isValueDependent();\n      if (!StartDependent)\n        StartIndex =\n            CheckArrayDesignatorExpr(*this, StartIndex, StartValue).get();\n      if (!EndDependent)\n        EndIndex = CheckArrayDesignatorExpr(*this, EndIndex, EndValue).get();\n\n      if (!StartIndex || !EndIndex)\n        Invalid = true;\n      else {\n        // Make sure we're comparing values with the same bit width.\n        if (StartDependent || EndDependent) {\n          // Nothing to compute.\n        } else if (StartValue.getBitWidth() > EndValue.getBitWidth())\n          EndValue = EndValue.extend(StartValue.getBitWidth());\n        else if (StartValue.getBitWidth() < EndValue.getBitWidth())\n          StartValue = StartValue.extend(EndValue.getBitWidth());\n\n        if (!StartDependent && !EndDependent && EndValue < StartValue) {\n          Diag(D.getEllipsisLoc(), diag::err_array_designator_empty_range)\n            << StartValue.toString(10) << EndValue.toString(10)\n            << StartIndex->getSourceRange() << EndIndex->getSourceRange();\n          Invalid = true;\n        } else {\n          Designators.push_back(ASTDesignator(InitExpressions.size(),\n                                              D.getLBracketLoc(),\n                                              D.getEllipsisLoc(),\n                                              D.getRBracketLoc()));\n          InitExpressions.push_back(StartIndex);\n          InitExpressions.push_back(EndIndex);\n        }\n      }\n      break;\n    }\n    }\n  }\n\n  if (Invalid || Init.isInvalid())\n    return ExprError();\n\n  // Clear out the expressions within the designation.\n  Desig.ClearExprs(*this);\n\n  return DesignatedInitExpr::Create(Context, Designators, InitExpressions,\n                                    EqualOrColonLoc, GNUSyntax,\n                                    Init.getAs<Expr>());\n}\n\n//===----------------------------------------------------------------------===//\n// Initialization entity\n//===----------------------------------------------------------------------===//\n\nInitializedEntity::InitializedEntity(ASTContext &Context, unsigned Index,\n                                     const InitializedEntity &Parent)\n  : Parent(&Parent), Index(Index)\n{\n  if (const ArrayType *AT = Context.getAsArrayType(Parent.getType())) {\n    Kind = EK_ArrayElement;\n    Type = AT->getElementType();\n  } else if (const VectorType *VT = Parent.getType()->getAs<VectorType>()) {\n    Kind = EK_VectorElement;\n    Type = VT->getElementType();\n  } else {\n    const ComplexType *CT = Parent.getType()->getAs<ComplexType>();\n    assert(CT && \"Unexpected type\");\n    Kind = EK_ComplexElement;\n    Type = CT->getElementType();\n  }\n}\n\nInitializedEntity\nInitializedEntity::InitializeBase(ASTContext &Context,\n                                  const CXXBaseSpecifier *Base,\n                                  bool IsInheritedVirtualBase,\n                                  const InitializedEntity *Parent) {\n  InitializedEntity Result;\n  Result.Kind = EK_Base;\n  Result.Parent = Parent;\n  Result.Base = reinterpret_cast<uintptr_t>(Base);\n  if (IsInheritedVirtualBase)\n    Result.Base |= 0x01;\n\n  Result.Type = Base->getType();\n  return Result;\n}\n\nDeclarationName InitializedEntity::getName() const {\n  switch (getKind()) {\n  case EK_Parameter:\n  case EK_Parameter_CF_Audited: {\n    ParmVarDecl *D = reinterpret_cast<ParmVarDecl*>(Parameter & ~0x1);\n    return (D ? D->getDeclName() : DeclarationName());\n  }\n\n  case EK_Variable:\n  case EK_Member:\n  case EK_Binding:\n  case EK_TemplateParameter:\n    return Variable.VariableOrMember->getDeclName();\n\n  case EK_LambdaCapture:\n    return DeclarationName(Capture.VarID);\n\n  case EK_Result:\n  case EK_StmtExprResult:\n  case EK_Exception:\n  case EK_New:\n  case EK_Temporary:\n  case EK_Base:\n  case EK_Delegating:\n  case EK_ArrayElement:\n  case EK_VectorElement:\n  case EK_ComplexElement:\n  case EK_BlockElement:\n  case EK_LambdaToBlockConversionBlockElement:\n  case EK_CompoundLiteralInit:\n  case EK_RelatedResult:\n    return DeclarationName();\n  }\n\n  llvm_unreachable(\"Invalid EntityKind!\");\n}\n\nValueDecl *InitializedEntity::getDecl() const {\n  switch (getKind()) {\n  case EK_Variable:\n  case EK_Member:\n  case EK_Binding:\n  case EK_TemplateParameter:\n    return Variable.VariableOrMember;\n\n  case EK_Parameter:\n  case EK_Parameter_CF_Audited:\n    return reinterpret_cast<ParmVarDecl*>(Parameter & ~0x1);\n\n  case EK_Result:\n  case EK_StmtExprResult:\n  case EK_Exception:\n  case EK_New:\n  case EK_Temporary:\n  case EK_Base:\n  case EK_Delegating:\n  case EK_ArrayElement:\n  case EK_VectorElement:\n  case EK_ComplexElement:\n  case EK_BlockElement:\n  case EK_LambdaToBlockConversionBlockElement:\n  case EK_LambdaCapture:\n  case EK_CompoundLiteralInit:\n  case EK_RelatedResult:\n    return nullptr;\n  }\n\n  llvm_unreachable(\"Invalid EntityKind!\");\n}\n\nbool InitializedEntity::allowsNRVO() const {\n  switch (getKind()) {\n  case EK_Result:\n  case EK_Exception:\n    return LocAndNRVO.NRVO;\n\n  case EK_StmtExprResult:\n  case EK_Variable:\n  case EK_Parameter:\n  case EK_Parameter_CF_Audited:\n  case EK_TemplateParameter:\n  case EK_Member:\n  case EK_Binding:\n  case EK_New:\n  case EK_Temporary:\n  case EK_CompoundLiteralInit:\n  case EK_Base:\n  case EK_Delegating:\n  case EK_ArrayElement:\n  case EK_VectorElement:\n  case EK_ComplexElement:\n  case EK_BlockElement:\n  case EK_LambdaToBlockConversionBlockElement:\n  case EK_LambdaCapture:\n  case EK_RelatedResult:\n    break;\n  }\n\n  return false;\n}\n\nunsigned InitializedEntity::dumpImpl(raw_ostream &OS) const {\n  assert(getParent() != this);\n  unsigned Depth = getParent() ? getParent()->dumpImpl(OS) : 0;\n  for (unsigned I = 0; I != Depth; ++I)\n    OS << \"`-\";\n\n  switch (getKind()) {\n  case EK_Variable: OS << \"Variable\"; break;\n  case EK_Parameter: OS << \"Parameter\"; break;\n  case EK_Parameter_CF_Audited: OS << \"CF audited function Parameter\";\n    break;\n  case EK_TemplateParameter: OS << \"TemplateParameter\"; break;\n  case EK_Result: OS << \"Result\"; break;\n  case EK_StmtExprResult: OS << \"StmtExprResult\"; break;\n  case EK_Exception: OS << \"Exception\"; break;\n  case EK_Member: OS << \"Member\"; break;\n  case EK_Binding: OS << \"Binding\"; break;\n  case EK_New: OS << \"New\"; break;\n  case EK_Temporary: OS << \"Temporary\"; break;\n  case EK_CompoundLiteralInit: OS << \"CompoundLiteral\";break;\n  case EK_RelatedResult: OS << \"RelatedResult\"; break;\n  case EK_Base: OS << \"Base\"; break;\n  case EK_Delegating: OS << \"Delegating\"; break;\n  case EK_ArrayElement: OS << \"ArrayElement \" << Index; break;\n  case EK_VectorElement: OS << \"VectorElement \" << Index; break;\n  case EK_ComplexElement: OS << \"ComplexElement \" << Index; break;\n  case EK_BlockElement: OS << \"Block\"; break;\n  case EK_LambdaToBlockConversionBlockElement:\n    OS << \"Block (lambda)\";\n    break;\n  case EK_LambdaCapture:\n    OS << \"LambdaCapture \";\n    OS << DeclarationName(Capture.VarID);\n    break;\n  }\n\n  if (auto *D = getDecl()) {\n    OS << \" \";\n    D->printQualifiedName(OS);\n  }\n\n  OS << \" '\" << getType().getAsString() << \"'\\n\";\n\n  return Depth + 1;\n}\n\nLLVM_DUMP_METHOD void InitializedEntity::dump() const {\n  dumpImpl(llvm::errs());\n}\n\n//===----------------------------------------------------------------------===//\n// Initialization sequence\n//===----------------------------------------------------------------------===//\n\nvoid InitializationSequence::Step::Destroy() {\n  switch (Kind) {\n  case SK_ResolveAddressOfOverloadedFunction:\n  case SK_CastDerivedToBaseRValue:\n  case SK_CastDerivedToBaseXValue:\n  case SK_CastDerivedToBaseLValue:\n  case SK_BindReference:\n  case SK_BindReferenceToTemporary:\n  case SK_FinalCopy:\n  case SK_ExtraneousCopyToTemporary:\n  case SK_UserConversion:\n  case SK_QualificationConversionRValue:\n  case SK_QualificationConversionXValue:\n  case SK_QualificationConversionLValue:\n  case SK_FunctionReferenceConversion:\n  case SK_AtomicConversion:\n  case SK_ListInitialization:\n  case SK_UnwrapInitList:\n  case SK_RewrapInitList:\n  case SK_ConstructorInitialization:\n  case SK_ConstructorInitializationFromList:\n  case SK_ZeroInitialization:\n  case SK_CAssignment:\n  case SK_StringInit:\n  case SK_ObjCObjectConversion:\n  case SK_ArrayLoopIndex:\n  case SK_ArrayLoopInit:\n  case SK_ArrayInit:\n  case SK_GNUArrayInit:\n  case SK_ParenthesizedArrayInit:\n  case SK_PassByIndirectCopyRestore:\n  case SK_PassByIndirectRestore:\n  case SK_ProduceObjCObject:\n  case SK_StdInitializerList:\n  case SK_StdInitializerListConstructorCall:\n  case SK_OCLSamplerInit:\n  case SK_OCLZeroOpaqueType:\n    break;\n\n  case SK_ConversionSequence:\n  case SK_ConversionSequenceNoNarrowing:\n    delete ICS;\n  }\n}\n\nbool InitializationSequence::isDirectReferenceBinding() const {\n  // There can be some lvalue adjustments after the SK_BindReference step.\n  for (auto I = Steps.rbegin(); I != Steps.rend(); ++I) {\n    if (I->Kind == SK_BindReference)\n      return true;\n    if (I->Kind == SK_BindReferenceToTemporary)\n      return false;\n  }\n  return false;\n}\n\nbool InitializationSequence::isAmbiguous() const {\n  if (!Failed())\n    return false;\n\n  switch (getFailureKind()) {\n  case FK_TooManyInitsForReference:\n  case FK_ParenthesizedListInitForReference:\n  case FK_ArrayNeedsInitList:\n  case FK_ArrayNeedsInitListOrStringLiteral:\n  case FK_ArrayNeedsInitListOrWideStringLiteral:\n  case FK_NarrowStringIntoWideCharArray:\n  case FK_WideStringIntoCharArray:\n  case FK_IncompatWideStringIntoWideChar:\n  case FK_PlainStringIntoUTF8Char:\n  case FK_UTF8StringIntoPlainChar:\n  case FK_AddressOfOverloadFailed: // FIXME: Could do better\n  case FK_NonConstLValueReferenceBindingToTemporary:\n  case FK_NonConstLValueReferenceBindingToBitfield:\n  case FK_NonConstLValueReferenceBindingToVectorElement:\n  case FK_NonConstLValueReferenceBindingToMatrixElement:\n  case FK_NonConstLValueReferenceBindingToUnrelated:\n  case FK_RValueReferenceBindingToLValue:\n  case FK_ReferenceAddrspaceMismatchTemporary:\n  case FK_ReferenceInitDropsQualifiers:\n  case FK_ReferenceInitFailed:\n  case FK_ConversionFailed:\n  case FK_ConversionFromPropertyFailed:\n  case FK_TooManyInitsForScalar:\n  case FK_ParenthesizedListInitForScalar:\n  case FK_ReferenceBindingToInitList:\n  case FK_InitListBadDestinationType:\n  case FK_DefaultInitOfConst:\n  case FK_Incomplete:\n  case FK_ArrayTypeMismatch:\n  case FK_NonConstantArrayInit:\n  case FK_ListInitializationFailed:\n  case FK_VariableLengthArrayHasInitializer:\n  case FK_PlaceholderType:\n  case FK_ExplicitConstructor:\n  case FK_AddressOfUnaddressableFunction:\n    return false;\n\n  case FK_ReferenceInitOverloadFailed:\n  case FK_UserConversionOverloadFailed:\n  case FK_ConstructorOverloadFailed:\n  case FK_ListConstructorOverloadFailed:\n    return FailedOverloadResult == OR_Ambiguous;\n  }\n\n  llvm_unreachable(\"Invalid EntityKind!\");\n}\n\nbool InitializationSequence::isConstructorInitialization() const {\n  return !Steps.empty() && Steps.back().Kind == SK_ConstructorInitialization;\n}\n\nvoid\nInitializationSequence\n::AddAddressOverloadResolutionStep(FunctionDecl *Function,\n                                   DeclAccessPair Found,\n                                   bool HadMultipleCandidates) {\n  Step S;\n  S.Kind = SK_ResolveAddressOfOverloadedFunction;\n  S.Type = Function->getType();\n  S.Function.HadMultipleCandidates = HadMultipleCandidates;\n  S.Function.Function = Function;\n  S.Function.FoundDecl = Found;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddDerivedToBaseCastStep(QualType BaseType,\n                                                      ExprValueKind VK) {\n  Step S;\n  switch (VK) {\n  case VK_RValue: S.Kind = SK_CastDerivedToBaseRValue; break;\n  case VK_XValue: S.Kind = SK_CastDerivedToBaseXValue; break;\n  case VK_LValue: S.Kind = SK_CastDerivedToBaseLValue; break;\n  }\n  S.Type = BaseType;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddReferenceBindingStep(QualType T,\n                                                     bool BindingTemporary) {\n  Step S;\n  S.Kind = BindingTemporary? SK_BindReferenceToTemporary : SK_BindReference;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddFinalCopy(QualType T) {\n  Step S;\n  S.Kind = SK_FinalCopy;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddExtraneousCopyToTemporary(QualType T) {\n  Step S;\n  S.Kind = SK_ExtraneousCopyToTemporary;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid\nInitializationSequence::AddUserConversionStep(FunctionDecl *Function,\n                                              DeclAccessPair FoundDecl,\n                                              QualType T,\n                                              bool HadMultipleCandidates) {\n  Step S;\n  S.Kind = SK_UserConversion;\n  S.Type = T;\n  S.Function.HadMultipleCandidates = HadMultipleCandidates;\n  S.Function.Function = Function;\n  S.Function.FoundDecl = FoundDecl;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddQualificationConversionStep(QualType Ty,\n                                                            ExprValueKind VK) {\n  Step S;\n  S.Kind = SK_QualificationConversionRValue; // work around a gcc warning\n  switch (VK) {\n  case VK_RValue:\n    S.Kind = SK_QualificationConversionRValue;\n    break;\n  case VK_XValue:\n    S.Kind = SK_QualificationConversionXValue;\n    break;\n  case VK_LValue:\n    S.Kind = SK_QualificationConversionLValue;\n    break;\n  }\n  S.Type = Ty;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddFunctionReferenceConversionStep(QualType Ty) {\n  Step S;\n  S.Kind = SK_FunctionReferenceConversion;\n  S.Type = Ty;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddAtomicConversionStep(QualType Ty) {\n  Step S;\n  S.Kind = SK_AtomicConversion;\n  S.Type = Ty;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddConversionSequenceStep(\n    const ImplicitConversionSequence &ICS, QualType T,\n    bool TopLevelOfInitList) {\n  Step S;\n  S.Kind = TopLevelOfInitList ? SK_ConversionSequenceNoNarrowing\n                              : SK_ConversionSequence;\n  S.Type = T;\n  S.ICS = new ImplicitConversionSequence(ICS);\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddListInitializationStep(QualType T) {\n  Step S;\n  S.Kind = SK_ListInitialization;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddConstructorInitializationStep(\n    DeclAccessPair FoundDecl, CXXConstructorDecl *Constructor, QualType T,\n    bool HadMultipleCandidates, bool FromInitList, bool AsInitList) {\n  Step S;\n  S.Kind = FromInitList ? AsInitList ? SK_StdInitializerListConstructorCall\n                                     : SK_ConstructorInitializationFromList\n                        : SK_ConstructorInitialization;\n  S.Type = T;\n  S.Function.HadMultipleCandidates = HadMultipleCandidates;\n  S.Function.Function = Constructor;\n  S.Function.FoundDecl = FoundDecl;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddZeroInitializationStep(QualType T) {\n  Step S;\n  S.Kind = SK_ZeroInitialization;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddCAssignmentStep(QualType T) {\n  Step S;\n  S.Kind = SK_CAssignment;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddStringInitStep(QualType T) {\n  Step S;\n  S.Kind = SK_StringInit;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddObjCObjectConversionStep(QualType T) {\n  Step S;\n  S.Kind = SK_ObjCObjectConversion;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddArrayInitStep(QualType T, bool IsGNUExtension) {\n  Step S;\n  S.Kind = IsGNUExtension ? SK_GNUArrayInit : SK_ArrayInit;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddArrayInitLoopStep(QualType T, QualType EltT) {\n  Step S;\n  S.Kind = SK_ArrayLoopIndex;\n  S.Type = EltT;\n  Steps.insert(Steps.begin(), S);\n\n  S.Kind = SK_ArrayLoopInit;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddParenthesizedArrayInitStep(QualType T) {\n  Step S;\n  S.Kind = SK_ParenthesizedArrayInit;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddPassByIndirectCopyRestoreStep(QualType type,\n                                                              bool shouldCopy) {\n  Step s;\n  s.Kind = (shouldCopy ? SK_PassByIndirectCopyRestore\n                       : SK_PassByIndirectRestore);\n  s.Type = type;\n  Steps.push_back(s);\n}\n\nvoid InitializationSequence::AddProduceObjCObjectStep(QualType T) {\n  Step S;\n  S.Kind = SK_ProduceObjCObject;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddStdInitializerListConstructionStep(QualType T) {\n  Step S;\n  S.Kind = SK_StdInitializerList;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddOCLSamplerInitStep(QualType T) {\n  Step S;\n  S.Kind = SK_OCLSamplerInit;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::AddOCLZeroOpaqueTypeStep(QualType T) {\n  Step S;\n  S.Kind = SK_OCLZeroOpaqueType;\n  S.Type = T;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::RewrapReferenceInitList(QualType T,\n                                                     InitListExpr *Syntactic) {\n  assert(Syntactic->getNumInits() == 1 &&\n         \"Can only rewrap trivial init lists.\");\n  Step S;\n  S.Kind = SK_UnwrapInitList;\n  S.Type = Syntactic->getInit(0)->getType();\n  Steps.insert(Steps.begin(), S);\n\n  S.Kind = SK_RewrapInitList;\n  S.Type = T;\n  S.WrappingSyntacticList = Syntactic;\n  Steps.push_back(S);\n}\n\nvoid InitializationSequence::SetOverloadFailure(FailureKind Failure,\n                                                OverloadingResult Result) {\n  setSequenceKind(FailedSequence);\n  this->Failure = Failure;\n  this->FailedOverloadResult = Result;\n}\n\n//===----------------------------------------------------------------------===//\n// Attempt initialization\n//===----------------------------------------------------------------------===//\n\n/// Tries to add a zero initializer. Returns true if that worked.\nstatic bool\nmaybeRecoverWithZeroInitialization(Sema &S, InitializationSequence &Sequence,\n                                   const InitializedEntity &Entity) {\n  if (Entity.getKind() != InitializedEntity::EK_Variable)\n    return false;\n\n  VarDecl *VD = cast<VarDecl>(Entity.getDecl());\n  if (VD->getInit() || VD->getEndLoc().isMacroID())\n    return false;\n\n  QualType VariableTy = VD->getType().getCanonicalType();\n  SourceLocation Loc = S.getLocForEndOfToken(VD->getEndLoc());\n  std::string Init = S.getFixItZeroInitializerForType(VariableTy, Loc);\n  if (!Init.empty()) {\n    Sequence.AddZeroInitializationStep(Entity.getType());\n    Sequence.SetZeroInitializationFixit(Init, Loc);\n    return true;\n  }\n  return false;\n}\n\nstatic void MaybeProduceObjCObject(Sema &S,\n                                   InitializationSequence &Sequence,\n                                   const InitializedEntity &Entity) {\n  if (!S.getLangOpts().ObjCAutoRefCount) return;\n\n  /// When initializing a parameter, produce the value if it's marked\n  /// __attribute__((ns_consumed)).\n  if (Entity.isParameterKind()) {\n    if (!Entity.isParameterConsumed())\n      return;\n\n    assert(Entity.getType()->isObjCRetainableType() &&\n           \"consuming an object of unretainable type?\");\n    Sequence.AddProduceObjCObjectStep(Entity.getType());\n\n  /// When initializing a return value, if the return type is a\n  /// retainable type, then returns need to immediately retain the\n  /// object.  If an autorelease is required, it will be done at the\n  /// last instant.\n  } else if (Entity.getKind() == InitializedEntity::EK_Result ||\n             Entity.getKind() == InitializedEntity::EK_StmtExprResult) {\n    if (!Entity.getType()->isObjCRetainableType())\n      return;\n\n    Sequence.AddProduceObjCObjectStep(Entity.getType());\n  }\n}\n\nstatic void TryListInitialization(Sema &S,\n                                  const InitializedEntity &Entity,\n                                  const InitializationKind &Kind,\n                                  InitListExpr *InitList,\n                                  InitializationSequence &Sequence,\n                                  bool TreatUnavailableAsInvalid);\n\n/// When initializing from init list via constructor, handle\n/// initialization of an object of type std::initializer_list<T>.\n///\n/// \\return true if we have handled initialization of an object of type\n/// std::initializer_list<T>, false otherwise.\nstatic bool TryInitializerListConstruction(Sema &S,\n                                           InitListExpr *List,\n                                           QualType DestType,\n                                           InitializationSequence &Sequence,\n                                           bool TreatUnavailableAsInvalid) {\n  QualType E;\n  if (!S.isStdInitializerList(DestType, &E))\n    return false;\n\n  if (!S.isCompleteType(List->getExprLoc(), E)) {\n    Sequence.setIncompleteTypeFailure(E);\n    return true;\n  }\n\n  // Try initializing a temporary array from the init list.\n  QualType ArrayType = S.Context.getConstantArrayType(\n      E.withConst(),\n      llvm::APInt(S.Context.getTypeSize(S.Context.getSizeType()),\n                  List->getNumInits()),\n      nullptr, clang::ArrayType::Normal, 0);\n  InitializedEntity HiddenArray =\n      InitializedEntity::InitializeTemporary(ArrayType);\n  InitializationKind Kind = InitializationKind::CreateDirectList(\n      List->getExprLoc(), List->getBeginLoc(), List->getEndLoc());\n  TryListInitialization(S, HiddenArray, Kind, List, Sequence,\n                        TreatUnavailableAsInvalid);\n  if (Sequence)\n    Sequence.AddStdInitializerListConstructionStep(DestType);\n  return true;\n}\n\n/// Determine if the constructor has the signature of a copy or move\n/// constructor for the type T of the class in which it was found. That is,\n/// determine if its first parameter is of type T or reference to (possibly\n/// cv-qualified) T.\nstatic bool hasCopyOrMoveCtorParam(ASTContext &Ctx,\n                                   const ConstructorInfo &Info) {\n  if (Info.Constructor->getNumParams() == 0)\n    return false;\n\n  QualType ParmT =\n      Info.Constructor->getParamDecl(0)->getType().getNonReferenceType();\n  QualType ClassT =\n      Ctx.getRecordType(cast<CXXRecordDecl>(Info.FoundDecl->getDeclContext()));\n\n  return Ctx.hasSameUnqualifiedType(ParmT, ClassT);\n}\n\nstatic OverloadingResult\nResolveConstructorOverload(Sema &S, SourceLocation DeclLoc,\n                           MultiExprArg Args,\n                           OverloadCandidateSet &CandidateSet,\n                           QualType DestType,\n                           DeclContext::lookup_result Ctors,\n                           OverloadCandidateSet::iterator &Best,\n                           bool CopyInitializing, bool AllowExplicit,\n                           bool OnlyListConstructors, bool IsListInit,\n                           bool SecondStepOfCopyInit = false) {\n  CandidateSet.clear(OverloadCandidateSet::CSK_InitByConstructor);\n  CandidateSet.setDestAS(DestType.getQualifiers().getAddressSpace());\n\n  for (NamedDecl *D : Ctors) {\n    auto Info = getConstructorInfo(D);\n    if (!Info.Constructor || Info.Constructor->isInvalidDecl())\n      continue;\n\n    if (OnlyListConstructors && !S.isInitListConstructor(Info.Constructor))\n      continue;\n\n    // C++11 [over.best.ics]p4:\n    //   ... and the constructor or user-defined conversion function is a\n    //   candidate by\n    //   - 13.3.1.3, when the argument is the temporary in the second step\n    //     of a class copy-initialization, or\n    //   - 13.3.1.4, 13.3.1.5, or 13.3.1.6 (in all cases), [not handled here]\n    //   - the second phase of 13.3.1.7 when the initializer list has exactly\n    //     one element that is itself an initializer list, and the target is\n    //     the first parameter of a constructor of class X, and the conversion\n    //     is to X or reference to (possibly cv-qualified X),\n    //   user-defined conversion sequences are not considered.\n    bool SuppressUserConversions =\n        SecondStepOfCopyInit ||\n        (IsListInit && Args.size() == 1 && isa<InitListExpr>(Args[0]) &&\n         hasCopyOrMoveCtorParam(S.Context, Info));\n\n    if (Info.ConstructorTmpl)\n      S.AddTemplateOverloadCandidate(\n          Info.ConstructorTmpl, Info.FoundDecl,\n          /*ExplicitArgs*/ nullptr, Args, CandidateSet, SuppressUserConversions,\n          /*PartialOverloading=*/false, AllowExplicit);\n    else {\n      // C++ [over.match.copy]p1:\n      //   - When initializing a temporary to be bound to the first parameter\n      //     of a constructor [for type T] that takes a reference to possibly\n      //     cv-qualified T as its first argument, called with a single\n      //     argument in the context of direct-initialization, explicit\n      //     conversion functions are also considered.\n      // FIXME: What if a constructor template instantiates to such a signature?\n      bool AllowExplicitConv = AllowExplicit && !CopyInitializing &&\n                               Args.size() == 1 &&\n                               hasCopyOrMoveCtorParam(S.Context, Info);\n      S.AddOverloadCandidate(Info.Constructor, Info.FoundDecl, Args,\n                             CandidateSet, SuppressUserConversions,\n                             /*PartialOverloading=*/false, AllowExplicit,\n                             AllowExplicitConv);\n    }\n  }\n\n  // FIXME: Work around a bug in C++17 guaranteed copy elision.\n  //\n  // When initializing an object of class type T by constructor\n  // ([over.match.ctor]) or by list-initialization ([over.match.list])\n  // from a single expression of class type U, conversion functions of\n  // U that convert to the non-reference type cv T are candidates.\n  // Explicit conversion functions are only candidates during\n  // direct-initialization.\n  //\n  // Note: SecondStepOfCopyInit is only ever true in this case when\n  // evaluating whether to produce a C++98 compatibility warning.\n  if (S.getLangOpts().CPlusPlus17 && Args.size() == 1 &&\n      !SecondStepOfCopyInit) {\n    Expr *Initializer = Args[0];\n    auto *SourceRD = Initializer->getType()->getAsCXXRecordDecl();\n    if (SourceRD && S.isCompleteType(DeclLoc, Initializer->getType())) {\n      const auto &Conversions = SourceRD->getVisibleConversionFunctions();\n      for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n        NamedDecl *D = *I;\n        CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(D->getDeclContext());\n        D = D->getUnderlyingDecl();\n\n        FunctionTemplateDecl *ConvTemplate = dyn_cast<FunctionTemplateDecl>(D);\n        CXXConversionDecl *Conv;\n        if (ConvTemplate)\n          Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n        else\n          Conv = cast<CXXConversionDecl>(D);\n\n        if (ConvTemplate)\n          S.AddTemplateConversionCandidate(\n              ConvTemplate, I.getPair(), ActingDC, Initializer, DestType,\n              CandidateSet, AllowExplicit, AllowExplicit,\n              /*AllowResultConversion*/ false);\n        else\n          S.AddConversionCandidate(Conv, I.getPair(), ActingDC, Initializer,\n                                   DestType, CandidateSet, AllowExplicit,\n                                   AllowExplicit,\n                                   /*AllowResultConversion*/ false);\n      }\n    }\n  }\n\n  // Perform overload resolution and return the result.\n  return CandidateSet.BestViableFunction(S, DeclLoc, Best);\n}\n\n/// Attempt initialization by constructor (C++ [dcl.init]), which\n/// enumerates the constructors of the initialized entity and performs overload\n/// resolution to select the best.\n/// \\param DestType       The destination class type.\n/// \\param DestArrayType  The destination type, which is either DestType or\n///                       a (possibly multidimensional) array of DestType.\n/// \\param IsListInit     Is this list-initialization?\n/// \\param IsInitListCopy Is this non-list-initialization resulting from a\n///                       list-initialization from {x} where x is the same\n///                       type as the entity?\nstatic void TryConstructorInitialization(Sema &S,\n                                         const InitializedEntity &Entity,\n                                         const InitializationKind &Kind,\n                                         MultiExprArg Args, QualType DestType,\n                                         QualType DestArrayType,\n                                         InitializationSequence &Sequence,\n                                         bool IsListInit = false,\n                                         bool IsInitListCopy = false) {\n  assert(((!IsListInit && !IsInitListCopy) ||\n          (Args.size() == 1 && isa<InitListExpr>(Args[0]))) &&\n         \"IsListInit/IsInitListCopy must come with a single initializer list \"\n         \"argument.\");\n  InitListExpr *ILE =\n      (IsListInit || IsInitListCopy) ? cast<InitListExpr>(Args[0]) : nullptr;\n  MultiExprArg UnwrappedArgs =\n      ILE ? MultiExprArg(ILE->getInits(), ILE->getNumInits()) : Args;\n\n  // The type we're constructing needs to be complete.\n  if (!S.isCompleteType(Kind.getLocation(), DestType)) {\n    Sequence.setIncompleteTypeFailure(DestType);\n    return;\n  }\n\n  // C++17 [dcl.init]p17:\n  //     - If the initializer expression is a prvalue and the cv-unqualified\n  //       version of the source type is the same class as the class of the\n  //       destination, the initializer expression is used to initialize the\n  //       destination object.\n  // Per DR (no number yet), this does not apply when initializing a base\n  // class or delegating to another constructor from a mem-initializer.\n  // ObjC++: Lambda captured by the block in the lambda to block conversion\n  // should avoid copy elision.\n  if (S.getLangOpts().CPlusPlus17 &&\n      Entity.getKind() != InitializedEntity::EK_Base &&\n      Entity.getKind() != InitializedEntity::EK_Delegating &&\n      Entity.getKind() !=\n          InitializedEntity::EK_LambdaToBlockConversionBlockElement &&\n      UnwrappedArgs.size() == 1 && UnwrappedArgs[0]->isRValue() &&\n      S.Context.hasSameUnqualifiedType(UnwrappedArgs[0]->getType(), DestType)) {\n    // Convert qualifications if necessary.\n    Sequence.AddQualificationConversionStep(DestType, VK_RValue);\n    if (ILE)\n      Sequence.RewrapReferenceInitList(DestType, ILE);\n    return;\n  }\n\n  const RecordType *DestRecordType = DestType->getAs<RecordType>();\n  assert(DestRecordType && \"Constructor initialization requires record type\");\n  CXXRecordDecl *DestRecordDecl\n    = cast<CXXRecordDecl>(DestRecordType->getDecl());\n\n  // Build the candidate set directly in the initialization sequence\n  // structure, so that it will persist if we fail.\n  OverloadCandidateSet &CandidateSet = Sequence.getFailedCandidateSet();\n\n  // Determine whether we are allowed to call explicit constructors or\n  // explicit conversion operators.\n  bool AllowExplicit = Kind.AllowExplicit() || IsListInit;\n  bool CopyInitialization = Kind.getKind() == InitializationKind::IK_Copy;\n\n  //   - Otherwise, if T is a class type, constructors are considered. The\n  //     applicable constructors are enumerated, and the best one is chosen\n  //     through overload resolution.\n  DeclContext::lookup_result Ctors = S.LookupConstructors(DestRecordDecl);\n\n  OverloadingResult Result = OR_No_Viable_Function;\n  OverloadCandidateSet::iterator Best;\n  bool AsInitializerList = false;\n\n  // C++11 [over.match.list]p1, per DR1467:\n  //   When objects of non-aggregate type T are list-initialized, such that\n  //   8.5.4 [dcl.init.list] specifies that overload resolution is performed\n  //   according to the rules in this section, overload resolution selects\n  //   the constructor in two phases:\n  //\n  //   - Initially, the candidate functions are the initializer-list\n  //     constructors of the class T and the argument list consists of the\n  //     initializer list as a single argument.\n  if (IsListInit) {\n    AsInitializerList = true;\n\n    // If the initializer list has no elements and T has a default constructor,\n    // the first phase is omitted.\n    if (!(UnwrappedArgs.empty() && S.LookupDefaultConstructor(DestRecordDecl)))\n      Result = ResolveConstructorOverload(S, Kind.getLocation(), Args,\n                                          CandidateSet, DestType, Ctors, Best,\n                                          CopyInitialization, AllowExplicit,\n                                          /*OnlyListConstructors=*/true,\n                                          IsListInit);\n  }\n\n  // C++11 [over.match.list]p1:\n  //   - If no viable initializer-list constructor is found, overload resolution\n  //     is performed again, where the candidate functions are all the\n  //     constructors of the class T and the argument list consists of the\n  //     elements of the initializer list.\n  if (Result == OR_No_Viable_Function) {\n    AsInitializerList = false;\n    Result = ResolveConstructorOverload(S, Kind.getLocation(), UnwrappedArgs,\n                                        CandidateSet, DestType, Ctors, Best,\n                                        CopyInitialization, AllowExplicit,\n                                        /*OnlyListConstructors=*/false,\n                                        IsListInit);\n  }\n  if (Result) {\n    Sequence.SetOverloadFailure(\n        IsListInit ? InitializationSequence::FK_ListConstructorOverloadFailed\n                   : InitializationSequence::FK_ConstructorOverloadFailed,\n        Result);\n\n    if (Result != OR_Deleted)\n      return;\n  }\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // In C++17, ResolveConstructorOverload can select a conversion function\n  // instead of a constructor.\n  if (auto *CD = dyn_cast<CXXConversionDecl>(Best->Function)) {\n    // Add the user-defined conversion step that calls the conversion function.\n    QualType ConvType = CD->getConversionType();\n    assert(S.Context.hasSameUnqualifiedType(ConvType, DestType) &&\n           \"should not have selected this conversion function\");\n    Sequence.AddUserConversionStep(CD, Best->FoundDecl, ConvType,\n                                   HadMultipleCandidates);\n    if (!S.Context.hasSameType(ConvType, DestType))\n      Sequence.AddQualificationConversionStep(DestType, VK_RValue);\n    if (IsListInit)\n      Sequence.RewrapReferenceInitList(Entity.getType(), ILE);\n    return;\n  }\n\n  CXXConstructorDecl *CtorDecl = cast<CXXConstructorDecl>(Best->Function);\n  if (Result != OR_Deleted) {\n    // C++11 [dcl.init]p6:\n    //   If a program calls for the default initialization of an object\n    //   of a const-qualified type T, T shall be a class type with a\n    //   user-provided default constructor.\n    // C++ core issue 253 proposal:\n    //   If the implicit default constructor initializes all subobjects, no\n    //   initializer should be required.\n    // The 253 proposal is for example needed to process libstdc++ headers\n    // in 5.x.\n    if (Kind.getKind() == InitializationKind::IK_Default &&\n        Entity.getType().isConstQualified()) {\n      if (!CtorDecl->getParent()->allowConstDefaultInit()) {\n        if (!maybeRecoverWithZeroInitialization(S, Sequence, Entity))\n          Sequence.SetFailed(InitializationSequence::FK_DefaultInitOfConst);\n        return;\n      }\n    }\n\n    // C++11 [over.match.list]p1:\n    //   In copy-list-initialization, if an explicit constructor is chosen, the\n    //   initializer is ill-formed.\n    if (IsListInit && !Kind.AllowExplicit() && CtorDecl->isExplicit()) {\n      Sequence.SetFailed(InitializationSequence::FK_ExplicitConstructor);\n      return;\n    }\n  }\n\n  // [class.copy.elision]p3:\n  // In some copy-initialization contexts, a two-stage overload resolution\n  // is performed.\n  // If the first overload resolution selects a deleted function, we also\n  // need the initialization sequence to decide whether to perform the second\n  // overload resolution.\n  // For deleted functions in other contexts, there is no need to get the\n  // initialization sequence.\n  if (Result == OR_Deleted && Kind.getKind() != InitializationKind::IK_Copy)\n    return;\n\n  // Add the constructor initialization step. Any cv-qualification conversion is\n  // subsumed by the initialization.\n  Sequence.AddConstructorInitializationStep(\n      Best->FoundDecl, CtorDecl, DestArrayType, HadMultipleCandidates,\n      IsListInit | IsInitListCopy, AsInitializerList);\n}\n\nstatic bool\nResolveOverloadedFunctionForReferenceBinding(Sema &S,\n                                             Expr *Initializer,\n                                             QualType &SourceType,\n                                             QualType &UnqualifiedSourceType,\n                                             QualType UnqualifiedTargetType,\n                                             InitializationSequence &Sequence) {\n  if (S.Context.getCanonicalType(UnqualifiedSourceType) ==\n        S.Context.OverloadTy) {\n    DeclAccessPair Found;\n    bool HadMultipleCandidates = false;\n    if (FunctionDecl *Fn\n        = S.ResolveAddressOfOverloadedFunction(Initializer,\n                                               UnqualifiedTargetType,\n                                               false, Found,\n                                               &HadMultipleCandidates)) {\n      Sequence.AddAddressOverloadResolutionStep(Fn, Found,\n                                                HadMultipleCandidates);\n      SourceType = Fn->getType();\n      UnqualifiedSourceType = SourceType.getUnqualifiedType();\n    } else if (!UnqualifiedTargetType->isRecordType()) {\n      Sequence.SetFailed(InitializationSequence::FK_AddressOfOverloadFailed);\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic void TryReferenceInitializationCore(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           const InitializationKind &Kind,\n                                           Expr *Initializer,\n                                           QualType cv1T1, QualType T1,\n                                           Qualifiers T1Quals,\n                                           QualType cv2T2, QualType T2,\n                                           Qualifiers T2Quals,\n                                           InitializationSequence &Sequence);\n\nstatic void TryValueInitialization(Sema &S,\n                                   const InitializedEntity &Entity,\n                                   const InitializationKind &Kind,\n                                   InitializationSequence &Sequence,\n                                   InitListExpr *InitList = nullptr);\n\n/// Attempt list initialization of a reference.\nstatic void TryReferenceListInitialization(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           const InitializationKind &Kind,\n                                           InitListExpr *InitList,\n                                           InitializationSequence &Sequence,\n                                           bool TreatUnavailableAsInvalid) {\n  // First, catch C++03 where this isn't possible.\n  if (!S.getLangOpts().CPlusPlus11) {\n    Sequence.SetFailed(InitializationSequence::FK_ReferenceBindingToInitList);\n    return;\n  }\n  // Can't reference initialize a compound literal.\n  if (Entity.getKind() == InitializedEntity::EK_CompoundLiteralInit) {\n    Sequence.SetFailed(InitializationSequence::FK_ReferenceBindingToInitList);\n    return;\n  }\n\n  QualType DestType = Entity.getType();\n  QualType cv1T1 = DestType->castAs<ReferenceType>()->getPointeeType();\n  Qualifiers T1Quals;\n  QualType T1 = S.Context.getUnqualifiedArrayType(cv1T1, T1Quals);\n\n  // Reference initialization via an initializer list works thus:\n  // If the initializer list consists of a single element that is\n  // reference-related to the referenced type, bind directly to that element\n  // (possibly creating temporaries).\n  // Otherwise, initialize a temporary with the initializer list and\n  // bind to that.\n  if (InitList->getNumInits() == 1) {\n    Expr *Initializer = InitList->getInit(0);\n    QualType cv2T2 = S.getCompletedType(Initializer);\n    Qualifiers T2Quals;\n    QualType T2 = S.Context.getUnqualifiedArrayType(cv2T2, T2Quals);\n\n    // If this fails, creating a temporary wouldn't work either.\n    if (ResolveOverloadedFunctionForReferenceBinding(S, Initializer, cv2T2, T2,\n                                                     T1, Sequence))\n      return;\n\n    SourceLocation DeclLoc = Initializer->getBeginLoc();\n    Sema::ReferenceCompareResult RefRelationship\n      = S.CompareReferenceRelationship(DeclLoc, cv1T1, cv2T2);\n    if (RefRelationship >= Sema::Ref_Related) {\n      // Try to bind the reference here.\n      TryReferenceInitializationCore(S, Entity, Kind, Initializer, cv1T1, T1,\n                                     T1Quals, cv2T2, T2, T2Quals, Sequence);\n      if (Sequence)\n        Sequence.RewrapReferenceInitList(cv1T1, InitList);\n      return;\n    }\n\n    // Update the initializer if we've resolved an overloaded function.\n    if (Sequence.step_begin() != Sequence.step_end())\n      Sequence.RewrapReferenceInitList(cv1T1, InitList);\n  }\n  // Perform address space compatibility check.\n  QualType cv1T1IgnoreAS = cv1T1;\n  if (T1Quals.hasAddressSpace()) {\n    Qualifiers T2Quals;\n    (void)S.Context.getUnqualifiedArrayType(InitList->getType(), T2Quals);\n    if (!T1Quals.isAddressSpaceSupersetOf(T2Quals)) {\n      Sequence.SetFailed(\n          InitializationSequence::FK_ReferenceInitDropsQualifiers);\n      return;\n    }\n    // Ignore address space of reference type at this point and perform address\n    // space conversion after the reference binding step.\n    cv1T1IgnoreAS =\n        S.Context.getQualifiedType(T1, T1Quals.withoutAddressSpace());\n  }\n  // Not reference-related. Create a temporary and bind to that.\n  InitializedEntity TempEntity =\n      InitializedEntity::InitializeTemporary(cv1T1IgnoreAS);\n\n  TryListInitialization(S, TempEntity, Kind, InitList, Sequence,\n                        TreatUnavailableAsInvalid);\n  if (Sequence) {\n    if (DestType->isRValueReferenceType() ||\n        (T1Quals.hasConst() && !T1Quals.hasVolatile())) {\n      Sequence.AddReferenceBindingStep(cv1T1IgnoreAS,\n                                       /*BindingTemporary=*/true);\n      if (T1Quals.hasAddressSpace())\n        Sequence.AddQualificationConversionStep(\n            cv1T1, DestType->isRValueReferenceType() ? VK_XValue : VK_LValue);\n    } else\n      Sequence.SetFailed(\n          InitializationSequence::FK_NonConstLValueReferenceBindingToTemporary);\n  }\n}\n\n/// Attempt list initialization (C++0x [dcl.init.list])\nstatic void TryListInitialization(Sema &S,\n                                  const InitializedEntity &Entity,\n                                  const InitializationKind &Kind,\n                                  InitListExpr *InitList,\n                                  InitializationSequence &Sequence,\n                                  bool TreatUnavailableAsInvalid) {\n  QualType DestType = Entity.getType();\n\n  // C++ doesn't allow scalar initialization with more than one argument.\n  // But C99 complex numbers are scalars and it makes sense there.\n  if (S.getLangOpts().CPlusPlus && DestType->isScalarType() &&\n      !DestType->isAnyComplexType() && InitList->getNumInits() > 1) {\n    Sequence.SetFailed(InitializationSequence::FK_TooManyInitsForScalar);\n    return;\n  }\n  if (DestType->isReferenceType()) {\n    TryReferenceListInitialization(S, Entity, Kind, InitList, Sequence,\n                                   TreatUnavailableAsInvalid);\n    return;\n  }\n\n  if (DestType->isRecordType() &&\n      !S.isCompleteType(InitList->getBeginLoc(), DestType)) {\n    Sequence.setIncompleteTypeFailure(DestType);\n    return;\n  }\n\n  // C++11 [dcl.init.list]p3, per DR1467:\n  // - If T is a class type and the initializer list has a single element of\n  //   type cv U, where U is T or a class derived from T, the object is\n  //   initialized from that element (by copy-initialization for\n  //   copy-list-initialization, or by direct-initialization for\n  //   direct-list-initialization).\n  // - Otherwise, if T is a character array and the initializer list has a\n  //   single element that is an appropriately-typed string literal\n  //   (8.5.2 [dcl.init.string]), initialization is performed as described\n  //   in that section.\n  // - Otherwise, if T is an aggregate, [...] (continue below).\n  if (S.getLangOpts().CPlusPlus11 && InitList->getNumInits() == 1) {\n    if (DestType->isRecordType()) {\n      QualType InitType = InitList->getInit(0)->getType();\n      if (S.Context.hasSameUnqualifiedType(InitType, DestType) ||\n          S.IsDerivedFrom(InitList->getBeginLoc(), InitType, DestType)) {\n        Expr *InitListAsExpr = InitList;\n        TryConstructorInitialization(S, Entity, Kind, InitListAsExpr, DestType,\n                                     DestType, Sequence,\n                                     /*InitListSyntax*/false,\n                                     /*IsInitListCopy*/true);\n        return;\n      }\n    }\n    if (const ArrayType *DestAT = S.Context.getAsArrayType(DestType)) {\n      Expr *SubInit[1] = {InitList->getInit(0)};\n      if (!isa<VariableArrayType>(DestAT) &&\n          IsStringInit(SubInit[0], DestAT, S.Context) == SIF_None) {\n        InitializationKind SubKind =\n            Kind.getKind() == InitializationKind::IK_DirectList\n                ? InitializationKind::CreateDirect(Kind.getLocation(),\n                                                   InitList->getLBraceLoc(),\n                                                   InitList->getRBraceLoc())\n                : Kind;\n        Sequence.InitializeFrom(S, Entity, SubKind, SubInit,\n                                /*TopLevelOfInitList*/ true,\n                                TreatUnavailableAsInvalid);\n\n        // TryStringLiteralInitialization() (in InitializeFrom()) will fail if\n        // the element is not an appropriately-typed string literal, in which\n        // case we should proceed as in C++11 (below).\n        if (Sequence) {\n          Sequence.RewrapReferenceInitList(Entity.getType(), InitList);\n          return;\n        }\n      }\n    }\n  }\n\n  // C++11 [dcl.init.list]p3:\n  //   - If T is an aggregate, aggregate initialization is performed.\n  if ((DestType->isRecordType() && !DestType->isAggregateType()) ||\n      (S.getLangOpts().CPlusPlus11 &&\n       S.isStdInitializerList(DestType, nullptr))) {\n    if (S.getLangOpts().CPlusPlus11) {\n      //   - Otherwise, if the initializer list has no elements and T is a\n      //     class type with a default constructor, the object is\n      //     value-initialized.\n      if (InitList->getNumInits() == 0) {\n        CXXRecordDecl *RD = DestType->getAsCXXRecordDecl();\n        if (S.LookupDefaultConstructor(RD)) {\n          TryValueInitialization(S, Entity, Kind, Sequence, InitList);\n          return;\n        }\n      }\n\n      //   - Otherwise, if T is a specialization of std::initializer_list<E>,\n      //     an initializer_list object constructed [...]\n      if (TryInitializerListConstruction(S, InitList, DestType, Sequence,\n                                         TreatUnavailableAsInvalid))\n        return;\n\n      //   - Otherwise, if T is a class type, constructors are considered.\n      Expr *InitListAsExpr = InitList;\n      TryConstructorInitialization(S, Entity, Kind, InitListAsExpr, DestType,\n                                   DestType, Sequence, /*InitListSyntax*/true);\n    } else\n      Sequence.SetFailed(InitializationSequence::FK_InitListBadDestinationType);\n    return;\n  }\n\n  if (S.getLangOpts().CPlusPlus && !DestType->isAggregateType() &&\n      InitList->getNumInits() == 1) {\n    Expr *E = InitList->getInit(0);\n\n    //   - Otherwise, if T is an enumeration with a fixed underlying type,\n    //     the initializer-list has a single element v, and the initialization\n    //     is direct-list-initialization, the object is initialized with the\n    //     value T(v); if a narrowing conversion is required to convert v to\n    //     the underlying type of T, the program is ill-formed.\n    auto *ET = DestType->getAs<EnumType>();\n    if (S.getLangOpts().CPlusPlus17 &&\n        Kind.getKind() == InitializationKind::IK_DirectList &&\n        ET && ET->getDecl()->isFixed() &&\n        !S.Context.hasSameUnqualifiedType(E->getType(), DestType) &&\n        (E->getType()->isIntegralOrEnumerationType() ||\n         E->getType()->isFloatingType())) {\n      // There are two ways that T(v) can work when T is an enumeration type.\n      // If there is either an implicit conversion sequence from v to T or\n      // a conversion function that can convert from v to T, then we use that.\n      // Otherwise, if v is of integral, enumeration, or floating-point type,\n      // it is converted to the enumeration type via its underlying type.\n      // There is no overlap possible between these two cases (except when the\n      // source value is already of the destination type), and the first\n      // case is handled by the general case for single-element lists below.\n      ImplicitConversionSequence ICS;\n      ICS.setStandard();\n      ICS.Standard.setAsIdentityConversion();\n      if (!E->isRValue())\n        ICS.Standard.First = ICK_Lvalue_To_Rvalue;\n      // If E is of a floating-point type, then the conversion is ill-formed\n      // due to narrowing, but go through the motions in order to produce the\n      // right diagnostic.\n      ICS.Standard.Second = E->getType()->isFloatingType()\n                                ? ICK_Floating_Integral\n                                : ICK_Integral_Conversion;\n      ICS.Standard.setFromType(E->getType());\n      ICS.Standard.setToType(0, E->getType());\n      ICS.Standard.setToType(1, DestType);\n      ICS.Standard.setToType(2, DestType);\n      Sequence.AddConversionSequenceStep(ICS, ICS.Standard.getToType(2),\n                                         /*TopLevelOfInitList*/true);\n      Sequence.RewrapReferenceInitList(Entity.getType(), InitList);\n      return;\n    }\n\n    //   - Otherwise, if the initializer list has a single element of type E\n    //     [...references are handled above...], the object or reference is\n    //     initialized from that element (by copy-initialization for\n    //     copy-list-initialization, or by direct-initialization for\n    //     direct-list-initialization); if a narrowing conversion is required\n    //     to convert the element to T, the program is ill-formed.\n    //\n    // Per core-24034, this is direct-initialization if we were performing\n    // direct-list-initialization and copy-initialization otherwise.\n    // We can't use InitListChecker for this, because it always performs\n    // copy-initialization. This only matters if we might use an 'explicit'\n    // conversion operator, or for the special case conversion of nullptr_t to\n    // bool, so we only need to handle those cases.\n    //\n    // FIXME: Why not do this in all cases?\n    Expr *Init = InitList->getInit(0);\n    if (Init->getType()->isRecordType() ||\n        (Init->getType()->isNullPtrType() && DestType->isBooleanType())) {\n      InitializationKind SubKind =\n          Kind.getKind() == InitializationKind::IK_DirectList\n              ? InitializationKind::CreateDirect(Kind.getLocation(),\n                                                 InitList->getLBraceLoc(),\n                                                 InitList->getRBraceLoc())\n              : Kind;\n      Expr *SubInit[1] = { Init };\n      Sequence.InitializeFrom(S, Entity, SubKind, SubInit,\n                              /*TopLevelOfInitList*/true,\n                              TreatUnavailableAsInvalid);\n      if (Sequence)\n        Sequence.RewrapReferenceInitList(Entity.getType(), InitList);\n      return;\n    }\n  }\n\n  InitListChecker CheckInitList(S, Entity, InitList,\n          DestType, /*VerifyOnly=*/true, TreatUnavailableAsInvalid);\n  if (CheckInitList.HadError()) {\n    Sequence.SetFailed(InitializationSequence::FK_ListInitializationFailed);\n    return;\n  }\n\n  // Add the list initialization step with the built init list.\n  Sequence.AddListInitializationStep(DestType);\n}\n\n/// Try a reference initialization that involves calling a conversion\n/// function.\nstatic OverloadingResult TryRefInitWithConversionFunction(\n    Sema &S, const InitializedEntity &Entity, const InitializationKind &Kind,\n    Expr *Initializer, bool AllowRValues, bool IsLValueRef,\n    InitializationSequence &Sequence) {\n  QualType DestType = Entity.getType();\n  QualType cv1T1 = DestType->castAs<ReferenceType>()->getPointeeType();\n  QualType T1 = cv1T1.getUnqualifiedType();\n  QualType cv2T2 = Initializer->getType();\n  QualType T2 = cv2T2.getUnqualifiedType();\n\n  assert(!S.CompareReferenceRelationship(Initializer->getBeginLoc(), T1, T2) &&\n         \"Must have incompatible references when binding via conversion\");\n\n  // Build the candidate set directly in the initialization sequence\n  // structure, so that it will persist if we fail.\n  OverloadCandidateSet &CandidateSet = Sequence.getFailedCandidateSet();\n  CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);\n\n  // Determine whether we are allowed to call explicit conversion operators.\n  // Note that none of [over.match.copy], [over.match.conv], nor\n  // [over.match.ref] permit an explicit constructor to be chosen when\n  // initializing a reference, not even for direct-initialization.\n  bool AllowExplicitCtors = false;\n  bool AllowExplicitConvs = Kind.allowExplicitConversionFunctionsInRefBinding();\n\n  const RecordType *T1RecordType = nullptr;\n  if (AllowRValues && (T1RecordType = T1->getAs<RecordType>()) &&\n      S.isCompleteType(Kind.getLocation(), T1)) {\n    // The type we're converting to is a class type. Enumerate its constructors\n    // to see if there is a suitable conversion.\n    CXXRecordDecl *T1RecordDecl = cast<CXXRecordDecl>(T1RecordType->getDecl());\n\n    for (NamedDecl *D : S.LookupConstructors(T1RecordDecl)) {\n      auto Info = getConstructorInfo(D);\n      if (!Info.Constructor)\n        continue;\n\n      if (!Info.Constructor->isInvalidDecl() &&\n          Info.Constructor->isConvertingConstructor(/*AllowExplicit*/true)) {\n        if (Info.ConstructorTmpl)\n          S.AddTemplateOverloadCandidate(\n              Info.ConstructorTmpl, Info.FoundDecl,\n              /*ExplicitArgs*/ nullptr, Initializer, CandidateSet,\n              /*SuppressUserConversions=*/true,\n              /*PartialOverloading*/ false, AllowExplicitCtors);\n        else\n          S.AddOverloadCandidate(\n              Info.Constructor, Info.FoundDecl, Initializer, CandidateSet,\n              /*SuppressUserConversions=*/true,\n              /*PartialOverloading*/ false, AllowExplicitCtors);\n      }\n    }\n  }\n  if (T1RecordType && T1RecordType->getDecl()->isInvalidDecl())\n    return OR_No_Viable_Function;\n\n  const RecordType *T2RecordType = nullptr;\n  if ((T2RecordType = T2->getAs<RecordType>()) &&\n      S.isCompleteType(Kind.getLocation(), T2)) {\n    // The type we're converting from is a class type, enumerate its conversion\n    // functions.\n    CXXRecordDecl *T2RecordDecl = cast<CXXRecordDecl>(T2RecordType->getDecl());\n\n    const auto &Conversions = T2RecordDecl->getVisibleConversionFunctions();\n    for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n      NamedDecl *D = *I;\n      CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(D->getDeclContext());\n      if (isa<UsingShadowDecl>(D))\n        D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n      FunctionTemplateDecl *ConvTemplate = dyn_cast<FunctionTemplateDecl>(D);\n      CXXConversionDecl *Conv;\n      if (ConvTemplate)\n        Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n      else\n        Conv = cast<CXXConversionDecl>(D);\n\n      // If the conversion function doesn't return a reference type,\n      // it can't be considered for this conversion unless we're allowed to\n      // consider rvalues.\n      // FIXME: Do we need to make sure that we only consider conversion\n      // candidates with reference-compatible results? That might be needed to\n      // break recursion.\n      if ((AllowRValues ||\n           Conv->getConversionType()->isLValueReferenceType())) {\n        if (ConvTemplate)\n          S.AddTemplateConversionCandidate(\n              ConvTemplate, I.getPair(), ActingDC, Initializer, DestType,\n              CandidateSet,\n              /*AllowObjCConversionOnExplicit=*/false, AllowExplicitConvs);\n        else\n          S.AddConversionCandidate(\n              Conv, I.getPair(), ActingDC, Initializer, DestType, CandidateSet,\n              /*AllowObjCConversionOnExplicit=*/false, AllowExplicitConvs);\n      }\n    }\n  }\n  if (T2RecordType && T2RecordType->getDecl()->isInvalidDecl())\n    return OR_No_Viable_Function;\n\n  SourceLocation DeclLoc = Initializer->getBeginLoc();\n\n  // Perform overload resolution. If it fails, return the failed result.\n  OverloadCandidateSet::iterator Best;\n  if (OverloadingResult Result\n        = CandidateSet.BestViableFunction(S, DeclLoc, Best))\n    return Result;\n\n  FunctionDecl *Function = Best->Function;\n  // This is the overload that will be used for this initialization step if we\n  // use this initialization. Mark it as referenced.\n  Function->setReferenced();\n\n  // Compute the returned type and value kind of the conversion.\n  QualType cv3T3;\n  if (isa<CXXConversionDecl>(Function))\n    cv3T3 = Function->getReturnType();\n  else\n    cv3T3 = T1;\n\n  ExprValueKind VK = VK_RValue;\n  if (cv3T3->isLValueReferenceType())\n    VK = VK_LValue;\n  else if (const auto *RRef = cv3T3->getAs<RValueReferenceType>())\n    VK = RRef->getPointeeType()->isFunctionType() ? VK_LValue : VK_XValue;\n  cv3T3 = cv3T3.getNonLValueExprType(S.Context);\n\n  // Add the user-defined conversion step.\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n  Sequence.AddUserConversionStep(Function, Best->FoundDecl, cv3T3,\n                                 HadMultipleCandidates);\n\n  // Determine whether we'll need to perform derived-to-base adjustments or\n  // other conversions.\n  Sema::ReferenceConversions RefConv;\n  Sema::ReferenceCompareResult NewRefRelationship =\n      S.CompareReferenceRelationship(DeclLoc, T1, cv3T3, &RefConv);\n\n  // Add the final conversion sequence, if necessary.\n  if (NewRefRelationship == Sema::Ref_Incompatible) {\n    assert(!isa<CXXConstructorDecl>(Function) &&\n           \"should not have conversion after constructor\");\n\n    ImplicitConversionSequence ICS;\n    ICS.setStandard();\n    ICS.Standard = Best->FinalConversion;\n    Sequence.AddConversionSequenceStep(ICS, ICS.Standard.getToType(2));\n\n    // Every implicit conversion results in a prvalue, except for a glvalue\n    // derived-to-base conversion, which we handle below.\n    cv3T3 = ICS.Standard.getToType(2);\n    VK = VK_RValue;\n  }\n\n  //   If the converted initializer is a prvalue, its type T4 is adjusted to\n  //   type \"cv1 T4\" and the temporary materialization conversion is applied.\n  //\n  // We adjust the cv-qualifications to match the reference regardless of\n  // whether we have a prvalue so that the AST records the change. In this\n  // case, T4 is \"cv3 T3\".\n  QualType cv1T4 = S.Context.getQualifiedType(cv3T3, cv1T1.getQualifiers());\n  if (cv1T4.getQualifiers() != cv3T3.getQualifiers())\n    Sequence.AddQualificationConversionStep(cv1T4, VK);\n  Sequence.AddReferenceBindingStep(cv1T4, VK == VK_RValue);\n  VK = IsLValueRef ? VK_LValue : VK_XValue;\n\n  if (RefConv & Sema::ReferenceConversions::DerivedToBase)\n    Sequence.AddDerivedToBaseCastStep(cv1T1, VK);\n  else if (RefConv & Sema::ReferenceConversions::ObjC)\n    Sequence.AddObjCObjectConversionStep(cv1T1);\n  else if (RefConv & Sema::ReferenceConversions::Function)\n    Sequence.AddFunctionReferenceConversionStep(cv1T1);\n  else if (RefConv & Sema::ReferenceConversions::Qualification) {\n    if (!S.Context.hasSameType(cv1T4, cv1T1))\n      Sequence.AddQualificationConversionStep(cv1T1, VK);\n  }\n\n  return OR_Success;\n}\n\nstatic void CheckCXX98CompatAccessibleCopy(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           Expr *CurInitExpr);\n\n/// Attempt reference initialization (C++0x [dcl.init.ref])\nstatic void TryReferenceInitialization(Sema &S,\n                                       const InitializedEntity &Entity,\n                                       const InitializationKind &Kind,\n                                       Expr *Initializer,\n                                       InitializationSequence &Sequence) {\n  QualType DestType = Entity.getType();\n  QualType cv1T1 = DestType->castAs<ReferenceType>()->getPointeeType();\n  Qualifiers T1Quals;\n  QualType T1 = S.Context.getUnqualifiedArrayType(cv1T1, T1Quals);\n  QualType cv2T2 = S.getCompletedType(Initializer);\n  Qualifiers T2Quals;\n  QualType T2 = S.Context.getUnqualifiedArrayType(cv2T2, T2Quals);\n\n  // If the initializer is the address of an overloaded function, try\n  // to resolve the overloaded function. If all goes well, T2 is the\n  // type of the resulting function.\n  if (ResolveOverloadedFunctionForReferenceBinding(S, Initializer, cv2T2, T2,\n                                                   T1, Sequence))\n    return;\n\n  // Delegate everything else to a subfunction.\n  TryReferenceInitializationCore(S, Entity, Kind, Initializer, cv1T1, T1,\n                                 T1Quals, cv2T2, T2, T2Quals, Sequence);\n}\n\n/// Determine whether an expression is a non-referenceable glvalue (one to\n/// which a reference can never bind). Attempting to bind a reference to\n/// such a glvalue will always create a temporary.\nstatic bool isNonReferenceableGLValue(Expr *E) {\n  return E->refersToBitField() || E->refersToVectorElement() ||\n         E->refersToMatrixElement();\n}\n\n/// Reference initialization without resolving overloaded functions.\n///\n/// We also can get here in C if we call a builtin which is declared as\n/// a function with a parameter of reference type (such as __builtin_va_end()).\nstatic void TryReferenceInitializationCore(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           const InitializationKind &Kind,\n                                           Expr *Initializer,\n                                           QualType cv1T1, QualType T1,\n                                           Qualifiers T1Quals,\n                                           QualType cv2T2, QualType T2,\n                                           Qualifiers T2Quals,\n                                           InitializationSequence &Sequence) {\n  QualType DestType = Entity.getType();\n  SourceLocation DeclLoc = Initializer->getBeginLoc();\n\n  // Compute some basic properties of the types and the initializer.\n  bool isLValueRef = DestType->isLValueReferenceType();\n  bool isRValueRef = !isLValueRef;\n  Expr::Classification InitCategory = Initializer->Classify(S.Context);\n\n  Sema::ReferenceConversions RefConv;\n  Sema::ReferenceCompareResult RefRelationship =\n      S.CompareReferenceRelationship(DeclLoc, cv1T1, cv2T2, &RefConv);\n\n  // C++0x [dcl.init.ref]p5:\n  //   A reference to type \"cv1 T1\" is initialized by an expression of type\n  //   \"cv2 T2\" as follows:\n  //\n  //     - If the reference is an lvalue reference and the initializer\n  //       expression\n  // Note the analogous bullet points for rvalue refs to functions. Because\n  // there are no function rvalues in C++, rvalue refs to functions are treated\n  // like lvalue refs.\n  OverloadingResult ConvOvlResult = OR_Success;\n  bool T1Function = T1->isFunctionType();\n  if (isLValueRef || T1Function) {\n    if (InitCategory.isLValue() && !isNonReferenceableGLValue(Initializer) &&\n        (RefRelationship == Sema::Ref_Compatible ||\n         (Kind.isCStyleOrFunctionalCast() &&\n          RefRelationship == Sema::Ref_Related))) {\n      //   - is an lvalue (but is not a bit-field), and \"cv1 T1\" is\n      //     reference-compatible with \"cv2 T2,\" or\n      if (RefConv & (Sema::ReferenceConversions::DerivedToBase |\n                     Sema::ReferenceConversions::ObjC)) {\n        // If we're converting the pointee, add any qualifiers first;\n        // these qualifiers must all be top-level, so just convert to \"cv1 T2\".\n        if (RefConv & (Sema::ReferenceConversions::Qualification))\n          Sequence.AddQualificationConversionStep(\n              S.Context.getQualifiedType(T2, T1Quals),\n              Initializer->getValueKind());\n        if (RefConv & Sema::ReferenceConversions::DerivedToBase)\n          Sequence.AddDerivedToBaseCastStep(cv1T1, VK_LValue);\n        else\n          Sequence.AddObjCObjectConversionStep(cv1T1);\n      } else if (RefConv & Sema::ReferenceConversions::Qualification) {\n        // Perform a (possibly multi-level) qualification conversion.\n        Sequence.AddQualificationConversionStep(cv1T1,\n                                                Initializer->getValueKind());\n      } else if (RefConv & Sema::ReferenceConversions::Function) {\n        Sequence.AddFunctionReferenceConversionStep(cv1T1);\n      }\n\n      // We only create a temporary here when binding a reference to a\n      // bit-field or vector element. Those cases are't supposed to be\n      // handled by this bullet, but the outcome is the same either way.\n      Sequence.AddReferenceBindingStep(cv1T1, false);\n      return;\n    }\n\n    //     - has a class type (i.e., T2 is a class type), where T1 is not\n    //       reference-related to T2, and can be implicitly converted to an\n    //       lvalue of type \"cv3 T3,\" where \"cv1 T1\" is reference-compatible\n    //       with \"cv3 T3\" (this conversion is selected by enumerating the\n    //       applicable conversion functions (13.3.1.6) and choosing the best\n    //       one through overload resolution (13.3)),\n    // If we have an rvalue ref to function type here, the rhs must be\n    // an rvalue. DR1287 removed the \"implicitly\" here.\n    if (RefRelationship == Sema::Ref_Incompatible && T2->isRecordType() &&\n        (isLValueRef || InitCategory.isRValue())) {\n      if (S.getLangOpts().CPlusPlus) {\n        // Try conversion functions only for C++.\n        ConvOvlResult = TryRefInitWithConversionFunction(\n            S, Entity, Kind, Initializer, /*AllowRValues*/ isRValueRef,\n            /*IsLValueRef*/ isLValueRef, Sequence);\n        if (ConvOvlResult == OR_Success)\n          return;\n        if (ConvOvlResult != OR_No_Viable_Function)\n          Sequence.SetOverloadFailure(\n              InitializationSequence::FK_ReferenceInitOverloadFailed,\n              ConvOvlResult);\n      } else {\n        ConvOvlResult = OR_No_Viable_Function;\n      }\n    }\n  }\n\n  //     - Otherwise, the reference shall be an lvalue reference to a\n  //       non-volatile const type (i.e., cv1 shall be const), or the reference\n  //       shall be an rvalue reference.\n  //       For address spaces, we interpret this to mean that an addr space\n  //       of a reference \"cv1 T1\" is a superset of addr space of \"cv2 T2\".\n  if (isLValueRef && !(T1Quals.hasConst() && !T1Quals.hasVolatile() &&\n                       T1Quals.isAddressSpaceSupersetOf(T2Quals))) {\n    if (S.Context.getCanonicalType(T2) == S.Context.OverloadTy)\n      Sequence.SetFailed(InitializationSequence::FK_AddressOfOverloadFailed);\n    else if (ConvOvlResult && !Sequence.getFailedCandidateSet().empty())\n      Sequence.SetOverloadFailure(\n                        InitializationSequence::FK_ReferenceInitOverloadFailed,\n                                  ConvOvlResult);\n    else if (!InitCategory.isLValue())\n      Sequence.SetFailed(\n          T1Quals.isAddressSpaceSupersetOf(T2Quals)\n              ? InitializationSequence::\n                    FK_NonConstLValueReferenceBindingToTemporary\n              : InitializationSequence::FK_ReferenceInitDropsQualifiers);\n    else {\n      InitializationSequence::FailureKind FK;\n      switch (RefRelationship) {\n      case Sema::Ref_Compatible:\n        if (Initializer->refersToBitField())\n          FK = InitializationSequence::\n              FK_NonConstLValueReferenceBindingToBitfield;\n        else if (Initializer->refersToVectorElement())\n          FK = InitializationSequence::\n              FK_NonConstLValueReferenceBindingToVectorElement;\n        else if (Initializer->refersToMatrixElement())\n          FK = InitializationSequence::\n              FK_NonConstLValueReferenceBindingToMatrixElement;\n        else\n          llvm_unreachable(\"unexpected kind of compatible initializer\");\n        break;\n      case Sema::Ref_Related:\n        FK = InitializationSequence::FK_ReferenceInitDropsQualifiers;\n        break;\n      case Sema::Ref_Incompatible:\n        FK = InitializationSequence::\n            FK_NonConstLValueReferenceBindingToUnrelated;\n        break;\n      }\n      Sequence.SetFailed(FK);\n    }\n    return;\n  }\n\n  //    - If the initializer expression\n  //      - is an\n  // [<=14] xvalue (but not a bit-field), class prvalue, array prvalue, or\n  // [1z]   rvalue (but not a bit-field) or\n  //        function lvalue and \"cv1 T1\" is reference-compatible with \"cv2 T2\"\n  //\n  // Note: functions are handled above and below rather than here...\n  if (!T1Function &&\n      (RefRelationship == Sema::Ref_Compatible ||\n       (Kind.isCStyleOrFunctionalCast() &&\n        RefRelationship == Sema::Ref_Related)) &&\n      ((InitCategory.isXValue() && !isNonReferenceableGLValue(Initializer)) ||\n       (InitCategory.isPRValue() &&\n        (S.getLangOpts().CPlusPlus17 || T2->isRecordType() ||\n         T2->isArrayType())))) {\n    ExprValueKind ValueKind = InitCategory.isXValue() ? VK_XValue : VK_RValue;\n    if (InitCategory.isPRValue() && T2->isRecordType()) {\n      // The corresponding bullet in C++03 [dcl.init.ref]p5 gives the\n      // compiler the freedom to perform a copy here or bind to the\n      // object, while C++0x requires that we bind directly to the\n      // object. Hence, we always bind to the object without making an\n      // extra copy. However, in C++03 requires that we check for the\n      // presence of a suitable copy constructor:\n      //\n      //   The constructor that would be used to make the copy shall\n      //   be callable whether or not the copy is actually done.\n      if (!S.getLangOpts().CPlusPlus11 && !S.getLangOpts().MicrosoftExt)\n        Sequence.AddExtraneousCopyToTemporary(cv2T2);\n      else if (S.getLangOpts().CPlusPlus11)\n        CheckCXX98CompatAccessibleCopy(S, Entity, Initializer);\n    }\n\n    // C++1z [dcl.init.ref]/5.2.1.2:\n    //   If the converted initializer is a prvalue, its type T4 is adjusted\n    //   to type \"cv1 T4\" and the temporary materialization conversion is\n    //   applied.\n    // Postpone address space conversions to after the temporary materialization\n    // conversion to allow creating temporaries in the alloca address space.\n    auto T1QualsIgnoreAS = T1Quals;\n    auto T2QualsIgnoreAS = T2Quals;\n    if (T1Quals.getAddressSpace() != T2Quals.getAddressSpace()) {\n      T1QualsIgnoreAS.removeAddressSpace();\n      T2QualsIgnoreAS.removeAddressSpace();\n    }\n    QualType cv1T4 = S.Context.getQualifiedType(cv2T2, T1QualsIgnoreAS);\n    if (T1QualsIgnoreAS != T2QualsIgnoreAS)\n      Sequence.AddQualificationConversionStep(cv1T4, ValueKind);\n    Sequence.AddReferenceBindingStep(cv1T4, ValueKind == VK_RValue);\n    ValueKind = isLValueRef ? VK_LValue : VK_XValue;\n    // Add addr space conversion if required.\n    if (T1Quals.getAddressSpace() != T2Quals.getAddressSpace()) {\n      auto T4Quals = cv1T4.getQualifiers();\n      T4Quals.addAddressSpace(T1Quals.getAddressSpace());\n      QualType cv1T4WithAS = S.Context.getQualifiedType(T2, T4Quals);\n      Sequence.AddQualificationConversionStep(cv1T4WithAS, ValueKind);\n      cv1T4 = cv1T4WithAS;\n    }\n\n    //   In any case, the reference is bound to the resulting glvalue (or to\n    //   an appropriate base class subobject).\n    if (RefConv & Sema::ReferenceConversions::DerivedToBase)\n      Sequence.AddDerivedToBaseCastStep(cv1T1, ValueKind);\n    else if (RefConv & Sema::ReferenceConversions::ObjC)\n      Sequence.AddObjCObjectConversionStep(cv1T1);\n    else if (RefConv & Sema::ReferenceConversions::Qualification) {\n      if (!S.Context.hasSameType(cv1T4, cv1T1))\n        Sequence.AddQualificationConversionStep(cv1T1, ValueKind);\n    }\n    return;\n  }\n\n  //       - has a class type (i.e., T2 is a class type), where T1 is not\n  //         reference-related to T2, and can be implicitly converted to an\n  //         xvalue, class prvalue, or function lvalue of type \"cv3 T3\",\n  //         where \"cv1 T1\" is reference-compatible with \"cv3 T3\",\n  //\n  // DR1287 removes the \"implicitly\" here.\n  if (T2->isRecordType()) {\n    if (RefRelationship == Sema::Ref_Incompatible) {\n      ConvOvlResult = TryRefInitWithConversionFunction(\n          S, Entity, Kind, Initializer, /*AllowRValues*/ true,\n          /*IsLValueRef*/ isLValueRef, Sequence);\n      if (ConvOvlResult)\n        Sequence.SetOverloadFailure(\n            InitializationSequence::FK_ReferenceInitOverloadFailed,\n            ConvOvlResult);\n\n      return;\n    }\n\n    if (RefRelationship == Sema::Ref_Compatible &&\n        isRValueRef && InitCategory.isLValue()) {\n      Sequence.SetFailed(\n        InitializationSequence::FK_RValueReferenceBindingToLValue);\n      return;\n    }\n\n    Sequence.SetFailed(InitializationSequence::FK_ReferenceInitDropsQualifiers);\n    return;\n  }\n\n  //      - Otherwise, a temporary of type \"cv1 T1\" is created and initialized\n  //        from the initializer expression using the rules for a non-reference\n  //        copy-initialization (8.5). The reference is then bound to the\n  //        temporary. [...]\n\n  // Ignore address space of reference type at this point and perform address\n  // space conversion after the reference binding step.\n  QualType cv1T1IgnoreAS =\n      T1Quals.hasAddressSpace()\n          ? S.Context.getQualifiedType(T1, T1Quals.withoutAddressSpace())\n          : cv1T1;\n\n  InitializedEntity TempEntity =\n      InitializedEntity::InitializeTemporary(cv1T1IgnoreAS);\n\n  // FIXME: Why do we use an implicit conversion here rather than trying\n  // copy-initialization?\n  ImplicitConversionSequence ICS\n    = S.TryImplicitConversion(Initializer, TempEntity.getType(),\n                              /*SuppressUserConversions=*/false,\n                              Sema::AllowedExplicit::None,\n                              /*FIXME:InOverloadResolution=*/false,\n                              /*CStyle=*/Kind.isCStyleOrFunctionalCast(),\n                              /*AllowObjCWritebackConversion=*/false);\n\n  if (ICS.isBad()) {\n    // FIXME: Use the conversion function set stored in ICS to turn\n    // this into an overloading ambiguity diagnostic. However, we need\n    // to keep that set as an OverloadCandidateSet rather than as some\n    // other kind of set.\n    if (ConvOvlResult && !Sequence.getFailedCandidateSet().empty())\n      Sequence.SetOverloadFailure(\n                        InitializationSequence::FK_ReferenceInitOverloadFailed,\n                                  ConvOvlResult);\n    else if (S.Context.getCanonicalType(T2) == S.Context.OverloadTy)\n      Sequence.SetFailed(InitializationSequence::FK_AddressOfOverloadFailed);\n    else\n      Sequence.SetFailed(InitializationSequence::FK_ReferenceInitFailed);\n    return;\n  } else {\n    Sequence.AddConversionSequenceStep(ICS, TempEntity.getType());\n  }\n\n  //        [...] If T1 is reference-related to T2, cv1 must be the\n  //        same cv-qualification as, or greater cv-qualification\n  //        than, cv2; otherwise, the program is ill-formed.\n  unsigned T1CVRQuals = T1Quals.getCVRQualifiers();\n  unsigned T2CVRQuals = T2Quals.getCVRQualifiers();\n  if ((RefRelationship == Sema::Ref_Related &&\n       (T1CVRQuals | T2CVRQuals) != T1CVRQuals) ||\n      !T1Quals.isAddressSpaceSupersetOf(T2Quals)) {\n    Sequence.SetFailed(InitializationSequence::FK_ReferenceInitDropsQualifiers);\n    return;\n  }\n\n  //   [...] If T1 is reference-related to T2 and the reference is an rvalue\n  //   reference, the initializer expression shall not be an lvalue.\n  if (RefRelationship >= Sema::Ref_Related && !isLValueRef &&\n      InitCategory.isLValue()) {\n    Sequence.SetFailed(\n                    InitializationSequence::FK_RValueReferenceBindingToLValue);\n    return;\n  }\n\n  Sequence.AddReferenceBindingStep(cv1T1IgnoreAS, /*BindingTemporary=*/true);\n\n  if (T1Quals.hasAddressSpace()) {\n    if (!Qualifiers::isAddressSpaceSupersetOf(T1Quals.getAddressSpace(),\n                                              LangAS::Default)) {\n      Sequence.SetFailed(\n          InitializationSequence::FK_ReferenceAddrspaceMismatchTemporary);\n      return;\n    }\n    Sequence.AddQualificationConversionStep(cv1T1, isLValueRef ? VK_LValue\n                                                               : VK_XValue);\n  }\n}\n\n/// Attempt character array initialization from a string literal\n/// (C++ [dcl.init.string], C99 6.7.8).\nstatic void TryStringLiteralInitialization(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           const InitializationKind &Kind,\n                                           Expr *Initializer,\n                                       InitializationSequence &Sequence) {\n  Sequence.AddStringInitStep(Entity.getType());\n}\n\n/// Attempt value initialization (C++ [dcl.init]p7).\nstatic void TryValueInitialization(Sema &S,\n                                   const InitializedEntity &Entity,\n                                   const InitializationKind &Kind,\n                                   InitializationSequence &Sequence,\n                                   InitListExpr *InitList) {\n  assert((!InitList || InitList->getNumInits() == 0) &&\n         \"Shouldn't use value-init for non-empty init lists\");\n\n  // C++98 [dcl.init]p5, C++11 [dcl.init]p7:\n  //\n  //   To value-initialize an object of type T means:\n  QualType T = Entity.getType();\n\n  //     -- if T is an array type, then each element is value-initialized;\n  T = S.Context.getBaseElementType(T);\n\n  if (const RecordType *RT = T->getAs<RecordType>()) {\n    if (CXXRecordDecl *ClassDecl = dyn_cast<CXXRecordDecl>(RT->getDecl())) {\n      bool NeedZeroInitialization = true;\n      // C++98:\n      // -- if T is a class type (clause 9) with a user-declared constructor\n      //    (12.1), then the default constructor for T is called (and the\n      //    initialization is ill-formed if T has no accessible default\n      //    constructor);\n      // C++11:\n      // -- if T is a class type (clause 9) with either no default constructor\n      //    (12.1 [class.ctor]) or a default constructor that is user-provided\n      //    or deleted, then the object is default-initialized;\n      //\n      // Note that the C++11 rule is the same as the C++98 rule if there are no\n      // defaulted or deleted constructors, so we just use it unconditionally.\n      CXXConstructorDecl *CD = S.LookupDefaultConstructor(ClassDecl);\n      if (!CD || !CD->getCanonicalDecl()->isDefaulted() || CD->isDeleted())\n        NeedZeroInitialization = false;\n\n      // -- if T is a (possibly cv-qualified) non-union class type without a\n      //    user-provided or deleted default constructor, then the object is\n      //    zero-initialized and, if T has a non-trivial default constructor,\n      //    default-initialized;\n      // The 'non-union' here was removed by DR1502. The 'non-trivial default\n      // constructor' part was removed by DR1507.\n      if (NeedZeroInitialization)\n        Sequence.AddZeroInitializationStep(Entity.getType());\n\n      // C++03:\n      // -- if T is a non-union class type without a user-declared constructor,\n      //    then every non-static data member and base class component of T is\n      //    value-initialized;\n      // [...] A program that calls for [...] value-initialization of an\n      // entity of reference type is ill-formed.\n      //\n      // C++11 doesn't need this handling, because value-initialization does not\n      // occur recursively there, and the implicit default constructor is\n      // defined as deleted in the problematic cases.\n      if (!S.getLangOpts().CPlusPlus11 &&\n          ClassDecl->hasUninitializedReferenceMember()) {\n        Sequence.SetFailed(InitializationSequence::FK_TooManyInitsForReference);\n        return;\n      }\n\n      // If this is list-value-initialization, pass the empty init list on when\n      // building the constructor call. This affects the semantics of a few\n      // things (such as whether an explicit default constructor can be called).\n      Expr *InitListAsExpr = InitList;\n      MultiExprArg Args(&InitListAsExpr, InitList ? 1 : 0);\n      bool InitListSyntax = InitList;\n\n      // FIXME: Instead of creating a CXXConstructExpr of array type here,\n      // wrap a class-typed CXXConstructExpr in an ArrayInitLoopExpr.\n      return TryConstructorInitialization(\n          S, Entity, Kind, Args, T, Entity.getType(), Sequence, InitListSyntax);\n    }\n  }\n\n  Sequence.AddZeroInitializationStep(Entity.getType());\n}\n\n/// Attempt default initialization (C++ [dcl.init]p6).\nstatic void TryDefaultInitialization(Sema &S,\n                                     const InitializedEntity &Entity,\n                                     const InitializationKind &Kind,\n                                     InitializationSequence &Sequence) {\n  assert(Kind.getKind() == InitializationKind::IK_Default);\n\n  // C++ [dcl.init]p6:\n  //   To default-initialize an object of type T means:\n  //     - if T is an array type, each element is default-initialized;\n  QualType DestType = S.Context.getBaseElementType(Entity.getType());\n\n  //     - if T is a (possibly cv-qualified) class type (Clause 9), the default\n  //       constructor for T is called (and the initialization is ill-formed if\n  //       T has no accessible default constructor);\n  if (DestType->isRecordType() && S.getLangOpts().CPlusPlus) {\n    TryConstructorInitialization(S, Entity, Kind, None, DestType,\n                                 Entity.getType(), Sequence);\n    return;\n  }\n\n  //     - otherwise, no initialization is performed.\n\n  //   If a program calls for the default initialization of an object of\n  //   a const-qualified type T, T shall be a class type with a user-provided\n  //   default constructor.\n  if (DestType.isConstQualified() && S.getLangOpts().CPlusPlus) {\n    if (!maybeRecoverWithZeroInitialization(S, Sequence, Entity))\n      Sequence.SetFailed(InitializationSequence::FK_DefaultInitOfConst);\n    return;\n  }\n\n  // If the destination type has a lifetime property, zero-initialize it.\n  if (DestType.getQualifiers().hasObjCLifetime()) {\n    Sequence.AddZeroInitializationStep(Entity.getType());\n    return;\n  }\n}\n\n/// Attempt a user-defined conversion between two types (C++ [dcl.init]),\n/// which enumerates all conversion functions and performs overload resolution\n/// to select the best.\nstatic void TryUserDefinedConversion(Sema &S,\n                                     QualType DestType,\n                                     const InitializationKind &Kind,\n                                     Expr *Initializer,\n                                     InitializationSequence &Sequence,\n                                     bool TopLevelOfInitList) {\n  assert(!DestType->isReferenceType() && \"References are handled elsewhere\");\n  QualType SourceType = Initializer->getType();\n  assert((DestType->isRecordType() || SourceType->isRecordType()) &&\n         \"Must have a class type to perform a user-defined conversion\");\n\n  // Build the candidate set directly in the initialization sequence\n  // structure, so that it will persist if we fail.\n  OverloadCandidateSet &CandidateSet = Sequence.getFailedCandidateSet();\n  CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);\n  CandidateSet.setDestAS(DestType.getQualifiers().getAddressSpace());\n\n  // Determine whether we are allowed to call explicit constructors or\n  // explicit conversion operators.\n  bool AllowExplicit = Kind.AllowExplicit();\n\n  if (const RecordType *DestRecordType = DestType->getAs<RecordType>()) {\n    // The type we're converting to is a class type. Enumerate its constructors\n    // to see if there is a suitable conversion.\n    CXXRecordDecl *DestRecordDecl\n      = cast<CXXRecordDecl>(DestRecordType->getDecl());\n\n    // Try to complete the type we're converting to.\n    if (S.isCompleteType(Kind.getLocation(), DestType)) {\n      for (NamedDecl *D : S.LookupConstructors(DestRecordDecl)) {\n        auto Info = getConstructorInfo(D);\n        if (!Info.Constructor)\n          continue;\n\n        if (!Info.Constructor->isInvalidDecl() &&\n            Info.Constructor->isConvertingConstructor(/*AllowExplicit*/true)) {\n          if (Info.ConstructorTmpl)\n            S.AddTemplateOverloadCandidate(\n                Info.ConstructorTmpl, Info.FoundDecl,\n                /*ExplicitArgs*/ nullptr, Initializer, CandidateSet,\n                /*SuppressUserConversions=*/true,\n                /*PartialOverloading*/ false, AllowExplicit);\n          else\n            S.AddOverloadCandidate(Info.Constructor, Info.FoundDecl,\n                                   Initializer, CandidateSet,\n                                   /*SuppressUserConversions=*/true,\n                                   /*PartialOverloading*/ false, AllowExplicit);\n        }\n      }\n    }\n  }\n\n  SourceLocation DeclLoc = Initializer->getBeginLoc();\n\n  if (const RecordType *SourceRecordType = SourceType->getAs<RecordType>()) {\n    // The type we're converting from is a class type, enumerate its conversion\n    // functions.\n\n    // We can only enumerate the conversion functions for a complete type; if\n    // the type isn't complete, simply skip this step.\n    if (S.isCompleteType(DeclLoc, SourceType)) {\n      CXXRecordDecl *SourceRecordDecl\n        = cast<CXXRecordDecl>(SourceRecordType->getDecl());\n\n      const auto &Conversions =\n          SourceRecordDecl->getVisibleConversionFunctions();\n      for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n        NamedDecl *D = *I;\n        CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(D->getDeclContext());\n        if (isa<UsingShadowDecl>(D))\n          D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n        FunctionTemplateDecl *ConvTemplate = dyn_cast<FunctionTemplateDecl>(D);\n        CXXConversionDecl *Conv;\n        if (ConvTemplate)\n          Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n        else\n          Conv = cast<CXXConversionDecl>(D);\n\n        if (ConvTemplate)\n          S.AddTemplateConversionCandidate(\n              ConvTemplate, I.getPair(), ActingDC, Initializer, DestType,\n              CandidateSet, AllowExplicit, AllowExplicit);\n        else\n          S.AddConversionCandidate(Conv, I.getPair(), ActingDC, Initializer,\n                                   DestType, CandidateSet, AllowExplicit,\n                                   AllowExplicit);\n      }\n    }\n  }\n\n  // Perform overload resolution. If it fails, return the failed result.\n  OverloadCandidateSet::iterator Best;\n  if (OverloadingResult Result\n        = CandidateSet.BestViableFunction(S, DeclLoc, Best)) {\n    Sequence.SetOverloadFailure(\n        InitializationSequence::FK_UserConversionOverloadFailed, Result);\n\n    // [class.copy.elision]p3:\n    // In some copy-initialization contexts, a two-stage overload resolution\n    // is performed.\n    // If the first overload resolution selects a deleted function, we also\n    // need the initialization sequence to decide whether to perform the second\n    // overload resolution.\n    if (!(Result == OR_Deleted &&\n          Kind.getKind() == InitializationKind::IK_Copy))\n      return;\n  }\n\n  FunctionDecl *Function = Best->Function;\n  Function->setReferenced();\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  if (isa<CXXConstructorDecl>(Function)) {\n    // Add the user-defined conversion step. Any cv-qualification conversion is\n    // subsumed by the initialization. Per DR5, the created temporary is of the\n    // cv-unqualified type of the destination.\n    Sequence.AddUserConversionStep(Function, Best->FoundDecl,\n                                   DestType.getUnqualifiedType(),\n                                   HadMultipleCandidates);\n\n    // C++14 and before:\n    //   - if the function is a constructor, the call initializes a temporary\n    //     of the cv-unqualified version of the destination type. The [...]\n    //     temporary [...] is then used to direct-initialize, according to the\n    //     rules above, the object that is the destination of the\n    //     copy-initialization.\n    // Note that this just performs a simple object copy from the temporary.\n    //\n    // C++17:\n    //   - if the function is a constructor, the call is a prvalue of the\n    //     cv-unqualified version of the destination type whose return object\n    //     is initialized by the constructor. The call is used to\n    //     direct-initialize, according to the rules above, the object that\n    //     is the destination of the copy-initialization.\n    // Therefore we need to do nothing further.\n    //\n    // FIXME: Mark this copy as extraneous.\n    if (!S.getLangOpts().CPlusPlus17)\n      Sequence.AddFinalCopy(DestType);\n    else if (DestType.hasQualifiers())\n      Sequence.AddQualificationConversionStep(DestType, VK_RValue);\n    return;\n  }\n\n  // Add the user-defined conversion step that calls the conversion function.\n  QualType ConvType = Function->getCallResultType();\n  Sequence.AddUserConversionStep(Function, Best->FoundDecl, ConvType,\n                                 HadMultipleCandidates);\n\n  if (ConvType->getAs<RecordType>()) {\n    //   The call is used to direct-initialize [...] the object that is the\n    //   destination of the copy-initialization.\n    //\n    // In C++17, this does not call a constructor if we enter /17.6.1:\n    //   - If the initializer expression is a prvalue and the cv-unqualified\n    //     version of the source type is the same as the class of the\n    //     destination [... do not make an extra copy]\n    //\n    // FIXME: Mark this copy as extraneous.\n    if (!S.getLangOpts().CPlusPlus17 ||\n        Function->getReturnType()->isReferenceType() ||\n        !S.Context.hasSameUnqualifiedType(ConvType, DestType))\n      Sequence.AddFinalCopy(DestType);\n    else if (!S.Context.hasSameType(ConvType, DestType))\n      Sequence.AddQualificationConversionStep(DestType, VK_RValue);\n    return;\n  }\n\n  // If the conversion following the call to the conversion function\n  // is interesting, add it as a separate step.\n  if (Best->FinalConversion.First || Best->FinalConversion.Second ||\n      Best->FinalConversion.Third) {\n    ImplicitConversionSequence ICS;\n    ICS.setStandard();\n    ICS.Standard = Best->FinalConversion;\n    Sequence.AddConversionSequenceStep(ICS, DestType, TopLevelOfInitList);\n  }\n}\n\n/// An egregious hack for compatibility with libstdc++-4.2: in <tr1/hashtable>,\n/// a function with a pointer return type contains a 'return false;' statement.\n/// In C++11, 'false' is not a null pointer, so this breaks the build of any\n/// code using that header.\n///\n/// Work around this by treating 'return false;' as zero-initializing the result\n/// if it's used in a pointer-returning function in a system header.\nstatic bool isLibstdcxxPointerReturnFalseHack(Sema &S,\n                                              const InitializedEntity &Entity,\n                                              const Expr *Init) {\n  return S.getLangOpts().CPlusPlus11 &&\n         Entity.getKind() == InitializedEntity::EK_Result &&\n         Entity.getType()->isPointerType() &&\n         isa<CXXBoolLiteralExpr>(Init) &&\n         !cast<CXXBoolLiteralExpr>(Init)->getValue() &&\n         S.getSourceManager().isInSystemHeader(Init->getExprLoc());\n}\n\n/// The non-zero enum values here are indexes into diagnostic alternatives.\nenum InvalidICRKind { IIK_okay, IIK_nonlocal, IIK_nonscalar };\n\n/// Determines whether this expression is an acceptable ICR source.\nstatic InvalidICRKind isInvalidICRSource(ASTContext &C, Expr *e,\n                                         bool isAddressOf, bool &isWeakAccess) {\n  // Skip parens.\n  e = e->IgnoreParens();\n\n  // Skip address-of nodes.\n  if (UnaryOperator *op = dyn_cast<UnaryOperator>(e)) {\n    if (op->getOpcode() == UO_AddrOf)\n      return isInvalidICRSource(C, op->getSubExpr(), /*addressof*/ true,\n                                isWeakAccess);\n\n  // Skip certain casts.\n  } else if (CastExpr *ce = dyn_cast<CastExpr>(e)) {\n    switch (ce->getCastKind()) {\n    case CK_Dependent:\n    case CK_BitCast:\n    case CK_LValueBitCast:\n    case CK_NoOp:\n      return isInvalidICRSource(C, ce->getSubExpr(), isAddressOf, isWeakAccess);\n\n    case CK_ArrayToPointerDecay:\n      return IIK_nonscalar;\n\n    case CK_NullToPointer:\n      return IIK_okay;\n\n    default:\n      break;\n    }\n\n  // If we have a declaration reference, it had better be a local variable.\n  } else if (isa<DeclRefExpr>(e)) {\n    // set isWeakAccess to true, to mean that there will be an implicit\n    // load which requires a cleanup.\n    if (e->getType().getObjCLifetime() == Qualifiers::OCL_Weak)\n      isWeakAccess = true;\n\n    if (!isAddressOf) return IIK_nonlocal;\n\n    VarDecl *var = dyn_cast<VarDecl>(cast<DeclRefExpr>(e)->getDecl());\n    if (!var) return IIK_nonlocal;\n\n    return (var->hasLocalStorage() ? IIK_okay : IIK_nonlocal);\n\n  // If we have a conditional operator, check both sides.\n  } else if (ConditionalOperator *cond = dyn_cast<ConditionalOperator>(e)) {\n    if (InvalidICRKind iik = isInvalidICRSource(C, cond->getLHS(), isAddressOf,\n                                                isWeakAccess))\n      return iik;\n\n    return isInvalidICRSource(C, cond->getRHS(), isAddressOf, isWeakAccess);\n\n  // These are never scalar.\n  } else if (isa<ArraySubscriptExpr>(e)) {\n    return IIK_nonscalar;\n\n  // Otherwise, it needs to be a null pointer constant.\n  } else {\n    return (e->isNullPointerConstant(C, Expr::NPC_ValueDependentIsNull)\n            ? IIK_okay : IIK_nonlocal);\n  }\n\n  return IIK_nonlocal;\n}\n\n/// Check whether the given expression is a valid operand for an\n/// indirect copy/restore.\nstatic void checkIndirectCopyRestoreSource(Sema &S, Expr *src) {\n  assert(src->isRValue());\n  bool isWeakAccess = false;\n  InvalidICRKind iik = isInvalidICRSource(S.Context, src, false, isWeakAccess);\n  // If isWeakAccess to true, there will be an implicit\n  // load which requires a cleanup.\n  if (S.getLangOpts().ObjCAutoRefCount && isWeakAccess)\n    S.Cleanup.setExprNeedsCleanups(true);\n\n  if (iik == IIK_okay) return;\n\n  S.Diag(src->getExprLoc(), diag::err_arc_nonlocal_writeback)\n    << ((unsigned) iik - 1)  // shift index into diagnostic explanations\n    << src->getSourceRange();\n}\n\n/// Determine whether we have compatible array types for the\n/// purposes of GNU by-copy array initialization.\nstatic bool hasCompatibleArrayTypes(ASTContext &Context, const ArrayType *Dest,\n                                    const ArrayType *Source) {\n  // If the source and destination array types are equivalent, we're\n  // done.\n  if (Context.hasSameType(QualType(Dest, 0), QualType(Source, 0)))\n    return true;\n\n  // Make sure that the element types are the same.\n  if (!Context.hasSameType(Dest->getElementType(), Source->getElementType()))\n    return false;\n\n  // The only mismatch we allow is when the destination is an\n  // incomplete array type and the source is a constant array type.\n  return Source->isConstantArrayType() && Dest->isIncompleteArrayType();\n}\n\nstatic bool tryObjCWritebackConversion(Sema &S,\n                                       InitializationSequence &Sequence,\n                                       const InitializedEntity &Entity,\n                                       Expr *Initializer) {\n  bool ArrayDecay = false;\n  QualType ArgType = Initializer->getType();\n  QualType ArgPointee;\n  if (const ArrayType *ArgArrayType = S.Context.getAsArrayType(ArgType)) {\n    ArrayDecay = true;\n    ArgPointee = ArgArrayType->getElementType();\n    ArgType = S.Context.getPointerType(ArgPointee);\n  }\n\n  // Handle write-back conversion.\n  QualType ConvertedArgType;\n  if (!S.isObjCWritebackConversion(ArgType, Entity.getType(),\n                                   ConvertedArgType))\n    return false;\n\n  // We should copy unless we're passing to an argument explicitly\n  // marked 'out'.\n  bool ShouldCopy = true;\n  if (ParmVarDecl *param = cast_or_null<ParmVarDecl>(Entity.getDecl()))\n    ShouldCopy = (param->getObjCDeclQualifier() != ParmVarDecl::OBJC_TQ_Out);\n\n  // Do we need an lvalue conversion?\n  if (ArrayDecay || Initializer->isGLValue()) {\n    ImplicitConversionSequence ICS;\n    ICS.setStandard();\n    ICS.Standard.setAsIdentityConversion();\n\n    QualType ResultType;\n    if (ArrayDecay) {\n      ICS.Standard.First = ICK_Array_To_Pointer;\n      ResultType = S.Context.getPointerType(ArgPointee);\n    } else {\n      ICS.Standard.First = ICK_Lvalue_To_Rvalue;\n      ResultType = Initializer->getType().getNonLValueExprType(S.Context);\n    }\n\n    Sequence.AddConversionSequenceStep(ICS, ResultType);\n  }\n\n  Sequence.AddPassByIndirectCopyRestoreStep(Entity.getType(), ShouldCopy);\n  return true;\n}\n\nstatic bool TryOCLSamplerInitialization(Sema &S,\n                                        InitializationSequence &Sequence,\n                                        QualType DestType,\n                                        Expr *Initializer) {\n  if (!S.getLangOpts().OpenCL || !DestType->isSamplerT() ||\n      (!Initializer->isIntegerConstantExpr(S.Context) &&\n      !Initializer->getType()->isSamplerT()))\n    return false;\n\n  Sequence.AddOCLSamplerInitStep(DestType);\n  return true;\n}\n\nstatic bool IsZeroInitializer(Expr *Initializer, Sema &S) {\n  return Initializer->isIntegerConstantExpr(S.getASTContext()) &&\n    (Initializer->EvaluateKnownConstInt(S.getASTContext()) == 0);\n}\n\nstatic bool TryOCLZeroOpaqueTypeInitialization(Sema &S,\n                                               InitializationSequence &Sequence,\n                                               QualType DestType,\n                                               Expr *Initializer) {\n  if (!S.getLangOpts().OpenCL)\n    return false;\n\n  //\n  // OpenCL 1.2 spec, s6.12.10\n  //\n  // The event argument can also be used to associate the\n  // async_work_group_copy with a previous async copy allowing\n  // an event to be shared by multiple async copies; otherwise\n  // event should be zero.\n  //\n  if (DestType->isEventT() || DestType->isQueueT()) {\n    if (!IsZeroInitializer(Initializer, S))\n      return false;\n\n    Sequence.AddOCLZeroOpaqueTypeStep(DestType);\n    return true;\n  }\n\n  // We should allow zero initialization for all types defined in the\n  // cl_intel_device_side_avc_motion_estimation extension, except\n  // intel_sub_group_avc_mce_payload_t and intel_sub_group_avc_mce_result_t.\n  if (S.getOpenCLOptions().isEnabled(\n          \"cl_intel_device_side_avc_motion_estimation\") &&\n      DestType->isOCLIntelSubgroupAVCType()) {\n    if (DestType->isOCLIntelSubgroupAVCMcePayloadType() ||\n        DestType->isOCLIntelSubgroupAVCMceResultType())\n      return false;\n    if (!IsZeroInitializer(Initializer, S))\n      return false;\n\n    Sequence.AddOCLZeroOpaqueTypeStep(DestType);\n    return true;\n  }\n\n  return false;\n}\n\nInitializationSequence::InitializationSequence(\n    Sema &S, const InitializedEntity &Entity, const InitializationKind &Kind,\n    MultiExprArg Args, bool TopLevelOfInitList, bool TreatUnavailableAsInvalid)\n    : FailedOverloadResult(OR_Success),\n      FailedCandidateSet(Kind.getLocation(), OverloadCandidateSet::CSK_Normal) {\n  InitializeFrom(S, Entity, Kind, Args, TopLevelOfInitList,\n                 TreatUnavailableAsInvalid);\n}\n\n/// Tries to get a FunctionDecl out of `E`. If it succeeds and we can take the\n/// address of that function, this returns true. Otherwise, it returns false.\nstatic bool isExprAnUnaddressableFunction(Sema &S, const Expr *E) {\n  auto *DRE = dyn_cast<DeclRefExpr>(E);\n  if (!DRE || !isa<FunctionDecl>(DRE->getDecl()))\n    return false;\n\n  return !S.checkAddressOfFunctionIsAvailable(\n      cast<FunctionDecl>(DRE->getDecl()));\n}\n\n/// Determine whether we can perform an elementwise array copy for this kind\n/// of entity.\nstatic bool canPerformArrayCopy(const InitializedEntity &Entity) {\n  switch (Entity.getKind()) {\n  case InitializedEntity::EK_LambdaCapture:\n    // C++ [expr.prim.lambda]p24:\n    //   For array members, the array elements are direct-initialized in\n    //   increasing subscript order.\n    return true;\n\n  case InitializedEntity::EK_Variable:\n    // C++ [dcl.decomp]p1:\n    //   [...] each element is copy-initialized or direct-initialized from the\n    //   corresponding element of the assignment-expression [...]\n    return isa<DecompositionDecl>(Entity.getDecl());\n\n  case InitializedEntity::EK_Member:\n    // C++ [class.copy.ctor]p14:\n    //   - if the member is an array, each element is direct-initialized with\n    //     the corresponding subobject of x\n    return Entity.isImplicitMemberInitializer();\n\n  case InitializedEntity::EK_ArrayElement:\n    // All the above cases are intended to apply recursively, even though none\n    // of them actually say that.\n    if (auto *E = Entity.getParent())\n      return canPerformArrayCopy(*E);\n    break;\n\n  default:\n    break;\n  }\n\n  return false;\n}\n\nvoid InitializationSequence::InitializeFrom(Sema &S,\n                                            const InitializedEntity &Entity,\n                                            const InitializationKind &Kind,\n                                            MultiExprArg Args,\n                                            bool TopLevelOfInitList,\n                                            bool TreatUnavailableAsInvalid) {\n  ASTContext &Context = S.Context;\n\n  // Eliminate non-overload placeholder types in the arguments.  We\n  // need to do this before checking whether types are dependent\n  // because lowering a pseudo-object expression might well give us\n  // something of dependent type.\n  for (unsigned I = 0, E = Args.size(); I != E; ++I)\n    if (Args[I]->getType()->isNonOverloadPlaceholderType()) {\n      // FIXME: should we be doing this here?\n      ExprResult result = S.CheckPlaceholderExpr(Args[I]);\n      if (result.isInvalid()) {\n        SetFailed(FK_PlaceholderType);\n        return;\n      }\n      Args[I] = result.get();\n    }\n\n  // C++0x [dcl.init]p16:\n  //   The semantics of initializers are as follows. The destination type is\n  //   the type of the object or reference being initialized and the source\n  //   type is the type of the initializer expression. The source type is not\n  //   defined when the initializer is a braced-init-list or when it is a\n  //   parenthesized list of expressions.\n  QualType DestType = Entity.getType();\n\n  if (DestType->isDependentType() ||\n      Expr::hasAnyTypeDependentArguments(Args)) {\n    SequenceKind = DependentSequence;\n    return;\n  }\n\n  // Almost everything is a normal sequence.\n  setSequenceKind(NormalSequence);\n\n  QualType SourceType;\n  Expr *Initializer = nullptr;\n  if (Args.size() == 1) {\n    Initializer = Args[0];\n    if (S.getLangOpts().ObjC) {\n      if (S.CheckObjCBridgeRelatedConversions(Initializer->getBeginLoc(),\n                                              DestType, Initializer->getType(),\n                                              Initializer) ||\n          S.CheckConversionToObjCLiteral(DestType, Initializer))\n        Args[0] = Initializer;\n    }\n    if (!isa<InitListExpr>(Initializer))\n      SourceType = Initializer->getType();\n  }\n\n  //     - If the initializer is a (non-parenthesized) braced-init-list, the\n  //       object is list-initialized (8.5.4).\n  if (Kind.getKind() != InitializationKind::IK_Direct) {\n    if (InitListExpr *InitList = dyn_cast_or_null<InitListExpr>(Initializer)) {\n      TryListInitialization(S, Entity, Kind, InitList, *this,\n                            TreatUnavailableAsInvalid);\n      return;\n    }\n  }\n\n  //     - If the destination type is a reference type, see 8.5.3.\n  if (DestType->isReferenceType()) {\n    // C++0x [dcl.init.ref]p1:\n    //   A variable declared to be a T& or T&&, that is, \"reference to type T\"\n    //   (8.3.2), shall be initialized by an object, or function, of type T or\n    //   by an object that can be converted into a T.\n    // (Therefore, multiple arguments are not permitted.)\n    if (Args.size() != 1)\n      SetFailed(FK_TooManyInitsForReference);\n    // C++17 [dcl.init.ref]p5:\n    //   A reference [...] is initialized by an expression [...] as follows:\n    // If the initializer is not an expression, presumably we should reject,\n    // but the standard fails to actually say so.\n    else if (isa<InitListExpr>(Args[0]))\n      SetFailed(FK_ParenthesizedListInitForReference);\n    else\n      TryReferenceInitialization(S, Entity, Kind, Args[0], *this);\n    return;\n  }\n\n  //     - If the initializer is (), the object is value-initialized.\n  if (Kind.getKind() == InitializationKind::IK_Value ||\n      (Kind.getKind() == InitializationKind::IK_Direct && Args.empty())) {\n    TryValueInitialization(S, Entity, Kind, *this);\n    return;\n  }\n\n  // Handle default initialization.\n  if (Kind.getKind() == InitializationKind::IK_Default) {\n    TryDefaultInitialization(S, Entity, Kind, *this);\n    return;\n  }\n\n  //     - If the destination type is an array of characters, an array of\n  //       char16_t, an array of char32_t, or an array of wchar_t, and the\n  //       initializer is a string literal, see 8.5.2.\n  //     - Otherwise, if the destination type is an array, the program is\n  //       ill-formed.\n  if (const ArrayType *DestAT = Context.getAsArrayType(DestType)) {\n    if (Initializer && isa<VariableArrayType>(DestAT)) {\n      SetFailed(FK_VariableLengthArrayHasInitializer);\n      return;\n    }\n\n    if (Initializer) {\n      switch (IsStringInit(Initializer, DestAT, Context)) {\n      case SIF_None:\n        TryStringLiteralInitialization(S, Entity, Kind, Initializer, *this);\n        return;\n      case SIF_NarrowStringIntoWideChar:\n        SetFailed(FK_NarrowStringIntoWideCharArray);\n        return;\n      case SIF_WideStringIntoChar:\n        SetFailed(FK_WideStringIntoCharArray);\n        return;\n      case SIF_IncompatWideStringIntoWideChar:\n        SetFailed(FK_IncompatWideStringIntoWideChar);\n        return;\n      case SIF_PlainStringIntoUTF8Char:\n        SetFailed(FK_PlainStringIntoUTF8Char);\n        return;\n      case SIF_UTF8StringIntoPlainChar:\n        SetFailed(FK_UTF8StringIntoPlainChar);\n        return;\n      case SIF_Other:\n        break;\n      }\n    }\n\n    // Some kinds of initialization permit an array to be initialized from\n    // another array of the same type, and perform elementwise initialization.\n    if (Initializer && isa<ConstantArrayType>(DestAT) &&\n        S.Context.hasSameUnqualifiedType(Initializer->getType(),\n                                         Entity.getType()) &&\n        canPerformArrayCopy(Entity)) {\n      // If source is a prvalue, use it directly.\n      if (Initializer->getValueKind() == VK_RValue) {\n        AddArrayInitStep(DestType, /*IsGNUExtension*/false);\n        return;\n      }\n\n      // Emit element-at-a-time copy loop.\n      InitializedEntity Element =\n          InitializedEntity::InitializeElement(S.Context, 0, Entity);\n      QualType InitEltT =\n          Context.getAsArrayType(Initializer->getType())->getElementType();\n      OpaqueValueExpr OVE(Initializer->getExprLoc(), InitEltT,\n                          Initializer->getValueKind(),\n                          Initializer->getObjectKind());\n      Expr *OVEAsExpr = &OVE;\n      InitializeFrom(S, Element, Kind, OVEAsExpr, TopLevelOfInitList,\n                     TreatUnavailableAsInvalid);\n      if (!Failed())\n        AddArrayInitLoopStep(Entity.getType(), InitEltT);\n      return;\n    }\n\n    // Note: as an GNU C extension, we allow initialization of an\n    // array from a compound literal that creates an array of the same\n    // type, so long as the initializer has no side effects.\n    if (!S.getLangOpts().CPlusPlus && Initializer &&\n        isa<CompoundLiteralExpr>(Initializer->IgnoreParens()) &&\n        Initializer->getType()->isArrayType()) {\n      const ArrayType *SourceAT\n        = Context.getAsArrayType(Initializer->getType());\n      if (!hasCompatibleArrayTypes(S.Context, DestAT, SourceAT))\n        SetFailed(FK_ArrayTypeMismatch);\n      else if (Initializer->HasSideEffects(S.Context))\n        SetFailed(FK_NonConstantArrayInit);\n      else {\n        AddArrayInitStep(DestType, /*IsGNUExtension*/true);\n      }\n    }\n    // Note: as a GNU C++ extension, we allow list-initialization of a\n    // class member of array type from a parenthesized initializer list.\n    else if (S.getLangOpts().CPlusPlus &&\n             Entity.getKind() == InitializedEntity::EK_Member &&\n             Initializer && isa<InitListExpr>(Initializer)) {\n      TryListInitialization(S, Entity, Kind, cast<InitListExpr>(Initializer),\n                            *this, TreatUnavailableAsInvalid);\n      AddParenthesizedArrayInitStep(DestType);\n    } else if (DestAT->getElementType()->isCharType())\n      SetFailed(FK_ArrayNeedsInitListOrStringLiteral);\n    else if (IsWideCharCompatible(DestAT->getElementType(), Context))\n      SetFailed(FK_ArrayNeedsInitListOrWideStringLiteral);\n    else\n      SetFailed(FK_ArrayNeedsInitList);\n\n    return;\n  }\n\n  // Determine whether we should consider writeback conversions for\n  // Objective-C ARC.\n  bool allowObjCWritebackConversion = S.getLangOpts().ObjCAutoRefCount &&\n         Entity.isParameterKind();\n\n  if (TryOCLSamplerInitialization(S, *this, DestType, Initializer))\n    return;\n\n  // We're at the end of the line for C: it's either a write-back conversion\n  // or it's a C assignment. There's no need to check anything else.\n  if (!S.getLangOpts().CPlusPlus) {\n    // If allowed, check whether this is an Objective-C writeback conversion.\n    if (allowObjCWritebackConversion &&\n        tryObjCWritebackConversion(S, *this, Entity, Initializer)) {\n      return;\n    }\n\n    if (TryOCLZeroOpaqueTypeInitialization(S, *this, DestType, Initializer))\n      return;\n\n    // Handle initialization in C\n    AddCAssignmentStep(DestType);\n    MaybeProduceObjCObject(S, *this, Entity);\n    return;\n  }\n\n  assert(S.getLangOpts().CPlusPlus);\n\n  //     - If the destination type is a (possibly cv-qualified) class type:\n  if (DestType->isRecordType()) {\n    //     - If the initialization is direct-initialization, or if it is\n    //       copy-initialization where the cv-unqualified version of the\n    //       source type is the same class as, or a derived class of, the\n    //       class of the destination, constructors are considered. [...]\n    if (Kind.getKind() == InitializationKind::IK_Direct ||\n        (Kind.getKind() == InitializationKind::IK_Copy &&\n         (Context.hasSameUnqualifiedType(SourceType, DestType) ||\n          S.IsDerivedFrom(Initializer->getBeginLoc(), SourceType, DestType))))\n      TryConstructorInitialization(S, Entity, Kind, Args,\n                                   DestType, DestType, *this);\n    //     - Otherwise (i.e., for the remaining copy-initialization cases),\n    //       user-defined conversion sequences that can convert from the source\n    //       type to the destination type or (when a conversion function is\n    //       used) to a derived class thereof are enumerated as described in\n    //       13.3.1.4, and the best one is chosen through overload resolution\n    //       (13.3).\n    else\n      TryUserDefinedConversion(S, DestType, Kind, Initializer, *this,\n                               TopLevelOfInitList);\n    return;\n  }\n\n  assert(Args.size() >= 1 && \"Zero-argument case handled above\");\n\n  // The remaining cases all need a source type.\n  if (Args.size() > 1) {\n    SetFailed(FK_TooManyInitsForScalar);\n    return;\n  } else if (isa<InitListExpr>(Args[0])) {\n    SetFailed(FK_ParenthesizedListInitForScalar);\n    return;\n  }\n\n  //    - Otherwise, if the source type is a (possibly cv-qualified) class\n  //      type, conversion functions are considered.\n  if (!SourceType.isNull() && SourceType->isRecordType()) {\n    // For a conversion to _Atomic(T) from either T or a class type derived\n    // from T, initialize the T object then convert to _Atomic type.\n    bool NeedAtomicConversion = false;\n    if (const AtomicType *Atomic = DestType->getAs<AtomicType>()) {\n      if (Context.hasSameUnqualifiedType(SourceType, Atomic->getValueType()) ||\n          S.IsDerivedFrom(Initializer->getBeginLoc(), SourceType,\n                          Atomic->getValueType())) {\n        DestType = Atomic->getValueType();\n        NeedAtomicConversion = true;\n      }\n    }\n\n    TryUserDefinedConversion(S, DestType, Kind, Initializer, *this,\n                             TopLevelOfInitList);\n    MaybeProduceObjCObject(S, *this, Entity);\n    if (!Failed() && NeedAtomicConversion)\n      AddAtomicConversionStep(Entity.getType());\n    return;\n  }\n\n  //    - Otherwise, if the initialization is direct-initialization, the source\n  //    type is std::nullptr_t, and the destination type is bool, the initial\n  //    value of the object being initialized is false.\n  if (!SourceType.isNull() && SourceType->isNullPtrType() &&\n      DestType->isBooleanType() &&\n      Kind.getKind() == InitializationKind::IK_Direct) {\n    AddConversionSequenceStep(\n        ImplicitConversionSequence::getNullptrToBool(SourceType, DestType,\n                                                     Initializer->isGLValue()),\n        DestType);\n    return;\n  }\n\n  //    - Otherwise, the initial value of the object being initialized is the\n  //      (possibly converted) value of the initializer expression. Standard\n  //      conversions (Clause 4) will be used, if necessary, to convert the\n  //      initializer expression to the cv-unqualified version of the\n  //      destination type; no user-defined conversions are considered.\n\n  ImplicitConversionSequence ICS\n    = S.TryImplicitConversion(Initializer, DestType,\n                              /*SuppressUserConversions*/true,\n                              Sema::AllowedExplicit::None,\n                              /*InOverloadResolution*/ false,\n                              /*CStyle=*/Kind.isCStyleOrFunctionalCast(),\n                              allowObjCWritebackConversion);\n\n  if (ICS.isStandard() &&\n      ICS.Standard.Second == ICK_Writeback_Conversion) {\n    // Objective-C ARC writeback conversion.\n\n    // We should copy unless we're passing to an argument explicitly\n    // marked 'out'.\n    bool ShouldCopy = true;\n    if (ParmVarDecl *Param = cast_or_null<ParmVarDecl>(Entity.getDecl()))\n      ShouldCopy = (Param->getObjCDeclQualifier() != ParmVarDecl::OBJC_TQ_Out);\n\n    // If there was an lvalue adjustment, add it as a separate conversion.\n    if (ICS.Standard.First == ICK_Array_To_Pointer ||\n        ICS.Standard.First == ICK_Lvalue_To_Rvalue) {\n      ImplicitConversionSequence LvalueICS;\n      LvalueICS.setStandard();\n      LvalueICS.Standard.setAsIdentityConversion();\n      LvalueICS.Standard.setAllToTypes(ICS.Standard.getToType(0));\n      LvalueICS.Standard.First = ICS.Standard.First;\n      AddConversionSequenceStep(LvalueICS, ICS.Standard.getToType(0));\n    }\n\n    AddPassByIndirectCopyRestoreStep(DestType, ShouldCopy);\n  } else if (ICS.isBad()) {\n    DeclAccessPair dap;\n    if (isLibstdcxxPointerReturnFalseHack(S, Entity, Initializer)) {\n      AddZeroInitializationStep(Entity.getType());\n    } else if (Initializer->getType() == Context.OverloadTy &&\n               !S.ResolveAddressOfOverloadedFunction(Initializer, DestType,\n                                                     false, dap))\n      SetFailed(InitializationSequence::FK_AddressOfOverloadFailed);\n    else if (Initializer->getType()->isFunctionType() &&\n             isExprAnUnaddressableFunction(S, Initializer))\n      SetFailed(InitializationSequence::FK_AddressOfUnaddressableFunction);\n    else\n      SetFailed(InitializationSequence::FK_ConversionFailed);\n  } else {\n    AddConversionSequenceStep(ICS, DestType, TopLevelOfInitList);\n\n    MaybeProduceObjCObject(S, *this, Entity);\n  }\n}\n\nInitializationSequence::~InitializationSequence() {\n  for (auto &S : Steps)\n    S.Destroy();\n}\n\n//===----------------------------------------------------------------------===//\n// Perform initialization\n//===----------------------------------------------------------------------===//\nstatic Sema::AssignmentAction\ngetAssignmentAction(const InitializedEntity &Entity, bool Diagnose = false) {\n  switch(Entity.getKind()) {\n  case InitializedEntity::EK_Variable:\n  case InitializedEntity::EK_New:\n  case InitializedEntity::EK_Exception:\n  case InitializedEntity::EK_Base:\n  case InitializedEntity::EK_Delegating:\n    return Sema::AA_Initializing;\n\n  case InitializedEntity::EK_Parameter:\n    if (Entity.getDecl() &&\n        isa<ObjCMethodDecl>(Entity.getDecl()->getDeclContext()))\n      return Sema::AA_Sending;\n\n    return Sema::AA_Passing;\n\n  case InitializedEntity::EK_Parameter_CF_Audited:\n    if (Entity.getDecl() &&\n      isa<ObjCMethodDecl>(Entity.getDecl()->getDeclContext()))\n      return Sema::AA_Sending;\n\n    return !Diagnose ? Sema::AA_Passing : Sema::AA_Passing_CFAudited;\n\n  case InitializedEntity::EK_Result:\n  case InitializedEntity::EK_StmtExprResult: // FIXME: Not quite right.\n    return Sema::AA_Returning;\n\n  case InitializedEntity::EK_Temporary:\n  case InitializedEntity::EK_RelatedResult:\n    // FIXME: Can we tell apart casting vs. converting?\n    return Sema::AA_Casting;\n\n  case InitializedEntity::EK_TemplateParameter:\n    // This is really initialization, but refer to it as conversion for\n    // consistency with CheckConvertedConstantExpression.\n    return Sema::AA_Converting;\n\n  case InitializedEntity::EK_Member:\n  case InitializedEntity::EK_Binding:\n  case InitializedEntity::EK_ArrayElement:\n  case InitializedEntity::EK_VectorElement:\n  case InitializedEntity::EK_ComplexElement:\n  case InitializedEntity::EK_BlockElement:\n  case InitializedEntity::EK_LambdaToBlockConversionBlockElement:\n  case InitializedEntity::EK_LambdaCapture:\n  case InitializedEntity::EK_CompoundLiteralInit:\n    return Sema::AA_Initializing;\n  }\n\n  llvm_unreachable(\"Invalid EntityKind!\");\n}\n\n/// Whether we should bind a created object as a temporary when\n/// initializing the given entity.\nstatic bool shouldBindAsTemporary(const InitializedEntity &Entity) {\n  switch (Entity.getKind()) {\n  case InitializedEntity::EK_ArrayElement:\n  case InitializedEntity::EK_Member:\n  case InitializedEntity::EK_Result:\n  case InitializedEntity::EK_StmtExprResult:\n  case InitializedEntity::EK_New:\n  case InitializedEntity::EK_Variable:\n  case InitializedEntity::EK_Base:\n  case InitializedEntity::EK_Delegating:\n  case InitializedEntity::EK_VectorElement:\n  case InitializedEntity::EK_ComplexElement:\n  case InitializedEntity::EK_Exception:\n  case InitializedEntity::EK_BlockElement:\n  case InitializedEntity::EK_LambdaToBlockConversionBlockElement:\n  case InitializedEntity::EK_LambdaCapture:\n  case InitializedEntity::EK_CompoundLiteralInit:\n  case InitializedEntity::EK_TemplateParameter:\n    return false;\n\n  case InitializedEntity::EK_Parameter:\n  case InitializedEntity::EK_Parameter_CF_Audited:\n  case InitializedEntity::EK_Temporary:\n  case InitializedEntity::EK_RelatedResult:\n  case InitializedEntity::EK_Binding:\n    return true;\n  }\n\n  llvm_unreachable(\"missed an InitializedEntity kind?\");\n}\n\n/// Whether the given entity, when initialized with an object\n/// created for that initialization, requires destruction.\nstatic bool shouldDestroyEntity(const InitializedEntity &Entity) {\n  switch (Entity.getKind()) {\n    case InitializedEntity::EK_Result:\n    case InitializedEntity::EK_StmtExprResult:\n    case InitializedEntity::EK_New:\n    case InitializedEntity::EK_Base:\n    case InitializedEntity::EK_Delegating:\n    case InitializedEntity::EK_VectorElement:\n    case InitializedEntity::EK_ComplexElement:\n    case InitializedEntity::EK_BlockElement:\n    case InitializedEntity::EK_LambdaToBlockConversionBlockElement:\n    case InitializedEntity::EK_LambdaCapture:\n      return false;\n\n    case InitializedEntity::EK_Member:\n    case InitializedEntity::EK_Binding:\n    case InitializedEntity::EK_Variable:\n    case InitializedEntity::EK_Parameter:\n    case InitializedEntity::EK_Parameter_CF_Audited:\n    case InitializedEntity::EK_TemplateParameter:\n    case InitializedEntity::EK_Temporary:\n    case InitializedEntity::EK_ArrayElement:\n    case InitializedEntity::EK_Exception:\n    case InitializedEntity::EK_CompoundLiteralInit:\n    case InitializedEntity::EK_RelatedResult:\n      return true;\n  }\n\n  llvm_unreachable(\"missed an InitializedEntity kind?\");\n}\n\n/// Get the location at which initialization diagnostics should appear.\nstatic SourceLocation getInitializationLoc(const InitializedEntity &Entity,\n                                           Expr *Initializer) {\n  switch (Entity.getKind()) {\n  case InitializedEntity::EK_Result:\n  case InitializedEntity::EK_StmtExprResult:\n    return Entity.getReturnLoc();\n\n  case InitializedEntity::EK_Exception:\n    return Entity.getThrowLoc();\n\n  case InitializedEntity::EK_Variable:\n  case InitializedEntity::EK_Binding:\n    return Entity.getDecl()->getLocation();\n\n  case InitializedEntity::EK_LambdaCapture:\n    return Entity.getCaptureLoc();\n\n  case InitializedEntity::EK_ArrayElement:\n  case InitializedEntity::EK_Member:\n  case InitializedEntity::EK_Parameter:\n  case InitializedEntity::EK_Parameter_CF_Audited:\n  case InitializedEntity::EK_TemplateParameter:\n  case InitializedEntity::EK_Temporary:\n  case InitializedEntity::EK_New:\n  case InitializedEntity::EK_Base:\n  case InitializedEntity::EK_Delegating:\n  case InitializedEntity::EK_VectorElement:\n  case InitializedEntity::EK_ComplexElement:\n  case InitializedEntity::EK_BlockElement:\n  case InitializedEntity::EK_LambdaToBlockConversionBlockElement:\n  case InitializedEntity::EK_CompoundLiteralInit:\n  case InitializedEntity::EK_RelatedResult:\n    return Initializer->getBeginLoc();\n  }\n  llvm_unreachable(\"missed an InitializedEntity kind?\");\n}\n\n/// Make a (potentially elidable) temporary copy of the object\n/// provided by the given initializer by calling the appropriate copy\n/// constructor.\n///\n/// \\param S The Sema object used for type-checking.\n///\n/// \\param T The type of the temporary object, which must either be\n/// the type of the initializer expression or a superclass thereof.\n///\n/// \\param Entity The entity being initialized.\n///\n/// \\param CurInit The initializer expression.\n///\n/// \\param IsExtraneousCopy Whether this is an \"extraneous\" copy that\n/// is permitted in C++03 (but not C++0x) when binding a reference to\n/// an rvalue.\n///\n/// \\returns An expression that copies the initializer expression into\n/// a temporary object, or an error expression if a copy could not be\n/// created.\nstatic ExprResult CopyObject(Sema &S,\n                             QualType T,\n                             const InitializedEntity &Entity,\n                             ExprResult CurInit,\n                             bool IsExtraneousCopy) {\n  if (CurInit.isInvalid())\n    return CurInit;\n  // Determine which class type we're copying to.\n  Expr *CurInitExpr = (Expr *)CurInit.get();\n  CXXRecordDecl *Class = nullptr;\n  if (const RecordType *Record = T->getAs<RecordType>())\n    Class = cast<CXXRecordDecl>(Record->getDecl());\n  if (!Class)\n    return CurInit;\n\n  SourceLocation Loc = getInitializationLoc(Entity, CurInit.get());\n\n  // Make sure that the type we are copying is complete.\n  if (S.RequireCompleteType(Loc, T, diag::err_temp_copy_incomplete))\n    return CurInit;\n\n  // Perform overload resolution using the class's constructors. Per\n  // C++11 [dcl.init]p16, second bullet for class types, this initialization\n  // is direct-initialization.\n  OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);\n  DeclContext::lookup_result Ctors = S.LookupConstructors(Class);\n\n  OverloadCandidateSet::iterator Best;\n  switch (ResolveConstructorOverload(\n      S, Loc, CurInitExpr, CandidateSet, T, Ctors, Best,\n      /*CopyInitializing=*/false, /*AllowExplicit=*/true,\n      /*OnlyListConstructors=*/false, /*IsListInit=*/false,\n      /*SecondStepOfCopyInit=*/true)) {\n  case OR_Success:\n    break;\n\n  case OR_No_Viable_Function:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(\n            Loc, S.PDiag(IsExtraneousCopy && !S.isSFINAEContext()\n                             ? diag::ext_rvalue_to_reference_temp_copy_no_viable\n                             : diag::err_temp_copy_no_viable)\n                     << (int)Entity.getKind() << CurInitExpr->getType()\n                     << CurInitExpr->getSourceRange()),\n        S, OCD_AllCandidates, CurInitExpr);\n    if (!IsExtraneousCopy || S.isSFINAEContext())\n      return ExprError();\n    return CurInit;\n\n  case OR_Ambiguous:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(Loc, S.PDiag(diag::err_temp_copy_ambiguous)\n                                     << (int)Entity.getKind()\n                                     << CurInitExpr->getType()\n                                     << CurInitExpr->getSourceRange()),\n        S, OCD_AmbiguousCandidates, CurInitExpr);\n    return ExprError();\n\n  case OR_Deleted:\n    S.Diag(Loc, diag::err_temp_copy_deleted)\n      << (int)Entity.getKind() << CurInitExpr->getType()\n      << CurInitExpr->getSourceRange();\n    S.NoteDeletedFunction(Best->Function);\n    return ExprError();\n  }\n\n  bool HadMultipleCandidates = CandidateSet.size() > 1;\n\n  CXXConstructorDecl *Constructor = cast<CXXConstructorDecl>(Best->Function);\n  SmallVector<Expr*, 8> ConstructorArgs;\n  CurInit.get(); // Ownership transferred into MultiExprArg, below.\n\n  S.CheckConstructorAccess(Loc, Constructor, Best->FoundDecl, Entity,\n                           IsExtraneousCopy);\n\n  if (IsExtraneousCopy) {\n    // If this is a totally extraneous copy for C++03 reference\n    // binding purposes, just return the original initialization\n    // expression. We don't generate an (elided) copy operation here\n    // because doing so would require us to pass down a flag to avoid\n    // infinite recursion, where each step adds another extraneous,\n    // elidable copy.\n\n    // Instantiate the default arguments of any extra parameters in\n    // the selected copy constructor, as if we were going to create a\n    // proper call to the copy constructor.\n    for (unsigned I = 1, N = Constructor->getNumParams(); I != N; ++I) {\n      ParmVarDecl *Parm = Constructor->getParamDecl(I);\n      if (S.RequireCompleteType(Loc, Parm->getType(),\n                                diag::err_call_incomplete_argument))\n        break;\n\n      // Build the default argument expression; we don't actually care\n      // if this succeeds or not, because this routine will complain\n      // if there was a problem.\n      S.BuildCXXDefaultArgExpr(Loc, Constructor, Parm);\n    }\n\n    return CurInitExpr;\n  }\n\n  // Determine the arguments required to actually perform the\n  // constructor call (we might have derived-to-base conversions, or\n  // the copy constructor may have default arguments).\n  if (S.CompleteConstructorCall(Constructor, T, CurInitExpr, Loc,\n                                ConstructorArgs))\n    return ExprError();\n\n  // C++0x [class.copy]p32:\n  //   When certain criteria are met, an implementation is allowed to\n  //   omit the copy/move construction of a class object, even if the\n  //   copy/move constructor and/or destructor for the object have\n  //   side effects. [...]\n  //     - when a temporary class object that has not been bound to a\n  //       reference (12.2) would be copied/moved to a class object\n  //       with the same cv-unqualified type, the copy/move operation\n  //       can be omitted by constructing the temporary object\n  //       directly into the target of the omitted copy/move\n  //\n  // Note that the other three bullets are handled elsewhere. Copy\n  // elision for return statements and throw expressions are handled as part\n  // of constructor initialization, while copy elision for exception handlers\n  // is handled by the run-time.\n  //\n  // FIXME: If the function parameter is not the same type as the temporary, we\n  // should still be able to elide the copy, but we don't have a way to\n  // represent in the AST how much should be elided in this case.\n  bool Elidable =\n      CurInitExpr->isTemporaryObject(S.Context, Class) &&\n      S.Context.hasSameUnqualifiedType(\n          Best->Function->getParamDecl(0)->getType().getNonReferenceType(),\n          CurInitExpr->getType());\n\n  // Actually perform the constructor call.\n  CurInit = S.BuildCXXConstructExpr(Loc, T, Best->FoundDecl, Constructor,\n                                    Elidable,\n                                    ConstructorArgs,\n                                    HadMultipleCandidates,\n                                    /*ListInit*/ false,\n                                    /*StdInitListInit*/ false,\n                                    /*ZeroInit*/ false,\n                                    CXXConstructExpr::CK_Complete,\n                                    SourceRange());\n\n  // If we're supposed to bind temporaries, do so.\n  if (!CurInit.isInvalid() && shouldBindAsTemporary(Entity))\n    CurInit = S.MaybeBindToTemporary(CurInit.getAs<Expr>());\n  return CurInit;\n}\n\n/// Check whether elidable copy construction for binding a reference to\n/// a temporary would have succeeded if we were building in C++98 mode, for\n/// -Wc++98-compat.\nstatic void CheckCXX98CompatAccessibleCopy(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           Expr *CurInitExpr) {\n  assert(S.getLangOpts().CPlusPlus11);\n\n  const RecordType *Record = CurInitExpr->getType()->getAs<RecordType>();\n  if (!Record)\n    return;\n\n  SourceLocation Loc = getInitializationLoc(Entity, CurInitExpr);\n  if (S.Diags.isIgnored(diag::warn_cxx98_compat_temp_copy, Loc))\n    return;\n\n  // Find constructors which would have been considered.\n  OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);\n  DeclContext::lookup_result Ctors =\n      S.LookupConstructors(cast<CXXRecordDecl>(Record->getDecl()));\n\n  // Perform overload resolution.\n  OverloadCandidateSet::iterator Best;\n  OverloadingResult OR = ResolveConstructorOverload(\n      S, Loc, CurInitExpr, CandidateSet, CurInitExpr->getType(), Ctors, Best,\n      /*CopyInitializing=*/false, /*AllowExplicit=*/true,\n      /*OnlyListConstructors=*/false, /*IsListInit=*/false,\n      /*SecondStepOfCopyInit=*/true);\n\n  PartialDiagnostic Diag = S.PDiag(diag::warn_cxx98_compat_temp_copy)\n    << OR << (int)Entity.getKind() << CurInitExpr->getType()\n    << CurInitExpr->getSourceRange();\n\n  switch (OR) {\n  case OR_Success:\n    S.CheckConstructorAccess(Loc, cast<CXXConstructorDecl>(Best->Function),\n                             Best->FoundDecl, Entity, Diag);\n    // FIXME: Check default arguments as far as that's possible.\n    break;\n\n  case OR_No_Viable_Function:\n    CandidateSet.NoteCandidates(PartialDiagnosticAt(Loc, Diag), S,\n                                OCD_AllCandidates, CurInitExpr);\n    break;\n\n  case OR_Ambiguous:\n    CandidateSet.NoteCandidates(PartialDiagnosticAt(Loc, Diag), S,\n                                OCD_AmbiguousCandidates, CurInitExpr);\n    break;\n\n  case OR_Deleted:\n    S.Diag(Loc, Diag);\n    S.NoteDeletedFunction(Best->Function);\n    break;\n  }\n}\n\nvoid InitializationSequence::PrintInitLocationNote(Sema &S,\n                                              const InitializedEntity &Entity) {\n  if (Entity.isParamOrTemplateParamKind() && Entity.getDecl()) {\n    if (Entity.getDecl()->getLocation().isInvalid())\n      return;\n\n    if (Entity.getDecl()->getDeclName())\n      S.Diag(Entity.getDecl()->getLocation(), diag::note_parameter_named_here)\n        << Entity.getDecl()->getDeclName();\n    else\n      S.Diag(Entity.getDecl()->getLocation(), diag::note_parameter_here);\n  }\n  else if (Entity.getKind() == InitializedEntity::EK_RelatedResult &&\n           Entity.getMethodDecl())\n    S.Diag(Entity.getMethodDecl()->getLocation(),\n           diag::note_method_return_type_change)\n      << Entity.getMethodDecl()->getDeclName();\n}\n\n/// Returns true if the parameters describe a constructor initialization of\n/// an explicit temporary object, e.g. \"Point(x, y)\".\nstatic bool isExplicitTemporary(const InitializedEntity &Entity,\n                                const InitializationKind &Kind,\n                                unsigned NumArgs) {\n  switch (Entity.getKind()) {\n  case InitializedEntity::EK_Temporary:\n  case InitializedEntity::EK_CompoundLiteralInit:\n  case InitializedEntity::EK_RelatedResult:\n    break;\n  default:\n    return false;\n  }\n\n  switch (Kind.getKind()) {\n  case InitializationKind::IK_DirectList:\n    return true;\n  // FIXME: Hack to work around cast weirdness.\n  case InitializationKind::IK_Direct:\n  case InitializationKind::IK_Value:\n    return NumArgs != 1;\n  default:\n    return false;\n  }\n}\n\nstatic ExprResult\nPerformConstructorInitialization(Sema &S,\n                                 const InitializedEntity &Entity,\n                                 const InitializationKind &Kind,\n                                 MultiExprArg Args,\n                                 const InitializationSequence::Step& Step,\n                                 bool &ConstructorInitRequiresZeroInit,\n                                 bool IsListInitialization,\n                                 bool IsStdInitListInitialization,\n                                 SourceLocation LBraceLoc,\n                                 SourceLocation RBraceLoc) {\n  unsigned NumArgs = Args.size();\n  CXXConstructorDecl *Constructor\n    = cast<CXXConstructorDecl>(Step.Function.Function);\n  bool HadMultipleCandidates = Step.Function.HadMultipleCandidates;\n\n  // Build a call to the selected constructor.\n  SmallVector<Expr*, 8> ConstructorArgs;\n  SourceLocation Loc = (Kind.isCopyInit() && Kind.getEqualLoc().isValid())\n                         ? Kind.getEqualLoc()\n                         : Kind.getLocation();\n\n  if (Kind.getKind() == InitializationKind::IK_Default) {\n    // Force even a trivial, implicit default constructor to be\n    // semantically checked. We do this explicitly because we don't build\n    // the definition for completely trivial constructors.\n    assert(Constructor->getParent() && \"No parent class for constructor.\");\n    if (Constructor->isDefaulted() && Constructor->isDefaultConstructor() &&\n        Constructor->isTrivial() && !Constructor->isUsed(false)) {\n      S.runWithSufficientStackSpace(Loc, [&] {\n        S.DefineImplicitDefaultConstructor(Loc, Constructor);\n      });\n    }\n  }\n\n  ExprResult CurInit((Expr *)nullptr);\n\n  // C++ [over.match.copy]p1:\n  //   - When initializing a temporary to be bound to the first parameter\n  //     of a constructor that takes a reference to possibly cv-qualified\n  //     T as its first argument, called with a single argument in the\n  //     context of direct-initialization, explicit conversion functions\n  //     are also considered.\n  bool AllowExplicitConv =\n      Kind.AllowExplicit() && !Kind.isCopyInit() && Args.size() == 1 &&\n      hasCopyOrMoveCtorParam(S.Context,\n                             getConstructorInfo(Step.Function.FoundDecl));\n\n  // Determine the arguments required to actually perform the constructor\n  // call.\n  if (S.CompleteConstructorCall(Constructor, Step.Type, Args, Loc,\n                                ConstructorArgs, AllowExplicitConv,\n                                IsListInitialization))\n    return ExprError();\n\n  if (isExplicitTemporary(Entity, Kind, NumArgs)) {\n    // An explicitly-constructed temporary, e.g., X(1, 2).\n    if (S.DiagnoseUseOfDecl(Constructor, Loc))\n      return ExprError();\n\n    TypeSourceInfo *TSInfo = Entity.getTypeSourceInfo();\n    if (!TSInfo)\n      TSInfo = S.Context.getTrivialTypeSourceInfo(Entity.getType(), Loc);\n    SourceRange ParenOrBraceRange =\n        (Kind.getKind() == InitializationKind::IK_DirectList)\n        ? SourceRange(LBraceLoc, RBraceLoc)\n        : Kind.getParenOrBraceRange();\n\n    CXXConstructorDecl *CalleeDecl = Constructor;\n    if (auto *Shadow = dyn_cast<ConstructorUsingShadowDecl>(\n            Step.Function.FoundDecl.getDecl())) {\n      CalleeDecl = S.findInheritingConstructor(Loc, Constructor, Shadow);\n      if (S.DiagnoseUseOfDecl(CalleeDecl, Loc))\n        return ExprError();\n    }\n    S.MarkFunctionReferenced(Loc, CalleeDecl);\n\n    CurInit = S.CheckForImmediateInvocation(\n        CXXTemporaryObjectExpr::Create(\n            S.Context, CalleeDecl,\n            Entity.getType().getNonLValueExprType(S.Context), TSInfo,\n            ConstructorArgs, ParenOrBraceRange, HadMultipleCandidates,\n            IsListInitialization, IsStdInitListInitialization,\n            ConstructorInitRequiresZeroInit),\n        CalleeDecl);\n  } else {\n    CXXConstructExpr::ConstructionKind ConstructKind =\n      CXXConstructExpr::CK_Complete;\n\n    if (Entity.getKind() == InitializedEntity::EK_Base) {\n      ConstructKind = Entity.getBaseSpecifier()->isVirtual() ?\n        CXXConstructExpr::CK_VirtualBase :\n        CXXConstructExpr::CK_NonVirtualBase;\n    } else if (Entity.getKind() == InitializedEntity::EK_Delegating) {\n      ConstructKind = CXXConstructExpr::CK_Delegating;\n    }\n\n    // Only get the parenthesis or brace range if it is a list initialization or\n    // direct construction.\n    SourceRange ParenOrBraceRange;\n    if (IsListInitialization)\n      ParenOrBraceRange = SourceRange(LBraceLoc, RBraceLoc);\n    else if (Kind.getKind() == InitializationKind::IK_Direct)\n      ParenOrBraceRange = Kind.getParenOrBraceRange();\n\n    // If the entity allows NRVO, mark the construction as elidable\n    // unconditionally.\n    if (Entity.allowsNRVO())\n      CurInit = S.BuildCXXConstructExpr(Loc, Step.Type,\n                                        Step.Function.FoundDecl,\n                                        Constructor, /*Elidable=*/true,\n                                        ConstructorArgs,\n                                        HadMultipleCandidates,\n                                        IsListInitialization,\n                                        IsStdInitListInitialization,\n                                        ConstructorInitRequiresZeroInit,\n                                        ConstructKind,\n                                        ParenOrBraceRange);\n    else\n      CurInit = S.BuildCXXConstructExpr(Loc, Step.Type,\n                                        Step.Function.FoundDecl,\n                                        Constructor,\n                                        ConstructorArgs,\n                                        HadMultipleCandidates,\n                                        IsListInitialization,\n                                        IsStdInitListInitialization,\n                                        ConstructorInitRequiresZeroInit,\n                                        ConstructKind,\n                                        ParenOrBraceRange);\n  }\n  if (CurInit.isInvalid())\n    return ExprError();\n\n  // Only check access if all of that succeeded.\n  S.CheckConstructorAccess(Loc, Constructor, Step.Function.FoundDecl, Entity);\n  if (S.DiagnoseUseOfDecl(Step.Function.FoundDecl, Loc))\n    return ExprError();\n\n  if (const ArrayType *AT = S.Context.getAsArrayType(Entity.getType()))\n    if (checkDestructorReference(S.Context.getBaseElementType(AT), Loc, S))\n      return ExprError();\n\n  if (shouldBindAsTemporary(Entity))\n    CurInit = S.MaybeBindToTemporary(CurInit.get());\n\n  return CurInit;\n}\n\nnamespace {\nenum LifetimeKind {\n  /// The lifetime of a temporary bound to this entity ends at the end of the\n  /// full-expression, and that's (probably) fine.\n  LK_FullExpression,\n\n  /// The lifetime of a temporary bound to this entity is extended to the\n  /// lifeitme of the entity itself.\n  LK_Extended,\n\n  /// The lifetime of a temporary bound to this entity probably ends too soon,\n  /// because the entity is allocated in a new-expression.\n  LK_New,\n\n  /// The lifetime of a temporary bound to this entity ends too soon, because\n  /// the entity is a return object.\n  LK_Return,\n\n  /// The lifetime of a temporary bound to this entity ends too soon, because\n  /// the entity is the result of a statement expression.\n  LK_StmtExprResult,\n\n  /// This is a mem-initializer: if it would extend a temporary (other than via\n  /// a default member initializer), the program is ill-formed.\n  LK_MemInitializer,\n};\nusing LifetimeResult =\n    llvm::PointerIntPair<const InitializedEntity *, 3, LifetimeKind>;\n}\n\n/// Determine the declaration which an initialized entity ultimately refers to,\n/// for the purpose of lifetime-extending a temporary bound to a reference in\n/// the initialization of \\p Entity.\nstatic LifetimeResult getEntityLifetime(\n    const InitializedEntity *Entity,\n    const InitializedEntity *InitField = nullptr) {\n  // C++11 [class.temporary]p5:\n  switch (Entity->getKind()) {\n  case InitializedEntity::EK_Variable:\n    //   The temporary [...] persists for the lifetime of the reference\n    return {Entity, LK_Extended};\n\n  case InitializedEntity::EK_Member:\n    // For subobjects, we look at the complete object.\n    if (Entity->getParent())\n      return getEntityLifetime(Entity->getParent(), Entity);\n\n    //   except:\n    // C++17 [class.base.init]p8:\n    //   A temporary expression bound to a reference member in a\n    //   mem-initializer is ill-formed.\n    // C++17 [class.base.init]p11:\n    //   A temporary expression bound to a reference member from a\n    //   default member initializer is ill-formed.\n    //\n    // The context of p11 and its example suggest that it's only the use of a\n    // default member initializer from a constructor that makes the program\n    // ill-formed, not its mere existence, and that it can even be used by\n    // aggregate initialization.\n    return {Entity, Entity->isDefaultMemberInitializer() ? LK_Extended\n                                                         : LK_MemInitializer};\n\n  case InitializedEntity::EK_Binding:\n    // Per [dcl.decomp]p3, the binding is treated as a variable of reference\n    // type.\n    return {Entity, LK_Extended};\n\n  case InitializedEntity::EK_Parameter:\n  case InitializedEntity::EK_Parameter_CF_Audited:\n    //   -- A temporary bound to a reference parameter in a function call\n    //      persists until the completion of the full-expression containing\n    //      the call.\n    return {nullptr, LK_FullExpression};\n\n  case InitializedEntity::EK_TemplateParameter:\n    // FIXME: This will always be ill-formed; should we eagerly diagnose it here?\n    return {nullptr, LK_FullExpression};\n\n  case InitializedEntity::EK_Result:\n    //   -- The lifetime of a temporary bound to the returned value in a\n    //      function return statement is not extended; the temporary is\n    //      destroyed at the end of the full-expression in the return statement.\n    return {nullptr, LK_Return};\n\n  case InitializedEntity::EK_StmtExprResult:\n    // FIXME: Should we lifetime-extend through the result of a statement\n    // expression?\n    return {nullptr, LK_StmtExprResult};\n\n  case InitializedEntity::EK_New:\n    //   -- A temporary bound to a reference in a new-initializer persists\n    //      until the completion of the full-expression containing the\n    //      new-initializer.\n    return {nullptr, LK_New};\n\n  case InitializedEntity::EK_Temporary:\n  case InitializedEntity::EK_CompoundLiteralInit:\n  case InitializedEntity::EK_RelatedResult:\n    // We don't yet know the storage duration of the surrounding temporary.\n    // Assume it's got full-expression duration for now, it will patch up our\n    // storage duration if that's not correct.\n    return {nullptr, LK_FullExpression};\n\n  case InitializedEntity::EK_ArrayElement:\n    // For subobjects, we look at the complete object.\n    return getEntityLifetime(Entity->getParent(), InitField);\n\n  case InitializedEntity::EK_Base:\n    // For subobjects, we look at the complete object.\n    if (Entity->getParent())\n      return getEntityLifetime(Entity->getParent(), InitField);\n    return {InitField, LK_MemInitializer};\n\n  case InitializedEntity::EK_Delegating:\n    // We can reach this case for aggregate initialization in a constructor:\n    //   struct A { int &&r; };\n    //   struct B : A { B() : A{0} {} };\n    // In this case, use the outermost field decl as the context.\n    return {InitField, LK_MemInitializer};\n\n  case InitializedEntity::EK_BlockElement:\n  case InitializedEntity::EK_LambdaToBlockConversionBlockElement:\n  case InitializedEntity::EK_LambdaCapture:\n  case InitializedEntity::EK_VectorElement:\n  case InitializedEntity::EK_ComplexElement:\n    return {nullptr, LK_FullExpression};\n\n  case InitializedEntity::EK_Exception:\n    // FIXME: Can we diagnose lifetime problems with exceptions?\n    return {nullptr, LK_FullExpression};\n  }\n  llvm_unreachable(\"unknown entity kind\");\n}\n\nnamespace {\nenum ReferenceKind {\n  /// Lifetime would be extended by a reference binding to a temporary.\n  RK_ReferenceBinding,\n  /// Lifetime would be extended by a std::initializer_list object binding to\n  /// its backing array.\n  RK_StdInitializerList,\n};\n\n/// A temporary or local variable. This will be one of:\n///  * A MaterializeTemporaryExpr.\n///  * A DeclRefExpr whose declaration is a local.\n///  * An AddrLabelExpr.\n///  * A BlockExpr for a block with captures.\nusing Local = Expr*;\n\n/// Expressions we stepped over when looking for the local state. Any steps\n/// that would inhibit lifetime extension or take us out of subexpressions of\n/// the initializer are included.\nstruct IndirectLocalPathEntry {\n  enum EntryKind {\n    DefaultInit,\n    AddressOf,\n    VarInit,\n    LValToRVal,\n    LifetimeBoundCall,\n    TemporaryCopy,\n    LambdaCaptureInit,\n    GslReferenceInit,\n    GslPointerInit\n  } Kind;\n  Expr *E;\n  union {\n    const Decl *D = nullptr;\n    const LambdaCapture *Capture;\n  };\n  IndirectLocalPathEntry() {}\n  IndirectLocalPathEntry(EntryKind K, Expr *E) : Kind(K), E(E) {}\n  IndirectLocalPathEntry(EntryKind K, Expr *E, const Decl *D)\n      : Kind(K), E(E), D(D) {}\n  IndirectLocalPathEntry(EntryKind K, Expr *E, const LambdaCapture *Capture)\n      : Kind(K), E(E), Capture(Capture) {}\n};\n\nusing IndirectLocalPath = llvm::SmallVectorImpl<IndirectLocalPathEntry>;\n\nstruct RevertToOldSizeRAII {\n  IndirectLocalPath &Path;\n  unsigned OldSize = Path.size();\n  RevertToOldSizeRAII(IndirectLocalPath &Path) : Path(Path) {}\n  ~RevertToOldSizeRAII() { Path.resize(OldSize); }\n};\n\nusing LocalVisitor = llvm::function_ref<bool(IndirectLocalPath &Path, Local L,\n                                             ReferenceKind RK)>;\n}\n\nstatic bool isVarOnPath(IndirectLocalPath &Path, VarDecl *VD) {\n  for (auto E : Path)\n    if (E.Kind == IndirectLocalPathEntry::VarInit && E.D == VD)\n      return true;\n  return false;\n}\n\nstatic bool pathContainsInit(IndirectLocalPath &Path) {\n  return llvm::any_of(Path, [=](IndirectLocalPathEntry E) {\n    return E.Kind == IndirectLocalPathEntry::DefaultInit ||\n           E.Kind == IndirectLocalPathEntry::VarInit;\n  });\n}\n\nstatic void visitLocalsRetainedByInitializer(IndirectLocalPath &Path,\n                                             Expr *Init, LocalVisitor Visit,\n                                             bool RevisitSubinits,\n                                             bool EnableLifetimeWarnings);\n\nstatic void visitLocalsRetainedByReferenceBinding(IndirectLocalPath &Path,\n                                                  Expr *Init, ReferenceKind RK,\n                                                  LocalVisitor Visit,\n                                                  bool EnableLifetimeWarnings);\n\ntemplate <typename T> static bool isRecordWithAttr(QualType Type) {\n  if (auto *RD = Type->getAsCXXRecordDecl())\n    return RD->hasAttr<T>();\n  return false;\n}\n\n// Decl::isInStdNamespace will return false for iterators in some STL\n// implementations due to them being defined in a namespace outside of the std\n// namespace.\nstatic bool isInStlNamespace(const Decl *D) {\n  const DeclContext *DC = D->getDeclContext();\n  if (!DC)\n    return false;\n  if (const auto *ND = dyn_cast<NamespaceDecl>(DC))\n    if (const IdentifierInfo *II = ND->getIdentifier()) {\n      StringRef Name = II->getName();\n      if (Name.size() >= 2 && Name.front() == '_' &&\n          (Name[1] == '_' || isUppercase(Name[1])))\n        return true;\n    }\n\n  return DC->isStdNamespace();\n}\n\nstatic bool shouldTrackImplicitObjectArg(const CXXMethodDecl *Callee) {\n  if (auto *Conv = dyn_cast_or_null<CXXConversionDecl>(Callee))\n    if (isRecordWithAttr<PointerAttr>(Conv->getConversionType()))\n      return true;\n  if (!isInStlNamespace(Callee->getParent()))\n    return false;\n  if (!isRecordWithAttr<PointerAttr>(Callee->getThisObjectType()) &&\n      !isRecordWithAttr<OwnerAttr>(Callee->getThisObjectType()))\n    return false;\n  if (Callee->getReturnType()->isPointerType() ||\n      isRecordWithAttr<PointerAttr>(Callee->getReturnType())) {\n    if (!Callee->getIdentifier())\n      return false;\n    return llvm::StringSwitch<bool>(Callee->getName())\n        .Cases(\"begin\", \"rbegin\", \"cbegin\", \"crbegin\", true)\n        .Cases(\"end\", \"rend\", \"cend\", \"crend\", true)\n        .Cases(\"c_str\", \"data\", \"get\", true)\n        // Map and set types.\n        .Cases(\"find\", \"equal_range\", \"lower_bound\", \"upper_bound\", true)\n        .Default(false);\n  } else if (Callee->getReturnType()->isReferenceType()) {\n    if (!Callee->getIdentifier()) {\n      auto OO = Callee->getOverloadedOperator();\n      return OO == OverloadedOperatorKind::OO_Subscript ||\n             OO == OverloadedOperatorKind::OO_Star;\n    }\n    return llvm::StringSwitch<bool>(Callee->getName())\n        .Cases(\"front\", \"back\", \"at\", \"top\", \"value\", true)\n        .Default(false);\n  }\n  return false;\n}\n\nstatic bool shouldTrackFirstArgument(const FunctionDecl *FD) {\n  if (!FD->getIdentifier() || FD->getNumParams() != 1)\n    return false;\n  const auto *RD = FD->getParamDecl(0)->getType()->getPointeeCXXRecordDecl();\n  if (!FD->isInStdNamespace() || !RD || !RD->isInStdNamespace())\n    return false;\n  if (!isRecordWithAttr<PointerAttr>(QualType(RD->getTypeForDecl(), 0)) &&\n      !isRecordWithAttr<OwnerAttr>(QualType(RD->getTypeForDecl(), 0)))\n    return false;\n  if (FD->getReturnType()->isPointerType() ||\n      isRecordWithAttr<PointerAttr>(FD->getReturnType())) {\n    return llvm::StringSwitch<bool>(FD->getName())\n        .Cases(\"begin\", \"rbegin\", \"cbegin\", \"crbegin\", true)\n        .Cases(\"end\", \"rend\", \"cend\", \"crend\", true)\n        .Case(\"data\", true)\n        .Default(false);\n  } else if (FD->getReturnType()->isReferenceType()) {\n    return llvm::StringSwitch<bool>(FD->getName())\n        .Cases(\"get\", \"any_cast\", true)\n        .Default(false);\n  }\n  return false;\n}\n\nstatic void handleGslAnnotatedTypes(IndirectLocalPath &Path, Expr *Call,\n                                    LocalVisitor Visit) {\n  auto VisitPointerArg = [&](const Decl *D, Expr *Arg, bool Value) {\n    // We are not interested in the temporary base objects of gsl Pointers:\n    //   Temp().ptr; // Here ptr might not dangle.\n    if (isa<MemberExpr>(Arg->IgnoreImpCasts()))\n      return;\n    // Once we initialized a value with a reference, it can no longer dangle.\n    if (!Value) {\n      for (auto It = Path.rbegin(), End = Path.rend(); It != End; ++It) {\n        if (It->Kind == IndirectLocalPathEntry::GslReferenceInit)\n          continue;\n        if (It->Kind == IndirectLocalPathEntry::GslPointerInit)\n          return;\n        break;\n      }\n    }\n    Path.push_back({Value ? IndirectLocalPathEntry::GslPointerInit\n                          : IndirectLocalPathEntry::GslReferenceInit,\n                    Arg, D});\n    if (Arg->isGLValue())\n      visitLocalsRetainedByReferenceBinding(Path, Arg, RK_ReferenceBinding,\n                                            Visit,\n                                            /*EnableLifetimeWarnings=*/true);\n    else\n      visitLocalsRetainedByInitializer(Path, Arg, Visit, true,\n                                       /*EnableLifetimeWarnings=*/true);\n    Path.pop_back();\n  };\n\n  if (auto *MCE = dyn_cast<CXXMemberCallExpr>(Call)) {\n    const auto *MD = cast_or_null<CXXMethodDecl>(MCE->getDirectCallee());\n    if (MD && shouldTrackImplicitObjectArg(MD))\n      VisitPointerArg(MD, MCE->getImplicitObjectArgument(),\n                      !MD->getReturnType()->isReferenceType());\n    return;\n  } else if (auto *OCE = dyn_cast<CXXOperatorCallExpr>(Call)) {\n    FunctionDecl *Callee = OCE->getDirectCallee();\n    if (Callee && Callee->isCXXInstanceMember() &&\n        shouldTrackImplicitObjectArg(cast<CXXMethodDecl>(Callee)))\n      VisitPointerArg(Callee, OCE->getArg(0),\n                      !Callee->getReturnType()->isReferenceType());\n    return;\n  } else if (auto *CE = dyn_cast<CallExpr>(Call)) {\n    FunctionDecl *Callee = CE->getDirectCallee();\n    if (Callee && shouldTrackFirstArgument(Callee))\n      VisitPointerArg(Callee, CE->getArg(0),\n                      !Callee->getReturnType()->isReferenceType());\n    return;\n  }\n\n  if (auto *CCE = dyn_cast<CXXConstructExpr>(Call)) {\n    const auto *Ctor = CCE->getConstructor();\n    const CXXRecordDecl *RD = Ctor->getParent();\n    if (CCE->getNumArgs() > 0 && RD->hasAttr<PointerAttr>())\n      VisitPointerArg(Ctor->getParamDecl(0), CCE->getArgs()[0], true);\n  }\n}\n\nstatic bool implicitObjectParamIsLifetimeBound(const FunctionDecl *FD) {\n  const TypeSourceInfo *TSI = FD->getTypeSourceInfo();\n  if (!TSI)\n    return false;\n  // Don't declare this variable in the second operand of the for-statement;\n  // GCC miscompiles that by ending its lifetime before evaluating the\n  // third operand. See gcc.gnu.org/PR86769.\n  AttributedTypeLoc ATL;\n  for (TypeLoc TL = TSI->getTypeLoc();\n       (ATL = TL.getAsAdjusted<AttributedTypeLoc>());\n       TL = ATL.getModifiedLoc()) {\n    if (ATL.getAttrAs<LifetimeBoundAttr>())\n      return true;\n  }\n\n  // Assume that all assignment operators with a \"normal\" return type return\n  // *this, that is, an lvalue reference that is the same type as the implicit\n  // object parameter (or the LHS for a non-member operator$=).\n  OverloadedOperatorKind OO = FD->getDeclName().getCXXOverloadedOperator();\n  if (OO == OO_Equal || isCompoundAssignmentOperator(OO)) {\n    QualType RetT = FD->getReturnType();\n    if (RetT->isLValueReferenceType()) {\n      ASTContext &Ctx = FD->getASTContext();\n      QualType LHST;\n      auto *MD = dyn_cast<CXXMethodDecl>(FD);\n      if (MD && MD->isCXXInstanceMember())\n        LHST = Ctx.getLValueReferenceType(MD->getThisObjectType());\n      else\n        LHST = MD->getParamDecl(0)->getType();\n      if (Ctx.hasSameType(RetT, LHST))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nstatic void visitLifetimeBoundArguments(IndirectLocalPath &Path, Expr *Call,\n                                        LocalVisitor Visit) {\n  const FunctionDecl *Callee;\n  ArrayRef<Expr*> Args;\n\n  if (auto *CE = dyn_cast<CallExpr>(Call)) {\n    Callee = CE->getDirectCallee();\n    Args = llvm::makeArrayRef(CE->getArgs(), CE->getNumArgs());\n  } else {\n    auto *CCE = cast<CXXConstructExpr>(Call);\n    Callee = CCE->getConstructor();\n    Args = llvm::makeArrayRef(CCE->getArgs(), CCE->getNumArgs());\n  }\n  if (!Callee)\n    return;\n\n  Expr *ObjectArg = nullptr;\n  if (isa<CXXOperatorCallExpr>(Call) && Callee->isCXXInstanceMember()) {\n    ObjectArg = Args[0];\n    Args = Args.slice(1);\n  } else if (auto *MCE = dyn_cast<CXXMemberCallExpr>(Call)) {\n    ObjectArg = MCE->getImplicitObjectArgument();\n  }\n\n  auto VisitLifetimeBoundArg = [&](const Decl *D, Expr *Arg) {\n    Path.push_back({IndirectLocalPathEntry::LifetimeBoundCall, Arg, D});\n    if (Arg->isGLValue())\n      visitLocalsRetainedByReferenceBinding(Path, Arg, RK_ReferenceBinding,\n                                            Visit,\n                                            /*EnableLifetimeWarnings=*/false);\n    else\n      visitLocalsRetainedByInitializer(Path, Arg, Visit, true,\n                                       /*EnableLifetimeWarnings=*/false);\n    Path.pop_back();\n  };\n\n  if (ObjectArg && implicitObjectParamIsLifetimeBound(Callee))\n    VisitLifetimeBoundArg(Callee, ObjectArg);\n\n  for (unsigned I = 0,\n                N = std::min<unsigned>(Callee->getNumParams(), Args.size());\n       I != N; ++I) {\n    if (Callee->getParamDecl(I)->hasAttr<LifetimeBoundAttr>())\n      VisitLifetimeBoundArg(Callee->getParamDecl(I), Args[I]);\n  }\n}\n\n/// Visit the locals that would be reachable through a reference bound to the\n/// glvalue expression \\c Init.\nstatic void visitLocalsRetainedByReferenceBinding(IndirectLocalPath &Path,\n                                                  Expr *Init, ReferenceKind RK,\n                                                  LocalVisitor Visit,\n                                                  bool EnableLifetimeWarnings) {\n  RevertToOldSizeRAII RAII(Path);\n\n  // Walk past any constructs which we can lifetime-extend across.\n  Expr *Old;\n  do {\n    Old = Init;\n\n    if (auto *FE = dyn_cast<FullExpr>(Init))\n      Init = FE->getSubExpr();\n\n    if (InitListExpr *ILE = dyn_cast<InitListExpr>(Init)) {\n      // If this is just redundant braces around an initializer, step over it.\n      if (ILE->isTransparent())\n        Init = ILE->getInit(0);\n    }\n\n    // Step over any subobject adjustments; we may have a materialized\n    // temporary inside them.\n    Init = const_cast<Expr *>(Init->skipRValueSubobjectAdjustments());\n\n    // Per current approach for DR1376, look through casts to reference type\n    // when performing lifetime extension.\n    if (CastExpr *CE = dyn_cast<CastExpr>(Init))\n      if (CE->getSubExpr()->isGLValue())\n        Init = CE->getSubExpr();\n\n    // Per the current approach for DR1299, look through array element access\n    // on array glvalues when performing lifetime extension.\n    if (auto *ASE = dyn_cast<ArraySubscriptExpr>(Init)) {\n      Init = ASE->getBase();\n      auto *ICE = dyn_cast<ImplicitCastExpr>(Init);\n      if (ICE && ICE->getCastKind() == CK_ArrayToPointerDecay)\n        Init = ICE->getSubExpr();\n      else\n        // We can't lifetime extend through this but we might still find some\n        // retained temporaries.\n        return visitLocalsRetainedByInitializer(Path, Init, Visit, true,\n                                                EnableLifetimeWarnings);\n    }\n\n    // Step into CXXDefaultInitExprs so we can diagnose cases where a\n    // constructor inherits one as an implicit mem-initializer.\n    if (auto *DIE = dyn_cast<CXXDefaultInitExpr>(Init)) {\n      Path.push_back(\n          {IndirectLocalPathEntry::DefaultInit, DIE, DIE->getField()});\n      Init = DIE->getExpr();\n    }\n  } while (Init != Old);\n\n  if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(Init)) {\n    if (Visit(Path, Local(MTE), RK))\n      visitLocalsRetainedByInitializer(Path, MTE->getSubExpr(), Visit, true,\n                                       EnableLifetimeWarnings);\n  }\n\n  if (isa<CallExpr>(Init)) {\n    if (EnableLifetimeWarnings)\n      handleGslAnnotatedTypes(Path, Init, Visit);\n    return visitLifetimeBoundArguments(Path, Init, Visit);\n  }\n\n  switch (Init->getStmtClass()) {\n  case Stmt::DeclRefExprClass: {\n    // If we find the name of a local non-reference parameter, we could have a\n    // lifetime problem.\n    auto *DRE = cast<DeclRefExpr>(Init);\n    auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n    if (VD && VD->hasLocalStorage() &&\n        !DRE->refersToEnclosingVariableOrCapture()) {\n      if (!VD->getType()->isReferenceType()) {\n        Visit(Path, Local(DRE), RK);\n      } else if (isa<ParmVarDecl>(DRE->getDecl())) {\n        // The lifetime of a reference parameter is unknown; assume it's OK\n        // for now.\n        break;\n      } else if (VD->getInit() && !isVarOnPath(Path, VD)) {\n        Path.push_back({IndirectLocalPathEntry::VarInit, DRE, VD});\n        visitLocalsRetainedByReferenceBinding(Path, VD->getInit(),\n                                              RK_ReferenceBinding, Visit,\n                                              EnableLifetimeWarnings);\n      }\n    }\n    break;\n  }\n\n  case Stmt::UnaryOperatorClass: {\n    // The only unary operator that make sense to handle here\n    // is Deref.  All others don't resolve to a \"name.\"  This includes\n    // handling all sorts of rvalues passed to a unary operator.\n    const UnaryOperator *U = cast<UnaryOperator>(Init);\n    if (U->getOpcode() == UO_Deref)\n      visitLocalsRetainedByInitializer(Path, U->getSubExpr(), Visit, true,\n                                       EnableLifetimeWarnings);\n    break;\n  }\n\n  case Stmt::OMPArraySectionExprClass: {\n    visitLocalsRetainedByInitializer(Path,\n                                     cast<OMPArraySectionExpr>(Init)->getBase(),\n                                     Visit, true, EnableLifetimeWarnings);\n    break;\n  }\n\n  case Stmt::ConditionalOperatorClass:\n  case Stmt::BinaryConditionalOperatorClass: {\n    auto *C = cast<AbstractConditionalOperator>(Init);\n    if (!C->getTrueExpr()->getType()->isVoidType())\n      visitLocalsRetainedByReferenceBinding(Path, C->getTrueExpr(), RK, Visit,\n                                            EnableLifetimeWarnings);\n    if (!C->getFalseExpr()->getType()->isVoidType())\n      visitLocalsRetainedByReferenceBinding(Path, C->getFalseExpr(), RK, Visit,\n                                            EnableLifetimeWarnings);\n    break;\n  }\n\n  // FIXME: Visit the left-hand side of an -> or ->*.\n\n  default:\n    break;\n  }\n}\n\n/// Visit the locals that would be reachable through an object initialized by\n/// the prvalue expression \\c Init.\nstatic void visitLocalsRetainedByInitializer(IndirectLocalPath &Path,\n                                             Expr *Init, LocalVisitor Visit,\n                                             bool RevisitSubinits,\n                                             bool EnableLifetimeWarnings) {\n  RevertToOldSizeRAII RAII(Path);\n\n  Expr *Old;\n  do {\n    Old = Init;\n\n    // Step into CXXDefaultInitExprs so we can diagnose cases where a\n    // constructor inherits one as an implicit mem-initializer.\n    if (auto *DIE = dyn_cast<CXXDefaultInitExpr>(Init)) {\n      Path.push_back({IndirectLocalPathEntry::DefaultInit, DIE, DIE->getField()});\n      Init = DIE->getExpr();\n    }\n\n    if (auto *FE = dyn_cast<FullExpr>(Init))\n      Init = FE->getSubExpr();\n\n    // Dig out the expression which constructs the extended temporary.\n    Init = const_cast<Expr *>(Init->skipRValueSubobjectAdjustments());\n\n    if (CXXBindTemporaryExpr *BTE = dyn_cast<CXXBindTemporaryExpr>(Init))\n      Init = BTE->getSubExpr();\n\n    Init = Init->IgnoreParens();\n\n    // Step over value-preserving rvalue casts.\n    if (auto *CE = dyn_cast<CastExpr>(Init)) {\n      switch (CE->getCastKind()) {\n      case CK_LValueToRValue:\n        // If we can match the lvalue to a const object, we can look at its\n        // initializer.\n        Path.push_back({IndirectLocalPathEntry::LValToRVal, CE});\n        return visitLocalsRetainedByReferenceBinding(\n            Path, Init, RK_ReferenceBinding,\n            [&](IndirectLocalPath &Path, Local L, ReferenceKind RK) -> bool {\n          if (auto *DRE = dyn_cast<DeclRefExpr>(L)) {\n            auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n            if (VD && VD->getType().isConstQualified() && VD->getInit() &&\n                !isVarOnPath(Path, VD)) {\n              Path.push_back({IndirectLocalPathEntry::VarInit, DRE, VD});\n              visitLocalsRetainedByInitializer(Path, VD->getInit(), Visit, true,\n                                               EnableLifetimeWarnings);\n            }\n          } else if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(L)) {\n            if (MTE->getType().isConstQualified())\n              visitLocalsRetainedByInitializer(Path, MTE->getSubExpr(), Visit,\n                                               true, EnableLifetimeWarnings);\n          }\n          return false;\n        }, EnableLifetimeWarnings);\n\n        // We assume that objects can be retained by pointers cast to integers,\n        // but not if the integer is cast to floating-point type or to _Complex.\n        // We assume that casts to 'bool' do not preserve enough information to\n        // retain a local object.\n      case CK_NoOp:\n      case CK_BitCast:\n      case CK_BaseToDerived:\n      case CK_DerivedToBase:\n      case CK_UncheckedDerivedToBase:\n      case CK_Dynamic:\n      case CK_ToUnion:\n      case CK_UserDefinedConversion:\n      case CK_ConstructorConversion:\n      case CK_IntegralToPointer:\n      case CK_PointerToIntegral:\n      case CK_VectorSplat:\n      case CK_IntegralCast:\n      case CK_CPointerToObjCPointerCast:\n      case CK_BlockPointerToObjCPointerCast:\n      case CK_AnyPointerToBlockPointerCast:\n      case CK_AddressSpaceConversion:\n        break;\n\n      case CK_ArrayToPointerDecay:\n        // Model array-to-pointer decay as taking the address of the array\n        // lvalue.\n        Path.push_back({IndirectLocalPathEntry::AddressOf, CE});\n        return visitLocalsRetainedByReferenceBinding(Path, CE->getSubExpr(),\n                                                     RK_ReferenceBinding, Visit,\n                                                     EnableLifetimeWarnings);\n\n      default:\n        return;\n      }\n\n      Init = CE->getSubExpr();\n    }\n  } while (Old != Init);\n\n  // C++17 [dcl.init.list]p6:\n  //   initializing an initializer_list object from the array extends the\n  //   lifetime of the array exactly like binding a reference to a temporary.\n  if (auto *ILE = dyn_cast<CXXStdInitializerListExpr>(Init))\n    return visitLocalsRetainedByReferenceBinding(Path, ILE->getSubExpr(),\n                                                 RK_StdInitializerList, Visit,\n                                                 EnableLifetimeWarnings);\n\n  if (InitListExpr *ILE = dyn_cast<InitListExpr>(Init)) {\n    // We already visited the elements of this initializer list while\n    // performing the initialization. Don't visit them again unless we've\n    // changed the lifetime of the initialized entity.\n    if (!RevisitSubinits)\n      return;\n\n    if (ILE->isTransparent())\n      return visitLocalsRetainedByInitializer(Path, ILE->getInit(0), Visit,\n                                              RevisitSubinits,\n                                              EnableLifetimeWarnings);\n\n    if (ILE->getType()->isArrayType()) {\n      for (unsigned I = 0, N = ILE->getNumInits(); I != N; ++I)\n        visitLocalsRetainedByInitializer(Path, ILE->getInit(I), Visit,\n                                         RevisitSubinits,\n                                         EnableLifetimeWarnings);\n      return;\n    }\n\n    if (CXXRecordDecl *RD = ILE->getType()->getAsCXXRecordDecl()) {\n      assert(RD->isAggregate() && \"aggregate init on non-aggregate\");\n\n      // If we lifetime-extend a braced initializer which is initializing an\n      // aggregate, and that aggregate contains reference members which are\n      // bound to temporaries, those temporaries are also lifetime-extended.\n      if (RD->isUnion() && ILE->getInitializedFieldInUnion() &&\n          ILE->getInitializedFieldInUnion()->getType()->isReferenceType())\n        visitLocalsRetainedByReferenceBinding(Path, ILE->getInit(0),\n                                              RK_ReferenceBinding, Visit,\n                                              EnableLifetimeWarnings);\n      else {\n        unsigned Index = 0;\n        for (; Index < RD->getNumBases() && Index < ILE->getNumInits(); ++Index)\n          visitLocalsRetainedByInitializer(Path, ILE->getInit(Index), Visit,\n                                           RevisitSubinits,\n                                           EnableLifetimeWarnings);\n        for (const auto *I : RD->fields()) {\n          if (Index >= ILE->getNumInits())\n            break;\n          if (I->isUnnamedBitfield())\n            continue;\n          Expr *SubInit = ILE->getInit(Index);\n          if (I->getType()->isReferenceType())\n            visitLocalsRetainedByReferenceBinding(Path, SubInit,\n                                                  RK_ReferenceBinding, Visit,\n                                                  EnableLifetimeWarnings);\n          else\n            // This might be either aggregate-initialization of a member or\n            // initialization of a std::initializer_list object. Regardless,\n            // we should recursively lifetime-extend that initializer.\n            visitLocalsRetainedByInitializer(Path, SubInit, Visit,\n                                             RevisitSubinits,\n                                             EnableLifetimeWarnings);\n          ++Index;\n        }\n      }\n    }\n    return;\n  }\n\n  // The lifetime of an init-capture is that of the closure object constructed\n  // by a lambda-expression.\n  if (auto *LE = dyn_cast<LambdaExpr>(Init)) {\n    LambdaExpr::capture_iterator CapI = LE->capture_begin();\n    for (Expr *E : LE->capture_inits()) {\n      assert(CapI != LE->capture_end());\n      const LambdaCapture &Cap = *CapI++;\n      if (!E)\n        continue;\n      if (Cap.capturesVariable())\n        Path.push_back({IndirectLocalPathEntry::LambdaCaptureInit, E, &Cap});\n      if (E->isGLValue())\n        visitLocalsRetainedByReferenceBinding(Path, E, RK_ReferenceBinding,\n                                              Visit, EnableLifetimeWarnings);\n      else\n        visitLocalsRetainedByInitializer(Path, E, Visit, true,\n                                         EnableLifetimeWarnings);\n      if (Cap.capturesVariable())\n        Path.pop_back();\n    }\n  }\n\n  // Assume that a copy or move from a temporary references the same objects\n  // that the temporary does.\n  if (auto *CCE = dyn_cast<CXXConstructExpr>(Init)) {\n    if (CCE->getConstructor()->isCopyOrMoveConstructor()) {\n      if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(CCE->getArg(0))) {\n        Expr *Arg = MTE->getSubExpr();\n        Path.push_back({IndirectLocalPathEntry::TemporaryCopy, Arg,\n                        CCE->getConstructor()});\n        visitLocalsRetainedByInitializer(Path, Arg, Visit, true,\n                                         /*EnableLifetimeWarnings*/false);\n        Path.pop_back();\n      }\n    }\n  }\n\n  if (isa<CallExpr>(Init) || isa<CXXConstructExpr>(Init)) {\n    if (EnableLifetimeWarnings)\n      handleGslAnnotatedTypes(Path, Init, Visit);\n    return visitLifetimeBoundArguments(Path, Init, Visit);\n  }\n\n  switch (Init->getStmtClass()) {\n  case Stmt::UnaryOperatorClass: {\n    auto *UO = cast<UnaryOperator>(Init);\n    // If the initializer is the address of a local, we could have a lifetime\n    // problem.\n    if (UO->getOpcode() == UO_AddrOf) {\n      // If this is &rvalue, then it's ill-formed and we have already diagnosed\n      // it. Don't produce a redundant warning about the lifetime of the\n      // temporary.\n      if (isa<MaterializeTemporaryExpr>(UO->getSubExpr()))\n        return;\n\n      Path.push_back({IndirectLocalPathEntry::AddressOf, UO});\n      visitLocalsRetainedByReferenceBinding(Path, UO->getSubExpr(),\n                                            RK_ReferenceBinding, Visit,\n                                            EnableLifetimeWarnings);\n    }\n    break;\n  }\n\n  case Stmt::BinaryOperatorClass: {\n    // Handle pointer arithmetic.\n    auto *BO = cast<BinaryOperator>(Init);\n    BinaryOperatorKind BOK = BO->getOpcode();\n    if (!BO->getType()->isPointerType() || (BOK != BO_Add && BOK != BO_Sub))\n      break;\n\n    if (BO->getLHS()->getType()->isPointerType())\n      visitLocalsRetainedByInitializer(Path, BO->getLHS(), Visit, true,\n                                       EnableLifetimeWarnings);\n    else if (BO->getRHS()->getType()->isPointerType())\n      visitLocalsRetainedByInitializer(Path, BO->getRHS(), Visit, true,\n                                       EnableLifetimeWarnings);\n    break;\n  }\n\n  case Stmt::ConditionalOperatorClass:\n  case Stmt::BinaryConditionalOperatorClass: {\n    auto *C = cast<AbstractConditionalOperator>(Init);\n    // In C++, we can have a throw-expression operand, which has 'void' type\n    // and isn't interesting from a lifetime perspective.\n    if (!C->getTrueExpr()->getType()->isVoidType())\n      visitLocalsRetainedByInitializer(Path, C->getTrueExpr(), Visit, true,\n                                       EnableLifetimeWarnings);\n    if (!C->getFalseExpr()->getType()->isVoidType())\n      visitLocalsRetainedByInitializer(Path, C->getFalseExpr(), Visit, true,\n                                       EnableLifetimeWarnings);\n    break;\n  }\n\n  case Stmt::BlockExprClass:\n    if (cast<BlockExpr>(Init)->getBlockDecl()->hasCaptures()) {\n      // This is a local block, whose lifetime is that of the function.\n      Visit(Path, Local(cast<BlockExpr>(Init)), RK_ReferenceBinding);\n    }\n    break;\n\n  case Stmt::AddrLabelExprClass:\n    // We want to warn if the address of a label would escape the function.\n    Visit(Path, Local(cast<AddrLabelExpr>(Init)), RK_ReferenceBinding);\n    break;\n\n  default:\n    break;\n  }\n}\n\n/// Whether a path to an object supports lifetime extension.\nenum PathLifetimeKind {\n  /// Lifetime-extend along this path.\n  Extend,\n  /// We should lifetime-extend, but we don't because (due to technical\n  /// limitations) we can't. This happens for default member initializers,\n  /// which we don't clone for every use, so we don't have a unique\n  /// MaterializeTemporaryExpr to update.\n  ShouldExtend,\n  /// Do not lifetime extend along this path.\n  NoExtend\n};\n\n/// Determine whether this is an indirect path to a temporary that we are\n/// supposed to lifetime-extend along.\nstatic PathLifetimeKind\nshouldLifetimeExtendThroughPath(const IndirectLocalPath &Path) {\n  PathLifetimeKind Kind = PathLifetimeKind::Extend;\n  for (auto Elem : Path) {\n    if (Elem.Kind == IndirectLocalPathEntry::DefaultInit)\n      Kind = PathLifetimeKind::ShouldExtend;\n    else if (Elem.Kind != IndirectLocalPathEntry::LambdaCaptureInit)\n      return PathLifetimeKind::NoExtend;\n  }\n  return Kind;\n}\n\n/// Find the range for the first interesting entry in the path at or after I.\nstatic SourceRange nextPathEntryRange(const IndirectLocalPath &Path, unsigned I,\n                                      Expr *E) {\n  for (unsigned N = Path.size(); I != N; ++I) {\n    switch (Path[I].Kind) {\n    case IndirectLocalPathEntry::AddressOf:\n    case IndirectLocalPathEntry::LValToRVal:\n    case IndirectLocalPathEntry::LifetimeBoundCall:\n    case IndirectLocalPathEntry::TemporaryCopy:\n    case IndirectLocalPathEntry::GslReferenceInit:\n    case IndirectLocalPathEntry::GslPointerInit:\n      // These exist primarily to mark the path as not permitting or\n      // supporting lifetime extension.\n      break;\n\n    case IndirectLocalPathEntry::VarInit:\n      if (cast<VarDecl>(Path[I].D)->isImplicit())\n        return SourceRange();\n      LLVM_FALLTHROUGH;\n    case IndirectLocalPathEntry::DefaultInit:\n      return Path[I].E->getSourceRange();\n\n    case IndirectLocalPathEntry::LambdaCaptureInit:\n      if (!Path[I].Capture->capturesVariable())\n        continue;\n      return Path[I].E->getSourceRange();\n    }\n  }\n  return E->getSourceRange();\n}\n\nstatic bool pathOnlyInitializesGslPointer(IndirectLocalPath &Path) {\n  for (auto It = Path.rbegin(), End = Path.rend(); It != End; ++It) {\n    if (It->Kind == IndirectLocalPathEntry::VarInit)\n      continue;\n    if (It->Kind == IndirectLocalPathEntry::AddressOf)\n      continue;\n    if (It->Kind == IndirectLocalPathEntry::LifetimeBoundCall)\n      continue;\n    return It->Kind == IndirectLocalPathEntry::GslPointerInit ||\n           It->Kind == IndirectLocalPathEntry::GslReferenceInit;\n  }\n  return false;\n}\n\nvoid Sema::checkInitializerLifetime(const InitializedEntity &Entity,\n                                    Expr *Init) {\n  LifetimeResult LR = getEntityLifetime(&Entity);\n  LifetimeKind LK = LR.getInt();\n  const InitializedEntity *ExtendingEntity = LR.getPointer();\n\n  // If this entity doesn't have an interesting lifetime, don't bother looking\n  // for temporaries within its initializer.\n  if (LK == LK_FullExpression)\n    return;\n\n  auto TemporaryVisitor = [&](IndirectLocalPath &Path, Local L,\n                              ReferenceKind RK) -> bool {\n    SourceRange DiagRange = nextPathEntryRange(Path, 0, L);\n    SourceLocation DiagLoc = DiagRange.getBegin();\n\n    auto *MTE = dyn_cast<MaterializeTemporaryExpr>(L);\n\n    bool IsGslPtrInitWithGslTempOwner = false;\n    bool IsLocalGslOwner = false;\n    if (pathOnlyInitializesGslPointer(Path)) {\n      if (isa<DeclRefExpr>(L)) {\n        // We do not want to follow the references when returning a pointer originating\n        // from a local owner to avoid the following false positive:\n        //   int &p = *localUniquePtr;\n        //   someContainer.add(std::move(localUniquePtr));\n        //   return p;\n        IsLocalGslOwner = isRecordWithAttr<OwnerAttr>(L->getType());\n        if (pathContainsInit(Path) || !IsLocalGslOwner)\n          return false;\n      } else {\n        IsGslPtrInitWithGslTempOwner = MTE && !MTE->getExtendingDecl() &&\n                            isRecordWithAttr<OwnerAttr>(MTE->getType());\n        // Skipping a chain of initializing gsl::Pointer annotated objects.\n        // We are looking only for the final source to find out if it was\n        // a local or temporary owner or the address of a local variable/param.\n        if (!IsGslPtrInitWithGslTempOwner)\n          return true;\n      }\n    }\n\n    switch (LK) {\n    case LK_FullExpression:\n      llvm_unreachable(\"already handled this\");\n\n    case LK_Extended: {\n      if (!MTE) {\n        // The initialized entity has lifetime beyond the full-expression,\n        // and the local entity does too, so don't warn.\n        //\n        // FIXME: We should consider warning if a static / thread storage\n        // duration variable retains an automatic storage duration local.\n        return false;\n      }\n\n      if (IsGslPtrInitWithGslTempOwner && DiagLoc.isValid()) {\n        Diag(DiagLoc, diag::warn_dangling_lifetime_pointer) << DiagRange;\n        return false;\n      }\n\n      switch (shouldLifetimeExtendThroughPath(Path)) {\n      case PathLifetimeKind::Extend:\n        // Update the storage duration of the materialized temporary.\n        // FIXME: Rebuild the expression instead of mutating it.\n        MTE->setExtendingDecl(ExtendingEntity->getDecl(),\n                              ExtendingEntity->allocateManglingNumber());\n        // Also visit the temporaries lifetime-extended by this initializer.\n        return true;\n\n      case PathLifetimeKind::ShouldExtend:\n        // We're supposed to lifetime-extend the temporary along this path (per\n        // the resolution of DR1815), but we don't support that yet.\n        //\n        // FIXME: Properly handle this situation. Perhaps the easiest approach\n        // would be to clone the initializer expression on each use that would\n        // lifetime extend its temporaries.\n        Diag(DiagLoc, diag::warn_unsupported_lifetime_extension)\n            << RK << DiagRange;\n        break;\n\n      case PathLifetimeKind::NoExtend:\n        // If the path goes through the initialization of a variable or field,\n        // it can't possibly reach a temporary created in this full-expression.\n        // We will have already diagnosed any problems with the initializer.\n        if (pathContainsInit(Path))\n          return false;\n\n        Diag(DiagLoc, diag::warn_dangling_variable)\n            << RK << !Entity.getParent()\n            << ExtendingEntity->getDecl()->isImplicit()\n            << ExtendingEntity->getDecl() << Init->isGLValue() << DiagRange;\n        break;\n      }\n      break;\n    }\n\n    case LK_MemInitializer: {\n      if (isa<MaterializeTemporaryExpr>(L)) {\n        // Under C++ DR1696, if a mem-initializer (or a default member\n        // initializer used by the absence of one) would lifetime-extend a\n        // temporary, the program is ill-formed.\n        if (auto *ExtendingDecl =\n                ExtendingEntity ? ExtendingEntity->getDecl() : nullptr) {\n          if (IsGslPtrInitWithGslTempOwner) {\n            Diag(DiagLoc, diag::warn_dangling_lifetime_pointer_member)\n                << ExtendingDecl << DiagRange;\n            Diag(ExtendingDecl->getLocation(),\n                 diag::note_ref_or_ptr_member_declared_here)\n                << true;\n            return false;\n          }\n          bool IsSubobjectMember = ExtendingEntity != &Entity;\n          Diag(DiagLoc, shouldLifetimeExtendThroughPath(Path) !=\n                                PathLifetimeKind::NoExtend\n                            ? diag::err_dangling_member\n                            : diag::warn_dangling_member)\n              << ExtendingDecl << IsSubobjectMember << RK << DiagRange;\n          // Don't bother adding a note pointing to the field if we're inside\n          // its default member initializer; our primary diagnostic points to\n          // the same place in that case.\n          if (Path.empty() ||\n              Path.back().Kind != IndirectLocalPathEntry::DefaultInit) {\n            Diag(ExtendingDecl->getLocation(),\n                 diag::note_lifetime_extending_member_declared_here)\n                << RK << IsSubobjectMember;\n          }\n        } else {\n          // We have a mem-initializer but no particular field within it; this\n          // is either a base class or a delegating initializer directly\n          // initializing the base-class from something that doesn't live long\n          // enough.\n          //\n          // FIXME: Warn on this.\n          return false;\n        }\n      } else {\n        // Paths via a default initializer can only occur during error recovery\n        // (there's no other way that a default initializer can refer to a\n        // local). Don't produce a bogus warning on those cases.\n        if (pathContainsInit(Path))\n          return false;\n\n        // Suppress false positives for code like the one below:\n        //   Ctor(unique_ptr<T> up) : member(*up), member2(move(up)) {}\n        if (IsLocalGslOwner && pathOnlyInitializesGslPointer(Path))\n          return false;\n\n        auto *DRE = dyn_cast<DeclRefExpr>(L);\n        auto *VD = DRE ? dyn_cast<VarDecl>(DRE->getDecl()) : nullptr;\n        if (!VD) {\n          // A member was initialized to a local block.\n          // FIXME: Warn on this.\n          return false;\n        }\n\n        if (auto *Member =\n                ExtendingEntity ? ExtendingEntity->getDecl() : nullptr) {\n          bool IsPointer = !Member->getType()->isReferenceType();\n          Diag(DiagLoc, IsPointer ? diag::warn_init_ptr_member_to_parameter_addr\n                                  : diag::warn_bind_ref_member_to_parameter)\n              << Member << VD << isa<ParmVarDecl>(VD) << DiagRange;\n          Diag(Member->getLocation(),\n               diag::note_ref_or_ptr_member_declared_here)\n              << (unsigned)IsPointer;\n        }\n      }\n      break;\n    }\n\n    case LK_New:\n      if (isa<MaterializeTemporaryExpr>(L)) {\n        if (IsGslPtrInitWithGslTempOwner)\n          Diag(DiagLoc, diag::warn_dangling_lifetime_pointer) << DiagRange;\n        else\n          Diag(DiagLoc, RK == RK_ReferenceBinding\n                            ? diag::warn_new_dangling_reference\n                            : diag::warn_new_dangling_initializer_list)\n              << !Entity.getParent() << DiagRange;\n      } else {\n        // We can't determine if the allocation outlives the local declaration.\n        return false;\n      }\n      break;\n\n    case LK_Return:\n    case LK_StmtExprResult:\n      if (auto *DRE = dyn_cast<DeclRefExpr>(L)) {\n        // We can't determine if the local variable outlives the statement\n        // expression.\n        if (LK == LK_StmtExprResult)\n          return false;\n        Diag(DiagLoc, diag::warn_ret_stack_addr_ref)\n            << Entity.getType()->isReferenceType() << DRE->getDecl()\n            << isa<ParmVarDecl>(DRE->getDecl()) << DiagRange;\n      } else if (isa<BlockExpr>(L)) {\n        Diag(DiagLoc, diag::err_ret_local_block) << DiagRange;\n      } else if (isa<AddrLabelExpr>(L)) {\n        // Don't warn when returning a label from a statement expression.\n        // Leaving the scope doesn't end its lifetime.\n        if (LK == LK_StmtExprResult)\n          return false;\n        Diag(DiagLoc, diag::warn_ret_addr_label) << DiagRange;\n      } else {\n        Diag(DiagLoc, diag::warn_ret_local_temp_addr_ref)\n         << Entity.getType()->isReferenceType() << DiagRange;\n      }\n      break;\n    }\n\n    for (unsigned I = 0; I != Path.size(); ++I) {\n      auto Elem = Path[I];\n\n      switch (Elem.Kind) {\n      case IndirectLocalPathEntry::AddressOf:\n      case IndirectLocalPathEntry::LValToRVal:\n        // These exist primarily to mark the path as not permitting or\n        // supporting lifetime extension.\n        break;\n\n      case IndirectLocalPathEntry::LifetimeBoundCall:\n      case IndirectLocalPathEntry::TemporaryCopy:\n      case IndirectLocalPathEntry::GslPointerInit:\n      case IndirectLocalPathEntry::GslReferenceInit:\n        // FIXME: Consider adding a note for these.\n        break;\n\n      case IndirectLocalPathEntry::DefaultInit: {\n        auto *FD = cast<FieldDecl>(Elem.D);\n        Diag(FD->getLocation(), diag::note_init_with_default_member_initalizer)\n            << FD << nextPathEntryRange(Path, I + 1, L);\n        break;\n      }\n\n      case IndirectLocalPathEntry::VarInit: {\n        const VarDecl *VD = cast<VarDecl>(Elem.D);\n        Diag(VD->getLocation(), diag::note_local_var_initializer)\n            << VD->getType()->isReferenceType()\n            << VD->isImplicit() << VD->getDeclName()\n            << nextPathEntryRange(Path, I + 1, L);\n        break;\n      }\n\n      case IndirectLocalPathEntry::LambdaCaptureInit:\n        if (!Elem.Capture->capturesVariable())\n          break;\n        // FIXME: We can't easily tell apart an init-capture from a nested\n        // capture of an init-capture.\n        const VarDecl *VD = Elem.Capture->getCapturedVar();\n        Diag(Elem.Capture->getLocation(), diag::note_lambda_capture_initializer)\n            << VD << VD->isInitCapture() << Elem.Capture->isExplicit()\n            << (Elem.Capture->getCaptureKind() == LCK_ByRef) << VD\n            << nextPathEntryRange(Path, I + 1, L);\n        break;\n      }\n    }\n\n    // We didn't lifetime-extend, so don't go any further; we don't need more\n    // warnings or errors on inner temporaries within this one's initializer.\n    return false;\n  };\n\n  bool EnableLifetimeWarnings = !getDiagnostics().isIgnored(\n      diag::warn_dangling_lifetime_pointer, SourceLocation());\n  llvm::SmallVector<IndirectLocalPathEntry, 8> Path;\n  if (Init->isGLValue())\n    visitLocalsRetainedByReferenceBinding(Path, Init, RK_ReferenceBinding,\n                                          TemporaryVisitor,\n                                          EnableLifetimeWarnings);\n  else\n    visitLocalsRetainedByInitializer(Path, Init, TemporaryVisitor, false,\n                                     EnableLifetimeWarnings);\n}\n\nstatic void DiagnoseNarrowingInInitList(Sema &S,\n                                        const ImplicitConversionSequence &ICS,\n                                        QualType PreNarrowingType,\n                                        QualType EntityType,\n                                        const Expr *PostInit);\n\n/// Provide warnings when std::move is used on construction.\nstatic void CheckMoveOnConstruction(Sema &S, const Expr *InitExpr,\n                                    bool IsReturnStmt) {\n  if (!InitExpr)\n    return;\n\n  if (S.inTemplateInstantiation())\n    return;\n\n  QualType DestType = InitExpr->getType();\n  if (!DestType->isRecordType())\n    return;\n\n  unsigned DiagID = 0;\n  if (IsReturnStmt) {\n    const CXXConstructExpr *CCE =\n        dyn_cast<CXXConstructExpr>(InitExpr->IgnoreParens());\n    if (!CCE || CCE->getNumArgs() != 1)\n      return;\n\n    if (!CCE->getConstructor()->isCopyOrMoveConstructor())\n      return;\n\n    InitExpr = CCE->getArg(0)->IgnoreImpCasts();\n  }\n\n  // Find the std::move call and get the argument.\n  const CallExpr *CE = dyn_cast<CallExpr>(InitExpr->IgnoreParens());\n  if (!CE || !CE->isCallToStdMove())\n    return;\n\n  const Expr *Arg = CE->getArg(0)->IgnoreImplicit();\n\n  if (IsReturnStmt) {\n    const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Arg->IgnoreParenImpCasts());\n    if (!DRE || DRE->refersToEnclosingVariableOrCapture())\n      return;\n\n    const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());\n    if (!VD || !VD->hasLocalStorage())\n      return;\n\n    // __block variables are not moved implicitly.\n    if (VD->hasAttr<BlocksAttr>())\n      return;\n\n    QualType SourceType = VD->getType();\n    if (!SourceType->isRecordType())\n      return;\n\n    if (!S.Context.hasSameUnqualifiedType(DestType, SourceType)) {\n      return;\n    }\n\n    // If we're returning a function parameter, copy elision\n    // is not possible.\n    if (isa<ParmVarDecl>(VD))\n      DiagID = diag::warn_redundant_move_on_return;\n    else\n      DiagID = diag::warn_pessimizing_move_on_return;\n  } else {\n    DiagID = diag::warn_pessimizing_move_on_initialization;\n    const Expr *ArgStripped = Arg->IgnoreImplicit()->IgnoreParens();\n    if (!ArgStripped->isRValue() || !ArgStripped->getType()->isRecordType())\n      return;\n  }\n\n  S.Diag(CE->getBeginLoc(), DiagID);\n\n  // Get all the locations for a fix-it.  Don't emit the fix-it if any location\n  // is within a macro.\n  SourceLocation CallBegin = CE->getCallee()->getBeginLoc();\n  if (CallBegin.isMacroID())\n    return;\n  SourceLocation RParen = CE->getRParenLoc();\n  if (RParen.isMacroID())\n    return;\n  SourceLocation LParen;\n  SourceLocation ArgLoc = Arg->getBeginLoc();\n\n  // Special testing for the argument location.  Since the fix-it needs the\n  // location right before the argument, the argument location can be in a\n  // macro only if it is at the beginning of the macro.\n  while (ArgLoc.isMacroID() &&\n         S.getSourceManager().isAtStartOfImmediateMacroExpansion(ArgLoc)) {\n    ArgLoc = S.getSourceManager().getImmediateExpansionRange(ArgLoc).getBegin();\n  }\n\n  if (LParen.isMacroID())\n    return;\n\n  LParen = ArgLoc.getLocWithOffset(-1);\n\n  S.Diag(CE->getBeginLoc(), diag::note_remove_move)\n      << FixItHint::CreateRemoval(SourceRange(CallBegin, LParen))\n      << FixItHint::CreateRemoval(SourceRange(RParen, RParen));\n}\n\nstatic void CheckForNullPointerDereference(Sema &S, const Expr *E) {\n  // Check to see if we are dereferencing a null pointer.  If so, this is\n  // undefined behavior, so warn about it.  This only handles the pattern\n  // \"*null\", which is a very syntactic check.\n  if (const UnaryOperator *UO = dyn_cast<UnaryOperator>(E->IgnoreParenCasts()))\n    if (UO->getOpcode() == UO_Deref &&\n        UO->getSubExpr()->IgnoreParenCasts()->\n        isNullPointerConstant(S.Context, Expr::NPC_ValueDependentIsNotNull)) {\n    S.DiagRuntimeBehavior(UO->getOperatorLoc(), UO,\n                          S.PDiag(diag::warn_binding_null_to_reference)\n                            << UO->getSubExpr()->getSourceRange());\n  }\n}\n\nMaterializeTemporaryExpr *\nSema::CreateMaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                                     bool BoundToLvalueReference) {\n  auto MTE = new (Context)\n      MaterializeTemporaryExpr(T, Temporary, BoundToLvalueReference);\n\n  // Order an ExprWithCleanups for lifetime marks.\n  //\n  // TODO: It'll be good to have a single place to check the access of the\n  // destructor and generate ExprWithCleanups for various uses. Currently these\n  // are done in both CreateMaterializeTemporaryExpr and MaybeBindToTemporary,\n  // but there may be a chance to merge them.\n  Cleanup.setExprNeedsCleanups(false);\n  return MTE;\n}\n\nExprResult Sema::TemporaryMaterializationConversion(Expr *E) {\n  // In C++98, we don't want to implicitly create an xvalue.\n  // FIXME: This means that AST consumers need to deal with \"prvalues\" that\n  // denote materialized temporaries. Maybe we should add another ValueKind\n  // for \"xvalue pretending to be a prvalue\" for C++98 support.\n  if (!E->isRValue() || !getLangOpts().CPlusPlus11)\n    return E;\n\n  // C++1z [conv.rval]/1: T shall be a complete type.\n  // FIXME: Does this ever matter (can we form a prvalue of incomplete type)?\n  // If so, we should check for a non-abstract class type here too.\n  QualType T = E->getType();\n  if (RequireCompleteType(E->getExprLoc(), T, diag::err_incomplete_type))\n    return ExprError();\n\n  return CreateMaterializeTemporaryExpr(E->getType(), E, false);\n}\n\nExprResult Sema::PerformQualificationConversion(Expr *E, QualType Ty,\n                                                ExprValueKind VK,\n                                                CheckedConversionKind CCK) {\n\n  CastKind CK = CK_NoOp;\n\n  if (VK == VK_RValue) {\n    auto PointeeTy = Ty->getPointeeType();\n    auto ExprPointeeTy = E->getType()->getPointeeType();\n    if (!PointeeTy.isNull() &&\n        PointeeTy.getAddressSpace() != ExprPointeeTy.getAddressSpace())\n      CK = CK_AddressSpaceConversion;\n  } else if (Ty.getAddressSpace() != E->getType().getAddressSpace()) {\n    CK = CK_AddressSpaceConversion;\n  }\n\n  return ImpCastExprToType(E, Ty, CK, VK, /*BasePath=*/nullptr, CCK);\n}\n\nExprResult InitializationSequence::Perform(Sema &S,\n                                           const InitializedEntity &Entity,\n                                           const InitializationKind &Kind,\n                                           MultiExprArg Args,\n                                           QualType *ResultType) {\n  if (Failed()) {\n    Diagnose(S, Entity, Kind, Args);\n    return ExprError();\n  }\n  if (!ZeroInitializationFixit.empty()) {\n    unsigned DiagID = diag::err_default_init_const;\n    if (Decl *D = Entity.getDecl())\n      if (S.getLangOpts().MSVCCompat && D->hasAttr<SelectAnyAttr>())\n        DiagID = diag::ext_default_init_const;\n\n    // The initialization would have succeeded with this fixit. Since the fixit\n    // is on the error, we need to build a valid AST in this case, so this isn't\n    // handled in the Failed() branch above.\n    QualType DestType = Entity.getType();\n    S.Diag(Kind.getLocation(), DiagID)\n        << DestType << (bool)DestType->getAs<RecordType>()\n        << FixItHint::CreateInsertion(ZeroInitializationFixitLoc,\n                                      ZeroInitializationFixit);\n  }\n\n  if (getKind() == DependentSequence) {\n    // If the declaration is a non-dependent, incomplete array type\n    // that has an initializer, then its type will be completed once\n    // the initializer is instantiated.\n    if (ResultType && !Entity.getType()->isDependentType() &&\n        Args.size() == 1) {\n      QualType DeclType = Entity.getType();\n      if (const IncompleteArrayType *ArrayT\n                           = S.Context.getAsIncompleteArrayType(DeclType)) {\n        // FIXME: We don't currently have the ability to accurately\n        // compute the length of an initializer list without\n        // performing full type-checking of the initializer list\n        // (since we have to determine where braces are implicitly\n        // introduced and such).  So, we fall back to making the array\n        // type a dependently-sized array type with no specified\n        // bound.\n        if (isa<InitListExpr>((Expr *)Args[0])) {\n          SourceRange Brackets;\n\n          // Scavange the location of the brackets from the entity, if we can.\n          if (auto *DD = dyn_cast_or_null<DeclaratorDecl>(Entity.getDecl())) {\n            if (TypeSourceInfo *TInfo = DD->getTypeSourceInfo()) {\n              TypeLoc TL = TInfo->getTypeLoc();\n              if (IncompleteArrayTypeLoc ArrayLoc =\n                      TL.getAs<IncompleteArrayTypeLoc>())\n                Brackets = ArrayLoc.getBracketsRange();\n            }\n          }\n\n          *ResultType\n            = S.Context.getDependentSizedArrayType(ArrayT->getElementType(),\n                                                   /*NumElts=*/nullptr,\n                                                   ArrayT->getSizeModifier(),\n                                       ArrayT->getIndexTypeCVRQualifiers(),\n                                                   Brackets);\n        }\n\n      }\n    }\n    if (Kind.getKind() == InitializationKind::IK_Direct &&\n        !Kind.isExplicitCast()) {\n      // Rebuild the ParenListExpr.\n      SourceRange ParenRange = Kind.getParenOrBraceRange();\n      return S.ActOnParenListExpr(ParenRange.getBegin(), ParenRange.getEnd(),\n                                  Args);\n    }\n    assert(Kind.getKind() == InitializationKind::IK_Copy ||\n           Kind.isExplicitCast() ||\n           Kind.getKind() == InitializationKind::IK_DirectList);\n    return ExprResult(Args[0]);\n  }\n\n  // No steps means no initialization.\n  if (Steps.empty())\n    return ExprResult((Expr *)nullptr);\n\n  if (S.getLangOpts().CPlusPlus11 && Entity.getType()->isReferenceType() &&\n      Args.size() == 1 && isa<InitListExpr>(Args[0]) &&\n      !Entity.isParamOrTemplateParamKind()) {\n    // Produce a C++98 compatibility warning if we are initializing a reference\n    // from an initializer list. For parameters, we produce a better warning\n    // elsewhere.\n    Expr *Init = Args[0];\n    S.Diag(Init->getBeginLoc(), diag::warn_cxx98_compat_reference_list_init)\n        << Init->getSourceRange();\n  }\n\n  // OpenCL v2.0 s6.13.11.1. atomic variables can be initialized in global scope\n  QualType ETy = Entity.getType();\n  bool HasGlobalAS = ETy.hasAddressSpace() &&\n                     ETy.getAddressSpace() == LangAS::opencl_global;\n\n  if (S.getLangOpts().OpenCLVersion >= 200 &&\n      ETy->isAtomicType() && !HasGlobalAS &&\n      Entity.getKind() == InitializedEntity::EK_Variable && Args.size() > 0) {\n    S.Diag(Args[0]->getBeginLoc(), diag::err_opencl_atomic_init)\n        << 1\n        << SourceRange(Entity.getDecl()->getBeginLoc(), Args[0]->getEndLoc());\n    return ExprError();\n  }\n\n  QualType DestType = Entity.getType().getNonReferenceType();\n  // FIXME: Ugly hack around the fact that Entity.getType() is not\n  // the same as Entity.getDecl()->getType() in cases involving type merging,\n  //  and we want latter when it makes sense.\n  if (ResultType)\n    *ResultType = Entity.getDecl() ? Entity.getDecl()->getType() :\n                                     Entity.getType();\n\n  ExprResult CurInit((Expr *)nullptr);\n  SmallVector<Expr*, 4> ArrayLoopCommonExprs;\n\n  // For initialization steps that start with a single initializer,\n  // grab the only argument out the Args and place it into the \"current\"\n  // initializer.\n  switch (Steps.front().Kind) {\n  case SK_ResolveAddressOfOverloadedFunction:\n  case SK_CastDerivedToBaseRValue:\n  case SK_CastDerivedToBaseXValue:\n  case SK_CastDerivedToBaseLValue:\n  case SK_BindReference:\n  case SK_BindReferenceToTemporary:\n  case SK_FinalCopy:\n  case SK_ExtraneousCopyToTemporary:\n  case SK_UserConversion:\n  case SK_QualificationConversionLValue:\n  case SK_QualificationConversionXValue:\n  case SK_QualificationConversionRValue:\n  case SK_FunctionReferenceConversion:\n  case SK_AtomicConversion:\n  case SK_ConversionSequence:\n  case SK_ConversionSequenceNoNarrowing:\n  case SK_ListInitialization:\n  case SK_UnwrapInitList:\n  case SK_RewrapInitList:\n  case SK_CAssignment:\n  case SK_StringInit:\n  case SK_ObjCObjectConversion:\n  case SK_ArrayLoopIndex:\n  case SK_ArrayLoopInit:\n  case SK_ArrayInit:\n  case SK_GNUArrayInit:\n  case SK_ParenthesizedArrayInit:\n  case SK_PassByIndirectCopyRestore:\n  case SK_PassByIndirectRestore:\n  case SK_ProduceObjCObject:\n  case SK_StdInitializerList:\n  case SK_OCLSamplerInit:\n  case SK_OCLZeroOpaqueType: {\n    assert(Args.size() == 1);\n    CurInit = Args[0];\n    if (!CurInit.get()) return ExprError();\n    break;\n  }\n\n  case SK_ConstructorInitialization:\n  case SK_ConstructorInitializationFromList:\n  case SK_StdInitializerListConstructorCall:\n  case SK_ZeroInitialization:\n    break;\n  }\n\n  // Promote from an unevaluated context to an unevaluated list context in\n  // C++11 list-initialization; we need to instantiate entities usable in\n  // constant expressions here in order to perform narrowing checks =(\n  EnterExpressionEvaluationContext Evaluated(\n      S, EnterExpressionEvaluationContext::InitList,\n      CurInit.get() && isa<InitListExpr>(CurInit.get()));\n\n  // C++ [class.abstract]p2:\n  //   no objects of an abstract class can be created except as subobjects\n  //   of a class derived from it\n  auto checkAbstractType = [&](QualType T) -> bool {\n    if (Entity.getKind() == InitializedEntity::EK_Base ||\n        Entity.getKind() == InitializedEntity::EK_Delegating)\n      return false;\n    return S.RequireNonAbstractType(Kind.getLocation(), T,\n                                    diag::err_allocation_of_abstract_type);\n  };\n\n  // Walk through the computed steps for the initialization sequence,\n  // performing the specified conversions along the way.\n  bool ConstructorInitRequiresZeroInit = false;\n  for (step_iterator Step = step_begin(), StepEnd = step_end();\n       Step != StepEnd; ++Step) {\n    if (CurInit.isInvalid())\n      return ExprError();\n\n    QualType SourceType = CurInit.get() ? CurInit.get()->getType() : QualType();\n\n    switch (Step->Kind) {\n    case SK_ResolveAddressOfOverloadedFunction:\n      // Overload resolution determined which function invoke; update the\n      // initializer to reflect that choice.\n      S.CheckAddressOfMemberAccess(CurInit.get(), Step->Function.FoundDecl);\n      if (S.DiagnoseUseOfDecl(Step->Function.FoundDecl, Kind.getLocation()))\n        return ExprError();\n      CurInit = S.FixOverloadedFunctionReference(CurInit,\n                                                 Step->Function.FoundDecl,\n                                                 Step->Function.Function);\n      break;\n\n    case SK_CastDerivedToBaseRValue:\n    case SK_CastDerivedToBaseXValue:\n    case SK_CastDerivedToBaseLValue: {\n      // We have a derived-to-base cast that produces either an rvalue or an\n      // lvalue. Perform that cast.\n\n      CXXCastPath BasePath;\n\n      // Casts to inaccessible base classes are allowed with C-style casts.\n      bool IgnoreBaseAccess = Kind.isCStyleOrFunctionalCast();\n      if (S.CheckDerivedToBaseConversion(\n              SourceType, Step->Type, CurInit.get()->getBeginLoc(),\n              CurInit.get()->getSourceRange(), &BasePath, IgnoreBaseAccess))\n        return ExprError();\n\n      ExprValueKind VK =\n          Step->Kind == SK_CastDerivedToBaseLValue ?\n              VK_LValue :\n              (Step->Kind == SK_CastDerivedToBaseXValue ?\n                   VK_XValue :\n                   VK_RValue);\n      CurInit = ImplicitCastExpr::Create(S.Context, Step->Type,\n                                         CK_DerivedToBase, CurInit.get(),\n                                         &BasePath, VK, FPOptionsOverride());\n      break;\n    }\n\n    case SK_BindReference:\n      // Reference binding does not have any corresponding ASTs.\n\n      // Check exception specifications\n      if (S.CheckExceptionSpecCompatibility(CurInit.get(), DestType))\n        return ExprError();\n\n      // We don't check for e.g. function pointers here, since address\n      // availability checks should only occur when the function first decays\n      // into a pointer or reference.\n      if (CurInit.get()->getType()->isFunctionProtoType()) {\n        if (auto *DRE = dyn_cast<DeclRefExpr>(CurInit.get()->IgnoreParens())) {\n          if (auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl())) {\n            if (!S.checkAddressOfFunctionIsAvailable(FD, /*Complain=*/true,\n                                                     DRE->getBeginLoc()))\n              return ExprError();\n          }\n        }\n      }\n\n      CheckForNullPointerDereference(S, CurInit.get());\n      break;\n\n    case SK_BindReferenceToTemporary: {\n      // Make sure the \"temporary\" is actually an rvalue.\n      assert(CurInit.get()->isRValue() && \"not a temporary\");\n\n      // Check exception specifications\n      if (S.CheckExceptionSpecCompatibility(CurInit.get(), DestType))\n        return ExprError();\n\n      QualType MTETy = Step->Type;\n\n      // When this is an incomplete array type (such as when this is\n      // initializing an array of unknown bounds from an init list), use THAT\n      // type instead so that we propogate the array bounds.\n      if (MTETy->isIncompleteArrayType() &&\n          !CurInit.get()->getType()->isIncompleteArrayType() &&\n          S.Context.hasSameType(\n              MTETy->getPointeeOrArrayElementType(),\n              CurInit.get()->getType()->getPointeeOrArrayElementType()))\n        MTETy = CurInit.get()->getType();\n\n      // Materialize the temporary into memory.\n      MaterializeTemporaryExpr *MTE = S.CreateMaterializeTemporaryExpr(\n          MTETy, CurInit.get(), Entity.getType()->isLValueReferenceType());\n      CurInit = MTE;\n\n      // If we're extending this temporary to automatic storage duration -- we\n      // need to register its cleanup during the full-expression's cleanups.\n      if (MTE->getStorageDuration() == SD_Automatic &&\n          MTE->getType().isDestructedType())\n        S.Cleanup.setExprNeedsCleanups(true);\n      break;\n    }\n\n    case SK_FinalCopy:\n      if (checkAbstractType(Step->Type))\n        return ExprError();\n\n      // If the overall initialization is initializing a temporary, we already\n      // bound our argument if it was necessary to do so. If not (if we're\n      // ultimately initializing a non-temporary), our argument needs to be\n      // bound since it's initializing a function parameter.\n      // FIXME: This is a mess. Rationalize temporary destruction.\n      if (!shouldBindAsTemporary(Entity))\n        CurInit = S.MaybeBindToTemporary(CurInit.get());\n      CurInit = CopyObject(S, Step->Type, Entity, CurInit,\n                           /*IsExtraneousCopy=*/false);\n      break;\n\n    case SK_ExtraneousCopyToTemporary:\n      CurInit = CopyObject(S, Step->Type, Entity, CurInit,\n                           /*IsExtraneousCopy=*/true);\n      break;\n\n    case SK_UserConversion: {\n      // We have a user-defined conversion that invokes either a constructor\n      // or a conversion function.\n      CastKind CastKind;\n      FunctionDecl *Fn = Step->Function.Function;\n      DeclAccessPair FoundFn = Step->Function.FoundDecl;\n      bool HadMultipleCandidates = Step->Function.HadMultipleCandidates;\n      bool CreatedObject = false;\n      if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(Fn)) {\n        // Build a call to the selected constructor.\n        SmallVector<Expr*, 8> ConstructorArgs;\n        SourceLocation Loc = CurInit.get()->getBeginLoc();\n\n        // Determine the arguments required to actually perform the constructor\n        // call.\n        Expr *Arg = CurInit.get();\n        if (S.CompleteConstructorCall(Constructor, Step->Type,\n                                      MultiExprArg(&Arg, 1), Loc,\n                                      ConstructorArgs))\n          return ExprError();\n\n        // Build an expression that constructs a temporary.\n        CurInit = S.BuildCXXConstructExpr(Loc, Step->Type,\n                                          FoundFn, Constructor,\n                                          ConstructorArgs,\n                                          HadMultipleCandidates,\n                                          /*ListInit*/ false,\n                                          /*StdInitListInit*/ false,\n                                          /*ZeroInit*/ false,\n                                          CXXConstructExpr::CK_Complete,\n                                          SourceRange());\n        if (CurInit.isInvalid())\n          return ExprError();\n\n        S.CheckConstructorAccess(Kind.getLocation(), Constructor, FoundFn,\n                                 Entity);\n        if (S.DiagnoseUseOfDecl(FoundFn, Kind.getLocation()))\n          return ExprError();\n\n        CastKind = CK_ConstructorConversion;\n        CreatedObject = true;\n      } else {\n        // Build a call to the conversion function.\n        CXXConversionDecl *Conversion = cast<CXXConversionDecl>(Fn);\n        S.CheckMemberOperatorAccess(Kind.getLocation(), CurInit.get(), nullptr,\n                                    FoundFn);\n        if (S.DiagnoseUseOfDecl(FoundFn, Kind.getLocation()))\n          return ExprError();\n\n        CurInit = S.BuildCXXMemberCallExpr(CurInit.get(), FoundFn, Conversion,\n                                           HadMultipleCandidates);\n        if (CurInit.isInvalid())\n          return ExprError();\n\n        CastKind = CK_UserDefinedConversion;\n        CreatedObject = Conversion->getReturnType()->isRecordType();\n      }\n\n      if (CreatedObject && checkAbstractType(CurInit.get()->getType()))\n        return ExprError();\n\n      CurInit = ImplicitCastExpr::Create(\n          S.Context, CurInit.get()->getType(), CastKind, CurInit.get(), nullptr,\n          CurInit.get()->getValueKind(), S.CurFPFeatureOverrides());\n\n      if (shouldBindAsTemporary(Entity))\n        // The overall entity is temporary, so this expression should be\n        // destroyed at the end of its full-expression.\n        CurInit = S.MaybeBindToTemporary(CurInit.getAs<Expr>());\n      else if (CreatedObject && shouldDestroyEntity(Entity)) {\n        // The object outlasts the full-expression, but we need to prepare for\n        // a destructor being run on it.\n        // FIXME: It makes no sense to do this here. This should happen\n        // regardless of how we initialized the entity.\n        QualType T = CurInit.get()->getType();\n        if (const RecordType *Record = T->getAs<RecordType>()) {\n          CXXDestructorDecl *Destructor\n            = S.LookupDestructor(cast<CXXRecordDecl>(Record->getDecl()));\n          S.CheckDestructorAccess(CurInit.get()->getBeginLoc(), Destructor,\n                                  S.PDiag(diag::err_access_dtor_temp) << T);\n          S.MarkFunctionReferenced(CurInit.get()->getBeginLoc(), Destructor);\n          if (S.DiagnoseUseOfDecl(Destructor, CurInit.get()->getBeginLoc()))\n            return ExprError();\n        }\n      }\n      break;\n    }\n\n    case SK_QualificationConversionLValue:\n    case SK_QualificationConversionXValue:\n    case SK_QualificationConversionRValue: {\n      // Perform a qualification conversion; these can never go wrong.\n      ExprValueKind VK =\n          Step->Kind == SK_QualificationConversionLValue\n              ? VK_LValue\n              : (Step->Kind == SK_QualificationConversionXValue ? VK_XValue\n                                                                : VK_RValue);\n      CurInit = S.PerformQualificationConversion(CurInit.get(), Step->Type, VK);\n      break;\n    }\n\n    case SK_FunctionReferenceConversion:\n      assert(CurInit.get()->isLValue() &&\n             \"function reference should be lvalue\");\n      CurInit =\n          S.ImpCastExprToType(CurInit.get(), Step->Type, CK_NoOp, VK_LValue);\n      break;\n\n    case SK_AtomicConversion: {\n      assert(CurInit.get()->isRValue() && \"cannot convert glvalue to atomic\");\n      CurInit = S.ImpCastExprToType(CurInit.get(), Step->Type,\n                                    CK_NonAtomicToAtomic, VK_RValue);\n      break;\n    }\n\n    case SK_ConversionSequence:\n    case SK_ConversionSequenceNoNarrowing: {\n      if (const auto *FromPtrType =\n              CurInit.get()->getType()->getAs<PointerType>()) {\n        if (const auto *ToPtrType = Step->Type->getAs<PointerType>()) {\n          if (FromPtrType->getPointeeType()->hasAttr(attr::NoDeref) &&\n              !ToPtrType->getPointeeType()->hasAttr(attr::NoDeref)) {\n            // Do not check static casts here because they are checked earlier\n            // in Sema::ActOnCXXNamedCast()\n            if (!Kind.isStaticCast()) {\n              S.Diag(CurInit.get()->getExprLoc(),\n                     diag::warn_noderef_to_dereferenceable_pointer)\n                  << CurInit.get()->getSourceRange();\n            }\n          }\n        }\n      }\n\n      Sema::CheckedConversionKind CCK\n        = Kind.isCStyleCast()? Sema::CCK_CStyleCast\n        : Kind.isFunctionalCast()? Sema::CCK_FunctionalCast\n        : Kind.isExplicitCast()? Sema::CCK_OtherCast\n        : Sema::CCK_ImplicitConversion;\n      ExprResult CurInitExprRes =\n        S.PerformImplicitConversion(CurInit.get(), Step->Type, *Step->ICS,\n                                    getAssignmentAction(Entity), CCK);\n      if (CurInitExprRes.isInvalid())\n        return ExprError();\n\n      S.DiscardMisalignedMemberAddress(Step->Type.getTypePtr(), CurInit.get());\n\n      CurInit = CurInitExprRes;\n\n      if (Step->Kind == SK_ConversionSequenceNoNarrowing &&\n          S.getLangOpts().CPlusPlus)\n        DiagnoseNarrowingInInitList(S, *Step->ICS, SourceType, Entity.getType(),\n                                    CurInit.get());\n\n      break;\n    }\n\n    case SK_ListInitialization: {\n      if (checkAbstractType(Step->Type))\n        return ExprError();\n\n      InitListExpr *InitList = cast<InitListExpr>(CurInit.get());\n      // If we're not initializing the top-level entity, we need to create an\n      // InitializeTemporary entity for our target type.\n      QualType Ty = Step->Type;\n      bool IsTemporary = !S.Context.hasSameType(Entity.getType(), Ty);\n      InitializedEntity TempEntity = InitializedEntity::InitializeTemporary(Ty);\n      InitializedEntity InitEntity = IsTemporary ? TempEntity : Entity;\n      InitListChecker PerformInitList(S, InitEntity,\n          InitList, Ty, /*VerifyOnly=*/false,\n          /*TreatUnavailableAsInvalid=*/false);\n      if (PerformInitList.HadError())\n        return ExprError();\n\n      // Hack: We must update *ResultType if available in order to set the\n      // bounds of arrays, e.g. in 'int ar[] = {1, 2, 3};'.\n      // Worst case: 'const int (&arref)[] = {1, 2, 3};'.\n      if (ResultType &&\n          ResultType->getNonReferenceType()->isIncompleteArrayType()) {\n        if ((*ResultType)->isRValueReferenceType())\n          Ty = S.Context.getRValueReferenceType(Ty);\n        else if ((*ResultType)->isLValueReferenceType())\n          Ty = S.Context.getLValueReferenceType(Ty,\n            (*ResultType)->castAs<LValueReferenceType>()->isSpelledAsLValue());\n        *ResultType = Ty;\n      }\n\n      InitListExpr *StructuredInitList =\n          PerformInitList.getFullyStructuredList();\n      CurInit.get();\n      CurInit = shouldBindAsTemporary(InitEntity)\n          ? S.MaybeBindToTemporary(StructuredInitList)\n          : StructuredInitList;\n      break;\n    }\n\n    case SK_ConstructorInitializationFromList: {\n      if (checkAbstractType(Step->Type))\n        return ExprError();\n\n      // When an initializer list is passed for a parameter of type \"reference\n      // to object\", we don't get an EK_Temporary entity, but instead an\n      // EK_Parameter entity with reference type.\n      // FIXME: This is a hack. What we really should do is create a user\n      // conversion step for this case, but this makes it considerably more\n      // complicated. For now, this will do.\n      InitializedEntity TempEntity = InitializedEntity::InitializeTemporary(\n                                        Entity.getType().getNonReferenceType());\n      bool UseTemporary = Entity.getType()->isReferenceType();\n      assert(Args.size() == 1 && \"expected a single argument for list init\");\n      InitListExpr *InitList = cast<InitListExpr>(Args[0]);\n      S.Diag(InitList->getExprLoc(), diag::warn_cxx98_compat_ctor_list_init)\n        << InitList->getSourceRange();\n      MultiExprArg Arg(InitList->getInits(), InitList->getNumInits());\n      CurInit = PerformConstructorInitialization(S, UseTemporary ? TempEntity :\n                                                                   Entity,\n                                                 Kind, Arg, *Step,\n                                               ConstructorInitRequiresZeroInit,\n                                               /*IsListInitialization*/true,\n                                               /*IsStdInitListInit*/false,\n                                               InitList->getLBraceLoc(),\n                                               InitList->getRBraceLoc());\n      break;\n    }\n\n    case SK_UnwrapInitList:\n      CurInit = cast<InitListExpr>(CurInit.get())->getInit(0);\n      break;\n\n    case SK_RewrapInitList: {\n      Expr *E = CurInit.get();\n      InitListExpr *Syntactic = Step->WrappingSyntacticList;\n      InitListExpr *ILE = new (S.Context) InitListExpr(S.Context,\n          Syntactic->getLBraceLoc(), E, Syntactic->getRBraceLoc());\n      ILE->setSyntacticForm(Syntactic);\n      ILE->setType(E->getType());\n      ILE->setValueKind(E->getValueKind());\n      CurInit = ILE;\n      break;\n    }\n\n    case SK_ConstructorInitialization:\n    case SK_StdInitializerListConstructorCall: {\n      if (checkAbstractType(Step->Type))\n        return ExprError();\n\n      // When an initializer list is passed for a parameter of type \"reference\n      // to object\", we don't get an EK_Temporary entity, but instead an\n      // EK_Parameter entity with reference type.\n      // FIXME: This is a hack. What we really should do is create a user\n      // conversion step for this case, but this makes it considerably more\n      // complicated. For now, this will do.\n      InitializedEntity TempEntity = InitializedEntity::InitializeTemporary(\n                                        Entity.getType().getNonReferenceType());\n      bool UseTemporary = Entity.getType()->isReferenceType();\n      bool IsStdInitListInit =\n          Step->Kind == SK_StdInitializerListConstructorCall;\n      Expr *Source = CurInit.get();\n      SourceRange Range = Kind.hasParenOrBraceRange()\n                              ? Kind.getParenOrBraceRange()\n                              : SourceRange();\n      CurInit = PerformConstructorInitialization(\n          S, UseTemporary ? TempEntity : Entity, Kind,\n          Source ? MultiExprArg(Source) : Args, *Step,\n          ConstructorInitRequiresZeroInit,\n          /*IsListInitialization*/ IsStdInitListInit,\n          /*IsStdInitListInitialization*/ IsStdInitListInit,\n          /*LBraceLoc*/ Range.getBegin(),\n          /*RBraceLoc*/ Range.getEnd());\n      break;\n    }\n\n    case SK_ZeroInitialization: {\n      step_iterator NextStep = Step;\n      ++NextStep;\n      if (NextStep != StepEnd &&\n          (NextStep->Kind == SK_ConstructorInitialization ||\n           NextStep->Kind == SK_ConstructorInitializationFromList)) {\n        // The need for zero-initialization is recorded directly into\n        // the call to the object's constructor within the next step.\n        ConstructorInitRequiresZeroInit = true;\n      } else if (Kind.getKind() == InitializationKind::IK_Value &&\n                 S.getLangOpts().CPlusPlus &&\n                 !Kind.isImplicitValueInit()) {\n        TypeSourceInfo *TSInfo = Entity.getTypeSourceInfo();\n        if (!TSInfo)\n          TSInfo = S.Context.getTrivialTypeSourceInfo(Step->Type,\n                                                    Kind.getRange().getBegin());\n\n        CurInit = new (S.Context) CXXScalarValueInitExpr(\n            Entity.getType().getNonLValueExprType(S.Context), TSInfo,\n            Kind.getRange().getEnd());\n      } else {\n        CurInit = new (S.Context) ImplicitValueInitExpr(Step->Type);\n      }\n      break;\n    }\n\n    case SK_CAssignment: {\n      QualType SourceType = CurInit.get()->getType();\n\n      // Save off the initial CurInit in case we need to emit a diagnostic\n      ExprResult InitialCurInit = CurInit;\n      ExprResult Result = CurInit;\n      Sema::AssignConvertType ConvTy =\n        S.CheckSingleAssignmentConstraints(Step->Type, Result, true,\n            Entity.getKind() == InitializedEntity::EK_Parameter_CF_Audited);\n      if (Result.isInvalid())\n        return ExprError();\n      CurInit = Result;\n\n      // If this is a call, allow conversion to a transparent union.\n      ExprResult CurInitExprRes = CurInit;\n      if (ConvTy != Sema::Compatible &&\n          Entity.isParameterKind() &&\n          S.CheckTransparentUnionArgumentConstraints(Step->Type, CurInitExprRes)\n            == Sema::Compatible)\n        ConvTy = Sema::Compatible;\n      if (CurInitExprRes.isInvalid())\n        return ExprError();\n      CurInit = CurInitExprRes;\n\n      bool Complained;\n      if (S.DiagnoseAssignmentResult(ConvTy, Kind.getLocation(),\n                                     Step->Type, SourceType,\n                                     InitialCurInit.get(),\n                                     getAssignmentAction(Entity, true),\n                                     &Complained)) {\n        PrintInitLocationNote(S, Entity);\n        return ExprError();\n      } else if (Complained)\n        PrintInitLocationNote(S, Entity);\n      break;\n    }\n\n    case SK_StringInit: {\n      QualType Ty = Step->Type;\n      bool UpdateType = ResultType && Entity.getType()->isIncompleteArrayType();\n      CheckStringInit(CurInit.get(), UpdateType ? *ResultType : Ty,\n                      S.Context.getAsArrayType(Ty), S);\n      break;\n    }\n\n    case SK_ObjCObjectConversion:\n      CurInit = S.ImpCastExprToType(CurInit.get(), Step->Type,\n                          CK_ObjCObjectLValueCast,\n                          CurInit.get()->getValueKind());\n      break;\n\n    case SK_ArrayLoopIndex: {\n      Expr *Cur = CurInit.get();\n      Expr *BaseExpr = new (S.Context)\n          OpaqueValueExpr(Cur->getExprLoc(), Cur->getType(),\n                          Cur->getValueKind(), Cur->getObjectKind(), Cur);\n      Expr *IndexExpr =\n          new (S.Context) ArrayInitIndexExpr(S.Context.getSizeType());\n      CurInit = S.CreateBuiltinArraySubscriptExpr(\n          BaseExpr, Kind.getLocation(), IndexExpr, Kind.getLocation());\n      ArrayLoopCommonExprs.push_back(BaseExpr);\n      break;\n    }\n\n    case SK_ArrayLoopInit: {\n      assert(!ArrayLoopCommonExprs.empty() &&\n             \"mismatched SK_ArrayLoopIndex and SK_ArrayLoopInit\");\n      Expr *Common = ArrayLoopCommonExprs.pop_back_val();\n      CurInit = new (S.Context) ArrayInitLoopExpr(Step->Type, Common,\n                                                  CurInit.get());\n      break;\n    }\n\n    case SK_GNUArrayInit:\n      // Okay: we checked everything before creating this step. Note that\n      // this is a GNU extension.\n      S.Diag(Kind.getLocation(), diag::ext_array_init_copy)\n        << Step->Type << CurInit.get()->getType()\n        << CurInit.get()->getSourceRange();\n      updateGNUCompoundLiteralRValue(CurInit.get());\n      LLVM_FALLTHROUGH;\n    case SK_ArrayInit:\n      // If the destination type is an incomplete array type, update the\n      // type accordingly.\n      if (ResultType) {\n        if (const IncompleteArrayType *IncompleteDest\n                           = S.Context.getAsIncompleteArrayType(Step->Type)) {\n          if (const ConstantArrayType *ConstantSource\n                 = S.Context.getAsConstantArrayType(CurInit.get()->getType())) {\n            *ResultType = S.Context.getConstantArrayType(\n                                             IncompleteDest->getElementType(),\n                                             ConstantSource->getSize(),\n                                             ConstantSource->getSizeExpr(),\n                                             ArrayType::Normal, 0);\n          }\n        }\n      }\n      break;\n\n    case SK_ParenthesizedArrayInit:\n      // Okay: we checked everything before creating this step. Note that\n      // this is a GNU extension.\n      S.Diag(Kind.getLocation(), diag::ext_array_init_parens)\n        << CurInit.get()->getSourceRange();\n      break;\n\n    case SK_PassByIndirectCopyRestore:\n    case SK_PassByIndirectRestore:\n      checkIndirectCopyRestoreSource(S, CurInit.get());\n      CurInit = new (S.Context) ObjCIndirectCopyRestoreExpr(\n          CurInit.get(), Step->Type,\n          Step->Kind == SK_PassByIndirectCopyRestore);\n      break;\n\n    case SK_ProduceObjCObject:\n      CurInit = ImplicitCastExpr::Create(\n          S.Context, Step->Type, CK_ARCProduceObject, CurInit.get(), nullptr,\n          VK_RValue, FPOptionsOverride());\n      break;\n\n    case SK_StdInitializerList: {\n      S.Diag(CurInit.get()->getExprLoc(),\n             diag::warn_cxx98_compat_initializer_list_init)\n        << CurInit.get()->getSourceRange();\n\n      // Materialize the temporary into memory.\n      MaterializeTemporaryExpr *MTE = S.CreateMaterializeTemporaryExpr(\n          CurInit.get()->getType(), CurInit.get(),\n          /*BoundToLvalueReference=*/false);\n\n      // Wrap it in a construction of a std::initializer_list<T>.\n      CurInit = new (S.Context) CXXStdInitializerListExpr(Step->Type, MTE);\n\n      // Bind the result, in case the library has given initializer_list a\n      // non-trivial destructor.\n      if (shouldBindAsTemporary(Entity))\n        CurInit = S.MaybeBindToTemporary(CurInit.get());\n      break;\n    }\n\n    case SK_OCLSamplerInit: {\n      // Sampler initialization have 5 cases:\n      //   1. function argument passing\n      //      1a. argument is a file-scope variable\n      //      1b. argument is a function-scope variable\n      //      1c. argument is one of caller function's parameters\n      //   2. variable initialization\n      //      2a. initializing a file-scope variable\n      //      2b. initializing a function-scope variable\n      //\n      // For file-scope variables, since they cannot be initialized by function\n      // call of __translate_sampler_initializer in LLVM IR, their references\n      // need to be replaced by a cast from their literal initializers to\n      // sampler type. Since sampler variables can only be used in function\n      // calls as arguments, we only need to replace them when handling the\n      // argument passing.\n      assert(Step->Type->isSamplerT() &&\n             \"Sampler initialization on non-sampler type.\");\n      Expr *Init = CurInit.get()->IgnoreParens();\n      QualType SourceType = Init->getType();\n      // Case 1\n      if (Entity.isParameterKind()) {\n        if (!SourceType->isSamplerT() && !SourceType->isIntegerType()) {\n          S.Diag(Kind.getLocation(), diag::err_sampler_argument_required)\n            << SourceType;\n          break;\n        } else if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Init)) {\n          auto Var = cast<VarDecl>(DRE->getDecl());\n          // Case 1b and 1c\n          // No cast from integer to sampler is needed.\n          if (!Var->hasGlobalStorage()) {\n            CurInit = ImplicitCastExpr::Create(\n                S.Context, Step->Type, CK_LValueToRValue, Init,\n                /*BasePath=*/nullptr, VK_RValue, FPOptionsOverride());\n            break;\n          }\n          // Case 1a\n          // For function call with a file-scope sampler variable as argument,\n          // get the integer literal.\n          // Do not diagnose if the file-scope variable does not have initializer\n          // since this has already been diagnosed when parsing the variable\n          // declaration.\n          if (!Var->getInit() || !isa<ImplicitCastExpr>(Var->getInit()))\n            break;\n          Init = cast<ImplicitCastExpr>(const_cast<Expr*>(\n            Var->getInit()))->getSubExpr();\n          SourceType = Init->getType();\n        }\n      } else {\n        // Case 2\n        // Check initializer is 32 bit integer constant.\n        // If the initializer is taken from global variable, do not diagnose since\n        // this has already been done when parsing the variable declaration.\n        if (!Init->isConstantInitializer(S.Context, false))\n          break;\n\n        if (!SourceType->isIntegerType() ||\n            32 != S.Context.getIntWidth(SourceType)) {\n          S.Diag(Kind.getLocation(), diag::err_sampler_initializer_not_integer)\n            << SourceType;\n          break;\n        }\n\n        Expr::EvalResult EVResult;\n        Init->EvaluateAsInt(EVResult, S.Context);\n        llvm::APSInt Result = EVResult.Val.getInt();\n        const uint64_t SamplerValue = Result.getLimitedValue();\n        // 32-bit value of sampler's initializer is interpreted as\n        // bit-field with the following structure:\n        // |unspecified|Filter|Addressing Mode| Normalized Coords|\n        // |31        6|5    4|3             1|                 0|\n        // This structure corresponds to enum values of sampler properties\n        // defined in SPIR spec v1.2 and also opencl-c.h\n        unsigned AddressingMode  = (0x0E & SamplerValue) >> 1;\n        unsigned FilterMode      = (0x30 & SamplerValue) >> 4;\n        if (FilterMode != 1 && FilterMode != 2 &&\n            !S.getOpenCLOptions().isEnabled(\n                \"cl_intel_device_side_avc_motion_estimation\"))\n          S.Diag(Kind.getLocation(),\n                 diag::warn_sampler_initializer_invalid_bits)\n                 << \"Filter Mode\";\n        if (AddressingMode > 4)\n          S.Diag(Kind.getLocation(),\n                 diag::warn_sampler_initializer_invalid_bits)\n                 << \"Addressing Mode\";\n      }\n\n      // Cases 1a, 2a and 2b\n      // Insert cast from integer to sampler.\n      CurInit = S.ImpCastExprToType(Init, S.Context.OCLSamplerTy,\n                                      CK_IntToOCLSampler);\n      break;\n    }\n    case SK_OCLZeroOpaqueType: {\n      assert((Step->Type->isEventT() || Step->Type->isQueueT() ||\n              Step->Type->isOCLIntelSubgroupAVCType()) &&\n             \"Wrong type for initialization of OpenCL opaque type.\");\n\n      CurInit = S.ImpCastExprToType(CurInit.get(), Step->Type,\n                                    CK_ZeroToOCLOpaqueType,\n                                    CurInit.get()->getValueKind());\n      break;\n    }\n    }\n  }\n\n  // Check whether the initializer has a shorter lifetime than the initialized\n  // entity, and if not, either lifetime-extend or warn as appropriate.\n  if (auto *Init = CurInit.get())\n    S.checkInitializerLifetime(Entity, Init);\n\n  // Diagnose non-fatal problems with the completed initialization.\n  if (Entity.getKind() == InitializedEntity::EK_Member &&\n      cast<FieldDecl>(Entity.getDecl())->isBitField())\n    S.CheckBitFieldInitialization(Kind.getLocation(),\n                                  cast<FieldDecl>(Entity.getDecl()),\n                                  CurInit.get());\n\n  // Check for std::move on construction.\n  if (const Expr *E = CurInit.get()) {\n    CheckMoveOnConstruction(S, E,\n                            Entity.getKind() == InitializedEntity::EK_Result);\n  }\n\n  return CurInit;\n}\n\n/// Somewhere within T there is an uninitialized reference subobject.\n/// Dig it out and diagnose it.\nstatic bool DiagnoseUninitializedReference(Sema &S, SourceLocation Loc,\n                                           QualType T) {\n  if (T->isReferenceType()) {\n    S.Diag(Loc, diag::err_reference_without_init)\n      << T.getNonReferenceType();\n    return true;\n  }\n\n  CXXRecordDecl *RD = T->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();\n  if (!RD || !RD->hasUninitializedReferenceMember())\n    return false;\n\n  for (const auto *FI : RD->fields()) {\n    if (FI->isUnnamedBitfield())\n      continue;\n\n    if (DiagnoseUninitializedReference(S, FI->getLocation(), FI->getType())) {\n      S.Diag(Loc, diag::note_value_initialization_here) << RD;\n      return true;\n    }\n  }\n\n  for (const auto &BI : RD->bases()) {\n    if (DiagnoseUninitializedReference(S, BI.getBeginLoc(), BI.getType())) {\n      S.Diag(Loc, diag::note_value_initialization_here) << RD;\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n//===----------------------------------------------------------------------===//\n// Diagnose initialization failures\n//===----------------------------------------------------------------------===//\n\n/// Emit notes associated with an initialization that failed due to a\n/// \"simple\" conversion failure.\nstatic void emitBadConversionNotes(Sema &S, const InitializedEntity &entity,\n                                   Expr *op) {\n  QualType destType = entity.getType();\n  if (destType.getNonReferenceType()->isObjCObjectPointerType() &&\n      op->getType()->isObjCObjectPointerType()) {\n\n    // Emit a possible note about the conversion failing because the\n    // operand is a message send with a related result type.\n    S.EmitRelatedResultTypeNote(op);\n\n    // Emit a possible note about a return failing because we're\n    // expecting a related result type.\n    if (entity.getKind() == InitializedEntity::EK_Result)\n      S.EmitRelatedResultTypeNoteForReturn(destType);\n  }\n  QualType fromType = op->getType();\n  auto *fromDecl = fromType.getTypePtr()->getPointeeCXXRecordDecl();\n  auto *destDecl = destType.getTypePtr()->getPointeeCXXRecordDecl();\n  if (fromDecl && destDecl && fromDecl->getDeclKind() == Decl::CXXRecord &&\n      destDecl->getDeclKind() == Decl::CXXRecord &&\n      !fromDecl->isInvalidDecl() && !destDecl->isInvalidDecl() &&\n      !fromDecl->hasDefinition())\n    S.Diag(fromDecl->getLocation(), diag::note_forward_class_conversion)\n        << S.getASTContext().getTagDeclType(fromDecl)\n        << S.getASTContext().getTagDeclType(destDecl);\n}\n\nstatic void diagnoseListInit(Sema &S, const InitializedEntity &Entity,\n                             InitListExpr *InitList) {\n  QualType DestType = Entity.getType();\n\n  QualType E;\n  if (S.getLangOpts().CPlusPlus11 && S.isStdInitializerList(DestType, &E)) {\n    QualType ArrayType = S.Context.getConstantArrayType(\n        E.withConst(),\n        llvm::APInt(S.Context.getTypeSize(S.Context.getSizeType()),\n                    InitList->getNumInits()),\n        nullptr, clang::ArrayType::Normal, 0);\n    InitializedEntity HiddenArray =\n        InitializedEntity::InitializeTemporary(ArrayType);\n    return diagnoseListInit(S, HiddenArray, InitList);\n  }\n\n  if (DestType->isReferenceType()) {\n    // A list-initialization failure for a reference means that we tried to\n    // create a temporary of the inner type (per [dcl.init.list]p3.6) and the\n    // inner initialization failed.\n    QualType T = DestType->castAs<ReferenceType>()->getPointeeType();\n    diagnoseListInit(S, InitializedEntity::InitializeTemporary(T), InitList);\n    SourceLocation Loc = InitList->getBeginLoc();\n    if (auto *D = Entity.getDecl())\n      Loc = D->getLocation();\n    S.Diag(Loc, diag::note_in_reference_temporary_list_initializer) << T;\n    return;\n  }\n\n  InitListChecker DiagnoseInitList(S, Entity, InitList, DestType,\n                                   /*VerifyOnly=*/false,\n                                   /*TreatUnavailableAsInvalid=*/false);\n  assert(DiagnoseInitList.HadError() &&\n         \"Inconsistent init list check result.\");\n}\n\nbool InitializationSequence::Diagnose(Sema &S,\n                                      const InitializedEntity &Entity,\n                                      const InitializationKind &Kind,\n                                      ArrayRef<Expr *> Args) {\n  if (!Failed())\n    return false;\n\n  // When we want to diagnose only one element of a braced-init-list,\n  // we need to factor it out.\n  Expr *OnlyArg;\n  if (Args.size() == 1) {\n    auto *List = dyn_cast<InitListExpr>(Args[0]);\n    if (List && List->getNumInits() == 1)\n      OnlyArg = List->getInit(0);\n    else\n      OnlyArg = Args[0];\n  }\n  else\n    OnlyArg = nullptr;\n\n  QualType DestType = Entity.getType();\n  switch (Failure) {\n  case FK_TooManyInitsForReference:\n    // FIXME: Customize for the initialized entity?\n    if (Args.empty()) {\n      // Dig out the reference subobject which is uninitialized and diagnose it.\n      // If this is value-initialization, this could be nested some way within\n      // the target type.\n      assert(Kind.getKind() == InitializationKind::IK_Value ||\n             DestType->isReferenceType());\n      bool Diagnosed =\n        DiagnoseUninitializedReference(S, Kind.getLocation(), DestType);\n      assert(Diagnosed && \"couldn't find uninitialized reference to diagnose\");\n      (void)Diagnosed;\n    } else  // FIXME: diagnostic below could be better!\n      S.Diag(Kind.getLocation(), diag::err_reference_has_multiple_inits)\n          << SourceRange(Args.front()->getBeginLoc(), Args.back()->getEndLoc());\n    break;\n  case FK_ParenthesizedListInitForReference:\n    S.Diag(Kind.getLocation(), diag::err_list_init_in_parens)\n      << 1 << Entity.getType() << Args[0]->getSourceRange();\n    break;\n\n  case FK_ArrayNeedsInitList:\n    S.Diag(Kind.getLocation(), diag::err_array_init_not_init_list) << 0;\n    break;\n  case FK_ArrayNeedsInitListOrStringLiteral:\n    S.Diag(Kind.getLocation(), diag::err_array_init_not_init_list) << 1;\n    break;\n  case FK_ArrayNeedsInitListOrWideStringLiteral:\n    S.Diag(Kind.getLocation(), diag::err_array_init_not_init_list) << 2;\n    break;\n  case FK_NarrowStringIntoWideCharArray:\n    S.Diag(Kind.getLocation(), diag::err_array_init_narrow_string_into_wchar);\n    break;\n  case FK_WideStringIntoCharArray:\n    S.Diag(Kind.getLocation(), diag::err_array_init_wide_string_into_char);\n    break;\n  case FK_IncompatWideStringIntoWideChar:\n    S.Diag(Kind.getLocation(),\n           diag::err_array_init_incompat_wide_string_into_wchar);\n    break;\n  case FK_PlainStringIntoUTF8Char:\n    S.Diag(Kind.getLocation(),\n           diag::err_array_init_plain_string_into_char8_t);\n    S.Diag(Args.front()->getBeginLoc(),\n           diag::note_array_init_plain_string_into_char8_t)\n        << FixItHint::CreateInsertion(Args.front()->getBeginLoc(), \"u8\");\n    break;\n  case FK_UTF8StringIntoPlainChar:\n    S.Diag(Kind.getLocation(),\n           diag::err_array_init_utf8_string_into_char)\n      << S.getLangOpts().CPlusPlus20;\n    break;\n  case FK_ArrayTypeMismatch:\n  case FK_NonConstantArrayInit:\n    S.Diag(Kind.getLocation(),\n           (Failure == FK_ArrayTypeMismatch\n              ? diag::err_array_init_different_type\n              : diag::err_array_init_non_constant_array))\n      << DestType.getNonReferenceType()\n      << OnlyArg->getType()\n      << Args[0]->getSourceRange();\n    break;\n\n  case FK_VariableLengthArrayHasInitializer:\n    S.Diag(Kind.getLocation(), diag::err_variable_object_no_init)\n      << Args[0]->getSourceRange();\n    break;\n\n  case FK_AddressOfOverloadFailed: {\n    DeclAccessPair Found;\n    S.ResolveAddressOfOverloadedFunction(OnlyArg,\n                                         DestType.getNonReferenceType(),\n                                         true,\n                                         Found);\n    break;\n  }\n\n  case FK_AddressOfUnaddressableFunction: {\n    auto *FD = cast<FunctionDecl>(cast<DeclRefExpr>(OnlyArg)->getDecl());\n    S.checkAddressOfFunctionIsAvailable(FD, /*Complain=*/true,\n                                        OnlyArg->getBeginLoc());\n    break;\n  }\n\n  case FK_ReferenceInitOverloadFailed:\n  case FK_UserConversionOverloadFailed:\n    switch (FailedOverloadResult) {\n    case OR_Ambiguous:\n\n      FailedCandidateSet.NoteCandidates(\n          PartialDiagnosticAt(\n              Kind.getLocation(),\n              Failure == FK_UserConversionOverloadFailed\n                  ? (S.PDiag(diag::err_typecheck_ambiguous_condition)\n                     << OnlyArg->getType() << DestType\n                     << Args[0]->getSourceRange())\n                  : (S.PDiag(diag::err_ref_init_ambiguous)\n                     << DestType << OnlyArg->getType()\n                     << Args[0]->getSourceRange())),\n          S, OCD_AmbiguousCandidates, Args);\n      break;\n\n    case OR_No_Viable_Function: {\n      auto Cands = FailedCandidateSet.CompleteCandidates(S, OCD_AllCandidates, Args);\n      if (!S.RequireCompleteType(Kind.getLocation(),\n                                 DestType.getNonReferenceType(),\n                          diag::err_typecheck_nonviable_condition_incomplete,\n                               OnlyArg->getType(), Args[0]->getSourceRange()))\n        S.Diag(Kind.getLocation(), diag::err_typecheck_nonviable_condition)\n          << (Entity.getKind() == InitializedEntity::EK_Result)\n          << OnlyArg->getType() << Args[0]->getSourceRange()\n          << DestType.getNonReferenceType();\n\n      FailedCandidateSet.NoteCandidates(S, Args, Cands);\n      break;\n    }\n    case OR_Deleted: {\n      S.Diag(Kind.getLocation(), diag::err_typecheck_deleted_function)\n        << OnlyArg->getType() << DestType.getNonReferenceType()\n        << Args[0]->getSourceRange();\n      OverloadCandidateSet::iterator Best;\n      OverloadingResult Ovl\n        = FailedCandidateSet.BestViableFunction(S, Kind.getLocation(), Best);\n      if (Ovl == OR_Deleted) {\n        S.NoteDeletedFunction(Best->Function);\n      } else {\n        llvm_unreachable(\"Inconsistent overload resolution?\");\n      }\n      break;\n    }\n\n    case OR_Success:\n      llvm_unreachable(\"Conversion did not fail!\");\n    }\n    break;\n\n  case FK_NonConstLValueReferenceBindingToTemporary:\n    if (isa<InitListExpr>(Args[0])) {\n      S.Diag(Kind.getLocation(),\n             diag::err_lvalue_reference_bind_to_initlist)\n      << DestType.getNonReferenceType().isVolatileQualified()\n      << DestType.getNonReferenceType()\n      << Args[0]->getSourceRange();\n      break;\n    }\n    LLVM_FALLTHROUGH;\n\n  case FK_NonConstLValueReferenceBindingToUnrelated:\n    S.Diag(Kind.getLocation(),\n           Failure == FK_NonConstLValueReferenceBindingToTemporary\n             ? diag::err_lvalue_reference_bind_to_temporary\n             : diag::err_lvalue_reference_bind_to_unrelated)\n      << DestType.getNonReferenceType().isVolatileQualified()\n      << DestType.getNonReferenceType()\n      << OnlyArg->getType()\n      << Args[0]->getSourceRange();\n    break;\n\n  case FK_NonConstLValueReferenceBindingToBitfield: {\n    // We don't necessarily have an unambiguous source bit-field.\n    FieldDecl *BitField = Args[0]->getSourceBitField();\n    S.Diag(Kind.getLocation(), diag::err_reference_bind_to_bitfield)\n      << DestType.isVolatileQualified()\n      << (BitField ? BitField->getDeclName() : DeclarationName())\n      << (BitField != nullptr)\n      << Args[0]->getSourceRange();\n    if (BitField)\n      S.Diag(BitField->getLocation(), diag::note_bitfield_decl);\n    break;\n  }\n\n  case FK_NonConstLValueReferenceBindingToVectorElement:\n    S.Diag(Kind.getLocation(), diag::err_reference_bind_to_vector_element)\n      << DestType.isVolatileQualified()\n      << Args[0]->getSourceRange();\n    break;\n\n  case FK_NonConstLValueReferenceBindingToMatrixElement:\n    S.Diag(Kind.getLocation(), diag::err_reference_bind_to_matrix_element)\n        << DestType.isVolatileQualified() << Args[0]->getSourceRange();\n    break;\n\n  case FK_RValueReferenceBindingToLValue:\n    S.Diag(Kind.getLocation(), diag::err_lvalue_to_rvalue_ref)\n      << DestType.getNonReferenceType() << OnlyArg->getType()\n      << Args[0]->getSourceRange();\n    break;\n\n  case FK_ReferenceAddrspaceMismatchTemporary:\n    S.Diag(Kind.getLocation(), diag::err_reference_bind_temporary_addrspace)\n        << DestType << Args[0]->getSourceRange();\n    break;\n\n  case FK_ReferenceInitDropsQualifiers: {\n    QualType SourceType = OnlyArg->getType();\n    QualType NonRefType = DestType.getNonReferenceType();\n    Qualifiers DroppedQualifiers =\n        SourceType.getQualifiers() - NonRefType.getQualifiers();\n\n    if (!NonRefType.getQualifiers().isAddressSpaceSupersetOf(\n            SourceType.getQualifiers()))\n      S.Diag(Kind.getLocation(), diag::err_reference_bind_drops_quals)\n          << NonRefType << SourceType << 1 /*addr space*/\n          << Args[0]->getSourceRange();\n    else if (DroppedQualifiers.hasQualifiers())\n      S.Diag(Kind.getLocation(), diag::err_reference_bind_drops_quals)\n          << NonRefType << SourceType << 0 /*cv quals*/\n          << Qualifiers::fromCVRMask(DroppedQualifiers.getCVRQualifiers())\n          << DroppedQualifiers.getCVRQualifiers() << Args[0]->getSourceRange();\n    else\n      // FIXME: Consider decomposing the type and explaining which qualifiers\n      // were dropped where, or on which level a 'const' is missing, etc.\n      S.Diag(Kind.getLocation(), diag::err_reference_bind_drops_quals)\n          << NonRefType << SourceType << 2 /*incompatible quals*/\n          << Args[0]->getSourceRange();\n    break;\n  }\n\n  case FK_ReferenceInitFailed:\n    S.Diag(Kind.getLocation(), diag::err_reference_bind_failed)\n      << DestType.getNonReferenceType()\n      << DestType.getNonReferenceType()->isIncompleteType()\n      << OnlyArg->isLValue()\n      << OnlyArg->getType()\n      << Args[0]->getSourceRange();\n    emitBadConversionNotes(S, Entity, Args[0]);\n    break;\n\n  case FK_ConversionFailed: {\n    QualType FromType = OnlyArg->getType();\n    PartialDiagnostic PDiag = S.PDiag(diag::err_init_conversion_failed)\n      << (int)Entity.getKind()\n      << DestType\n      << OnlyArg->isLValue()\n      << FromType\n      << Args[0]->getSourceRange();\n    S.HandleFunctionTypeMismatch(PDiag, FromType, DestType);\n    S.Diag(Kind.getLocation(), PDiag);\n    emitBadConversionNotes(S, Entity, Args[0]);\n    break;\n  }\n\n  case FK_ConversionFromPropertyFailed:\n    // No-op. This error has already been reported.\n    break;\n\n  case FK_TooManyInitsForScalar: {\n    SourceRange R;\n\n    auto *InitList = dyn_cast<InitListExpr>(Args[0]);\n    if (InitList && InitList->getNumInits() >= 1) {\n      R = SourceRange(InitList->getInit(0)->getEndLoc(), InitList->getEndLoc());\n    } else {\n      assert(Args.size() > 1 && \"Expected multiple initializers!\");\n      R = SourceRange(Args.front()->getEndLoc(), Args.back()->getEndLoc());\n    }\n\n    R.setBegin(S.getLocForEndOfToken(R.getBegin()));\n    if (Kind.isCStyleOrFunctionalCast())\n      S.Diag(Kind.getLocation(), diag::err_builtin_func_cast_more_than_one_arg)\n        << R;\n    else\n      S.Diag(Kind.getLocation(), diag::err_excess_initializers)\n        << /*scalar=*/2 << R;\n    break;\n  }\n\n  case FK_ParenthesizedListInitForScalar:\n    S.Diag(Kind.getLocation(), diag::err_list_init_in_parens)\n      << 0 << Entity.getType() << Args[0]->getSourceRange();\n    break;\n\n  case FK_ReferenceBindingToInitList:\n    S.Diag(Kind.getLocation(), diag::err_reference_bind_init_list)\n      << DestType.getNonReferenceType() << Args[0]->getSourceRange();\n    break;\n\n  case FK_InitListBadDestinationType:\n    S.Diag(Kind.getLocation(), diag::err_init_list_bad_dest_type)\n      << (DestType->isRecordType()) << DestType << Args[0]->getSourceRange();\n    break;\n\n  case FK_ListConstructorOverloadFailed:\n  case FK_ConstructorOverloadFailed: {\n    SourceRange ArgsRange;\n    if (Args.size())\n      ArgsRange =\n          SourceRange(Args.front()->getBeginLoc(), Args.back()->getEndLoc());\n\n    if (Failure == FK_ListConstructorOverloadFailed) {\n      assert(Args.size() == 1 &&\n             \"List construction from other than 1 argument.\");\n      InitListExpr *InitList = cast<InitListExpr>(Args[0]);\n      Args = MultiExprArg(InitList->getInits(), InitList->getNumInits());\n    }\n\n    // FIXME: Using \"DestType\" for the entity we're printing is probably\n    // bad.\n    switch (FailedOverloadResult) {\n      case OR_Ambiguous:\n        FailedCandidateSet.NoteCandidates(\n            PartialDiagnosticAt(Kind.getLocation(),\n                                S.PDiag(diag::err_ovl_ambiguous_init)\n                                    << DestType << ArgsRange),\n            S, OCD_AmbiguousCandidates, Args);\n        break;\n\n      case OR_No_Viable_Function:\n        if (Kind.getKind() == InitializationKind::IK_Default &&\n            (Entity.getKind() == InitializedEntity::EK_Base ||\n             Entity.getKind() == InitializedEntity::EK_Member) &&\n            isa<CXXConstructorDecl>(S.CurContext)) {\n          // This is implicit default initialization of a member or\n          // base within a constructor. If no viable function was\n          // found, notify the user that they need to explicitly\n          // initialize this base/member.\n          CXXConstructorDecl *Constructor\n            = cast<CXXConstructorDecl>(S.CurContext);\n          const CXXRecordDecl *InheritedFrom = nullptr;\n          if (auto Inherited = Constructor->getInheritedConstructor())\n            InheritedFrom = Inherited.getShadowDecl()->getNominatedBaseClass();\n          if (Entity.getKind() == InitializedEntity::EK_Base) {\n            S.Diag(Kind.getLocation(), diag::err_missing_default_ctor)\n              << (InheritedFrom ? 2 : Constructor->isImplicit() ? 1 : 0)\n              << S.Context.getTypeDeclType(Constructor->getParent())\n              << /*base=*/0\n              << Entity.getType()\n              << InheritedFrom;\n\n            RecordDecl *BaseDecl\n              = Entity.getBaseSpecifier()->getType()->castAs<RecordType>()\n                                                                  ->getDecl();\n            S.Diag(BaseDecl->getLocation(), diag::note_previous_decl)\n              << S.Context.getTagDeclType(BaseDecl);\n          } else {\n            S.Diag(Kind.getLocation(), diag::err_missing_default_ctor)\n              << (InheritedFrom ? 2 : Constructor->isImplicit() ? 1 : 0)\n              << S.Context.getTypeDeclType(Constructor->getParent())\n              << /*member=*/1\n              << Entity.getName()\n              << InheritedFrom;\n            S.Diag(Entity.getDecl()->getLocation(),\n                   diag::note_member_declared_at);\n\n            if (const RecordType *Record\n                                 = Entity.getType()->getAs<RecordType>())\n              S.Diag(Record->getDecl()->getLocation(),\n                     diag::note_previous_decl)\n                << S.Context.getTagDeclType(Record->getDecl());\n          }\n          break;\n        }\n\n        FailedCandidateSet.NoteCandidates(\n            PartialDiagnosticAt(\n                Kind.getLocation(),\n                S.PDiag(diag::err_ovl_no_viable_function_in_init)\n                    << DestType << ArgsRange),\n            S, OCD_AllCandidates, Args);\n        break;\n\n      case OR_Deleted: {\n        OverloadCandidateSet::iterator Best;\n        OverloadingResult Ovl\n          = FailedCandidateSet.BestViableFunction(S, Kind.getLocation(), Best);\n        if (Ovl != OR_Deleted) {\n          S.Diag(Kind.getLocation(), diag::err_ovl_deleted_init)\n              << DestType << ArgsRange;\n          llvm_unreachable(\"Inconsistent overload resolution?\");\n          break;\n        }\n\n        // If this is a defaulted or implicitly-declared function, then\n        // it was implicitly deleted. Make it clear that the deletion was\n        // implicit.\n        if (S.isImplicitlyDeleted(Best->Function))\n          S.Diag(Kind.getLocation(), diag::err_ovl_deleted_special_init)\n            << S.getSpecialMember(cast<CXXMethodDecl>(Best->Function))\n            << DestType << ArgsRange;\n        else\n          S.Diag(Kind.getLocation(), diag::err_ovl_deleted_init)\n              << DestType << ArgsRange;\n\n        S.NoteDeletedFunction(Best->Function);\n        break;\n      }\n\n      case OR_Success:\n        llvm_unreachable(\"Conversion did not fail!\");\n    }\n  }\n  break;\n\n  case FK_DefaultInitOfConst:\n    if (Entity.getKind() == InitializedEntity::EK_Member &&\n        isa<CXXConstructorDecl>(S.CurContext)) {\n      // This is implicit default-initialization of a const member in\n      // a constructor. Complain that it needs to be explicitly\n      // initialized.\n      CXXConstructorDecl *Constructor = cast<CXXConstructorDecl>(S.CurContext);\n      S.Diag(Kind.getLocation(), diag::err_uninitialized_member_in_ctor)\n        << (Constructor->getInheritedConstructor() ? 2 :\n            Constructor->isImplicit() ? 1 : 0)\n        << S.Context.getTypeDeclType(Constructor->getParent())\n        << /*const=*/1\n        << Entity.getName();\n      S.Diag(Entity.getDecl()->getLocation(), diag::note_previous_decl)\n        << Entity.getName();\n    } else {\n      S.Diag(Kind.getLocation(), diag::err_default_init_const)\n          << DestType << (bool)DestType->getAs<RecordType>();\n    }\n    break;\n\n  case FK_Incomplete:\n    S.RequireCompleteType(Kind.getLocation(), FailedIncompleteType,\n                          diag::err_init_incomplete_type);\n    break;\n\n  case FK_ListInitializationFailed: {\n    // Run the init list checker again to emit diagnostics.\n    InitListExpr *InitList = cast<InitListExpr>(Args[0]);\n    diagnoseListInit(S, Entity, InitList);\n    break;\n  }\n\n  case FK_PlaceholderType: {\n    // FIXME: Already diagnosed!\n    break;\n  }\n\n  case FK_ExplicitConstructor: {\n    S.Diag(Kind.getLocation(), diag::err_selected_explicit_constructor)\n      << Args[0]->getSourceRange();\n    OverloadCandidateSet::iterator Best;\n    OverloadingResult Ovl\n      = FailedCandidateSet.BestViableFunction(S, Kind.getLocation(), Best);\n    (void)Ovl;\n    assert(Ovl == OR_Success && \"Inconsistent overload resolution\");\n    CXXConstructorDecl *CtorDecl = cast<CXXConstructorDecl>(Best->Function);\n    S.Diag(CtorDecl->getLocation(),\n           diag::note_explicit_ctor_deduction_guide_here) << false;\n    break;\n  }\n  }\n\n  PrintInitLocationNote(S, Entity);\n  return true;\n}\n\nvoid InitializationSequence::dump(raw_ostream &OS) const {\n  switch (SequenceKind) {\n  case FailedSequence: {\n    OS << \"Failed sequence: \";\n    switch (Failure) {\n    case FK_TooManyInitsForReference:\n      OS << \"too many initializers for reference\";\n      break;\n\n    case FK_ParenthesizedListInitForReference:\n      OS << \"parenthesized list init for reference\";\n      break;\n\n    case FK_ArrayNeedsInitList:\n      OS << \"array requires initializer list\";\n      break;\n\n    case FK_AddressOfUnaddressableFunction:\n      OS << \"address of unaddressable function was taken\";\n      break;\n\n    case FK_ArrayNeedsInitListOrStringLiteral:\n      OS << \"array requires initializer list or string literal\";\n      break;\n\n    case FK_ArrayNeedsInitListOrWideStringLiteral:\n      OS << \"array requires initializer list or wide string literal\";\n      break;\n\n    case FK_NarrowStringIntoWideCharArray:\n      OS << \"narrow string into wide char array\";\n      break;\n\n    case FK_WideStringIntoCharArray:\n      OS << \"wide string into char array\";\n      break;\n\n    case FK_IncompatWideStringIntoWideChar:\n      OS << \"incompatible wide string into wide char array\";\n      break;\n\n    case FK_PlainStringIntoUTF8Char:\n      OS << \"plain string literal into char8_t array\";\n      break;\n\n    case FK_UTF8StringIntoPlainChar:\n      OS << \"u8 string literal into char array\";\n      break;\n\n    case FK_ArrayTypeMismatch:\n      OS << \"array type mismatch\";\n      break;\n\n    case FK_NonConstantArrayInit:\n      OS << \"non-constant array initializer\";\n      break;\n\n    case FK_AddressOfOverloadFailed:\n      OS << \"address of overloaded function failed\";\n      break;\n\n    case FK_ReferenceInitOverloadFailed:\n      OS << \"overload resolution for reference initialization failed\";\n      break;\n\n    case FK_NonConstLValueReferenceBindingToTemporary:\n      OS << \"non-const lvalue reference bound to temporary\";\n      break;\n\n    case FK_NonConstLValueReferenceBindingToBitfield:\n      OS << \"non-const lvalue reference bound to bit-field\";\n      break;\n\n    case FK_NonConstLValueReferenceBindingToVectorElement:\n      OS << \"non-const lvalue reference bound to vector element\";\n      break;\n\n    case FK_NonConstLValueReferenceBindingToMatrixElement:\n      OS << \"non-const lvalue reference bound to matrix element\";\n      break;\n\n    case FK_NonConstLValueReferenceBindingToUnrelated:\n      OS << \"non-const lvalue reference bound to unrelated type\";\n      break;\n\n    case FK_RValueReferenceBindingToLValue:\n      OS << \"rvalue reference bound to an lvalue\";\n      break;\n\n    case FK_ReferenceInitDropsQualifiers:\n      OS << \"reference initialization drops qualifiers\";\n      break;\n\n    case FK_ReferenceAddrspaceMismatchTemporary:\n      OS << \"reference with mismatching address space bound to temporary\";\n      break;\n\n    case FK_ReferenceInitFailed:\n      OS << \"reference initialization failed\";\n      break;\n\n    case FK_ConversionFailed:\n      OS << \"conversion failed\";\n      break;\n\n    case FK_ConversionFromPropertyFailed:\n      OS << \"conversion from property failed\";\n      break;\n\n    case FK_TooManyInitsForScalar:\n      OS << \"too many initializers for scalar\";\n      break;\n\n    case FK_ParenthesizedListInitForScalar:\n      OS << \"parenthesized list init for reference\";\n      break;\n\n    case FK_ReferenceBindingToInitList:\n      OS << \"referencing binding to initializer list\";\n      break;\n\n    case FK_InitListBadDestinationType:\n      OS << \"initializer list for non-aggregate, non-scalar type\";\n      break;\n\n    case FK_UserConversionOverloadFailed:\n      OS << \"overloading failed for user-defined conversion\";\n      break;\n\n    case FK_ConstructorOverloadFailed:\n      OS << \"constructor overloading failed\";\n      break;\n\n    case FK_DefaultInitOfConst:\n      OS << \"default initialization of a const variable\";\n      break;\n\n    case FK_Incomplete:\n      OS << \"initialization of incomplete type\";\n      break;\n\n    case FK_ListInitializationFailed:\n      OS << \"list initialization checker failure\";\n      break;\n\n    case FK_VariableLengthArrayHasInitializer:\n      OS << \"variable length array has an initializer\";\n      break;\n\n    case FK_PlaceholderType:\n      OS << \"initializer expression isn't contextually valid\";\n      break;\n\n    case FK_ListConstructorOverloadFailed:\n      OS << \"list constructor overloading failed\";\n      break;\n\n    case FK_ExplicitConstructor:\n      OS << \"list copy initialization chose explicit constructor\";\n      break;\n    }\n    OS << '\\n';\n    return;\n  }\n\n  case DependentSequence:\n    OS << \"Dependent sequence\\n\";\n    return;\n\n  case NormalSequence:\n    OS << \"Normal sequence: \";\n    break;\n  }\n\n  for (step_iterator S = step_begin(), SEnd = step_end(); S != SEnd; ++S) {\n    if (S != step_begin()) {\n      OS << \" -> \";\n    }\n\n    switch (S->Kind) {\n    case SK_ResolveAddressOfOverloadedFunction:\n      OS << \"resolve address of overloaded function\";\n      break;\n\n    case SK_CastDerivedToBaseRValue:\n      OS << \"derived-to-base (rvalue)\";\n      break;\n\n    case SK_CastDerivedToBaseXValue:\n      OS << \"derived-to-base (xvalue)\";\n      break;\n\n    case SK_CastDerivedToBaseLValue:\n      OS << \"derived-to-base (lvalue)\";\n      break;\n\n    case SK_BindReference:\n      OS << \"bind reference to lvalue\";\n      break;\n\n    case SK_BindReferenceToTemporary:\n      OS << \"bind reference to a temporary\";\n      break;\n\n    case SK_FinalCopy:\n      OS << \"final copy in class direct-initialization\";\n      break;\n\n    case SK_ExtraneousCopyToTemporary:\n      OS << \"extraneous C++03 copy to temporary\";\n      break;\n\n    case SK_UserConversion:\n      OS << \"user-defined conversion via \" << *S->Function.Function;\n      break;\n\n    case SK_QualificationConversionRValue:\n      OS << \"qualification conversion (rvalue)\";\n      break;\n\n    case SK_QualificationConversionXValue:\n      OS << \"qualification conversion (xvalue)\";\n      break;\n\n    case SK_QualificationConversionLValue:\n      OS << \"qualification conversion (lvalue)\";\n      break;\n\n    case SK_FunctionReferenceConversion:\n      OS << \"function reference conversion\";\n      break;\n\n    case SK_AtomicConversion:\n      OS << \"non-atomic-to-atomic conversion\";\n      break;\n\n    case SK_ConversionSequence:\n      OS << \"implicit conversion sequence (\";\n      S->ICS->dump(); // FIXME: use OS\n      OS << \")\";\n      break;\n\n    case SK_ConversionSequenceNoNarrowing:\n      OS << \"implicit conversion sequence with narrowing prohibited (\";\n      S->ICS->dump(); // FIXME: use OS\n      OS << \")\";\n      break;\n\n    case SK_ListInitialization:\n      OS << \"list aggregate initialization\";\n      break;\n\n    case SK_UnwrapInitList:\n      OS << \"unwrap reference initializer list\";\n      break;\n\n    case SK_RewrapInitList:\n      OS << \"rewrap reference initializer list\";\n      break;\n\n    case SK_ConstructorInitialization:\n      OS << \"constructor initialization\";\n      break;\n\n    case SK_ConstructorInitializationFromList:\n      OS << \"list initialization via constructor\";\n      break;\n\n    case SK_ZeroInitialization:\n      OS << \"zero initialization\";\n      break;\n\n    case SK_CAssignment:\n      OS << \"C assignment\";\n      break;\n\n    case SK_StringInit:\n      OS << \"string initialization\";\n      break;\n\n    case SK_ObjCObjectConversion:\n      OS << \"Objective-C object conversion\";\n      break;\n\n    case SK_ArrayLoopIndex:\n      OS << \"indexing for array initialization loop\";\n      break;\n\n    case SK_ArrayLoopInit:\n      OS << \"array initialization loop\";\n      break;\n\n    case SK_ArrayInit:\n      OS << \"array initialization\";\n      break;\n\n    case SK_GNUArrayInit:\n      OS << \"array initialization (GNU extension)\";\n      break;\n\n    case SK_ParenthesizedArrayInit:\n      OS << \"parenthesized array initialization\";\n      break;\n\n    case SK_PassByIndirectCopyRestore:\n      OS << \"pass by indirect copy and restore\";\n      break;\n\n    case SK_PassByIndirectRestore:\n      OS << \"pass by indirect restore\";\n      break;\n\n    case SK_ProduceObjCObject:\n      OS << \"Objective-C object retension\";\n      break;\n\n    case SK_StdInitializerList:\n      OS << \"std::initializer_list from initializer list\";\n      break;\n\n    case SK_StdInitializerListConstructorCall:\n      OS << \"list initialization from std::initializer_list\";\n      break;\n\n    case SK_OCLSamplerInit:\n      OS << \"OpenCL sampler_t from integer constant\";\n      break;\n\n    case SK_OCLZeroOpaqueType:\n      OS << \"OpenCL opaque type from zero\";\n      break;\n    }\n\n    OS << \" [\" << S->Type.getAsString() << ']';\n  }\n\n  OS << '\\n';\n}\n\nvoid InitializationSequence::dump() const {\n  dump(llvm::errs());\n}\n\nstatic bool NarrowingErrs(const LangOptions &L) {\n  return L.CPlusPlus11 &&\n         (!L.MicrosoftExt || L.isCompatibleWithMSVC(LangOptions::MSVC2015));\n}\n\nstatic void DiagnoseNarrowingInInitList(Sema &S,\n                                        const ImplicitConversionSequence &ICS,\n                                        QualType PreNarrowingType,\n                                        QualType EntityType,\n                                        const Expr *PostInit) {\n  const StandardConversionSequence *SCS = nullptr;\n  switch (ICS.getKind()) {\n  case ImplicitConversionSequence::StandardConversion:\n    SCS = &ICS.Standard;\n    break;\n  case ImplicitConversionSequence::UserDefinedConversion:\n    SCS = &ICS.UserDefined.After;\n    break;\n  case ImplicitConversionSequence::AmbiguousConversion:\n  case ImplicitConversionSequence::EllipsisConversion:\n  case ImplicitConversionSequence::BadConversion:\n    return;\n  }\n\n  // C++11 [dcl.init.list]p7: Check whether this is a narrowing conversion.\n  APValue ConstantValue;\n  QualType ConstantType;\n  switch (SCS->getNarrowingKind(S.Context, PostInit, ConstantValue,\n                                ConstantType)) {\n  case NK_Not_Narrowing:\n  case NK_Dependent_Narrowing:\n    // No narrowing occurred.\n    return;\n\n  case NK_Type_Narrowing:\n    // This was a floating-to-integer conversion, which is always considered a\n    // narrowing conversion even if the value is a constant and can be\n    // represented exactly as an integer.\n    S.Diag(PostInit->getBeginLoc(), NarrowingErrs(S.getLangOpts())\n                                        ? diag::ext_init_list_type_narrowing\n                                        : diag::warn_init_list_type_narrowing)\n        << PostInit->getSourceRange()\n        << PreNarrowingType.getLocalUnqualifiedType()\n        << EntityType.getLocalUnqualifiedType();\n    break;\n\n  case NK_Constant_Narrowing:\n    // A constant value was narrowed.\n    S.Diag(PostInit->getBeginLoc(),\n           NarrowingErrs(S.getLangOpts())\n               ? diag::ext_init_list_constant_narrowing\n               : diag::warn_init_list_constant_narrowing)\n        << PostInit->getSourceRange()\n        << ConstantValue.getAsString(S.getASTContext(), ConstantType)\n        << EntityType.getLocalUnqualifiedType();\n    break;\n\n  case NK_Variable_Narrowing:\n    // A variable's value may have been narrowed.\n    S.Diag(PostInit->getBeginLoc(),\n           NarrowingErrs(S.getLangOpts())\n               ? diag::ext_init_list_variable_narrowing\n               : diag::warn_init_list_variable_narrowing)\n        << PostInit->getSourceRange()\n        << PreNarrowingType.getLocalUnqualifiedType()\n        << EntityType.getLocalUnqualifiedType();\n    break;\n  }\n\n  SmallString<128> StaticCast;\n  llvm::raw_svector_ostream OS(StaticCast);\n  OS << \"static_cast<\";\n  if (const TypedefType *TT = EntityType->getAs<TypedefType>()) {\n    // It's important to use the typedef's name if there is one so that the\n    // fixit doesn't break code using types like int64_t.\n    //\n    // FIXME: This will break if the typedef requires qualification.  But\n    // getQualifiedNameAsString() includes non-machine-parsable components.\n    OS << *TT->getDecl();\n  } else if (const BuiltinType *BT = EntityType->getAs<BuiltinType>())\n    OS << BT->getName(S.getLangOpts());\n  else {\n    // Oops, we didn't find the actual type of the variable.  Don't emit a fixit\n    // with a broken cast.\n    return;\n  }\n  OS << \">(\";\n  S.Diag(PostInit->getBeginLoc(), diag::note_init_list_narrowing_silence)\n      << PostInit->getSourceRange()\n      << FixItHint::CreateInsertion(PostInit->getBeginLoc(), OS.str())\n      << FixItHint::CreateInsertion(\n             S.getLocForEndOfToken(PostInit->getEndLoc()), \")\");\n}\n\n//===----------------------------------------------------------------------===//\n// Initialization helper functions\n//===----------------------------------------------------------------------===//\nbool\nSema::CanPerformCopyInitialization(const InitializedEntity &Entity,\n                                   ExprResult Init) {\n  if (Init.isInvalid())\n    return false;\n\n  Expr *InitE = Init.get();\n  assert(InitE && \"No initialization expression\");\n\n  InitializationKind Kind =\n      InitializationKind::CreateCopy(InitE->getBeginLoc(), SourceLocation());\n  InitializationSequence Seq(*this, Entity, Kind, InitE);\n  return !Seq.Failed();\n}\n\nExprResult\nSema::PerformCopyInitialization(const InitializedEntity &Entity,\n                                SourceLocation EqualLoc,\n                                ExprResult Init,\n                                bool TopLevelOfInitList,\n                                bool AllowExplicit) {\n  if (Init.isInvalid())\n    return ExprError();\n\n  Expr *InitE = Init.get();\n  assert(InitE && \"No initialization expression?\");\n\n  if (EqualLoc.isInvalid())\n    EqualLoc = InitE->getBeginLoc();\n\n  InitializationKind Kind = InitializationKind::CreateCopy(\n      InitE->getBeginLoc(), EqualLoc, AllowExplicit);\n  InitializationSequence Seq(*this, Entity, Kind, InitE, TopLevelOfInitList);\n\n  // Prevent infinite recursion when performing parameter copy-initialization.\n  const bool ShouldTrackCopy =\n      Entity.isParameterKind() && Seq.isConstructorInitialization();\n  if (ShouldTrackCopy) {\n    if (llvm::find(CurrentParameterCopyTypes, Entity.getType()) !=\n        CurrentParameterCopyTypes.end()) {\n      Seq.SetOverloadFailure(\n          InitializationSequence::FK_ConstructorOverloadFailed,\n          OR_No_Viable_Function);\n\n      // Try to give a meaningful diagnostic note for the problematic\n      // constructor.\n      const auto LastStep = Seq.step_end() - 1;\n      assert(LastStep->Kind ==\n             InitializationSequence::SK_ConstructorInitialization);\n      const FunctionDecl *Function = LastStep->Function.Function;\n      auto Candidate =\n          llvm::find_if(Seq.getFailedCandidateSet(),\n                        [Function](const OverloadCandidate &Candidate) -> bool {\n                          return Candidate.Viable &&\n                                 Candidate.Function == Function &&\n                                 Candidate.Conversions.size() > 0;\n                        });\n      if (Candidate != Seq.getFailedCandidateSet().end() &&\n          Function->getNumParams() > 0) {\n        Candidate->Viable = false;\n        Candidate->FailureKind = ovl_fail_bad_conversion;\n        Candidate->Conversions[0].setBad(BadConversionSequence::no_conversion,\n                                         InitE,\n                                         Function->getParamDecl(0)->getType());\n      }\n    }\n    CurrentParameterCopyTypes.push_back(Entity.getType());\n  }\n\n  ExprResult Result = Seq.Perform(*this, Entity, Kind, InitE);\n\n  if (ShouldTrackCopy)\n    CurrentParameterCopyTypes.pop_back();\n\n  return Result;\n}\n\n/// Determine whether RD is, or is derived from, a specialization of CTD.\nstatic bool isOrIsDerivedFromSpecializationOf(CXXRecordDecl *RD,\n                                              ClassTemplateDecl *CTD) {\n  auto NotSpecialization = [&] (const CXXRecordDecl *Candidate) {\n    auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(Candidate);\n    return !CTSD || !declaresSameEntity(CTSD->getSpecializedTemplate(), CTD);\n  };\n  return !(NotSpecialization(RD) && RD->forallBases(NotSpecialization));\n}\n\nQualType Sema::DeduceTemplateSpecializationFromInitializer(\n    TypeSourceInfo *TSInfo, const InitializedEntity &Entity,\n    const InitializationKind &Kind, MultiExprArg Inits) {\n  auto *DeducedTST = dyn_cast<DeducedTemplateSpecializationType>(\n      TSInfo->getType()->getContainedDeducedType());\n  assert(DeducedTST && \"not a deduced template specialization type\");\n\n  auto TemplateName = DeducedTST->getTemplateName();\n  if (TemplateName.isDependent())\n    return SubstAutoType(TSInfo->getType(), Context.DependentTy);\n\n  // We can only perform deduction for class templates.\n  auto *Template =\n      dyn_cast_or_null<ClassTemplateDecl>(TemplateName.getAsTemplateDecl());\n  if (!Template) {\n    Diag(Kind.getLocation(),\n         diag::err_deduced_non_class_template_specialization_type)\n      << (int)getTemplateNameKindForDiagnostics(TemplateName) << TemplateName;\n    if (auto *TD = TemplateName.getAsTemplateDecl())\n      Diag(TD->getLocation(), diag::note_template_decl_here);\n    return QualType();\n  }\n\n  // Can't deduce from dependent arguments.\n  if (Expr::hasAnyTypeDependentArguments(Inits)) {\n    Diag(TSInfo->getTypeLoc().getBeginLoc(),\n         diag::warn_cxx14_compat_class_template_argument_deduction)\n        << TSInfo->getTypeLoc().getSourceRange() << 0;\n    return SubstAutoType(TSInfo->getType(), Context.DependentTy);\n  }\n\n  // FIXME: Perform \"exact type\" matching first, per CWG discussion?\n  //        Or implement this via an implied 'T(T) -> T' deduction guide?\n\n  // FIXME: Do we need/want a std::initializer_list<T> special case?\n\n  // Look up deduction guides, including those synthesized from constructors.\n  //\n  // C++1z [over.match.class.deduct]p1:\n  //   A set of functions and function templates is formed comprising:\n  //   - For each constructor of the class template designated by the\n  //     template-name, a function template [...]\n  //  - For each deduction-guide, a function or function template [...]\n  DeclarationNameInfo NameInfo(\n      Context.DeclarationNames.getCXXDeductionGuideName(Template),\n      TSInfo->getTypeLoc().getEndLoc());\n  LookupResult Guides(*this, NameInfo, LookupOrdinaryName);\n  LookupQualifiedName(Guides, Template->getDeclContext());\n\n  // FIXME: Do not diagnose inaccessible deduction guides. The standard isn't\n  // clear on this, but they're not found by name so access does not apply.\n  Guides.suppressDiagnostics();\n\n  // Figure out if this is list-initialization.\n  InitListExpr *ListInit =\n      (Inits.size() == 1 && Kind.getKind() != InitializationKind::IK_Direct)\n          ? dyn_cast<InitListExpr>(Inits[0])\n          : nullptr;\n\n  // C++1z [over.match.class.deduct]p1:\n  //   Initialization and overload resolution are performed as described in\n  //   [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]\n  //   (as appropriate for the type of initialization performed) for an object\n  //   of a hypothetical class type, where the selected functions and function\n  //   templates are considered to be the constructors of that class type\n  //\n  // Since we know we're initializing a class type of a type unrelated to that\n  // of the initializer, this reduces to something fairly reasonable.\n  OverloadCandidateSet Candidates(Kind.getLocation(),\n                                  OverloadCandidateSet::CSK_Normal);\n  OverloadCandidateSet::iterator Best;\n\n  bool HasAnyDeductionGuide = false;\n  bool AllowExplicit = !Kind.isCopyInit() || ListInit;\n\n  auto tryToResolveOverload =\n      [&](bool OnlyListConstructors) -> OverloadingResult {\n    Candidates.clear(OverloadCandidateSet::CSK_Normal);\n    HasAnyDeductionGuide = false;\n\n    for (auto I = Guides.begin(), E = Guides.end(); I != E; ++I) {\n      NamedDecl *D = (*I)->getUnderlyingDecl();\n      if (D->isInvalidDecl())\n        continue;\n\n      auto *TD = dyn_cast<FunctionTemplateDecl>(D);\n      auto *GD = dyn_cast_or_null<CXXDeductionGuideDecl>(\n          TD ? TD->getTemplatedDecl() : dyn_cast<FunctionDecl>(D));\n      if (!GD)\n        continue;\n\n      if (!GD->isImplicit())\n        HasAnyDeductionGuide = true;\n\n      // C++ [over.match.ctor]p1: (non-list copy-initialization from non-class)\n      //   For copy-initialization, the candidate functions are all the\n      //   converting constructors (12.3.1) of that class.\n      // C++ [over.match.copy]p1: (non-list copy-initialization from class)\n      //   The converting constructors of T are candidate functions.\n      if (!AllowExplicit) {\n        // Overload resolution checks whether the deduction guide is declared\n        // explicit for us.\n\n        // When looking for a converting constructor, deduction guides that\n        // could never be called with one argument are not interesting to\n        // check or note.\n        if (GD->getMinRequiredArguments() > 1 ||\n            (GD->getNumParams() == 0 && !GD->isVariadic()))\n          continue;\n      }\n\n      // C++ [over.match.list]p1.1: (first phase list initialization)\n      //   Initially, the candidate functions are the initializer-list\n      //   constructors of the class T\n      if (OnlyListConstructors && !isInitListConstructor(GD))\n        continue;\n\n      // C++ [over.match.list]p1.2: (second phase list initialization)\n      //   the candidate functions are all the constructors of the class T\n      // C++ [over.match.ctor]p1: (all other cases)\n      //   the candidate functions are all the constructors of the class of\n      //   the object being initialized\n\n      // C++ [over.best.ics]p4:\n      //   When [...] the constructor [...] is a candidate by\n      //    - [over.match.copy] (in all cases)\n      // FIXME: The \"second phase of [over.match.list] case can also\n      // theoretically happen here, but it's not clear whether we can\n      // ever have a parameter of the right type.\n      bool SuppressUserConversions = Kind.isCopyInit();\n\n      if (TD)\n        AddTemplateOverloadCandidate(TD, I.getPair(), /*ExplicitArgs*/ nullptr,\n                                     Inits, Candidates, SuppressUserConversions,\n                                     /*PartialOverloading*/ false,\n                                     AllowExplicit);\n      else\n        AddOverloadCandidate(GD, I.getPair(), Inits, Candidates,\n                             SuppressUserConversions,\n                             /*PartialOverloading*/ false, AllowExplicit);\n    }\n    return Candidates.BestViableFunction(*this, Kind.getLocation(), Best);\n  };\n\n  OverloadingResult Result = OR_No_Viable_Function;\n\n  // C++11 [over.match.list]p1, per DR1467: for list-initialization, first\n  // try initializer-list constructors.\n  if (ListInit) {\n    bool TryListConstructors = true;\n\n    // Try list constructors unless the list is empty and the class has one or\n    // more default constructors, in which case those constructors win.\n    if (!ListInit->getNumInits()) {\n      for (NamedDecl *D : Guides) {\n        auto *FD = dyn_cast<FunctionDecl>(D->getUnderlyingDecl());\n        if (FD && FD->getMinRequiredArguments() == 0) {\n          TryListConstructors = false;\n          break;\n        }\n      }\n    } else if (ListInit->getNumInits() == 1) {\n      // C++ [over.match.class.deduct]:\n      //   As an exception, the first phase in [over.match.list] (considering\n      //   initializer-list constructors) is omitted if the initializer list\n      //   consists of a single expression of type cv U, where U is a\n      //   specialization of C or a class derived from a specialization of C.\n      Expr *E = ListInit->getInit(0);\n      auto *RD = E->getType()->getAsCXXRecordDecl();\n      if (!isa<InitListExpr>(E) && RD &&\n          isCompleteType(Kind.getLocation(), E->getType()) &&\n          isOrIsDerivedFromSpecializationOf(RD, Template))\n        TryListConstructors = false;\n    }\n\n    if (TryListConstructors)\n      Result = tryToResolveOverload(/*OnlyListConstructor*/true);\n    // Then unwrap the initializer list and try again considering all\n    // constructors.\n    Inits = MultiExprArg(ListInit->getInits(), ListInit->getNumInits());\n  }\n\n  // If list-initialization fails, or if we're doing any other kind of\n  // initialization, we (eventually) consider constructors.\n  if (Result == OR_No_Viable_Function)\n    Result = tryToResolveOverload(/*OnlyListConstructor*/false);\n\n  switch (Result) {\n  case OR_Ambiguous:\n    // FIXME: For list-initialization candidates, it'd usually be better to\n    // list why they were not viable when given the initializer list itself as\n    // an argument.\n    Candidates.NoteCandidates(\n        PartialDiagnosticAt(\n            Kind.getLocation(),\n            PDiag(diag::err_deduced_class_template_ctor_ambiguous)\n                << TemplateName),\n        *this, OCD_AmbiguousCandidates, Inits);\n    return QualType();\n\n  case OR_No_Viable_Function: {\n    CXXRecordDecl *Primary =\n        cast<ClassTemplateDecl>(Template)->getTemplatedDecl();\n    bool Complete =\n        isCompleteType(Kind.getLocation(), Context.getTypeDeclType(Primary));\n    Candidates.NoteCandidates(\n        PartialDiagnosticAt(\n            Kind.getLocation(),\n            PDiag(Complete ? diag::err_deduced_class_template_ctor_no_viable\n                           : diag::err_deduced_class_template_incomplete)\n                << TemplateName << !Guides.empty()),\n        *this, OCD_AllCandidates, Inits);\n    return QualType();\n  }\n\n  case OR_Deleted: {\n    Diag(Kind.getLocation(), diag::err_deduced_class_template_deleted)\n      << TemplateName;\n    NoteDeletedFunction(Best->Function);\n    return QualType();\n  }\n\n  case OR_Success:\n    // C++ [over.match.list]p1:\n    //   In copy-list-initialization, if an explicit constructor is chosen, the\n    //   initialization is ill-formed.\n    if (Kind.isCopyInit() && ListInit &&\n        cast<CXXDeductionGuideDecl>(Best->Function)->isExplicit()) {\n      bool IsDeductionGuide = !Best->Function->isImplicit();\n      Diag(Kind.getLocation(), diag::err_deduced_class_template_explicit)\n          << TemplateName << IsDeductionGuide;\n      Diag(Best->Function->getLocation(),\n           diag::note_explicit_ctor_deduction_guide_here)\n          << IsDeductionGuide;\n      return QualType();\n    }\n\n    // Make sure we didn't select an unusable deduction guide, and mark it\n    // as referenced.\n    DiagnoseUseOfDecl(Best->Function, Kind.getLocation());\n    MarkFunctionReferenced(Kind.getLocation(), Best->Function);\n    break;\n  }\n\n  // C++ [dcl.type.class.deduct]p1:\n  //  The placeholder is replaced by the return type of the function selected\n  //  by overload resolution for class template deduction.\n  QualType DeducedType =\n      SubstAutoType(TSInfo->getType(), Best->Function->getReturnType());\n  Diag(TSInfo->getTypeLoc().getBeginLoc(),\n       diag::warn_cxx14_compat_class_template_argument_deduction)\n      << TSInfo->getTypeLoc().getSourceRange() << 1 << DeducedType;\n\n  // Warn if CTAD was used on a type that does not have any user-defined\n  // deduction guides.\n  if (!HasAnyDeductionGuide) {\n    Diag(TSInfo->getTypeLoc().getBeginLoc(),\n         diag::warn_ctad_maybe_unsupported)\n        << TemplateName;\n    Diag(Template->getLocation(), diag::note_suppress_ctad_maybe_unsupported);\n  }\n\n  return DeducedType;\n}\n"}}, "reports": [{"events": [{"location": {"col": 29, "file": 20, "line": 6817}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "6b49f30fed60ec56401991eab61d431b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 20, "line": 6916}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "e66ecfdc0fb18bd3d3500064c10f5833", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 20, "line": 6916}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "4a660b6cf21ac9def3095f0b13977bac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 20, "line": 7034}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "83c037f1a04a8b36645125b5e4eeb77a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 20, "line": 7034}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "bfa44a58a18158cd0c9533e79f5783b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 9945}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "3c4f0a9e7ed95c4a37f37627bac5a5f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 9945}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaInit.cpp", "reportHash": "24c6ef66a59fb4c9655841c81ba30d62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
