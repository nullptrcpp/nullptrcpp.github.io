<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "content": "//===- ExprObjC.h - Classes for representing ObjC expressions ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ExprObjC interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPROBJC_H\n#define LLVM_CLANG_AST_EXPROBJC_H\n\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/SelectorLocationsKind.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace clang {\n\nclass ASTContext;\nclass CXXBaseSpecifier;\n\n/// ObjCStringLiteral, used for Objective-C string literals\n/// i.e. @\"foo\".\nclass ObjCStringLiteral : public Expr {\n  Stmt *String;\n  SourceLocation AtLoc;\n\npublic:\n  ObjCStringLiteral(StringLiteral *SL, QualType T, SourceLocation L)\n      : Expr(ObjCStringLiteralClass, T, VK_RValue, OK_Ordinary), String(SL),\n        AtLoc(L) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCStringLiteral(EmptyShell Empty)\n      : Expr(ObjCStringLiteralClass, Empty) {}\n\n  StringLiteral *getString() { return cast<StringLiteral>(String); }\n  const StringLiteral *getString() const { return cast<StringLiteral>(String); }\n  void setString(StringLiteral *S) { String = S; }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return String->getEndLoc(); }\n\n  // Iterators\n  child_range children() { return child_range(&String, &String+1); }\n\n  const_child_range children() const {\n    return const_child_range(&String, &String + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCStringLiteralClass;\n  }\n};\n\n/// ObjCBoolLiteralExpr - Objective-C Boolean Literal.\nclass ObjCBoolLiteralExpr : public Expr {\n  bool Value;\n  SourceLocation Loc;\n\npublic:\n  ObjCBoolLiteralExpr(bool val, QualType Ty, SourceLocation l)\n      : Expr(ObjCBoolLiteralExprClass, Ty, VK_RValue, OK_Ordinary), Value(val),\n        Loc(l) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCBoolLiteralExpr(EmptyShell Empty)\n      : Expr(ObjCBoolLiteralExprClass, Empty) {}\n\n  bool getValue() const { return Value; }\n  void setValue(bool V) { Value = V; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBoolLiteralExprClass;\n  }\n};\n\n/// ObjCBoxedExpr - used for generalized expression boxing.\n/// as in: @(strdup(\"hello world\")), @(random()) or @(view.frame)\n/// Also used for boxing non-parenthesized numeric literals;\n/// as in: @42 or \\@true (c++/objc++) or \\@__objc_yes (c/objc).\nclass ObjCBoxedExpr : public Expr {\n  Stmt *SubExpr;\n  ObjCMethodDecl *BoxingMethod;\n  SourceRange Range;\n\npublic:\n  friend class ASTStmtReader;\n\n  ObjCBoxedExpr(Expr *E, QualType T, ObjCMethodDecl *method, SourceRange R)\n      : Expr(ObjCBoxedExprClass, T, VK_RValue, OK_Ordinary), SubExpr(E),\n        BoxingMethod(method), Range(R) {\n    setDependence(computeDependence(this));\n  }\n  explicit ObjCBoxedExpr(EmptyShell Empty)\n      : Expr(ObjCBoxedExprClass, Empty) {}\n\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n\n  ObjCMethodDecl *getBoxingMethod() const {\n    return BoxingMethod;\n  }\n\n  // Indicates whether this boxed expression can be emitted as a compile-time\n  // constant.\n  bool isExpressibleAsConstantInitializer() const {\n    return !BoxingMethod && SubExpr;\n  }\n\n  SourceLocation getAtLoc() const { return Range.getBegin(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return Range;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n\n  using const_arg_iterator = ConstExprIterator;\n\n  const_arg_iterator arg_begin() const {\n    return reinterpret_cast<Stmt const * const*>(&SubExpr);\n  }\n\n  const_arg_iterator arg_end() const {\n    return reinterpret_cast<Stmt const * const*>(&SubExpr + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBoxedExprClass;\n  }\n};\n\n/// ObjCArrayLiteral - used for objective-c array containers; as in:\n/// @[@\"Hello\", NSApp, [NSNumber numberWithInt:42]];\nclass ObjCArrayLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCArrayLiteral, Expr *> {\n  unsigned NumElements;\n  SourceRange Range;\n  ObjCMethodDecl *ArrayWithObjectsMethod;\n\n  ObjCArrayLiteral(ArrayRef<Expr *> Elements,\n                   QualType T, ObjCMethodDecl * Method,\n                   SourceRange SR);\n\n  explicit ObjCArrayLiteral(EmptyShell Empty, unsigned NumElements)\n      : Expr(ObjCArrayLiteralClass, Empty), NumElements(NumElements) {}\n\npublic:\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  static ObjCArrayLiteral *Create(const ASTContext &C,\n                                  ArrayRef<Expr *> Elements,\n                                  QualType T, ObjCMethodDecl * Method,\n                                  SourceRange SR);\n\n  static ObjCArrayLiteral *CreateEmpty(const ASTContext &C,\n                                       unsigned NumElements);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  /// Retrieve elements of array of literals.\n  Expr **getElements() { return getTrailingObjects<Expr *>(); }\n\n  /// Retrieve elements of array of literals.\n  const Expr * const *getElements() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  /// getNumElements - Return number of elements of objective-c array literal.\n  unsigned getNumElements() const { return NumElements; }\n\n  /// getElement - Return the Element at the specified index.\n  Expr *getElement(unsigned Index) {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    return getElements()[Index];\n  }\n  const Expr *getElement(unsigned Index) const {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    return getElements()[Index];\n  }\n\n  ObjCMethodDecl *getArrayWithObjectsMethod() const {\n    return ArrayWithObjectsMethod;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(getElements()),\n                       reinterpret_cast<Stmt **>(getElements()) + NumElements);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCArrayLiteral *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n      return T->getStmtClass() == ObjCArrayLiteralClass;\n  }\n};\n\n/// An element in an Objective-C dictionary literal.\n///\nstruct ObjCDictionaryElement {\n  /// The key for the dictionary element.\n  Expr *Key;\n\n  /// The value of the dictionary element.\n  Expr *Value;\n\n  /// The location of the ellipsis, if this is a pack expansion.\n  SourceLocation EllipsisLoc;\n\n  /// The number of elements this pack expansion will expand to, if\n  /// this is a pack expansion and is known.\n  Optional<unsigned> NumExpansions;\n\n  /// Determines whether this dictionary element is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n};\n\n} // namespace clang\n\nnamespace clang {\n\n/// Internal struct for storing Key/value pair.\nstruct ObjCDictionaryLiteral_KeyValuePair {\n  Expr *Key;\n  Expr *Value;\n};\n\n/// Internal struct to describes an element that is a pack\n/// expansion, used if any of the elements in the dictionary literal\n/// are pack expansions.\nstruct ObjCDictionaryLiteral_ExpansionData {\n  /// The location of the ellipsis, if this element is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// If non-zero, the number of elements that this pack\n  /// expansion will expand to (+1).\n  unsigned NumExpansionsPlusOne;\n};\n\n/// ObjCDictionaryLiteral - AST node to represent objective-c dictionary\n/// literals; as in:  @{@\"name\" : NSUserName(), @\"date\" : [NSDate date] };\nclass ObjCDictionaryLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCDictionaryLiteral,\n                                    ObjCDictionaryLiteral_KeyValuePair,\n                                    ObjCDictionaryLiteral_ExpansionData> {\n  /// The number of elements in this dictionary literal.\n  unsigned NumElements : 31;\n\n  /// Determine whether this dictionary literal has any pack expansions.\n  ///\n  /// If the dictionary literal has pack expansions, then there will\n  /// be an array of pack expansion data following the array of\n  /// key/value pairs, which provide the locations of the ellipses (if\n  /// any) and number of elements in the expansion (if known). If\n  /// there are no pack expansions, we optimize away this storage.\n  unsigned HasPackExpansions : 1;\n\n  SourceRange Range;\n  ObjCMethodDecl *DictWithObjectsMethod;\n\n  using KeyValuePair = ObjCDictionaryLiteral_KeyValuePair;\n  using ExpansionData = ObjCDictionaryLiteral_ExpansionData;\n\n  ObjCDictionaryLiteral(ArrayRef<ObjCDictionaryElement> VK,\n                        bool HasPackExpansions,\n                        QualType T, ObjCMethodDecl *method,\n                        SourceRange SR);\n\n  explicit ObjCDictionaryLiteral(EmptyShell Empty, unsigned NumElements,\n                                 bool HasPackExpansions)\n      : Expr(ObjCDictionaryLiteralClass, Empty), NumElements(NumElements),\n        HasPackExpansions(HasPackExpansions) {}\n\n  size_t numTrailingObjects(OverloadToken<KeyValuePair>) const {\n    return NumElements;\n  }\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  static ObjCDictionaryLiteral *Create(const ASTContext &C,\n                                       ArrayRef<ObjCDictionaryElement> VK,\n                                       bool HasPackExpansions,\n                                       QualType T, ObjCMethodDecl *method,\n                                       SourceRange SR);\n\n  static ObjCDictionaryLiteral *CreateEmpty(const ASTContext &C,\n                                            unsigned NumElements,\n                                            bool HasPackExpansions);\n\n  /// getNumElements - Return number of elements of objective-c dictionary\n  /// literal.\n  unsigned getNumElements() const { return NumElements; }\n\n  ObjCDictionaryElement getKeyValueElement(unsigned Index) const {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    const KeyValuePair &KV = getTrailingObjects<KeyValuePair>()[Index];\n    ObjCDictionaryElement Result = { KV.Key, KV.Value, SourceLocation(), None };\n    if (HasPackExpansions) {\n      const ExpansionData &Expansion =\n          getTrailingObjects<ExpansionData>()[Index];\n      Result.EllipsisLoc = Expansion.EllipsisLoc;\n      if (Expansion.NumExpansionsPlusOne > 0)\n        Result.NumExpansions = Expansion.NumExpansionsPlusOne - 1;\n    }\n    return Result;\n  }\n\n  ObjCMethodDecl *getDictWithObjectsMethod() const {\n    return DictWithObjectsMethod;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  // Iterators\n  child_range children() {\n    // Note: we're taking advantage of the layout of the KeyValuePair struct\n    // here. If that struct changes, this code will need to change as well.\n    static_assert(sizeof(KeyValuePair) == sizeof(Stmt *) * 2,\n                  \"KeyValuePair is expected size\");\n    return child_range(\n        reinterpret_cast<Stmt **>(getTrailingObjects<KeyValuePair>()),\n        reinterpret_cast<Stmt **>(getTrailingObjects<KeyValuePair>()) +\n            NumElements * 2);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCDictionaryLiteral *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCDictionaryLiteralClass;\n  }\n};\n\n/// ObjCEncodeExpr, used for \\@encode in Objective-C.  \\@encode has the same\n/// type and behavior as StringLiteral except that the string initializer is\n/// obtained from ASTContext with the encoding type as an argument.\nclass ObjCEncodeExpr : public Expr {\n  TypeSourceInfo *EncodedType;\n  SourceLocation AtLoc, RParenLoc;\n\npublic:\n  ObjCEncodeExpr(QualType T, TypeSourceInfo *EncodedType, SourceLocation at,\n                 SourceLocation rp)\n      : Expr(ObjCEncodeExprClass, T, VK_LValue, OK_Ordinary),\n        EncodedType(EncodedType), AtLoc(at), RParenLoc(rp) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCEncodeExpr(EmptyShell Empty) : Expr(ObjCEncodeExprClass, Empty){}\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  QualType getEncodedType() const { return EncodedType->getType(); }\n\n  TypeSourceInfo *getEncodedTypeSourceInfo() const { return EncodedType; }\n\n  void setEncodedTypeSourceInfo(TypeSourceInfo *EncType) {\n    EncodedType = EncType;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCEncodeExprClass;\n  }\n};\n\n/// ObjCSelectorExpr used for \\@selector in Objective-C.\nclass ObjCSelectorExpr : public Expr {\n  Selector SelName;\n  SourceLocation AtLoc, RParenLoc;\n\npublic:\n  ObjCSelectorExpr(QualType T, Selector selInfo, SourceLocation at,\n                   SourceLocation rp)\n      : Expr(ObjCSelectorExprClass, T, VK_RValue, OK_Ordinary),\n        SelName(selInfo), AtLoc(at), RParenLoc(rp) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCSelectorExpr(EmptyShell Empty)\n      : Expr(ObjCSelectorExprClass, Empty) {}\n\n  Selector getSelector() const { return SelName; }\n  void setSelector(Selector S) { SelName = S; }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return SelName.getNumArgs(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCSelectorExprClass;\n  }\n};\n\n/// ObjCProtocolExpr used for protocol expression in Objective-C.\n///\n/// This is used as: \\@protocol(foo), as in:\n/// \\code\n///   [obj conformsToProtocol:@protocol(foo)]\n/// \\endcode\n///\n/// The return type is \"Protocol*\".\nclass ObjCProtocolExpr : public Expr {\n  ObjCProtocolDecl *TheProtocol;\n  SourceLocation AtLoc, ProtoLoc, RParenLoc;\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  ObjCProtocolExpr(QualType T, ObjCProtocolDecl *protocol, SourceLocation at,\n                   SourceLocation protoLoc, SourceLocation rp)\n      : Expr(ObjCProtocolExprClass, T, VK_RValue, OK_Ordinary),\n        TheProtocol(protocol), AtLoc(at), ProtoLoc(protoLoc), RParenLoc(rp) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCProtocolExpr(EmptyShell Empty)\n      : Expr(ObjCProtocolExprClass, Empty) {}\n\n  ObjCProtocolDecl *getProtocol() const { return TheProtocol; }\n  void setProtocol(ObjCProtocolDecl *P) { TheProtocol = P; }\n\n  SourceLocation getProtocolIdLoc() const { return ProtoLoc; }\n  SourceLocation getAtLoc() const { return AtLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCProtocolExprClass;\n  }\n};\n\n/// ObjCIvarRefExpr - A reference to an ObjC instance variable.\nclass ObjCIvarRefExpr : public Expr {\n  ObjCIvarDecl *D;\n  Stmt *Base;\n  SourceLocation Loc;\n\n  /// OpLoc - This is the location of '.' or '->'\n  SourceLocation OpLoc;\n\n  // True if this is \"X->F\", false if this is \"X.F\".\n  bool IsArrow : 1;\n\n  // True if ivar reference has no base (self assumed).\n  bool IsFreeIvar : 1;\n\npublic:\n  ObjCIvarRefExpr(ObjCIvarDecl *d, QualType t, SourceLocation l,\n                  SourceLocation oploc, Expr *base, bool arrow = false,\n                  bool freeIvar = false)\n      : Expr(ObjCIvarRefExprClass, t, VK_LValue,\n             d->isBitField() ? OK_BitField : OK_Ordinary),\n        D(d), Base(base), Loc(l), OpLoc(oploc), IsArrow(arrow),\n        IsFreeIvar(freeIvar) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCIvarRefExpr(EmptyShell Empty)\n      : Expr(ObjCIvarRefExprClass, Empty) {}\n\n  ObjCIvarDecl *getDecl() { return D; }\n  const ObjCIvarDecl *getDecl() const { return D; }\n  void setDecl(ObjCIvarDecl *d) { D = d; }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr * base) { Base = base; }\n\n  bool isArrow() const { return IsArrow; }\n  bool isFreeIvar() const { return IsFreeIvar; }\n  void setIsArrow(bool A) { IsArrow = A; }\n  void setIsFreeIvar(bool A) { IsFreeIvar = A; }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isFreeIvar() ? Loc : getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  SourceLocation getOpLoc() const { return OpLoc; }\n  void setOpLoc(SourceLocation L) { OpLoc = L; }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCIvarRefExprClass;\n  }\n};\n\n/// ObjCPropertyRefExpr - A dot-syntax expression to access an ObjC\n/// property.\nclass ObjCPropertyRefExpr : public Expr {\nprivate:\n  /// If the bool is true, this is an implicit property reference; the\n  /// pointer is an (optional) ObjCMethodDecl and Setter may be set.\n  /// if the bool is false, this is an explicit property reference;\n  /// the pointer is an ObjCPropertyDecl and Setter is always null.\n  llvm::PointerIntPair<NamedDecl *, 1, bool> PropertyOrGetter;\n\n  /// Indicates whether the property reference will result in a message\n  /// to the getter, the setter, or both.\n  /// This applies to both implicit and explicit property references.\n  enum MethodRefFlags {\n    MethodRef_None = 0,\n    MethodRef_Getter = 0x1,\n    MethodRef_Setter = 0x2\n  };\n\n  /// Contains the Setter method pointer and MethodRefFlags bit flags.\n  llvm::PointerIntPair<ObjCMethodDecl *, 2, unsigned> SetterAndMethodRefFlags;\n\n  // FIXME: Maybe we should store the property identifier here,\n  // because it's not rederivable from the other data when there's an\n  // implicit property with no getter (because the 'foo' -> 'setFoo:'\n  // transformation is lossy on the first character).\n\n  SourceLocation IdLoc;\n\n  /// When the receiver in property access is 'super', this is\n  /// the location of the 'super' keyword.  When it's an interface,\n  /// this is that interface.\n  SourceLocation ReceiverLoc;\n  llvm::PointerUnion<Stmt *, const Type *, ObjCInterfaceDecl *> Receiver;\n\npublic:\n  ObjCPropertyRefExpr(ObjCPropertyDecl *PD, QualType t, ExprValueKind VK,\n                      ExprObjectKind OK, SourceLocation l, Expr *base)\n      : Expr(ObjCPropertyRefExprClass, t, VK, OK), PropertyOrGetter(PD, false),\n        IdLoc(l), Receiver(base) {\n    assert(t->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCPropertyDecl *PD, QualType t, ExprValueKind VK,\n                      ExprObjectKind OK, SourceLocation l, SourceLocation sl,\n                      QualType st)\n      : Expr(ObjCPropertyRefExprClass, t, VK, OK), PropertyOrGetter(PD, false),\n        IdLoc(l), ReceiverLoc(sl), Receiver(st.getTypePtr()) {\n    assert(t->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, Expr *Base)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), Receiver(Base) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, SourceLocation SuperLoc,\n                      QualType SuperTy)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), ReceiverLoc(SuperLoc), Receiver(SuperTy.getTypePtr()) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, SourceLocation ReceiverLoc,\n                      ObjCInterfaceDecl *Receiver)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), ReceiverLoc(ReceiverLoc), Receiver(Receiver) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCPropertyRefExpr(EmptyShell Empty)\n      : Expr(ObjCPropertyRefExprClass, Empty) {}\n\n  bool isImplicitProperty() const { return PropertyOrGetter.getInt(); }\n  bool isExplicitProperty() const { return !PropertyOrGetter.getInt(); }\n\n  ObjCPropertyDecl *getExplicitProperty() const {\n    assert(!isImplicitProperty());\n    return cast<ObjCPropertyDecl>(PropertyOrGetter.getPointer());\n  }\n\n  ObjCMethodDecl *getImplicitPropertyGetter() const {\n    assert(isImplicitProperty());\n    return cast_or_null<ObjCMethodDecl>(PropertyOrGetter.getPointer());\n  }\n\n  ObjCMethodDecl *getImplicitPropertySetter() const {\n    assert(isImplicitProperty());\n    return SetterAndMethodRefFlags.getPointer();\n  }\n\n  Selector getGetterSelector() const {\n    if (isImplicitProperty())\n      return getImplicitPropertyGetter()->getSelector();\n    return getExplicitProperty()->getGetterName();\n  }\n\n  Selector getSetterSelector() const {\n    if (isImplicitProperty())\n      return getImplicitPropertySetter()->getSelector();\n    return getExplicitProperty()->getSetterName();\n  }\n\n  /// True if the property reference will result in a message to the\n  /// getter.\n  /// This applies to both implicit and explicit property references.\n  bool isMessagingGetter() const {\n    return SetterAndMethodRefFlags.getInt() & MethodRef_Getter;\n  }\n\n  /// True if the property reference will result in a message to the\n  /// setter.\n  /// This applies to both implicit and explicit property references.\n  bool isMessagingSetter() const {\n    return SetterAndMethodRefFlags.getInt() & MethodRef_Setter;\n  }\n\n  void setIsMessagingGetter(bool val = true) {\n    setMethodRefFlag(MethodRef_Getter, val);\n  }\n\n  void setIsMessagingSetter(bool val = true) {\n    setMethodRefFlag(MethodRef_Setter, val);\n  }\n\n  const Expr *getBase() const {\n    return cast<Expr>(Receiver.get<Stmt*>());\n  }\n  Expr *getBase() {\n    return cast<Expr>(Receiver.get<Stmt*>());\n  }\n\n  SourceLocation getLocation() const { return IdLoc; }\n\n  SourceLocation getReceiverLocation() const { return ReceiverLoc; }\n\n  QualType getSuperReceiverType() const {\n    return QualType(Receiver.get<const Type*>(), 0);\n  }\n\n  ObjCInterfaceDecl *getClassReceiver() const {\n    return Receiver.get<ObjCInterfaceDecl*>();\n  }\n\n  bool isObjectReceiver() const { return Receiver.is<Stmt*>(); }\n  bool isSuperReceiver() const { return Receiver.is<const Type*>(); }\n  bool isClassReceiver() const { return Receiver.is<ObjCInterfaceDecl*>(); }\n\n  /// Determine the type of the base, regardless of the kind of receiver.\n  QualType getReceiverType(const ASTContext &ctx) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isObjectReceiver() ? getBase()->getBeginLoc()\n                              : getReceiverLocation();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return IdLoc; }\n\n  // Iterators\n  child_range children() {\n    if (Receiver.is<Stmt*>()) {\n      Stmt **begin = reinterpret_cast<Stmt**>(&Receiver); // hack!\n      return child_range(begin, begin+1);\n    }\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCPropertyRefExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCPropertyRefExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  void setExplicitProperty(ObjCPropertyDecl *D, unsigned methRefFlags) {\n    PropertyOrGetter.setPointer(D);\n    PropertyOrGetter.setInt(false);\n    SetterAndMethodRefFlags.setPointer(nullptr);\n    SetterAndMethodRefFlags.setInt(methRefFlags);\n  }\n\n  void setImplicitProperty(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                           unsigned methRefFlags) {\n    PropertyOrGetter.setPointer(Getter);\n    PropertyOrGetter.setInt(true);\n    SetterAndMethodRefFlags.setPointer(Setter);\n    SetterAndMethodRefFlags.setInt(methRefFlags);\n  }\n\n  void setBase(Expr *Base) { Receiver = Base; }\n  void setSuperReceiver(QualType T) { Receiver = T.getTypePtr(); }\n  void setClassReceiver(ObjCInterfaceDecl *D) { Receiver = D; }\n\n  void setLocation(SourceLocation L) { IdLoc = L; }\n  void setReceiverLocation(SourceLocation Loc) { ReceiverLoc = Loc; }\n\n  void setMethodRefFlag(MethodRefFlags flag, bool val) {\n    unsigned f = SetterAndMethodRefFlags.getInt();\n    if (val)\n      f |= flag;\n    else\n      f &= ~flag;\n    SetterAndMethodRefFlags.setInt(f);\n  }\n};\n\n/// ObjCSubscriptRefExpr - used for array and dictionary subscripting.\n/// array[4] = array[3]; dictionary[key] = dictionary[alt_key];\nclass ObjCSubscriptRefExpr : public Expr {\n  // Location of ']' in an indexing expression.\n  SourceLocation RBracket;\n\n  // array/dictionary base expression.\n  // for arrays, this is a numeric expression. For dictionaries, this is\n  // an objective-c object pointer expression.\n  enum { BASE, KEY, END_EXPR };\n  Stmt* SubExprs[END_EXPR];\n\n  ObjCMethodDecl *GetAtIndexMethodDecl;\n\n  // For immutable objects this is null. When ObjCSubscriptRefExpr is to read\n  // an indexed object this is null too.\n  ObjCMethodDecl *SetAtIndexMethodDecl;\n\npublic:\n  ObjCSubscriptRefExpr(Expr *base, Expr *key, QualType T, ExprValueKind VK,\n                       ExprObjectKind OK, ObjCMethodDecl *getMethod,\n                       ObjCMethodDecl *setMethod, SourceLocation RB)\n      : Expr(ObjCSubscriptRefExprClass, T, VK, OK), RBracket(RB),\n        GetAtIndexMethodDecl(getMethod), SetAtIndexMethodDecl(setMethod) {\n    SubExprs[BASE] = base;\n    SubExprs[KEY] = key;\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCSubscriptRefExpr(EmptyShell Empty)\n      : Expr(ObjCSubscriptRefExprClass, Empty) {}\n\n  SourceLocation getRBracket() const { return RBracket; }\n  void setRBracket(SourceLocation RB) { RBracket = RB; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExprs[BASE]->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracket; }\n\n  Expr *getBaseExpr() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBaseExpr(Stmt *S) { SubExprs[BASE] = S; }\n\n  Expr *getKeyExpr() const { return cast<Expr>(SubExprs[KEY]); }\n  void setKeyExpr(Stmt *S) { SubExprs[KEY] = S; }\n\n  ObjCMethodDecl *getAtIndexMethodDecl() const {\n    return GetAtIndexMethodDecl;\n  }\n\n  ObjCMethodDecl *setAtIndexMethodDecl() const {\n    return SetAtIndexMethodDecl;\n  }\n\n  bool isArraySubscriptRefExpr() const {\n    return getKeyExpr()->getType()->isIntegralOrEnumerationType();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + END_EXPR);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCSubscriptRefExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// An expression that sends a message to the given Objective-C\n/// object or class.\n///\n/// The following contains two message send expressions:\n///\n/// \\code\n///   [[NSString alloc] initWithString:@\"Hello\"]\n/// \\endcode\n///\n/// The innermost message send invokes the \"alloc\" class method on the\n/// NSString class, while the outermost message send invokes the\n/// \"initWithString\" instance method on the object returned from\n/// NSString's \"alloc\". In all, an Objective-C message send can take\n/// on four different (although related) forms:\n///\n///   1. Send to an object instance.\n///   2. Send to a class.\n///   3. Send to the superclass instance of the current class.\n///   4. Send to the superclass of the current class.\n///\n/// All four kinds of message sends are modeled by the ObjCMessageExpr\n/// class, and can be distinguished via \\c getReceiverKind(). Example:\n///\n/// The \"void *\" trailing objects are actually ONE void * (the\n/// receiver pointer), and NumArgs Expr *. But due to the\n/// implementation of children(), these must be together contiguously.\nclass ObjCMessageExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCMessageExpr, void *, SourceLocation> {\n  /// Stores either the selector that this message is sending\n  /// to (when \\c HasMethod is zero) or an \\c ObjCMethodDecl pointer\n  /// referring to the method that we type-checked against.\n  uintptr_t SelectorOrMethod = 0;\n\n  enum { NumArgsBitWidth = 16 };\n\n  /// The number of arguments in the message send, not\n  /// including the receiver.\n  unsigned NumArgs : NumArgsBitWidth;\n\n  /// The kind of message send this is, which is one of the\n  /// ReceiverKind values.\n  ///\n  /// We pad this out to a byte to avoid excessive masking and shifting.\n  unsigned Kind : 8;\n\n  /// Whether we have an actual method prototype in \\c\n  /// SelectorOrMethod.\n  ///\n  /// When non-zero, we have a method declaration; otherwise, we just\n  /// have a selector.\n  unsigned HasMethod : 1;\n\n  /// Whether this message send is a \"delegate init call\",\n  /// i.e. a call of an init method on self from within an init method.\n  unsigned IsDelegateInitCall : 1;\n\n  /// Whether this message send was implicitly generated by\n  /// the implementation rather than explicitly written by the user.\n  unsigned IsImplicit : 1;\n\n  /// Whether the locations of the selector identifiers are in a\n  /// \"standard\" position, a enum SelectorLocationsKind.\n  unsigned SelLocsKind : 2;\n\n  /// When the message expression is a send to 'super', this is\n  /// the location of the 'super' keyword.\n  SourceLocation SuperLoc;\n\n  /// The source locations of the open and close square\n  /// brackets ('[' and ']', respectively).\n  SourceLocation LBracLoc, RBracLoc;\n\n  ObjCMessageExpr(EmptyShell Empty, unsigned NumArgs)\n      : Expr(ObjCMessageExprClass, Empty), Kind(0), HasMethod(false),\n        IsDelegateInitCall(false), IsImplicit(false), SelLocsKind(0) {\n    setNumArgs(NumArgs);\n  }\n\n  ObjCMessageExpr(QualType T, ExprValueKind VK,\n                  SourceLocation LBracLoc,\n                  SourceLocation SuperLoc,\n                  bool IsInstanceSuper,\n                  QualType SuperType,\n                  Selector Sel,\n                  ArrayRef<SourceLocation> SelLocs,\n                  SelectorLocationsKind SelLocsK,\n                  ObjCMethodDecl *Method,\n                  ArrayRef<Expr *> Args,\n                  SourceLocation RBracLoc,\n                  bool isImplicit);\n  ObjCMessageExpr(QualType T, ExprValueKind VK,\n                  SourceLocation LBracLoc,\n                  TypeSourceInfo *Receiver,\n                  Selector Sel,\n                  ArrayRef<SourceLocation> SelLocs,\n                  SelectorLocationsKind SelLocsK,\n                  ObjCMethodDecl *Method,\n                  ArrayRef<Expr *> Args,\n                  SourceLocation RBracLoc,\n                  bool isImplicit);\n  ObjCMessageExpr(QualType T, ExprValueKind VK,\n                  SourceLocation LBracLoc,\n                  Expr *Receiver,\n                  Selector Sel,\n                  ArrayRef<SourceLocation> SelLocs,\n                  SelectorLocationsKind SelLocsK,\n                  ObjCMethodDecl *Method,\n                  ArrayRef<Expr *> Args,\n                  SourceLocation RBracLoc,\n                  bool isImplicit);\n\n  size_t numTrailingObjects(OverloadToken<void *>) const { return NumArgs + 1; }\n\n  void setNumArgs(unsigned Num) {\n    assert((Num >> NumArgsBitWidth) == 0 && \"Num of args is out of range!\");\n    NumArgs = Num;\n  }\n\n  void initArgsAndSelLocs(ArrayRef<Expr *> Args,\n                          ArrayRef<SourceLocation> SelLocs,\n                          SelectorLocationsKind SelLocsK);\n\n  /// Retrieve the pointer value of the message receiver.\n  void *getReceiverPointer() const { return *getTrailingObjects<void *>(); }\n\n  /// Set the pointer value of the message receiver.\n  void setReceiverPointer(void *Value) {\n    *getTrailingObjects<void *>() = Value;\n  }\n\n  SelectorLocationsKind getSelLocsKind() const {\n    return (SelectorLocationsKind)SelLocsKind;\n  }\n\n  bool hasStandardSelLocs() const {\n    return getSelLocsKind() != SelLoc_NonStandard;\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  SourceLocation *getStoredSelLocs() {\n    return getTrailingObjects<SourceLocation>();\n  }\n  const SourceLocation *getStoredSelLocs() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  /// Get the number of stored selector identifiers locations.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  unsigned getNumStoredSelLocs() const {\n    if (hasStandardSelLocs())\n      return 0;\n    return getNumSelectorLocs();\n  }\n\n  static ObjCMessageExpr *alloc(const ASTContext &C,\n                                ArrayRef<Expr *> Args,\n                                SourceLocation RBraceLoc,\n                                ArrayRef<SourceLocation> SelLocs,\n                                Selector Sel,\n                                SelectorLocationsKind &SelLocsK);\n  static ObjCMessageExpr *alloc(const ASTContext &C,\n                                unsigned NumArgs,\n                                unsigned NumStoredSelLocs);\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The kind of receiver this message is sending to.\n  enum ReceiverKind {\n    /// The receiver is a class.\n    Class = 0,\n\n    /// The receiver is an object instance.\n    Instance,\n\n    /// The receiver is a superclass.\n    SuperClass,\n\n    /// The receiver is the instance of the superclass object.\n    SuperInstance\n  };\n\n  /// Create a message send to super.\n  ///\n  /// \\param Context The ASTContext in which this expression will be created.\n  ///\n  /// \\param T The result type of this message.\n  ///\n  /// \\param VK The value kind of this message.  A message returning\n  /// a l-value or r-value reference will be an l-value or x-value,\n  /// respectively.\n  ///\n  /// \\param LBracLoc The location of the open square bracket '['.\n  ///\n  /// \\param SuperLoc The location of the \"super\" keyword.\n  ///\n  /// \\param IsInstanceSuper Whether this is an instance \"super\"\n  /// message (otherwise, it's a class \"super\" message).\n  ///\n  /// \\param Sel The selector used to determine which method gets called.\n  ///\n  /// \\param Method The Objective-C method against which this message\n  /// send was type-checked. May be nullptr.\n  ///\n  /// \\param Args The message send arguments.\n  ///\n  /// \\param RBracLoc The location of the closing square bracket ']'.\n  static ObjCMessageExpr *Create(const ASTContext &Context, QualType T,\n                                 ExprValueKind VK,\n                                 SourceLocation LBracLoc,\n                                 SourceLocation SuperLoc,\n                                 bool IsInstanceSuper,\n                                 QualType SuperType,\n                                 Selector Sel,\n                                 ArrayRef<SourceLocation> SelLocs,\n                                 ObjCMethodDecl *Method,\n                                 ArrayRef<Expr *> Args,\n                                 SourceLocation RBracLoc,\n                                 bool isImplicit);\n\n  /// Create a class message send.\n  ///\n  /// \\param Context The ASTContext in which this expression will be created.\n  ///\n  /// \\param T The result type of this message.\n  ///\n  /// \\param VK The value kind of this message.  A message returning\n  /// a l-value or r-value reference will be an l-value or x-value,\n  /// respectively.\n  ///\n  /// \\param LBracLoc The location of the open square bracket '['.\n  ///\n  /// \\param Receiver The type of the receiver, including\n  /// source-location information.\n  ///\n  /// \\param Sel The selector used to determine which method gets called.\n  ///\n  /// \\param Method The Objective-C method against which this message\n  /// send was type-checked. May be nullptr.\n  ///\n  /// \\param Args The message send arguments.\n  ///\n  /// \\param RBracLoc The location of the closing square bracket ']'.\n  static ObjCMessageExpr *Create(const ASTContext &Context, QualType T,\n                                 ExprValueKind VK,\n                                 SourceLocation LBracLoc,\n                                 TypeSourceInfo *Receiver,\n                                 Selector Sel,\n                                 ArrayRef<SourceLocation> SelLocs,\n                                 ObjCMethodDecl *Method,\n                                 ArrayRef<Expr *> Args,\n                                 SourceLocation RBracLoc,\n                                 bool isImplicit);\n\n  /// Create an instance message send.\n  ///\n  /// \\param Context The ASTContext in which this expression will be created.\n  ///\n  /// \\param T The result type of this message.\n  ///\n  /// \\param VK The value kind of this message.  A message returning\n  /// a l-value or r-value reference will be an l-value or x-value,\n  /// respectively.\n  ///\n  /// \\param LBracLoc The location of the open square bracket '['.\n  ///\n  /// \\param Receiver The expression used to produce the object that\n  /// will receive this message.\n  ///\n  /// \\param Sel The selector used to determine which method gets called.\n  ///\n  /// \\param Method The Objective-C method against which this message\n  /// send was type-checked. May be nullptr.\n  ///\n  /// \\param Args The message send arguments.\n  ///\n  /// \\param RBracLoc The location of the closing square bracket ']'.\n  static ObjCMessageExpr *Create(const ASTContext &Context, QualType T,\n                                 ExprValueKind VK,\n                                 SourceLocation LBracLoc,\n                                 Expr *Receiver,\n                                 Selector Sel,\n                                 ArrayRef<SourceLocation> SeLocs,\n                                 ObjCMethodDecl *Method,\n                                 ArrayRef<Expr *> Args,\n                                 SourceLocation RBracLoc,\n                                 bool isImplicit);\n\n  /// Create an empty Objective-C message expression, to be\n  /// filled in by subsequent calls.\n  ///\n  /// \\param Context The context in which the message send will be created.\n  ///\n  /// \\param NumArgs The number of message arguments, not including\n  /// the receiver.\n  static ObjCMessageExpr *CreateEmpty(const ASTContext &Context,\n                                      unsigned NumArgs,\n                                      unsigned NumStoredSelLocs);\n\n  /// Indicates whether the message send was implicitly\n  /// generated by the implementation. If false, it was written explicitly\n  /// in the source code.\n  bool isImplicit() const { return IsImplicit; }\n\n  /// Determine the kind of receiver that this message is being\n  /// sent to.\n  ReceiverKind getReceiverKind() const { return (ReceiverKind)Kind; }\n\n  /// \\return the return type of the message being sent.\n  /// This is not always the type of the message expression itself because\n  /// of references (the expression would not have a reference type).\n  /// It is also not always the declared return type of the method because\n  /// of `instancetype` (in that case it's an expression type).\n  QualType getCallReturnType(ASTContext &Ctx) const;\n\n  /// Source range of the receiver.\n  SourceRange getReceiverRange() const;\n\n  /// Determine whether this is an instance message to either a\n  /// computed object or to super.\n  bool isInstanceMessage() const {\n    return getReceiverKind() == Instance || getReceiverKind() == SuperInstance;\n  }\n\n  /// Determine whether this is an class message to either a\n  /// specified class or to super.\n  bool isClassMessage() const {\n    return getReceiverKind() == Class || getReceiverKind() == SuperClass;\n  }\n\n  /// Returns the object expression (receiver) for an instance message,\n  /// or null for a message that is not an instance message.\n  Expr *getInstanceReceiver() {\n    if (getReceiverKind() == Instance)\n      return static_cast<Expr *>(getReceiverPointer());\n\n    return nullptr;\n  }\n  const Expr *getInstanceReceiver() const {\n    return const_cast<ObjCMessageExpr*>(this)->getInstanceReceiver();\n  }\n\n  /// Turn this message send into an instance message that\n  /// computes the receiver object with the given expression.\n  void setInstanceReceiver(Expr *rec) {\n    Kind = Instance;\n    setReceiverPointer(rec);\n  }\n\n  /// Returns the type of a class message send, or NULL if the\n  /// message is not a class message.\n  QualType getClassReceiver() const {\n    if (TypeSourceInfo *TSInfo = getClassReceiverTypeInfo())\n      return TSInfo->getType();\n\n    return {};\n  }\n\n  /// Returns a type-source information of a class message\n  /// send, or nullptr if the message is not a class message.\n  TypeSourceInfo *getClassReceiverTypeInfo() const {\n    if (getReceiverKind() == Class)\n      return reinterpret_cast<TypeSourceInfo *>(getReceiverPointer());\n    return nullptr;\n  }\n\n  void setClassReceiver(TypeSourceInfo *TSInfo) {\n    Kind = Class;\n    setReceiverPointer(TSInfo);\n  }\n\n  /// Retrieve the location of the 'super' keyword for a class\n  /// or instance message to 'super', otherwise an invalid source location.\n  SourceLocation getSuperLoc() const {\n    if (getReceiverKind() == SuperInstance || getReceiverKind() == SuperClass)\n      return SuperLoc;\n\n    return SourceLocation();\n  }\n\n  /// Retrieve the receiver type to which this message is being directed.\n  ///\n  /// This routine cross-cuts all of the different kinds of message\n  /// sends to determine what the underlying (statically known) type\n  /// of the receiver will be; use \\c getReceiverKind() to determine\n  /// whether the message is a class or an instance method, whether it\n  /// is a send to super or not, etc.\n  ///\n  /// \\returns The type of the receiver.\n  QualType getReceiverType() const;\n\n  /// Retrieve the Objective-C interface to which this message\n  /// is being directed, if known.\n  ///\n  /// This routine cross-cuts all of the different kinds of message\n  /// sends to determine what the underlying (statically known) type\n  /// of the receiver will be; use \\c getReceiverKind() to determine\n  /// whether the message is a class or an instance method, whether it\n  /// is a send to super or not, etc.\n  ///\n  /// \\returns The Objective-C interface if known, otherwise nullptr.\n  ObjCInterfaceDecl *getReceiverInterface() const;\n\n  /// Retrieve the type referred to by 'super'.\n  ///\n  /// The returned type will either be an ObjCInterfaceType (for an\n  /// class message to super) or an ObjCObjectPointerType that refers\n  /// to a class (for an instance message to super);\n  QualType getSuperType() const {\n    if (getReceiverKind() == SuperInstance || getReceiverKind() == SuperClass)\n      return QualType::getFromOpaquePtr(getReceiverPointer());\n\n    return QualType();\n  }\n\n  void setSuper(SourceLocation Loc, QualType T, bool IsInstanceSuper) {\n    Kind = IsInstanceSuper? SuperInstance : SuperClass;\n    SuperLoc = Loc;\n    setReceiverPointer(T.getAsOpaquePtr());\n  }\n\n  Selector getSelector() const;\n\n  void setSelector(Selector S) {\n    HasMethod = false;\n    SelectorOrMethod = reinterpret_cast<uintptr_t>(S.getAsOpaquePtr());\n  }\n\n  const ObjCMethodDecl *getMethodDecl() const {\n    if (HasMethod)\n      return reinterpret_cast<const ObjCMethodDecl *>(SelectorOrMethod);\n\n    return nullptr;\n  }\n\n  ObjCMethodDecl *getMethodDecl() {\n    if (HasMethod)\n      return reinterpret_cast<ObjCMethodDecl *>(SelectorOrMethod);\n\n    return nullptr;\n  }\n\n  void setMethodDecl(ObjCMethodDecl *MD) {\n    HasMethod = true;\n    SelectorOrMethod = reinterpret_cast<uintptr_t>(MD);\n  }\n\n  ObjCMethodFamily getMethodFamily() const {\n    if (HasMethod) return getMethodDecl()->getMethodFamily();\n    return getSelector().getMethodFamily();\n  }\n\n  /// Return the number of actual arguments in this message,\n  /// not counting the receiver.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the arguments to this message, not including the\n  /// receiver.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<void *>() + 1);\n  }\n  const Expr * const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(getTrailingObjects<void *>() +\n                                                 1);\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// isDelegateInitCall - Answers whether this message send has been\n  /// tagged as a \"delegate init call\", i.e. a call to a method in the\n  /// -init family on self from within an -init method implementation.\n  bool isDelegateInitCall() const { return IsDelegateInitCall; }\n  void setDelegateInitCall(bool isDelegate) { IsDelegateInitCall = isDelegate; }\n\n  SourceLocation getLeftLoc() const { return LBracLoc; }\n  SourceLocation getRightLoc() const { return RBracLoc; }\n\n  SourceLocation getSelectorStartLoc() const {\n    if (isImplicit())\n      return getBeginLoc();\n    return getSelectorLoc(0);\n  }\n\n  SourceLocation getSelectorLoc(unsigned Index) const {\n    assert(Index < getNumSelectorLocs() && \"Index out of range!\");\n    if (hasStandardSelLocs())\n      return getStandardSelectorLoc(Index, getSelector(),\n                                   getSelLocsKind() == SelLoc_StandardWithSpace,\n                               llvm::makeArrayRef(const_cast<Expr**>(getArgs()),\n                                                  getNumArgs()),\n                                   RBracLoc);\n    return getStoredSelLocs()[Index];\n  }\n\n  void getSelectorLocs(SmallVectorImpl<SourceLocation> &SelLocs) const;\n\n  unsigned getNumSelectorLocs() const {\n    if (isImplicit())\n      return 0;\n    Selector Sel = getSelector();\n    if (Sel.isUnarySelector())\n      return 1;\n    return Sel.getNumArgs();\n  }\n\n  void setSourceRange(SourceRange R) {\n    LBracLoc = R.getBegin();\n    RBracLoc = R.getEnd();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LBracLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracLoc; }\n\n  // Iterators\n  child_range children();\n\n  const_child_range children() const;\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n\n  llvm::iterator_range<arg_iterator> arguments() {\n    return llvm::make_range(arg_begin(), arg_end());\n  }\n\n  llvm::iterator_range<const_arg_iterator> arguments() const {\n    return llvm::make_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() { return reinterpret_cast<Stmt **>(getArgs()); }\n\n  arg_iterator arg_end()   {\n    return reinterpret_cast<Stmt **>(getArgs() + NumArgs);\n  }\n\n  const_arg_iterator arg_begin() const {\n    return reinterpret_cast<Stmt const * const*>(getArgs());\n  }\n\n  const_arg_iterator arg_end() const {\n    return reinterpret_cast<Stmt const * const*>(getArgs() + NumArgs);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCMessageExprClass;\n  }\n};\n\n/// ObjCIsaExpr - Represent X->isa and X.isa when X is an ObjC 'id' type.\n/// (similar in spirit to MemberExpr).\nclass ObjCIsaExpr : public Expr {\n  /// Base - the expression for the base object pointer.\n  Stmt *Base;\n\n  /// IsaMemberLoc - This is the location of the 'isa'.\n  SourceLocation IsaMemberLoc;\n\n  /// OpLoc - This is the location of '.' or '->'\n  SourceLocation OpLoc;\n\n  /// IsArrow - True if this is \"X->F\", false if this is \"X.F\".\n  bool IsArrow;\n\npublic:\n  ObjCIsaExpr(Expr *base, bool isarrow, SourceLocation l, SourceLocation oploc,\n              QualType ty)\n      : Expr(ObjCIsaExprClass, ty, VK_LValue, OK_Ordinary), Base(base),\n        IsaMemberLoc(l), OpLoc(oploc), IsArrow(isarrow) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty expression.\n  explicit ObjCIsaExpr(EmptyShell Empty) : Expr(ObjCIsaExprClass, Empty) {}\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  bool isArrow() const { return IsArrow; }\n  void setArrow(bool A) { IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getIsaMemberLoc() const { return IsaMemberLoc; }\n  void setIsaMemberLoc(SourceLocation L) { IsaMemberLoc = L; }\n\n  SourceLocation getOpLoc() const { return OpLoc; }\n  void setOpLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getBaseLocEnd() const LLVM_READONLY {\n    return getBase()->getEndLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return IsaMemberLoc; }\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return IsaMemberLoc; }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCIsaExprClass;\n  }\n};\n\n/// ObjCIndirectCopyRestoreExpr - Represents the passing of a function\n/// argument by indirect copy-restore in ARC.  This is used to support\n/// passing indirect arguments with the wrong lifetime, e.g. when\n/// passing the address of a __strong local variable to an 'out'\n/// parameter.  This expression kind is only valid in an \"argument\"\n/// position to some sort of call expression.\n///\n/// The parameter must have type 'pointer to T', and the argument must\n/// have type 'pointer to U', where T and U agree except possibly in\n/// qualification.  If the argument value is null, then a null pointer\n/// is passed;  otherwise it points to an object A, and:\n/// 1. A temporary object B of type T is initialized, either by\n///    zero-initialization (used when initializing an 'out' parameter)\n///    or copy-initialization (used when initializing an 'inout'\n///    parameter).\n/// 2. The address of the temporary is passed to the function.\n/// 3. If the call completes normally, A is move-assigned from B.\n/// 4. Finally, A is destroyed immediately.\n///\n/// Currently 'T' must be a retainable object lifetime and must be\n/// __autoreleasing;  this qualifier is ignored when initializing\n/// the value.\nclass ObjCIndirectCopyRestoreExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  Stmt *Operand;\n\n  // unsigned ObjCIndirectCopyRestoreBits.ShouldCopy : 1;\n\n  explicit ObjCIndirectCopyRestoreExpr(EmptyShell Empty)\n      : Expr(ObjCIndirectCopyRestoreExprClass, Empty) {}\n\n  void setShouldCopy(bool shouldCopy) {\n    ObjCIndirectCopyRestoreExprBits.ShouldCopy = shouldCopy;\n  }\n\npublic:\n  ObjCIndirectCopyRestoreExpr(Expr *operand, QualType type, bool shouldCopy)\n      : Expr(ObjCIndirectCopyRestoreExprClass, type, VK_LValue, OK_Ordinary),\n        Operand(operand) {\n    setShouldCopy(shouldCopy);\n    setDependence(computeDependence(this));\n  }\n\n  Expr *getSubExpr() { return cast<Expr>(Operand); }\n  const Expr *getSubExpr() const { return cast<Expr>(Operand); }\n\n  /// shouldCopy - True if we should do the 'copy' part of the\n  /// copy-restore.  If false, the temporary will be zero-initialized.\n  bool shouldCopy() const { return ObjCIndirectCopyRestoreExprBits.ShouldCopy; }\n\n  child_range children() { return child_range(&Operand, &Operand+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Operand, &Operand + 1);\n  }\n\n  // Source locations are determined by the subexpression.\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Operand->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Operand->getEndLoc();\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSubExpr()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *s) {\n    return s->getStmtClass() == ObjCIndirectCopyRestoreExprClass;\n  }\n};\n\n/// An Objective-C \"bridged\" cast expression, which casts between\n/// Objective-C pointers and C pointers, transferring ownership in the process.\n///\n/// \\code\n/// NSString *str = (__bridge_transfer NSString *)CFCreateString();\n/// \\endcode\nclass ObjCBridgedCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<ObjCBridgedCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation LParenLoc;\n  SourceLocation BridgeKeywordLoc;\n  unsigned Kind : 2;\n\npublic:\n  ObjCBridgedCastExpr(SourceLocation LParenLoc, ObjCBridgeCastKind Kind,\n                      CastKind CK, SourceLocation BridgeKeywordLoc,\n                      TypeSourceInfo *TSInfo, Expr *Operand)\n      : ExplicitCastExpr(ObjCBridgedCastExprClass, TSInfo->getType(), VK_RValue,\n                         CK, Operand, 0, false, TSInfo),\n        LParenLoc(LParenLoc), BridgeKeywordLoc(BridgeKeywordLoc), Kind(Kind) {}\n\n  /// Construct an empty Objective-C bridged cast.\n  explicit ObjCBridgedCastExpr(EmptyShell Shell)\n      : ExplicitCastExpr(ObjCBridgedCastExprClass, Shell, 0, false) {}\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Determine which kind of bridge is being performed via this cast.\n  ObjCBridgeCastKind getBridgeKind() const {\n    return static_cast<ObjCBridgeCastKind>(Kind);\n  }\n\n  /// Retrieve the kind of bridge being performed as a string.\n  StringRef getBridgeKindName() const;\n\n  /// The location of the bridge keyword.\n  SourceLocation getBridgeKeywordLoc() const { return BridgeKeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBridgedCastExprClass;\n  }\n};\n\n/// A runtime availability query.\n///\n/// There are 2 ways to spell this node:\n/// \\code\n///   @available(macos 10.10, ios 8, *); // Objective-C\n///   __builtin_available(macos 10.10, ios 8, *); // C, C++, and Objective-C\n/// \\endcode\n///\n/// Note that we only need to keep track of one \\c VersionTuple here, which is\n/// the one that corresponds to the current deployment target. This is meant to\n/// be used in the condition of an \\c if, but it is also usable as top level\n/// expressions.\n///\nclass ObjCAvailabilityCheckExpr : public Expr {\n  friend class ASTStmtReader;\n\n  VersionTuple VersionToCheck;\n  SourceLocation AtLoc, RParen;\n\npublic:\n  ObjCAvailabilityCheckExpr(VersionTuple VersionToCheck, SourceLocation AtLoc,\n                            SourceLocation RParen, QualType Ty)\n      : Expr(ObjCAvailabilityCheckExprClass, Ty, VK_RValue, OK_Ordinary),\n        VersionToCheck(VersionToCheck), AtLoc(AtLoc), RParen(RParen) {\n    setDependence(ExprDependence::None);\n  }\n\n  explicit ObjCAvailabilityCheckExpr(EmptyShell Shell)\n      : Expr(ObjCAvailabilityCheckExprClass, Shell) {}\n\n  SourceLocation getBeginLoc() const { return AtLoc; }\n  SourceLocation getEndLoc() const { return RParen; }\n  SourceRange getSourceRange() const { return {AtLoc, RParen}; }\n\n  /// This may be '*', in which case this should fold to true.\n  bool hasVersion() const { return !VersionToCheck.empty(); }\n  VersionTuple getVersion() { return VersionToCheck; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAvailabilityCheckExprClass;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_EXPROBJC_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "content": "//===---- CGObjC.cpp - Emit LLVM Code for Objective-C ---------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This contains code to emit Objective-C code as LLVM code.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CGDebugInfo.h\"\n#include \"CGObjCRuntime.h\"\n#include \"CodeGenFunction.h\"\n#include \"CodeGenModule.h\"\n#include \"ConstantEmitter.h\"\n#include \"TargetInfo.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/StmtObjC.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/CodeGen/CGFunctionInfo.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Analysis/ObjCARCUtil.h\"\n#include \"llvm/BinaryFormat/MachO.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/InlineAsm.h\"\nusing namespace clang;\nusing namespace CodeGen;\n\ntypedef llvm::PointerIntPair<llvm::Value*,1,bool> TryEmitResult;\nstatic TryEmitResult\ntryEmitARCRetainScalarExpr(CodeGenFunction &CGF, const Expr *e);\nstatic RValue AdjustObjCObjectType(CodeGenFunction &CGF,\n                                   QualType ET,\n                                   RValue Result);\n\n/// Given the address of a variable of pointer type, find the correct\n/// null to store into it.\nstatic llvm::Constant *getNullForVariable(Address addr) {\n  llvm::Type *type = addr.getElementType();\n  return llvm::ConstantPointerNull::get(cast<llvm::PointerType>(type));\n}\n\n/// Emits an instance of NSConstantString representing the object.\nllvm::Value *CodeGenFunction::EmitObjCStringLiteral(const ObjCStringLiteral *E)\n{\n  llvm::Constant *C =\n      CGM.getObjCRuntime().GenerateConstantString(E->getString()).getPointer();\n  // FIXME: This bitcast should just be made an invariant on the Runtime.\n  return llvm::ConstantExpr::getBitCast(C, ConvertType(E->getType()));\n}\n\n/// EmitObjCBoxedExpr - This routine generates code to call\n/// the appropriate expression boxing method. This will either be\n/// one of +[NSNumber numberWith<Type>:], or +[NSString stringWithUTF8String:],\n/// or [NSValue valueWithBytes:objCType:].\n///\nllvm::Value *\nCodeGenFunction::EmitObjCBoxedExpr(const ObjCBoxedExpr *E) {\n  // Generate the correct selector for this literal's concrete type.\n  // Get the method.\n  const ObjCMethodDecl *BoxingMethod = E->getBoxingMethod();\n  const Expr *SubExpr = E->getSubExpr();\n\n  if (E->isExpressibleAsConstantInitializer()) {\n    ConstantEmitter ConstEmitter(CGM);\n    return ConstEmitter.tryEmitAbstract(E, E->getType());\n  }\n\n  assert(BoxingMethod->isClassMethod() && \"BoxingMethod must be a class method\");\n  Selector Sel = BoxingMethod->getSelector();\n\n  // Generate a reference to the class pointer, which will be the receiver.\n  // Assumes that the method was introduced in the class that should be\n  // messaged (avoids pulling it out of the result type).\n  CGObjCRuntime &Runtime = CGM.getObjCRuntime();\n  const ObjCInterfaceDecl *ClassDecl = BoxingMethod->getClassInterface();\n  llvm::Value *Receiver = Runtime.GetClass(*this, ClassDecl);\n\n  CallArgList Args;\n  const ParmVarDecl *ArgDecl = *BoxingMethod->param_begin();\n  QualType ArgQT = ArgDecl->getType().getUnqualifiedType();\n\n  // ObjCBoxedExpr supports boxing of structs and unions\n  // via [NSValue valueWithBytes:objCType:]\n  const QualType ValueType(SubExpr->getType().getCanonicalType());\n  if (ValueType->isObjCBoxableRecordType()) {\n    // Emit CodeGen for first parameter\n    // and cast value to correct type\n    Address Temporary = CreateMemTemp(SubExpr->getType());\n    EmitAnyExprToMem(SubExpr, Temporary, Qualifiers(), /*isInit*/ true);\n    Address BitCast = Builder.CreateBitCast(Temporary, ConvertType(ArgQT));\n    Args.add(RValue::get(BitCast.getPointer()), ArgQT);\n\n    // Create char array to store type encoding\n    std::string Str;\n    getContext().getObjCEncodingForType(ValueType, Str);\n    llvm::Constant *GV = CGM.GetAddrOfConstantCString(Str).getPointer();\n\n    // Cast type encoding to correct type\n    const ParmVarDecl *EncodingDecl = BoxingMethod->parameters()[1];\n    QualType EncodingQT = EncodingDecl->getType().getUnqualifiedType();\n    llvm::Value *Cast = Builder.CreateBitCast(GV, ConvertType(EncodingQT));\n\n    Args.add(RValue::get(Cast), EncodingQT);\n  } else {\n    Args.add(EmitAnyExpr(SubExpr), ArgQT);\n  }\n\n  RValue result = Runtime.GenerateMessageSend(\n      *this, ReturnValueSlot(), BoxingMethod->getReturnType(), Sel, Receiver,\n      Args, ClassDecl, BoxingMethod);\n  return Builder.CreateBitCast(result.getScalarVal(),\n                               ConvertType(E->getType()));\n}\n\nllvm::Value *CodeGenFunction::EmitObjCCollectionLiteral(const Expr *E,\n                                    const ObjCMethodDecl *MethodWithObjects) {\n  ASTContext &Context = CGM.getContext();\n  const ObjCDictionaryLiteral *DLE = nullptr;\n  const ObjCArrayLiteral *ALE = dyn_cast<ObjCArrayLiteral>(E);\n  if (!ALE)\n    DLE = cast<ObjCDictionaryLiteral>(E);\n\n  // Optimize empty collections by referencing constants, when available.\n  uint64_t NumElements =\n    ALE ? ALE->getNumElements() : DLE->getNumElements();\n  if (NumElements == 0 && CGM.getLangOpts().ObjCRuntime.hasEmptyCollections()) {\n    StringRef ConstantName = ALE ? \"__NSArray0__\" : \"__NSDictionary0__\";\n    QualType IdTy(CGM.getContext().getObjCIdType());\n    llvm::Constant *Constant =\n        CGM.CreateRuntimeVariable(ConvertType(IdTy), ConstantName);\n    LValue LV = MakeNaturalAlignAddrLValue(Constant, IdTy);\n    llvm::Value *Ptr = EmitLoadOfScalar(LV, E->getBeginLoc());\n    cast<llvm::LoadInst>(Ptr)->setMetadata(\n        CGM.getModule().getMDKindID(\"invariant.load\"),\n        llvm::MDNode::get(getLLVMContext(), None));\n    return Builder.CreateBitCast(Ptr, ConvertType(E->getType()));\n  }\n\n  // Compute the type of the array we're initializing.\n  llvm::APInt APNumElements(Context.getTypeSize(Context.getSizeType()),\n                            NumElements);\n  QualType ElementType = Context.getObjCIdType().withConst();\n  QualType ElementArrayType\n    = Context.getConstantArrayType(ElementType, APNumElements, nullptr,\n                                   ArrayType::Normal, /*IndexTypeQuals=*/0);\n\n  // Allocate the temporary array(s).\n  Address Objects = CreateMemTemp(ElementArrayType, \"objects\");\n  Address Keys = Address::invalid();\n  if (DLE)\n    Keys = CreateMemTemp(ElementArrayType, \"keys\");\n\n  // In ARC, we may need to do extra work to keep all the keys and\n  // values alive until after the call.\n  SmallVector<llvm::Value *, 16> NeededObjects;\n  bool TrackNeededObjects =\n    (getLangOpts().ObjCAutoRefCount &&\n    CGM.getCodeGenOpts().OptimizationLevel != 0);\n\n  // Perform the actual initialialization of the array(s).\n  for (uint64_t i = 0; i < NumElements; i++) {\n    if (ALE) {\n      // Emit the element and store it to the appropriate array slot.\n      const Expr *Rhs = ALE->getElement(i);\n      LValue LV = MakeAddrLValue(Builder.CreateConstArrayGEP(Objects, i),\n                                 ElementType, AlignmentSource::Decl);\n\n      llvm::Value *value = EmitScalarExpr(Rhs);\n      EmitStoreThroughLValue(RValue::get(value), LV, true);\n      if (TrackNeededObjects) {\n        NeededObjects.push_back(value);\n      }\n    } else {\n      // Emit the key and store it to the appropriate array slot.\n      const Expr *Key = DLE->getKeyValueElement(i).Key;\n      LValue KeyLV = MakeAddrLValue(Builder.CreateConstArrayGEP(Keys, i),\n                                    ElementType, AlignmentSource::Decl);\n      llvm::Value *keyValue = EmitScalarExpr(Key);\n      EmitStoreThroughLValue(RValue::get(keyValue), KeyLV, /*isInit=*/true);\n\n      // Emit the value and store it to the appropriate array slot.\n      const Expr *Value = DLE->getKeyValueElement(i).Value;\n      LValue ValueLV = MakeAddrLValue(Builder.CreateConstArrayGEP(Objects, i),\n                                      ElementType, AlignmentSource::Decl);\n      llvm::Value *valueValue = EmitScalarExpr(Value);\n      EmitStoreThroughLValue(RValue::get(valueValue), ValueLV, /*isInit=*/true);\n      if (TrackNeededObjects) {\n        NeededObjects.push_back(keyValue);\n        NeededObjects.push_back(valueValue);\n      }\n    }\n  }\n\n  // Generate the argument list.\n  CallArgList Args;\n  ObjCMethodDecl::param_const_iterator PI = MethodWithObjects->param_begin();\n  const ParmVarDecl *argDecl = *PI++;\n  QualType ArgQT = argDecl->getType().getUnqualifiedType();\n  Args.add(RValue::get(Objects.getPointer()), ArgQT);\n  if (DLE) {\n    argDecl = *PI++;\n    ArgQT = argDecl->getType().getUnqualifiedType();\n    Args.add(RValue::get(Keys.getPointer()), ArgQT);\n  }\n  argDecl = *PI;\n  ArgQT = argDecl->getType().getUnqualifiedType();\n  llvm::Value *Count =\n    llvm::ConstantInt::get(CGM.getTypes().ConvertType(ArgQT), NumElements);\n  Args.add(RValue::get(Count), ArgQT);\n\n  // Generate a reference to the class pointer, which will be the receiver.\n  Selector Sel = MethodWithObjects->getSelector();\n  QualType ResultType = E->getType();\n  const ObjCObjectPointerType *InterfacePointerType\n    = ResultType->getAsObjCInterfacePointerType();\n  ObjCInterfaceDecl *Class\n    = InterfacePointerType->getObjectType()->getInterface();\n  CGObjCRuntime &Runtime = CGM.getObjCRuntime();\n  llvm::Value *Receiver = Runtime.GetClass(*this, Class);\n\n  // Generate the message send.\n  RValue result = Runtime.GenerateMessageSend(\n      *this, ReturnValueSlot(), MethodWithObjects->getReturnType(), Sel,\n      Receiver, Args, Class, MethodWithObjects);\n\n  // The above message send needs these objects, but in ARC they are\n  // passed in a buffer that is essentially __unsafe_unretained.\n  // Therefore we must prevent the optimizer from releasing them until\n  // after the call.\n  if (TrackNeededObjects) {\n    EmitARCIntrinsicUse(NeededObjects);\n  }\n\n  return Builder.CreateBitCast(result.getScalarVal(),\n                               ConvertType(E->getType()));\n}\n\nllvm::Value *CodeGenFunction::EmitObjCArrayLiteral(const ObjCArrayLiteral *E) {\n  return EmitObjCCollectionLiteral(E, E->getArrayWithObjectsMethod());\n}\n\nllvm::Value *CodeGenFunction::EmitObjCDictionaryLiteral(\n                                            const ObjCDictionaryLiteral *E) {\n  return EmitObjCCollectionLiteral(E, E->getDictWithObjectsMethod());\n}\n\n/// Emit a selector.\nllvm::Value *CodeGenFunction::EmitObjCSelectorExpr(const ObjCSelectorExpr *E) {\n  // Untyped selector.\n  // Note that this implementation allows for non-constant strings to be passed\n  // as arguments to @selector().  Currently, the only thing preventing this\n  // behaviour is the type checking in the front end.\n  return CGM.getObjCRuntime().GetSelector(*this, E->getSelector());\n}\n\nllvm::Value *CodeGenFunction::EmitObjCProtocolExpr(const ObjCProtocolExpr *E) {\n  // FIXME: This should pass the Decl not the name.\n  return CGM.getObjCRuntime().GenerateProtocolRef(*this, E->getProtocol());\n}\n\n/// Adjust the type of an Objective-C object that doesn't match up due\n/// to type erasure at various points, e.g., related result types or the use\n/// of parameterized classes.\nstatic RValue AdjustObjCObjectType(CodeGenFunction &CGF, QualType ExpT,\n                                   RValue Result) {\n  if (!ExpT->isObjCRetainableType())\n    return Result;\n\n  // If the converted types are the same, we're done.\n  llvm::Type *ExpLLVMTy = CGF.ConvertType(ExpT);\n  if (ExpLLVMTy == Result.getScalarVal()->getType())\n    return Result;\n\n  // We have applied a substitution. Cast the rvalue appropriately.\n  return RValue::get(CGF.Builder.CreateBitCast(Result.getScalarVal(),\n                                               ExpLLVMTy));\n}\n\n/// Decide whether to extend the lifetime of the receiver of a\n/// returns-inner-pointer message.\nstatic bool\nshouldExtendReceiverForInnerPointerMessage(const ObjCMessageExpr *message) {\n  switch (message->getReceiverKind()) {\n\n  // For a normal instance message, we should extend unless the\n  // receiver is loaded from a variable with precise lifetime.\n  case ObjCMessageExpr::Instance: {\n    const Expr *receiver = message->getInstanceReceiver();\n\n    // Look through OVEs.\n    if (auto opaque = dyn_cast<OpaqueValueExpr>(receiver)) {\n      if (opaque->getSourceExpr())\n        receiver = opaque->getSourceExpr()->IgnoreParens();\n    }\n\n    const ImplicitCastExpr *ice = dyn_cast<ImplicitCastExpr>(receiver);\n    if (!ice || ice->getCastKind() != CK_LValueToRValue) return true;\n    receiver = ice->getSubExpr()->IgnoreParens();\n\n    // Look through OVEs.\n    if (auto opaque = dyn_cast<OpaqueValueExpr>(receiver)) {\n      if (opaque->getSourceExpr())\n        receiver = opaque->getSourceExpr()->IgnoreParens();\n    }\n\n    // Only __strong variables.\n    if (receiver->getType().getObjCLifetime() != Qualifiers::OCL_Strong)\n      return true;\n\n    // All ivars and fields have precise lifetime.\n    if (isa<MemberExpr>(receiver) || isa<ObjCIvarRefExpr>(receiver))\n      return false;\n\n    // Otherwise, check for variables.\n    const DeclRefExpr *declRef = dyn_cast<DeclRefExpr>(ice->getSubExpr());\n    if (!declRef) return true;\n    const VarDecl *var = dyn_cast<VarDecl>(declRef->getDecl());\n    if (!var) return true;\n\n    // All variables have precise lifetime except local variables with\n    // automatic storage duration that aren't specially marked.\n    return (var->hasLocalStorage() &&\n            !var->hasAttr<ObjCPreciseLifetimeAttr>());\n  }\n\n  case ObjCMessageExpr::Class:\n  case ObjCMessageExpr::SuperClass:\n    // It's never necessary for class objects.\n    return false;\n\n  case ObjCMessageExpr::SuperInstance:\n    // We generally assume that 'self' lives throughout a method call.\n    return false;\n  }\n\n  llvm_unreachable(\"invalid receiver kind\");\n}\n\n/// Given an expression of ObjC pointer type, check whether it was\n/// immediately loaded from an ARC __weak l-value.\nstatic const Expr *findWeakLValue(const Expr *E) {\n  assert(E->getType()->isObjCRetainableType());\n  E = E->IgnoreParens();\n  if (auto CE = dyn_cast<CastExpr>(E)) {\n    if (CE->getCastKind() == CK_LValueToRValue) {\n      if (CE->getSubExpr()->getType().getObjCLifetime() == Qualifiers::OCL_Weak)\n        return CE->getSubExpr();\n    }\n  }\n\n  return nullptr;\n}\n\n/// The ObjC runtime may provide entrypoints that are likely to be faster\n/// than an ordinary message send of the appropriate selector.\n///\n/// The entrypoints are guaranteed to be equivalent to just sending the\n/// corresponding message.  If the entrypoint is implemented naively as just a\n/// message send, using it is a trade-off: it sacrifices a few cycles of\n/// overhead to save a small amount of code.  However, it's possible for\n/// runtimes to detect and special-case classes that use \"standard\"\n/// behavior; if that's dynamically a large proportion of all objects, using\n/// the entrypoint will also be faster than using a message send.\n///\n/// If the runtime does support a required entrypoint, then this method will\n/// generate a call and return the resulting value.  Otherwise it will return\n/// None and the caller can generate a msgSend instead.\nstatic Optional<llvm::Value *>\ntryGenerateSpecializedMessageSend(CodeGenFunction &CGF, QualType ResultType,\n                                  llvm::Value *Receiver,\n                                  const CallArgList& Args, Selector Sel,\n                                  const ObjCMethodDecl *method,\n                                  bool isClassMessage) {\n  auto &CGM = CGF.CGM;\n  if (!CGM.getCodeGenOpts().ObjCConvertMessagesToRuntimeCalls)\n    return None;\n\n  auto &Runtime = CGM.getLangOpts().ObjCRuntime;\n  switch (Sel.getMethodFamily()) {\n  case OMF_alloc:\n    if (isClassMessage &&\n        Runtime.shouldUseRuntimeFunctionsForAlloc() &&\n        ResultType->isObjCObjectPointerType()) {\n        // [Foo alloc] -> objc_alloc(Foo) or\n        // [self alloc] -> objc_alloc(self)\n        if (Sel.isUnarySelector() && Sel.getNameForSlot(0) == \"alloc\")\n          return CGF.EmitObjCAlloc(Receiver, CGF.ConvertType(ResultType));\n        // [Foo allocWithZone:nil] -> objc_allocWithZone(Foo) or\n        // [self allocWithZone:nil] -> objc_allocWithZone(self)\n        if (Sel.isKeywordSelector() && Sel.getNumArgs() == 1 &&\n            Args.size() == 1 && Args.front().getType()->isPointerType() &&\n            Sel.getNameForSlot(0) == \"allocWithZone\") {\n          const llvm::Value* arg = Args.front().getKnownRValue().getScalarVal();\n          if (isa<llvm::ConstantPointerNull>(arg))\n            return CGF.EmitObjCAllocWithZone(Receiver,\n                                             CGF.ConvertType(ResultType));\n          return None;\n        }\n    }\n    break;\n\n  case OMF_autorelease:\n    if (ResultType->isObjCObjectPointerType() &&\n        CGM.getLangOpts().getGC() == LangOptions::NonGC &&\n        Runtime.shouldUseARCFunctionsForRetainRelease())\n      return CGF.EmitObjCAutorelease(Receiver, CGF.ConvertType(ResultType));\n    break;\n\n  case OMF_retain:\n    if (ResultType->isObjCObjectPointerType() &&\n        CGM.getLangOpts().getGC() == LangOptions::NonGC &&\n        Runtime.shouldUseARCFunctionsForRetainRelease())\n      return CGF.EmitObjCRetainNonBlock(Receiver, CGF.ConvertType(ResultType));\n    break;\n\n  case OMF_release:\n    if (ResultType->isVoidType() &&\n        CGM.getLangOpts().getGC() == LangOptions::NonGC &&\n        Runtime.shouldUseARCFunctionsForRetainRelease()) {\n      CGF.EmitObjCRelease(Receiver, ARCPreciseLifetime);\n      return nullptr;\n    }\n    break;\n\n  default:\n    break;\n  }\n  return None;\n}\n\nCodeGen::RValue CGObjCRuntime::GeneratePossiblySpecializedMessageSend(\n    CodeGenFunction &CGF, ReturnValueSlot Return, QualType ResultType,\n    Selector Sel, llvm::Value *Receiver, const CallArgList &Args,\n    const ObjCInterfaceDecl *OID, const ObjCMethodDecl *Method,\n    bool isClassMessage) {\n  if (Optional<llvm::Value *> SpecializedResult =\n          tryGenerateSpecializedMessageSend(CGF, ResultType, Receiver, Args,\n                                            Sel, Method, isClassMessage)) {\n    return RValue::get(SpecializedResult.getValue());\n  }\n  return GenerateMessageSend(CGF, Return, ResultType, Sel, Receiver, Args, OID,\n                             Method);\n}\n\nstatic void AppendFirstImpliedRuntimeProtocols(\n    const ObjCProtocolDecl *PD,\n    llvm::UniqueVector<const ObjCProtocolDecl *> &PDs) {\n  if (!PD->isNonRuntimeProtocol()) {\n    const auto *Can = PD->getCanonicalDecl();\n    PDs.insert(Can);\n    return;\n  }\n\n  for (const auto *ParentPD : PD->protocols())\n    AppendFirstImpliedRuntimeProtocols(ParentPD, PDs);\n}\n\nstd::vector<const ObjCProtocolDecl *>\nCGObjCRuntime::GetRuntimeProtocolList(ObjCProtocolDecl::protocol_iterator begin,\n                                      ObjCProtocolDecl::protocol_iterator end) {\n  std::vector<const ObjCProtocolDecl *> RuntimePds;\n  llvm::DenseSet<const ObjCProtocolDecl *> NonRuntimePDs;\n\n  for (; begin != end; ++begin) {\n    const auto *It = *begin;\n    const auto *Can = It->getCanonicalDecl();\n    if (Can->isNonRuntimeProtocol())\n      NonRuntimePDs.insert(Can);\n    else\n      RuntimePds.push_back(Can);\n  }\n\n  // If there are no non-runtime protocols then we can just stop now.\n  if (NonRuntimePDs.empty())\n    return RuntimePds;\n\n  // Else we have to search through the non-runtime protocol's inheritancy\n  // hierarchy DAG stopping whenever a branch either finds a runtime protocol or\n  // a non-runtime protocol without any parents. These are the \"first-implied\"\n  // protocols from a non-runtime protocol.\n  llvm::UniqueVector<const ObjCProtocolDecl *> FirstImpliedProtos;\n  for (const auto *PD : NonRuntimePDs)\n    AppendFirstImpliedRuntimeProtocols(PD, FirstImpliedProtos);\n\n  // Walk the Runtime list to get all protocols implied via the inclusion of\n  // this protocol, e.g. all protocols it inherits from including itself.\n  llvm::DenseSet<const ObjCProtocolDecl *> AllImpliedProtocols;\n  for (const auto *PD : RuntimePds) {\n    const auto *Can = PD->getCanonicalDecl();\n    AllImpliedProtocols.insert(Can);\n    Can->getImpliedProtocols(AllImpliedProtocols);\n  }\n\n  // Similar to above, walk the list of first-implied protocols to find the set\n  // all the protocols implied excluding the listed protocols themselves since\n  // they are not yet a part of the `RuntimePds` list.\n  for (const auto *PD : FirstImpliedProtos) {\n    PD->getImpliedProtocols(AllImpliedProtocols);\n  }\n\n  // From the first-implied list we have to finish building the final protocol\n  // list. If a protocol in the first-implied list was already implied via some\n  // inheritance path through some other protocols then it would be redundant to\n  // add it here and so we skip over it.\n  for (const auto *PD : FirstImpliedProtos) {\n    if (!AllImpliedProtocols.contains(PD)) {\n      RuntimePds.push_back(PD);\n    }\n  }\n\n  return RuntimePds;\n}\n\n/// Instead of '[[MyClass alloc] init]', try to generate\n/// 'objc_alloc_init(MyClass)'. This provides a code size improvement on the\n/// caller side, as well as the optimized objc_alloc.\nstatic Optional<llvm::Value *>\ntryEmitSpecializedAllocInit(CodeGenFunction &CGF, const ObjCMessageExpr *OME) {\n  auto &Runtime = CGF.getLangOpts().ObjCRuntime;\n  if (!Runtime.shouldUseRuntimeFunctionForCombinedAllocInit())\n    return None;\n\n  // Match the exact pattern '[[MyClass alloc] init]'.\n  Selector Sel = OME->getSelector();\n  if (OME->getReceiverKind() != ObjCMessageExpr::Instance ||\n      !OME->getType()->isObjCObjectPointerType() || !Sel.isUnarySelector() ||\n      Sel.getNameForSlot(0) != \"init\")\n    return None;\n\n  // Okay, this is '[receiver init]', check if 'receiver' is '[cls alloc]'\n  // with 'cls' a Class.\n  auto *SubOME =\n      dyn_cast<ObjCMessageExpr>(OME->getInstanceReceiver()->IgnoreParenCasts());\n  if (!SubOME)\n    return None;\n  Selector SubSel = SubOME->getSelector();\n\n  if (!SubOME->getType()->isObjCObjectPointerType() ||\n      !SubSel.isUnarySelector() || SubSel.getNameForSlot(0) != \"alloc\")\n    return None;\n\n  llvm::Value *Receiver = nullptr;\n  switch (SubOME->getReceiverKind()) {\n  case ObjCMessageExpr::Instance:\n    if (!SubOME->getInstanceReceiver()->getType()->isObjCClassType())\n      return None;\n    Receiver = CGF.EmitScalarExpr(SubOME->getInstanceReceiver());\n    break;\n\n  case ObjCMessageExpr::Class: {\n    QualType ReceiverType = SubOME->getClassReceiver();\n    const ObjCObjectType *ObjTy = ReceiverType->castAs<ObjCObjectType>();\n    const ObjCInterfaceDecl *ID = ObjTy->getInterface();\n    assert(ID && \"null interface should be impossible here\");\n    Receiver = CGF.CGM.getObjCRuntime().GetClass(CGF, ID);\n    break;\n  }\n  case ObjCMessageExpr::SuperInstance:\n  case ObjCMessageExpr::SuperClass:\n    return None;\n  }\n\n  return CGF.EmitObjCAllocInit(Receiver, CGF.ConvertType(OME->getType()));\n}\n\nRValue CodeGenFunction::EmitObjCMessageExpr(const ObjCMessageExpr *E,\n                                            ReturnValueSlot Return) {\n  // Only the lookup mechanism and first two arguments of the method\n  // implementation vary between runtimes.  We can get the receiver and\n  // arguments in generic code.\n\n  bool isDelegateInit = E->isDelegateInitCall();\n\n  const ObjCMethodDecl *method = E->getMethodDecl();\n\n  // If the method is -retain, and the receiver's being loaded from\n  // a __weak variable, peephole the entire operation to objc_loadWeakRetained.\n  if (method && E->getReceiverKind() == ObjCMessageExpr::Instance &&\n      method->getMethodFamily() == OMF_retain) {\n    if (auto lvalueExpr = findWeakLValue(E->getInstanceReceiver())) {\n      LValue lvalue = EmitLValue(lvalueExpr);\n      llvm::Value *result = EmitARCLoadWeakRetained(lvalue.getAddress(*this));\n      return AdjustObjCObjectType(*this, E->getType(), RValue::get(result));\n    }\n  }\n\n  if (Optional<llvm::Value *> Val = tryEmitSpecializedAllocInit(*this, E))\n    return AdjustObjCObjectType(*this, E->getType(), RValue::get(*Val));\n\n  // We don't retain the receiver in delegate init calls, and this is\n  // safe because the receiver value is always loaded from 'self',\n  // which we zero out.  We don't want to Block_copy block receivers,\n  // though.\n  bool retainSelf =\n    (!isDelegateInit &&\n     CGM.getLangOpts().ObjCAutoRefCount &&\n     method &&\n     method->hasAttr<NSConsumesSelfAttr>());\n\n  CGObjCRuntime &Runtime = CGM.getObjCRuntime();\n  bool isSuperMessage = false;\n  bool isClassMessage = false;\n  ObjCInterfaceDecl *OID = nullptr;\n  // Find the receiver\n  QualType ReceiverType;\n  llvm::Value *Receiver = nullptr;\n  switch (E->getReceiverKind()) {\n  case ObjCMessageExpr::Instance:\n    ReceiverType = E->getInstanceReceiver()->getType();\n    isClassMessage = ReceiverType->isObjCClassType();\n    if (retainSelf) {\n      TryEmitResult ter = tryEmitARCRetainScalarExpr(*this,\n                                                   E->getInstanceReceiver());\n      Receiver = ter.getPointer();\n      if (ter.getInt()) retainSelf = false;\n    } else\n      Receiver = EmitScalarExpr(E->getInstanceReceiver());\n    break;\n\n  case ObjCMessageExpr::Class: {\n    ReceiverType = E->getClassReceiver();\n    OID = ReceiverType->castAs<ObjCObjectType>()->getInterface();\n    assert(OID && \"Invalid Objective-C class message send\");\n    Receiver = Runtime.GetClass(*this, OID);\n    isClassMessage = true;\n    break;\n  }\n\n  case ObjCMessageExpr::SuperInstance:\n    ReceiverType = E->getSuperType();\n    Receiver = LoadObjCSelf();\n    isSuperMessage = true;\n    break;\n\n  case ObjCMessageExpr::SuperClass:\n    ReceiverType = E->getSuperType();\n    Receiver = LoadObjCSelf();\n    isSuperMessage = true;\n    isClassMessage = true;\n    break;\n  }\n\n  if (retainSelf)\n    Receiver = EmitARCRetainNonBlock(Receiver);\n\n  // In ARC, we sometimes want to \"extend the lifetime\"\n  // (i.e. retain+autorelease) of receivers of returns-inner-pointer\n  // messages.\n  if (getLangOpts().ObjCAutoRefCount && method &&\n      method->hasAttr<ObjCReturnsInnerPointerAttr>() &&\n      shouldExtendReceiverForInnerPointerMessage(E))\n    Receiver = EmitARCRetainAutorelease(ReceiverType, Receiver);\n\n  QualType ResultType = method ? method->getReturnType() : E->getType();\n\n  CallArgList Args;\n  EmitCallArgs(Args, method, E->arguments(), /*AC*/AbstractCallee(method));\n\n  // For delegate init calls in ARC, do an unsafe store of null into\n  // self.  This represents the call taking direct ownership of that\n  // value.  We have to do this after emitting the other call\n  // arguments because they might also reference self, but we don't\n  // have to worry about any of them modifying self because that would\n  // be an undefined read and write of an object in unordered\n  // expressions.\n  if (isDelegateInit) {\n    assert(getLangOpts().ObjCAutoRefCount &&\n           \"delegate init calls should only be marked in ARC\");\n\n    // Do an unsafe store of null into self.\n    Address selfAddr =\n      GetAddrOfLocalVar(cast<ObjCMethodDecl>(CurCodeDecl)->getSelfDecl());\n    Builder.CreateStore(getNullForVariable(selfAddr), selfAddr);\n  }\n\n  RValue result;\n  if (isSuperMessage) {\n    // super is only valid in an Objective-C method\n    const ObjCMethodDecl *OMD = cast<ObjCMethodDecl>(CurFuncDecl);\n    bool isCategoryImpl = isa<ObjCCategoryImplDecl>(OMD->getDeclContext());\n    result = Runtime.GenerateMessageSendSuper(*this, Return, ResultType,\n                                              E->getSelector(),\n                                              OMD->getClassInterface(),\n                                              isCategoryImpl,\n                                              Receiver,\n                                              isClassMessage,\n                                              Args,\n                                              method);\n  } else {\n    // Call runtime methods directly if we can.\n    result = Runtime.GeneratePossiblySpecializedMessageSend(\n        *this, Return, ResultType, E->getSelector(), Receiver, Args, OID,\n        method, isClassMessage);\n  }\n\n  // For delegate init calls in ARC, implicitly store the result of\n  // the call back into self.  This takes ownership of the value.\n  if (isDelegateInit) {\n    Address selfAddr =\n      GetAddrOfLocalVar(cast<ObjCMethodDecl>(CurCodeDecl)->getSelfDecl());\n    llvm::Value *newSelf = result.getScalarVal();\n\n    // The delegate return type isn't necessarily a matching type; in\n    // fact, it's quite likely to be 'id'.\n    llvm::Type *selfTy = selfAddr.getElementType();\n    newSelf = Builder.CreateBitCast(newSelf, selfTy);\n\n    Builder.CreateStore(newSelf, selfAddr);\n  }\n\n  return AdjustObjCObjectType(*this, E->getType(), result);\n}\n\nnamespace {\nstruct FinishARCDealloc final : EHScopeStack::Cleanup {\n  void Emit(CodeGenFunction &CGF, Flags flags) override {\n    const ObjCMethodDecl *method = cast<ObjCMethodDecl>(CGF.CurCodeDecl);\n\n    const ObjCImplDecl *impl = cast<ObjCImplDecl>(method->getDeclContext());\n    const ObjCInterfaceDecl *iface = impl->getClassInterface();\n    if (!iface->getSuperClass()) return;\n\n    bool isCategory = isa<ObjCCategoryImplDecl>(impl);\n\n    // Call [super dealloc] if we have a superclass.\n    llvm::Value *self = CGF.LoadObjCSelf();\n\n    CallArgList args;\n    CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(),\n                                                      CGF.getContext().VoidTy,\n                                                      method->getSelector(),\n                                                      iface,\n                                                      isCategory,\n                                                      self,\n                                                      /*is class msg*/ false,\n                                                      args,\n                                                      method);\n  }\n};\n}\n\n/// StartObjCMethod - Begin emission of an ObjCMethod. This generates\n/// the LLVM function and sets the other context used by\n/// CodeGenFunction.\nvoid CodeGenFunction::StartObjCMethod(const ObjCMethodDecl *OMD,\n                                      const ObjCContainerDecl *CD) {\n  SourceLocation StartLoc = OMD->getBeginLoc();\n  FunctionArgList args;\n  // Check if we should generate debug info for this method.\n  if (OMD->hasAttr<NoDebugAttr>())\n    DebugInfo = nullptr; // disable debug info indefinitely for this function\n\n  llvm::Function *Fn = CGM.getObjCRuntime().GenerateMethod(OMD, CD);\n\n  const CGFunctionInfo &FI = CGM.getTypes().arrangeObjCMethodDeclaration(OMD);\n  if (OMD->isDirectMethod()) {\n    Fn->setVisibility(llvm::Function::HiddenVisibility);\n    CGM.SetLLVMFunctionAttributes(OMD, FI, Fn);\n    CGM.SetLLVMFunctionAttributesForDefinition(OMD, Fn);\n  } else {\n    CGM.SetInternalFunctionAttributes(OMD, Fn, FI);\n  }\n\n  args.push_back(OMD->getSelfDecl());\n  args.push_back(OMD->getCmdDecl());\n\n  args.append(OMD->param_begin(), OMD->param_end());\n\n  CurGD = OMD;\n  CurEHLocation = OMD->getEndLoc();\n\n  StartFunction(OMD, OMD->getReturnType(), Fn, FI, args,\n                OMD->getLocation(), StartLoc);\n\n  if (OMD->isDirectMethod()) {\n    // This function is a direct call, it has to implement a nil check\n    // on entry.\n    //\n    // TODO: possibly have several entry points to elide the check\n    CGM.getObjCRuntime().GenerateDirectMethodPrologue(*this, Fn, OMD, CD);\n  }\n\n  // In ARC, certain methods get an extra cleanup.\n  if (CGM.getLangOpts().ObjCAutoRefCount &&\n      OMD->isInstanceMethod() &&\n      OMD->getSelector().isUnarySelector()) {\n    const IdentifierInfo *ident =\n      OMD->getSelector().getIdentifierInfoForSlot(0);\n    if (ident->isStr(\"dealloc\"))\n      EHStack.pushCleanup<FinishARCDealloc>(getARCCleanupKind());\n  }\n}\n\nstatic llvm::Value *emitARCRetainLoadOfScalar(CodeGenFunction &CGF,\n                                              LValue lvalue, QualType type);\n\n/// Generate an Objective-C method.  An Objective-C method is a C function with\n/// its pointer, name, and types registered in the class structure.\nvoid CodeGenFunction::GenerateObjCMethod(const ObjCMethodDecl *OMD) {\n  StartObjCMethod(OMD, OMD->getClassInterface());\n  PGO.assignRegionCounters(GlobalDecl(OMD), CurFn);\n  assert(isa<CompoundStmt>(OMD->getBody()));\n  incrementProfileCounter(OMD->getBody());\n  EmitCompoundStmtWithoutScope(*cast<CompoundStmt>(OMD->getBody()));\n  FinishFunction(OMD->getBodyRBrace());\n}\n\n/// emitStructGetterCall - Call the runtime function to load a property\n/// into the return value slot.\nstatic void emitStructGetterCall(CodeGenFunction &CGF, ObjCIvarDecl *ivar,\n                                 bool isAtomic, bool hasStrong) {\n  ASTContext &Context = CGF.getContext();\n\n  Address src =\n      CGF.EmitLValueForIvar(CGF.TypeOfSelfObject(), CGF.LoadObjCSelf(), ivar, 0)\n          .getAddress(CGF);\n\n  // objc_copyStruct (ReturnValue, &structIvar,\n  //                  sizeof (Type of Ivar), isAtomic, false);\n  CallArgList args;\n\n  Address dest = CGF.Builder.CreateBitCast(CGF.ReturnValue, CGF.VoidPtrTy);\n  args.add(RValue::get(dest.getPointer()), Context.VoidPtrTy);\n\n  src = CGF.Builder.CreateBitCast(src, CGF.VoidPtrTy);\n  args.add(RValue::get(src.getPointer()), Context.VoidPtrTy);\n\n  CharUnits size = CGF.getContext().getTypeSizeInChars(ivar->getType());\n  args.add(RValue::get(CGF.CGM.getSize(size)), Context.getSizeType());\n  args.add(RValue::get(CGF.Builder.getInt1(isAtomic)), Context.BoolTy);\n  args.add(RValue::get(CGF.Builder.getInt1(hasStrong)), Context.BoolTy);\n\n  llvm::FunctionCallee fn = CGF.CGM.getObjCRuntime().GetGetStructFunction();\n  CGCallee callee = CGCallee::forDirect(fn);\n  CGF.EmitCall(CGF.getTypes().arrangeBuiltinFunctionCall(Context.VoidTy, args),\n               callee, ReturnValueSlot(), args);\n}\n\n/// Determine whether the given architecture supports unaligned atomic\n/// accesses.  They don't have to be fast, just faster than a function\n/// call and a mutex.\nstatic bool hasUnalignedAtomics(llvm::Triple::ArchType arch) {\n  // FIXME: Allow unaligned atomic load/store on x86.  (It is not\n  // currently supported by the backend.)\n  return 0;\n}\n\n/// Return the maximum size that permits atomic accesses for the given\n/// architecture.\nstatic CharUnits getMaxAtomicAccessSize(CodeGenModule &CGM,\n                                        llvm::Triple::ArchType arch) {\n  // ARM has 8-byte atomic accesses, but it's not clear whether we\n  // want to rely on them here.\n\n  // In the default case, just assume that any size up to a pointer is\n  // fine given adequate alignment.\n  return CharUnits::fromQuantity(CGM.PointerSizeInBytes);\n}\n\nnamespace {\n  class PropertyImplStrategy {\n  public:\n    enum StrategyKind {\n      /// The 'native' strategy is to use the architecture's provided\n      /// reads and writes.\n      Native,\n\n      /// Use objc_setProperty and objc_getProperty.\n      GetSetProperty,\n\n      /// Use objc_setProperty for the setter, but use expression\n      /// evaluation for the getter.\n      SetPropertyAndExpressionGet,\n\n      /// Use objc_copyStruct.\n      CopyStruct,\n\n      /// The 'expression' strategy is to emit normal assignment or\n      /// lvalue-to-rvalue expressions.\n      Expression\n    };\n\n    StrategyKind getKind() const { return StrategyKind(Kind); }\n\n    bool hasStrongMember() const { return HasStrong; }\n    bool isAtomic() const { return IsAtomic; }\n    bool isCopy() const { return IsCopy; }\n\n    CharUnits getIvarSize() const { return IvarSize; }\n    CharUnits getIvarAlignment() const { return IvarAlignment; }\n\n    PropertyImplStrategy(CodeGenModule &CGM,\n                         const ObjCPropertyImplDecl *propImpl);\n\n  private:\n    unsigned Kind : 8;\n    unsigned IsAtomic : 1;\n    unsigned IsCopy : 1;\n    unsigned HasStrong : 1;\n\n    CharUnits IvarSize;\n    CharUnits IvarAlignment;\n  };\n}\n\n/// Pick an implementation strategy for the given property synthesis.\nPropertyImplStrategy::PropertyImplStrategy(CodeGenModule &CGM,\n                                     const ObjCPropertyImplDecl *propImpl) {\n  const ObjCPropertyDecl *prop = propImpl->getPropertyDecl();\n  ObjCPropertyDecl::SetterKind setterKind = prop->getSetterKind();\n\n  IsCopy = (setterKind == ObjCPropertyDecl::Copy);\n  IsAtomic = prop->isAtomic();\n  HasStrong = false; // doesn't matter here.\n\n  // Evaluate the ivar's size and alignment.\n  ObjCIvarDecl *ivar = propImpl->getPropertyIvarDecl();\n  QualType ivarType = ivar->getType();\n  auto TInfo = CGM.getContext().getTypeInfoInChars(ivarType);\n  IvarSize = TInfo.Width;\n  IvarAlignment = TInfo.Align;\n\n  // If we have a copy property, we always have to use getProperty/setProperty.\n  // TODO: we could actually use setProperty and an expression for non-atomics.\n  if (IsCopy) {\n    Kind = GetSetProperty;\n    return;\n  }\n\n  // Handle retain.\n  if (setterKind == ObjCPropertyDecl::Retain) {\n    // In GC-only, there's nothing special that needs to be done.\n    if (CGM.getLangOpts().getGC() == LangOptions::GCOnly) {\n      // fallthrough\n\n    // In ARC, if the property is non-atomic, use expression emission,\n    // which translates to objc_storeStrong.  This isn't required, but\n    // it's slightly nicer.\n    } else if (CGM.getLangOpts().ObjCAutoRefCount && !IsAtomic) {\n      // Using standard expression emission for the setter is only\n      // acceptable if the ivar is __strong, which won't be true if\n      // the property is annotated with __attribute__((NSObject)).\n      // TODO: falling all the way back to objc_setProperty here is\n      // just laziness, though;  we could still use objc_storeStrong\n      // if we hacked it right.\n      if (ivarType.getObjCLifetime() == Qualifiers::OCL_Strong)\n        Kind = Expression;\n      else\n        Kind = SetPropertyAndExpressionGet;\n      return;\n\n    // Otherwise, we need to at least use setProperty.  However, if\n    // the property isn't atomic, we can use normal expression\n    // emission for the getter.\n    } else if (!IsAtomic) {\n      Kind = SetPropertyAndExpressionGet;\n      return;\n\n    // Otherwise, we have to use both setProperty and getProperty.\n    } else {\n      Kind = GetSetProperty;\n      return;\n    }\n  }\n\n  // If we're not atomic, just use expression accesses.\n  if (!IsAtomic) {\n    Kind = Expression;\n    return;\n  }\n\n  // Properties on bitfield ivars need to be emitted using expression\n  // accesses even if they're nominally atomic.\n  if (ivar->isBitField()) {\n    Kind = Expression;\n    return;\n  }\n\n  // GC-qualified or ARC-qualified ivars need to be emitted as\n  // expressions.  This actually works out to being atomic anyway,\n  // except for ARC __strong, but that should trigger the above code.\n  if (ivarType.hasNonTrivialObjCLifetime() ||\n      (CGM.getLangOpts().getGC() &&\n       CGM.getContext().getObjCGCAttrKind(ivarType))) {\n    Kind = Expression;\n    return;\n  }\n\n  // Compute whether the ivar has strong members.\n  if (CGM.getLangOpts().getGC())\n    if (const RecordType *recordType = ivarType->getAs<RecordType>())\n      HasStrong = recordType->getDecl()->hasObjectMember();\n\n  // We can never access structs with object members with a native\n  // access, because we need to use write barriers.  This is what\n  // objc_copyStruct is for.\n  if (HasStrong) {\n    Kind = CopyStruct;\n    return;\n  }\n\n  // Otherwise, this is target-dependent and based on the size and\n  // alignment of the ivar.\n\n  // If the size of the ivar is not a power of two, give up.  We don't\n  // want to get into the business of doing compare-and-swaps.\n  if (!IvarSize.isPowerOfTwo()) {\n    Kind = CopyStruct;\n    return;\n  }\n\n  llvm::Triple::ArchType arch =\n    CGM.getTarget().getTriple().getArch();\n\n  // Most architectures require memory to fit within a single cache\n  // line, so the alignment has to be at least the size of the access.\n  // Otherwise we have to grab a lock.\n  if (IvarAlignment < IvarSize && !hasUnalignedAtomics(arch)) {\n    Kind = CopyStruct;\n    return;\n  }\n\n  // If the ivar's size exceeds the architecture's maximum atomic\n  // access size, we have to use CopyStruct.\n  if (IvarSize > getMaxAtomicAccessSize(CGM, arch)) {\n    Kind = CopyStruct;\n    return;\n  }\n\n  // Otherwise, we can use native loads and stores.\n  Kind = Native;\n}\n\n/// Generate an Objective-C property getter function.\n///\n/// The given Decl must be an ObjCImplementationDecl. \\@synthesize\n/// is illegal within a category.\nvoid CodeGenFunction::GenerateObjCGetter(ObjCImplementationDecl *IMP,\n                                         const ObjCPropertyImplDecl *PID) {\n  llvm::Constant *AtomicHelperFn =\n      CodeGenFunction(CGM).GenerateObjCAtomicGetterCopyHelperFunction(PID);\n  ObjCMethodDecl *OMD = PID->getGetterMethodDecl();\n  assert(OMD && \"Invalid call to generate getter (empty method)\");\n  StartObjCMethod(OMD, IMP->getClassInterface());\n\n  generateObjCGetterBody(IMP, PID, OMD, AtomicHelperFn);\n\n  FinishFunction(OMD->getEndLoc());\n}\n\nstatic bool hasTrivialGetExpr(const ObjCPropertyImplDecl *propImpl) {\n  const Expr *getter = propImpl->getGetterCXXConstructor();\n  if (!getter) return true;\n\n  // Sema only makes only of these when the ivar has a C++ class type,\n  // so the form is pretty constrained.\n\n  // If the property has a reference type, we might just be binding a\n  // reference, in which case the result will be a gl-value.  We should\n  // treat this as a non-trivial operation.\n  if (getter->isGLValue())\n    return false;\n\n  // If we selected a trivial copy-constructor, we're okay.\n  if (const CXXConstructExpr *construct = dyn_cast<CXXConstructExpr>(getter))\n    return (construct->getConstructor()->isTrivial());\n\n  // The constructor might require cleanups (in which case it's never\n  // trivial).\n  assert(isa<ExprWithCleanups>(getter));\n  return false;\n}\n\n/// emitCPPObjectAtomicGetterCall - Call the runtime function to\n/// copy the ivar into the resturn slot.\nstatic void emitCPPObjectAtomicGetterCall(CodeGenFunction &CGF,\n                                          llvm::Value *returnAddr,\n                                          ObjCIvarDecl *ivar,\n                                          llvm::Constant *AtomicHelperFn) {\n  // objc_copyCppObjectAtomic (&returnSlot, &CppObjectIvar,\n  //                           AtomicHelperFn);\n  CallArgList args;\n\n  // The 1st argument is the return Slot.\n  args.add(RValue::get(returnAddr), CGF.getContext().VoidPtrTy);\n\n  // The 2nd argument is the address of the ivar.\n  llvm::Value *ivarAddr =\n      CGF.EmitLValueForIvar(CGF.TypeOfSelfObject(), CGF.LoadObjCSelf(), ivar, 0)\n          .getPointer(CGF);\n  ivarAddr = CGF.Builder.CreateBitCast(ivarAddr, CGF.Int8PtrTy);\n  args.add(RValue::get(ivarAddr), CGF.getContext().VoidPtrTy);\n\n  // Third argument is the helper function.\n  args.add(RValue::get(AtomicHelperFn), CGF.getContext().VoidPtrTy);\n\n  llvm::FunctionCallee copyCppAtomicObjectFn =\n      CGF.CGM.getObjCRuntime().GetCppAtomicObjectGetFunction();\n  CGCallee callee = CGCallee::forDirect(copyCppAtomicObjectFn);\n  CGF.EmitCall(\n      CGF.getTypes().arrangeBuiltinFunctionCall(CGF.getContext().VoidTy, args),\n               callee, ReturnValueSlot(), args);\n}\n\nvoid\nCodeGenFunction::generateObjCGetterBody(const ObjCImplementationDecl *classImpl,\n                                        const ObjCPropertyImplDecl *propImpl,\n                                        const ObjCMethodDecl *GetterMethodDecl,\n                                        llvm::Constant *AtomicHelperFn) {\n  // If there's a non-trivial 'get' expression, we just have to emit that.\n  if (!hasTrivialGetExpr(propImpl)) {\n    if (!AtomicHelperFn) {\n      auto *ret = ReturnStmt::Create(getContext(), SourceLocation(),\n                                     propImpl->getGetterCXXConstructor(),\n                                     /* NRVOCandidate=*/nullptr);\n      EmitReturnStmt(*ret);\n    }\n    else {\n      ObjCIvarDecl *ivar = propImpl->getPropertyIvarDecl();\n      emitCPPObjectAtomicGetterCall(*this, ReturnValue.getPointer(),\n                                    ivar, AtomicHelperFn);\n    }\n    return;\n  }\n\n  const ObjCPropertyDecl *prop = propImpl->getPropertyDecl();\n  QualType propType = prop->getType();\n  ObjCMethodDecl *getterMethod = propImpl->getGetterMethodDecl();\n\n  ObjCIvarDecl *ivar = propImpl->getPropertyIvarDecl();\n\n  // Pick an implementation strategy.\n  PropertyImplStrategy strategy(CGM, propImpl);\n  switch (strategy.getKind()) {\n  case PropertyImplStrategy::Native: {\n    // We don't need to do anything for a zero-size struct.\n    if (strategy.getIvarSize().isZero())\n      return;\n\n    LValue LV = EmitLValueForIvar(TypeOfSelfObject(), LoadObjCSelf(), ivar, 0);\n\n    // Currently, all atomic accesses have to be through integer\n    // types, so there's no point in trying to pick a prettier type.\n    uint64_t ivarSize = getContext().toBits(strategy.getIvarSize());\n    llvm::Type *bitcastType = llvm::Type::getIntNTy(getLLVMContext(), ivarSize);\n    bitcastType = bitcastType->getPointerTo(); // addrspace 0 okay\n\n    // Perform an atomic load.  This does not impose ordering constraints.\n    Address ivarAddr = LV.getAddress(*this);\n    ivarAddr = Builder.CreateBitCast(ivarAddr, bitcastType);\n    llvm::LoadInst *load = Builder.CreateLoad(ivarAddr, \"load\");\n    load->setAtomic(llvm::AtomicOrdering::Unordered);\n\n    // Store that value into the return address.  Doing this with a\n    // bitcast is likely to produce some pretty ugly IR, but it's not\n    // the *most* terrible thing in the world.\n    llvm::Type *retTy = ConvertType(getterMethod->getReturnType());\n    uint64_t retTySize = CGM.getDataLayout().getTypeSizeInBits(retTy);\n    llvm::Value *ivarVal = load;\n    if (ivarSize > retTySize) {\n      llvm::Type *newTy = llvm::Type::getIntNTy(getLLVMContext(), retTySize);\n      ivarVal = Builder.CreateTrunc(load, newTy);\n      bitcastType = newTy->getPointerTo();\n    }\n    Builder.CreateStore(ivarVal,\n                        Builder.CreateBitCast(ReturnValue, bitcastType));\n\n    // Make sure we don't do an autorelease.\n    AutoreleaseResult = false;\n    return;\n  }\n\n  case PropertyImplStrategy::GetSetProperty: {\n    llvm::FunctionCallee getPropertyFn =\n        CGM.getObjCRuntime().GetPropertyGetFunction();\n    if (!getPropertyFn) {\n      CGM.ErrorUnsupported(propImpl, \"Obj-C getter requiring atomic copy\");\n      return;\n    }\n    CGCallee callee = CGCallee::forDirect(getPropertyFn);\n\n    // Return (ivar-type) objc_getProperty((id) self, _cmd, offset, true).\n    // FIXME: Can't this be simpler? This might even be worse than the\n    // corresponding gcc code.\n    llvm::Value *cmd =\n      Builder.CreateLoad(GetAddrOfLocalVar(getterMethod->getCmdDecl()), \"cmd\");\n    llvm::Value *self = Builder.CreateBitCast(LoadObjCSelf(), VoidPtrTy);\n    llvm::Value *ivarOffset =\n      EmitIvarOffset(classImpl->getClassInterface(), ivar);\n\n    CallArgList args;\n    args.add(RValue::get(self), getContext().getObjCIdType());\n    args.add(RValue::get(cmd), getContext().getObjCSelType());\n    args.add(RValue::get(ivarOffset), getContext().getPointerDiffType());\n    args.add(RValue::get(Builder.getInt1(strategy.isAtomic())),\n             getContext().BoolTy);\n\n    // FIXME: We shouldn't need to get the function info here, the\n    // runtime already should have computed it to build the function.\n    llvm::CallBase *CallInstruction;\n    RValue RV = EmitCall(getTypes().arrangeBuiltinFunctionCall(\n                             getContext().getObjCIdType(), args),\n                         callee, ReturnValueSlot(), args, &CallInstruction);\n    if (llvm::CallInst *call = dyn_cast<llvm::CallInst>(CallInstruction))\n      call->setTailCall();\n\n    // We need to fix the type here. Ivars with copy & retain are\n    // always objects so we don't need to worry about complex or\n    // aggregates.\n    RV = RValue::get(Builder.CreateBitCast(\n        RV.getScalarVal(),\n        getTypes().ConvertType(getterMethod->getReturnType())));\n\n    EmitReturnOfRValue(RV, propType);\n\n    // objc_getProperty does an autorelease, so we should suppress ours.\n    AutoreleaseResult = false;\n\n    return;\n  }\n\n  case PropertyImplStrategy::CopyStruct:\n    emitStructGetterCall(*this, ivar, strategy.isAtomic(),\n                         strategy.hasStrongMember());\n    return;\n\n  case PropertyImplStrategy::Expression:\n  case PropertyImplStrategy::SetPropertyAndExpressionGet: {\n    LValue LV = EmitLValueForIvar(TypeOfSelfObject(), LoadObjCSelf(), ivar, 0);\n\n    QualType ivarType = ivar->getType();\n    switch (getEvaluationKind(ivarType)) {\n    case TEK_Complex: {\n      ComplexPairTy pair = EmitLoadOfComplex(LV, SourceLocation());\n      EmitStoreOfComplex(pair, MakeAddrLValue(ReturnValue, ivarType),\n                         /*init*/ true);\n      return;\n    }\n    case TEK_Aggregate: {\n      // The return value slot is guaranteed to not be aliased, but\n      // that's not necessarily the same as \"on the stack\", so\n      // we still potentially need objc_memmove_collectable.\n      EmitAggregateCopy(/* Dest= */ MakeAddrLValue(ReturnValue, ivarType),\n                        /* Src= */ LV, ivarType, getOverlapForReturnValue());\n      return;\n    }\n    case TEK_Scalar: {\n      llvm::Value *value;\n      if (propType->isReferenceType()) {\n        value = LV.getAddress(*this).getPointer();\n      } else {\n        // We want to load and autoreleaseReturnValue ARC __weak ivars.\n        if (LV.getQuals().getObjCLifetime() == Qualifiers::OCL_Weak) {\n          if (getLangOpts().ObjCAutoRefCount) {\n            value = emitARCRetainLoadOfScalar(*this, LV, ivarType);\n          } else {\n            value = EmitARCLoadWeak(LV.getAddress(*this));\n          }\n\n        // Otherwise we want to do a simple load, suppressing the\n        // final autorelease.\n        } else {\n          value = EmitLoadOfLValue(LV, SourceLocation()).getScalarVal();\n          AutoreleaseResult = false;\n        }\n\n        value = Builder.CreateBitCast(\n            value, ConvertType(GetterMethodDecl->getReturnType()));\n      }\n\n      EmitReturnOfRValue(RValue::get(value), propType);\n      return;\n    }\n    }\n    llvm_unreachable(\"bad evaluation kind\");\n  }\n\n  }\n  llvm_unreachable(\"bad @property implementation strategy!\");\n}\n\n/// emitStructSetterCall - Call the runtime function to store the value\n/// from the first formal parameter into the given ivar.\nstatic void emitStructSetterCall(CodeGenFunction &CGF, ObjCMethodDecl *OMD,\n                                 ObjCIvarDecl *ivar) {\n  // objc_copyStruct (&structIvar, &Arg,\n  //                  sizeof (struct something), true, false);\n  CallArgList args;\n\n  // The first argument is the address of the ivar.\n  llvm::Value *ivarAddr =\n      CGF.EmitLValueForIvar(CGF.TypeOfSelfObject(), CGF.LoadObjCSelf(), ivar, 0)\n          .getPointer(CGF);\n  ivarAddr = CGF.Builder.CreateBitCast(ivarAddr, CGF.Int8PtrTy);\n  args.add(RValue::get(ivarAddr), CGF.getContext().VoidPtrTy);\n\n  // The second argument is the address of the parameter variable.\n  ParmVarDecl *argVar = *OMD->param_begin();\n  DeclRefExpr argRef(CGF.getContext(), argVar, false,\n                     argVar->getType().getNonReferenceType(), VK_LValue,\n                     SourceLocation());\n  llvm::Value *argAddr = CGF.EmitLValue(&argRef).getPointer(CGF);\n  argAddr = CGF.Builder.CreateBitCast(argAddr, CGF.Int8PtrTy);\n  args.add(RValue::get(argAddr), CGF.getContext().VoidPtrTy);\n\n  // The third argument is the sizeof the type.\n  llvm::Value *size =\n    CGF.CGM.getSize(CGF.getContext().getTypeSizeInChars(ivar->getType()));\n  args.add(RValue::get(size), CGF.getContext().getSizeType());\n\n  // The fourth argument is the 'isAtomic' flag.\n  args.add(RValue::get(CGF.Builder.getTrue()), CGF.getContext().BoolTy);\n\n  // The fifth argument is the 'hasStrong' flag.\n  // FIXME: should this really always be false?\n  args.add(RValue::get(CGF.Builder.getFalse()), CGF.getContext().BoolTy);\n\n  llvm::FunctionCallee fn = CGF.CGM.getObjCRuntime().GetSetStructFunction();\n  CGCallee callee = CGCallee::forDirect(fn);\n  CGF.EmitCall(\n      CGF.getTypes().arrangeBuiltinFunctionCall(CGF.getContext().VoidTy, args),\n               callee, ReturnValueSlot(), args);\n}\n\n/// emitCPPObjectAtomicSetterCall - Call the runtime function to store\n/// the value from the first formal parameter into the given ivar, using\n/// the Cpp API for atomic Cpp objects with non-trivial copy assignment.\nstatic void emitCPPObjectAtomicSetterCall(CodeGenFunction &CGF,\n                                          ObjCMethodDecl *OMD,\n                                          ObjCIvarDecl *ivar,\n                                          llvm::Constant *AtomicHelperFn) {\n  // objc_copyCppObjectAtomic (&CppObjectIvar, &Arg,\n  //                           AtomicHelperFn);\n  CallArgList args;\n\n  // The first argument is the address of the ivar.\n  llvm::Value *ivarAddr =\n      CGF.EmitLValueForIvar(CGF.TypeOfSelfObject(), CGF.LoadObjCSelf(), ivar, 0)\n          .getPointer(CGF);\n  ivarAddr = CGF.Builder.CreateBitCast(ivarAddr, CGF.Int8PtrTy);\n  args.add(RValue::get(ivarAddr), CGF.getContext().VoidPtrTy);\n\n  // The second argument is the address of the parameter variable.\n  ParmVarDecl *argVar = *OMD->param_begin();\n  DeclRefExpr argRef(CGF.getContext(), argVar, false,\n                     argVar->getType().getNonReferenceType(), VK_LValue,\n                     SourceLocation());\n  llvm::Value *argAddr = CGF.EmitLValue(&argRef).getPointer(CGF);\n  argAddr = CGF.Builder.CreateBitCast(argAddr, CGF.Int8PtrTy);\n  args.add(RValue::get(argAddr), CGF.getContext().VoidPtrTy);\n\n  // Third argument is the helper function.\n  args.add(RValue::get(AtomicHelperFn), CGF.getContext().VoidPtrTy);\n\n  llvm::FunctionCallee fn =\n      CGF.CGM.getObjCRuntime().GetCppAtomicObjectSetFunction();\n  CGCallee callee = CGCallee::forDirect(fn);\n  CGF.EmitCall(\n      CGF.getTypes().arrangeBuiltinFunctionCall(CGF.getContext().VoidTy, args),\n               callee, ReturnValueSlot(), args);\n}\n\n\nstatic bool hasTrivialSetExpr(const ObjCPropertyImplDecl *PID) {\n  Expr *setter = PID->getSetterCXXAssignment();\n  if (!setter) return true;\n\n  // Sema only makes only of these when the ivar has a C++ class type,\n  // so the form is pretty constrained.\n\n  // An operator call is trivial if the function it calls is trivial.\n  // This also implies that there's nothing non-trivial going on with\n  // the arguments, because operator= can only be trivial if it's a\n  // synthesized assignment operator and therefore both parameters are\n  // references.\n  if (CallExpr *call = dyn_cast<CallExpr>(setter)) {\n    if (const FunctionDecl *callee\n          = dyn_cast_or_null<FunctionDecl>(call->getCalleeDecl()))\n      if (callee->isTrivial())\n        return true;\n    return false;\n  }\n\n  assert(isa<ExprWithCleanups>(setter));\n  return false;\n}\n\nstatic bool UseOptimizedSetter(CodeGenModule &CGM) {\n  if (CGM.getLangOpts().getGC() != LangOptions::NonGC)\n    return false;\n  return CGM.getLangOpts().ObjCRuntime.hasOptimizedSetter();\n}\n\nvoid\nCodeGenFunction::generateObjCSetterBody(const ObjCImplementationDecl *classImpl,\n                                        const ObjCPropertyImplDecl *propImpl,\n                                        llvm::Constant *AtomicHelperFn) {\n  ObjCIvarDecl *ivar = propImpl->getPropertyIvarDecl();\n  ObjCMethodDecl *setterMethod = propImpl->getSetterMethodDecl();\n\n  // Just use the setter expression if Sema gave us one and it's\n  // non-trivial.\n  if (!hasTrivialSetExpr(propImpl)) {\n    if (!AtomicHelperFn)\n      // If non-atomic, assignment is called directly.\n      EmitStmt(propImpl->getSetterCXXAssignment());\n    else\n      // If atomic, assignment is called via a locking api.\n      emitCPPObjectAtomicSetterCall(*this, setterMethod, ivar,\n                                    AtomicHelperFn);\n    return;\n  }\n\n  PropertyImplStrategy strategy(CGM, propImpl);\n  switch (strategy.getKind()) {\n  case PropertyImplStrategy::Native: {\n    // We don't need to do anything for a zero-size struct.\n    if (strategy.getIvarSize().isZero())\n      return;\n\n    Address argAddr = GetAddrOfLocalVar(*setterMethod->param_begin());\n\n    LValue ivarLValue =\n      EmitLValueForIvar(TypeOfSelfObject(), LoadObjCSelf(), ivar, /*quals*/ 0);\n    Address ivarAddr = ivarLValue.getAddress(*this);\n\n    // Currently, all atomic accesses have to be through integer\n    // types, so there's no point in trying to pick a prettier type.\n    llvm::Type *bitcastType =\n      llvm::Type::getIntNTy(getLLVMContext(),\n                            getContext().toBits(strategy.getIvarSize()));\n\n    // Cast both arguments to the chosen operation type.\n    argAddr = Builder.CreateElementBitCast(argAddr, bitcastType);\n    ivarAddr = Builder.CreateElementBitCast(ivarAddr, bitcastType);\n\n    // This bitcast load is likely to cause some nasty IR.\n    llvm::Value *load = Builder.CreateLoad(argAddr);\n\n    // Perform an atomic store.  There are no memory ordering requirements.\n    llvm::StoreInst *store = Builder.CreateStore(load, ivarAddr);\n    store->setAtomic(llvm::AtomicOrdering::Unordered);\n    return;\n  }\n\n  case PropertyImplStrategy::GetSetProperty:\n  case PropertyImplStrategy::SetPropertyAndExpressionGet: {\n\n    llvm::FunctionCallee setOptimizedPropertyFn = nullptr;\n    llvm::FunctionCallee setPropertyFn = nullptr;\n    if (UseOptimizedSetter(CGM)) {\n      // 10.8 and iOS 6.0 code and GC is off\n      setOptimizedPropertyFn =\n          CGM.getObjCRuntime().GetOptimizedPropertySetFunction(\n              strategy.isAtomic(), strategy.isCopy());\n      if (!setOptimizedPropertyFn) {\n        CGM.ErrorUnsupported(propImpl, \"Obj-C optimized setter - NYI\");\n        return;\n      }\n    }\n    else {\n      setPropertyFn = CGM.getObjCRuntime().GetPropertySetFunction();\n      if (!setPropertyFn) {\n        CGM.ErrorUnsupported(propImpl, \"Obj-C setter requiring atomic copy\");\n        return;\n      }\n    }\n\n    // Emit objc_setProperty((id) self, _cmd, offset, arg,\n    //                       <is-atomic>, <is-copy>).\n    llvm::Value *cmd =\n      Builder.CreateLoad(GetAddrOfLocalVar(setterMethod->getCmdDecl()));\n    llvm::Value *self =\n      Builder.CreateBitCast(LoadObjCSelf(), VoidPtrTy);\n    llvm::Value *ivarOffset =\n      EmitIvarOffset(classImpl->getClassInterface(), ivar);\n    Address argAddr = GetAddrOfLocalVar(*setterMethod->param_begin());\n    llvm::Value *arg = Builder.CreateLoad(argAddr, \"arg\");\n    arg = Builder.CreateBitCast(arg, VoidPtrTy);\n\n    CallArgList args;\n    args.add(RValue::get(self), getContext().getObjCIdType());\n    args.add(RValue::get(cmd), getContext().getObjCSelType());\n    if (setOptimizedPropertyFn) {\n      args.add(RValue::get(arg), getContext().getObjCIdType());\n      args.add(RValue::get(ivarOffset), getContext().getPointerDiffType());\n      CGCallee callee = CGCallee::forDirect(setOptimizedPropertyFn);\n      EmitCall(getTypes().arrangeBuiltinFunctionCall(getContext().VoidTy, args),\n               callee, ReturnValueSlot(), args);\n    } else {\n      args.add(RValue::get(ivarOffset), getContext().getPointerDiffType());\n      args.add(RValue::get(arg), getContext().getObjCIdType());\n      args.add(RValue::get(Builder.getInt1(strategy.isAtomic())),\n               getContext().BoolTy);\n      args.add(RValue::get(Builder.getInt1(strategy.isCopy())),\n               getContext().BoolTy);\n      // FIXME: We shouldn't need to get the function info here, the runtime\n      // already should have computed it to build the function.\n      CGCallee callee = CGCallee::forDirect(setPropertyFn);\n      EmitCall(getTypes().arrangeBuiltinFunctionCall(getContext().VoidTy, args),\n               callee, ReturnValueSlot(), args);\n    }\n\n    return;\n  }\n\n  case PropertyImplStrategy::CopyStruct:\n    emitStructSetterCall(*this, setterMethod, ivar);\n    return;\n\n  case PropertyImplStrategy::Expression:\n    break;\n  }\n\n  // Otherwise, fake up some ASTs and emit a normal assignment.\n  ValueDecl *selfDecl = setterMethod->getSelfDecl();\n  DeclRefExpr self(getContext(), selfDecl, false, selfDecl->getType(),\n                   VK_LValue, SourceLocation());\n  ImplicitCastExpr selfLoad(ImplicitCastExpr::OnStack, selfDecl->getType(),\n                            CK_LValueToRValue, &self, VK_RValue,\n                            FPOptionsOverride());\n  ObjCIvarRefExpr ivarRef(ivar, ivar->getType().getNonReferenceType(),\n                          SourceLocation(), SourceLocation(),\n                          &selfLoad, true, true);\n\n  ParmVarDecl *argDecl = *setterMethod->param_begin();\n  QualType argType = argDecl->getType().getNonReferenceType();\n  DeclRefExpr arg(getContext(), argDecl, false, argType, VK_LValue,\n                  SourceLocation());\n  ImplicitCastExpr argLoad(ImplicitCastExpr::OnStack,\n                           argType.getUnqualifiedType(), CK_LValueToRValue,\n                           &arg, VK_RValue, FPOptionsOverride());\n\n  // The property type can differ from the ivar type in some situations with\n  // Objective-C pointer types, we can always bit cast the RHS in these cases.\n  // The following absurdity is just to ensure well-formed IR.\n  CastKind argCK = CK_NoOp;\n  if (ivarRef.getType()->isObjCObjectPointerType()) {\n    if (argLoad.getType()->isObjCObjectPointerType())\n      argCK = CK_BitCast;\n    else if (argLoad.getType()->isBlockPointerType())\n      argCK = CK_BlockPointerToObjCPointerCast;\n    else\n      argCK = CK_CPointerToObjCPointerCast;\n  } else if (ivarRef.getType()->isBlockPointerType()) {\n     if (argLoad.getType()->isBlockPointerType())\n      argCK = CK_BitCast;\n    else\n      argCK = CK_AnyPointerToBlockPointerCast;\n  } else if (ivarRef.getType()->isPointerType()) {\n    argCK = CK_BitCast;\n  }\n  ImplicitCastExpr argCast(ImplicitCastExpr::OnStack, ivarRef.getType(), argCK,\n                           &argLoad, VK_RValue, FPOptionsOverride());\n  Expr *finalArg = &argLoad;\n  if (!getContext().hasSameUnqualifiedType(ivarRef.getType(),\n                                           argLoad.getType()))\n    finalArg = &argCast;\n\n  BinaryOperator *assign = BinaryOperator::Create(\n      getContext(), &ivarRef, finalArg, BO_Assign, ivarRef.getType(), VK_RValue,\n      OK_Ordinary, SourceLocation(), FPOptionsOverride());\n  EmitStmt(assign);\n}\n\n/// Generate an Objective-C property setter function.\n///\n/// The given Decl must be an ObjCImplementationDecl. \\@synthesize\n/// is illegal within a category.\nvoid CodeGenFunction::GenerateObjCSetter(ObjCImplementationDecl *IMP,\n                                         const ObjCPropertyImplDecl *PID) {\n  llvm::Constant *AtomicHelperFn =\n      CodeGenFunction(CGM).GenerateObjCAtomicSetterCopyHelperFunction(PID);\n  ObjCMethodDecl *OMD = PID->getSetterMethodDecl();\n  assert(OMD && \"Invalid call to generate setter (empty method)\");\n  StartObjCMethod(OMD, IMP->getClassInterface());\n\n  generateObjCSetterBody(IMP, PID, AtomicHelperFn);\n\n  FinishFunction(OMD->getEndLoc());\n}\n\nnamespace {\n  struct DestroyIvar final : EHScopeStack::Cleanup {\n  private:\n    llvm::Value *addr;\n    const ObjCIvarDecl *ivar;\n    CodeGenFunction::Destroyer *destroyer;\n    bool useEHCleanupForArray;\n  public:\n    DestroyIvar(llvm::Value *addr, const ObjCIvarDecl *ivar,\n                CodeGenFunction::Destroyer *destroyer,\n                bool useEHCleanupForArray)\n      : addr(addr), ivar(ivar), destroyer(destroyer),\n        useEHCleanupForArray(useEHCleanupForArray) {}\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      LValue lvalue\n        = CGF.EmitLValueForIvar(CGF.TypeOfSelfObject(), addr, ivar, /*CVR*/ 0);\n      CGF.emitDestroy(lvalue.getAddress(CGF), ivar->getType(), destroyer,\n                      flags.isForNormalCleanup() && useEHCleanupForArray);\n    }\n  };\n}\n\n/// Like CodeGenFunction::destroyARCStrong, but do it with a call.\nstatic void destroyARCStrongWithStore(CodeGenFunction &CGF,\n                                      Address addr,\n                                      QualType type) {\n  llvm::Value *null = getNullForVariable(addr);\n  CGF.EmitARCStoreStrongCall(addr, null, /*ignored*/ true);\n}\n\nstatic void emitCXXDestructMethod(CodeGenFunction &CGF,\n                                  ObjCImplementationDecl *impl) {\n  CodeGenFunction::RunCleanupsScope scope(CGF);\n\n  llvm::Value *self = CGF.LoadObjCSelf();\n\n  const ObjCInterfaceDecl *iface = impl->getClassInterface();\n  for (const ObjCIvarDecl *ivar = iface->all_declared_ivar_begin();\n       ivar; ivar = ivar->getNextIvar()) {\n    QualType type = ivar->getType();\n\n    // Check whether the ivar is a destructible type.\n    QualType::DestructionKind dtorKind = type.isDestructedType();\n    if (!dtorKind) continue;\n\n    CodeGenFunction::Destroyer *destroyer = nullptr;\n\n    // Use a call to objc_storeStrong to destroy strong ivars, for the\n    // general benefit of the tools.\n    if (dtorKind == QualType::DK_objc_strong_lifetime) {\n      destroyer = destroyARCStrongWithStore;\n\n    // Otherwise use the default for the destruction kind.\n    } else {\n      destroyer = CGF.getDestroyer(dtorKind);\n    }\n\n    CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind);\n\n    CGF.EHStack.pushCleanup<DestroyIvar>(cleanupKind, self, ivar, destroyer,\n                                         cleanupKind & EHCleanup);\n  }\n\n  assert(scope.requiresCleanups() && \"nothing to do in .cxx_destruct?\");\n}\n\nvoid CodeGenFunction::GenerateObjCCtorDtorMethod(ObjCImplementationDecl *IMP,\n                                                 ObjCMethodDecl *MD,\n                                                 bool ctor) {\n  MD->createImplicitParams(CGM.getContext(), IMP->getClassInterface());\n  StartObjCMethod(MD, IMP->getClassInterface());\n\n  // Emit .cxx_construct.\n  if (ctor) {\n    // Suppress the final autorelease in ARC.\n    AutoreleaseResult = false;\n\n    for (const auto *IvarInit : IMP->inits()) {\n      FieldDecl *Field = IvarInit->getAnyMember();\n      ObjCIvarDecl *Ivar = cast<ObjCIvarDecl>(Field);\n      LValue LV = EmitLValueForIvar(TypeOfSelfObject(),\n                                    LoadObjCSelf(), Ivar, 0);\n      EmitAggExpr(IvarInit->getInit(),\n                  AggValueSlot::forLValue(LV, *this, AggValueSlot::IsDestructed,\n                                          AggValueSlot::DoesNotNeedGCBarriers,\n                                          AggValueSlot::IsNotAliased,\n                                          AggValueSlot::DoesNotOverlap));\n    }\n    // constructor returns 'self'.\n    CodeGenTypes &Types = CGM.getTypes();\n    QualType IdTy(CGM.getContext().getObjCIdType());\n    llvm::Value *SelfAsId =\n      Builder.CreateBitCast(LoadObjCSelf(), Types.ConvertType(IdTy));\n    EmitReturnOfRValue(RValue::get(SelfAsId), IdTy);\n\n  // Emit .cxx_destruct.\n  } else {\n    emitCXXDestructMethod(*this, IMP);\n  }\n  FinishFunction();\n}\n\nllvm::Value *CodeGenFunction::LoadObjCSelf() {\n  VarDecl *Self = cast<ObjCMethodDecl>(CurFuncDecl)->getSelfDecl();\n  DeclRefExpr DRE(getContext(), Self,\n                  /*is enclosing local*/ (CurFuncDecl != CurCodeDecl),\n                  Self->getType(), VK_LValue, SourceLocation());\n  return EmitLoadOfScalar(EmitDeclRefLValue(&DRE), SourceLocation());\n}\n\nQualType CodeGenFunction::TypeOfSelfObject() {\n  const ObjCMethodDecl *OMD = cast<ObjCMethodDecl>(CurFuncDecl);\n  ImplicitParamDecl *selfDecl = OMD->getSelfDecl();\n  const ObjCObjectPointerType *PTy = cast<ObjCObjectPointerType>(\n    getContext().getCanonicalType(selfDecl->getType()));\n  return PTy->getPointeeType();\n}\n\nvoid CodeGenFunction::EmitObjCForCollectionStmt(const ObjCForCollectionStmt &S){\n  llvm::FunctionCallee EnumerationMutationFnPtr =\n      CGM.getObjCRuntime().EnumerationMutationFunction();\n  if (!EnumerationMutationFnPtr) {\n    CGM.ErrorUnsupported(&S, \"Obj-C fast enumeration for this runtime\");\n    return;\n  }\n  CGCallee EnumerationMutationFn =\n    CGCallee::forDirect(EnumerationMutationFnPtr);\n\n  CGDebugInfo *DI = getDebugInfo();\n  if (DI)\n    DI->EmitLexicalBlockStart(Builder, S.getSourceRange().getBegin());\n\n  RunCleanupsScope ForScope(*this);\n\n  // The local variable comes into scope immediately.\n  AutoVarEmission variable = AutoVarEmission::invalid();\n  if (const DeclStmt *SD = dyn_cast<DeclStmt>(S.getElement()))\n    variable = EmitAutoVarAlloca(*cast<VarDecl>(SD->getSingleDecl()));\n\n  JumpDest LoopEnd = getJumpDestInCurrentScope(\"forcoll.end\");\n\n  // Fast enumeration state.\n  QualType StateTy = CGM.getObjCFastEnumerationStateType();\n  Address StatePtr = CreateMemTemp(StateTy, \"state.ptr\");\n  EmitNullInitialization(StatePtr, StateTy);\n\n  // Number of elements in the items array.\n  static const unsigned NumItems = 16;\n\n  // Fetch the countByEnumeratingWithState:objects:count: selector.\n  IdentifierInfo *II[] = {\n    &CGM.getContext().Idents.get(\"countByEnumeratingWithState\"),\n    &CGM.getContext().Idents.get(\"objects\"),\n    &CGM.getContext().Idents.get(\"count\")\n  };\n  Selector FastEnumSel =\n    CGM.getContext().Selectors.getSelector(llvm::array_lengthof(II), &II[0]);\n\n  QualType ItemsTy =\n    getContext().getConstantArrayType(getContext().getObjCIdType(),\n                                      llvm::APInt(32, NumItems), nullptr,\n                                      ArrayType::Normal, 0);\n  Address ItemsPtr = CreateMemTemp(ItemsTy, \"items.ptr\");\n\n  // Emit the collection pointer.  In ARC, we do a retain.\n  llvm::Value *Collection;\n  if (getLangOpts().ObjCAutoRefCount) {\n    Collection = EmitARCRetainScalarExpr(S.getCollection());\n\n    // Enter a cleanup to do the release.\n    EmitObjCConsumeObject(S.getCollection()->getType(), Collection);\n  } else {\n    Collection = EmitScalarExpr(S.getCollection());\n  }\n\n  // The 'continue' label needs to appear within the cleanup for the\n  // collection object.\n  JumpDest AfterBody = getJumpDestInCurrentScope(\"forcoll.next\");\n\n  // Send it our message:\n  CallArgList Args;\n\n  // The first argument is a temporary of the enumeration-state type.\n  Args.add(RValue::get(StatePtr.getPointer()),\n           getContext().getPointerType(StateTy));\n\n  // The second argument is a temporary array with space for NumItems\n  // pointers.  We'll actually be loading elements from the array\n  // pointer written into the control state; this buffer is so that\n  // collections that *aren't* backed by arrays can still queue up\n  // batches of elements.\n  Args.add(RValue::get(ItemsPtr.getPointer()),\n           getContext().getPointerType(ItemsTy));\n\n  // The third argument is the capacity of that temporary array.\n  llvm::Type *NSUIntegerTy = ConvertType(getContext().getNSUIntegerType());\n  llvm::Constant *Count = llvm::ConstantInt::get(NSUIntegerTy, NumItems);\n  Args.add(RValue::get(Count), getContext().getNSUIntegerType());\n\n  // Start the enumeration.\n  RValue CountRV =\n      CGM.getObjCRuntime().GenerateMessageSend(*this, ReturnValueSlot(),\n                                               getContext().getNSUIntegerType(),\n                                               FastEnumSel, Collection, Args);\n\n  // The initial number of objects that were returned in the buffer.\n  llvm::Value *initialBufferLimit = CountRV.getScalarVal();\n\n  llvm::BasicBlock *EmptyBB = createBasicBlock(\"forcoll.empty\");\n  llvm::BasicBlock *LoopInitBB = createBasicBlock(\"forcoll.loopinit\");\n\n  llvm::Value *zero = llvm::Constant::getNullValue(NSUIntegerTy);\n\n  // If the limit pointer was zero to begin with, the collection is\n  // empty; skip all this. Set the branch weight assuming this has the same\n  // probability of exiting the loop as any other loop exit.\n  uint64_t EntryCount = getCurrentProfileCount();\n  Builder.CreateCondBr(\n      Builder.CreateICmpEQ(initialBufferLimit, zero, \"iszero\"), EmptyBB,\n      LoopInitBB,\n      createProfileWeights(EntryCount, getProfileCount(S.getBody())));\n\n  // Otherwise, initialize the loop.\n  EmitBlock(LoopInitBB);\n\n  // Save the initial mutations value.  This is the value at an\n  // address that was written into the state object by\n  // countByEnumeratingWithState:objects:count:.\n  Address StateMutationsPtrPtr =\n      Builder.CreateStructGEP(StatePtr, 2, \"mutationsptr.ptr\");\n  llvm::Value *StateMutationsPtr\n    = Builder.CreateLoad(StateMutationsPtrPtr, \"mutationsptr\");\n\n  llvm::Type *UnsignedLongTy = ConvertType(getContext().UnsignedLongTy);\n  llvm::Value *initialMutations =\n    Builder.CreateAlignedLoad(UnsignedLongTy, StateMutationsPtr,\n                              getPointerAlign(), \"forcoll.initial-mutations\");\n\n  // Start looping.  This is the point we return to whenever we have a\n  // fresh, non-empty batch of objects.\n  llvm::BasicBlock *LoopBodyBB = createBasicBlock(\"forcoll.loopbody\");\n  EmitBlock(LoopBodyBB);\n\n  // The current index into the buffer.\n  llvm::PHINode *index = Builder.CreatePHI(NSUIntegerTy, 3, \"forcoll.index\");\n  index->addIncoming(zero, LoopInitBB);\n\n  // The current buffer size.\n  llvm::PHINode *count = Builder.CreatePHI(NSUIntegerTy, 3, \"forcoll.count\");\n  count->addIncoming(initialBufferLimit, LoopInitBB);\n\n  incrementProfileCounter(&S);\n\n  // Check whether the mutations value has changed from where it was\n  // at start.  StateMutationsPtr should actually be invariant between\n  // refreshes.\n  StateMutationsPtr = Builder.CreateLoad(StateMutationsPtrPtr, \"mutationsptr\");\n  llvm::Value *currentMutations\n    = Builder.CreateAlignedLoad(UnsignedLongTy, StateMutationsPtr,\n                                getPointerAlign(), \"statemutations\");\n\n  llvm::BasicBlock *WasMutatedBB = createBasicBlock(\"forcoll.mutated\");\n  llvm::BasicBlock *WasNotMutatedBB = createBasicBlock(\"forcoll.notmutated\");\n\n  Builder.CreateCondBr(Builder.CreateICmpEQ(currentMutations, initialMutations),\n                       WasNotMutatedBB, WasMutatedBB);\n\n  // If so, call the enumeration-mutation function.\n  EmitBlock(WasMutatedBB);\n  llvm::Type *ObjCIdType = ConvertType(getContext().getObjCIdType());\n  llvm::Value *V =\n    Builder.CreateBitCast(Collection, ObjCIdType);\n  CallArgList Args2;\n  Args2.add(RValue::get(V), getContext().getObjCIdType());\n  // FIXME: We shouldn't need to get the function info here, the runtime already\n  // should have computed it to build the function.\n  EmitCall(\n          CGM.getTypes().arrangeBuiltinFunctionCall(getContext().VoidTy, Args2),\n           EnumerationMutationFn, ReturnValueSlot(), Args2);\n\n  // Otherwise, or if the mutation function returns, just continue.\n  EmitBlock(WasNotMutatedBB);\n\n  // Initialize the element variable.\n  RunCleanupsScope elementVariableScope(*this);\n  bool elementIsVariable;\n  LValue elementLValue;\n  QualType elementType;\n  if (const DeclStmt *SD = dyn_cast<DeclStmt>(S.getElement())) {\n    // Initialize the variable, in case it's a __block variable or something.\n    EmitAutoVarInit(variable);\n\n    const VarDecl *D = cast<VarDecl>(SD->getSingleDecl());\n    DeclRefExpr tempDRE(getContext(), const_cast<VarDecl *>(D), false,\n                        D->getType(), VK_LValue, SourceLocation());\n    elementLValue = EmitLValue(&tempDRE);\n    elementType = D->getType();\n    elementIsVariable = true;\n\n    if (D->isARCPseudoStrong())\n      elementLValue.getQuals().setObjCLifetime(Qualifiers::OCL_ExplicitNone);\n  } else {\n    elementLValue = LValue(); // suppress warning\n    elementType = cast<Expr>(S.getElement())->getType();\n    elementIsVariable = false;\n  }\n  llvm::Type *convertedElementType = ConvertType(elementType);\n\n  // Fetch the buffer out of the enumeration state.\n  // TODO: this pointer should actually be invariant between\n  // refreshes, which would help us do certain loop optimizations.\n  Address StateItemsPtr =\n      Builder.CreateStructGEP(StatePtr, 1, \"stateitems.ptr\");\n  llvm::Value *EnumStateItems =\n    Builder.CreateLoad(StateItemsPtr, \"stateitems\");\n\n  // Fetch the value at the current index from the buffer.\n  llvm::Value *CurrentItemPtr =\n    Builder.CreateGEP(EnumStateItems, index, \"currentitem.ptr\");\n  llvm::Value *CurrentItem =\n    Builder.CreateAlignedLoad(ObjCIdType, CurrentItemPtr, getPointerAlign());\n\n  if (SanOpts.has(SanitizerKind::ObjCCast)) {\n    // Before using an item from the collection, check that the implicit cast\n    // from id to the element type is valid. This is done with instrumentation\n    // roughly corresponding to:\n    //\n    //   if (![item isKindOfClass:expectedCls]) { /* emit diagnostic */ }\n    const ObjCObjectPointerType *ObjPtrTy =\n        elementType->getAsObjCInterfacePointerType();\n    const ObjCInterfaceType *InterfaceTy =\n        ObjPtrTy ? ObjPtrTy->getInterfaceType() : nullptr;\n    if (InterfaceTy) {\n      SanitizerScope SanScope(this);\n      auto &C = CGM.getContext();\n      assert(InterfaceTy->getDecl() && \"No decl for ObjC interface type\");\n      Selector IsKindOfClassSel = GetUnarySelector(\"isKindOfClass\", C);\n      CallArgList IsKindOfClassArgs;\n      llvm::Value *Cls =\n          CGM.getObjCRuntime().GetClass(*this, InterfaceTy->getDecl());\n      IsKindOfClassArgs.add(RValue::get(Cls), C.getObjCClassType());\n      llvm::Value *IsClass =\n          CGM.getObjCRuntime()\n              .GenerateMessageSend(*this, ReturnValueSlot(), C.BoolTy,\n                                   IsKindOfClassSel, CurrentItem,\n                                   IsKindOfClassArgs)\n              .getScalarVal();\n      llvm::Constant *StaticData[] = {\n          EmitCheckSourceLocation(S.getBeginLoc()),\n          EmitCheckTypeDescriptor(QualType(InterfaceTy, 0))};\n      EmitCheck({{IsClass, SanitizerKind::ObjCCast}},\n                SanitizerHandler::InvalidObjCCast,\n                ArrayRef<llvm::Constant *>(StaticData), CurrentItem);\n    }\n  }\n\n  // Cast that value to the right type.\n  CurrentItem = Builder.CreateBitCast(CurrentItem, convertedElementType,\n                                      \"currentitem\");\n\n  // Make sure we have an l-value.  Yes, this gets evaluated every\n  // time through the loop.\n  if (!elementIsVariable) {\n    elementLValue = EmitLValue(cast<Expr>(S.getElement()));\n    EmitStoreThroughLValue(RValue::get(CurrentItem), elementLValue);\n  } else {\n    EmitStoreThroughLValue(RValue::get(CurrentItem), elementLValue,\n                           /*isInit*/ true);\n  }\n\n  // If we do have an element variable, this assignment is the end of\n  // its initialization.\n  if (elementIsVariable)\n    EmitAutoVarCleanups(variable);\n\n  // Perform the loop body, setting up break and continue labels.\n  BreakContinueStack.push_back(BreakContinue(LoopEnd, AfterBody));\n  {\n    RunCleanupsScope Scope(*this);\n    EmitStmt(S.getBody());\n  }\n  BreakContinueStack.pop_back();\n\n  // Destroy the element variable now.\n  elementVariableScope.ForceCleanup();\n\n  // Check whether there are more elements.\n  EmitBlock(AfterBody.getBlock());\n\n  llvm::BasicBlock *FetchMoreBB = createBasicBlock(\"forcoll.refetch\");\n\n  // First we check in the local buffer.\n  llvm::Value *indexPlusOne =\n      Builder.CreateAdd(index, llvm::ConstantInt::get(NSUIntegerTy, 1));\n\n  // If we haven't overrun the buffer yet, we can continue.\n  // Set the branch weights based on the simplifying assumption that this is\n  // like a while-loop, i.e., ignoring that the false branch fetches more\n  // elements and then returns to the loop.\n  Builder.CreateCondBr(\n      Builder.CreateICmpULT(indexPlusOne, count), LoopBodyBB, FetchMoreBB,\n      createProfileWeights(getProfileCount(S.getBody()), EntryCount));\n\n  index->addIncoming(indexPlusOne, AfterBody.getBlock());\n  count->addIncoming(count, AfterBody.getBlock());\n\n  // Otherwise, we have to fetch more elements.\n  EmitBlock(FetchMoreBB);\n\n  CountRV =\n      CGM.getObjCRuntime().GenerateMessageSend(*this, ReturnValueSlot(),\n                                               getContext().getNSUIntegerType(),\n                                               FastEnumSel, Collection, Args);\n\n  // If we got a zero count, we're done.\n  llvm::Value *refetchCount = CountRV.getScalarVal();\n\n  // (note that the message send might split FetchMoreBB)\n  index->addIncoming(zero, Builder.GetInsertBlock());\n  count->addIncoming(refetchCount, Builder.GetInsertBlock());\n\n  Builder.CreateCondBr(Builder.CreateICmpEQ(refetchCount, zero),\n                       EmptyBB, LoopBodyBB);\n\n  // No more elements.\n  EmitBlock(EmptyBB);\n\n  if (!elementIsVariable) {\n    // If the element was not a declaration, set it to be null.\n\n    llvm::Value *null = llvm::Constant::getNullValue(convertedElementType);\n    elementLValue = EmitLValue(cast<Expr>(S.getElement()));\n    EmitStoreThroughLValue(RValue::get(null), elementLValue);\n  }\n\n  if (DI)\n    DI->EmitLexicalBlockEnd(Builder, S.getSourceRange().getEnd());\n\n  ForScope.ForceCleanup();\n  EmitBlock(LoopEnd.getBlock());\n}\n\nvoid CodeGenFunction::EmitObjCAtTryStmt(const ObjCAtTryStmt &S) {\n  CGM.getObjCRuntime().EmitTryStmt(*this, S);\n}\n\nvoid CodeGenFunction::EmitObjCAtThrowStmt(const ObjCAtThrowStmt &S) {\n  CGM.getObjCRuntime().EmitThrowStmt(*this, S);\n}\n\nvoid CodeGenFunction::EmitObjCAtSynchronizedStmt(\n                                              const ObjCAtSynchronizedStmt &S) {\n  CGM.getObjCRuntime().EmitSynchronizedStmt(*this, S);\n}\n\nnamespace {\n  struct CallObjCRelease final : EHScopeStack::Cleanup {\n    CallObjCRelease(llvm::Value *object) : object(object) {}\n    llvm::Value *object;\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      // Releases at the end of the full-expression are imprecise.\n      CGF.EmitARCRelease(object, ARCImpreciseLifetime);\n    }\n  };\n}\n\n/// Produce the code for a CK_ARCConsumeObject.  Does a primitive\n/// release at the end of the full-expression.\nllvm::Value *CodeGenFunction::EmitObjCConsumeObject(QualType type,\n                                                    llvm::Value *object) {\n  // If we're in a conditional branch, we need to make the cleanup\n  // conditional.\n  pushFullExprCleanup<CallObjCRelease>(getARCCleanupKind(), object);\n  return object;\n}\n\nllvm::Value *CodeGenFunction::EmitObjCExtendObjectLifetime(QualType type,\n                                                           llvm::Value *value) {\n  return EmitARCRetainAutorelease(type, value);\n}\n\n/// Given a number of pointers, inform the optimizer that they're\n/// being intrinsically used up until this point in the program.\nvoid CodeGenFunction::EmitARCIntrinsicUse(ArrayRef<llvm::Value*> values) {\n  llvm::Function *&fn = CGM.getObjCEntrypoints().clang_arc_use;\n  if (!fn)\n    fn = CGM.getIntrinsic(llvm::Intrinsic::objc_clang_arc_use);\n\n  // This isn't really a \"runtime\" function, but as an intrinsic it\n  // doesn't really matter as long as we align things up.\n  EmitNounwindRuntimeCall(fn, values);\n}\n\n/// Emit a call to \"clang.arc.noop.use\", which consumes the result of a call\n/// that has operand bundle \"clang.arc.attachedcall\".\nvoid CodeGenFunction::EmitARCNoopIntrinsicUse(ArrayRef<llvm::Value *> values) {\n  llvm::Function *&fn = CGM.getObjCEntrypoints().clang_arc_noop_use;\n  if (!fn)\n    fn = CGM.getIntrinsic(llvm::Intrinsic::objc_clang_arc_noop_use);\n  EmitNounwindRuntimeCall(fn, values);\n}\n\nstatic void setARCRuntimeFunctionLinkage(CodeGenModule &CGM, llvm::Value *RTF) {\n  if (auto *F = dyn_cast<llvm::Function>(RTF)) {\n    // If the target runtime doesn't naturally support ARC, emit weak\n    // references to the runtime support library.  We don't really\n    // permit this to fail, but we need a particular relocation style.\n    if (!CGM.getLangOpts().ObjCRuntime.hasNativeARC() &&\n        !CGM.getTriple().isOSBinFormatCOFF()) {\n      F->setLinkage(llvm::Function::ExternalWeakLinkage);\n    }\n  }\n}\n\nstatic void setARCRuntimeFunctionLinkage(CodeGenModule &CGM,\n                                         llvm::FunctionCallee RTF) {\n  setARCRuntimeFunctionLinkage(CGM, RTF.getCallee());\n}\n\n/// Perform an operation having the signature\n///   i8* (i8*)\n/// where a null input causes a no-op and returns null.\nstatic llvm::Value *emitARCValueOperation(\n    CodeGenFunction &CGF, llvm::Value *value, llvm::Type *returnType,\n    llvm::Function *&fn, llvm::Intrinsic::ID IntID,\n    llvm::CallInst::TailCallKind tailKind = llvm::CallInst::TCK_None) {\n  if (isa<llvm::ConstantPointerNull>(value))\n    return value;\n\n  if (!fn) {\n    fn = CGF.CGM.getIntrinsic(IntID);\n    setARCRuntimeFunctionLinkage(CGF.CGM, fn);\n  }\n\n  // Cast the argument to 'id'.\n  llvm::Type *origType = returnType ? returnType : value->getType();\n  value = CGF.Builder.CreateBitCast(value, CGF.Int8PtrTy);\n\n  // Call the function.\n  llvm::CallInst *call = CGF.EmitNounwindRuntimeCall(fn, value);\n  call->setTailCallKind(tailKind);\n\n  // Cast the result back to the original type.\n  return CGF.Builder.CreateBitCast(call, origType);\n}\n\n/// Perform an operation having the following signature:\n///   i8* (i8**)\nstatic llvm::Value *emitARCLoadOperation(CodeGenFunction &CGF, Address addr,\n                                         llvm::Function *&fn,\n                                         llvm::Intrinsic::ID IntID) {\n  if (!fn) {\n    fn = CGF.CGM.getIntrinsic(IntID);\n    setARCRuntimeFunctionLinkage(CGF.CGM, fn);\n  }\n\n  // Cast the argument to 'id*'.\n  llvm::Type *origType = addr.getElementType();\n  addr = CGF.Builder.CreateBitCast(addr, CGF.Int8PtrPtrTy);\n\n  // Call the function.\n  llvm::Value *result = CGF.EmitNounwindRuntimeCall(fn, addr.getPointer());\n\n  // Cast the result back to a dereference of the original type.\n  if (origType != CGF.Int8PtrTy)\n    result = CGF.Builder.CreateBitCast(result, origType);\n\n  return result;\n}\n\n/// Perform an operation having the following signature:\n///   i8* (i8**, i8*)\nstatic llvm::Value *emitARCStoreOperation(CodeGenFunction &CGF, Address addr,\n                                          llvm::Value *value,\n                                          llvm::Function *&fn,\n                                          llvm::Intrinsic::ID IntID,\n                                          bool ignored) {\n  assert(addr.getElementType() == value->getType());\n\n  if (!fn) {\n    fn = CGF.CGM.getIntrinsic(IntID);\n    setARCRuntimeFunctionLinkage(CGF.CGM, fn);\n  }\n\n  llvm::Type *origType = value->getType();\n\n  llvm::Value *args[] = {\n    CGF.Builder.CreateBitCast(addr.getPointer(), CGF.Int8PtrPtrTy),\n    CGF.Builder.CreateBitCast(value, CGF.Int8PtrTy)\n  };\n  llvm::CallInst *result = CGF.EmitNounwindRuntimeCall(fn, args);\n\n  if (ignored) return nullptr;\n\n  return CGF.Builder.CreateBitCast(result, origType);\n}\n\n/// Perform an operation having the following signature:\n///   void (i8**, i8**)\nstatic void emitARCCopyOperation(CodeGenFunction &CGF, Address dst, Address src,\n                                 llvm::Function *&fn,\n                                 llvm::Intrinsic::ID IntID) {\n  assert(dst.getType() == src.getType());\n\n  if (!fn) {\n    fn = CGF.CGM.getIntrinsic(IntID);\n    setARCRuntimeFunctionLinkage(CGF.CGM, fn);\n  }\n\n  llvm::Value *args[] = {\n    CGF.Builder.CreateBitCast(dst.getPointer(), CGF.Int8PtrPtrTy),\n    CGF.Builder.CreateBitCast(src.getPointer(), CGF.Int8PtrPtrTy)\n  };\n  CGF.EmitNounwindRuntimeCall(fn, args);\n}\n\n/// Perform an operation having the signature\n///   i8* (i8*)\n/// where a null input causes a no-op and returns null.\nstatic llvm::Value *emitObjCValueOperation(CodeGenFunction &CGF,\n                                           llvm::Value *value,\n                                           llvm::Type *returnType,\n                                           llvm::FunctionCallee &fn,\n                                           StringRef fnName) {\n  if (isa<llvm::ConstantPointerNull>(value))\n    return value;\n\n  if (!fn) {\n    llvm::FunctionType *fnType =\n      llvm::FunctionType::get(CGF.Int8PtrTy, CGF.Int8PtrTy, false);\n    fn = CGF.CGM.CreateRuntimeFunction(fnType, fnName);\n\n    // We have Native ARC, so set nonlazybind attribute for performance\n    if (llvm::Function *f = dyn_cast<llvm::Function>(fn.getCallee()))\n      if (fnName == \"objc_retain\")\n        f->addFnAttr(llvm::Attribute::NonLazyBind);\n  }\n\n  // Cast the argument to 'id'.\n  llvm::Type *origType = returnType ? returnType : value->getType();\n  value = CGF.Builder.CreateBitCast(value, CGF.Int8PtrTy);\n\n  // Call the function.\n  llvm::CallBase *Inst = CGF.EmitCallOrInvoke(fn, value);\n\n  // Mark calls to objc_autorelease as tail on the assumption that methods\n  // overriding autorelease do not touch anything on the stack.\n  if (fnName == \"objc_autorelease\")\n    if (auto *Call = dyn_cast<llvm::CallInst>(Inst))\n      Call->setTailCall();\n\n  // Cast the result back to the original type.\n  return CGF.Builder.CreateBitCast(Inst, origType);\n}\n\n/// Produce the code to do a retain.  Based on the type, calls one of:\n///   call i8* \\@objc_retain(i8* %value)\n///   call i8* \\@objc_retainBlock(i8* %value)\nllvm::Value *CodeGenFunction::EmitARCRetain(QualType type, llvm::Value *value) {\n  if (type->isBlockPointerType())\n    return EmitARCRetainBlock(value, /*mandatory*/ false);\n  else\n    return EmitARCRetainNonBlock(value);\n}\n\n/// Retain the given object, with normal retain semantics.\n///   call i8* \\@objc_retain(i8* %value)\nllvm::Value *CodeGenFunction::EmitARCRetainNonBlock(llvm::Value *value) {\n  return emitARCValueOperation(*this, value, nullptr,\n                               CGM.getObjCEntrypoints().objc_retain,\n                               llvm::Intrinsic::objc_retain);\n}\n\n/// Retain the given block, with _Block_copy semantics.\n///   call i8* \\@objc_retainBlock(i8* %value)\n///\n/// \\param mandatory - If false, emit the call with metadata\n/// indicating that it's okay for the optimizer to eliminate this call\n/// if it can prove that the block never escapes except down the stack.\nllvm::Value *CodeGenFunction::EmitARCRetainBlock(llvm::Value *value,\n                                                 bool mandatory) {\n  llvm::Value *result\n    = emitARCValueOperation(*this, value, nullptr,\n                            CGM.getObjCEntrypoints().objc_retainBlock,\n                            llvm::Intrinsic::objc_retainBlock);\n\n  // If the copy isn't mandatory, add !clang.arc.copy_on_escape to\n  // tell the optimizer that it doesn't need to do this copy if the\n  // block doesn't escape, where being passed as an argument doesn't\n  // count as escaping.\n  if (!mandatory && isa<llvm::Instruction>(result)) {\n    llvm::CallInst *call\n      = cast<llvm::CallInst>(result->stripPointerCasts());\n    assert(call->getCalledOperand() ==\n           CGM.getObjCEntrypoints().objc_retainBlock);\n\n    call->setMetadata(\"clang.arc.copy_on_escape\",\n                      llvm::MDNode::get(Builder.getContext(), None));\n  }\n\n  return result;\n}\n\nstatic void emitAutoreleasedReturnValueMarker(CodeGenFunction &CGF) {\n  // Fetch the void(void) inline asm which marks that we're going to\n  // do something with the autoreleased return value.\n  llvm::InlineAsm *&marker\n    = CGF.CGM.getObjCEntrypoints().retainAutoreleasedReturnValueMarker;\n  if (!marker) {\n    StringRef assembly\n      = CGF.CGM.getTargetCodeGenInfo()\n           .getARCRetainAutoreleasedReturnValueMarker();\n\n    // If we have an empty assembly string, there's nothing to do.\n    if (assembly.empty()) {\n\n    // Otherwise, at -O0, build an inline asm that we're going to call\n    // in a moment.\n    } else if (CGF.CGM.getCodeGenOpts().OptimizationLevel == 0) {\n      llvm::FunctionType *type =\n        llvm::FunctionType::get(CGF.VoidTy, /*variadic*/false);\n\n      marker = llvm::InlineAsm::get(type, assembly, \"\", /*sideeffects*/ true);\n\n    // If we're at -O1 and above, we don't want to litter the code\n    // with this marker yet, so leave a breadcrumb for the ARC\n    // optimizer to pick up.\n    } else {\n      const char *retainRVMarkerKey = llvm::objcarc::getRVMarkerModuleFlagStr();\n      if (!CGF.CGM.getModule().getModuleFlag(retainRVMarkerKey)) {\n        auto *str = llvm::MDString::get(CGF.getLLVMContext(), assembly);\n        CGF.CGM.getModule().addModuleFlag(llvm::Module::Error,\n                                          retainRVMarkerKey, str);\n      }\n    }\n  }\n\n  // Call the marker asm if we made one, which we do only at -O0.\n  if (marker)\n    CGF.Builder.CreateCall(marker, None, CGF.getBundlesForFunclet(marker));\n}\n\nstatic llvm::Value *emitOptimizedARCReturnCall(llvm::Value *value,\n                                               bool IsRetainRV,\n                                               CodeGenFunction &CGF) {\n  emitAutoreleasedReturnValueMarker(CGF);\n\n  // Add operand bundle \"clang.arc.attachedcall\" to the call instead of emitting\n  // retainRV or claimRV calls in the IR. We currently do this only when the\n  // optimization level isn't -O0 since global-isel, which is currently run at\n  // -O0, doesn't know about the operand bundle.\n\n  // FIXME: Do this when the target isn't aarch64.\n  if (CGF.CGM.getCodeGenOpts().OptimizationLevel > 0 &&\n      CGF.CGM.getTarget().getTriple().isAArch64()) {\n    llvm::Value *bundleArgs[] = {llvm::ConstantInt::get(\n        CGF.Int64Ty,\n        llvm::objcarc::getAttachedCallOperandBundleEnum(IsRetainRV))};\n    llvm::OperandBundleDef OB(\"clang.arc.attachedcall\", bundleArgs);\n    auto *oldCall = cast<llvm::CallBase>(value);\n    llvm::CallBase *newCall = llvm::CallBase::addOperandBundle(\n        oldCall, llvm::LLVMContext::OB_clang_arc_attachedcall, OB, oldCall);\n    newCall->copyMetadata(*oldCall);\n    oldCall->replaceAllUsesWith(newCall);\n    oldCall->eraseFromParent();\n    CGF.EmitARCNoopIntrinsicUse(newCall);\n    return newCall;\n  }\n\n  bool isNoTail =\n      CGF.CGM.getTargetCodeGenInfo().markARCOptimizedReturnCallsAsNoTail();\n  llvm::CallInst::TailCallKind tailKind =\n      isNoTail ? llvm::CallInst::TCK_NoTail : llvm::CallInst::TCK_None;\n  ObjCEntrypoints &EPs = CGF.CGM.getObjCEntrypoints();\n  llvm::Function *&EP = IsRetainRV\n                            ? EPs.objc_retainAutoreleasedReturnValue\n                            : EPs.objc_unsafeClaimAutoreleasedReturnValue;\n  llvm::Intrinsic::ID IID =\n      IsRetainRV ? llvm::Intrinsic::objc_retainAutoreleasedReturnValue\n                 : llvm::Intrinsic::objc_unsafeClaimAutoreleasedReturnValue;\n  return emitARCValueOperation(CGF, value, nullptr, EP, IID, tailKind);\n}\n\n/// Retain the given object which is the result of a function call.\n///   call i8* \\@objc_retainAutoreleasedReturnValue(i8* %value)\n///\n/// Yes, this function name is one character away from a different\n/// call with completely different semantics.\nllvm::Value *\nCodeGenFunction::EmitARCRetainAutoreleasedReturnValue(llvm::Value *value) {\n  return emitOptimizedARCReturnCall(value, true, *this);\n}\n\n/// Claim a possibly-autoreleased return value at +0.  This is only\n/// valid to do in contexts which do not rely on the retain to keep\n/// the object valid for all of its uses; for example, when\n/// the value is ignored, or when it is being assigned to an\n/// __unsafe_unretained variable.\n///\n///   call i8* \\@objc_unsafeClaimAutoreleasedReturnValue(i8* %value)\nllvm::Value *\nCodeGenFunction::EmitARCUnsafeClaimAutoreleasedReturnValue(llvm::Value *value) {\n  return emitOptimizedARCReturnCall(value, false, *this);\n}\n\n/// Release the given object.\n///   call void \\@objc_release(i8* %value)\nvoid CodeGenFunction::EmitARCRelease(llvm::Value *value,\n                                     ARCPreciseLifetime_t precise) {\n  if (isa<llvm::ConstantPointerNull>(value)) return;\n\n  llvm::Function *&fn = CGM.getObjCEntrypoints().objc_release;\n  if (!fn) {\n    fn = CGM.getIntrinsic(llvm::Intrinsic::objc_release);\n    setARCRuntimeFunctionLinkage(CGM, fn);\n  }\n\n  // Cast the argument to 'id'.\n  value = Builder.CreateBitCast(value, Int8PtrTy);\n\n  // Call objc_release.\n  llvm::CallInst *call = EmitNounwindRuntimeCall(fn, value);\n\n  if (precise == ARCImpreciseLifetime) {\n    call->setMetadata(\"clang.imprecise_release\",\n                      llvm::MDNode::get(Builder.getContext(), None));\n  }\n}\n\n/// Destroy a __strong variable.\n///\n/// At -O0, emit a call to store 'null' into the address;\n/// instrumenting tools prefer this because the address is exposed,\n/// but it's relatively cumbersome to optimize.\n///\n/// At -O1 and above, just load and call objc_release.\n///\n///   call void \\@objc_storeStrong(i8** %addr, i8* null)\nvoid CodeGenFunction::EmitARCDestroyStrong(Address addr,\n                                           ARCPreciseLifetime_t precise) {\n  if (CGM.getCodeGenOpts().OptimizationLevel == 0) {\n    llvm::Value *null = getNullForVariable(addr);\n    EmitARCStoreStrongCall(addr, null, /*ignored*/ true);\n    return;\n  }\n\n  llvm::Value *value = Builder.CreateLoad(addr);\n  EmitARCRelease(value, precise);\n}\n\n/// Store into a strong object.  Always calls this:\n///   call void \\@objc_storeStrong(i8** %addr, i8* %value)\nllvm::Value *CodeGenFunction::EmitARCStoreStrongCall(Address addr,\n                                                     llvm::Value *value,\n                                                     bool ignored) {\n  assert(addr.getElementType() == value->getType());\n\n  llvm::Function *&fn = CGM.getObjCEntrypoints().objc_storeStrong;\n  if (!fn) {\n    fn = CGM.getIntrinsic(llvm::Intrinsic::objc_storeStrong);\n    setARCRuntimeFunctionLinkage(CGM, fn);\n  }\n\n  llvm::Value *args[] = {\n    Builder.CreateBitCast(addr.getPointer(), Int8PtrPtrTy),\n    Builder.CreateBitCast(value, Int8PtrTy)\n  };\n  EmitNounwindRuntimeCall(fn, args);\n\n  if (ignored) return nullptr;\n  return value;\n}\n\n/// Store into a strong object.  Sometimes calls this:\n///   call void \\@objc_storeStrong(i8** %addr, i8* %value)\n/// Other times, breaks it down into components.\nllvm::Value *CodeGenFunction::EmitARCStoreStrong(LValue dst,\n                                                 llvm::Value *newValue,\n                                                 bool ignored) {\n  QualType type = dst.getType();\n  bool isBlock = type->isBlockPointerType();\n\n  // Use a store barrier at -O0 unless this is a block type or the\n  // lvalue is inadequately aligned.\n  if (shouldUseFusedARCCalls() &&\n      !isBlock &&\n      (dst.getAlignment().isZero() ||\n       dst.getAlignment() >= CharUnits::fromQuantity(PointerAlignInBytes))) {\n    return EmitARCStoreStrongCall(dst.getAddress(*this), newValue, ignored);\n  }\n\n  // Otherwise, split it out.\n\n  // Retain the new value.\n  newValue = EmitARCRetain(type, newValue);\n\n  // Read the old value.\n  llvm::Value *oldValue = EmitLoadOfScalar(dst, SourceLocation());\n\n  // Store.  We do this before the release so that any deallocs won't\n  // see the old value.\n  EmitStoreOfScalar(newValue, dst);\n\n  // Finally, release the old value.\n  EmitARCRelease(oldValue, dst.isARCPreciseLifetime());\n\n  return newValue;\n}\n\n/// Autorelease the given object.\n///   call i8* \\@objc_autorelease(i8* %value)\nllvm::Value *CodeGenFunction::EmitARCAutorelease(llvm::Value *value) {\n  return emitARCValueOperation(*this, value, nullptr,\n                               CGM.getObjCEntrypoints().objc_autorelease,\n                               llvm::Intrinsic::objc_autorelease);\n}\n\n/// Autorelease the given object.\n///   call i8* \\@objc_autoreleaseReturnValue(i8* %value)\nllvm::Value *\nCodeGenFunction::EmitARCAutoreleaseReturnValue(llvm::Value *value) {\n  return emitARCValueOperation(*this, value, nullptr,\n                            CGM.getObjCEntrypoints().objc_autoreleaseReturnValue,\n                               llvm::Intrinsic::objc_autoreleaseReturnValue,\n                               llvm::CallInst::TCK_Tail);\n}\n\n/// Do a fused retain/autorelease of the given object.\n///   call i8* \\@objc_retainAutoreleaseReturnValue(i8* %value)\nllvm::Value *\nCodeGenFunction::EmitARCRetainAutoreleaseReturnValue(llvm::Value *value) {\n  return emitARCValueOperation(*this, value, nullptr,\n                     CGM.getObjCEntrypoints().objc_retainAutoreleaseReturnValue,\n                             llvm::Intrinsic::objc_retainAutoreleaseReturnValue,\n                               llvm::CallInst::TCK_Tail);\n}\n\n/// Do a fused retain/autorelease of the given object.\n///   call i8* \\@objc_retainAutorelease(i8* %value)\n/// or\n///   %retain = call i8* \\@objc_retainBlock(i8* %value)\n///   call i8* \\@objc_autorelease(i8* %retain)\nllvm::Value *CodeGenFunction::EmitARCRetainAutorelease(QualType type,\n                                                       llvm::Value *value) {\n  if (!type->isBlockPointerType())\n    return EmitARCRetainAutoreleaseNonBlock(value);\n\n  if (isa<llvm::ConstantPointerNull>(value)) return value;\n\n  llvm::Type *origType = value->getType();\n  value = Builder.CreateBitCast(value, Int8PtrTy);\n  value = EmitARCRetainBlock(value, /*mandatory*/ true);\n  value = EmitARCAutorelease(value);\n  return Builder.CreateBitCast(value, origType);\n}\n\n/// Do a fused retain/autorelease of the given object.\n///   call i8* \\@objc_retainAutorelease(i8* %value)\nllvm::Value *\nCodeGenFunction::EmitARCRetainAutoreleaseNonBlock(llvm::Value *value) {\n  return emitARCValueOperation(*this, value, nullptr,\n                               CGM.getObjCEntrypoints().objc_retainAutorelease,\n                               llvm::Intrinsic::objc_retainAutorelease);\n}\n\n/// i8* \\@objc_loadWeak(i8** %addr)\n/// Essentially objc_autorelease(objc_loadWeakRetained(addr)).\nllvm::Value *CodeGenFunction::EmitARCLoadWeak(Address addr) {\n  return emitARCLoadOperation(*this, addr,\n                              CGM.getObjCEntrypoints().objc_loadWeak,\n                              llvm::Intrinsic::objc_loadWeak);\n}\n\n/// i8* \\@objc_loadWeakRetained(i8** %addr)\nllvm::Value *CodeGenFunction::EmitARCLoadWeakRetained(Address addr) {\n  return emitARCLoadOperation(*this, addr,\n                              CGM.getObjCEntrypoints().objc_loadWeakRetained,\n                              llvm::Intrinsic::objc_loadWeakRetained);\n}\n\n/// i8* \\@objc_storeWeak(i8** %addr, i8* %value)\n/// Returns %value.\nllvm::Value *CodeGenFunction::EmitARCStoreWeak(Address addr,\n                                               llvm::Value *value,\n                                               bool ignored) {\n  return emitARCStoreOperation(*this, addr, value,\n                               CGM.getObjCEntrypoints().objc_storeWeak,\n                               llvm::Intrinsic::objc_storeWeak, ignored);\n}\n\n/// i8* \\@objc_initWeak(i8** %addr, i8* %value)\n/// Returns %value.  %addr is known to not have a current weak entry.\n/// Essentially equivalent to:\n///   *addr = nil; objc_storeWeak(addr, value);\nvoid CodeGenFunction::EmitARCInitWeak(Address addr, llvm::Value *value) {\n  // If we're initializing to null, just write null to memory; no need\n  // to get the runtime involved.  But don't do this if optimization\n  // is enabled, because accounting for this would make the optimizer\n  // much more complicated.\n  if (isa<llvm::ConstantPointerNull>(value) &&\n      CGM.getCodeGenOpts().OptimizationLevel == 0) {\n    Builder.CreateStore(value, addr);\n    return;\n  }\n\n  emitARCStoreOperation(*this, addr, value,\n                        CGM.getObjCEntrypoints().objc_initWeak,\n                        llvm::Intrinsic::objc_initWeak, /*ignored*/ true);\n}\n\n/// void \\@objc_destroyWeak(i8** %addr)\n/// Essentially objc_storeWeak(addr, nil).\nvoid CodeGenFunction::EmitARCDestroyWeak(Address addr) {\n  llvm::Function *&fn = CGM.getObjCEntrypoints().objc_destroyWeak;\n  if (!fn) {\n    fn = CGM.getIntrinsic(llvm::Intrinsic::objc_destroyWeak);\n    setARCRuntimeFunctionLinkage(CGM, fn);\n  }\n\n  // Cast the argument to 'id*'.\n  addr = Builder.CreateBitCast(addr, Int8PtrPtrTy);\n\n  EmitNounwindRuntimeCall(fn, addr.getPointer());\n}\n\n/// void \\@objc_moveWeak(i8** %dest, i8** %src)\n/// Disregards the current value in %dest.  Leaves %src pointing to nothing.\n/// Essentially (objc_copyWeak(dest, src), objc_destroyWeak(src)).\nvoid CodeGenFunction::EmitARCMoveWeak(Address dst, Address src) {\n  emitARCCopyOperation(*this, dst, src,\n                       CGM.getObjCEntrypoints().objc_moveWeak,\n                       llvm::Intrinsic::objc_moveWeak);\n}\n\n/// void \\@objc_copyWeak(i8** %dest, i8** %src)\n/// Disregards the current value in %dest.  Essentially\n///   objc_release(objc_initWeak(dest, objc_readWeakRetained(src)))\nvoid CodeGenFunction::EmitARCCopyWeak(Address dst, Address src) {\n  emitARCCopyOperation(*this, dst, src,\n                       CGM.getObjCEntrypoints().objc_copyWeak,\n                       llvm::Intrinsic::objc_copyWeak);\n}\n\nvoid CodeGenFunction::emitARCCopyAssignWeak(QualType Ty, Address DstAddr,\n                                            Address SrcAddr) {\n  llvm::Value *Object = EmitARCLoadWeakRetained(SrcAddr);\n  Object = EmitObjCConsumeObject(Ty, Object);\n  EmitARCStoreWeak(DstAddr, Object, false);\n}\n\nvoid CodeGenFunction::emitARCMoveAssignWeak(QualType Ty, Address DstAddr,\n                                            Address SrcAddr) {\n  llvm::Value *Object = EmitARCLoadWeakRetained(SrcAddr);\n  Object = EmitObjCConsumeObject(Ty, Object);\n  EmitARCStoreWeak(DstAddr, Object, false);\n  EmitARCDestroyWeak(SrcAddr);\n}\n\n/// Produce the code to do a objc_autoreleasepool_push.\n///   call i8* \\@objc_autoreleasePoolPush(void)\nllvm::Value *CodeGenFunction::EmitObjCAutoreleasePoolPush() {\n  llvm::Function *&fn = CGM.getObjCEntrypoints().objc_autoreleasePoolPush;\n  if (!fn) {\n    fn = CGM.getIntrinsic(llvm::Intrinsic::objc_autoreleasePoolPush);\n    setARCRuntimeFunctionLinkage(CGM, fn);\n  }\n\n  return EmitNounwindRuntimeCall(fn);\n}\n\n/// Produce the code to do a primitive release.\n///   call void \\@objc_autoreleasePoolPop(i8* %ptr)\nvoid CodeGenFunction::EmitObjCAutoreleasePoolPop(llvm::Value *value) {\n  assert(value->getType() == Int8PtrTy);\n\n  if (getInvokeDest()) {\n    // Call the runtime method not the intrinsic if we are handling exceptions\n    llvm::FunctionCallee &fn =\n        CGM.getObjCEntrypoints().objc_autoreleasePoolPopInvoke;\n    if (!fn) {\n      llvm::FunctionType *fnType =\n        llvm::FunctionType::get(Builder.getVoidTy(), Int8PtrTy, false);\n      fn = CGM.CreateRuntimeFunction(fnType, \"objc_autoreleasePoolPop\");\n      setARCRuntimeFunctionLinkage(CGM, fn);\n    }\n\n    // objc_autoreleasePoolPop can throw.\n    EmitRuntimeCallOrInvoke(fn, value);\n  } else {\n    llvm::FunctionCallee &fn = CGM.getObjCEntrypoints().objc_autoreleasePoolPop;\n    if (!fn) {\n      fn = CGM.getIntrinsic(llvm::Intrinsic::objc_autoreleasePoolPop);\n      setARCRuntimeFunctionLinkage(CGM, fn);\n    }\n\n    EmitRuntimeCall(fn, value);\n  }\n}\n\n/// Produce the code to do an MRR version objc_autoreleasepool_push.\n/// Which is: [[NSAutoreleasePool alloc] init];\n/// Where alloc is declared as: + (id) alloc; in NSAutoreleasePool class.\n/// init is declared as: - (id) init; in its NSObject super class.\n///\nllvm::Value *CodeGenFunction::EmitObjCMRRAutoreleasePoolPush() {\n  CGObjCRuntime &Runtime = CGM.getObjCRuntime();\n  llvm::Value *Receiver = Runtime.EmitNSAutoreleasePoolClassRef(*this);\n  // [NSAutoreleasePool alloc]\n  IdentifierInfo *II = &CGM.getContext().Idents.get(\"alloc\");\n  Selector AllocSel = getContext().Selectors.getSelector(0, &II);\n  CallArgList Args;\n  RValue AllocRV =\n    Runtime.GenerateMessageSend(*this, ReturnValueSlot(),\n                                getContext().getObjCIdType(),\n                                AllocSel, Receiver, Args);\n\n  // [Receiver init]\n  Receiver = AllocRV.getScalarVal();\n  II = &CGM.getContext().Idents.get(\"init\");\n  Selector InitSel = getContext().Selectors.getSelector(0, &II);\n  RValue InitRV =\n    Runtime.GenerateMessageSend(*this, ReturnValueSlot(),\n                                getContext().getObjCIdType(),\n                                InitSel, Receiver, Args);\n  return InitRV.getScalarVal();\n}\n\n/// Allocate the given objc object.\n///   call i8* \\@objc_alloc(i8* %value)\nllvm::Value *CodeGenFunction::EmitObjCAlloc(llvm::Value *value,\n                                            llvm::Type *resultType) {\n  return emitObjCValueOperation(*this, value, resultType,\n                                CGM.getObjCEntrypoints().objc_alloc,\n                                \"objc_alloc\");\n}\n\n/// Allocate the given objc object.\n///   call i8* \\@objc_allocWithZone(i8* %value)\nllvm::Value *CodeGenFunction::EmitObjCAllocWithZone(llvm::Value *value,\n                                                    llvm::Type *resultType) {\n  return emitObjCValueOperation(*this, value, resultType,\n                                CGM.getObjCEntrypoints().objc_allocWithZone,\n                                \"objc_allocWithZone\");\n}\n\nllvm::Value *CodeGenFunction::EmitObjCAllocInit(llvm::Value *value,\n                                                llvm::Type *resultType) {\n  return emitObjCValueOperation(*this, value, resultType,\n                                CGM.getObjCEntrypoints().objc_alloc_init,\n                                \"objc_alloc_init\");\n}\n\n/// Produce the code to do a primitive release.\n/// [tmp drain];\nvoid CodeGenFunction::EmitObjCMRRAutoreleasePoolPop(llvm::Value *Arg) {\n  IdentifierInfo *II = &CGM.getContext().Idents.get(\"drain\");\n  Selector DrainSel = getContext().Selectors.getSelector(0, &II);\n  CallArgList Args;\n  CGM.getObjCRuntime().GenerateMessageSend(*this, ReturnValueSlot(),\n                              getContext().VoidTy, DrainSel, Arg, Args);\n}\n\nvoid CodeGenFunction::destroyARCStrongPrecise(CodeGenFunction &CGF,\n                                              Address addr,\n                                              QualType type) {\n  CGF.EmitARCDestroyStrong(addr, ARCPreciseLifetime);\n}\n\nvoid CodeGenFunction::destroyARCStrongImprecise(CodeGenFunction &CGF,\n                                                Address addr,\n                                                QualType type) {\n  CGF.EmitARCDestroyStrong(addr, ARCImpreciseLifetime);\n}\n\nvoid CodeGenFunction::destroyARCWeak(CodeGenFunction &CGF,\n                                     Address addr,\n                                     QualType type) {\n  CGF.EmitARCDestroyWeak(addr);\n}\n\nvoid CodeGenFunction::emitARCIntrinsicUse(CodeGenFunction &CGF, Address addr,\n                                          QualType type) {\n  llvm::Value *value = CGF.Builder.CreateLoad(addr);\n  CGF.EmitARCIntrinsicUse(value);\n}\n\n/// Autorelease the given object.\n///   call i8* \\@objc_autorelease(i8* %value)\nllvm::Value *CodeGenFunction::EmitObjCAutorelease(llvm::Value *value,\n                                                  llvm::Type *returnType) {\n  return emitObjCValueOperation(\n      *this, value, returnType,\n      CGM.getObjCEntrypoints().objc_autoreleaseRuntimeFunction,\n      \"objc_autorelease\");\n}\n\n/// Retain the given object, with normal retain semantics.\n///   call i8* \\@objc_retain(i8* %value)\nllvm::Value *CodeGenFunction::EmitObjCRetainNonBlock(llvm::Value *value,\n                                                     llvm::Type *returnType) {\n  return emitObjCValueOperation(\n      *this, value, returnType,\n      CGM.getObjCEntrypoints().objc_retainRuntimeFunction, \"objc_retain\");\n}\n\n/// Release the given object.\n///   call void \\@objc_release(i8* %value)\nvoid CodeGenFunction::EmitObjCRelease(llvm::Value *value,\n                                      ARCPreciseLifetime_t precise) {\n  if (isa<llvm::ConstantPointerNull>(value)) return;\n\n  llvm::FunctionCallee &fn =\n      CGM.getObjCEntrypoints().objc_releaseRuntimeFunction;\n  if (!fn) {\n    llvm::FunctionType *fnType =\n        llvm::FunctionType::get(Builder.getVoidTy(), Int8PtrTy, false);\n    fn = CGM.CreateRuntimeFunction(fnType, \"objc_release\");\n    setARCRuntimeFunctionLinkage(CGM, fn);\n    // We have Native ARC, so set nonlazybind attribute for performance\n    if (llvm::Function *f = dyn_cast<llvm::Function>(fn.getCallee()))\n      f->addFnAttr(llvm::Attribute::NonLazyBind);\n  }\n\n  // Cast the argument to 'id'.\n  value = Builder.CreateBitCast(value, Int8PtrTy);\n\n  // Call objc_release.\n  llvm::CallBase *call = EmitCallOrInvoke(fn, value);\n\n  if (precise == ARCImpreciseLifetime) {\n    call->setMetadata(\"clang.imprecise_release\",\n                      llvm::MDNode::get(Builder.getContext(), None));\n  }\n}\n\nnamespace {\n  struct CallObjCAutoreleasePoolObject final : EHScopeStack::Cleanup {\n    llvm::Value *Token;\n\n    CallObjCAutoreleasePoolObject(llvm::Value *token) : Token(token) {}\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      CGF.EmitObjCAutoreleasePoolPop(Token);\n    }\n  };\n  struct CallObjCMRRAutoreleasePoolObject final : EHScopeStack::Cleanup {\n    llvm::Value *Token;\n\n    CallObjCMRRAutoreleasePoolObject(llvm::Value *token) : Token(token) {}\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      CGF.EmitObjCMRRAutoreleasePoolPop(Token);\n    }\n  };\n}\n\nvoid CodeGenFunction::EmitObjCAutoreleasePoolCleanup(llvm::Value *Ptr) {\n  if (CGM.getLangOpts().ObjCAutoRefCount)\n    EHStack.pushCleanup<CallObjCAutoreleasePoolObject>(NormalCleanup, Ptr);\n  else\n    EHStack.pushCleanup<CallObjCMRRAutoreleasePoolObject>(NormalCleanup, Ptr);\n}\n\nstatic bool shouldRetainObjCLifetime(Qualifiers::ObjCLifetime lifetime) {\n  switch (lifetime) {\n  case Qualifiers::OCL_None:\n  case Qualifiers::OCL_ExplicitNone:\n  case Qualifiers::OCL_Strong:\n  case Qualifiers::OCL_Autoreleasing:\n    return true;\n\n  case Qualifiers::OCL_Weak:\n    return false;\n  }\n\n  llvm_unreachable(\"impossible lifetime!\");\n}\n\nstatic TryEmitResult tryEmitARCRetainLoadOfScalar(CodeGenFunction &CGF,\n                                                  LValue lvalue,\n                                                  QualType type) {\n  llvm::Value *result;\n  bool shouldRetain = shouldRetainObjCLifetime(type.getObjCLifetime());\n  if (shouldRetain) {\n    result = CGF.EmitLoadOfLValue(lvalue, SourceLocation()).getScalarVal();\n  } else {\n    assert(type.getObjCLifetime() == Qualifiers::OCL_Weak);\n    result = CGF.EmitARCLoadWeakRetained(lvalue.getAddress(CGF));\n  }\n  return TryEmitResult(result, !shouldRetain);\n}\n\nstatic TryEmitResult tryEmitARCRetainLoadOfScalar(CodeGenFunction &CGF,\n                                                  const Expr *e) {\n  e = e->IgnoreParens();\n  QualType type = e->getType();\n\n  // If we're loading retained from a __strong xvalue, we can avoid\n  // an extra retain/release pair by zeroing out the source of this\n  // \"move\" operation.\n  if (e->isXValue() &&\n      !type.isConstQualified() &&\n      type.getObjCLifetime() == Qualifiers::OCL_Strong) {\n    // Emit the lvalue.\n    LValue lv = CGF.EmitLValue(e);\n\n    // Load the object pointer.\n    llvm::Value *result = CGF.EmitLoadOfLValue(lv,\n                                               SourceLocation()).getScalarVal();\n\n    // Set the source pointer to NULL.\n    CGF.EmitStoreOfScalar(getNullForVariable(lv.getAddress(CGF)), lv);\n\n    return TryEmitResult(result, true);\n  }\n\n  // As a very special optimization, in ARC++, if the l-value is the\n  // result of a non-volatile assignment, do a simple retain of the\n  // result of the call to objc_storeWeak instead of reloading.\n  if (CGF.getLangOpts().CPlusPlus &&\n      !type.isVolatileQualified() &&\n      type.getObjCLifetime() == Qualifiers::OCL_Weak &&\n      isa<BinaryOperator>(e) &&\n      cast<BinaryOperator>(e)->getOpcode() == BO_Assign)\n    return TryEmitResult(CGF.EmitScalarExpr(e), false);\n\n  // Try to emit code for scalar constant instead of emitting LValue and\n  // loading it because we are not guaranteed to have an l-value. One of such\n  // cases is DeclRefExpr referencing non-odr-used constant-evaluated variable.\n  if (const auto *decl_expr = dyn_cast<DeclRefExpr>(e)) {\n    auto *DRE = const_cast<DeclRefExpr *>(decl_expr);\n    if (CodeGenFunction::ConstantEmission constant = CGF.tryEmitAsConstant(DRE))\n      return TryEmitResult(CGF.emitScalarConstant(constant, DRE),\n                           !shouldRetainObjCLifetime(type.getObjCLifetime()));\n  }\n\n  return tryEmitARCRetainLoadOfScalar(CGF, CGF.EmitLValue(e), type);\n}\n\ntypedef llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                         llvm::Value *value)>\n  ValueTransform;\n\n/// Insert code immediately after a call.\n\n// FIXME: We should find a way to emit the runtime call immediately\n// after the call is emitted to eliminate the need for this function.\nstatic llvm::Value *emitARCOperationAfterCall(CodeGenFunction &CGF,\n                                              llvm::Value *value,\n                                              ValueTransform doAfterCall,\n                                              ValueTransform doFallback) {\n  CGBuilderTy::InsertPoint ip = CGF.Builder.saveIP();\n\n  if (llvm::CallInst *call = dyn_cast<llvm::CallInst>(value)) {\n    // Place the retain immediately following the call.\n    CGF.Builder.SetInsertPoint(call->getParent(),\n                               ++llvm::BasicBlock::iterator(call));\n    value = doAfterCall(CGF, value);\n  } else if (llvm::InvokeInst *invoke = dyn_cast<llvm::InvokeInst>(value)) {\n    // Place the retain at the beginning of the normal destination block.\n    llvm::BasicBlock *BB = invoke->getNormalDest();\n    CGF.Builder.SetInsertPoint(BB, BB->begin());\n    value = doAfterCall(CGF, value);\n\n  // Bitcasts can arise because of related-result returns.  Rewrite\n  // the operand.\n  } else if (llvm::BitCastInst *bitcast = dyn_cast<llvm::BitCastInst>(value)) {\n    // Change the insert point to avoid emitting the fall-back call after the\n    // bitcast.\n    CGF.Builder.SetInsertPoint(bitcast->getParent(), bitcast->getIterator());\n    llvm::Value *operand = bitcast->getOperand(0);\n    operand = emitARCOperationAfterCall(CGF, operand, doAfterCall, doFallback);\n    bitcast->setOperand(0, operand);\n    value = bitcast;\n  } else {\n    auto *phi = dyn_cast<llvm::PHINode>(value);\n    if (phi && phi->getNumIncomingValues() == 2 &&\n        isa<llvm::ConstantPointerNull>(phi->getIncomingValue(1)) &&\n        isa<llvm::CallBase>(phi->getIncomingValue(0))) {\n      // Handle phi instructions that are generated when it's necessary to check\n      // whether the receiver of a message is null.\n      llvm::Value *inVal = phi->getIncomingValue(0);\n      inVal = emitARCOperationAfterCall(CGF, inVal, doAfterCall, doFallback);\n      phi->setIncomingValue(0, inVal);\n      value = phi;\n    } else {\n      // Generic fall-back case.\n      // Retain using the non-block variant: we never need to do a copy\n      // of a block that's been returned to us.\n      value = doFallback(CGF, value);\n    }\n  }\n\n  CGF.Builder.restoreIP(ip);\n  return value;\n}\n\n/// Given that the given expression is some sort of call (which does\n/// not return retained), emit a retain following it.\nstatic llvm::Value *emitARCRetainCallResult(CodeGenFunction &CGF,\n                                            const Expr *e) {\n  llvm::Value *value = CGF.EmitScalarExpr(e);\n  return emitARCOperationAfterCall(CGF, value,\n           [](CodeGenFunction &CGF, llvm::Value *value) {\n             return CGF.EmitARCRetainAutoreleasedReturnValue(value);\n           },\n           [](CodeGenFunction &CGF, llvm::Value *value) {\n             return CGF.EmitARCRetainNonBlock(value);\n           });\n}\n\n/// Given that the given expression is some sort of call (which does\n/// not return retained), perform an unsafeClaim following it.\nstatic llvm::Value *emitARCUnsafeClaimCallResult(CodeGenFunction &CGF,\n                                                 const Expr *e) {\n  llvm::Value *value = CGF.EmitScalarExpr(e);\n  return emitARCOperationAfterCall(CGF, value,\n           [](CodeGenFunction &CGF, llvm::Value *value) {\n             return CGF.EmitARCUnsafeClaimAutoreleasedReturnValue(value);\n           },\n           [](CodeGenFunction &CGF, llvm::Value *value) {\n             return value;\n           });\n}\n\nllvm::Value *CodeGenFunction::EmitARCReclaimReturnedObject(const Expr *E,\n                                                      bool allowUnsafeClaim) {\n  if (allowUnsafeClaim &&\n      CGM.getLangOpts().ObjCRuntime.hasARCUnsafeClaimAutoreleasedReturnValue()) {\n    return emitARCUnsafeClaimCallResult(*this, E);\n  } else {\n    llvm::Value *value = emitARCRetainCallResult(*this, E);\n    return EmitObjCConsumeObject(E->getType(), value);\n  }\n}\n\n/// Determine whether it might be important to emit a separate\n/// objc_retain_block on the result of the given expression, or\n/// whether it's okay to just emit it in a +1 context.\nstatic bool shouldEmitSeparateBlockRetain(const Expr *e) {\n  assert(e->getType()->isBlockPointerType());\n  e = e->IgnoreParens();\n\n  // For future goodness, emit block expressions directly in +1\n  // contexts if we can.\n  if (isa<BlockExpr>(e))\n    return false;\n\n  if (const CastExpr *cast = dyn_cast<CastExpr>(e)) {\n    switch (cast->getCastKind()) {\n    // Emitting these operations in +1 contexts is goodness.\n    case CK_LValueToRValue:\n    case CK_ARCReclaimReturnedObject:\n    case CK_ARCConsumeObject:\n    case CK_ARCProduceObject:\n      return false;\n\n    // These operations preserve a block type.\n    case CK_NoOp:\n    case CK_BitCast:\n      return shouldEmitSeparateBlockRetain(cast->getSubExpr());\n\n    // These operations are known to be bad (or haven't been considered).\n    case CK_AnyPointerToBlockPointerCast:\n    default:\n      return true;\n    }\n  }\n\n  return true;\n}\n\nnamespace {\n/// A CRTP base class for emitting expressions of retainable object\n/// pointer type in ARC.\ntemplate <typename Impl, typename Result> class ARCExprEmitter {\nprotected:\n  CodeGenFunction &CGF;\n  Impl &asImpl() { return *static_cast<Impl*>(this); }\n\n  ARCExprEmitter(CodeGenFunction &CGF) : CGF(CGF) {}\n\npublic:\n  Result visit(const Expr *e);\n  Result visitCastExpr(const CastExpr *e);\n  Result visitPseudoObjectExpr(const PseudoObjectExpr *e);\n  Result visitBlockExpr(const BlockExpr *e);\n  Result visitBinaryOperator(const BinaryOperator *e);\n  Result visitBinAssign(const BinaryOperator *e);\n  Result visitBinAssignUnsafeUnretained(const BinaryOperator *e);\n  Result visitBinAssignAutoreleasing(const BinaryOperator *e);\n  Result visitBinAssignWeak(const BinaryOperator *e);\n  Result visitBinAssignStrong(const BinaryOperator *e);\n\n  // Minimal implementation:\n  //   Result visitLValueToRValue(const Expr *e)\n  //   Result visitConsumeObject(const Expr *e)\n  //   Result visitExtendBlockObject(const Expr *e)\n  //   Result visitReclaimReturnedObject(const Expr *e)\n  //   Result visitCall(const Expr *e)\n  //   Result visitExpr(const Expr *e)\n  //\n  //   Result emitBitCast(Result result, llvm::Type *resultType)\n  //   llvm::Value *getValueOfResult(Result result)\n};\n}\n\n/// Try to emit a PseudoObjectExpr under special ARC rules.\n///\n/// This massively duplicates emitPseudoObjectRValue.\ntemplate <typename Impl, typename Result>\nResult\nARCExprEmitter<Impl,Result>::visitPseudoObjectExpr(const PseudoObjectExpr *E) {\n  SmallVector<CodeGenFunction::OpaqueValueMappingData, 4> opaques;\n\n  // Find the result expression.\n  const Expr *resultExpr = E->getResultExpr();\n  assert(resultExpr);\n  Result result;\n\n  for (PseudoObjectExpr::const_semantics_iterator\n         i = E->semantics_begin(), e = E->semantics_end(); i != e; ++i) {\n    const Expr *semantic = *i;\n\n    // If this semantic expression is an opaque value, bind it\n    // to the result of its source expression.\n    if (const OpaqueValueExpr *ov = dyn_cast<OpaqueValueExpr>(semantic)) {\n      typedef CodeGenFunction::OpaqueValueMappingData OVMA;\n      OVMA opaqueData;\n\n      // If this semantic is the result of the pseudo-object\n      // expression, try to evaluate the source as +1.\n      if (ov == resultExpr) {\n        assert(!OVMA::shouldBindAsLValue(ov));\n        result = asImpl().visit(ov->getSourceExpr());\n        opaqueData = OVMA::bind(CGF, ov,\n                            RValue::get(asImpl().getValueOfResult(result)));\n\n      // Otherwise, just bind it.\n      } else {\n        opaqueData = OVMA::bind(CGF, ov, ov->getSourceExpr());\n      }\n      opaques.push_back(opaqueData);\n\n    // Otherwise, if the expression is the result, evaluate it\n    // and remember the result.\n    } else if (semantic == resultExpr) {\n      result = asImpl().visit(semantic);\n\n    // Otherwise, evaluate the expression in an ignored context.\n    } else {\n      CGF.EmitIgnoredExpr(semantic);\n    }\n  }\n\n  // Unbind all the opaques now.\n  for (unsigned i = 0, e = opaques.size(); i != e; ++i)\n    opaques[i].unbind(CGF);\n\n  return result;\n}\n\ntemplate <typename Impl, typename Result>\nResult ARCExprEmitter<Impl, Result>::visitBlockExpr(const BlockExpr *e) {\n  // The default implementation just forwards the expression to visitExpr.\n  return asImpl().visitExpr(e);\n}\n\ntemplate <typename Impl, typename Result>\nResult ARCExprEmitter<Impl,Result>::visitCastExpr(const CastExpr *e) {\n  switch (e->getCastKind()) {\n\n  // No-op casts don't change the type, so we just ignore them.\n  case CK_NoOp:\n    return asImpl().visit(e->getSubExpr());\n\n  // These casts can change the type.\n  case CK_CPointerToObjCPointerCast:\n  case CK_BlockPointerToObjCPointerCast:\n  case CK_AnyPointerToBlockPointerCast:\n  case CK_BitCast: {\n    llvm::Type *resultType = CGF.ConvertType(e->getType());\n    assert(e->getSubExpr()->getType()->hasPointerRepresentation());\n    Result result = asImpl().visit(e->getSubExpr());\n    return asImpl().emitBitCast(result, resultType);\n  }\n\n  // Handle some casts specially.\n  case CK_LValueToRValue:\n    return asImpl().visitLValueToRValue(e->getSubExpr());\n  case CK_ARCConsumeObject:\n    return asImpl().visitConsumeObject(e->getSubExpr());\n  case CK_ARCExtendBlockObject:\n    return asImpl().visitExtendBlockObject(e->getSubExpr());\n  case CK_ARCReclaimReturnedObject:\n    return asImpl().visitReclaimReturnedObject(e->getSubExpr());\n\n  // Otherwise, use the default logic.\n  default:\n    return asImpl().visitExpr(e);\n  }\n}\n\ntemplate <typename Impl, typename Result>\nResult\nARCExprEmitter<Impl,Result>::visitBinaryOperator(const BinaryOperator *e) {\n  switch (e->getOpcode()) {\n  case BO_Comma:\n    CGF.EmitIgnoredExpr(e->getLHS());\n    CGF.EnsureInsertPoint();\n    return asImpl().visit(e->getRHS());\n\n  case BO_Assign:\n    return asImpl().visitBinAssign(e);\n\n  default:\n    return asImpl().visitExpr(e);\n  }\n}\n\ntemplate <typename Impl, typename Result>\nResult ARCExprEmitter<Impl,Result>::visitBinAssign(const BinaryOperator *e) {\n  switch (e->getLHS()->getType().getObjCLifetime()) {\n  case Qualifiers::OCL_ExplicitNone:\n    return asImpl().visitBinAssignUnsafeUnretained(e);\n\n  case Qualifiers::OCL_Weak:\n    return asImpl().visitBinAssignWeak(e);\n\n  case Qualifiers::OCL_Autoreleasing:\n    return asImpl().visitBinAssignAutoreleasing(e);\n\n  case Qualifiers::OCL_Strong:\n    return asImpl().visitBinAssignStrong(e);\n\n  case Qualifiers::OCL_None:\n    return asImpl().visitExpr(e);\n  }\n  llvm_unreachable(\"bad ObjC ownership qualifier\");\n}\n\n/// The default rule for __unsafe_unretained emits the RHS recursively,\n/// stores into the unsafe variable, and propagates the result outward.\ntemplate <typename Impl, typename Result>\nResult ARCExprEmitter<Impl,Result>::\n                    visitBinAssignUnsafeUnretained(const BinaryOperator *e) {\n  // Recursively emit the RHS.\n  // For __block safety, do this before emitting the LHS.\n  Result result = asImpl().visit(e->getRHS());\n\n  // Perform the store.\n  LValue lvalue =\n    CGF.EmitCheckedLValue(e->getLHS(), CodeGenFunction::TCK_Store);\n  CGF.EmitStoreThroughLValue(RValue::get(asImpl().getValueOfResult(result)),\n                             lvalue);\n\n  return result;\n}\n\ntemplate <typename Impl, typename Result>\nResult\nARCExprEmitter<Impl,Result>::visitBinAssignAutoreleasing(const BinaryOperator *e) {\n  return asImpl().visitExpr(e);\n}\n\ntemplate <typename Impl, typename Result>\nResult\nARCExprEmitter<Impl,Result>::visitBinAssignWeak(const BinaryOperator *e) {\n  return asImpl().visitExpr(e);\n}\n\ntemplate <typename Impl, typename Result>\nResult\nARCExprEmitter<Impl,Result>::visitBinAssignStrong(const BinaryOperator *e) {\n  return asImpl().visitExpr(e);\n}\n\n/// The general expression-emission logic.\ntemplate <typename Impl, typename Result>\nResult ARCExprEmitter<Impl,Result>::visit(const Expr *e) {\n  // We should *never* see a nested full-expression here, because if\n  // we fail to emit at +1, our caller must not retain after we close\n  // out the full-expression.  This isn't as important in the unsafe\n  // emitter.\n  assert(!isa<ExprWithCleanups>(e));\n\n  // Look through parens, __extension__, generic selection, etc.\n  e = e->IgnoreParens();\n\n  // Handle certain kinds of casts.\n  if (const CastExpr *ce = dyn_cast<CastExpr>(e)) {\n    return asImpl().visitCastExpr(ce);\n\n  // Handle the comma operator.\n  } else if (auto op = dyn_cast<BinaryOperator>(e)) {\n    return asImpl().visitBinaryOperator(op);\n\n  // TODO: handle conditional operators here\n\n  // For calls and message sends, use the retained-call logic.\n  // Delegate inits are a special case in that they're the only\n  // returns-retained expression that *isn't* surrounded by\n  // a consume.\n  } else if (isa<CallExpr>(e) ||\n             (isa<ObjCMessageExpr>(e) &&\n              !cast<ObjCMessageExpr>(e)->isDelegateInitCall())) {\n    return asImpl().visitCall(e);\n\n  // Look through pseudo-object expressions.\n  } else if (const PseudoObjectExpr *pseudo = dyn_cast<PseudoObjectExpr>(e)) {\n    return asImpl().visitPseudoObjectExpr(pseudo);\n  } else if (auto *be = dyn_cast<BlockExpr>(e))\n    return asImpl().visitBlockExpr(be);\n\n  return asImpl().visitExpr(e);\n}\n\nnamespace {\n\n/// An emitter for +1 results.\nstruct ARCRetainExprEmitter :\n  public ARCExprEmitter<ARCRetainExprEmitter, TryEmitResult> {\n\n  ARCRetainExprEmitter(CodeGenFunction &CGF) : ARCExprEmitter(CGF) {}\n\n  llvm::Value *getValueOfResult(TryEmitResult result) {\n    return result.getPointer();\n  }\n\n  TryEmitResult emitBitCast(TryEmitResult result, llvm::Type *resultType) {\n    llvm::Value *value = result.getPointer();\n    value = CGF.Builder.CreateBitCast(value, resultType);\n    result.setPointer(value);\n    return result;\n  }\n\n  TryEmitResult visitLValueToRValue(const Expr *e) {\n    return tryEmitARCRetainLoadOfScalar(CGF, e);\n  }\n\n  /// For consumptions, just emit the subexpression and thus elide\n  /// the retain/release pair.\n  TryEmitResult visitConsumeObject(const Expr *e) {\n    llvm::Value *result = CGF.EmitScalarExpr(e);\n    return TryEmitResult(result, true);\n  }\n\n  TryEmitResult visitBlockExpr(const BlockExpr *e) {\n    TryEmitResult result = visitExpr(e);\n    // Avoid the block-retain if this is a block literal that doesn't need to be\n    // copied to the heap.\n    if (e->getBlockDecl()->canAvoidCopyToHeap())\n      result.setInt(true);\n    return result;\n  }\n\n  /// Block extends are net +0.  Naively, we could just recurse on\n  /// the subexpression, but actually we need to ensure that the\n  /// value is copied as a block, so there's a little filter here.\n  TryEmitResult visitExtendBlockObject(const Expr *e) {\n    llvm::Value *result; // will be a +0 value\n\n    // If we can't safely assume the sub-expression will produce a\n    // block-copied value, emit the sub-expression at +0.\n    if (shouldEmitSeparateBlockRetain(e)) {\n      result = CGF.EmitScalarExpr(e);\n\n    // Otherwise, try to emit the sub-expression at +1 recursively.\n    } else {\n      TryEmitResult subresult = asImpl().visit(e);\n\n      // If that produced a retained value, just use that.\n      if (subresult.getInt()) {\n        return subresult;\n      }\n\n      // Otherwise it's +0.\n      result = subresult.getPointer();\n    }\n\n    // Retain the object as a block.\n    result = CGF.EmitARCRetainBlock(result, /*mandatory*/ true);\n    return TryEmitResult(result, true);\n  }\n\n  /// For reclaims, emit the subexpression as a retained call and\n  /// skip the consumption.\n  TryEmitResult visitReclaimReturnedObject(const Expr *e) {\n    llvm::Value *result = emitARCRetainCallResult(CGF, e);\n    return TryEmitResult(result, true);\n  }\n\n  /// When we have an undecorated call, retroactively do a claim.\n  TryEmitResult visitCall(const Expr *e) {\n    llvm::Value *result = emitARCRetainCallResult(CGF, e);\n    return TryEmitResult(result, true);\n  }\n\n  // TODO: maybe special-case visitBinAssignWeak?\n\n  TryEmitResult visitExpr(const Expr *e) {\n    // We didn't find an obvious production, so emit what we've got and\n    // tell the caller that we didn't manage to retain.\n    llvm::Value *result = CGF.EmitScalarExpr(e);\n    return TryEmitResult(result, false);\n  }\n};\n}\n\nstatic TryEmitResult\ntryEmitARCRetainScalarExpr(CodeGenFunction &CGF, const Expr *e) {\n  return ARCRetainExprEmitter(CGF).visit(e);\n}\n\nstatic llvm::Value *emitARCRetainLoadOfScalar(CodeGenFunction &CGF,\n                                                LValue lvalue,\n                                                QualType type) {\n  TryEmitResult result = tryEmitARCRetainLoadOfScalar(CGF, lvalue, type);\n  llvm::Value *value = result.getPointer();\n  if (!result.getInt())\n    value = CGF.EmitARCRetain(type, value);\n  return value;\n}\n\n/// EmitARCRetainScalarExpr - Semantically equivalent to\n/// EmitARCRetainObject(e->getType(), EmitScalarExpr(e)), but making a\n/// best-effort attempt to peephole expressions that naturally produce\n/// retained objects.\nllvm::Value *CodeGenFunction::EmitARCRetainScalarExpr(const Expr *e) {\n  // The retain needs to happen within the full-expression.\n  if (const ExprWithCleanups *cleanups = dyn_cast<ExprWithCleanups>(e)) {\n    RunCleanupsScope scope(*this);\n    return EmitARCRetainScalarExpr(cleanups->getSubExpr());\n  }\n\n  TryEmitResult result = tryEmitARCRetainScalarExpr(*this, e);\n  llvm::Value *value = result.getPointer();\n  if (!result.getInt())\n    value = EmitARCRetain(e->getType(), value);\n  return value;\n}\n\nllvm::Value *\nCodeGenFunction::EmitARCRetainAutoreleaseScalarExpr(const Expr *e) {\n  // The retain needs to happen within the full-expression.\n  if (const ExprWithCleanups *cleanups = dyn_cast<ExprWithCleanups>(e)) {\n    RunCleanupsScope scope(*this);\n    return EmitARCRetainAutoreleaseScalarExpr(cleanups->getSubExpr());\n  }\n\n  TryEmitResult result = tryEmitARCRetainScalarExpr(*this, e);\n  llvm::Value *value = result.getPointer();\n  if (result.getInt())\n    value = EmitARCAutorelease(value);\n  else\n    value = EmitARCRetainAutorelease(e->getType(), value);\n  return value;\n}\n\nllvm::Value *CodeGenFunction::EmitARCExtendBlockObject(const Expr *e) {\n  llvm::Value *result;\n  bool doRetain;\n\n  if (shouldEmitSeparateBlockRetain(e)) {\n    result = EmitScalarExpr(e);\n    doRetain = true;\n  } else {\n    TryEmitResult subresult = tryEmitARCRetainScalarExpr(*this, e);\n    result = subresult.getPointer();\n    doRetain = !subresult.getInt();\n  }\n\n  if (doRetain)\n    result = EmitARCRetainBlock(result, /*mandatory*/ true);\n  return EmitObjCConsumeObject(e->getType(), result);\n}\n\nllvm::Value *CodeGenFunction::EmitObjCThrowOperand(const Expr *expr) {\n  // In ARC, retain and autorelease the expression.\n  if (getLangOpts().ObjCAutoRefCount) {\n    // Do so before running any cleanups for the full-expression.\n    // EmitARCRetainAutoreleaseScalarExpr does this for us.\n    return EmitARCRetainAutoreleaseScalarExpr(expr);\n  }\n\n  // Otherwise, use the normal scalar-expression emission.  The\n  // exception machinery doesn't do anything special with the\n  // exception like retaining it, so there's no safety associated with\n  // only running cleanups after the throw has started, and when it\n  // matters it tends to be substantially inferior code.\n  return EmitScalarExpr(expr);\n}\n\nnamespace {\n\n/// An emitter for assigning into an __unsafe_unretained context.\nstruct ARCUnsafeUnretainedExprEmitter :\n  public ARCExprEmitter<ARCUnsafeUnretainedExprEmitter, llvm::Value*> {\n\n  ARCUnsafeUnretainedExprEmitter(CodeGenFunction &CGF) : ARCExprEmitter(CGF) {}\n\n  llvm::Value *getValueOfResult(llvm::Value *value) {\n    return value;\n  }\n\n  llvm::Value *emitBitCast(llvm::Value *value, llvm::Type *resultType) {\n    return CGF.Builder.CreateBitCast(value, resultType);\n  }\n\n  llvm::Value *visitLValueToRValue(const Expr *e) {\n    return CGF.EmitScalarExpr(e);\n  }\n\n  /// For consumptions, just emit the subexpression and perform the\n  /// consumption like normal.\n  llvm::Value *visitConsumeObject(const Expr *e) {\n    llvm::Value *value = CGF.EmitScalarExpr(e);\n    return CGF.EmitObjCConsumeObject(e->getType(), value);\n  }\n\n  /// No special logic for block extensions.  (This probably can't\n  /// actually happen in this emitter, though.)\n  llvm::Value *visitExtendBlockObject(const Expr *e) {\n    return CGF.EmitARCExtendBlockObject(e);\n  }\n\n  /// For reclaims, perform an unsafeClaim if that's enabled.\n  llvm::Value *visitReclaimReturnedObject(const Expr *e) {\n    return CGF.EmitARCReclaimReturnedObject(e, /*unsafe*/ true);\n  }\n\n  /// When we have an undecorated call, just emit it without adding\n  /// the unsafeClaim.\n  llvm::Value *visitCall(const Expr *e) {\n    return CGF.EmitScalarExpr(e);\n  }\n\n  /// Just do normal scalar emission in the default case.\n  llvm::Value *visitExpr(const Expr *e) {\n    return CGF.EmitScalarExpr(e);\n  }\n};\n}\n\nstatic llvm::Value *emitARCUnsafeUnretainedScalarExpr(CodeGenFunction &CGF,\n                                                      const Expr *e) {\n  return ARCUnsafeUnretainedExprEmitter(CGF).visit(e);\n}\n\n/// EmitARCUnsafeUnretainedScalarExpr - Semantically equivalent to\n/// immediately releasing the resut of EmitARCRetainScalarExpr, but\n/// avoiding any spurious retains, including by performing reclaims\n/// with objc_unsafeClaimAutoreleasedReturnValue.\nllvm::Value *CodeGenFunction::EmitARCUnsafeUnretainedScalarExpr(const Expr *e) {\n  // Look through full-expressions.\n  if (const ExprWithCleanups *cleanups = dyn_cast<ExprWithCleanups>(e)) {\n    RunCleanupsScope scope(*this);\n    return emitARCUnsafeUnretainedScalarExpr(*this, cleanups->getSubExpr());\n  }\n\n  return emitARCUnsafeUnretainedScalarExpr(*this, e);\n}\n\nstd::pair<LValue,llvm::Value*>\nCodeGenFunction::EmitARCStoreUnsafeUnretained(const BinaryOperator *e,\n                                              bool ignored) {\n  // Evaluate the RHS first.  If we're ignoring the result, assume\n  // that we can emit at an unsafe +0.\n  llvm::Value *value;\n  if (ignored) {\n    value = EmitARCUnsafeUnretainedScalarExpr(e->getRHS());\n  } else {\n    value = EmitScalarExpr(e->getRHS());\n  }\n\n  // Emit the LHS and perform the store.\n  LValue lvalue = EmitLValue(e->getLHS());\n  EmitStoreOfScalar(value, lvalue);\n\n  return std::pair<LValue,llvm::Value*>(std::move(lvalue), value);\n}\n\nstd::pair<LValue,llvm::Value*>\nCodeGenFunction::EmitARCStoreStrong(const BinaryOperator *e,\n                                    bool ignored) {\n  // Evaluate the RHS first.\n  TryEmitResult result = tryEmitARCRetainScalarExpr(*this, e->getRHS());\n  llvm::Value *value = result.getPointer();\n\n  bool hasImmediateRetain = result.getInt();\n\n  // If we didn't emit a retained object, and the l-value is of block\n  // type, then we need to emit the block-retain immediately in case\n  // it invalidates the l-value.\n  if (!hasImmediateRetain && e->getType()->isBlockPointerType()) {\n    value = EmitARCRetainBlock(value, /*mandatory*/ false);\n    hasImmediateRetain = true;\n  }\n\n  LValue lvalue = EmitLValue(e->getLHS());\n\n  // If the RHS was emitted retained, expand this.\n  if (hasImmediateRetain) {\n    llvm::Value *oldValue = EmitLoadOfScalar(lvalue, SourceLocation());\n    EmitStoreOfScalar(value, lvalue);\n    EmitARCRelease(oldValue, lvalue.isARCPreciseLifetime());\n  } else {\n    value = EmitARCStoreStrong(lvalue, value, ignored);\n  }\n\n  return std::pair<LValue,llvm::Value*>(lvalue, value);\n}\n\nstd::pair<LValue,llvm::Value*>\nCodeGenFunction::EmitARCStoreAutoreleasing(const BinaryOperator *e) {\n  llvm::Value *value = EmitARCRetainAutoreleaseScalarExpr(e->getRHS());\n  LValue lvalue = EmitLValue(e->getLHS());\n\n  EmitStoreOfScalar(value, lvalue);\n\n  return std::pair<LValue,llvm::Value*>(lvalue, value);\n}\n\nvoid CodeGenFunction::EmitObjCAutoreleasePoolStmt(\n                                          const ObjCAutoreleasePoolStmt &ARPS) {\n  const Stmt *subStmt = ARPS.getSubStmt();\n  const CompoundStmt &S = cast<CompoundStmt>(*subStmt);\n\n  CGDebugInfo *DI = getDebugInfo();\n  if (DI)\n    DI->EmitLexicalBlockStart(Builder, S.getLBracLoc());\n\n  // Keep track of the current cleanup stack depth.\n  RunCleanupsScope Scope(*this);\n  if (CGM.getLangOpts().ObjCRuntime.hasNativeARC()) {\n    llvm::Value *token = EmitObjCAutoreleasePoolPush();\n    EHStack.pushCleanup<CallObjCAutoreleasePoolObject>(NormalCleanup, token);\n  } else {\n    llvm::Value *token = EmitObjCMRRAutoreleasePoolPush();\n    EHStack.pushCleanup<CallObjCMRRAutoreleasePoolObject>(NormalCleanup, token);\n  }\n\n  for (const auto *I : S.body())\n    EmitStmt(I);\n\n  if (DI)\n    DI->EmitLexicalBlockEnd(Builder, S.getRBracLoc());\n}\n\n/// EmitExtendGCLifetime - Given a pointer to an Objective-C object,\n/// make sure it survives garbage collection until this point.\nvoid CodeGenFunction::EmitExtendGCLifetime(llvm::Value *object) {\n  // We just use an inline assembly.\n  llvm::FunctionType *extenderType\n    = llvm::FunctionType::get(VoidTy, VoidPtrTy, RequiredArgs::All);\n  llvm::InlineAsm *extender = llvm::InlineAsm::get(extenderType,\n                                                   /* assembly */ \"\",\n                                                   /* constraints */ \"r\",\n                                                   /* side effects */ true);\n\n  object = Builder.CreateBitCast(object, VoidPtrTy);\n  EmitNounwindRuntimeCall(extender, object);\n}\n\n/// GenerateObjCAtomicSetterCopyHelperFunction - Given a c++ object type with\n/// non-trivial copy assignment function, produce following helper function.\n/// static void copyHelper(Ty *dest, const Ty *source) { *dest = *source; }\n///\nllvm::Constant *\nCodeGenFunction::GenerateObjCAtomicSetterCopyHelperFunction(\n                                        const ObjCPropertyImplDecl *PID) {\n  if (!getLangOpts().CPlusPlus ||\n      !getLangOpts().ObjCRuntime.hasAtomicCopyHelper())\n    return nullptr;\n  QualType Ty = PID->getPropertyIvarDecl()->getType();\n  if (!Ty->isRecordType())\n    return nullptr;\n  const ObjCPropertyDecl *PD = PID->getPropertyDecl();\n  if ((!(PD->getPropertyAttributes() & ObjCPropertyAttribute::kind_atomic)))\n    return nullptr;\n  llvm::Constant *HelperFn = nullptr;\n  if (hasTrivialSetExpr(PID))\n    return nullptr;\n  assert(PID->getSetterCXXAssignment() && \"SetterCXXAssignment - null\");\n  if ((HelperFn = CGM.getAtomicSetterHelperFnMap(Ty)))\n    return HelperFn;\n\n  ASTContext &C = getContext();\n  IdentifierInfo *II\n    = &CGM.getContext().Idents.get(\"__assign_helper_atomic_property_\");\n\n  QualType ReturnTy = C.VoidTy;\n  QualType DestTy = C.getPointerType(Ty);\n  QualType SrcTy = Ty;\n  SrcTy.addConst();\n  SrcTy = C.getPointerType(SrcTy);\n\n  SmallVector<QualType, 2> ArgTys;\n  ArgTys.push_back(DestTy);\n  ArgTys.push_back(SrcTy);\n  QualType FunctionTy = C.getFunctionType(ReturnTy, ArgTys, {});\n\n  FunctionDecl *FD = FunctionDecl::Create(\n      C, C.getTranslationUnitDecl(), SourceLocation(), SourceLocation(), II,\n      FunctionTy, nullptr, SC_Static, false, false);\n\n  FunctionArgList args;\n  ImplicitParamDecl DstDecl(C, FD, SourceLocation(), /*Id=*/nullptr, DestTy,\n                            ImplicitParamDecl::Other);\n  args.push_back(&DstDecl);\n  ImplicitParamDecl SrcDecl(C, FD, SourceLocation(), /*Id=*/nullptr, SrcTy,\n                            ImplicitParamDecl::Other);\n  args.push_back(&SrcDecl);\n\n  const CGFunctionInfo &FI =\n      CGM.getTypes().arrangeBuiltinFunctionDeclaration(ReturnTy, args);\n\n  llvm::FunctionType *LTy = CGM.getTypes().GetFunctionType(FI);\n\n  llvm::Function *Fn =\n    llvm::Function::Create(LTy, llvm::GlobalValue::InternalLinkage,\n                           \"__assign_helper_atomic_property_\",\n                           &CGM.getModule());\n\n  CGM.SetInternalFunctionAttributes(GlobalDecl(), Fn, FI);\n\n  StartFunction(FD, ReturnTy, Fn, FI, args);\n\n  DeclRefExpr DstExpr(C, &DstDecl, false, DestTy, VK_RValue, SourceLocation());\n  UnaryOperator *DST = UnaryOperator::Create(\n      C, &DstExpr, UO_Deref, DestTy->getPointeeType(), VK_LValue, OK_Ordinary,\n      SourceLocation(), false, FPOptionsOverride());\n\n  DeclRefExpr SrcExpr(C, &SrcDecl, false, SrcTy, VK_RValue, SourceLocation());\n  UnaryOperator *SRC = UnaryOperator::Create(\n      C, &SrcExpr, UO_Deref, SrcTy->getPointeeType(), VK_LValue, OK_Ordinary,\n      SourceLocation(), false, FPOptionsOverride());\n\n  Expr *Args[2] = {DST, SRC};\n  CallExpr *CalleeExp = cast<CallExpr>(PID->getSetterCXXAssignment());\n  CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(\n      C, OO_Equal, CalleeExp->getCallee(), Args, DestTy->getPointeeType(),\n      VK_LValue, SourceLocation(), FPOptionsOverride());\n\n  EmitStmt(TheCall);\n\n  FinishFunction();\n  HelperFn = llvm::ConstantExpr::getBitCast(Fn, VoidPtrTy);\n  CGM.setAtomicSetterHelperFnMap(Ty, HelperFn);\n  return HelperFn;\n}\n\nllvm::Constant *\nCodeGenFunction::GenerateObjCAtomicGetterCopyHelperFunction(\n                                            const ObjCPropertyImplDecl *PID) {\n  if (!getLangOpts().CPlusPlus ||\n      !getLangOpts().ObjCRuntime.hasAtomicCopyHelper())\n    return nullptr;\n  const ObjCPropertyDecl *PD = PID->getPropertyDecl();\n  QualType Ty = PD->getType();\n  if (!Ty->isRecordType())\n    return nullptr;\n  if ((!(PD->getPropertyAttributes() & ObjCPropertyAttribute::kind_atomic)))\n    return nullptr;\n  llvm::Constant *HelperFn = nullptr;\n  if (hasTrivialGetExpr(PID))\n    return nullptr;\n  assert(PID->getGetterCXXConstructor() && \"getGetterCXXConstructor - null\");\n  if ((HelperFn = CGM.getAtomicGetterHelperFnMap(Ty)))\n    return HelperFn;\n\n  ASTContext &C = getContext();\n  IdentifierInfo *II =\n      &CGM.getContext().Idents.get(\"__copy_helper_atomic_property_\");\n\n  QualType ReturnTy = C.VoidTy;\n  QualType DestTy = C.getPointerType(Ty);\n  QualType SrcTy = Ty;\n  SrcTy.addConst();\n  SrcTy = C.getPointerType(SrcTy);\n\n  SmallVector<QualType, 2> ArgTys;\n  ArgTys.push_back(DestTy);\n  ArgTys.push_back(SrcTy);\n  QualType FunctionTy = C.getFunctionType(ReturnTy, ArgTys, {});\n\n  FunctionDecl *FD = FunctionDecl::Create(\n      C, C.getTranslationUnitDecl(), SourceLocation(), SourceLocation(), II,\n      FunctionTy, nullptr, SC_Static, false, false);\n\n  FunctionArgList args;\n  ImplicitParamDecl DstDecl(C, FD, SourceLocation(), /*Id=*/nullptr, DestTy,\n                            ImplicitParamDecl::Other);\n  args.push_back(&DstDecl);\n  ImplicitParamDecl SrcDecl(C, FD, SourceLocation(), /*Id=*/nullptr, SrcTy,\n                            ImplicitParamDecl::Other);\n  args.push_back(&SrcDecl);\n\n  const CGFunctionInfo &FI =\n      CGM.getTypes().arrangeBuiltinFunctionDeclaration(ReturnTy, args);\n\n  llvm::FunctionType *LTy = CGM.getTypes().GetFunctionType(FI);\n\n  llvm::Function *Fn = llvm::Function::Create(\n      LTy, llvm::GlobalValue::InternalLinkage, \"__copy_helper_atomic_property_\",\n      &CGM.getModule());\n\n  CGM.SetInternalFunctionAttributes(GlobalDecl(), Fn, FI);\n\n  StartFunction(FD, ReturnTy, Fn, FI, args);\n\n  DeclRefExpr SrcExpr(getContext(), &SrcDecl, false, SrcTy, VK_RValue,\n                      SourceLocation());\n\n  UnaryOperator *SRC = UnaryOperator::Create(\n      C, &SrcExpr, UO_Deref, SrcTy->getPointeeType(), VK_LValue, OK_Ordinary,\n      SourceLocation(), false, FPOptionsOverride());\n\n  CXXConstructExpr *CXXConstExpr =\n    cast<CXXConstructExpr>(PID->getGetterCXXConstructor());\n\n  SmallVector<Expr*, 4> ConstructorArgs;\n  ConstructorArgs.push_back(SRC);\n  ConstructorArgs.append(std::next(CXXConstExpr->arg_begin()),\n                         CXXConstExpr->arg_end());\n\n  CXXConstructExpr *TheCXXConstructExpr =\n    CXXConstructExpr::Create(C, Ty, SourceLocation(),\n                             CXXConstExpr->getConstructor(),\n                             CXXConstExpr->isElidable(),\n                             ConstructorArgs,\n                             CXXConstExpr->hadMultipleCandidates(),\n                             CXXConstExpr->isListInitialization(),\n                             CXXConstExpr->isStdInitListInitialization(),\n                             CXXConstExpr->requiresZeroInitialization(),\n                             CXXConstExpr->getConstructionKind(),\n                             SourceRange());\n\n  DeclRefExpr DstExpr(getContext(), &DstDecl, false, DestTy, VK_RValue,\n                      SourceLocation());\n\n  RValue DV = EmitAnyExpr(&DstExpr);\n  CharUnits Alignment\n    = getContext().getTypeAlignInChars(TheCXXConstructExpr->getType());\n  EmitAggExpr(TheCXXConstructExpr,\n              AggValueSlot::forAddr(Address(DV.getScalarVal(), Alignment),\n                                    Qualifiers(),\n                                    AggValueSlot::IsDestructed,\n                                    AggValueSlot::DoesNotNeedGCBarriers,\n                                    AggValueSlot::IsNotAliased,\n                                    AggValueSlot::DoesNotOverlap));\n\n  FinishFunction();\n  HelperFn = llvm::ConstantExpr::getBitCast(Fn, VoidPtrTy);\n  CGM.setAtomicGetterHelperFnMap(Ty, HelperFn);\n  return HelperFn;\n}\n\nllvm::Value *\nCodeGenFunction::EmitBlockCopyAndAutorelease(llvm::Value *Block, QualType Ty) {\n  // Get selectors for retain/autorelease.\n  IdentifierInfo *CopyID = &getContext().Idents.get(\"copy\");\n  Selector CopySelector =\n      getContext().Selectors.getNullarySelector(CopyID);\n  IdentifierInfo *AutoreleaseID = &getContext().Idents.get(\"autorelease\");\n  Selector AutoreleaseSelector =\n      getContext().Selectors.getNullarySelector(AutoreleaseID);\n\n  // Emit calls to retain/autorelease.\n  CGObjCRuntime &Runtime = CGM.getObjCRuntime();\n  llvm::Value *Val = Block;\n  RValue Result;\n  Result = Runtime.GenerateMessageSend(*this, ReturnValueSlot(),\n                                       Ty, CopySelector,\n                                       Val, CallArgList(), nullptr, nullptr);\n  Val = Result.getScalarVal();\n  Result = Runtime.GenerateMessageSend(*this, ReturnValueSlot(),\n                                       Ty, AutoreleaseSelector,\n                                       Val, CallArgList(), nullptr, nullptr);\n  Val = Result.getScalarVal();\n  return Val;\n}\n\nstatic unsigned getBaseMachOPlatformID(const llvm::Triple &TT) {\n  switch (TT.getOS()) {\n  case llvm::Triple::Darwin:\n  case llvm::Triple::MacOSX:\n    return llvm::MachO::PLATFORM_MACOS;\n  case llvm::Triple::IOS:\n    return llvm::MachO::PLATFORM_IOS;\n  case llvm::Triple::TvOS:\n    return llvm::MachO::PLATFORM_TVOS;\n  case llvm::Triple::WatchOS:\n    return llvm::MachO::PLATFORM_WATCHOS;\n  default:\n    return /*Unknown platform*/ 0;\n  }\n}\n\nstatic llvm::Value *emitIsPlatformVersionAtLeast(CodeGenFunction &CGF,\n                                                 const VersionTuple &Version) {\n  CodeGenModule &CGM = CGF.CGM;\n  // Note: we intend to support multi-platform version checks, so reserve\n  // the room for a dual platform checking invocation that will be\n  // implemented in the future.\n  llvm::SmallVector<llvm::Value *, 8> Args;\n\n  auto EmitArgs = [&](const VersionTuple &Version, const llvm::Triple &TT) {\n    Optional<unsigned> Min = Version.getMinor(), SMin = Version.getSubminor();\n    Args.push_back(\n        llvm::ConstantInt::get(CGM.Int32Ty, getBaseMachOPlatformID(TT)));\n    Args.push_back(llvm::ConstantInt::get(CGM.Int32Ty, Version.getMajor()));\n    Args.push_back(llvm::ConstantInt::get(CGM.Int32Ty, Min ? *Min : 0));\n    Args.push_back(llvm::ConstantInt::get(CGM.Int32Ty, SMin ? *SMin : 0));\n  };\n\n  assert(!Version.empty() && \"unexpected empty version\");\n  EmitArgs(Version, CGM.getTarget().getTriple());\n\n  if (!CGM.IsPlatformVersionAtLeastFn) {\n    llvm::FunctionType *FTy = llvm::FunctionType::get(\n        CGM.Int32Ty, {CGM.Int32Ty, CGM.Int32Ty, CGM.Int32Ty, CGM.Int32Ty},\n        false);\n    CGM.IsPlatformVersionAtLeastFn =\n        CGM.CreateRuntimeFunction(FTy, \"__isPlatformVersionAtLeast\");\n  }\n\n  llvm::Value *Check =\n      CGF.EmitNounwindRuntimeCall(CGM.IsPlatformVersionAtLeastFn, Args);\n  return CGF.Builder.CreateICmpNE(Check,\n                                  llvm::Constant::getNullValue(CGM.Int32Ty));\n}\n\nllvm::Value *\nCodeGenFunction::EmitBuiltinAvailable(const VersionTuple &Version) {\n  // Darwin uses the new __isPlatformVersionAtLeast family of routines.\n  if (CGM.getTarget().getTriple().isOSDarwin())\n    return emitIsPlatformVersionAtLeast(*this, Version);\n\n  if (!CGM.IsOSVersionAtLeastFn) {\n    llvm::FunctionType *FTy =\n        llvm::FunctionType::get(Int32Ty, {Int32Ty, Int32Ty, Int32Ty}, false);\n    CGM.IsOSVersionAtLeastFn =\n        CGM.CreateRuntimeFunction(FTy, \"__isOSVersionAtLeast\");\n  }\n\n  Optional<unsigned> Min = Version.getMinor(), SMin = Version.getSubminor();\n  llvm::Value *Args[] = {\n      llvm::ConstantInt::get(CGM.Int32Ty, Version.getMajor()),\n      llvm::ConstantInt::get(CGM.Int32Ty, Min ? *Min : 0),\n      llvm::ConstantInt::get(CGM.Int32Ty, SMin ? *SMin : 0),\n  };\n\n  llvm::Value *CallRes =\n      EmitNounwindRuntimeCall(CGM.IsOSVersionAtLeastFn, Args);\n\n  return Builder.CreateICmpNE(CallRes, llvm::Constant::getNullValue(Int32Ty));\n}\n\nstatic bool isFoundationNeededForDarwinAvailabilityCheck(\n    const llvm::Triple &TT, const VersionTuple &TargetVersion) {\n  VersionTuple FoundationDroppedInVersion;\n  switch (TT.getOS()) {\n  case llvm::Triple::IOS:\n  case llvm::Triple::TvOS:\n    FoundationDroppedInVersion = VersionTuple(/*Major=*/13);\n    break;\n  case llvm::Triple::WatchOS:\n    FoundationDroppedInVersion = VersionTuple(/*Major=*/6);\n    break;\n  case llvm::Triple::Darwin:\n  case llvm::Triple::MacOSX:\n    FoundationDroppedInVersion = VersionTuple(/*Major=*/10, /*Minor=*/15);\n    break;\n  default:\n    llvm_unreachable(\"Unexpected OS\");\n  }\n  return TargetVersion < FoundationDroppedInVersion;\n}\n\nvoid CodeGenModule::emitAtAvailableLinkGuard() {\n  if (!IsPlatformVersionAtLeastFn)\n    return;\n  // @available requires CoreFoundation only on Darwin.\n  if (!Target.getTriple().isOSDarwin())\n    return;\n  // @available doesn't need Foundation on macOS 10.15+, iOS/tvOS 13+, or\n  // watchOS 6+.\n  if (!isFoundationNeededForDarwinAvailabilityCheck(\n          Target.getTriple(), Target.getPlatformMinVersion()))\n    return;\n  // Add -framework CoreFoundation to the linker commands. We still want to\n  // emit the core foundation reference down below because otherwise if\n  // CoreFoundation is not used in the code, the linker won't link the\n  // framework.\n  auto &Context = getLLVMContext();\n  llvm::Metadata *Args[2] = {llvm::MDString::get(Context, \"-framework\"),\n                             llvm::MDString::get(Context, \"CoreFoundation\")};\n  LinkerOptionsMetadata.push_back(llvm::MDNode::get(Context, Args));\n  // Emit a reference to a symbol from CoreFoundation to ensure that\n  // CoreFoundation is linked into the final binary.\n  llvm::FunctionType *FTy =\n      llvm::FunctionType::get(Int32Ty, {VoidPtrTy}, false);\n  llvm::FunctionCallee CFFunc =\n      CreateRuntimeFunction(FTy, \"CFBundleGetVersionNumber\");\n\n  llvm::FunctionType *CheckFTy = llvm::FunctionType::get(VoidTy, {}, false);\n  llvm::FunctionCallee CFLinkCheckFuncRef = CreateRuntimeFunction(\n      CheckFTy, \"__clang_at_available_requires_core_foundation_framework\",\n      llvm::AttributeList(), /*Local=*/true);\n  llvm::Function *CFLinkCheckFunc =\n      cast<llvm::Function>(CFLinkCheckFuncRef.getCallee()->stripPointerCasts());\n  if (CFLinkCheckFunc->empty()) {\n    CFLinkCheckFunc->setLinkage(llvm::GlobalValue::LinkOnceAnyLinkage);\n    CFLinkCheckFunc->setVisibility(llvm::GlobalValue::HiddenVisibility);\n    CodeGenFunction CGF(*this);\n    CGF.Builder.SetInsertPoint(CGF.createBasicBlock(\"\", CFLinkCheckFunc));\n    CGF.EmitNounwindRuntimeCall(CFFunc,\n                                llvm::Constant::getNullValue(VoidPtrTy));\n    CGF.Builder.CreateUnreachable();\n    addCompilerUsedGlobal(CFLinkCheckFunc);\n  }\n}\n\nCGObjCRuntime::~CGObjCRuntime() {}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 14, "line": 263}, "message": "destructor '~ObjCDictionaryElement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "7fee768157de6d848a2f8435ce400ecf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 40, "line": 2993}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "reportHash": "661eb8e91cd45897ed697ad69a8ccbec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 40, "line": 2996}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "reportHash": "661eb8e91cd45897ed697ad69a8ccbec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 40, "line": 3007}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "reportHash": "661eb8e91cd45897ed697ad69a8ccbec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 40, "line": 3010}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "reportHash": "661eb8e91cd45897ed697ad69a8ccbec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 40, "line": 3897}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "reportHash": "547ceef40ca30a9d8aec53635c788f32", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 40, "line": 3897}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjC.cpp", "reportHash": "ca6112d05682de8762bed592327f8180", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
