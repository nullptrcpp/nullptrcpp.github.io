<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "content": "//===------ SemaDeclCXX.cpp - Semantic Analysis for C++ Declarations ------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements semantic analysis for C++ declarations.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/EvaluatedExprVisitor.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/LiteralSupport.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/CXXFieldCollector.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/ParsedTemplate.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"llvm/ADT/ScopeExit.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include <map>\n#include <set>\n\nusing namespace clang;\n\n//===----------------------------------------------------------------------===//\n// CheckDefaultArgumentVisitor\n//===----------------------------------------------------------------------===//\n\nnamespace {\n/// CheckDefaultArgumentVisitor - C++ [dcl.fct.default] Traverses\n/// the default argument of a parameter to determine whether it\n/// contains any ill-formed subexpressions. For example, this will\n/// diagnose the use of local variables or parameters within the\n/// default argument expression.\nclass CheckDefaultArgumentVisitor\n    : public ConstStmtVisitor<CheckDefaultArgumentVisitor, bool> {\n  Sema &S;\n  const Expr *DefaultArg;\n\npublic:\n  CheckDefaultArgumentVisitor(Sema &S, const Expr *DefaultArg)\n      : S(S), DefaultArg(DefaultArg) {}\n\n  bool VisitExpr(const Expr *Node);\n  bool VisitDeclRefExpr(const DeclRefExpr *DRE);\n  bool VisitCXXThisExpr(const CXXThisExpr *ThisE);\n  bool VisitLambdaExpr(const LambdaExpr *Lambda);\n  bool VisitPseudoObjectExpr(const PseudoObjectExpr *POE);\n};\n\n/// VisitExpr - Visit all of the children of this expression.\nbool CheckDefaultArgumentVisitor::VisitExpr(const Expr *Node) {\n  bool IsInvalid = false;\n  for (const Stmt *SubStmt : Node->children())\n    IsInvalid |= Visit(SubStmt);\n  return IsInvalid;\n}\n\n/// VisitDeclRefExpr - Visit a reference to a declaration, to\n/// determine whether this declaration can be used in the default\n/// argument expression.\nbool CheckDefaultArgumentVisitor::VisitDeclRefExpr(const DeclRefExpr *DRE) {\n  const NamedDecl *Decl = DRE->getDecl();\n  if (const auto *Param = dyn_cast<ParmVarDecl>(Decl)) {\n    // C++ [dcl.fct.default]p9:\n    //   [...] parameters of a function shall not be used in default\n    //   argument expressions, even if they are not evaluated. [...]\n    //\n    // C++17 [dcl.fct.default]p9 (by CWG 2082):\n    //   [...] A parameter shall not appear as a potentially-evaluated\n    //   expression in a default argument. [...]\n    //\n    if (DRE->isNonOdrUse() != NOUR_Unevaluated)\n      return S.Diag(DRE->getBeginLoc(),\n                    diag::err_param_default_argument_references_param)\n             << Param->getDeclName() << DefaultArg->getSourceRange();\n  } else if (const auto *VDecl = dyn_cast<VarDecl>(Decl)) {\n    // C++ [dcl.fct.default]p7:\n    //   Local variables shall not be used in default argument\n    //   expressions.\n    //\n    // C++17 [dcl.fct.default]p7 (by CWG 2082):\n    //   A local variable shall not appear as a potentially-evaluated\n    //   expression in a default argument.\n    //\n    // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):\n    //   Note: A local variable cannot be odr-used (6.3) in a default argument.\n    //\n    if (VDecl->isLocalVarDecl() && !DRE->isNonOdrUse())\n      return S.Diag(DRE->getBeginLoc(),\n                    diag::err_param_default_argument_references_local)\n             << VDecl->getDeclName() << DefaultArg->getSourceRange();\n  }\n\n  return false;\n}\n\n/// VisitCXXThisExpr - Visit a C++ \"this\" expression.\nbool CheckDefaultArgumentVisitor::VisitCXXThisExpr(const CXXThisExpr *ThisE) {\n  // C++ [dcl.fct.default]p8:\n  //   The keyword this shall not be used in a default argument of a\n  //   member function.\n  return S.Diag(ThisE->getBeginLoc(),\n                diag::err_param_default_argument_references_this)\n         << ThisE->getSourceRange();\n}\n\nbool CheckDefaultArgumentVisitor::VisitPseudoObjectExpr(\n    const PseudoObjectExpr *POE) {\n  bool Invalid = false;\n  for (const Expr *E : POE->semantics()) {\n    // Look through bindings.\n    if (const auto *OVE = dyn_cast<OpaqueValueExpr>(E)) {\n      E = OVE->getSourceExpr();\n      assert(E && \"pseudo-object binding without source expression?\");\n    }\n\n    Invalid |= Visit(E);\n  }\n  return Invalid;\n}\n\nbool CheckDefaultArgumentVisitor::VisitLambdaExpr(const LambdaExpr *Lambda) {\n  // C++11 [expr.lambda.prim]p13:\n  //   A lambda-expression appearing in a default argument shall not\n  //   implicitly or explicitly capture any entity.\n  if (Lambda->capture_begin() == Lambda->capture_end())\n    return false;\n\n  return S.Diag(Lambda->getBeginLoc(), diag::err_lambda_capture_default_arg);\n}\n} // namespace\n\nvoid\nSema::ImplicitExceptionSpecification::CalledDecl(SourceLocation CallLoc,\n                                                 const CXXMethodDecl *Method) {\n  // If we have an MSAny spec already, don't bother.\n  if (!Method || ComputedEST == EST_MSAny)\n    return;\n\n  const FunctionProtoType *Proto\n    = Method->getType()->getAs<FunctionProtoType>();\n  Proto = Self->ResolveExceptionSpec(CallLoc, Proto);\n  if (!Proto)\n    return;\n\n  ExceptionSpecificationType EST = Proto->getExceptionSpecType();\n\n  // If we have a throw-all spec at this point, ignore the function.\n  if (ComputedEST == EST_None)\n    return;\n\n  if (EST == EST_None && Method->hasAttr<NoThrowAttr>())\n    EST = EST_BasicNoexcept;\n\n  switch (EST) {\n  case EST_Unparsed:\n  case EST_Uninstantiated:\n  case EST_Unevaluated:\n    llvm_unreachable(\"should not see unresolved exception specs here\");\n\n  // If this function can throw any exceptions, make a note of that.\n  case EST_MSAny:\n  case EST_None:\n    // FIXME: Whichever we see last of MSAny and None determines our result.\n    // We should make a consistent, order-independent choice here.\n    ClearExceptions();\n    ComputedEST = EST;\n    return;\n  case EST_NoexceptFalse:\n    ClearExceptions();\n    ComputedEST = EST_None;\n    return;\n  // FIXME: If the call to this decl is using any of its default arguments, we\n  // need to search them for potentially-throwing calls.\n  // If this function has a basic noexcept, it doesn't affect the outcome.\n  case EST_BasicNoexcept:\n  case EST_NoexceptTrue:\n  case EST_NoThrow:\n    return;\n  // If we're still at noexcept(true) and there's a throw() callee,\n  // change to that specification.\n  case EST_DynamicNone:\n    if (ComputedEST == EST_BasicNoexcept)\n      ComputedEST = EST_DynamicNone;\n    return;\n  case EST_DependentNoexcept:\n    llvm_unreachable(\n        \"should not generate implicit declarations for dependent cases\");\n  case EST_Dynamic:\n    break;\n  }\n  assert(EST == EST_Dynamic && \"EST case not considered earlier.\");\n  assert(ComputedEST != EST_None &&\n         \"Shouldn't collect exceptions when throw-all is guaranteed.\");\n  ComputedEST = EST_Dynamic;\n  // Record the exceptions in this function's exception specification.\n  for (const auto &E : Proto->exceptions())\n    if (ExceptionsSeen.insert(Self->Context.getCanonicalType(E)).second)\n      Exceptions.push_back(E);\n}\n\nvoid Sema::ImplicitExceptionSpecification::CalledStmt(Stmt *S) {\n  if (!S || ComputedEST == EST_MSAny)\n    return;\n\n  // FIXME:\n  //\n  // C++0x [except.spec]p14:\n  //   [An] implicit exception-specification specifies the type-id T if and\n  // only if T is allowed by the exception-specification of a function directly\n  // invoked by f's implicit definition; f shall allow all exceptions if any\n  // function it directly invokes allows all exceptions, and f shall allow no\n  // exceptions if every function it directly invokes allows no exceptions.\n  //\n  // Note in particular that if an implicit exception-specification is generated\n  // for a function containing a throw-expression, that specification can still\n  // be noexcept(true).\n  //\n  // Note also that 'directly invoked' is not defined in the standard, and there\n  // is no indication that we should only consider potentially-evaluated calls.\n  //\n  // Ultimately we should implement the intent of the standard: the exception\n  // specification should be the set of exceptions which can be thrown by the\n  // implicit definition. For now, we assume that any non-nothrow expression can\n  // throw any exception.\n\n  if (Self->canThrow(S))\n    ComputedEST = EST_None;\n}\n\nExprResult Sema::ConvertParamDefaultArgument(const ParmVarDecl *Param,\n                                             Expr *Arg,\n                                             SourceLocation EqualLoc) {\n  if (RequireCompleteType(Param->getLocation(), Param->getType(),\n                          diag::err_typecheck_decl_incomplete_type))\n    return true;\n\n  // C++ [dcl.fct.default]p5\n  //   A default argument expression is implicitly converted (clause\n  //   4) to the parameter type. The default argument expression has\n  //   the same semantic constraints as the initializer expression in\n  //   a declaration of a variable of the parameter type, using the\n  //   copy-initialization semantics (8.5).\n  InitializedEntity Entity = InitializedEntity::InitializeParameter(Context,\n                                                                    Param);\n  InitializationKind Kind = InitializationKind::CreateCopy(Param->getLocation(),\n                                                           EqualLoc);\n  InitializationSequence InitSeq(*this, Entity, Kind, Arg);\n  ExprResult Result = InitSeq.Perform(*this, Entity, Kind, Arg);\n  if (Result.isInvalid())\n    return true;\n  Arg = Result.getAs<Expr>();\n\n  CheckCompletedExpr(Arg, EqualLoc);\n  Arg = MaybeCreateExprWithCleanups(Arg);\n\n  return Arg;\n}\n\nvoid Sema::SetParamDefaultArgument(ParmVarDecl *Param, Expr *Arg,\n                                   SourceLocation EqualLoc) {\n  // Add the default argument to the parameter\n  Param->setDefaultArg(Arg);\n\n  // We have already instantiated this parameter; provide each of the\n  // instantiations with the uninstantiated default argument.\n  UnparsedDefaultArgInstantiationsMap::iterator InstPos\n    = UnparsedDefaultArgInstantiations.find(Param);\n  if (InstPos != UnparsedDefaultArgInstantiations.end()) {\n    for (unsigned I = 0, N = InstPos->second.size(); I != N; ++I)\n      InstPos->second[I]->setUninstantiatedDefaultArg(Arg);\n\n    // We're done tracking this parameter's instantiations.\n    UnparsedDefaultArgInstantiations.erase(InstPos);\n  }\n}\n\n/// ActOnParamDefaultArgument - Check whether the default argument\n/// provided for a function parameter is well-formed. If so, attach it\n/// to the parameter declaration.\nvoid\nSema::ActOnParamDefaultArgument(Decl *param, SourceLocation EqualLoc,\n                                Expr *DefaultArg) {\n  if (!param || !DefaultArg)\n    return;\n\n  ParmVarDecl *Param = cast<ParmVarDecl>(param);\n  UnparsedDefaultArgLocs.erase(Param);\n\n  auto Fail = [&] {\n    Param->setInvalidDecl();\n    Param->setDefaultArg(new (Context) OpaqueValueExpr(\n        EqualLoc, Param->getType().getNonReferenceType(), VK_RValue));\n  };\n\n  // Default arguments are only permitted in C++\n  if (!getLangOpts().CPlusPlus) {\n    Diag(EqualLoc, diag::err_param_default_argument)\n      << DefaultArg->getSourceRange();\n    return Fail();\n  }\n\n  // Check for unexpanded parameter packs.\n  if (DiagnoseUnexpandedParameterPack(DefaultArg, UPPC_DefaultArgument)) {\n    return Fail();\n  }\n\n  // C++11 [dcl.fct.default]p3\n  //   A default argument expression [...] shall not be specified for a\n  //   parameter pack.\n  if (Param->isParameterPack()) {\n    Diag(EqualLoc, diag::err_param_default_argument_on_parameter_pack)\n        << DefaultArg->getSourceRange();\n    // Recover by discarding the default argument.\n    Param->setDefaultArg(nullptr);\n    return;\n  }\n\n  ExprResult Result = ConvertParamDefaultArgument(Param, DefaultArg, EqualLoc);\n  if (Result.isInvalid())\n    return Fail();\n\n  DefaultArg = Result.getAs<Expr>();\n\n  // Check that the default argument is well-formed\n  CheckDefaultArgumentVisitor DefaultArgChecker(*this, DefaultArg);\n  if (DefaultArgChecker.Visit(DefaultArg))\n    return Fail();\n\n  SetParamDefaultArgument(Param, DefaultArg, EqualLoc);\n}\n\n/// ActOnParamUnparsedDefaultArgument - We've seen a default\n/// argument for a function parameter, but we can't parse it yet\n/// because we're inside a class definition. Note that this default\n/// argument will be parsed later.\nvoid Sema::ActOnParamUnparsedDefaultArgument(Decl *param,\n                                             SourceLocation EqualLoc,\n                                             SourceLocation ArgLoc) {\n  if (!param)\n    return;\n\n  ParmVarDecl *Param = cast<ParmVarDecl>(param);\n  Param->setUnparsedDefaultArg();\n  UnparsedDefaultArgLocs[Param] = ArgLoc;\n}\n\n/// ActOnParamDefaultArgumentError - Parsing or semantic analysis of\n/// the default argument for the parameter param failed.\nvoid Sema::ActOnParamDefaultArgumentError(Decl *param,\n                                          SourceLocation EqualLoc) {\n  if (!param)\n    return;\n\n  ParmVarDecl *Param = cast<ParmVarDecl>(param);\n  Param->setInvalidDecl();\n  UnparsedDefaultArgLocs.erase(Param);\n  Param->setDefaultArg(new(Context)\n                       OpaqueValueExpr(EqualLoc,\n                                       Param->getType().getNonReferenceType(),\n                                       VK_RValue));\n}\n\n/// CheckExtraCXXDefaultArguments - Check for any extra default\n/// arguments in the declarator, which is not a function declaration\n/// or definition and therefore is not permitted to have default\n/// arguments. This routine should be invoked for every declarator\n/// that is not a function declaration or definition.\nvoid Sema::CheckExtraCXXDefaultArguments(Declarator &D) {\n  // C++ [dcl.fct.default]p3\n  //   A default argument expression shall be specified only in the\n  //   parameter-declaration-clause of a function declaration or in a\n  //   template-parameter (14.1). It shall not be specified for a\n  //   parameter pack. If it is specified in a\n  //   parameter-declaration-clause, it shall not occur within a\n  //   declarator or abstract-declarator of a parameter-declaration.\n  bool MightBeFunction = D.isFunctionDeclarationContext();\n  for (unsigned i = 0, e = D.getNumTypeObjects(); i != e; ++i) {\n    DeclaratorChunk &chunk = D.getTypeObject(i);\n    if (chunk.Kind == DeclaratorChunk::Function) {\n      if (MightBeFunction) {\n        // This is a function declaration. It can have default arguments, but\n        // keep looking in case its return type is a function type with default\n        // arguments.\n        MightBeFunction = false;\n        continue;\n      }\n      for (unsigned argIdx = 0, e = chunk.Fun.NumParams; argIdx != e;\n           ++argIdx) {\n        ParmVarDecl *Param = cast<ParmVarDecl>(chunk.Fun.Params[argIdx].Param);\n        if (Param->hasUnparsedDefaultArg()) {\n          std::unique_ptr<CachedTokens> Toks =\n              std::move(chunk.Fun.Params[argIdx].DefaultArgTokens);\n          SourceRange SR;\n          if (Toks->size() > 1)\n            SR = SourceRange((*Toks)[1].getLocation(),\n                             Toks->back().getLocation());\n          else\n            SR = UnparsedDefaultArgLocs[Param];\n          Diag(Param->getLocation(), diag::err_param_default_argument_nonfunc)\n            << SR;\n        } else if (Param->getDefaultArg()) {\n          Diag(Param->getLocation(), diag::err_param_default_argument_nonfunc)\n            << Param->getDefaultArg()->getSourceRange();\n          Param->setDefaultArg(nullptr);\n        }\n      }\n    } else if (chunk.Kind != DeclaratorChunk::Paren) {\n      MightBeFunction = false;\n    }\n  }\n}\n\nstatic bool functionDeclHasDefaultArgument(const FunctionDecl *FD) {\n  return std::any_of(FD->param_begin(), FD->param_end(), [](ParmVarDecl *P) {\n    return P->hasDefaultArg() && !P->hasInheritedDefaultArg();\n  });\n}\n\n/// MergeCXXFunctionDecl - Merge two declarations of the same C++\n/// function, once we already know that they have the same\n/// type. Subroutine of MergeFunctionDecl. Returns true if there was an\n/// error, false otherwise.\nbool Sema::MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old,\n                                Scope *S) {\n  bool Invalid = false;\n\n  // The declaration context corresponding to the scope is the semantic\n  // parent, unless this is a local function declaration, in which case\n  // it is that surrounding function.\n  DeclContext *ScopeDC = New->isLocalExternDecl()\n                             ? New->getLexicalDeclContext()\n                             : New->getDeclContext();\n\n  // Find the previous declaration for the purpose of default arguments.\n  FunctionDecl *PrevForDefaultArgs = Old;\n  for (/**/; PrevForDefaultArgs;\n       // Don't bother looking back past the latest decl if this is a local\n       // extern declaration; nothing else could work.\n       PrevForDefaultArgs = New->isLocalExternDecl()\n                                ? nullptr\n                                : PrevForDefaultArgs->getPreviousDecl()) {\n    // Ignore hidden declarations.\n    if (!LookupResult::isVisible(*this, PrevForDefaultArgs))\n      continue;\n\n    if (S && !isDeclInScope(PrevForDefaultArgs, ScopeDC, S) &&\n        !New->isCXXClassMember()) {\n      // Ignore default arguments of old decl if they are not in\n      // the same scope and this is not an out-of-line definition of\n      // a member function.\n      continue;\n    }\n\n    if (PrevForDefaultArgs->isLocalExternDecl() != New->isLocalExternDecl()) {\n      // If only one of these is a local function declaration, then they are\n      // declared in different scopes, even though isDeclInScope may think\n      // they're in the same scope. (If both are local, the scope check is\n      // sufficient, and if neither is local, then they are in the same scope.)\n      continue;\n    }\n\n    // We found the right previous declaration.\n    break;\n  }\n\n  // C++ [dcl.fct.default]p4:\n  //   For non-template functions, default arguments can be added in\n  //   later declarations of a function in the same\n  //   scope. Declarations in different scopes have completely\n  //   distinct sets of default arguments. That is, declarations in\n  //   inner scopes do not acquire default arguments from\n  //   declarations in outer scopes, and vice versa. In a given\n  //   function declaration, all parameters subsequent to a\n  //   parameter with a default argument shall have default\n  //   arguments supplied in this or previous declarations. A\n  //   default argument shall not be redefined by a later\n  //   declaration (not even to the same value).\n  //\n  // C++ [dcl.fct.default]p6:\n  //   Except for member functions of class templates, the default arguments\n  //   in a member function definition that appears outside of the class\n  //   definition are added to the set of default arguments provided by the\n  //   member function declaration in the class definition.\n  for (unsigned p = 0, NumParams = PrevForDefaultArgs\n                                       ? PrevForDefaultArgs->getNumParams()\n                                       : 0;\n       p < NumParams; ++p) {\n    ParmVarDecl *OldParam = PrevForDefaultArgs->getParamDecl(p);\n    ParmVarDecl *NewParam = New->getParamDecl(p);\n\n    bool OldParamHasDfl = OldParam ? OldParam->hasDefaultArg() : false;\n    bool NewParamHasDfl = NewParam->hasDefaultArg();\n\n    if (OldParamHasDfl && NewParamHasDfl) {\n      unsigned DiagDefaultParamID =\n        diag::err_param_default_argument_redefinition;\n\n      // MSVC accepts that default parameters be redefined for member functions\n      // of template class. The new default parameter's value is ignored.\n      Invalid = true;\n      if (getLangOpts().MicrosoftExt) {\n        CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(New);\n        if (MD && MD->getParent()->getDescribedClassTemplate()) {\n          // Merge the old default argument into the new parameter.\n          NewParam->setHasInheritedDefaultArg();\n          if (OldParam->hasUninstantiatedDefaultArg())\n            NewParam->setUninstantiatedDefaultArg(\n                                      OldParam->getUninstantiatedDefaultArg());\n          else\n            NewParam->setDefaultArg(OldParam->getInit());\n          DiagDefaultParamID = diag::ext_param_default_argument_redefinition;\n          Invalid = false;\n        }\n      }\n\n      // FIXME: If we knew where the '=' was, we could easily provide a fix-it\n      // hint here. Alternatively, we could walk the type-source information\n      // for NewParam to find the last source location in the type... but it\n      // isn't worth the effort right now. This is the kind of test case that\n      // is hard to get right:\n      //   int f(int);\n      //   void g(int (*fp)(int) = f);\n      //   void g(int (*fp)(int) = &f);\n      Diag(NewParam->getLocation(), DiagDefaultParamID)\n        << NewParam->getDefaultArgRange();\n\n      // Look for the function declaration where the default argument was\n      // actually written, which may be a declaration prior to Old.\n      for (auto Older = PrevForDefaultArgs;\n           OldParam->hasInheritedDefaultArg(); /**/) {\n        Older = Older->getPreviousDecl();\n        OldParam = Older->getParamDecl(p);\n      }\n\n      Diag(OldParam->getLocation(), diag::note_previous_definition)\n        << OldParam->getDefaultArgRange();\n    } else if (OldParamHasDfl) {\n      // Merge the old default argument into the new parameter unless the new\n      // function is a friend declaration in a template class. In the latter\n      // case the default arguments will be inherited when the friend\n      // declaration will be instantiated.\n      if (New->getFriendObjectKind() == Decl::FOK_None ||\n          !New->getLexicalDeclContext()->isDependentContext()) {\n        // It's important to use getInit() here;  getDefaultArg()\n        // strips off any top-level ExprWithCleanups.\n        NewParam->setHasInheritedDefaultArg();\n        if (OldParam->hasUnparsedDefaultArg())\n          NewParam->setUnparsedDefaultArg();\n        else if (OldParam->hasUninstantiatedDefaultArg())\n          NewParam->setUninstantiatedDefaultArg(\n                                       OldParam->getUninstantiatedDefaultArg());\n        else\n          NewParam->setDefaultArg(OldParam->getInit());\n      }\n    } else if (NewParamHasDfl) {\n      if (New->getDescribedFunctionTemplate()) {\n        // Paragraph 4, quoted above, only applies to non-template functions.\n        Diag(NewParam->getLocation(),\n             diag::err_param_default_argument_template_redecl)\n          << NewParam->getDefaultArgRange();\n        Diag(PrevForDefaultArgs->getLocation(),\n             diag::note_template_prev_declaration)\n            << false;\n      } else if (New->getTemplateSpecializationKind()\n                   != TSK_ImplicitInstantiation &&\n                 New->getTemplateSpecializationKind() != TSK_Undeclared) {\n        // C++ [temp.expr.spec]p21:\n        //   Default function arguments shall not be specified in a declaration\n        //   or a definition for one of the following explicit specializations:\n        //     - the explicit specialization of a function template;\n        //     - the explicit specialization of a member function template;\n        //     - the explicit specialization of a member function of a class\n        //       template where the class template specialization to which the\n        //       member function specialization belongs is implicitly\n        //       instantiated.\n        Diag(NewParam->getLocation(), diag::err_template_spec_default_arg)\n          << (New->getTemplateSpecializationKind() ==TSK_ExplicitSpecialization)\n          << New->getDeclName()\n          << NewParam->getDefaultArgRange();\n      } else if (New->getDeclContext()->isDependentContext()) {\n        // C++ [dcl.fct.default]p6 (DR217):\n        //   Default arguments for a member function of a class template shall\n        //   be specified on the initial declaration of the member function\n        //   within the class template.\n        //\n        // Reading the tea leaves a bit in DR217 and its reference to DR205\n        // leads me to the conclusion that one cannot add default function\n        // arguments for an out-of-line definition of a member function of a\n        // dependent type.\n        int WhichKind = 2;\n        if (CXXRecordDecl *Record\n              = dyn_cast<CXXRecordDecl>(New->getDeclContext())) {\n          if (Record->getDescribedClassTemplate())\n            WhichKind = 0;\n          else if (isa<ClassTemplatePartialSpecializationDecl>(Record))\n            WhichKind = 1;\n          else\n            WhichKind = 2;\n        }\n\n        Diag(NewParam->getLocation(),\n             diag::err_param_default_argument_member_template_redecl)\n          << WhichKind\n          << NewParam->getDefaultArgRange();\n      }\n    }\n  }\n\n  // DR1344: If a default argument is added outside a class definition and that\n  // default argument makes the function a special member function, the program\n  // is ill-formed. This can only happen for constructors.\n  if (isa<CXXConstructorDecl>(New) &&\n      New->getMinRequiredArguments() < Old->getMinRequiredArguments()) {\n    CXXSpecialMember NewSM = getSpecialMember(cast<CXXMethodDecl>(New)),\n                     OldSM = getSpecialMember(cast<CXXMethodDecl>(Old));\n    if (NewSM != OldSM) {\n      ParmVarDecl *NewParam = New->getParamDecl(New->getMinRequiredArguments());\n      assert(NewParam->hasDefaultArg());\n      Diag(NewParam->getLocation(), diag::err_default_arg_makes_ctor_special)\n        << NewParam->getDefaultArgRange() << NewSM;\n      Diag(Old->getLocation(), diag::note_previous_declaration);\n    }\n  }\n\n  const FunctionDecl *Def;\n  // C++11 [dcl.constexpr]p1: If any declaration of a function or function\n  // template has a constexpr specifier then all its declarations shall\n  // contain the constexpr specifier.\n  if (New->getConstexprKind() != Old->getConstexprKind()) {\n    Diag(New->getLocation(), diag::err_constexpr_redecl_mismatch)\n        << New << static_cast<int>(New->getConstexprKind())\n        << static_cast<int>(Old->getConstexprKind());\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n    Invalid = true;\n  } else if (!Old->getMostRecentDecl()->isInlined() && New->isInlined() &&\n             Old->isDefined(Def) &&\n             // If a friend function is inlined but does not have 'inline'\n             // specifier, it is a definition. Do not report attribute conflict\n             // in this case, redefinition will be diagnosed later.\n             (New->isInlineSpecified() ||\n              New->getFriendObjectKind() == Decl::FOK_None)) {\n    // C++11 [dcl.fcn.spec]p4:\n    //   If the definition of a function appears in a translation unit before its\n    //   first declaration as inline, the program is ill-formed.\n    Diag(New->getLocation(), diag::err_inline_decl_follows_def) << New;\n    Diag(Def->getLocation(), diag::note_previous_definition);\n    Invalid = true;\n  }\n\n  // C++17 [temp.deduct.guide]p3:\n  //   Two deduction guide declarations in the same translation unit\n  //   for the same class template shall not have equivalent\n  //   parameter-declaration-clauses.\n  if (isa<CXXDeductionGuideDecl>(New) &&\n      !New->isFunctionTemplateSpecialization() && isVisible(Old)) {\n    Diag(New->getLocation(), diag::err_deduction_guide_redeclared);\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n  }\n\n  // C++11 [dcl.fct.default]p4: If a friend declaration specifies a default\n  // argument expression, that declaration shall be a definition and shall be\n  // the only declaration of the function or function template in the\n  // translation unit.\n  if (Old->getFriendObjectKind() == Decl::FOK_Undeclared &&\n      functionDeclHasDefaultArgument(Old)) {\n    Diag(New->getLocation(), diag::err_friend_decl_with_def_arg_redeclared);\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n    Invalid = true;\n  }\n\n  // C++11 [temp.friend]p4 (DR329):\n  //   When a function is defined in a friend function declaration in a class\n  //   template, the function is instantiated when the function is odr-used.\n  //   The same restrictions on multiple declarations and definitions that\n  //   apply to non-template function declarations and definitions also apply\n  //   to these implicit definitions.\n  const FunctionDecl *OldDefinition = nullptr;\n  if (New->isThisDeclarationInstantiatedFromAFriendDefinition() &&\n      Old->isDefined(OldDefinition, true))\n    CheckForFunctionRedefinition(New, OldDefinition);\n\n  return Invalid;\n}\n\nNamedDecl *\nSema::ActOnDecompositionDeclarator(Scope *S, Declarator &D,\n                                   MultiTemplateParamsArg TemplateParamLists) {\n  assert(D.isDecompositionDeclarator());\n  const DecompositionDeclarator &Decomp = D.getDecompositionDeclarator();\n\n  // The syntax only allows a decomposition declarator as a simple-declaration,\n  // a for-range-declaration, or a condition in Clang, but we parse it in more\n  // cases than that.\n  if (!D.mayHaveDecompositionDeclarator()) {\n    Diag(Decomp.getLSquareLoc(), diag::err_decomp_decl_context)\n      << Decomp.getSourceRange();\n    return nullptr;\n  }\n\n  if (!TemplateParamLists.empty()) {\n    // FIXME: There's no rule against this, but there are also no rules that\n    // would actually make it usable, so we reject it for now.\n    Diag(TemplateParamLists.front()->getTemplateLoc(),\n         diag::err_decomp_decl_template);\n    return nullptr;\n  }\n\n  Diag(Decomp.getLSquareLoc(),\n       !getLangOpts().CPlusPlus17\n           ? diag::ext_decomp_decl\n           : D.getContext() == DeclaratorContext::Condition\n                 ? diag::ext_decomp_decl_cond\n                 : diag::warn_cxx14_compat_decomp_decl)\n      << Decomp.getSourceRange();\n\n  // The semantic context is always just the current context.\n  DeclContext *const DC = CurContext;\n\n  // C++17 [dcl.dcl]/8:\n  //   The decl-specifier-seq shall contain only the type-specifier auto\n  //   and cv-qualifiers.\n  // C++2a [dcl.dcl]/8:\n  //   If decl-specifier-seq contains any decl-specifier other than static,\n  //   thread_local, auto, or cv-qualifiers, the program is ill-formed.\n  auto &DS = D.getDeclSpec();\n  {\n    SmallVector<StringRef, 8> BadSpecifiers;\n    SmallVector<SourceLocation, 8> BadSpecifierLocs;\n    SmallVector<StringRef, 8> CPlusPlus20Specifiers;\n    SmallVector<SourceLocation, 8> CPlusPlus20SpecifierLocs;\n    if (auto SCS = DS.getStorageClassSpec()) {\n      if (SCS == DeclSpec::SCS_static) {\n        CPlusPlus20Specifiers.push_back(DeclSpec::getSpecifierName(SCS));\n        CPlusPlus20SpecifierLocs.push_back(DS.getStorageClassSpecLoc());\n      } else {\n        BadSpecifiers.push_back(DeclSpec::getSpecifierName(SCS));\n        BadSpecifierLocs.push_back(DS.getStorageClassSpecLoc());\n      }\n    }\n    if (auto TSCS = DS.getThreadStorageClassSpec()) {\n      CPlusPlus20Specifiers.push_back(DeclSpec::getSpecifierName(TSCS));\n      CPlusPlus20SpecifierLocs.push_back(DS.getThreadStorageClassSpecLoc());\n    }\n    if (DS.hasConstexprSpecifier()) {\n      BadSpecifiers.push_back(\n          DeclSpec::getSpecifierName(DS.getConstexprSpecifier()));\n      BadSpecifierLocs.push_back(DS.getConstexprSpecLoc());\n    }\n    if (DS.isInlineSpecified()) {\n      BadSpecifiers.push_back(\"inline\");\n      BadSpecifierLocs.push_back(DS.getInlineSpecLoc());\n    }\n    if (!BadSpecifiers.empty()) {\n      auto &&Err = Diag(BadSpecifierLocs.front(), diag::err_decomp_decl_spec);\n      Err << (int)BadSpecifiers.size()\n          << llvm::join(BadSpecifiers.begin(), BadSpecifiers.end(), \" \");\n      // Don't add FixItHints to remove the specifiers; we do still respect\n      // them when building the underlying variable.\n      for (auto Loc : BadSpecifierLocs)\n        Err << SourceRange(Loc, Loc);\n    } else if (!CPlusPlus20Specifiers.empty()) {\n      auto &&Warn = Diag(CPlusPlus20SpecifierLocs.front(),\n                         getLangOpts().CPlusPlus20\n                             ? diag::warn_cxx17_compat_decomp_decl_spec\n                             : diag::ext_decomp_decl_spec);\n      Warn << (int)CPlusPlus20Specifiers.size()\n           << llvm::join(CPlusPlus20Specifiers.begin(),\n                         CPlusPlus20Specifiers.end(), \" \");\n      for (auto Loc : CPlusPlus20SpecifierLocs)\n        Warn << SourceRange(Loc, Loc);\n    }\n    // We can't recover from it being declared as a typedef.\n    if (DS.getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return nullptr;\n  }\n\n  // C++2a [dcl.struct.bind]p1:\n  //   A cv that includes volatile is deprecated\n  if ((DS.getTypeQualifiers() & DeclSpec::TQ_volatile) &&\n      getLangOpts().CPlusPlus20)\n    Diag(DS.getVolatileSpecLoc(),\n         diag::warn_deprecated_volatile_structured_binding);\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType R = TInfo->getType();\n\n  if (DiagnoseUnexpandedParameterPack(D.getIdentifierLoc(), TInfo,\n                                      UPPC_DeclarationType))\n    D.setInvalidType();\n\n  // The syntax only allows a single ref-qualifier prior to the decomposition\n  // declarator. No other declarator chunks are permitted. Also check the type\n  // specifier here.\n  if (DS.getTypeSpecType() != DeclSpec::TST_auto ||\n      D.hasGroupingParens() || D.getNumTypeObjects() > 1 ||\n      (D.getNumTypeObjects() == 1 &&\n       D.getTypeObject(0).Kind != DeclaratorChunk::Reference)) {\n    Diag(Decomp.getLSquareLoc(),\n         (D.hasGroupingParens() ||\n          (D.getNumTypeObjects() &&\n           D.getTypeObject(0).Kind == DeclaratorChunk::Paren))\n             ? diag::err_decomp_decl_parens\n             : diag::err_decomp_decl_type)\n        << R;\n\n    // In most cases, there's no actual problem with an explicitly-specified\n    // type, but a function type won't work here, and ActOnVariableDeclarator\n    // shouldn't be called for such a type.\n    if (R->isFunctionType())\n      D.setInvalidType();\n  }\n\n  // Build the BindingDecls.\n  SmallVector<BindingDecl*, 8> Bindings;\n\n  // Build the BindingDecls.\n  for (auto &B : D.getDecompositionDeclarator().bindings()) {\n    // Check for name conflicts.\n    DeclarationNameInfo NameInfo(B.Name, B.NameLoc);\n    LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                          ForVisibleRedeclaration);\n    LookupName(Previous, S,\n               /*CreateBuiltins*/DC->getRedeclContext()->isTranslationUnit());\n\n    // It's not permitted to shadow a template parameter name.\n    if (Previous.isSingleResult() &&\n        Previous.getFoundDecl()->isTemplateParameter()) {\n      DiagnoseTemplateParameterShadow(D.getIdentifierLoc(),\n                                      Previous.getFoundDecl());\n      Previous.clear();\n    }\n\n    auto *BD = BindingDecl::Create(Context, DC, B.NameLoc, B.Name);\n\n    // Find the shadowed declaration before filtering for scope.\n    NamedDecl *ShadowedDecl = D.getCXXScopeSpec().isEmpty()\n                                  ? getShadowedDeclaration(BD, Previous)\n                                  : nullptr;\n\n    bool ConsiderLinkage = DC->isFunctionOrMethod() &&\n                           DS.getStorageClassSpec() == DeclSpec::SCS_extern;\n    FilterLookupForScope(Previous, DC, S, ConsiderLinkage,\n                         /*AllowInlineNamespace*/false);\n\n    if (!Previous.empty()) {\n      auto *Old = Previous.getRepresentativeDecl();\n      Diag(B.NameLoc, diag::err_redefinition) << B.Name;\n      Diag(Old->getLocation(), diag::note_previous_definition);\n    } else if (ShadowedDecl && !D.isRedeclaration()) {\n      CheckShadow(BD, ShadowedDecl, Previous);\n    }\n    PushOnScopeChains(BD, S, true);\n    Bindings.push_back(BD);\n    ParsingInitForAutoVars.insert(BD);\n  }\n\n  // There are no prior lookup results for the variable itself, because it\n  // is unnamed.\n  DeclarationNameInfo NameInfo((IdentifierInfo *)nullptr,\n                               Decomp.getLSquareLoc());\n  LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                        ForVisibleRedeclaration);\n\n  // Build the variable that holds the non-decomposed object.\n  bool AddToScope = true;\n  NamedDecl *New =\n      ActOnVariableDeclarator(S, D, DC, TInfo, Previous,\n                              MultiTemplateParamsArg(), AddToScope, Bindings);\n  if (AddToScope) {\n    S->AddDecl(New);\n    CurContext->addHiddenDecl(New);\n  }\n\n  if (isInOpenMPDeclareTargetContext())\n    checkDeclIsAllowedInOpenMPTarget(nullptr, New);\n\n  return New;\n}\n\nstatic bool checkSimpleDecomposition(\n    Sema &S, ArrayRef<BindingDecl *> Bindings, ValueDecl *Src,\n    QualType DecompType, const llvm::APSInt &NumElems, QualType ElemType,\n    llvm::function_ref<ExprResult(SourceLocation, Expr *, unsigned)> GetInit) {\n  if ((int64_t)Bindings.size() != NumElems) {\n    S.Diag(Src->getLocation(), diag::err_decomp_decl_wrong_number_bindings)\n        << DecompType << (unsigned)Bindings.size()\n        << (unsigned)NumElems.getLimitedValue(UINT_MAX) << NumElems.toString(10)\n        << (NumElems < Bindings.size());\n    return true;\n  }\n\n  unsigned I = 0;\n  for (auto *B : Bindings) {\n    SourceLocation Loc = B->getLocation();\n    ExprResult E = S.BuildDeclRefExpr(Src, DecompType, VK_LValue, Loc);\n    if (E.isInvalid())\n      return true;\n    E = GetInit(Loc, E.get(), I++);\n    if (E.isInvalid())\n      return true;\n    B->setBinding(ElemType, E.get());\n  }\n\n  return false;\n}\n\nstatic bool checkArrayLikeDecomposition(Sema &S,\n                                        ArrayRef<BindingDecl *> Bindings,\n                                        ValueDecl *Src, QualType DecompType,\n                                        const llvm::APSInt &NumElems,\n                                        QualType ElemType) {\n  return checkSimpleDecomposition(\n      S, Bindings, Src, DecompType, NumElems, ElemType,\n      [&](SourceLocation Loc, Expr *Base, unsigned I) -> ExprResult {\n        ExprResult E = S.ActOnIntegerConstant(Loc, I);\n        if (E.isInvalid())\n          return ExprError();\n        return S.CreateBuiltinArraySubscriptExpr(Base, Loc, E.get(), Loc);\n      });\n}\n\nstatic bool checkArrayDecomposition(Sema &S, ArrayRef<BindingDecl*> Bindings,\n                                    ValueDecl *Src, QualType DecompType,\n                                    const ConstantArrayType *CAT) {\n  return checkArrayLikeDecomposition(S, Bindings, Src, DecompType,\n                                     llvm::APSInt(CAT->getSize()),\n                                     CAT->getElementType());\n}\n\nstatic bool checkVectorDecomposition(Sema &S, ArrayRef<BindingDecl*> Bindings,\n                                     ValueDecl *Src, QualType DecompType,\n                                     const VectorType *VT) {\n  return checkArrayLikeDecomposition(\n      S, Bindings, Src, DecompType, llvm::APSInt::get(VT->getNumElements()),\n      S.Context.getQualifiedType(VT->getElementType(),\n                                 DecompType.getQualifiers()));\n}\n\nstatic bool checkComplexDecomposition(Sema &S,\n                                      ArrayRef<BindingDecl *> Bindings,\n                                      ValueDecl *Src, QualType DecompType,\n                                      const ComplexType *CT) {\n  return checkSimpleDecomposition(\n      S, Bindings, Src, DecompType, llvm::APSInt::get(2),\n      S.Context.getQualifiedType(CT->getElementType(),\n                                 DecompType.getQualifiers()),\n      [&](SourceLocation Loc, Expr *Base, unsigned I) -> ExprResult {\n        return S.CreateBuiltinUnaryOp(Loc, I ? UO_Imag : UO_Real, Base);\n      });\n}\n\nstatic std::string printTemplateArgs(const PrintingPolicy &PrintingPolicy,\n                                     TemplateArgumentListInfo &Args) {\n  SmallString<128> SS;\n  llvm::raw_svector_ostream OS(SS);\n  bool First = true;\n  for (auto &Arg : Args.arguments()) {\n    if (!First)\n      OS << \", \";\n    Arg.getArgument().print(PrintingPolicy, OS);\n    First = false;\n  }\n  return std::string(OS.str());\n}\n\nstatic bool lookupStdTypeTraitMember(Sema &S, LookupResult &TraitMemberLookup,\n                                     SourceLocation Loc, StringRef Trait,\n                                     TemplateArgumentListInfo &Args,\n                                     unsigned DiagID) {\n  auto DiagnoseMissing = [&] {\n    if (DiagID)\n      S.Diag(Loc, DiagID) << printTemplateArgs(S.Context.getPrintingPolicy(),\n                                               Args);\n    return true;\n  };\n\n  // FIXME: Factor out duplication with lookupPromiseType in SemaCoroutine.\n  NamespaceDecl *Std = S.getStdNamespace();\n  if (!Std)\n    return DiagnoseMissing();\n\n  // Look up the trait itself, within namespace std. We can diagnose various\n  // problems with this lookup even if we've been asked to not diagnose a\n  // missing specialization, because this can only fail if the user has been\n  // declaring their own names in namespace std or we don't support the\n  // standard library implementation in use.\n  LookupResult Result(S, &S.PP.getIdentifierTable().get(Trait),\n                      Loc, Sema::LookupOrdinaryName);\n  if (!S.LookupQualifiedName(Result, Std))\n    return DiagnoseMissing();\n  if (Result.isAmbiguous())\n    return true;\n\n  ClassTemplateDecl *TraitTD = Result.getAsSingle<ClassTemplateDecl>();\n  if (!TraitTD) {\n    Result.suppressDiagnostics();\n    NamedDecl *Found = *Result.begin();\n    S.Diag(Loc, diag::err_std_type_trait_not_class_template) << Trait;\n    S.Diag(Found->getLocation(), diag::note_declared_at);\n    return true;\n  }\n\n  // Build the template-id.\n  QualType TraitTy = S.CheckTemplateIdType(TemplateName(TraitTD), Loc, Args);\n  if (TraitTy.isNull())\n    return true;\n  if (!S.isCompleteType(Loc, TraitTy)) {\n    if (DiagID)\n      S.RequireCompleteType(\n          Loc, TraitTy, DiagID,\n          printTemplateArgs(S.Context.getPrintingPolicy(), Args));\n    return true;\n  }\n\n  CXXRecordDecl *RD = TraitTy->getAsCXXRecordDecl();\n  assert(RD && \"specialization of class template is not a class?\");\n\n  // Look up the member of the trait type.\n  S.LookupQualifiedName(TraitMemberLookup, RD);\n  return TraitMemberLookup.isAmbiguous();\n}\n\nstatic TemplateArgumentLoc\ngetTrivialIntegralTemplateArgument(Sema &S, SourceLocation Loc, QualType T,\n                                   uint64_t I) {\n  TemplateArgument Arg(S.Context, S.Context.MakeIntValue(I, T), T);\n  return S.getTrivialTemplateArgumentLoc(Arg, T, Loc);\n}\n\nstatic TemplateArgumentLoc\ngetTrivialTypeTemplateArgument(Sema &S, SourceLocation Loc, QualType T) {\n  return S.getTrivialTemplateArgumentLoc(TemplateArgument(T), QualType(), Loc);\n}\n\nnamespace { enum class IsTupleLike { TupleLike, NotTupleLike, Error }; }\n\nstatic IsTupleLike isTupleLike(Sema &S, SourceLocation Loc, QualType T,\n                               llvm::APSInt &Size) {\n  EnterExpressionEvaluationContext ContextRAII(\n      S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  DeclarationName Value = S.PP.getIdentifierInfo(\"value\");\n  LookupResult R(S, Value, Loc, Sema::LookupOrdinaryName);\n\n  // Form template argument list for tuple_size<T>.\n  TemplateArgumentListInfo Args(Loc, Loc);\n  Args.addArgument(getTrivialTypeTemplateArgument(S, Loc, T));\n\n  // If there's no tuple_size specialization or the lookup of 'value' is empty,\n  // it's not tuple-like.\n  if (lookupStdTypeTraitMember(S, R, Loc, \"tuple_size\", Args, /*DiagID*/ 0) ||\n      R.empty())\n    return IsTupleLike::NotTupleLike;\n\n  // If we get this far, we've committed to the tuple interpretation, but\n  // we can still fail if there actually isn't a usable ::value.\n\n  struct ICEDiagnoser : Sema::VerifyICEDiagnoser {\n    LookupResult &R;\n    TemplateArgumentListInfo &Args;\n    ICEDiagnoser(LookupResult &R, TemplateArgumentListInfo &Args)\n        : R(R), Args(Args) {}\n    Sema::SemaDiagnosticBuilder diagnoseNotICE(Sema &S,\n                                               SourceLocation Loc) override {\n      return S.Diag(Loc, diag::err_decomp_decl_std_tuple_size_not_constant)\n          << printTemplateArgs(S.Context.getPrintingPolicy(), Args);\n    }\n  } Diagnoser(R, Args);\n\n  ExprResult E =\n      S.BuildDeclarationNameExpr(CXXScopeSpec(), R, /*NeedsADL*/false);\n  if (E.isInvalid())\n    return IsTupleLike::Error;\n\n  E = S.VerifyIntegerConstantExpression(E.get(), &Size, Diagnoser);\n  if (E.isInvalid())\n    return IsTupleLike::Error;\n\n  return IsTupleLike::TupleLike;\n}\n\n/// \\return std::tuple_element<I, T>::type.\nstatic QualType getTupleLikeElementType(Sema &S, SourceLocation Loc,\n                                        unsigned I, QualType T) {\n  // Form template argument list for tuple_element<I, T>.\n  TemplateArgumentListInfo Args(Loc, Loc);\n  Args.addArgument(\n      getTrivialIntegralTemplateArgument(S, Loc, S.Context.getSizeType(), I));\n  Args.addArgument(getTrivialTypeTemplateArgument(S, Loc, T));\n\n  DeclarationName TypeDN = S.PP.getIdentifierInfo(\"type\");\n  LookupResult R(S, TypeDN, Loc, Sema::LookupOrdinaryName);\n  if (lookupStdTypeTraitMember(\n          S, R, Loc, \"tuple_element\", Args,\n          diag::err_decomp_decl_std_tuple_element_not_specialized))\n    return QualType();\n\n  auto *TD = R.getAsSingle<TypeDecl>();\n  if (!TD) {\n    R.suppressDiagnostics();\n    S.Diag(Loc, diag::err_decomp_decl_std_tuple_element_not_specialized)\n      << printTemplateArgs(S.Context.getPrintingPolicy(), Args);\n    if (!R.empty())\n      S.Diag(R.getRepresentativeDecl()->getLocation(), diag::note_declared_at);\n    return QualType();\n  }\n\n  return S.Context.getTypeDeclType(TD);\n}\n\nnamespace {\nstruct InitializingBinding {\n  Sema &S;\n  InitializingBinding(Sema &S, BindingDecl *BD) : S(S) {\n    Sema::CodeSynthesisContext Ctx;\n    Ctx.Kind = Sema::CodeSynthesisContext::InitializingStructuredBinding;\n    Ctx.PointOfInstantiation = BD->getLocation();\n    Ctx.Entity = BD;\n    S.pushCodeSynthesisContext(Ctx);\n  }\n  ~InitializingBinding() {\n    S.popCodeSynthesisContext();\n  }\n};\n}\n\nstatic bool checkTupleLikeDecomposition(Sema &S,\n                                        ArrayRef<BindingDecl *> Bindings,\n                                        VarDecl *Src, QualType DecompType,\n                                        const llvm::APSInt &TupleSize) {\n  if ((int64_t)Bindings.size() != TupleSize) {\n    S.Diag(Src->getLocation(), diag::err_decomp_decl_wrong_number_bindings)\n        << DecompType << (unsigned)Bindings.size()\n        << (unsigned)TupleSize.getLimitedValue(UINT_MAX)\n        << TupleSize.toString(10) << (TupleSize < Bindings.size());\n    return true;\n  }\n\n  if (Bindings.empty())\n    return false;\n\n  DeclarationName GetDN = S.PP.getIdentifierInfo(\"get\");\n\n  // [dcl.decomp]p3:\n  //   The unqualified-id get is looked up in the scope of E by class member\n  //   access lookup ...\n  LookupResult MemberGet(S, GetDN, Src->getLocation(), Sema::LookupMemberName);\n  bool UseMemberGet = false;\n  if (S.isCompleteType(Src->getLocation(), DecompType)) {\n    if (auto *RD = DecompType->getAsCXXRecordDecl())\n      S.LookupQualifiedName(MemberGet, RD);\n    if (MemberGet.isAmbiguous())\n      return true;\n    //   ... and if that finds at least one declaration that is a function\n    //   template whose first template parameter is a non-type parameter ...\n    for (NamedDecl *D : MemberGet) {\n      if (FunctionTemplateDecl *FTD =\n              dyn_cast<FunctionTemplateDecl>(D->getUnderlyingDecl())) {\n        TemplateParameterList *TPL = FTD->getTemplateParameters();\n        if (TPL->size() != 0 &&\n            isa<NonTypeTemplateParmDecl>(TPL->getParam(0))) {\n          //   ... the initializer is e.get<i>().\n          UseMemberGet = true;\n          break;\n        }\n      }\n    }\n  }\n\n  unsigned I = 0;\n  for (auto *B : Bindings) {\n    InitializingBinding InitContext(S, B);\n    SourceLocation Loc = B->getLocation();\n\n    ExprResult E = S.BuildDeclRefExpr(Src, DecompType, VK_LValue, Loc);\n    if (E.isInvalid())\n      return true;\n\n    //   e is an lvalue if the type of the entity is an lvalue reference and\n    //   an xvalue otherwise\n    if (!Src->getType()->isLValueReferenceType())\n      E = ImplicitCastExpr::Create(S.Context, E.get()->getType(), CK_NoOp,\n                                   E.get(), nullptr, VK_XValue,\n                                   FPOptionsOverride());\n\n    TemplateArgumentListInfo Args(Loc, Loc);\n    Args.addArgument(\n        getTrivialIntegralTemplateArgument(S, Loc, S.Context.getSizeType(), I));\n\n    if (UseMemberGet) {\n      //   if [lookup of member get] finds at least one declaration, the\n      //   initializer is e.get<i-1>().\n      E = S.BuildMemberReferenceExpr(E.get(), DecompType, Loc, false,\n                                     CXXScopeSpec(), SourceLocation(), nullptr,\n                                     MemberGet, &Args, nullptr);\n      if (E.isInvalid())\n        return true;\n\n      E = S.BuildCallExpr(nullptr, E.get(), Loc, None, Loc);\n    } else {\n      //   Otherwise, the initializer is get<i-1>(e), where get is looked up\n      //   in the associated namespaces.\n      Expr *Get = UnresolvedLookupExpr::Create(\n          S.Context, nullptr, NestedNameSpecifierLoc(), SourceLocation(),\n          DeclarationNameInfo(GetDN, Loc), /*RequiresADL*/true, &Args,\n          UnresolvedSetIterator(), UnresolvedSetIterator());\n\n      Expr *Arg = E.get();\n      E = S.BuildCallExpr(nullptr, Get, Loc, Arg, Loc);\n    }\n    if (E.isInvalid())\n      return true;\n    Expr *Init = E.get();\n\n    //   Given the type T designated by std::tuple_element<i - 1, E>::type,\n    QualType T = getTupleLikeElementType(S, Loc, I, DecompType);\n    if (T.isNull())\n      return true;\n\n    //   each vi is a variable of type \"reference to T\" initialized with the\n    //   initializer, where the reference is an lvalue reference if the\n    //   initializer is an lvalue and an rvalue reference otherwise\n    QualType RefType =\n        S.BuildReferenceType(T, E.get()->isLValue(), Loc, B->getDeclName());\n    if (RefType.isNull())\n      return true;\n    auto *RefVD = VarDecl::Create(\n        S.Context, Src->getDeclContext(), Loc, Loc,\n        B->getDeclName().getAsIdentifierInfo(), RefType,\n        S.Context.getTrivialTypeSourceInfo(T, Loc), Src->getStorageClass());\n    RefVD->setLexicalDeclContext(Src->getLexicalDeclContext());\n    RefVD->setTSCSpec(Src->getTSCSpec());\n    RefVD->setImplicit();\n    if (Src->isInlineSpecified())\n      RefVD->setInlineSpecified();\n    RefVD->getLexicalDeclContext()->addHiddenDecl(RefVD);\n\n    InitializedEntity Entity = InitializedEntity::InitializeBinding(RefVD);\n    InitializationKind Kind = InitializationKind::CreateCopy(Loc, Loc);\n    InitializationSequence Seq(S, Entity, Kind, Init);\n    E = Seq.Perform(S, Entity, Kind, Init);\n    if (E.isInvalid())\n      return true;\n    E = S.ActOnFinishFullExpr(E.get(), Loc, /*DiscardedValue*/ false);\n    if (E.isInvalid())\n      return true;\n    RefVD->setInit(E.get());\n    S.CheckCompleteVariableDeclaration(RefVD);\n\n    E = S.BuildDeclarationNameExpr(CXXScopeSpec(),\n                                   DeclarationNameInfo(B->getDeclName(), Loc),\n                                   RefVD);\n    if (E.isInvalid())\n      return true;\n\n    B->setBinding(T, E.get());\n    I++;\n  }\n\n  return false;\n}\n\n/// Find the base class to decompose in a built-in decomposition of a class type.\n/// This base class search is, unfortunately, not quite like any other that we\n/// perform anywhere else in C++.\nstatic DeclAccessPair findDecomposableBaseClass(Sema &S, SourceLocation Loc,\n                                                const CXXRecordDecl *RD,\n                                                CXXCastPath &BasePath) {\n  auto BaseHasFields = [](const CXXBaseSpecifier *Specifier,\n                          CXXBasePath &Path) {\n    return Specifier->getType()->getAsCXXRecordDecl()->hasDirectFields();\n  };\n\n  const CXXRecordDecl *ClassWithFields = nullptr;\n  AccessSpecifier AS = AS_public;\n  if (RD->hasDirectFields())\n    // [dcl.decomp]p4:\n    //   Otherwise, all of E's non-static data members shall be public direct\n    //   members of E ...\n    ClassWithFields = RD;\n  else {\n    //   ... or of ...\n    CXXBasePaths Paths;\n    Paths.setOrigin(const_cast<CXXRecordDecl*>(RD));\n    if (!RD->lookupInBases(BaseHasFields, Paths)) {\n      // If no classes have fields, just decompose RD itself. (This will work\n      // if and only if zero bindings were provided.)\n      return DeclAccessPair::make(const_cast<CXXRecordDecl*>(RD), AS_public);\n    }\n\n    CXXBasePath *BestPath = nullptr;\n    for (auto &P : Paths) {\n      if (!BestPath)\n        BestPath = &P;\n      else if (!S.Context.hasSameType(P.back().Base->getType(),\n                                      BestPath->back().Base->getType())) {\n        //   ... the same ...\n        S.Diag(Loc, diag::err_decomp_decl_multiple_bases_with_members)\n          << false << RD << BestPath->back().Base->getType()\n          << P.back().Base->getType();\n        return DeclAccessPair();\n      } else if (P.Access < BestPath->Access) {\n        BestPath = &P;\n      }\n    }\n\n    //   ... unambiguous ...\n    QualType BaseType = BestPath->back().Base->getType();\n    if (Paths.isAmbiguous(S.Context.getCanonicalType(BaseType))) {\n      S.Diag(Loc, diag::err_decomp_decl_ambiguous_base)\n        << RD << BaseType << S.getAmbiguousPathsDisplayString(Paths);\n      return DeclAccessPair();\n    }\n\n    //   ... [accessible, implied by other rules] base class of E.\n    S.CheckBaseClassAccess(Loc, BaseType, S.Context.getRecordType(RD),\n                           *BestPath, diag::err_decomp_decl_inaccessible_base);\n    AS = BestPath->Access;\n\n    ClassWithFields = BaseType->getAsCXXRecordDecl();\n    S.BuildBasePathArray(Paths, BasePath);\n  }\n\n  // The above search did not check whether the selected class itself has base\n  // classes with fields, so check that now.\n  CXXBasePaths Paths;\n  if (ClassWithFields->lookupInBases(BaseHasFields, Paths)) {\n    S.Diag(Loc, diag::err_decomp_decl_multiple_bases_with_members)\n      << (ClassWithFields == RD) << RD << ClassWithFields\n      << Paths.front().back().Base->getType();\n    return DeclAccessPair();\n  }\n\n  return DeclAccessPair::make(const_cast<CXXRecordDecl*>(ClassWithFields), AS);\n}\n\nstatic bool checkMemberDecomposition(Sema &S, ArrayRef<BindingDecl*> Bindings,\n                                     ValueDecl *Src, QualType DecompType,\n                                     const CXXRecordDecl *OrigRD) {\n  if (S.RequireCompleteType(Src->getLocation(), DecompType,\n                            diag::err_incomplete_type))\n    return true;\n\n  CXXCastPath BasePath;\n  DeclAccessPair BasePair =\n      findDecomposableBaseClass(S, Src->getLocation(), OrigRD, BasePath);\n  const CXXRecordDecl *RD = cast_or_null<CXXRecordDecl>(BasePair.getDecl());\n  if (!RD)\n    return true;\n  QualType BaseType = S.Context.getQualifiedType(S.Context.getRecordType(RD),\n                                                 DecompType.getQualifiers());\n\n  auto DiagnoseBadNumberOfBindings = [&]() -> bool {\n    unsigned NumFields =\n        std::count_if(RD->field_begin(), RD->field_end(),\n                      [](FieldDecl *FD) { return !FD->isUnnamedBitfield(); });\n    assert(Bindings.size() != NumFields);\n    S.Diag(Src->getLocation(), diag::err_decomp_decl_wrong_number_bindings)\n        << DecompType << (unsigned)Bindings.size() << NumFields << NumFields\n        << (NumFields < Bindings.size());\n    return true;\n  };\n\n  //   all of E's non-static data members shall be [...] well-formed\n  //   when named as e.name in the context of the structured binding,\n  //   E shall not have an anonymous union member, ...\n  unsigned I = 0;\n  for (auto *FD : RD->fields()) {\n    if (FD->isUnnamedBitfield())\n      continue;\n\n    // All the non-static data members are required to be nameable, so they\n    // must all have names.\n    if (!FD->getDeclName()) {\n      if (RD->isLambda()) {\n        S.Diag(Src->getLocation(), diag::err_decomp_decl_lambda);\n        S.Diag(RD->getLocation(), diag::note_lambda_decl);\n        return true;\n      }\n\n      if (FD->isAnonymousStructOrUnion()) {\n        S.Diag(Src->getLocation(), diag::err_decomp_decl_anon_union_member)\n          << DecompType << FD->getType()->isUnionType();\n        S.Diag(FD->getLocation(), diag::note_declared_at);\n        return true;\n      }\n\n      // FIXME: Are there any other ways we could have an anonymous member?\n    }\n\n    // We have a real field to bind.\n    if (I >= Bindings.size())\n      return DiagnoseBadNumberOfBindings();\n    auto *B = Bindings[I++];\n    SourceLocation Loc = B->getLocation();\n\n    // The field must be accessible in the context of the structured binding.\n    // We already checked that the base class is accessible.\n    // FIXME: Add 'const' to AccessedEntity's classes so we can remove the\n    // const_cast here.\n    S.CheckStructuredBindingMemberAccess(\n        Loc, const_cast<CXXRecordDecl *>(OrigRD),\n        DeclAccessPair::make(FD, CXXRecordDecl::MergeAccess(\n                                     BasePair.getAccess(), FD->getAccess())));\n\n    // Initialize the binding to Src.FD.\n    ExprResult E = S.BuildDeclRefExpr(Src, DecompType, VK_LValue, Loc);\n    if (E.isInvalid())\n      return true;\n    E = S.ImpCastExprToType(E.get(), BaseType, CK_UncheckedDerivedToBase,\n                            VK_LValue, &BasePath);\n    if (E.isInvalid())\n      return true;\n    E = S.BuildFieldReferenceExpr(E.get(), /*IsArrow*/ false, Loc,\n                                  CXXScopeSpec(), FD,\n                                  DeclAccessPair::make(FD, FD->getAccess()),\n                                  DeclarationNameInfo(FD->getDeclName(), Loc));\n    if (E.isInvalid())\n      return true;\n\n    // If the type of the member is T, the referenced type is cv T, where cv is\n    // the cv-qualification of the decomposition expression.\n    //\n    // FIXME: We resolve a defect here: if the field is mutable, we do not add\n    // 'const' to the type of the field.\n    Qualifiers Q = DecompType.getQualifiers();\n    if (FD->isMutable())\n      Q.removeConst();\n    B->setBinding(S.BuildQualifiedType(FD->getType(), Loc, Q), E.get());\n  }\n\n  if (I != Bindings.size())\n    return DiagnoseBadNumberOfBindings();\n\n  return false;\n}\n\nvoid Sema::CheckCompleteDecompositionDeclaration(DecompositionDecl *DD) {\n  QualType DecompType = DD->getType();\n\n  // If the type of the decomposition is dependent, then so is the type of\n  // each binding.\n  if (DecompType->isDependentType()) {\n    for (auto *B : DD->bindings())\n      B->setType(Context.DependentTy);\n    return;\n  }\n\n  DecompType = DecompType.getNonReferenceType();\n  ArrayRef<BindingDecl*> Bindings = DD->bindings();\n\n  // C++1z [dcl.decomp]/2:\n  //   If E is an array type [...]\n  // As an extension, we also support decomposition of built-in complex and\n  // vector types.\n  if (auto *CAT = Context.getAsConstantArrayType(DecompType)) {\n    if (checkArrayDecomposition(*this, Bindings, DD, DecompType, CAT))\n      DD->setInvalidDecl();\n    return;\n  }\n  if (auto *VT = DecompType->getAs<VectorType>()) {\n    if (checkVectorDecomposition(*this, Bindings, DD, DecompType, VT))\n      DD->setInvalidDecl();\n    return;\n  }\n  if (auto *CT = DecompType->getAs<ComplexType>()) {\n    if (checkComplexDecomposition(*this, Bindings, DD, DecompType, CT))\n      DD->setInvalidDecl();\n    return;\n  }\n\n  // C++1z [dcl.decomp]/3:\n  //   if the expression std::tuple_size<E>::value is a well-formed integral\n  //   constant expression, [...]\n  llvm::APSInt TupleSize(32);\n  switch (isTupleLike(*this, DD->getLocation(), DecompType, TupleSize)) {\n  case IsTupleLike::Error:\n    DD->setInvalidDecl();\n    return;\n\n  case IsTupleLike::TupleLike:\n    if (checkTupleLikeDecomposition(*this, Bindings, DD, DecompType, TupleSize))\n      DD->setInvalidDecl();\n    return;\n\n  case IsTupleLike::NotTupleLike:\n    break;\n  }\n\n  // C++1z [dcl.dcl]/8:\n  //   [E shall be of array or non-union class type]\n  CXXRecordDecl *RD = DecompType->getAsCXXRecordDecl();\n  if (!RD || RD->isUnion()) {\n    Diag(DD->getLocation(), diag::err_decomp_decl_unbindable_type)\n        << DD << !RD << DecompType;\n    DD->setInvalidDecl();\n    return;\n  }\n\n  // C++1z [dcl.decomp]/4:\n  //   all of E's non-static data members shall be [...] direct members of\n  //   E or of the same unambiguous public base class of E, ...\n  if (checkMemberDecomposition(*this, Bindings, DD, DecompType, RD))\n    DD->setInvalidDecl();\n}\n\n/// Merge the exception specifications of two variable declarations.\n///\n/// This is called when there's a redeclaration of a VarDecl. The function\n/// checks if the redeclaration might have an exception specification and\n/// validates compatibility and merges the specs if necessary.\nvoid Sema::MergeVarDeclExceptionSpecs(VarDecl *New, VarDecl *Old) {\n  // Shortcut if exceptions are disabled.\n  if (!getLangOpts().CXXExceptions)\n    return;\n\n  assert(Context.hasSameType(New->getType(), Old->getType()) &&\n         \"Should only be called if types are otherwise the same.\");\n\n  QualType NewType = New->getType();\n  QualType OldType = Old->getType();\n\n  // We're only interested in pointers and references to functions, as well\n  // as pointers to member functions.\n  if (const ReferenceType *R = NewType->getAs<ReferenceType>()) {\n    NewType = R->getPointeeType();\n    OldType = OldType->castAs<ReferenceType>()->getPointeeType();\n  } else if (const PointerType *P = NewType->getAs<PointerType>()) {\n    NewType = P->getPointeeType();\n    OldType = OldType->castAs<PointerType>()->getPointeeType();\n  } else if (const MemberPointerType *M = NewType->getAs<MemberPointerType>()) {\n    NewType = M->getPointeeType();\n    OldType = OldType->castAs<MemberPointerType>()->getPointeeType();\n  }\n\n  if (!NewType->isFunctionProtoType())\n    return;\n\n  // There's lots of special cases for functions. For function pointers, system\n  // libraries are hopefully not as broken so that we don't need these\n  // workarounds.\n  if (CheckEquivalentExceptionSpec(\n        OldType->getAs<FunctionProtoType>(), Old->getLocation(),\n        NewType->getAs<FunctionProtoType>(), New->getLocation())) {\n    New->setInvalidDecl();\n  }\n}\n\n/// CheckCXXDefaultArguments - Verify that the default arguments for a\n/// function declaration are well-formed according to C++\n/// [dcl.fct.default].\nvoid Sema::CheckCXXDefaultArguments(FunctionDecl *FD) {\n  unsigned NumParams = FD->getNumParams();\n  unsigned ParamIdx = 0;\n\n  // This checking doesn't make sense for explicit specializations; their\n  // default arguments are determined by the declaration we're specializing,\n  // not by FD.\n  if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)\n    return;\n  if (auto *FTD = FD->getDescribedFunctionTemplate())\n    if (FTD->isMemberSpecialization())\n      return;\n\n  // Find first parameter with a default argument\n  for (; ParamIdx < NumParams; ++ParamIdx) {\n    ParmVarDecl *Param = FD->getParamDecl(ParamIdx);\n    if (Param->hasDefaultArg())\n      break;\n  }\n\n  // C++20 [dcl.fct.default]p4:\n  //   In a given function declaration, each parameter subsequent to a parameter\n  //   with a default argument shall have a default argument supplied in this or\n  //   a previous declaration, unless the parameter was expanded from a\n  //   parameter pack, or shall be a function parameter pack.\n  for (; ParamIdx < NumParams; ++ParamIdx) {\n    ParmVarDecl *Param = FD->getParamDecl(ParamIdx);\n    if (!Param->hasDefaultArg() && !Param->isParameterPack() &&\n        !(CurrentInstantiationScope &&\n          CurrentInstantiationScope->isLocalPackExpansion(Param))) {\n      if (Param->isInvalidDecl())\n        /* We already complained about this parameter. */;\n      else if (Param->getIdentifier())\n        Diag(Param->getLocation(),\n             diag::err_param_default_argument_missing_name)\n          << Param->getIdentifier();\n      else\n        Diag(Param->getLocation(),\n             diag::err_param_default_argument_missing);\n    }\n  }\n}\n\n/// Check that the given type is a literal type. Issue a diagnostic if not,\n/// if Kind is Diagnose.\n/// \\return \\c true if a problem has been found (and optionally diagnosed).\ntemplate <typename... Ts>\nstatic bool CheckLiteralType(Sema &SemaRef, Sema::CheckConstexprKind Kind,\n                             SourceLocation Loc, QualType T, unsigned DiagID,\n                             Ts &&...DiagArgs) {\n  if (T->isDependentType())\n    return false;\n\n  switch (Kind) {\n  case Sema::CheckConstexprKind::Diagnose:\n    return SemaRef.RequireLiteralType(Loc, T, DiagID,\n                                      std::forward<Ts>(DiagArgs)...);\n\n  case Sema::CheckConstexprKind::CheckValid:\n    return !T->isLiteralType(SemaRef.Context);\n  }\n\n  llvm_unreachable(\"unknown CheckConstexprKind\");\n}\n\n/// Determine whether a destructor cannot be constexpr due to\nstatic bool CheckConstexprDestructorSubobjects(Sema &SemaRef,\n                                               const CXXDestructorDecl *DD,\n                                               Sema::CheckConstexprKind Kind) {\n  auto Check = [&](SourceLocation Loc, QualType T, const FieldDecl *FD) {\n    const CXXRecordDecl *RD =\n        T->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();\n    if (!RD || RD->hasConstexprDestructor())\n      return true;\n\n    if (Kind == Sema::CheckConstexprKind::Diagnose) {\n      SemaRef.Diag(DD->getLocation(), diag::err_constexpr_dtor_subobject)\n          << static_cast<int>(DD->getConstexprKind()) << !FD\n          << (FD ? FD->getDeclName() : DeclarationName()) << T;\n      SemaRef.Diag(Loc, diag::note_constexpr_dtor_subobject)\n          << !FD << (FD ? FD->getDeclName() : DeclarationName()) << T;\n    }\n    return false;\n  };\n\n  const CXXRecordDecl *RD = DD->getParent();\n  for (const CXXBaseSpecifier &B : RD->bases())\n    if (!Check(B.getBaseTypeLoc(), B.getType(), nullptr))\n      return false;\n  for (const FieldDecl *FD : RD->fields())\n    if (!Check(FD->getLocation(), FD->getType(), FD))\n      return false;\n  return true;\n}\n\n/// Check whether a function's parameter types are all literal types. If so,\n/// return true. If not, produce a suitable diagnostic and return false.\nstatic bool CheckConstexprParameterTypes(Sema &SemaRef,\n                                         const FunctionDecl *FD,\n                                         Sema::CheckConstexprKind Kind) {\n  unsigned ArgIndex = 0;\n  const auto *FT = FD->getType()->castAs<FunctionProtoType>();\n  for (FunctionProtoType::param_type_iterator i = FT->param_type_begin(),\n                                              e = FT->param_type_end();\n       i != e; ++i, ++ArgIndex) {\n    const ParmVarDecl *PD = FD->getParamDecl(ArgIndex);\n    SourceLocation ParamLoc = PD->getLocation();\n    if (CheckLiteralType(SemaRef, Kind, ParamLoc, *i,\n                         diag::err_constexpr_non_literal_param, ArgIndex + 1,\n                         PD->getSourceRange(), isa<CXXConstructorDecl>(FD),\n                         FD->isConsteval()))\n      return false;\n  }\n  return true;\n}\n\n/// Check whether a function's return type is a literal type. If so, return\n/// true. If not, produce a suitable diagnostic and return false.\nstatic bool CheckConstexprReturnType(Sema &SemaRef, const FunctionDecl *FD,\n                                     Sema::CheckConstexprKind Kind) {\n  if (CheckLiteralType(SemaRef, Kind, FD->getLocation(), FD->getReturnType(),\n                       diag::err_constexpr_non_literal_return,\n                       FD->isConsteval()))\n    return false;\n  return true;\n}\n\n/// Get diagnostic %select index for tag kind for\n/// record diagnostic message.\n/// WARNING: Indexes apply to particular diagnostics only!\n///\n/// \\returns diagnostic %select index.\nstatic unsigned getRecordDiagFromTagKind(TagTypeKind Tag) {\n  switch (Tag) {\n  case TTK_Struct: return 0;\n  case TTK_Interface: return 1;\n  case TTK_Class:  return 2;\n  default: llvm_unreachable(\"Invalid tag kind for record diagnostic!\");\n  }\n}\n\nstatic bool CheckConstexprFunctionBody(Sema &SemaRef, const FunctionDecl *Dcl,\n                                       Stmt *Body,\n                                       Sema::CheckConstexprKind Kind);\n\n// Check whether a function declaration satisfies the requirements of a\n// constexpr function definition or a constexpr constructor definition. If so,\n// return true. If not, produce appropriate diagnostics (unless asked not to by\n// Kind) and return false.\n//\n// This implements C++11 [dcl.constexpr]p3,4, as amended by DR1360.\nbool Sema::CheckConstexprFunctionDefinition(const FunctionDecl *NewFD,\n                                            CheckConstexprKind Kind) {\n  const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(NewFD);\n  if (MD && MD->isInstance()) {\n    // C++11 [dcl.constexpr]p4:\n    //  The definition of a constexpr constructor shall satisfy the following\n    //  constraints:\n    //  - the class shall not have any virtual base classes;\n    //\n    // FIXME: This only applies to constructors and destructors, not arbitrary\n    // member functions.\n    const CXXRecordDecl *RD = MD->getParent();\n    if (RD->getNumVBases()) {\n      if (Kind == CheckConstexprKind::CheckValid)\n        return false;\n\n      Diag(NewFD->getLocation(), diag::err_constexpr_virtual_base)\n        << isa<CXXConstructorDecl>(NewFD)\n        << getRecordDiagFromTagKind(RD->getTagKind()) << RD->getNumVBases();\n      for (const auto &I : RD->vbases())\n        Diag(I.getBeginLoc(), diag::note_constexpr_virtual_base_here)\n            << I.getSourceRange();\n      return false;\n    }\n  }\n\n  if (!isa<CXXConstructorDecl>(NewFD)) {\n    // C++11 [dcl.constexpr]p3:\n    //  The definition of a constexpr function shall satisfy the following\n    //  constraints:\n    // - it shall not be virtual; (removed in C++20)\n    const CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(NewFD);\n    if (Method && Method->isVirtual()) {\n      if (getLangOpts().CPlusPlus20) {\n        if (Kind == CheckConstexprKind::Diagnose)\n          Diag(Method->getLocation(), diag::warn_cxx17_compat_constexpr_virtual);\n      } else {\n        if (Kind == CheckConstexprKind::CheckValid)\n          return false;\n\n        Method = Method->getCanonicalDecl();\n        Diag(Method->getLocation(), diag::err_constexpr_virtual);\n\n        // If it's not obvious why this function is virtual, find an overridden\n        // function which uses the 'virtual' keyword.\n        const CXXMethodDecl *WrittenVirtual = Method;\n        while (!WrittenVirtual->isVirtualAsWritten())\n          WrittenVirtual = *WrittenVirtual->begin_overridden_methods();\n        if (WrittenVirtual != Method)\n          Diag(WrittenVirtual->getLocation(),\n               diag::note_overridden_virtual_function);\n        return false;\n      }\n    }\n\n    // - its return type shall be a literal type;\n    if (!CheckConstexprReturnType(*this, NewFD, Kind))\n      return false;\n  }\n\n  if (auto *Dtor = dyn_cast<CXXDestructorDecl>(NewFD)) {\n    // A destructor can be constexpr only if the defaulted destructor could be;\n    // we don't need to check the members and bases if we already know they all\n    // have constexpr destructors.\n    if (!Dtor->getParent()->defaultedDestructorIsConstexpr()) {\n      if (Kind == CheckConstexprKind::CheckValid)\n        return false;\n      if (!CheckConstexprDestructorSubobjects(*this, Dtor, Kind))\n        return false;\n    }\n  }\n\n  // - each of its parameter types shall be a literal type;\n  if (!CheckConstexprParameterTypes(*this, NewFD, Kind))\n    return false;\n\n  Stmt *Body = NewFD->getBody();\n  assert(Body &&\n         \"CheckConstexprFunctionDefinition called on function with no body\");\n  return CheckConstexprFunctionBody(*this, NewFD, Body, Kind);\n}\n\n/// Check the given declaration statement is legal within a constexpr function\n/// body. C++11 [dcl.constexpr]p3,p4, and C++1y [dcl.constexpr]p3.\n///\n/// \\return true if the body is OK (maybe only as an extension), false if we\n///         have diagnosed a problem.\nstatic bool CheckConstexprDeclStmt(Sema &SemaRef, const FunctionDecl *Dcl,\n                                   DeclStmt *DS, SourceLocation &Cxx1yLoc,\n                                   Sema::CheckConstexprKind Kind) {\n  // C++11 [dcl.constexpr]p3 and p4:\n  //  The definition of a constexpr function(p3) or constructor(p4) [...] shall\n  //  contain only\n  for (const auto *DclIt : DS->decls()) {\n    switch (DclIt->getKind()) {\n    case Decl::StaticAssert:\n    case Decl::Using:\n    case Decl::UsingShadow:\n    case Decl::UsingDirective:\n    case Decl::UnresolvedUsingTypename:\n    case Decl::UnresolvedUsingValue:\n      //   - static_assert-declarations\n      //   - using-declarations,\n      //   - using-directives,\n      continue;\n\n    case Decl::Typedef:\n    case Decl::TypeAlias: {\n      //   - typedef declarations and alias-declarations that do not define\n      //     classes or enumerations,\n      const auto *TN = cast<TypedefNameDecl>(DclIt);\n      if (TN->getUnderlyingType()->isVariablyModifiedType()) {\n        // Don't allow variably-modified types in constexpr functions.\n        if (Kind == Sema::CheckConstexprKind::Diagnose) {\n          TypeLoc TL = TN->getTypeSourceInfo()->getTypeLoc();\n          SemaRef.Diag(TL.getBeginLoc(), diag::err_constexpr_vla)\n            << TL.getSourceRange() << TL.getType()\n            << isa<CXXConstructorDecl>(Dcl);\n        }\n        return false;\n      }\n      continue;\n    }\n\n    case Decl::Enum:\n    case Decl::CXXRecord:\n      // C++1y allows types to be defined, not just declared.\n      if (cast<TagDecl>(DclIt)->isThisDeclarationADefinition()) {\n        if (Kind == Sema::CheckConstexprKind::Diagnose) {\n          SemaRef.Diag(DS->getBeginLoc(),\n                       SemaRef.getLangOpts().CPlusPlus14\n                           ? diag::warn_cxx11_compat_constexpr_type_definition\n                           : diag::ext_constexpr_type_definition)\n              << isa<CXXConstructorDecl>(Dcl);\n        } else if (!SemaRef.getLangOpts().CPlusPlus14) {\n          return false;\n        }\n      }\n      continue;\n\n    case Decl::EnumConstant:\n    case Decl::IndirectField:\n    case Decl::ParmVar:\n      // These can only appear with other declarations which are banned in\n      // C++11 and permitted in C++1y, so ignore them.\n      continue;\n\n    case Decl::Var:\n    case Decl::Decomposition: {\n      // C++1y [dcl.constexpr]p3 allows anything except:\n      //   a definition of a variable of non-literal type or of static or\n      //   thread storage duration or [before C++2a] for which no\n      //   initialization is performed.\n      const auto *VD = cast<VarDecl>(DclIt);\n      if (VD->isThisDeclarationADefinition()) {\n        if (VD->isStaticLocal()) {\n          if (Kind == Sema::CheckConstexprKind::Diagnose) {\n            SemaRef.Diag(VD->getLocation(),\n                         diag::err_constexpr_local_var_static)\n              << isa<CXXConstructorDecl>(Dcl)\n              << (VD->getTLSKind() == VarDecl::TLS_Dynamic);\n          }\n          return false;\n        }\n        if (CheckLiteralType(SemaRef, Kind, VD->getLocation(), VD->getType(),\n                             diag::err_constexpr_local_var_non_literal_type,\n                             isa<CXXConstructorDecl>(Dcl)))\n          return false;\n        if (!VD->getType()->isDependentType() &&\n            !VD->hasInit() && !VD->isCXXForRangeDecl()) {\n          if (Kind == Sema::CheckConstexprKind::Diagnose) {\n            SemaRef.Diag(\n                VD->getLocation(),\n                SemaRef.getLangOpts().CPlusPlus20\n                    ? diag::warn_cxx17_compat_constexpr_local_var_no_init\n                    : diag::ext_constexpr_local_var_no_init)\n                << isa<CXXConstructorDecl>(Dcl);\n          } else if (!SemaRef.getLangOpts().CPlusPlus20) {\n            return false;\n          }\n          continue;\n        }\n      }\n      if (Kind == Sema::CheckConstexprKind::Diagnose) {\n        SemaRef.Diag(VD->getLocation(),\n                     SemaRef.getLangOpts().CPlusPlus14\n                      ? diag::warn_cxx11_compat_constexpr_local_var\n                      : diag::ext_constexpr_local_var)\n          << isa<CXXConstructorDecl>(Dcl);\n      } else if (!SemaRef.getLangOpts().CPlusPlus14) {\n        return false;\n      }\n      continue;\n    }\n\n    case Decl::NamespaceAlias:\n    case Decl::Function:\n      // These are disallowed in C++11 and permitted in C++1y. Allow them\n      // everywhere as an extension.\n      if (!Cxx1yLoc.isValid())\n        Cxx1yLoc = DS->getBeginLoc();\n      continue;\n\n    default:\n      if (Kind == Sema::CheckConstexprKind::Diagnose) {\n        SemaRef.Diag(DS->getBeginLoc(), diag::err_constexpr_body_invalid_stmt)\n            << isa<CXXConstructorDecl>(Dcl) << Dcl->isConsteval();\n      }\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/// Check that the given field is initialized within a constexpr constructor.\n///\n/// \\param Dcl The constexpr constructor being checked.\n/// \\param Field The field being checked. This may be a member of an anonymous\n///        struct or union nested within the class being checked.\n/// \\param Inits All declarations, including anonymous struct/union members and\n///        indirect members, for which any initialization was provided.\n/// \\param Diagnosed Whether we've emitted the error message yet. Used to attach\n///        multiple notes for different members to the same error.\n/// \\param Kind Whether we're diagnosing a constructor as written or determining\n///        whether the formal requirements are satisfied.\n/// \\return \\c false if we're checking for validity and the constructor does\n///         not satisfy the requirements on a constexpr constructor.\nstatic bool CheckConstexprCtorInitializer(Sema &SemaRef,\n                                          const FunctionDecl *Dcl,\n                                          FieldDecl *Field,\n                                          llvm::SmallSet<Decl*, 16> &Inits,\n                                          bool &Diagnosed,\n                                          Sema::CheckConstexprKind Kind) {\n  // In C++20 onwards, there's nothing to check for validity.\n  if (Kind == Sema::CheckConstexprKind::CheckValid &&\n      SemaRef.getLangOpts().CPlusPlus20)\n    return true;\n\n  if (Field->isInvalidDecl())\n    return true;\n\n  if (Field->isUnnamedBitfield())\n    return true;\n\n  // Anonymous unions with no variant members and empty anonymous structs do not\n  // need to be explicitly initialized. FIXME: Anonymous structs that contain no\n  // indirect fields don't need initializing.\n  if (Field->isAnonymousStructOrUnion() &&\n      (Field->getType()->isUnionType()\n           ? !Field->getType()->getAsCXXRecordDecl()->hasVariantMembers()\n           : Field->getType()->getAsCXXRecordDecl()->isEmpty()))\n    return true;\n\n  if (!Inits.count(Field)) {\n    if (Kind == Sema::CheckConstexprKind::Diagnose) {\n      if (!Diagnosed) {\n        SemaRef.Diag(Dcl->getLocation(),\n                     SemaRef.getLangOpts().CPlusPlus20\n                         ? diag::warn_cxx17_compat_constexpr_ctor_missing_init\n                         : diag::ext_constexpr_ctor_missing_init);\n        Diagnosed = true;\n      }\n      SemaRef.Diag(Field->getLocation(),\n                   diag::note_constexpr_ctor_missing_init);\n    } else if (!SemaRef.getLangOpts().CPlusPlus20) {\n      return false;\n    }\n  } else if (Field->isAnonymousStructOrUnion()) {\n    const RecordDecl *RD = Field->getType()->castAs<RecordType>()->getDecl();\n    for (auto *I : RD->fields())\n      // If an anonymous union contains an anonymous struct of which any member\n      // is initialized, all members must be initialized.\n      if (!RD->isUnion() || Inits.count(I))\n        if (!CheckConstexprCtorInitializer(SemaRef, Dcl, I, Inits, Diagnosed,\n                                           Kind))\n          return false;\n  }\n  return true;\n}\n\n/// Check the provided statement is allowed in a constexpr function\n/// definition.\nstatic bool\nCheckConstexprFunctionStmt(Sema &SemaRef, const FunctionDecl *Dcl, Stmt *S,\n                           SmallVectorImpl<SourceLocation> &ReturnStmts,\n                           SourceLocation &Cxx1yLoc, SourceLocation &Cxx2aLoc,\n                           Sema::CheckConstexprKind Kind) {\n  // - its function-body shall be [...] a compound-statement that contains only\n  switch (S->getStmtClass()) {\n  case Stmt::NullStmtClass:\n    //   - null statements,\n    return true;\n\n  case Stmt::DeclStmtClass:\n    //   - static_assert-declarations\n    //   - using-declarations,\n    //   - using-directives,\n    //   - typedef declarations and alias-declarations that do not define\n    //     classes or enumerations,\n    if (!CheckConstexprDeclStmt(SemaRef, Dcl, cast<DeclStmt>(S), Cxx1yLoc, Kind))\n      return false;\n    return true;\n\n  case Stmt::ReturnStmtClass:\n    //   - and exactly one return statement;\n    if (isa<CXXConstructorDecl>(Dcl)) {\n      // C++1y allows return statements in constexpr constructors.\n      if (!Cxx1yLoc.isValid())\n        Cxx1yLoc = S->getBeginLoc();\n      return true;\n    }\n\n    ReturnStmts.push_back(S->getBeginLoc());\n    return true;\n\n  case Stmt::CompoundStmtClass: {\n    // C++1y allows compound-statements.\n    if (!Cxx1yLoc.isValid())\n      Cxx1yLoc = S->getBeginLoc();\n\n    CompoundStmt *CompStmt = cast<CompoundStmt>(S);\n    for (auto *BodyIt : CompStmt->body()) {\n      if (!CheckConstexprFunctionStmt(SemaRef, Dcl, BodyIt, ReturnStmts,\n                                      Cxx1yLoc, Cxx2aLoc, Kind))\n        return false;\n    }\n    return true;\n  }\n\n  case Stmt::AttributedStmtClass:\n    if (!Cxx1yLoc.isValid())\n      Cxx1yLoc = S->getBeginLoc();\n    return true;\n\n  case Stmt::IfStmtClass: {\n    // C++1y allows if-statements.\n    if (!Cxx1yLoc.isValid())\n      Cxx1yLoc = S->getBeginLoc();\n\n    IfStmt *If = cast<IfStmt>(S);\n    if (!CheckConstexprFunctionStmt(SemaRef, Dcl, If->getThen(), ReturnStmts,\n                                    Cxx1yLoc, Cxx2aLoc, Kind))\n      return false;\n    if (If->getElse() &&\n        !CheckConstexprFunctionStmt(SemaRef, Dcl, If->getElse(), ReturnStmts,\n                                    Cxx1yLoc, Cxx2aLoc, Kind))\n      return false;\n    return true;\n  }\n\n  case Stmt::WhileStmtClass:\n  case Stmt::DoStmtClass:\n  case Stmt::ForStmtClass:\n  case Stmt::CXXForRangeStmtClass:\n  case Stmt::ContinueStmtClass:\n    // C++1y allows all of these. We don't allow them as extensions in C++11,\n    // because they don't make sense without variable mutation.\n    if (!SemaRef.getLangOpts().CPlusPlus14)\n      break;\n    if (!Cxx1yLoc.isValid())\n      Cxx1yLoc = S->getBeginLoc();\n    for (Stmt *SubStmt : S->children())\n      if (SubStmt &&\n          !CheckConstexprFunctionStmt(SemaRef, Dcl, SubStmt, ReturnStmts,\n                                      Cxx1yLoc, Cxx2aLoc, Kind))\n        return false;\n    return true;\n\n  case Stmt::SwitchStmtClass:\n  case Stmt::CaseStmtClass:\n  case Stmt::DefaultStmtClass:\n  case Stmt::BreakStmtClass:\n    // C++1y allows switch-statements, and since they don't need variable\n    // mutation, we can reasonably allow them in C++11 as an extension.\n    if (!Cxx1yLoc.isValid())\n      Cxx1yLoc = S->getBeginLoc();\n    for (Stmt *SubStmt : S->children())\n      if (SubStmt &&\n          !CheckConstexprFunctionStmt(SemaRef, Dcl, SubStmt, ReturnStmts,\n                                      Cxx1yLoc, Cxx2aLoc, Kind))\n        return false;\n    return true;\n\n  case Stmt::GCCAsmStmtClass:\n  case Stmt::MSAsmStmtClass:\n    // C++2a allows inline assembly statements.\n  case Stmt::CXXTryStmtClass:\n    if (Cxx2aLoc.isInvalid())\n      Cxx2aLoc = S->getBeginLoc();\n    for (Stmt *SubStmt : S->children()) {\n      if (SubStmt &&\n          !CheckConstexprFunctionStmt(SemaRef, Dcl, SubStmt, ReturnStmts,\n                                      Cxx1yLoc, Cxx2aLoc, Kind))\n        return false;\n    }\n    return true;\n\n  case Stmt::CXXCatchStmtClass:\n    // Do not bother checking the language mode (already covered by the\n    // try block check).\n    if (!CheckConstexprFunctionStmt(SemaRef, Dcl,\n                                    cast<CXXCatchStmt>(S)->getHandlerBlock(),\n                                    ReturnStmts, Cxx1yLoc, Cxx2aLoc, Kind))\n      return false;\n    return true;\n\n  default:\n    if (!isa<Expr>(S))\n      break;\n\n    // C++1y allows expression-statements.\n    if (!Cxx1yLoc.isValid())\n      Cxx1yLoc = S->getBeginLoc();\n    return true;\n  }\n\n  if (Kind == Sema::CheckConstexprKind::Diagnose) {\n    SemaRef.Diag(S->getBeginLoc(), diag::err_constexpr_body_invalid_stmt)\n        << isa<CXXConstructorDecl>(Dcl) << Dcl->isConsteval();\n  }\n  return false;\n}\n\n/// Check the body for the given constexpr function declaration only contains\n/// the permitted types of statement. C++11 [dcl.constexpr]p3,p4.\n///\n/// \\return true if the body is OK, false if we have found or diagnosed a\n/// problem.\nstatic bool CheckConstexprFunctionBody(Sema &SemaRef, const FunctionDecl *Dcl,\n                                       Stmt *Body,\n                                       Sema::CheckConstexprKind Kind) {\n  SmallVector<SourceLocation, 4> ReturnStmts;\n\n  if (isa<CXXTryStmt>(Body)) {\n    // C++11 [dcl.constexpr]p3:\n    //  The definition of a constexpr function shall satisfy the following\n    //  constraints: [...]\n    // - its function-body shall be = delete, = default, or a\n    //   compound-statement\n    //\n    // C++11 [dcl.constexpr]p4:\n    //  In the definition of a constexpr constructor, [...]\n    // - its function-body shall not be a function-try-block;\n    //\n    // This restriction is lifted in C++2a, as long as inner statements also\n    // apply the general constexpr rules.\n    switch (Kind) {\n    case Sema::CheckConstexprKind::CheckValid:\n      if (!SemaRef.getLangOpts().CPlusPlus20)\n        return false;\n      break;\n\n    case Sema::CheckConstexprKind::Diagnose:\n      SemaRef.Diag(Body->getBeginLoc(),\n           !SemaRef.getLangOpts().CPlusPlus20\n               ? diag::ext_constexpr_function_try_block_cxx20\n               : diag::warn_cxx17_compat_constexpr_function_try_block)\n          << isa<CXXConstructorDecl>(Dcl);\n      break;\n    }\n  }\n\n  // - its function-body shall be [...] a compound-statement that contains only\n  //   [... list of cases ...]\n  //\n  // Note that walking the children here is enough to properly check for\n  // CompoundStmt and CXXTryStmt body.\n  SourceLocation Cxx1yLoc, Cxx2aLoc;\n  for (Stmt *SubStmt : Body->children()) {\n    if (SubStmt &&\n        !CheckConstexprFunctionStmt(SemaRef, Dcl, SubStmt, ReturnStmts,\n                                    Cxx1yLoc, Cxx2aLoc, Kind))\n      return false;\n  }\n\n  if (Kind == Sema::CheckConstexprKind::CheckValid) {\n    // If this is only valid as an extension, report that we don't satisfy the\n    // constraints of the current language.\n    if ((Cxx2aLoc.isValid() && !SemaRef.getLangOpts().CPlusPlus20) ||\n        (Cxx1yLoc.isValid() && !SemaRef.getLangOpts().CPlusPlus17))\n      return false;\n  } else if (Cxx2aLoc.isValid()) {\n    SemaRef.Diag(Cxx2aLoc,\n         SemaRef.getLangOpts().CPlusPlus20\n           ? diag::warn_cxx17_compat_constexpr_body_invalid_stmt\n           : diag::ext_constexpr_body_invalid_stmt_cxx20)\n      << isa<CXXConstructorDecl>(Dcl);\n  } else if (Cxx1yLoc.isValid()) {\n    SemaRef.Diag(Cxx1yLoc,\n         SemaRef.getLangOpts().CPlusPlus14\n           ? diag::warn_cxx11_compat_constexpr_body_invalid_stmt\n           : diag::ext_constexpr_body_invalid_stmt)\n      << isa<CXXConstructorDecl>(Dcl);\n  }\n\n  if (const CXXConstructorDecl *Constructor\n        = dyn_cast<CXXConstructorDecl>(Dcl)) {\n    const CXXRecordDecl *RD = Constructor->getParent();\n    // DR1359:\n    // - every non-variant non-static data member and base class sub-object\n    //   shall be initialized;\n    // DR1460:\n    // - if the class is a union having variant members, exactly one of them\n    //   shall be initialized;\n    if (RD->isUnion()) {\n      if (Constructor->getNumCtorInitializers() == 0 &&\n          RD->hasVariantMembers()) {\n        if (Kind == Sema::CheckConstexprKind::Diagnose) {\n          SemaRef.Diag(\n              Dcl->getLocation(),\n              SemaRef.getLangOpts().CPlusPlus20\n                  ? diag::warn_cxx17_compat_constexpr_union_ctor_no_init\n                  : diag::ext_constexpr_union_ctor_no_init);\n        } else if (!SemaRef.getLangOpts().CPlusPlus20) {\n          return false;\n        }\n      }\n    } else if (!Constructor->isDependentContext() &&\n               !Constructor->isDelegatingConstructor()) {\n      assert(RD->getNumVBases() == 0 && \"constexpr ctor with virtual bases\");\n\n      // Skip detailed checking if we have enough initializers, and we would\n      // allow at most one initializer per member.\n      bool AnyAnonStructUnionMembers = false;\n      unsigned Fields = 0;\n      for (CXXRecordDecl::field_iterator I = RD->field_begin(),\n           E = RD->field_end(); I != E; ++I, ++Fields) {\n        if (I->isAnonymousStructOrUnion()) {\n          AnyAnonStructUnionMembers = true;\n          break;\n        }\n      }\n      // DR1460:\n      // - if the class is a union-like class, but is not a union, for each of\n      //   its anonymous union members having variant members, exactly one of\n      //   them shall be initialized;\n      if (AnyAnonStructUnionMembers ||\n          Constructor->getNumCtorInitializers() != RD->getNumBases() + Fields) {\n        // Check initialization of non-static data members. Base classes are\n        // always initialized so do not need to be checked. Dependent bases\n        // might not have initializers in the member initializer list.\n        llvm::SmallSet<Decl*, 16> Inits;\n        for (const auto *I: Constructor->inits()) {\n          if (FieldDecl *FD = I->getMember())\n            Inits.insert(FD);\n          else if (IndirectFieldDecl *ID = I->getIndirectMember())\n            Inits.insert(ID->chain_begin(), ID->chain_end());\n        }\n\n        bool Diagnosed = false;\n        for (auto *I : RD->fields())\n          if (!CheckConstexprCtorInitializer(SemaRef, Dcl, I, Inits, Diagnosed,\n                                             Kind))\n            return false;\n      }\n    }\n  } else {\n    if (ReturnStmts.empty()) {\n      // C++1y doesn't require constexpr functions to contain a 'return'\n      // statement. We still do, unless the return type might be void, because\n      // otherwise if there's no return statement, the function cannot\n      // be used in a core constant expression.\n      bool OK = SemaRef.getLangOpts().CPlusPlus14 &&\n                (Dcl->getReturnType()->isVoidType() ||\n                 Dcl->getReturnType()->isDependentType());\n      switch (Kind) {\n      case Sema::CheckConstexprKind::Diagnose:\n        SemaRef.Diag(Dcl->getLocation(),\n                     OK ? diag::warn_cxx11_compat_constexpr_body_no_return\n                        : diag::err_constexpr_body_no_return)\n            << Dcl->isConsteval();\n        if (!OK)\n          return false;\n        break;\n\n      case Sema::CheckConstexprKind::CheckValid:\n        // The formal requirements don't include this rule in C++14, even\n        // though the \"must be able to produce a constant expression\" rules\n        // still imply it in some cases.\n        if (!SemaRef.getLangOpts().CPlusPlus14)\n          return false;\n        break;\n      }\n    } else if (ReturnStmts.size() > 1) {\n      switch (Kind) {\n      case Sema::CheckConstexprKind::Diagnose:\n        SemaRef.Diag(\n            ReturnStmts.back(),\n            SemaRef.getLangOpts().CPlusPlus14\n                ? diag::warn_cxx11_compat_constexpr_body_multiple_return\n                : diag::ext_constexpr_body_multiple_return);\n        for (unsigned I = 0; I < ReturnStmts.size() - 1; ++I)\n          SemaRef.Diag(ReturnStmts[I],\n                       diag::note_constexpr_body_previous_return);\n        break;\n\n      case Sema::CheckConstexprKind::CheckValid:\n        if (!SemaRef.getLangOpts().CPlusPlus14)\n          return false;\n        break;\n      }\n    }\n  }\n\n  // C++11 [dcl.constexpr]p5:\n  //   if no function argument values exist such that the function invocation\n  //   substitution would produce a constant expression, the program is\n  //   ill-formed; no diagnostic required.\n  // C++11 [dcl.constexpr]p3:\n  //   - every constructor call and implicit conversion used in initializing the\n  //     return value shall be one of those allowed in a constant expression.\n  // C++11 [dcl.constexpr]p4:\n  //   - every constructor involved in initializing non-static data members and\n  //     base class sub-objects shall be a constexpr constructor.\n  //\n  // Note that this rule is distinct from the \"requirements for a constexpr\n  // function\", so is not checked in CheckValid mode.\n  SmallVector<PartialDiagnosticAt, 8> Diags;\n  if (Kind == Sema::CheckConstexprKind::Diagnose &&\n      !Expr::isPotentialConstantExpr(Dcl, Diags)) {\n    SemaRef.Diag(Dcl->getLocation(),\n                 diag::ext_constexpr_function_never_constant_expr)\n        << isa<CXXConstructorDecl>(Dcl) << Dcl->isConsteval();\n    for (size_t I = 0, N = Diags.size(); I != N; ++I)\n      SemaRef.Diag(Diags[I].first, Diags[I].second);\n    // Don't return false here: we allow this for compatibility in\n    // system headers.\n  }\n\n  return true;\n}\n\n/// Get the class that is directly named by the current context. This is the\n/// class for which an unqualified-id in this scope could name a constructor\n/// or destructor.\n///\n/// If the scope specifier denotes a class, this will be that class.\n/// If the scope specifier is empty, this will be the class whose\n/// member-specification we are currently within. Otherwise, there\n/// is no such class.\nCXXRecordDecl *Sema::getCurrentClass(Scope *, const CXXScopeSpec *SS) {\n  assert(getLangOpts().CPlusPlus && \"No class names in C!\");\n\n  if (SS && SS->isInvalid())\n    return nullptr;\n\n  if (SS && SS->isNotEmpty()) {\n    DeclContext *DC = computeDeclContext(*SS, true);\n    return dyn_cast_or_null<CXXRecordDecl>(DC);\n  }\n\n  return dyn_cast_or_null<CXXRecordDecl>(CurContext);\n}\n\n/// isCurrentClassName - Determine whether the identifier II is the\n/// name of the class type currently being defined. In the case of\n/// nested classes, this will only return true if II is the name of\n/// the innermost class.\nbool Sema::isCurrentClassName(const IdentifierInfo &II, Scope *S,\n                              const CXXScopeSpec *SS) {\n  CXXRecordDecl *CurDecl = getCurrentClass(S, SS);\n  return CurDecl && &II == CurDecl->getIdentifier();\n}\n\n/// Determine whether the identifier II is a typo for the name of\n/// the class type currently being defined. If so, update it to the identifier\n/// that should have been used.\nbool Sema::isCurrentClassNameTypo(IdentifierInfo *&II, const CXXScopeSpec *SS) {\n  assert(getLangOpts().CPlusPlus && \"No class names in C!\");\n\n  if (!getLangOpts().SpellChecking)\n    return false;\n\n  CXXRecordDecl *CurDecl;\n  if (SS && SS->isSet() && !SS->isInvalid()) {\n    DeclContext *DC = computeDeclContext(*SS, true);\n    CurDecl = dyn_cast_or_null<CXXRecordDecl>(DC);\n  } else\n    CurDecl = dyn_cast_or_null<CXXRecordDecl>(CurContext);\n\n  if (CurDecl && CurDecl->getIdentifier() && II != CurDecl->getIdentifier() &&\n      3 * II->getName().edit_distance(CurDecl->getIdentifier()->getName())\n          < II->getLength()) {\n    II = CurDecl->getIdentifier();\n    return true;\n  }\n\n  return false;\n}\n\n/// Determine whether the given class is a base class of the given\n/// class, including looking at dependent bases.\nstatic bool findCircularInheritance(const CXXRecordDecl *Class,\n                                    const CXXRecordDecl *Current) {\n  SmallVector<const CXXRecordDecl*, 8> Queue;\n\n  Class = Class->getCanonicalDecl();\n  while (true) {\n    for (const auto &I : Current->bases()) {\n      CXXRecordDecl *Base = I.getType()->getAsCXXRecordDecl();\n      if (!Base)\n        continue;\n\n      Base = Base->getDefinition();\n      if (!Base)\n        continue;\n\n      if (Base->getCanonicalDecl() == Class)\n        return true;\n\n      Queue.push_back(Base);\n    }\n\n    if (Queue.empty())\n      return false;\n\n    Current = Queue.pop_back_val();\n  }\n\n  return false;\n}\n\n/// Check the validity of a C++ base class specifier.\n///\n/// \\returns a new CXXBaseSpecifier if well-formed, emits diagnostics\n/// and returns NULL otherwise.\nCXXBaseSpecifier *\nSema::CheckBaseSpecifier(CXXRecordDecl *Class,\n                         SourceRange SpecifierRange,\n                         bool Virtual, AccessSpecifier Access,\n                         TypeSourceInfo *TInfo,\n                         SourceLocation EllipsisLoc) {\n  QualType BaseType = TInfo->getType();\n  if (BaseType->containsErrors()) {\n    // Already emitted a diagnostic when parsing the error type.\n    return nullptr;\n  }\n  // C++ [class.union]p1:\n  //   A union shall not have base classes.\n  if (Class->isUnion()) {\n    Diag(Class->getLocation(), diag::err_base_clause_on_union)\n      << SpecifierRange;\n    return nullptr;\n  }\n\n  if (EllipsisLoc.isValid() &&\n      !TInfo->getType()->containsUnexpandedParameterPack()) {\n    Diag(EllipsisLoc, diag::err_pack_expansion_without_parameter_packs)\n      << TInfo->getTypeLoc().getSourceRange();\n    EllipsisLoc = SourceLocation();\n  }\n\n  SourceLocation BaseLoc = TInfo->getTypeLoc().getBeginLoc();\n\n  if (BaseType->isDependentType()) {\n    // Make sure that we don't have circular inheritance among our dependent\n    // bases. For non-dependent bases, the check for completeness below handles\n    // this.\n    if (CXXRecordDecl *BaseDecl = BaseType->getAsCXXRecordDecl()) {\n      if (BaseDecl->getCanonicalDecl() == Class->getCanonicalDecl() ||\n          ((BaseDecl = BaseDecl->getDefinition()) &&\n           findCircularInheritance(Class, BaseDecl))) {\n        Diag(BaseLoc, diag::err_circular_inheritance)\n          << BaseType << Context.getTypeDeclType(Class);\n\n        if (BaseDecl->getCanonicalDecl() != Class->getCanonicalDecl())\n          Diag(BaseDecl->getLocation(), diag::note_previous_decl)\n            << BaseType;\n\n        return nullptr;\n      }\n    }\n\n    return new (Context) CXXBaseSpecifier(SpecifierRange, Virtual,\n                                          Class->getTagKind() == TTK_Class,\n                                          Access, TInfo, EllipsisLoc);\n  }\n\n  // Base specifiers must be record types.\n  if (!BaseType->isRecordType()) {\n    Diag(BaseLoc, diag::err_base_must_be_class) << SpecifierRange;\n    return nullptr;\n  }\n\n  // C++ [class.union]p1:\n  //   A union shall not be used as a base class.\n  if (BaseType->isUnionType()) {\n    Diag(BaseLoc, diag::err_union_as_base_class) << SpecifierRange;\n    return nullptr;\n  }\n\n  // For the MS ABI, propagate DLL attributes to base class templates.\n  if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    if (Attr *ClassAttr = getDLLAttr(Class)) {\n      if (auto *BaseTemplate = dyn_cast_or_null<ClassTemplateSpecializationDecl>(\n              BaseType->getAsCXXRecordDecl())) {\n        propagateDLLAttrToBaseClassTemplate(Class, ClassAttr, BaseTemplate,\n                                            BaseLoc);\n      }\n    }\n  }\n\n  // C++ [class.derived]p2:\n  //   The class-name in a base-specifier shall not be an incompletely\n  //   defined class.\n  if (RequireCompleteType(BaseLoc, BaseType,\n                          diag::err_incomplete_base_class, SpecifierRange)) {\n    Class->setInvalidDecl();\n    return nullptr;\n  }\n\n  // If the base class is polymorphic or isn't empty, the new one is/isn't, too.\n  RecordDecl *BaseDecl = BaseType->castAs<RecordType>()->getDecl();\n  assert(BaseDecl && \"Record type has no declaration\");\n  BaseDecl = BaseDecl->getDefinition();\n  assert(BaseDecl && \"Base type is not incomplete, but has no definition\");\n  CXXRecordDecl *CXXBaseDecl = cast<CXXRecordDecl>(BaseDecl);\n  assert(CXXBaseDecl && \"Base type is not a C++ type\");\n\n  // Microsoft docs say:\n  // \"If a base-class has a code_seg attribute, derived classes must have the\n  // same attribute.\"\n  const auto *BaseCSA = CXXBaseDecl->getAttr<CodeSegAttr>();\n  const auto *DerivedCSA = Class->getAttr<CodeSegAttr>();\n  if ((DerivedCSA || BaseCSA) &&\n      (!BaseCSA || !DerivedCSA || BaseCSA->getName() != DerivedCSA->getName())) {\n    Diag(Class->getLocation(), diag::err_mismatched_code_seg_base);\n    Diag(CXXBaseDecl->getLocation(), diag::note_base_class_specified_here)\n      << CXXBaseDecl;\n    return nullptr;\n  }\n\n  // A class which contains a flexible array member is not suitable for use as a\n  // base class:\n  //   - If the layout determines that a base comes before another base,\n  //     the flexible array member would index into the subsequent base.\n  //   - If the layout determines that base comes before the derived class,\n  //     the flexible array member would index into the derived class.\n  if (CXXBaseDecl->hasFlexibleArrayMember()) {\n    Diag(BaseLoc, diag::err_base_class_has_flexible_array_member)\n      << CXXBaseDecl->getDeclName();\n    return nullptr;\n  }\n\n  // C++ [class]p3:\n  //   If a class is marked final and it appears as a base-type-specifier in\n  //   base-clause, the program is ill-formed.\n  if (FinalAttr *FA = CXXBaseDecl->getAttr<FinalAttr>()) {\n    Diag(BaseLoc, diag::err_class_marked_final_used_as_base)\n      << CXXBaseDecl->getDeclName()\n      << FA->isSpelledAsSealed();\n    Diag(CXXBaseDecl->getLocation(), diag::note_entity_declared_at)\n        << CXXBaseDecl->getDeclName() << FA->getRange();\n    return nullptr;\n  }\n\n  if (BaseDecl->isInvalidDecl())\n    Class->setInvalidDecl();\n\n  // Create the base specifier.\n  return new (Context) CXXBaseSpecifier(SpecifierRange, Virtual,\n                                        Class->getTagKind() == TTK_Class,\n                                        Access, TInfo, EllipsisLoc);\n}\n\n/// ActOnBaseSpecifier - Parsed a base specifier. A base specifier is\n/// one entry in the base class list of a class specifier, for\n/// example:\n///    class foo : public bar, virtual private baz {\n/// 'public bar' and 'virtual private baz' are each base-specifiers.\nBaseResult\nSema::ActOnBaseSpecifier(Decl *classdecl, SourceRange SpecifierRange,\n                         ParsedAttributes &Attributes,\n                         bool Virtual, AccessSpecifier Access,\n                         ParsedType basetype, SourceLocation BaseLoc,\n                         SourceLocation EllipsisLoc) {\n  if (!classdecl)\n    return true;\n\n  AdjustDeclIfTemplate(classdecl);\n  CXXRecordDecl *Class = dyn_cast<CXXRecordDecl>(classdecl);\n  if (!Class)\n    return true;\n\n  // We haven't yet attached the base specifiers.\n  Class->setIsParsingBaseSpecifiers();\n\n  // We do not support any C++11 attributes on base-specifiers yet.\n  // Diagnose any attributes we see.\n  for (const ParsedAttr &AL : Attributes) {\n    if (AL.isInvalid() || AL.getKind() == ParsedAttr::IgnoredAttribute)\n      continue;\n    Diag(AL.getLoc(), AL.getKind() == ParsedAttr::UnknownAttribute\n                          ? (unsigned)diag::warn_unknown_attribute_ignored\n                          : (unsigned)diag::err_base_specifier_attribute)\n        << AL << AL.getRange();\n  }\n\n  TypeSourceInfo *TInfo = nullptr;\n  GetTypeFromParser(basetype, &TInfo);\n\n  if (EllipsisLoc.isInvalid() &&\n      DiagnoseUnexpandedParameterPack(SpecifierRange.getBegin(), TInfo,\n                                      UPPC_BaseType))\n    return true;\n\n  if (CXXBaseSpecifier *BaseSpec = CheckBaseSpecifier(Class, SpecifierRange,\n                                                      Virtual, Access, TInfo,\n                                                      EllipsisLoc))\n    return BaseSpec;\n  else\n    Class->setInvalidDecl();\n\n  return true;\n}\n\n/// Use small set to collect indirect bases.  As this is only used\n/// locally, there's no need to abstract the small size parameter.\ntypedef llvm::SmallPtrSet<QualType, 4> IndirectBaseSet;\n\n/// Recursively add the bases of Type.  Don't add Type itself.\nstatic void\nNoteIndirectBases(ASTContext &Context, IndirectBaseSet &Set,\n                  const QualType &Type)\n{\n  // Even though the incoming type is a base, it might not be\n  // a class -- it could be a template parm, for instance.\n  if (auto Rec = Type->getAs<RecordType>()) {\n    auto Decl = Rec->getAsCXXRecordDecl();\n\n    // Iterate over its bases.\n    for (const auto &BaseSpec : Decl->bases()) {\n      QualType Base = Context.getCanonicalType(BaseSpec.getType())\n        .getUnqualifiedType();\n      if (Set.insert(Base).second)\n        // If we've not already seen it, recurse.\n        NoteIndirectBases(Context, Set, Base);\n    }\n  }\n}\n\n/// Performs the actual work of attaching the given base class\n/// specifiers to a C++ class.\nbool Sema::AttachBaseSpecifiers(CXXRecordDecl *Class,\n                                MutableArrayRef<CXXBaseSpecifier *> Bases) {\n if (Bases.empty())\n    return false;\n\n  // Used to keep track of which base types we have already seen, so\n  // that we can properly diagnose redundant direct base types. Note\n  // that the key is always the unqualified canonical type of the base\n  // class.\n  std::map<QualType, CXXBaseSpecifier*, QualTypeOrdering> KnownBaseTypes;\n\n  // Used to track indirect bases so we can see if a direct base is\n  // ambiguous.\n  IndirectBaseSet IndirectBaseTypes;\n\n  // Copy non-redundant base specifiers into permanent storage.\n  unsigned NumGoodBases = 0;\n  bool Invalid = false;\n  for (unsigned idx = 0; idx < Bases.size(); ++idx) {\n    QualType NewBaseType\n      = Context.getCanonicalType(Bases[idx]->getType());\n    NewBaseType = NewBaseType.getLocalUnqualifiedType();\n\n    CXXBaseSpecifier *&KnownBase = KnownBaseTypes[NewBaseType];\n    if (KnownBase) {\n      // C++ [class.mi]p3:\n      //   A class shall not be specified as a direct base class of a\n      //   derived class more than once.\n      Diag(Bases[idx]->getBeginLoc(), diag::err_duplicate_base_class)\n          << KnownBase->getType() << Bases[idx]->getSourceRange();\n\n      // Delete the duplicate base class specifier; we're going to\n      // overwrite its pointer later.\n      Context.Deallocate(Bases[idx]);\n\n      Invalid = true;\n    } else {\n      // Okay, add this new base class.\n      KnownBase = Bases[idx];\n      Bases[NumGoodBases++] = Bases[idx];\n\n      // Note this base's direct & indirect bases, if there could be ambiguity.\n      if (Bases.size() > 1)\n        NoteIndirectBases(Context, IndirectBaseTypes, NewBaseType);\n\n      if (const RecordType *Record = NewBaseType->getAs<RecordType>()) {\n        const CXXRecordDecl *RD = cast<CXXRecordDecl>(Record->getDecl());\n        if (Class->isInterface() &&\n              (!RD->isInterfaceLike() ||\n               KnownBase->getAccessSpecifier() != AS_public)) {\n          // The Microsoft extension __interface does not permit bases that\n          // are not themselves public interfaces.\n          Diag(KnownBase->getBeginLoc(), diag::err_invalid_base_in_interface)\n              << getRecordDiagFromTagKind(RD->getTagKind()) << RD\n              << RD->getSourceRange();\n          Invalid = true;\n        }\n        if (RD->hasAttr<WeakAttr>())\n          Class->addAttr(WeakAttr::CreateImplicit(Context));\n      }\n    }\n  }\n\n  // Attach the remaining base class specifiers to the derived class.\n  Class->setBases(Bases.data(), NumGoodBases);\n\n  // Check that the only base classes that are duplicate are virtual.\n  for (unsigned idx = 0; idx < NumGoodBases; ++idx) {\n    // Check whether this direct base is inaccessible due to ambiguity.\n    QualType BaseType = Bases[idx]->getType();\n\n    // Skip all dependent types in templates being used as base specifiers.\n    // Checks below assume that the base specifier is a CXXRecord.\n    if (BaseType->isDependentType())\n      continue;\n\n    CanQualType CanonicalBase = Context.getCanonicalType(BaseType)\n      .getUnqualifiedType();\n\n    if (IndirectBaseTypes.count(CanonicalBase)) {\n      CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                         /*DetectVirtual=*/true);\n      bool found\n        = Class->isDerivedFrom(CanonicalBase->getAsCXXRecordDecl(), Paths);\n      assert(found);\n      (void)found;\n\n      if (Paths.isAmbiguous(CanonicalBase))\n        Diag(Bases[idx]->getBeginLoc(), diag::warn_inaccessible_base_class)\n            << BaseType << getAmbiguousPathsDisplayString(Paths)\n            << Bases[idx]->getSourceRange();\n      else\n        assert(Bases[idx]->isVirtual());\n    }\n\n    // Delete the base class specifier, since its data has been copied\n    // into the CXXRecordDecl.\n    Context.Deallocate(Bases[idx]);\n  }\n\n  return Invalid;\n}\n\n/// ActOnBaseSpecifiers - Attach the given base specifiers to the\n/// class, after checking whether there are any duplicate base\n/// classes.\nvoid Sema::ActOnBaseSpecifiers(Decl *ClassDecl,\n                               MutableArrayRef<CXXBaseSpecifier *> Bases) {\n  if (!ClassDecl || Bases.empty())\n    return;\n\n  AdjustDeclIfTemplate(ClassDecl);\n  AttachBaseSpecifiers(cast<CXXRecordDecl>(ClassDecl), Bases);\n}\n\n/// Determine whether the type \\p Derived is a C++ class that is\n/// derived from the type \\p Base.\nbool Sema::IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base) {\n  if (!getLangOpts().CPlusPlus)\n    return false;\n\n  CXXRecordDecl *DerivedRD = Derived->getAsCXXRecordDecl();\n  if (!DerivedRD)\n    return false;\n\n  CXXRecordDecl *BaseRD = Base->getAsCXXRecordDecl();\n  if (!BaseRD)\n    return false;\n\n  // If either the base or the derived type is invalid, don't try to\n  // check whether one is derived from the other.\n  if (BaseRD->isInvalidDecl() || DerivedRD->isInvalidDecl())\n    return false;\n\n  // FIXME: In a modules build, do we need the entire path to be visible for us\n  // to be able to use the inheritance relationship?\n  if (!isCompleteType(Loc, Derived) && !DerivedRD->isBeingDefined())\n    return false;\n\n  return DerivedRD->isDerivedFrom(BaseRD);\n}\n\n/// Determine whether the type \\p Derived is a C++ class that is\n/// derived from the type \\p Base.\nbool Sema::IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base,\n                         CXXBasePaths &Paths) {\n  if (!getLangOpts().CPlusPlus)\n    return false;\n\n  CXXRecordDecl *DerivedRD = Derived->getAsCXXRecordDecl();\n  if (!DerivedRD)\n    return false;\n\n  CXXRecordDecl *BaseRD = Base->getAsCXXRecordDecl();\n  if (!BaseRD)\n    return false;\n\n  if (!isCompleteType(Loc, Derived) && !DerivedRD->isBeingDefined())\n    return false;\n\n  return DerivedRD->isDerivedFrom(BaseRD, Paths);\n}\n\nstatic void BuildBasePathArray(const CXXBasePath &Path,\n                               CXXCastPath &BasePathArray) {\n  // We first go backward and check if we have a virtual base.\n  // FIXME: It would be better if CXXBasePath had the base specifier for\n  // the nearest virtual base.\n  unsigned Start = 0;\n  for (unsigned I = Path.size(); I != 0; --I) {\n    if (Path[I - 1].Base->isVirtual()) {\n      Start = I - 1;\n      break;\n    }\n  }\n\n  // Now add all bases.\n  for (unsigned I = Start, E = Path.size(); I != E; ++I)\n    BasePathArray.push_back(const_cast<CXXBaseSpecifier*>(Path[I].Base));\n}\n\n\nvoid Sema::BuildBasePathArray(const CXXBasePaths &Paths,\n                              CXXCastPath &BasePathArray) {\n  assert(BasePathArray.empty() && \"Base path array must be empty!\");\n  assert(Paths.isRecordingPaths() && \"Must record paths!\");\n  return ::BuildBasePathArray(Paths.front(), BasePathArray);\n}\n/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base\n/// conversion (where Derived and Base are class types) is\n/// well-formed, meaning that the conversion is unambiguous (and\n/// that all of the base classes are accessible). Returns true\n/// and emits a diagnostic if the code is ill-formed, returns false\n/// otherwise. Loc is the location where this routine should point to\n/// if there is an error, and Range is the source range to highlight\n/// if there is an error.\n///\n/// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the\n/// diagnostic for the respective type of error will be suppressed, but the\n/// check for ill-formed code will still be performed.\nbool\nSema::CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                   unsigned InaccessibleBaseID,\n                                   unsigned AmbiguousBaseConvID,\n                                   SourceLocation Loc, SourceRange Range,\n                                   DeclarationName Name,\n                                   CXXCastPath *BasePath,\n                                   bool IgnoreAccess) {\n  // First, determine whether the path from Derived to Base is\n  // ambiguous. This is slightly more expensive than checking whether\n  // the Derived to Base conversion exists, because here we need to\n  // explore multiple paths to determine if there is an ambiguity.\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                     /*DetectVirtual=*/false);\n  bool DerivationOkay = IsDerivedFrom(Loc, Derived, Base, Paths);\n  if (!DerivationOkay)\n    return true;\n\n  const CXXBasePath *Path = nullptr;\n  if (!Paths.isAmbiguous(Context.getCanonicalType(Base).getUnqualifiedType()))\n    Path = &Paths.front();\n\n  // For MSVC compatibility, check if Derived directly inherits from Base. Clang\n  // warns about this hierarchy under -Winaccessible-base, but MSVC allows the\n  // user to access such bases.\n  if (!Path && getLangOpts().MSVCCompat) {\n    for (const CXXBasePath &PossiblePath : Paths) {\n      if (PossiblePath.size() == 1) {\n        Path = &PossiblePath;\n        if (AmbiguousBaseConvID)\n          Diag(Loc, diag::ext_ms_ambiguous_direct_base)\n              << Base << Derived << Range;\n        break;\n      }\n    }\n  }\n\n  if (Path) {\n    if (!IgnoreAccess) {\n      // Check that the base class can be accessed.\n      switch (\n          CheckBaseClassAccess(Loc, Base, Derived, *Path, InaccessibleBaseID)) {\n      case AR_inaccessible:\n        return true;\n      case AR_accessible:\n      case AR_dependent:\n      case AR_delayed:\n        break;\n      }\n    }\n\n    // Build a base path if necessary.\n    if (BasePath)\n      ::BuildBasePathArray(*Path, *BasePath);\n    return false;\n  }\n\n  if (AmbiguousBaseConvID) {\n    // We know that the derived-to-base conversion is ambiguous, and\n    // we're going to produce a diagnostic. Perform the derived-to-base\n    // search just one more time to compute all of the possible paths so\n    // that we can print them out. This is more expensive than any of\n    // the previous derived-to-base checks we've done, but at this point\n    // performance isn't as much of an issue.\n    Paths.clear();\n    Paths.setRecordingPaths(true);\n    bool StillOkay = IsDerivedFrom(Loc, Derived, Base, Paths);\n    assert(StillOkay && \"Can only be used with a derived-to-base conversion\");\n    (void)StillOkay;\n\n    // Build up a textual representation of the ambiguous paths, e.g.,\n    // D -> B -> A, that will be used to illustrate the ambiguous\n    // conversions in the diagnostic. We only print one of the paths\n    // to each base class subobject.\n    std::string PathDisplayStr = getAmbiguousPathsDisplayString(Paths);\n\n    Diag(Loc, AmbiguousBaseConvID)\n    << Derived << Base << PathDisplayStr << Range << Name;\n  }\n  return true;\n}\n\nbool\nSema::CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                   SourceLocation Loc, SourceRange Range,\n                                   CXXCastPath *BasePath,\n                                   bool IgnoreAccess) {\n  return CheckDerivedToBaseConversion(\n      Derived, Base, diag::err_upcast_to_inaccessible_base,\n      diag::err_ambiguous_derived_to_base_conv, Loc, Range, DeclarationName(),\n      BasePath, IgnoreAccess);\n}\n\n\n/// Builds a string representing ambiguous paths from a\n/// specific derived class to different subobjects of the same base\n/// class.\n///\n/// This function builds a string that can be used in error messages\n/// to show the different paths that one can take through the\n/// inheritance hierarchy to go from the derived class to different\n/// subobjects of a base class. The result looks something like this:\n/// @code\n/// struct D -> struct B -> struct A\n/// struct D -> struct C -> struct A\n/// @endcode\nstd::string Sema::getAmbiguousPathsDisplayString(CXXBasePaths &Paths) {\n  std::string PathDisplayStr;\n  std::set<unsigned> DisplayedPaths;\n  for (CXXBasePaths::paths_iterator Path = Paths.begin();\n       Path != Paths.end(); ++Path) {\n    if (DisplayedPaths.insert(Path->back().SubobjectNumber).second) {\n      // We haven't displayed a path to this particular base\n      // class subobject yet.\n      PathDisplayStr += \"\\n    \";\n      PathDisplayStr += Context.getTypeDeclType(Paths.getOrigin()).getAsString();\n      for (CXXBasePath::const_iterator Element = Path->begin();\n           Element != Path->end(); ++Element)\n        PathDisplayStr += \" -> \" + Element->Base->getType().getAsString();\n    }\n  }\n\n  return PathDisplayStr;\n}\n\n//===----------------------------------------------------------------------===//\n// C++ class member Handling\n//===----------------------------------------------------------------------===//\n\n/// ActOnAccessSpecifier - Parsed an access specifier followed by a colon.\nbool Sema::ActOnAccessSpecifier(AccessSpecifier Access, SourceLocation ASLoc,\n                                SourceLocation ColonLoc,\n                                const ParsedAttributesView &Attrs) {\n  assert(Access != AS_none && \"Invalid kind for syntactic access specifier!\");\n  AccessSpecDecl *ASDecl = AccessSpecDecl::Create(Context, Access, CurContext,\n                                                  ASLoc, ColonLoc);\n  CurContext->addHiddenDecl(ASDecl);\n  return ProcessAccessDeclAttributeList(ASDecl, Attrs);\n}\n\n/// CheckOverrideControl - Check C++11 override control semantics.\nvoid Sema::CheckOverrideControl(NamedDecl *D) {\n  if (D->isInvalidDecl())\n    return;\n\n  // We only care about \"override\" and \"final\" declarations.\n  if (!D->hasAttr<OverrideAttr>() && !D->hasAttr<FinalAttr>())\n    return;\n\n  CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(D);\n\n  // We can't check dependent instance methods.\n  if (MD && MD->isInstance() &&\n      (MD->getParent()->hasAnyDependentBases() ||\n       MD->getType()->isDependentType()))\n    return;\n\n  if (MD && !MD->isVirtual()) {\n    // If we have a non-virtual method, check if if hides a virtual method.\n    // (In that case, it's most likely the method has the wrong type.)\n    SmallVector<CXXMethodDecl *, 8> OverloadedMethods;\n    FindHiddenVirtualMethods(MD, OverloadedMethods);\n\n    if (!OverloadedMethods.empty()) {\n      if (OverrideAttr *OA = D->getAttr<OverrideAttr>()) {\n        Diag(OA->getLocation(),\n             diag::override_keyword_hides_virtual_member_function)\n          << \"override\" << (OverloadedMethods.size() > 1);\n      } else if (FinalAttr *FA = D->getAttr<FinalAttr>()) {\n        Diag(FA->getLocation(),\n             diag::override_keyword_hides_virtual_member_function)\n          << (FA->isSpelledAsSealed() ? \"sealed\" : \"final\")\n          << (OverloadedMethods.size() > 1);\n      }\n      NoteHiddenVirtualMethods(MD, OverloadedMethods);\n      MD->setInvalidDecl();\n      return;\n    }\n    // Fall through into the general case diagnostic.\n    // FIXME: We might want to attempt typo correction here.\n  }\n\n  if (!MD || !MD->isVirtual()) {\n    if (OverrideAttr *OA = D->getAttr<OverrideAttr>()) {\n      Diag(OA->getLocation(),\n           diag::override_keyword_only_allowed_on_virtual_member_functions)\n        << \"override\" << FixItHint::CreateRemoval(OA->getLocation());\n      D->dropAttr<OverrideAttr>();\n    }\n    if (FinalAttr *FA = D->getAttr<FinalAttr>()) {\n      Diag(FA->getLocation(),\n           diag::override_keyword_only_allowed_on_virtual_member_functions)\n        << (FA->isSpelledAsSealed() ? \"sealed\" : \"final\")\n        << FixItHint::CreateRemoval(FA->getLocation());\n      D->dropAttr<FinalAttr>();\n    }\n    return;\n  }\n\n  // C++11 [class.virtual]p5:\n  //   If a function is marked with the virt-specifier override and\n  //   does not override a member function of a base class, the program is\n  //   ill-formed.\n  bool HasOverriddenMethods = MD->size_overridden_methods() != 0;\n  if (MD->hasAttr<OverrideAttr>() && !HasOverriddenMethods)\n    Diag(MD->getLocation(), diag::err_function_marked_override_not_overriding)\n      << MD->getDeclName();\n}\n\nvoid Sema::DiagnoseAbsenceOfOverrideControl(NamedDecl *D, bool Inconsistent) {\n  if (D->isInvalidDecl() || D->hasAttr<OverrideAttr>())\n    return;\n  CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(D);\n  if (!MD || MD->isImplicit() || MD->hasAttr<FinalAttr>())\n    return;\n\n  SourceLocation Loc = MD->getLocation();\n  SourceLocation SpellingLoc = Loc;\n  if (getSourceManager().isMacroArgExpansion(Loc))\n    SpellingLoc = getSourceManager().getImmediateExpansionRange(Loc).getBegin();\n  SpellingLoc = getSourceManager().getSpellingLoc(SpellingLoc);\n  if (SpellingLoc.isValid() && getSourceManager().isInSystemHeader(SpellingLoc))\n      return;\n\n  if (MD->size_overridden_methods() > 0) {\n    auto EmitDiag = [&](unsigned DiagInconsistent, unsigned DiagSuggest) {\n      unsigned DiagID =\n          Inconsistent && !Diags.isIgnored(DiagInconsistent, MD->getLocation())\n              ? DiagInconsistent\n              : DiagSuggest;\n      Diag(MD->getLocation(), DiagID) << MD->getDeclName();\n      const CXXMethodDecl *OMD = *MD->begin_overridden_methods();\n      Diag(OMD->getLocation(), diag::note_overridden_virtual_function);\n    };\n    if (isa<CXXDestructorDecl>(MD))\n      EmitDiag(\n          diag::warn_inconsistent_destructor_marked_not_override_overriding,\n          diag::warn_suggest_destructor_marked_not_override_overriding);\n    else\n      EmitDiag(diag::warn_inconsistent_function_marked_not_override_overriding,\n               diag::warn_suggest_function_marked_not_override_overriding);\n  }\n}\n\n/// CheckIfOverriddenFunctionIsMarkedFinal - Checks whether a virtual member\n/// function overrides a virtual member function marked 'final', according to\n/// C++11 [class.virtual]p4.\nbool Sema::CheckIfOverriddenFunctionIsMarkedFinal(const CXXMethodDecl *New,\n                                                  const CXXMethodDecl *Old) {\n  FinalAttr *FA = Old->getAttr<FinalAttr>();\n  if (!FA)\n    return false;\n\n  Diag(New->getLocation(), diag::err_final_function_overridden)\n    << New->getDeclName()\n    << FA->isSpelledAsSealed();\n  Diag(Old->getLocation(), diag::note_overridden_virtual_function);\n  return true;\n}\n\nstatic bool InitializationHasSideEffects(const FieldDecl &FD) {\n  const Type *T = FD.getType()->getBaseElementTypeUnsafe();\n  // FIXME: Destruction of ObjC lifetime types has side-effects.\n  if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n    return !RD->isCompleteDefinition() ||\n           !RD->hasTrivialDefaultConstructor() ||\n           !RD->hasTrivialDestructor();\n  return false;\n}\n\nstatic const ParsedAttr *getMSPropertyAttr(const ParsedAttributesView &list) {\n  ParsedAttributesView::const_iterator Itr =\n      llvm::find_if(list, [](const ParsedAttr &AL) {\n        return AL.isDeclspecPropertyAttribute();\n      });\n  if (Itr != list.end())\n    return &*Itr;\n  return nullptr;\n}\n\n// Check if there is a field shadowing.\nvoid Sema::CheckShadowInheritedFields(const SourceLocation &Loc,\n                                      DeclarationName FieldName,\n                                      const CXXRecordDecl *RD,\n                                      bool DeclIsField) {\n  if (Diags.isIgnored(diag::warn_shadow_field, Loc))\n    return;\n\n  // To record a shadowed field in a base\n  std::map<CXXRecordDecl*, NamedDecl*> Bases;\n  auto FieldShadowed = [&](const CXXBaseSpecifier *Specifier,\n                           CXXBasePath &Path) {\n    const auto Base = Specifier->getType()->getAsCXXRecordDecl();\n    // Record an ambiguous path directly\n    if (Bases.find(Base) != Bases.end())\n      return true;\n    for (const auto Field : Base->lookup(FieldName)) {\n      if ((isa<FieldDecl>(Field) || isa<IndirectFieldDecl>(Field)) &&\n          Field->getAccess() != AS_private) {\n        assert(Field->getAccess() != AS_none);\n        assert(Bases.find(Base) == Bases.end());\n        Bases[Base] = Field;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                     /*DetectVirtual=*/true);\n  if (!RD->lookupInBases(FieldShadowed, Paths))\n    return;\n\n  for (const auto &P : Paths) {\n    auto Base = P.back().Base->getType()->getAsCXXRecordDecl();\n    auto It = Bases.find(Base);\n    // Skip duplicated bases\n    if (It == Bases.end())\n      continue;\n    auto BaseField = It->second;\n    assert(BaseField->getAccess() != AS_private);\n    if (AS_none !=\n        CXXRecordDecl::MergeAccess(P.Access, BaseField->getAccess())) {\n      Diag(Loc, diag::warn_shadow_field)\n        << FieldName << RD << Base << DeclIsField;\n      Diag(BaseField->getLocation(), diag::note_shadow_field);\n      Bases.erase(It);\n    }\n  }\n}\n\n/// ActOnCXXMemberDeclarator - This is invoked when a C++ class member\n/// declarator is parsed. 'AS' is the access specifier, 'BW' specifies the\n/// bitfield width if there is one, 'InitExpr' specifies the initializer if\n/// one has been parsed, and 'InitStyle' is set if an in-class initializer is\n/// present (but parsing it has been deferred).\nNamedDecl *\nSema::ActOnCXXMemberDeclarator(Scope *S, AccessSpecifier AS, Declarator &D,\n                               MultiTemplateParamsArg TemplateParameterLists,\n                               Expr *BW, const VirtSpecifiers &VS,\n                               InClassInitStyle InitStyle) {\n  const DeclSpec &DS = D.getDeclSpec();\n  DeclarationNameInfo NameInfo = GetNameForDeclarator(D);\n  DeclarationName Name = NameInfo.getName();\n  SourceLocation Loc = NameInfo.getLoc();\n\n  // For anonymous bitfields, the location should point to the type.\n  if (Loc.isInvalid())\n    Loc = D.getBeginLoc();\n\n  Expr *BitWidth = static_cast<Expr*>(BW);\n\n  assert(isa<CXXRecordDecl>(CurContext));\n  assert(!DS.isFriendSpecified());\n\n  bool isFunc = D.isDeclarationOfFunction();\n  const ParsedAttr *MSPropertyAttr =\n      getMSPropertyAttr(D.getDeclSpec().getAttributes());\n\n  if (cast<CXXRecordDecl>(CurContext)->isInterface()) {\n    // The Microsoft extension __interface only permits public member functions\n    // and prohibits constructors, destructors, operators, non-public member\n    // functions, static methods and data members.\n    unsigned InvalidDecl;\n    bool ShowDeclName = true;\n    if (!isFunc &&\n        (DS.getStorageClassSpec() == DeclSpec::SCS_typedef || MSPropertyAttr))\n      InvalidDecl = 0;\n    else if (!isFunc)\n      InvalidDecl = 1;\n    else if (AS != AS_public)\n      InvalidDecl = 2;\n    else if (DS.getStorageClassSpec() == DeclSpec::SCS_static)\n      InvalidDecl = 3;\n    else switch (Name.getNameKind()) {\n      case DeclarationName::CXXConstructorName:\n        InvalidDecl = 4;\n        ShowDeclName = false;\n        break;\n\n      case DeclarationName::CXXDestructorName:\n        InvalidDecl = 5;\n        ShowDeclName = false;\n        break;\n\n      case DeclarationName::CXXOperatorName:\n      case DeclarationName::CXXConversionFunctionName:\n        InvalidDecl = 6;\n        break;\n\n      default:\n        InvalidDecl = 0;\n        break;\n    }\n\n    if (InvalidDecl) {\n      if (ShowDeclName)\n        Diag(Loc, diag::err_invalid_member_in_interface)\n          << (InvalidDecl-1) << Name;\n      else\n        Diag(Loc, diag::err_invalid_member_in_interface)\n          << (InvalidDecl-1) << \"\";\n      return nullptr;\n    }\n  }\n\n  // C++ 9.2p6: A member shall not be declared to have automatic storage\n  // duration (auto, register) or with the extern storage-class-specifier.\n  // C++ 7.1.1p8: The mutable specifier can be applied only to names of class\n  // data members and cannot be applied to names declared const or static,\n  // and cannot be applied to reference members.\n  switch (DS.getStorageClassSpec()) {\n  case DeclSpec::SCS_unspecified:\n  case DeclSpec::SCS_typedef:\n  case DeclSpec::SCS_static:\n    break;\n  case DeclSpec::SCS_mutable:\n    if (isFunc) {\n      Diag(DS.getStorageClassSpecLoc(), diag::err_mutable_function);\n\n      // FIXME: It would be nicer if the keyword was ignored only for this\n      // declarator. Otherwise we could get follow-up errors.\n      D.getMutableDeclSpec().ClearStorageClassSpecs();\n    }\n    break;\n  default:\n    Diag(DS.getStorageClassSpecLoc(),\n         diag::err_storageclass_invalid_for_member);\n    D.getMutableDeclSpec().ClearStorageClassSpecs();\n    break;\n  }\n\n  bool isInstField = ((DS.getStorageClassSpec() == DeclSpec::SCS_unspecified ||\n                       DS.getStorageClassSpec() == DeclSpec::SCS_mutable) &&\n                      !isFunc);\n\n  if (DS.hasConstexprSpecifier() && isInstField) {\n    SemaDiagnosticBuilder B =\n        Diag(DS.getConstexprSpecLoc(), diag::err_invalid_constexpr_member);\n    SourceLocation ConstexprLoc = DS.getConstexprSpecLoc();\n    if (InitStyle == ICIS_NoInit) {\n      B << 0 << 0;\n      if (D.getDeclSpec().getTypeQualifiers() & DeclSpec::TQ_const)\n        B << FixItHint::CreateRemoval(ConstexprLoc);\n      else {\n        B << FixItHint::CreateReplacement(ConstexprLoc, \"const\");\n        D.getMutableDeclSpec().ClearConstexprSpec();\n        const char *PrevSpec;\n        unsigned DiagID;\n        bool Failed = D.getMutableDeclSpec().SetTypeQual(\n            DeclSpec::TQ_const, ConstexprLoc, PrevSpec, DiagID, getLangOpts());\n        (void)Failed;\n        assert(!Failed && \"Making a constexpr member const shouldn't fail\");\n      }\n    } else {\n      B << 1;\n      const char *PrevSpec;\n      unsigned DiagID;\n      if (D.getMutableDeclSpec().SetStorageClassSpec(\n          *this, DeclSpec::SCS_static, ConstexprLoc, PrevSpec, DiagID,\n          Context.getPrintingPolicy())) {\n        assert(DS.getStorageClassSpec() == DeclSpec::SCS_mutable &&\n               \"This is the only DeclSpec that should fail to be applied\");\n        B << 1;\n      } else {\n        B << 0 << FixItHint::CreateInsertion(ConstexprLoc, \"static \");\n        isInstField = false;\n      }\n    }\n  }\n\n  NamedDecl *Member;\n  if (isInstField) {\n    CXXScopeSpec &SS = D.getCXXScopeSpec();\n\n    // Data members must have identifiers for names.\n    if (!Name.isIdentifier()) {\n      Diag(Loc, diag::err_bad_variable_name)\n        << Name;\n      return nullptr;\n    }\n\n    IdentifierInfo *II = Name.getAsIdentifierInfo();\n\n    // Member field could not be with \"template\" keyword.\n    // So TemplateParameterLists should be empty in this case.\n    if (TemplateParameterLists.size()) {\n      TemplateParameterList* TemplateParams = TemplateParameterLists[0];\n      if (TemplateParams->size()) {\n        // There is no such thing as a member field template.\n        Diag(D.getIdentifierLoc(), diag::err_template_member)\n            << II\n            << SourceRange(TemplateParams->getTemplateLoc(),\n                TemplateParams->getRAngleLoc());\n      } else {\n        // There is an extraneous 'template<>' for this member.\n        Diag(TemplateParams->getTemplateLoc(),\n            diag::err_template_member_noparams)\n            << II\n            << SourceRange(TemplateParams->getTemplateLoc(),\n                TemplateParams->getRAngleLoc());\n      }\n      return nullptr;\n    }\n\n    if (SS.isSet() && !SS.isInvalid()) {\n      // The user provided a superfluous scope specifier inside a class\n      // definition:\n      //\n      // class X {\n      //   int X::member;\n      // };\n      if (DeclContext *DC = computeDeclContext(SS, false))\n        diagnoseQualifiedDeclaration(SS, DC, Name, D.getIdentifierLoc(),\n                                     D.getName().getKind() ==\n                                         UnqualifiedIdKind::IK_TemplateId);\n      else\n        Diag(D.getIdentifierLoc(), diag::err_member_qualification)\n          << Name << SS.getRange();\n\n      SS.clear();\n    }\n\n    if (MSPropertyAttr) {\n      Member = HandleMSProperty(S, cast<CXXRecordDecl>(CurContext), Loc, D,\n                                BitWidth, InitStyle, AS, *MSPropertyAttr);\n      if (!Member)\n        return nullptr;\n      isInstField = false;\n    } else {\n      Member = HandleField(S, cast<CXXRecordDecl>(CurContext), Loc, D,\n                                BitWidth, InitStyle, AS);\n      if (!Member)\n        return nullptr;\n    }\n\n    CheckShadowInheritedFields(Loc, Name, cast<CXXRecordDecl>(CurContext));\n  } else {\n    Member = HandleDeclarator(S, D, TemplateParameterLists);\n    if (!Member)\n      return nullptr;\n\n    // Non-instance-fields can't have a bitfield.\n    if (BitWidth) {\n      if (Member->isInvalidDecl()) {\n        // don't emit another diagnostic.\n      } else if (isa<VarDecl>(Member) || isa<VarTemplateDecl>(Member)) {\n        // C++ 9.6p3: A bit-field shall not be a static member.\n        // \"static member 'A' cannot be a bit-field\"\n        Diag(Loc, diag::err_static_not_bitfield)\n          << Name << BitWidth->getSourceRange();\n      } else if (isa<TypedefDecl>(Member)) {\n        // \"typedef member 'x' cannot be a bit-field\"\n        Diag(Loc, diag::err_typedef_not_bitfield)\n          << Name << BitWidth->getSourceRange();\n      } else {\n        // A function typedef (\"typedef int f(); f a;\").\n        // C++ 9.6p3: A bit-field shall have integral or enumeration type.\n        Diag(Loc, diag::err_not_integral_type_bitfield)\n          << Name << cast<ValueDecl>(Member)->getType()\n          << BitWidth->getSourceRange();\n      }\n\n      BitWidth = nullptr;\n      Member->setInvalidDecl();\n    }\n\n    NamedDecl *NonTemplateMember = Member;\n    if (FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(Member))\n      NonTemplateMember = FunTmpl->getTemplatedDecl();\n    else if (VarTemplateDecl *VarTmpl = dyn_cast<VarTemplateDecl>(Member))\n      NonTemplateMember = VarTmpl->getTemplatedDecl();\n\n    Member->setAccess(AS);\n\n    // If we have declared a member function template or static data member\n    // template, set the access of the templated declaration as well.\n    if (NonTemplateMember != Member)\n      NonTemplateMember->setAccess(AS);\n\n    // C++ [temp.deduct.guide]p3:\n    //   A deduction guide [...] for a member class template [shall be\n    //   declared] with the same access [as the template].\n    if (auto *DG = dyn_cast<CXXDeductionGuideDecl>(NonTemplateMember)) {\n      auto *TD = DG->getDeducedTemplate();\n      // Access specifiers are only meaningful if both the template and the\n      // deduction guide are from the same scope.\n      if (AS != TD->getAccess() &&\n          TD->getDeclContext()->getRedeclContext()->Equals(\n              DG->getDeclContext()->getRedeclContext())) {\n        Diag(DG->getBeginLoc(), diag::err_deduction_guide_wrong_access);\n        Diag(TD->getBeginLoc(), diag::note_deduction_guide_template_access)\n            << TD->getAccess();\n        const AccessSpecDecl *LastAccessSpec = nullptr;\n        for (const auto *D : cast<CXXRecordDecl>(CurContext)->decls()) {\n          if (const auto *AccessSpec = dyn_cast<AccessSpecDecl>(D))\n            LastAccessSpec = AccessSpec;\n        }\n        assert(LastAccessSpec && \"differing access with no access specifier\");\n        Diag(LastAccessSpec->getBeginLoc(), diag::note_deduction_guide_access)\n            << AS;\n      }\n    }\n  }\n\n  if (VS.isOverrideSpecified())\n    Member->addAttr(OverrideAttr::Create(Context, VS.getOverrideLoc(),\n                                         AttributeCommonInfo::AS_Keyword));\n  if (VS.isFinalSpecified())\n    Member->addAttr(FinalAttr::Create(\n        Context, VS.getFinalLoc(), AttributeCommonInfo::AS_Keyword,\n        static_cast<FinalAttr::Spelling>(VS.isFinalSpelledSealed())));\n\n  if (VS.getLastLocation().isValid()) {\n    // Update the end location of a method that has a virt-specifiers.\n    if (CXXMethodDecl *MD = dyn_cast_or_null<CXXMethodDecl>(Member))\n      MD->setRangeEnd(VS.getLastLocation());\n  }\n\n  CheckOverrideControl(Member);\n\n  assert((Name || isInstField) && \"No identifier for non-field ?\");\n\n  if (isInstField) {\n    FieldDecl *FD = cast<FieldDecl>(Member);\n    FieldCollector->Add(FD);\n\n    if (!Diags.isIgnored(diag::warn_unused_private_field, FD->getLocation())) {\n      // Remember all explicit private FieldDecls that have a name, no side\n      // effects and are not part of a dependent type declaration.\n      if (!FD->isImplicit() && FD->getDeclName() &&\n          FD->getAccess() == AS_private &&\n          !FD->hasAttr<UnusedAttr>() &&\n          !FD->getParent()->isDependentContext() &&\n          !InitializationHasSideEffects(*FD))\n        UnusedPrivateFields.insert(FD);\n    }\n  }\n\n  return Member;\n}\n\nnamespace {\n  class UninitializedFieldVisitor\n      : public EvaluatedExprVisitor<UninitializedFieldVisitor> {\n    Sema &S;\n    // List of Decls to generate a warning on.  Also remove Decls that become\n    // initialized.\n    llvm::SmallPtrSetImpl<ValueDecl*> &Decls;\n    // List of base classes of the record.  Classes are removed after their\n    // initializers.\n    llvm::SmallPtrSetImpl<QualType> &BaseClasses;\n    // Vector of decls to be removed from the Decl set prior to visiting the\n    // nodes.  These Decls may have been initialized in the prior initializer.\n    llvm::SmallVector<ValueDecl*, 4> DeclsToRemove;\n    // If non-null, add a note to the warning pointing back to the constructor.\n    const CXXConstructorDecl *Constructor;\n    // Variables to hold state when processing an initializer list.  When\n    // InitList is true, special case initialization of FieldDecls matching\n    // InitListFieldDecl.\n    bool InitList;\n    FieldDecl *InitListFieldDecl;\n    llvm::SmallVector<unsigned, 4> InitFieldIndex;\n\n  public:\n    typedef EvaluatedExprVisitor<UninitializedFieldVisitor> Inherited;\n    UninitializedFieldVisitor(Sema &S,\n                              llvm::SmallPtrSetImpl<ValueDecl*> &Decls,\n                              llvm::SmallPtrSetImpl<QualType> &BaseClasses)\n      : Inherited(S.Context), S(S), Decls(Decls), BaseClasses(BaseClasses),\n        Constructor(nullptr), InitList(false), InitListFieldDecl(nullptr) {}\n\n    // Returns true if the use of ME is not an uninitialized use.\n    bool IsInitListMemberExprInitialized(MemberExpr *ME,\n                                         bool CheckReferenceOnly) {\n      llvm::SmallVector<FieldDecl*, 4> Fields;\n      bool ReferenceField = false;\n      while (ME) {\n        FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n        if (!FD)\n          return false;\n        Fields.push_back(FD);\n        if (FD->getType()->isReferenceType())\n          ReferenceField = true;\n        ME = dyn_cast<MemberExpr>(ME->getBase()->IgnoreParenImpCasts());\n      }\n\n      // Binding a reference to an uninitialized field is not an\n      // uninitialized use.\n      if (CheckReferenceOnly && !ReferenceField)\n        return true;\n\n      llvm::SmallVector<unsigned, 4> UsedFieldIndex;\n      // Discard the first field since it is the field decl that is being\n      // initialized.\n      for (auto I = Fields.rbegin() + 1, E = Fields.rend(); I != E; ++I) {\n        UsedFieldIndex.push_back((*I)->getFieldIndex());\n      }\n\n      for (auto UsedIter = UsedFieldIndex.begin(),\n                UsedEnd = UsedFieldIndex.end(),\n                OrigIter = InitFieldIndex.begin(),\n                OrigEnd = InitFieldIndex.end();\n           UsedIter != UsedEnd && OrigIter != OrigEnd; ++UsedIter, ++OrigIter) {\n        if (*UsedIter < *OrigIter)\n          return true;\n        if (*UsedIter > *OrigIter)\n          break;\n      }\n\n      return false;\n    }\n\n    void HandleMemberExpr(MemberExpr *ME, bool CheckReferenceOnly,\n                          bool AddressOf) {\n      if (isa<EnumConstantDecl>(ME->getMemberDecl()))\n        return;\n\n      // FieldME is the inner-most MemberExpr that is not an anonymous struct\n      // or union.\n      MemberExpr *FieldME = ME;\n\n      bool AllPODFields = FieldME->getType().isPODType(S.Context);\n\n      Expr *Base = ME;\n      while (MemberExpr *SubME =\n                 dyn_cast<MemberExpr>(Base->IgnoreParenImpCasts())) {\n\n        if (isa<VarDecl>(SubME->getMemberDecl()))\n          return;\n\n        if (FieldDecl *FD = dyn_cast<FieldDecl>(SubME->getMemberDecl()))\n          if (!FD->isAnonymousStructOrUnion())\n            FieldME = SubME;\n\n        if (!FieldME->getType().isPODType(S.Context))\n          AllPODFields = false;\n\n        Base = SubME->getBase();\n      }\n\n      if (!isa<CXXThisExpr>(Base->IgnoreParenImpCasts())) {\n        Visit(Base);\n        return;\n      }\n\n      if (AddressOf && AllPODFields)\n        return;\n\n      ValueDecl* FoundVD = FieldME->getMemberDecl();\n\n      if (ImplicitCastExpr *BaseCast = dyn_cast<ImplicitCastExpr>(Base)) {\n        while (isa<ImplicitCastExpr>(BaseCast->getSubExpr())) {\n          BaseCast = cast<ImplicitCastExpr>(BaseCast->getSubExpr());\n        }\n\n        if (BaseCast->getCastKind() == CK_UncheckedDerivedToBase) {\n          QualType T = BaseCast->getType();\n          if (T->isPointerType() &&\n              BaseClasses.count(T->getPointeeType())) {\n            S.Diag(FieldME->getExprLoc(), diag::warn_base_class_is_uninit)\n                << T->getPointeeType() << FoundVD;\n          }\n        }\n      }\n\n      if (!Decls.count(FoundVD))\n        return;\n\n      const bool IsReference = FoundVD->getType()->isReferenceType();\n\n      if (InitList && !AddressOf && FoundVD == InitListFieldDecl) {\n        // Special checking for initializer lists.\n        if (IsInitListMemberExprInitialized(ME, CheckReferenceOnly)) {\n          return;\n        }\n      } else {\n        // Prevent double warnings on use of unbounded references.\n        if (CheckReferenceOnly && !IsReference)\n          return;\n      }\n\n      unsigned diag = IsReference\n          ? diag::warn_reference_field_is_uninit\n          : diag::warn_field_is_uninit;\n      S.Diag(FieldME->getExprLoc(), diag) << FoundVD;\n      if (Constructor)\n        S.Diag(Constructor->getLocation(),\n               diag::note_uninit_in_this_constructor)\n          << (Constructor->isDefaultConstructor() && Constructor->isImplicit());\n\n    }\n\n    void HandleValue(Expr *E, bool AddressOf) {\n      E = E->IgnoreParens();\n\n      if (MemberExpr *ME = dyn_cast<MemberExpr>(E)) {\n        HandleMemberExpr(ME, false /*CheckReferenceOnly*/,\n                         AddressOf /*AddressOf*/);\n        return;\n      }\n\n      if (ConditionalOperator *CO = dyn_cast<ConditionalOperator>(E)) {\n        Visit(CO->getCond());\n        HandleValue(CO->getTrueExpr(), AddressOf);\n        HandleValue(CO->getFalseExpr(), AddressOf);\n        return;\n      }\n\n      if (BinaryConditionalOperator *BCO =\n              dyn_cast<BinaryConditionalOperator>(E)) {\n        Visit(BCO->getCond());\n        HandleValue(BCO->getFalseExpr(), AddressOf);\n        return;\n      }\n\n      if (OpaqueValueExpr *OVE = dyn_cast<OpaqueValueExpr>(E)) {\n        HandleValue(OVE->getSourceExpr(), AddressOf);\n        return;\n      }\n\n      if (BinaryOperator *BO = dyn_cast<BinaryOperator>(E)) {\n        switch (BO->getOpcode()) {\n        default:\n          break;\n        case(BO_PtrMemD):\n        case(BO_PtrMemI):\n          HandleValue(BO->getLHS(), AddressOf);\n          Visit(BO->getRHS());\n          return;\n        case(BO_Comma):\n          Visit(BO->getLHS());\n          HandleValue(BO->getRHS(), AddressOf);\n          return;\n        }\n      }\n\n      Visit(E);\n    }\n\n    void CheckInitListExpr(InitListExpr *ILE) {\n      InitFieldIndex.push_back(0);\n      for (auto Child : ILE->children()) {\n        if (InitListExpr *SubList = dyn_cast<InitListExpr>(Child)) {\n          CheckInitListExpr(SubList);\n        } else {\n          Visit(Child);\n        }\n        ++InitFieldIndex.back();\n      }\n      InitFieldIndex.pop_back();\n    }\n\n    void CheckInitializer(Expr *E, const CXXConstructorDecl *FieldConstructor,\n                          FieldDecl *Field, const Type *BaseClass) {\n      // Remove Decls that may have been initialized in the previous\n      // initializer.\n      for (ValueDecl* VD : DeclsToRemove)\n        Decls.erase(VD);\n      DeclsToRemove.clear();\n\n      Constructor = FieldConstructor;\n      InitListExpr *ILE = dyn_cast<InitListExpr>(E);\n\n      if (ILE && Field) {\n        InitList = true;\n        InitListFieldDecl = Field;\n        InitFieldIndex.clear();\n        CheckInitListExpr(ILE);\n      } else {\n        InitList = false;\n        Visit(E);\n      }\n\n      if (Field)\n        Decls.erase(Field);\n      if (BaseClass)\n        BaseClasses.erase(BaseClass->getCanonicalTypeInternal());\n    }\n\n    void VisitMemberExpr(MemberExpr *ME) {\n      // All uses of unbounded reference fields will warn.\n      HandleMemberExpr(ME, true /*CheckReferenceOnly*/, false /*AddressOf*/);\n    }\n\n    void VisitImplicitCastExpr(ImplicitCastExpr *E) {\n      if (E->getCastKind() == CK_LValueToRValue) {\n        HandleValue(E->getSubExpr(), false /*AddressOf*/);\n        return;\n      }\n\n      Inherited::VisitImplicitCastExpr(E);\n    }\n\n    void VisitCXXConstructExpr(CXXConstructExpr *E) {\n      if (E->getConstructor()->isCopyConstructor()) {\n        Expr *ArgExpr = E->getArg(0);\n        if (InitListExpr *ILE = dyn_cast<InitListExpr>(ArgExpr))\n          if (ILE->getNumInits() == 1)\n            ArgExpr = ILE->getInit(0);\n        if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(ArgExpr))\n          if (ICE->getCastKind() == CK_NoOp)\n            ArgExpr = ICE->getSubExpr();\n        HandleValue(ArgExpr, false /*AddressOf*/);\n        return;\n      }\n      Inherited::VisitCXXConstructExpr(E);\n    }\n\n    void VisitCXXMemberCallExpr(CXXMemberCallExpr *E) {\n      Expr *Callee = E->getCallee();\n      if (isa<MemberExpr>(Callee)) {\n        HandleValue(Callee, false /*AddressOf*/);\n        for (auto Arg : E->arguments())\n          Visit(Arg);\n        return;\n      }\n\n      Inherited::VisitCXXMemberCallExpr(E);\n    }\n\n    void VisitCallExpr(CallExpr *E) {\n      // Treat std::move as a use.\n      if (E->isCallToStdMove()) {\n        HandleValue(E->getArg(0), /*AddressOf=*/false);\n        return;\n      }\n\n      Inherited::VisitCallExpr(E);\n    }\n\n    void VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {\n      Expr *Callee = E->getCallee();\n\n      if (isa<UnresolvedLookupExpr>(Callee))\n        return Inherited::VisitCXXOperatorCallExpr(E);\n\n      Visit(Callee);\n      for (auto Arg : E->arguments())\n        HandleValue(Arg->IgnoreParenImpCasts(), false /*AddressOf*/);\n    }\n\n    void VisitBinaryOperator(BinaryOperator *E) {\n      // If a field assignment is detected, remove the field from the\n      // uninitiailized field set.\n      if (E->getOpcode() == BO_Assign)\n        if (MemberExpr *ME = dyn_cast<MemberExpr>(E->getLHS()))\n          if (FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\n            if (!FD->getType()->isReferenceType())\n              DeclsToRemove.push_back(FD);\n\n      if (E->isCompoundAssignmentOp()) {\n        HandleValue(E->getLHS(), false /*AddressOf*/);\n        Visit(E->getRHS());\n        return;\n      }\n\n      Inherited::VisitBinaryOperator(E);\n    }\n\n    void VisitUnaryOperator(UnaryOperator *E) {\n      if (E->isIncrementDecrementOp()) {\n        HandleValue(E->getSubExpr(), false /*AddressOf*/);\n        return;\n      }\n      if (E->getOpcode() == UO_AddrOf) {\n        if (MemberExpr *ME = dyn_cast<MemberExpr>(E->getSubExpr())) {\n          HandleValue(ME->getBase(), true /*AddressOf*/);\n          return;\n        }\n      }\n\n      Inherited::VisitUnaryOperator(E);\n    }\n  };\n\n  // Diagnose value-uses of fields to initialize themselves, e.g.\n  //   foo(foo)\n  // where foo is not also a parameter to the constructor.\n  // Also diagnose across field uninitialized use such as\n  //   x(y), y(x)\n  // TODO: implement -Wuninitialized and fold this into that framework.\n  static void DiagnoseUninitializedFields(\n      Sema &SemaRef, const CXXConstructorDecl *Constructor) {\n\n    if (SemaRef.getDiagnostics().isIgnored(diag::warn_field_is_uninit,\n                                           Constructor->getLocation())) {\n      return;\n    }\n\n    if (Constructor->isInvalidDecl())\n      return;\n\n    const CXXRecordDecl *RD = Constructor->getParent();\n\n    if (RD->isDependentContext())\n      return;\n\n    // Holds fields that are uninitialized.\n    llvm::SmallPtrSet<ValueDecl*, 4> UninitializedFields;\n\n    // At the beginning, all fields are uninitialized.\n    for (auto *I : RD->decls()) {\n      if (auto *FD = dyn_cast<FieldDecl>(I)) {\n        UninitializedFields.insert(FD);\n      } else if (auto *IFD = dyn_cast<IndirectFieldDecl>(I)) {\n        UninitializedFields.insert(IFD->getAnonField());\n      }\n    }\n\n    llvm::SmallPtrSet<QualType, 4> UninitializedBaseClasses;\n    for (auto I : RD->bases())\n      UninitializedBaseClasses.insert(I.getType().getCanonicalType());\n\n    if (UninitializedFields.empty() && UninitializedBaseClasses.empty())\n      return;\n\n    UninitializedFieldVisitor UninitializedChecker(SemaRef,\n                                                   UninitializedFields,\n                                                   UninitializedBaseClasses);\n\n    for (const auto *FieldInit : Constructor->inits()) {\n      if (UninitializedFields.empty() && UninitializedBaseClasses.empty())\n        break;\n\n      Expr *InitExpr = FieldInit->getInit();\n      if (!InitExpr)\n        continue;\n\n      if (CXXDefaultInitExpr *Default =\n              dyn_cast<CXXDefaultInitExpr>(InitExpr)) {\n        InitExpr = Default->getExpr();\n        if (!InitExpr)\n          continue;\n        // In class initializers will point to the constructor.\n        UninitializedChecker.CheckInitializer(InitExpr, Constructor,\n                                              FieldInit->getAnyMember(),\n                                              FieldInit->getBaseClass());\n      } else {\n        UninitializedChecker.CheckInitializer(InitExpr, nullptr,\n                                              FieldInit->getAnyMember(),\n                                              FieldInit->getBaseClass());\n      }\n    }\n  }\n} // namespace\n\n/// Enter a new C++ default initializer scope. After calling this, the\n/// caller must call \\ref ActOnFinishCXXInClassMemberInitializer, even if\n/// parsing or instantiating the initializer failed.\nvoid Sema::ActOnStartCXXInClassMemberInitializer() {\n  // Create a synthetic function scope to represent the call to the constructor\n  // that notionally surrounds a use of this initializer.\n  PushFunctionScope();\n}\n\nvoid Sema::ActOnStartTrailingRequiresClause(Scope *S, Declarator &D) {\n  if (!D.isFunctionDeclarator())\n    return;\n  auto &FTI = D.getFunctionTypeInfo();\n  if (!FTI.Params)\n    return;\n  for (auto &Param : ArrayRef<DeclaratorChunk::ParamInfo>(FTI.Params,\n                                                          FTI.NumParams)) {\n    auto *ParamDecl = cast<NamedDecl>(Param.Param);\n    if (ParamDecl->getDeclName())\n      PushOnScopeChains(ParamDecl, S, /*AddToContext=*/false);\n  }\n}\n\nExprResult Sema::ActOnFinishTrailingRequiresClause(ExprResult ConstraintExpr) {\n  return ActOnRequiresClause(ConstraintExpr);\n}\n\nExprResult Sema::ActOnRequiresClause(ExprResult ConstraintExpr) {\n  if (ConstraintExpr.isInvalid())\n    return ExprError();\n\n  ConstraintExpr = CorrectDelayedTyposInExpr(ConstraintExpr);\n  if (ConstraintExpr.isInvalid())\n    return ExprError();\n\n  if (DiagnoseUnexpandedParameterPack(ConstraintExpr.get(),\n                                      UPPC_RequiresClause))\n    return ExprError();\n\n  return ConstraintExpr;\n}\n\n/// This is invoked after parsing an in-class initializer for a\n/// non-static C++ class member, and after instantiating an in-class initializer\n/// in a class template. Such actions are deferred until the class is complete.\nvoid Sema::ActOnFinishCXXInClassMemberInitializer(Decl *D,\n                                                  SourceLocation InitLoc,\n                                                  Expr *InitExpr) {\n  // Pop the notional constructor scope we created earlier.\n  PopFunctionScopeInfo(nullptr, D);\n\n  FieldDecl *FD = dyn_cast<FieldDecl>(D);\n  assert((isa<MSPropertyDecl>(D) || FD->getInClassInitStyle() != ICIS_NoInit) &&\n         \"must set init style when field is created\");\n\n  if (!InitExpr) {\n    D->setInvalidDecl();\n    if (FD)\n      FD->removeInClassInitializer();\n    return;\n  }\n\n  if (DiagnoseUnexpandedParameterPack(InitExpr, UPPC_Initializer)) {\n    FD->setInvalidDecl();\n    FD->removeInClassInitializer();\n    return;\n  }\n\n  ExprResult Init = InitExpr;\n  if (!FD->getType()->isDependentType() && !InitExpr->isTypeDependent()) {\n    InitializedEntity Entity =\n        InitializedEntity::InitializeMemberFromDefaultMemberInitializer(FD);\n    InitializationKind Kind =\n        FD->getInClassInitStyle() == ICIS_ListInit\n            ? InitializationKind::CreateDirectList(InitExpr->getBeginLoc(),\n                                                   InitExpr->getBeginLoc(),\n                                                   InitExpr->getEndLoc())\n            : InitializationKind::CreateCopy(InitExpr->getBeginLoc(), InitLoc);\n    InitializationSequence Seq(*this, Entity, Kind, InitExpr);\n    Init = Seq.Perform(*this, Entity, Kind, InitExpr);\n    if (Init.isInvalid()) {\n      FD->setInvalidDecl();\n      return;\n    }\n  }\n\n  // C++11 [class.base.init]p7:\n  //   The initialization of each base and member constitutes a\n  //   full-expression.\n  Init = ActOnFinishFullExpr(Init.get(), InitLoc, /*DiscardedValue*/ false);\n  if (Init.isInvalid()) {\n    FD->setInvalidDecl();\n    return;\n  }\n\n  InitExpr = Init.get();\n\n  FD->setInClassInitializer(InitExpr);\n}\n\n/// Find the direct and/or virtual base specifiers that\n/// correspond to the given base type, for use in base initialization\n/// within a constructor.\nstatic bool FindBaseInitializer(Sema &SemaRef,\n                                CXXRecordDecl *ClassDecl,\n                                QualType BaseType,\n                                const CXXBaseSpecifier *&DirectBaseSpec,\n                                const CXXBaseSpecifier *&VirtualBaseSpec) {\n  // First, check for a direct base class.\n  DirectBaseSpec = nullptr;\n  for (const auto &Base : ClassDecl->bases()) {\n    if (SemaRef.Context.hasSameUnqualifiedType(BaseType, Base.getType())) {\n      // We found a direct base of this type. That's what we're\n      // initializing.\n      DirectBaseSpec = &Base;\n      break;\n    }\n  }\n\n  // Check for a virtual base class.\n  // FIXME: We might be able to short-circuit this if we know in advance that\n  // there are no virtual bases.\n  VirtualBaseSpec = nullptr;\n  if (!DirectBaseSpec || !DirectBaseSpec->isVirtual()) {\n    // We haven't found a base yet; search the class hierarchy for a\n    // virtual base class.\n    CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                       /*DetectVirtual=*/false);\n    if (SemaRef.IsDerivedFrom(ClassDecl->getLocation(),\n                              SemaRef.Context.getTypeDeclType(ClassDecl),\n                              BaseType, Paths)) {\n      for (CXXBasePaths::paths_iterator Path = Paths.begin();\n           Path != Paths.end(); ++Path) {\n        if (Path->back().Base->isVirtual()) {\n          VirtualBaseSpec = Path->back().Base;\n          break;\n        }\n      }\n    }\n  }\n\n  return DirectBaseSpec || VirtualBaseSpec;\n}\n\n/// Handle a C++ member initializer using braced-init-list syntax.\nMemInitResult\nSema::ActOnMemInitializer(Decl *ConstructorD,\n                          Scope *S,\n                          CXXScopeSpec &SS,\n                          IdentifierInfo *MemberOrBase,\n                          ParsedType TemplateTypeTy,\n                          const DeclSpec &DS,\n                          SourceLocation IdLoc,\n                          Expr *InitList,\n                          SourceLocation EllipsisLoc) {\n  return BuildMemInitializer(ConstructorD, S, SS, MemberOrBase, TemplateTypeTy,\n                             DS, IdLoc, InitList,\n                             EllipsisLoc);\n}\n\n/// Handle a C++ member initializer using parentheses syntax.\nMemInitResult\nSema::ActOnMemInitializer(Decl *ConstructorD,\n                          Scope *S,\n                          CXXScopeSpec &SS,\n                          IdentifierInfo *MemberOrBase,\n                          ParsedType TemplateTypeTy,\n                          const DeclSpec &DS,\n                          SourceLocation IdLoc,\n                          SourceLocation LParenLoc,\n                          ArrayRef<Expr *> Args,\n                          SourceLocation RParenLoc,\n                          SourceLocation EllipsisLoc) {\n  Expr *List = ParenListExpr::Create(Context, LParenLoc, Args, RParenLoc);\n  return BuildMemInitializer(ConstructorD, S, SS, MemberOrBase, TemplateTypeTy,\n                             DS, IdLoc, List, EllipsisLoc);\n}\n\nnamespace {\n\n// Callback to only accept typo corrections that can be a valid C++ member\n// intializer: either a non-static field member or a base class.\nclass MemInitializerValidatorCCC final : public CorrectionCandidateCallback {\npublic:\n  explicit MemInitializerValidatorCCC(CXXRecordDecl *ClassDecl)\n      : ClassDecl(ClassDecl) {}\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    if (NamedDecl *ND = candidate.getCorrectionDecl()) {\n      if (FieldDecl *Member = dyn_cast<FieldDecl>(ND))\n        return Member->getDeclContext()->getRedeclContext()->Equals(ClassDecl);\n      return isa<TypeDecl>(ND);\n    }\n    return false;\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<MemInitializerValidatorCCC>(*this);\n  }\n\nprivate:\n  CXXRecordDecl *ClassDecl;\n};\n\n}\n\nValueDecl *Sema::tryLookupCtorInitMemberDecl(CXXRecordDecl *ClassDecl,\n                                             CXXScopeSpec &SS,\n                                             ParsedType TemplateTypeTy,\n                                             IdentifierInfo *MemberOrBase) {\n  if (SS.getScopeRep() || TemplateTypeTy)\n    return nullptr;\n  DeclContext::lookup_result Result = ClassDecl->lookup(MemberOrBase);\n  if (Result.empty())\n    return nullptr;\n  ValueDecl *Member;\n  if ((Member = dyn_cast<FieldDecl>(Result.front())) ||\n      (Member = dyn_cast<IndirectFieldDecl>(Result.front())))\n    return Member;\n  return nullptr;\n}\n\n/// Handle a C++ member initializer.\nMemInitResult\nSema::BuildMemInitializer(Decl *ConstructorD,\n                          Scope *S,\n                          CXXScopeSpec &SS,\n                          IdentifierInfo *MemberOrBase,\n                          ParsedType TemplateTypeTy,\n                          const DeclSpec &DS,\n                          SourceLocation IdLoc,\n                          Expr *Init,\n                          SourceLocation EllipsisLoc) {\n  ExprResult Res = CorrectDelayedTyposInExpr(Init);\n  if (!Res.isUsable())\n    return true;\n  Init = Res.get();\n\n  if (!ConstructorD)\n    return true;\n\n  AdjustDeclIfTemplate(ConstructorD);\n\n  CXXConstructorDecl *Constructor\n    = dyn_cast<CXXConstructorDecl>(ConstructorD);\n  if (!Constructor) {\n    // The user wrote a constructor initializer on a function that is\n    // not a C++ constructor. Ignore the error for now, because we may\n    // have more member initializers coming; we'll diagnose it just\n    // once in ActOnMemInitializers.\n    return true;\n  }\n\n  CXXRecordDecl *ClassDecl = Constructor->getParent();\n\n  // C++ [class.base.init]p2:\n  //   Names in a mem-initializer-id are looked up in the scope of the\n  //   constructor's class and, if not found in that scope, are looked\n  //   up in the scope containing the constructor's definition.\n  //   [Note: if the constructor's class contains a member with the\n  //   same name as a direct or virtual base class of the class, a\n  //   mem-initializer-id naming the member or base class and composed\n  //   of a single identifier refers to the class member. A\n  //   mem-initializer-id for the hidden base class may be specified\n  //   using a qualified name. ]\n\n  // Look for a member, first.\n  if (ValueDecl *Member = tryLookupCtorInitMemberDecl(\n          ClassDecl, SS, TemplateTypeTy, MemberOrBase)) {\n    if (EllipsisLoc.isValid())\n      Diag(EllipsisLoc, diag::err_pack_expansion_member_init)\n          << MemberOrBase\n          << SourceRange(IdLoc, Init->getSourceRange().getEnd());\n\n    return BuildMemberInitializer(Member, Init, IdLoc);\n  }\n  // It didn't name a member, so see if it names a class.\n  QualType BaseType;\n  TypeSourceInfo *TInfo = nullptr;\n\n  if (TemplateTypeTy) {\n    BaseType = GetTypeFromParser(TemplateTypeTy, &TInfo);\n    if (BaseType.isNull())\n      return true;\n  } else if (DS.getTypeSpecType() == TST_decltype) {\n    BaseType = BuildDecltypeType(DS.getRepAsExpr(), DS.getTypeSpecTypeLoc());\n  } else if (DS.getTypeSpecType() == TST_decltype_auto) {\n    Diag(DS.getTypeSpecTypeLoc(), diag::err_decltype_auto_invalid);\n    return true;\n  } else {\n    LookupResult R(*this, MemberOrBase, IdLoc, LookupOrdinaryName);\n    LookupParsedName(R, S, &SS);\n\n    TypeDecl *TyD = R.getAsSingle<TypeDecl>();\n    if (!TyD) {\n      if (R.isAmbiguous()) return true;\n\n      // We don't want access-control diagnostics here.\n      R.suppressDiagnostics();\n\n      if (SS.isSet() && isDependentScopeSpecifier(SS)) {\n        bool NotUnknownSpecialization = false;\n        DeclContext *DC = computeDeclContext(SS, false);\n        if (CXXRecordDecl *Record = dyn_cast_or_null<CXXRecordDecl>(DC))\n          NotUnknownSpecialization = !Record->hasAnyDependentBases();\n\n        if (!NotUnknownSpecialization) {\n          // When the scope specifier can refer to a member of an unknown\n          // specialization, we take it as a type name.\n          BaseType = CheckTypenameType(ETK_None, SourceLocation(),\n                                       SS.getWithLocInContext(Context),\n                                       *MemberOrBase, IdLoc);\n          if (BaseType.isNull())\n            return true;\n\n          TInfo = Context.CreateTypeSourceInfo(BaseType);\n          DependentNameTypeLoc TL =\n              TInfo->getTypeLoc().castAs<DependentNameTypeLoc>();\n          if (!TL.isNull()) {\n            TL.setNameLoc(IdLoc);\n            TL.setElaboratedKeywordLoc(SourceLocation());\n            TL.setQualifierLoc(SS.getWithLocInContext(Context));\n          }\n\n          R.clear();\n          R.setLookupName(MemberOrBase);\n        }\n      }\n\n      // If no results were found, try to correct typos.\n      TypoCorrection Corr;\n      MemInitializerValidatorCCC CCC(ClassDecl);\n      if (R.empty() && BaseType.isNull() &&\n          (Corr = CorrectTypo(R.getLookupNameInfo(), R.getLookupKind(), S, &SS,\n                              CCC, CTK_ErrorRecovery, ClassDecl))) {\n        if (FieldDecl *Member = Corr.getCorrectionDeclAs<FieldDecl>()) {\n          // We have found a non-static data member with a similar\n          // name to what was typed; complain and initialize that\n          // member.\n          diagnoseTypo(Corr,\n                       PDiag(diag::err_mem_init_not_member_or_class_suggest)\n                         << MemberOrBase << true);\n          return BuildMemberInitializer(Member, Init, IdLoc);\n        } else if (TypeDecl *Type = Corr.getCorrectionDeclAs<TypeDecl>()) {\n          const CXXBaseSpecifier *DirectBaseSpec;\n          const CXXBaseSpecifier *VirtualBaseSpec;\n          if (FindBaseInitializer(*this, ClassDecl,\n                                  Context.getTypeDeclType(Type),\n                                  DirectBaseSpec, VirtualBaseSpec)) {\n            // We have found a direct or virtual base class with a\n            // similar name to what was typed; complain and initialize\n            // that base class.\n            diagnoseTypo(Corr,\n                         PDiag(diag::err_mem_init_not_member_or_class_suggest)\n                           << MemberOrBase << false,\n                         PDiag() /*Suppress note, we provide our own.*/);\n\n            const CXXBaseSpecifier *BaseSpec = DirectBaseSpec ? DirectBaseSpec\n                                                              : VirtualBaseSpec;\n            Diag(BaseSpec->getBeginLoc(), diag::note_base_class_specified_here)\n                << BaseSpec->getType() << BaseSpec->getSourceRange();\n\n            TyD = Type;\n          }\n        }\n      }\n\n      if (!TyD && BaseType.isNull()) {\n        Diag(IdLoc, diag::err_mem_init_not_member_or_class)\n          << MemberOrBase << SourceRange(IdLoc,Init->getSourceRange().getEnd());\n        return true;\n      }\n    }\n\n    if (BaseType.isNull()) {\n      BaseType = Context.getTypeDeclType(TyD);\n      MarkAnyDeclReferenced(TyD->getLocation(), TyD, /*OdrUse=*/false);\n      if (SS.isSet()) {\n        BaseType = Context.getElaboratedType(ETK_None, SS.getScopeRep(),\n                                             BaseType);\n        TInfo = Context.CreateTypeSourceInfo(BaseType);\n        ElaboratedTypeLoc TL = TInfo->getTypeLoc().castAs<ElaboratedTypeLoc>();\n        TL.getNamedTypeLoc().castAs<TypeSpecTypeLoc>().setNameLoc(IdLoc);\n        TL.setElaboratedKeywordLoc(SourceLocation());\n        TL.setQualifierLoc(SS.getWithLocInContext(Context));\n      }\n    }\n  }\n\n  if (!TInfo)\n    TInfo = Context.getTrivialTypeSourceInfo(BaseType, IdLoc);\n\n  return BuildBaseInitializer(BaseType, TInfo, Init, ClassDecl, EllipsisLoc);\n}\n\nMemInitResult\nSema::BuildMemberInitializer(ValueDecl *Member, Expr *Init,\n                             SourceLocation IdLoc) {\n  FieldDecl *DirectMember = dyn_cast<FieldDecl>(Member);\n  IndirectFieldDecl *IndirectMember = dyn_cast<IndirectFieldDecl>(Member);\n  assert((DirectMember || IndirectMember) &&\n         \"Member must be a FieldDecl or IndirectFieldDecl\");\n\n  if (DiagnoseUnexpandedParameterPack(Init, UPPC_Initializer))\n    return true;\n\n  if (Member->isInvalidDecl())\n    return true;\n\n  MultiExprArg Args;\n  if (ParenListExpr *ParenList = dyn_cast<ParenListExpr>(Init)) {\n    Args = MultiExprArg(ParenList->getExprs(), ParenList->getNumExprs());\n  } else if (InitListExpr *InitList = dyn_cast<InitListExpr>(Init)) {\n    Args = MultiExprArg(InitList->getInits(), InitList->getNumInits());\n  } else {\n    // Template instantiation doesn't reconstruct ParenListExprs for us.\n    Args = Init;\n  }\n\n  SourceRange InitRange = Init->getSourceRange();\n\n  if (Member->getType()->isDependentType() || Init->isTypeDependent()) {\n    // Can't check initialization for a member of dependent type or when\n    // any of the arguments are type-dependent expressions.\n    DiscardCleanupsInEvaluationContext();\n  } else {\n    bool InitList = false;\n    if (isa<InitListExpr>(Init)) {\n      InitList = true;\n      Args = Init;\n    }\n\n    // Initialize the member.\n    InitializedEntity MemberEntity =\n      DirectMember ? InitializedEntity::InitializeMember(DirectMember, nullptr)\n                   : InitializedEntity::InitializeMember(IndirectMember,\n                                                         nullptr);\n    InitializationKind Kind =\n        InitList ? InitializationKind::CreateDirectList(\n                       IdLoc, Init->getBeginLoc(), Init->getEndLoc())\n                 : InitializationKind::CreateDirect(IdLoc, InitRange.getBegin(),\n                                                    InitRange.getEnd());\n\n    InitializationSequence InitSeq(*this, MemberEntity, Kind, Args);\n    ExprResult MemberInit = InitSeq.Perform(*this, MemberEntity, Kind, Args,\n                                            nullptr);\n    if (MemberInit.isInvalid())\n      return true;\n\n    // C++11 [class.base.init]p7:\n    //   The initialization of each base and member constitutes a\n    //   full-expression.\n    MemberInit = ActOnFinishFullExpr(MemberInit.get(), InitRange.getBegin(),\n                                     /*DiscardedValue*/ false);\n    if (MemberInit.isInvalid())\n      return true;\n\n    Init = MemberInit.get();\n  }\n\n  if (DirectMember) {\n    return new (Context) CXXCtorInitializer(Context, DirectMember, IdLoc,\n                                            InitRange.getBegin(), Init,\n                                            InitRange.getEnd());\n  } else {\n    return new (Context) CXXCtorInitializer(Context, IndirectMember, IdLoc,\n                                            InitRange.getBegin(), Init,\n                                            InitRange.getEnd());\n  }\n}\n\nMemInitResult\nSema::BuildDelegatingInitializer(TypeSourceInfo *TInfo, Expr *Init,\n                                 CXXRecordDecl *ClassDecl) {\n  SourceLocation NameLoc = TInfo->getTypeLoc().getLocalSourceRange().getBegin();\n  if (!LangOpts.CPlusPlus11)\n    return Diag(NameLoc, diag::err_delegating_ctor)\n      << TInfo->getTypeLoc().getLocalSourceRange();\n  Diag(NameLoc, diag::warn_cxx98_compat_delegating_ctor);\n\n  bool InitList = true;\n  MultiExprArg Args = Init;\n  if (ParenListExpr *ParenList = dyn_cast<ParenListExpr>(Init)) {\n    InitList = false;\n    Args = MultiExprArg(ParenList->getExprs(), ParenList->getNumExprs());\n  }\n\n  SourceRange InitRange = Init->getSourceRange();\n  // Initialize the object.\n  InitializedEntity DelegationEntity = InitializedEntity::InitializeDelegation(\n                                     QualType(ClassDecl->getTypeForDecl(), 0));\n  InitializationKind Kind =\n      InitList ? InitializationKind::CreateDirectList(\n                     NameLoc, Init->getBeginLoc(), Init->getEndLoc())\n               : InitializationKind::CreateDirect(NameLoc, InitRange.getBegin(),\n                                                  InitRange.getEnd());\n  InitializationSequence InitSeq(*this, DelegationEntity, Kind, Args);\n  ExprResult DelegationInit = InitSeq.Perform(*this, DelegationEntity, Kind,\n                                              Args, nullptr);\n  if (DelegationInit.isInvalid())\n    return true;\n\n  assert(cast<CXXConstructExpr>(DelegationInit.get())->getConstructor() &&\n         \"Delegating constructor with no target?\");\n\n  // C++11 [class.base.init]p7:\n  //   The initialization of each base and member constitutes a\n  //   full-expression.\n  DelegationInit = ActOnFinishFullExpr(\n      DelegationInit.get(), InitRange.getBegin(), /*DiscardedValue*/ false);\n  if (DelegationInit.isInvalid())\n    return true;\n\n  // If we are in a dependent context, template instantiation will\n  // perform this type-checking again. Just save the arguments that we\n  // received in a ParenListExpr.\n  // FIXME: This isn't quite ideal, since our ASTs don't capture all\n  // of the information that we have about the base\n  // initializer. However, deconstructing the ASTs is a dicey process,\n  // and this approach is far more likely to get the corner cases right.\n  if (CurContext->isDependentContext())\n    DelegationInit = Init;\n\n  return new (Context) CXXCtorInitializer(Context, TInfo, InitRange.getBegin(),\n                                          DelegationInit.getAs<Expr>(),\n                                          InitRange.getEnd());\n}\n\nMemInitResult\nSema::BuildBaseInitializer(QualType BaseType, TypeSourceInfo *BaseTInfo,\n                           Expr *Init, CXXRecordDecl *ClassDecl,\n                           SourceLocation EllipsisLoc) {\n  SourceLocation BaseLoc\n    = BaseTInfo->getTypeLoc().getLocalSourceRange().getBegin();\n\n  if (!BaseType->isDependentType() && !BaseType->isRecordType())\n    return Diag(BaseLoc, diag::err_base_init_does_not_name_class)\n             << BaseType << BaseTInfo->getTypeLoc().getLocalSourceRange();\n\n  // C++ [class.base.init]p2:\n  //   [...] Unless the mem-initializer-id names a nonstatic data\n  //   member of the constructor's class or a direct or virtual base\n  //   of that class, the mem-initializer is ill-formed. A\n  //   mem-initializer-list can initialize a base class using any\n  //   name that denotes that base class type.\n  bool Dependent = BaseType->isDependentType() || Init->isTypeDependent();\n\n  SourceRange InitRange = Init->getSourceRange();\n  if (EllipsisLoc.isValid()) {\n    // This is a pack expansion.\n    if (!BaseType->containsUnexpandedParameterPack())  {\n      Diag(EllipsisLoc, diag::err_pack_expansion_without_parameter_packs)\n        << SourceRange(BaseLoc, InitRange.getEnd());\n\n      EllipsisLoc = SourceLocation();\n    }\n  } else {\n    // Check for any unexpanded parameter packs.\n    if (DiagnoseUnexpandedParameterPack(BaseLoc, BaseTInfo, UPPC_Initializer))\n      return true;\n\n    if (DiagnoseUnexpandedParameterPack(Init, UPPC_Initializer))\n      return true;\n  }\n\n  // Check for direct and virtual base classes.\n  const CXXBaseSpecifier *DirectBaseSpec = nullptr;\n  const CXXBaseSpecifier *VirtualBaseSpec = nullptr;\n  if (!Dependent) {\n    if (Context.hasSameUnqualifiedType(QualType(ClassDecl->getTypeForDecl(),0),\n                                       BaseType))\n      return BuildDelegatingInitializer(BaseTInfo, Init, ClassDecl);\n\n    FindBaseInitializer(*this, ClassDecl, BaseType, DirectBaseSpec,\n                        VirtualBaseSpec);\n\n    // C++ [base.class.init]p2:\n    // Unless the mem-initializer-id names a nonstatic data member of the\n    // constructor's class or a direct or virtual base of that class, the\n    // mem-initializer is ill-formed.\n    if (!DirectBaseSpec && !VirtualBaseSpec) {\n      // If the class has any dependent bases, then it's possible that\n      // one of those types will resolve to the same type as\n      // BaseType. Therefore, just treat this as a dependent base\n      // class initialization.  FIXME: Should we try to check the\n      // initialization anyway? It seems odd.\n      if (ClassDecl->hasAnyDependentBases())\n        Dependent = true;\n      else\n        return Diag(BaseLoc, diag::err_not_direct_base_or_virtual)\n          << BaseType << Context.getTypeDeclType(ClassDecl)\n          << BaseTInfo->getTypeLoc().getLocalSourceRange();\n    }\n  }\n\n  if (Dependent) {\n    DiscardCleanupsInEvaluationContext();\n\n    return new (Context) CXXCtorInitializer(Context, BaseTInfo,\n                                            /*IsVirtual=*/false,\n                                            InitRange.getBegin(), Init,\n                                            InitRange.getEnd(), EllipsisLoc);\n  }\n\n  // C++ [base.class.init]p2:\n  //   If a mem-initializer-id is ambiguous because it designates both\n  //   a direct non-virtual base class and an inherited virtual base\n  //   class, the mem-initializer is ill-formed.\n  if (DirectBaseSpec && VirtualBaseSpec)\n    return Diag(BaseLoc, diag::err_base_init_direct_and_virtual)\n      << BaseType << BaseTInfo->getTypeLoc().getLocalSourceRange();\n\n  const CXXBaseSpecifier *BaseSpec = DirectBaseSpec;\n  if (!BaseSpec)\n    BaseSpec = VirtualBaseSpec;\n\n  // Initialize the base.\n  bool InitList = true;\n  MultiExprArg Args = Init;\n  if (ParenListExpr *ParenList = dyn_cast<ParenListExpr>(Init)) {\n    InitList = false;\n    Args = MultiExprArg(ParenList->getExprs(), ParenList->getNumExprs());\n  }\n\n  InitializedEntity BaseEntity =\n    InitializedEntity::InitializeBase(Context, BaseSpec, VirtualBaseSpec);\n  InitializationKind Kind =\n      InitList ? InitializationKind::CreateDirectList(BaseLoc)\n               : InitializationKind::CreateDirect(BaseLoc, InitRange.getBegin(),\n                                                  InitRange.getEnd());\n  InitializationSequence InitSeq(*this, BaseEntity, Kind, Args);\n  ExprResult BaseInit = InitSeq.Perform(*this, BaseEntity, Kind, Args, nullptr);\n  if (BaseInit.isInvalid())\n    return true;\n\n  // C++11 [class.base.init]p7:\n  //   The initialization of each base and member constitutes a\n  //   full-expression.\n  BaseInit = ActOnFinishFullExpr(BaseInit.get(), InitRange.getBegin(),\n                                 /*DiscardedValue*/ false);\n  if (BaseInit.isInvalid())\n    return true;\n\n  // If we are in a dependent context, template instantiation will\n  // perform this type-checking again. Just save the arguments that we\n  // received in a ParenListExpr.\n  // FIXME: This isn't quite ideal, since our ASTs don't capture all\n  // of the information that we have about the base\n  // initializer. However, deconstructing the ASTs is a dicey process,\n  // and this approach is far more likely to get the corner cases right.\n  if (CurContext->isDependentContext())\n    BaseInit = Init;\n\n  return new (Context) CXXCtorInitializer(Context, BaseTInfo,\n                                          BaseSpec->isVirtual(),\n                                          InitRange.getBegin(),\n                                          BaseInit.getAs<Expr>(),\n                                          InitRange.getEnd(), EllipsisLoc);\n}\n\n// Create a static_cast\\<T&&>(expr).\nstatic Expr *CastForMoving(Sema &SemaRef, Expr *E, QualType T = QualType()) {\n  if (T.isNull()) T = E->getType();\n  QualType TargetType = SemaRef.BuildReferenceType(\n      T, /*SpelledAsLValue*/false, SourceLocation(), DeclarationName());\n  SourceLocation ExprLoc = E->getBeginLoc();\n  TypeSourceInfo *TargetLoc = SemaRef.Context.getTrivialTypeSourceInfo(\n      TargetType, ExprLoc);\n\n  return SemaRef.BuildCXXNamedCast(ExprLoc, tok::kw_static_cast, TargetLoc, E,\n                                   SourceRange(ExprLoc, ExprLoc),\n                                   E->getSourceRange()).get();\n}\n\n/// ImplicitInitializerKind - How an implicit base or member initializer should\n/// initialize its base or member.\nenum ImplicitInitializerKind {\n  IIK_Default,\n  IIK_Copy,\n  IIK_Move,\n  IIK_Inherit\n};\n\nstatic bool\nBuildImplicitBaseInitializer(Sema &SemaRef, CXXConstructorDecl *Constructor,\n                             ImplicitInitializerKind ImplicitInitKind,\n                             CXXBaseSpecifier *BaseSpec,\n                             bool IsInheritedVirtualBase,\n                             CXXCtorInitializer *&CXXBaseInit) {\n  InitializedEntity InitEntity\n    = InitializedEntity::InitializeBase(SemaRef.Context, BaseSpec,\n                                        IsInheritedVirtualBase);\n\n  ExprResult BaseInit;\n\n  switch (ImplicitInitKind) {\n  case IIK_Inherit:\n  case IIK_Default: {\n    InitializationKind InitKind\n      = InitializationKind::CreateDefault(Constructor->getLocation());\n    InitializationSequence InitSeq(SemaRef, InitEntity, InitKind, None);\n    BaseInit = InitSeq.Perform(SemaRef, InitEntity, InitKind, None);\n    break;\n  }\n\n  case IIK_Move:\n  case IIK_Copy: {\n    bool Moving = ImplicitInitKind == IIK_Move;\n    ParmVarDecl *Param = Constructor->getParamDecl(0);\n    QualType ParamType = Param->getType().getNonReferenceType();\n\n    Expr *CopyCtorArg =\n      DeclRefExpr::Create(SemaRef.Context, NestedNameSpecifierLoc(),\n                          SourceLocation(), Param, false,\n                          Constructor->getLocation(), ParamType,\n                          VK_LValue, nullptr);\n\n    SemaRef.MarkDeclRefReferenced(cast<DeclRefExpr>(CopyCtorArg));\n\n    // Cast to the base class to avoid ambiguities.\n    QualType ArgTy =\n      SemaRef.Context.getQualifiedType(BaseSpec->getType().getUnqualifiedType(),\n                                       ParamType.getQualifiers());\n\n    if (Moving) {\n      CopyCtorArg = CastForMoving(SemaRef, CopyCtorArg);\n    }\n\n    CXXCastPath BasePath;\n    BasePath.push_back(BaseSpec);\n    CopyCtorArg = SemaRef.ImpCastExprToType(CopyCtorArg, ArgTy,\n                                            CK_UncheckedDerivedToBase,\n                                            Moving ? VK_XValue : VK_LValue,\n                                            &BasePath).get();\n\n    InitializationKind InitKind\n      = InitializationKind::CreateDirect(Constructor->getLocation(),\n                                         SourceLocation(), SourceLocation());\n    InitializationSequence InitSeq(SemaRef, InitEntity, InitKind, CopyCtorArg);\n    BaseInit = InitSeq.Perform(SemaRef, InitEntity, InitKind, CopyCtorArg);\n    break;\n  }\n  }\n\n  BaseInit = SemaRef.MaybeCreateExprWithCleanups(BaseInit);\n  if (BaseInit.isInvalid())\n    return true;\n\n  CXXBaseInit =\n    new (SemaRef.Context) CXXCtorInitializer(SemaRef.Context,\n               SemaRef.Context.getTrivialTypeSourceInfo(BaseSpec->getType(),\n                                                        SourceLocation()),\n                                             BaseSpec->isVirtual(),\n                                             SourceLocation(),\n                                             BaseInit.getAs<Expr>(),\n                                             SourceLocation(),\n                                             SourceLocation());\n\n  return false;\n}\n\nstatic bool RefersToRValueRef(Expr *MemRef) {\n  ValueDecl *Referenced = cast<MemberExpr>(MemRef)->getMemberDecl();\n  return Referenced->getType()->isRValueReferenceType();\n}\n\nstatic bool\nBuildImplicitMemberInitializer(Sema &SemaRef, CXXConstructorDecl *Constructor,\n                               ImplicitInitializerKind ImplicitInitKind,\n                               FieldDecl *Field, IndirectFieldDecl *Indirect,\n                               CXXCtorInitializer *&CXXMemberInit) {\n  if (Field->isInvalidDecl())\n    return true;\n\n  SourceLocation Loc = Constructor->getLocation();\n\n  if (ImplicitInitKind == IIK_Copy || ImplicitInitKind == IIK_Move) {\n    bool Moving = ImplicitInitKind == IIK_Move;\n    ParmVarDecl *Param = Constructor->getParamDecl(0);\n    QualType ParamType = Param->getType().getNonReferenceType();\n\n    // Suppress copying zero-width bitfields.\n    if (Field->isZeroLengthBitField(SemaRef.Context))\n      return false;\n\n    Expr *MemberExprBase =\n      DeclRefExpr::Create(SemaRef.Context, NestedNameSpecifierLoc(),\n                          SourceLocation(), Param, false,\n                          Loc, ParamType, VK_LValue, nullptr);\n\n    SemaRef.MarkDeclRefReferenced(cast<DeclRefExpr>(MemberExprBase));\n\n    if (Moving) {\n      MemberExprBase = CastForMoving(SemaRef, MemberExprBase);\n    }\n\n    // Build a reference to this field within the parameter.\n    CXXScopeSpec SS;\n    LookupResult MemberLookup(SemaRef, Field->getDeclName(), Loc,\n                              Sema::LookupMemberName);\n    MemberLookup.addDecl(Indirect ? cast<ValueDecl>(Indirect)\n                                  : cast<ValueDecl>(Field), AS_public);\n    MemberLookup.resolveKind();\n    ExprResult CtorArg\n      = SemaRef.BuildMemberReferenceExpr(MemberExprBase,\n                                         ParamType, Loc,\n                                         /*IsArrow=*/false,\n                                         SS,\n                                         /*TemplateKWLoc=*/SourceLocation(),\n                                         /*FirstQualifierInScope=*/nullptr,\n                                         MemberLookup,\n                                         /*TemplateArgs=*/nullptr,\n                                         /*S*/nullptr);\n    if (CtorArg.isInvalid())\n      return true;\n\n    // C++11 [class.copy]p15:\n    //   - if a member m has rvalue reference type T&&, it is direct-initialized\n    //     with static_cast<T&&>(x.m);\n    if (RefersToRValueRef(CtorArg.get())) {\n      CtorArg = CastForMoving(SemaRef, CtorArg.get());\n    }\n\n    InitializedEntity Entity =\n        Indirect ? InitializedEntity::InitializeMember(Indirect, nullptr,\n                                                       /*Implicit*/ true)\n                 : InitializedEntity::InitializeMember(Field, nullptr,\n                                                       /*Implicit*/ true);\n\n    // Direct-initialize to use the copy constructor.\n    InitializationKind InitKind =\n      InitializationKind::CreateDirect(Loc, SourceLocation(), SourceLocation());\n\n    Expr *CtorArgE = CtorArg.getAs<Expr>();\n    InitializationSequence InitSeq(SemaRef, Entity, InitKind, CtorArgE);\n    ExprResult MemberInit =\n        InitSeq.Perform(SemaRef, Entity, InitKind, MultiExprArg(&CtorArgE, 1));\n    MemberInit = SemaRef.MaybeCreateExprWithCleanups(MemberInit);\n    if (MemberInit.isInvalid())\n      return true;\n\n    if (Indirect)\n      CXXMemberInit = new (SemaRef.Context) CXXCtorInitializer(\n          SemaRef.Context, Indirect, Loc, Loc, MemberInit.getAs<Expr>(), Loc);\n    else\n      CXXMemberInit = new (SemaRef.Context) CXXCtorInitializer(\n          SemaRef.Context, Field, Loc, Loc, MemberInit.getAs<Expr>(), Loc);\n    return false;\n  }\n\n  assert((ImplicitInitKind == IIK_Default || ImplicitInitKind == IIK_Inherit) &&\n         \"Unhandled implicit init kind!\");\n\n  QualType FieldBaseElementType =\n    SemaRef.Context.getBaseElementType(Field->getType());\n\n  if (FieldBaseElementType->isRecordType()) {\n    InitializedEntity InitEntity =\n        Indirect ? InitializedEntity::InitializeMember(Indirect, nullptr,\n                                                       /*Implicit*/ true)\n                 : InitializedEntity::InitializeMember(Field, nullptr,\n                                                       /*Implicit*/ true);\n    InitializationKind InitKind =\n      InitializationKind::CreateDefault(Loc);\n\n    InitializationSequence InitSeq(SemaRef, InitEntity, InitKind, None);\n    ExprResult MemberInit =\n      InitSeq.Perform(SemaRef, InitEntity, InitKind, None);\n\n    MemberInit = SemaRef.MaybeCreateExprWithCleanups(MemberInit);\n    if (MemberInit.isInvalid())\n      return true;\n\n    if (Indirect)\n      CXXMemberInit = new (SemaRef.Context) CXXCtorInitializer(SemaRef.Context,\n                                                               Indirect, Loc,\n                                                               Loc,\n                                                               MemberInit.get(),\n                                                               Loc);\n    else\n      CXXMemberInit = new (SemaRef.Context) CXXCtorInitializer(SemaRef.Context,\n                                                               Field, Loc, Loc,\n                                                               MemberInit.get(),\n                                                               Loc);\n    return false;\n  }\n\n  if (!Field->getParent()->isUnion()) {\n    if (FieldBaseElementType->isReferenceType()) {\n      SemaRef.Diag(Constructor->getLocation(),\n                   diag::err_uninitialized_member_in_ctor)\n      << (int)Constructor->isImplicit()\n      << SemaRef.Context.getTagDeclType(Constructor->getParent())\n      << 0 << Field->getDeclName();\n      SemaRef.Diag(Field->getLocation(), diag::note_declared_at);\n      return true;\n    }\n\n    if (FieldBaseElementType.isConstQualified()) {\n      SemaRef.Diag(Constructor->getLocation(),\n                   diag::err_uninitialized_member_in_ctor)\n      << (int)Constructor->isImplicit()\n      << SemaRef.Context.getTagDeclType(Constructor->getParent())\n      << 1 << Field->getDeclName();\n      SemaRef.Diag(Field->getLocation(), diag::note_declared_at);\n      return true;\n    }\n  }\n\n  if (FieldBaseElementType.hasNonTrivialObjCLifetime()) {\n    // ARC and Weak:\n    //   Default-initialize Objective-C pointers to NULL.\n    CXXMemberInit\n      = new (SemaRef.Context) CXXCtorInitializer(SemaRef.Context, Field,\n                                                 Loc, Loc,\n                 new (SemaRef.Context) ImplicitValueInitExpr(Field->getType()),\n                                                 Loc);\n    return false;\n  }\n\n  // Nothing to initialize.\n  CXXMemberInit = nullptr;\n  return false;\n}\n\nnamespace {\nstruct BaseAndFieldInfo {\n  Sema &S;\n  CXXConstructorDecl *Ctor;\n  bool AnyErrorsInInits;\n  ImplicitInitializerKind IIK;\n  llvm::DenseMap<const void *, CXXCtorInitializer*> AllBaseFields;\n  SmallVector<CXXCtorInitializer*, 8> AllToInit;\n  llvm::DenseMap<TagDecl*, FieldDecl*> ActiveUnionMember;\n\n  BaseAndFieldInfo(Sema &S, CXXConstructorDecl *Ctor, bool ErrorsInInits)\n    : S(S), Ctor(Ctor), AnyErrorsInInits(ErrorsInInits) {\n    bool Generated = Ctor->isImplicit() || Ctor->isDefaulted();\n    if (Ctor->getInheritedConstructor())\n      IIK = IIK_Inherit;\n    else if (Generated && Ctor->isCopyConstructor())\n      IIK = IIK_Copy;\n    else if (Generated && Ctor->isMoveConstructor())\n      IIK = IIK_Move;\n    else\n      IIK = IIK_Default;\n  }\n\n  bool isImplicitCopyOrMove() const {\n    switch (IIK) {\n    case IIK_Copy:\n    case IIK_Move:\n      return true;\n\n    case IIK_Default:\n    case IIK_Inherit:\n      return false;\n    }\n\n    llvm_unreachable(\"Invalid ImplicitInitializerKind!\");\n  }\n\n  bool addFieldInitializer(CXXCtorInitializer *Init) {\n    AllToInit.push_back(Init);\n\n    // Check whether this initializer makes the field \"used\".\n    if (Init->getInit()->HasSideEffects(S.Context))\n      S.UnusedPrivateFields.remove(Init->getAnyMember());\n\n    return false;\n  }\n\n  bool isInactiveUnionMember(FieldDecl *Field) {\n    RecordDecl *Record = Field->getParent();\n    if (!Record->isUnion())\n      return false;\n\n    if (FieldDecl *Active =\n            ActiveUnionMember.lookup(Record->getCanonicalDecl()))\n      return Active != Field->getCanonicalDecl();\n\n    // In an implicit copy or move constructor, ignore any in-class initializer.\n    if (isImplicitCopyOrMove())\n      return true;\n\n    // If there's no explicit initialization, the field is active only if it\n    // has an in-class initializer...\n    if (Field->hasInClassInitializer())\n      return false;\n    // ... or it's an anonymous struct or union whose class has an in-class\n    // initializer.\n    if (!Field->isAnonymousStructOrUnion())\n      return true;\n    CXXRecordDecl *FieldRD = Field->getType()->getAsCXXRecordDecl();\n    return !FieldRD->hasInClassInitializer();\n  }\n\n  /// Determine whether the given field is, or is within, a union member\n  /// that is inactive (because there was an initializer given for a different\n  /// member of the union, or because the union was not initialized at all).\n  bool isWithinInactiveUnionMember(FieldDecl *Field,\n                                   IndirectFieldDecl *Indirect) {\n    if (!Indirect)\n      return isInactiveUnionMember(Field);\n\n    for (auto *C : Indirect->chain()) {\n      FieldDecl *Field = dyn_cast<FieldDecl>(C);\n      if (Field && isInactiveUnionMember(Field))\n        return true;\n    }\n    return false;\n  }\n};\n}\n\n/// Determine whether the given type is an incomplete or zero-lenfgth\n/// array type.\nstatic bool isIncompleteOrZeroLengthArrayType(ASTContext &Context, QualType T) {\n  if (T->isIncompleteArrayType())\n    return true;\n\n  while (const ConstantArrayType *ArrayT = Context.getAsConstantArrayType(T)) {\n    if (!ArrayT->getSize())\n      return true;\n\n    T = ArrayT->getElementType();\n  }\n\n  return false;\n}\n\nstatic bool CollectFieldInitializer(Sema &SemaRef, BaseAndFieldInfo &Info,\n                                    FieldDecl *Field,\n                                    IndirectFieldDecl *Indirect = nullptr) {\n  if (Field->isInvalidDecl())\n    return false;\n\n  // Overwhelmingly common case: we have a direct initializer for this field.\n  if (CXXCtorInitializer *Init =\n          Info.AllBaseFields.lookup(Field->getCanonicalDecl()))\n    return Info.addFieldInitializer(Init);\n\n  // C++11 [class.base.init]p8:\n  //   if the entity is a non-static data member that has a\n  //   brace-or-equal-initializer and either\n  //   -- the constructor's class is a union and no other variant member of that\n  //      union is designated by a mem-initializer-id or\n  //   -- the constructor's class is not a union, and, if the entity is a member\n  //      of an anonymous union, no other member of that union is designated by\n  //      a mem-initializer-id,\n  //   the entity is initialized as specified in [dcl.init].\n  //\n  // We also apply the same rules to handle anonymous structs within anonymous\n  // unions.\n  if (Info.isWithinInactiveUnionMember(Field, Indirect))\n    return false;\n\n  if (Field->hasInClassInitializer() && !Info.isImplicitCopyOrMove()) {\n    ExprResult DIE =\n        SemaRef.BuildCXXDefaultInitExpr(Info.Ctor->getLocation(), Field);\n    if (DIE.isInvalid())\n      return true;\n\n    auto Entity = InitializedEntity::InitializeMember(Field, nullptr, true);\n    SemaRef.checkInitializerLifetime(Entity, DIE.get());\n\n    CXXCtorInitializer *Init;\n    if (Indirect)\n      Init = new (SemaRef.Context)\n          CXXCtorInitializer(SemaRef.Context, Indirect, SourceLocation(),\n                             SourceLocation(), DIE.get(), SourceLocation());\n    else\n      Init = new (SemaRef.Context)\n          CXXCtorInitializer(SemaRef.Context, Field, SourceLocation(),\n                             SourceLocation(), DIE.get(), SourceLocation());\n    return Info.addFieldInitializer(Init);\n  }\n\n  // Don't initialize incomplete or zero-length arrays.\n  if (isIncompleteOrZeroLengthArrayType(SemaRef.Context, Field->getType()))\n    return false;\n\n  // Don't try to build an implicit initializer if there were semantic\n  // errors in any of the initializers (and therefore we might be\n  // missing some that the user actually wrote).\n  if (Info.AnyErrorsInInits)\n    return false;\n\n  CXXCtorInitializer *Init = nullptr;\n  if (BuildImplicitMemberInitializer(Info.S, Info.Ctor, Info.IIK, Field,\n                                     Indirect, Init))\n    return true;\n\n  if (!Init)\n    return false;\n\n  return Info.addFieldInitializer(Init);\n}\n\nbool\nSema::SetDelegatingInitializer(CXXConstructorDecl *Constructor,\n                               CXXCtorInitializer *Initializer) {\n  assert(Initializer->isDelegatingInitializer());\n  Constructor->setNumCtorInitializers(1);\n  CXXCtorInitializer **initializer =\n    new (Context) CXXCtorInitializer*[1];\n  memcpy(initializer, &Initializer, sizeof (CXXCtorInitializer*));\n  Constructor->setCtorInitializers(initializer);\n\n  if (CXXDestructorDecl *Dtor = LookupDestructor(Constructor->getParent())) {\n    MarkFunctionReferenced(Initializer->getSourceLocation(), Dtor);\n    DiagnoseUseOfDecl(Dtor, Initializer->getSourceLocation());\n  }\n\n  DelegatingCtorDecls.push_back(Constructor);\n\n  DiagnoseUninitializedFields(*this, Constructor);\n\n  return false;\n}\n\nbool Sema::SetCtorInitializers(CXXConstructorDecl *Constructor, bool AnyErrors,\n                               ArrayRef<CXXCtorInitializer *> Initializers) {\n  if (Constructor->isDependentContext()) {\n    // Just store the initializers as written, they will be checked during\n    // instantiation.\n    if (!Initializers.empty()) {\n      Constructor->setNumCtorInitializers(Initializers.size());\n      CXXCtorInitializer **baseOrMemberInitializers =\n        new (Context) CXXCtorInitializer*[Initializers.size()];\n      memcpy(baseOrMemberInitializers, Initializers.data(),\n             Initializers.size() * sizeof(CXXCtorInitializer*));\n      Constructor->setCtorInitializers(baseOrMemberInitializers);\n    }\n\n    // Let template instantiation know whether we had errors.\n    if (AnyErrors)\n      Constructor->setInvalidDecl();\n\n    return false;\n  }\n\n  BaseAndFieldInfo Info(*this, Constructor, AnyErrors);\n\n  // We need to build the initializer AST according to order of construction\n  // and not what user specified in the Initializers list.\n  CXXRecordDecl *ClassDecl = Constructor->getParent()->getDefinition();\n  if (!ClassDecl)\n    return true;\n\n  bool HadError = false;\n\n  for (unsigned i = 0; i < Initializers.size(); i++) {\n    CXXCtorInitializer *Member = Initializers[i];\n\n    if (Member->isBaseInitializer())\n      Info.AllBaseFields[Member->getBaseClass()->getAs<RecordType>()] = Member;\n    else {\n      Info.AllBaseFields[Member->getAnyMember()->getCanonicalDecl()] = Member;\n\n      if (IndirectFieldDecl *F = Member->getIndirectMember()) {\n        for (auto *C : F->chain()) {\n          FieldDecl *FD = dyn_cast<FieldDecl>(C);\n          if (FD && FD->getParent()->isUnion())\n            Info.ActiveUnionMember.insert(std::make_pair(\n                FD->getParent()->getCanonicalDecl(), FD->getCanonicalDecl()));\n        }\n      } else if (FieldDecl *FD = Member->getMember()) {\n        if (FD->getParent()->isUnion())\n          Info.ActiveUnionMember.insert(std::make_pair(\n              FD->getParent()->getCanonicalDecl(), FD->getCanonicalDecl()));\n      }\n    }\n  }\n\n  // Keep track of the direct virtual bases.\n  llvm::SmallPtrSet<CXXBaseSpecifier *, 16> DirectVBases;\n  for (auto &I : ClassDecl->bases()) {\n    if (I.isVirtual())\n      DirectVBases.insert(&I);\n  }\n\n  // Push virtual bases before others.\n  for (auto &VBase : ClassDecl->vbases()) {\n    if (CXXCtorInitializer *Value\n        = Info.AllBaseFields.lookup(VBase.getType()->getAs<RecordType>())) {\n      // [class.base.init]p7, per DR257:\n      //   A mem-initializer where the mem-initializer-id names a virtual base\n      //   class is ignored during execution of a constructor of any class that\n      //   is not the most derived class.\n      if (ClassDecl->isAbstract()) {\n        // FIXME: Provide a fixit to remove the base specifier. This requires\n        // tracking the location of the associated comma for a base specifier.\n        Diag(Value->getSourceLocation(), diag::warn_abstract_vbase_init_ignored)\n          << VBase.getType() << ClassDecl;\n        DiagnoseAbstractType(ClassDecl);\n      }\n\n      Info.AllToInit.push_back(Value);\n    } else if (!AnyErrors && !ClassDecl->isAbstract()) {\n      // [class.base.init]p8, per DR257:\n      //   If a given [...] base class is not named by a mem-initializer-id\n      //   [...] and the entity is not a virtual base class of an abstract\n      //   class, then [...] the entity is default-initialized.\n      bool IsInheritedVirtualBase = !DirectVBases.count(&VBase);\n      CXXCtorInitializer *CXXBaseInit;\n      if (BuildImplicitBaseInitializer(*this, Constructor, Info.IIK,\n                                       &VBase, IsInheritedVirtualBase,\n                                       CXXBaseInit)) {\n        HadError = true;\n        continue;\n      }\n\n      Info.AllToInit.push_back(CXXBaseInit);\n    }\n  }\n\n  // Non-virtual bases.\n  for (auto &Base : ClassDecl->bases()) {\n    // Virtuals are in the virtual base list and already constructed.\n    if (Base.isVirtual())\n      continue;\n\n    if (CXXCtorInitializer *Value\n          = Info.AllBaseFields.lookup(Base.getType()->getAs<RecordType>())) {\n      Info.AllToInit.push_back(Value);\n    } else if (!AnyErrors) {\n      CXXCtorInitializer *CXXBaseInit;\n      if (BuildImplicitBaseInitializer(*this, Constructor, Info.IIK,\n                                       &Base, /*IsInheritedVirtualBase=*/false,\n                                       CXXBaseInit)) {\n        HadError = true;\n        continue;\n      }\n\n      Info.AllToInit.push_back(CXXBaseInit);\n    }\n  }\n\n  // Fields.\n  for (auto *Mem : ClassDecl->decls()) {\n    if (auto *F = dyn_cast<FieldDecl>(Mem)) {\n      // C++ [class.bit]p2:\n      //   A declaration for a bit-field that omits the identifier declares an\n      //   unnamed bit-field. Unnamed bit-fields are not members and cannot be\n      //   initialized.\n      if (F->isUnnamedBitfield())\n        continue;\n\n      // If we're not generating the implicit copy/move constructor, then we'll\n      // handle anonymous struct/union fields based on their individual\n      // indirect fields.\n      if (F->isAnonymousStructOrUnion() && !Info.isImplicitCopyOrMove())\n        continue;\n\n      if (CollectFieldInitializer(*this, Info, F))\n        HadError = true;\n      continue;\n    }\n\n    // Beyond this point, we only consider default initialization.\n    if (Info.isImplicitCopyOrMove())\n      continue;\n\n    if (auto *F = dyn_cast<IndirectFieldDecl>(Mem)) {\n      if (F->getType()->isIncompleteArrayType()) {\n        assert(ClassDecl->hasFlexibleArrayMember() &&\n               \"Incomplete array type is not valid\");\n        continue;\n      }\n\n      // Initialize each field of an anonymous struct individually.\n      if (CollectFieldInitializer(*this, Info, F->getAnonField(), F))\n        HadError = true;\n\n      continue;\n    }\n  }\n\n  unsigned NumInitializers = Info.AllToInit.size();\n  if (NumInitializers > 0) {\n    Constructor->setNumCtorInitializers(NumInitializers);\n    CXXCtorInitializer **baseOrMemberInitializers =\n      new (Context) CXXCtorInitializer*[NumInitializers];\n    memcpy(baseOrMemberInitializers, Info.AllToInit.data(),\n           NumInitializers * sizeof(CXXCtorInitializer*));\n    Constructor->setCtorInitializers(baseOrMemberInitializers);\n\n    // Constructors implicitly reference the base and member\n    // destructors.\n    MarkBaseAndMemberDestructorsReferenced(Constructor->getLocation(),\n                                           Constructor->getParent());\n  }\n\n  return HadError;\n}\n\nstatic void PopulateKeysForFields(FieldDecl *Field, SmallVectorImpl<const void*> &IdealInits) {\n  if (const RecordType *RT = Field->getType()->getAs<RecordType>()) {\n    const RecordDecl *RD = RT->getDecl();\n    if (RD->isAnonymousStructOrUnion()) {\n      for (auto *Field : RD->fields())\n        PopulateKeysForFields(Field, IdealInits);\n      return;\n    }\n  }\n  IdealInits.push_back(Field->getCanonicalDecl());\n}\n\nstatic const void *GetKeyForBase(ASTContext &Context, QualType BaseType) {\n  return Context.getCanonicalType(BaseType).getTypePtr();\n}\n\nstatic const void *GetKeyForMember(ASTContext &Context,\n                                   CXXCtorInitializer *Member) {\n  if (!Member->isAnyMemberInitializer())\n    return GetKeyForBase(Context, QualType(Member->getBaseClass(), 0));\n\n  return Member->getAnyMember()->getCanonicalDecl();\n}\n\nstatic void DiagnoseBaseOrMemInitializerOrder(\n    Sema &SemaRef, const CXXConstructorDecl *Constructor,\n    ArrayRef<CXXCtorInitializer *> Inits) {\n  if (Constructor->getDeclContext()->isDependentContext())\n    return;\n\n  // Don't check initializers order unless the warning is enabled at the\n  // location of at least one initializer.\n  bool ShouldCheckOrder = false;\n  for (unsigned InitIndex = 0; InitIndex != Inits.size(); ++InitIndex) {\n    CXXCtorInitializer *Init = Inits[InitIndex];\n    if (!SemaRef.Diags.isIgnored(diag::warn_initializer_out_of_order,\n                                 Init->getSourceLocation())) {\n      ShouldCheckOrder = true;\n      break;\n    }\n  }\n  if (!ShouldCheckOrder)\n    return;\n\n  // Build the list of bases and members in the order that they'll\n  // actually be initialized.  The explicit initializers should be in\n  // this same order but may be missing things.\n  SmallVector<const void*, 32> IdealInitKeys;\n\n  const CXXRecordDecl *ClassDecl = Constructor->getParent();\n\n  // 1. Virtual bases.\n  for (const auto &VBase : ClassDecl->vbases())\n    IdealInitKeys.push_back(GetKeyForBase(SemaRef.Context, VBase.getType()));\n\n  // 2. Non-virtual bases.\n  for (const auto &Base : ClassDecl->bases()) {\n    if (Base.isVirtual())\n      continue;\n    IdealInitKeys.push_back(GetKeyForBase(SemaRef.Context, Base.getType()));\n  }\n\n  // 3. Direct fields.\n  for (auto *Field : ClassDecl->fields()) {\n    if (Field->isUnnamedBitfield())\n      continue;\n\n    PopulateKeysForFields(Field, IdealInitKeys);\n  }\n\n  unsigned NumIdealInits = IdealInitKeys.size();\n  unsigned IdealIndex = 0;\n\n  CXXCtorInitializer *PrevInit = nullptr;\n  for (unsigned InitIndex = 0; InitIndex != Inits.size(); ++InitIndex) {\n    CXXCtorInitializer *Init = Inits[InitIndex];\n    const void *InitKey = GetKeyForMember(SemaRef.Context, Init);\n\n    // Scan forward to try to find this initializer in the idealized\n    // initializers list.\n    for (; IdealIndex != NumIdealInits; ++IdealIndex)\n      if (InitKey == IdealInitKeys[IdealIndex])\n        break;\n\n    // If we didn't find this initializer, it must be because we\n    // scanned past it on a previous iteration.  That can only\n    // happen if we're out of order;  emit a warning.\n    if (IdealIndex == NumIdealInits && PrevInit) {\n      Sema::SemaDiagnosticBuilder D =\n        SemaRef.Diag(PrevInit->getSourceLocation(),\n                     diag::warn_initializer_out_of_order);\n\n      if (PrevInit->isAnyMemberInitializer())\n        D << 0 << PrevInit->getAnyMember()->getDeclName();\n      else\n        D << 1 << PrevInit->getTypeSourceInfo()->getType();\n\n      if (Init->isAnyMemberInitializer())\n        D << 0 << Init->getAnyMember()->getDeclName();\n      else\n        D << 1 << Init->getTypeSourceInfo()->getType();\n\n      // Move back to the initializer's location in the ideal list.\n      for (IdealIndex = 0; IdealIndex != NumIdealInits; ++IdealIndex)\n        if (InitKey == IdealInitKeys[IdealIndex])\n          break;\n\n      assert(IdealIndex < NumIdealInits &&\n             \"initializer not found in initializer list\");\n    }\n\n    PrevInit = Init;\n  }\n}\n\nnamespace {\nbool CheckRedundantInit(Sema &S,\n                        CXXCtorInitializer *Init,\n                        CXXCtorInitializer *&PrevInit) {\n  if (!PrevInit) {\n    PrevInit = Init;\n    return false;\n  }\n\n  if (FieldDecl *Field = Init->getAnyMember())\n    S.Diag(Init->getSourceLocation(),\n           diag::err_multiple_mem_initialization)\n      << Field->getDeclName()\n      << Init->getSourceRange();\n  else {\n    const Type *BaseClass = Init->getBaseClass();\n    assert(BaseClass && \"neither field nor base\");\n    S.Diag(Init->getSourceLocation(),\n           diag::err_multiple_base_initialization)\n      << QualType(BaseClass, 0)\n      << Init->getSourceRange();\n  }\n  S.Diag(PrevInit->getSourceLocation(), diag::note_previous_initializer)\n    << 0 << PrevInit->getSourceRange();\n\n  return true;\n}\n\ntypedef std::pair<NamedDecl *, CXXCtorInitializer *> UnionEntry;\ntypedef llvm::DenseMap<RecordDecl*, UnionEntry> RedundantUnionMap;\n\nbool CheckRedundantUnionInit(Sema &S,\n                             CXXCtorInitializer *Init,\n                             RedundantUnionMap &Unions) {\n  FieldDecl *Field = Init->getAnyMember();\n  RecordDecl *Parent = Field->getParent();\n  NamedDecl *Child = Field;\n\n  while (Parent->isAnonymousStructOrUnion() || Parent->isUnion()) {\n    if (Parent->isUnion()) {\n      UnionEntry &En = Unions[Parent];\n      if (En.first && En.first != Child) {\n        S.Diag(Init->getSourceLocation(),\n               diag::err_multiple_mem_union_initialization)\n          << Field->getDeclName()\n          << Init->getSourceRange();\n        S.Diag(En.second->getSourceLocation(), diag::note_previous_initializer)\n          << 0 << En.second->getSourceRange();\n        return true;\n      }\n      if (!En.first) {\n        En.first = Child;\n        En.second = Init;\n      }\n      if (!Parent->isAnonymousStructOrUnion())\n        return false;\n    }\n\n    Child = Parent;\n    Parent = cast<RecordDecl>(Parent->getDeclContext());\n  }\n\n  return false;\n}\n}\n\n/// ActOnMemInitializers - Handle the member initializers for a constructor.\nvoid Sema::ActOnMemInitializers(Decl *ConstructorDecl,\n                                SourceLocation ColonLoc,\n                                ArrayRef<CXXCtorInitializer*> MemInits,\n                                bool AnyErrors) {\n  if (!ConstructorDecl)\n    return;\n\n  AdjustDeclIfTemplate(ConstructorDecl);\n\n  CXXConstructorDecl *Constructor\n    = dyn_cast<CXXConstructorDecl>(ConstructorDecl);\n\n  if (!Constructor) {\n    Diag(ColonLoc, diag::err_only_constructors_take_base_inits);\n    return;\n  }\n\n  // Mapping for the duplicate initializers check.\n  // For member initializers, this is keyed with a FieldDecl*.\n  // For base initializers, this is keyed with a Type*.\n  llvm::DenseMap<const void *, CXXCtorInitializer *> Members;\n\n  // Mapping for the inconsistent anonymous-union initializers check.\n  RedundantUnionMap MemberUnions;\n\n  bool HadError = false;\n  for (unsigned i = 0; i < MemInits.size(); i++) {\n    CXXCtorInitializer *Init = MemInits[i];\n\n    // Set the source order index.\n    Init->setSourceOrder(i);\n\n    if (Init->isAnyMemberInitializer()) {\n      const void *Key = GetKeyForMember(Context, Init);\n      if (CheckRedundantInit(*this, Init, Members[Key]) ||\n          CheckRedundantUnionInit(*this, Init, MemberUnions))\n        HadError = true;\n    } else if (Init->isBaseInitializer()) {\n      const void *Key = GetKeyForMember(Context, Init);\n      if (CheckRedundantInit(*this, Init, Members[Key]))\n        HadError = true;\n    } else {\n      assert(Init->isDelegatingInitializer());\n      // This must be the only initializer\n      if (MemInits.size() != 1) {\n        Diag(Init->getSourceLocation(),\n             diag::err_delegating_initializer_alone)\n          << Init->getSourceRange() << MemInits[i ? 0 : 1]->getSourceRange();\n        // We will treat this as being the only initializer.\n      }\n      SetDelegatingInitializer(Constructor, MemInits[i]);\n      // Return immediately as the initializer is set.\n      return;\n    }\n  }\n\n  if (HadError)\n    return;\n\n  DiagnoseBaseOrMemInitializerOrder(*this, Constructor, MemInits);\n\n  SetCtorInitializers(Constructor, AnyErrors, MemInits);\n\n  DiagnoseUninitializedFields(*this, Constructor);\n}\n\nvoid\nSema::MarkBaseAndMemberDestructorsReferenced(SourceLocation Location,\n                                             CXXRecordDecl *ClassDecl) {\n  // Ignore dependent contexts. Also ignore unions, since their members never\n  // have destructors implicitly called.\n  if (ClassDecl->isDependentContext() || ClassDecl->isUnion())\n    return;\n\n  // FIXME: all the access-control diagnostics are positioned on the\n  // field/base declaration.  That's probably good; that said, the\n  // user might reasonably want to know why the destructor is being\n  // emitted, and we currently don't say.\n\n  // Non-static data members.\n  for (auto *Field : ClassDecl->fields()) {\n    if (Field->isInvalidDecl())\n      continue;\n\n    // Don't destroy incomplete or zero-length arrays.\n    if (isIncompleteOrZeroLengthArrayType(Context, Field->getType()))\n      continue;\n\n    QualType FieldType = Context.getBaseElementType(Field->getType());\n\n    const RecordType* RT = FieldType->getAs<RecordType>();\n    if (!RT)\n      continue;\n\n    CXXRecordDecl *FieldClassDecl = cast<CXXRecordDecl>(RT->getDecl());\n    if (FieldClassDecl->isInvalidDecl())\n      continue;\n    if (FieldClassDecl->hasIrrelevantDestructor())\n      continue;\n    // The destructor for an implicit anonymous union member is never invoked.\n    if (FieldClassDecl->isUnion() && FieldClassDecl->isAnonymousStructOrUnion())\n      continue;\n\n    CXXDestructorDecl *Dtor = LookupDestructor(FieldClassDecl);\n    assert(Dtor && \"No dtor found for FieldClassDecl!\");\n    CheckDestructorAccess(Field->getLocation(), Dtor,\n                          PDiag(diag::err_access_dtor_field)\n                            << Field->getDeclName()\n                            << FieldType);\n\n    MarkFunctionReferenced(Location, Dtor);\n    DiagnoseUseOfDecl(Dtor, Location);\n  }\n\n  // We only potentially invoke the destructors of potentially constructed\n  // subobjects.\n  bool VisitVirtualBases = !ClassDecl->isAbstract();\n\n  // If the destructor exists and has already been marked used in the MS ABI,\n  // then virtual base destructors have already been checked and marked used.\n  // Skip checking them again to avoid duplicate diagnostics.\n  if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    CXXDestructorDecl *Dtor = ClassDecl->getDestructor();\n    if (Dtor && Dtor->isUsed())\n      VisitVirtualBases = false;\n  }\n\n  llvm::SmallPtrSet<const RecordType *, 8> DirectVirtualBases;\n\n  // Bases.\n  for (const auto &Base : ClassDecl->bases()) {\n    const RecordType *RT = Base.getType()->getAs<RecordType>();\n    if (!RT)\n      continue;\n\n    // Remember direct virtual bases.\n    if (Base.isVirtual()) {\n      if (!VisitVirtualBases)\n        continue;\n      DirectVirtualBases.insert(RT);\n    }\n\n    CXXRecordDecl *BaseClassDecl = cast<CXXRecordDecl>(RT->getDecl());\n    // If our base class is invalid, we probably can't get its dtor anyway.\n    if (BaseClassDecl->isInvalidDecl())\n      continue;\n    if (BaseClassDecl->hasIrrelevantDestructor())\n      continue;\n\n    CXXDestructorDecl *Dtor = LookupDestructor(BaseClassDecl);\n    assert(Dtor && \"No dtor found for BaseClassDecl!\");\n\n    // FIXME: caret should be on the start of the class name\n    CheckDestructorAccess(Base.getBeginLoc(), Dtor,\n                          PDiag(diag::err_access_dtor_base)\n                              << Base.getType() << Base.getSourceRange(),\n                          Context.getTypeDeclType(ClassDecl));\n\n    MarkFunctionReferenced(Location, Dtor);\n    DiagnoseUseOfDecl(Dtor, Location);\n  }\n\n  if (VisitVirtualBases)\n    MarkVirtualBaseDestructorsReferenced(Location, ClassDecl,\n                                         &DirectVirtualBases);\n}\n\nvoid Sema::MarkVirtualBaseDestructorsReferenced(\n    SourceLocation Location, CXXRecordDecl *ClassDecl,\n    llvm::SmallPtrSetImpl<const RecordType *> *DirectVirtualBases) {\n  // Virtual bases.\n  for (const auto &VBase : ClassDecl->vbases()) {\n    // Bases are always records in a well-formed non-dependent class.\n    const RecordType *RT = VBase.getType()->castAs<RecordType>();\n\n    // Ignore already visited direct virtual bases.\n    if (DirectVirtualBases && DirectVirtualBases->count(RT))\n      continue;\n\n    CXXRecordDecl *BaseClassDecl = cast<CXXRecordDecl>(RT->getDecl());\n    // If our base class is invalid, we probably can't get its dtor anyway.\n    if (BaseClassDecl->isInvalidDecl())\n      continue;\n    if (BaseClassDecl->hasIrrelevantDestructor())\n      continue;\n\n    CXXDestructorDecl *Dtor = LookupDestructor(BaseClassDecl);\n    assert(Dtor && \"No dtor found for BaseClassDecl!\");\n    if (CheckDestructorAccess(\n            ClassDecl->getLocation(), Dtor,\n            PDiag(diag::err_access_dtor_vbase)\n                << Context.getTypeDeclType(ClassDecl) << VBase.getType(),\n            Context.getTypeDeclType(ClassDecl)) ==\n        AR_accessible) {\n      CheckDerivedToBaseConversion(\n          Context.getTypeDeclType(ClassDecl), VBase.getType(),\n          diag::err_access_dtor_vbase, 0, ClassDecl->getLocation(),\n          SourceRange(), DeclarationName(), nullptr);\n    }\n\n    MarkFunctionReferenced(Location, Dtor);\n    DiagnoseUseOfDecl(Dtor, Location);\n  }\n}\n\nvoid Sema::ActOnDefaultCtorInitializers(Decl *CDtorDecl) {\n  if (!CDtorDecl)\n    return;\n\n  if (CXXConstructorDecl *Constructor\n      = dyn_cast<CXXConstructorDecl>(CDtorDecl)) {\n    SetCtorInitializers(Constructor, /*AnyErrors=*/false);\n    DiagnoseUninitializedFields(*this, Constructor);\n  }\n}\n\nbool Sema::isAbstractType(SourceLocation Loc, QualType T) {\n  if (!getLangOpts().CPlusPlus)\n    return false;\n\n  const auto *RD = Context.getBaseElementType(T)->getAsCXXRecordDecl();\n  if (!RD)\n    return false;\n\n  // FIXME: Per [temp.inst]p1, we are supposed to trigger instantiation of a\n  // class template specialization here, but doing so breaks a lot of code.\n\n  // We can't answer whether something is abstract until it has a\n  // definition. If it's currently being defined, we'll walk back\n  // over all the declarations when we have a full definition.\n  const CXXRecordDecl *Def = RD->getDefinition();\n  if (!Def || Def->isBeingDefined())\n    return false;\n\n  return RD->isAbstract();\n}\n\nbool Sema::RequireNonAbstractType(SourceLocation Loc, QualType T,\n                                  TypeDiagnoser &Diagnoser) {\n  if (!isAbstractType(Loc, T))\n    return false;\n\n  T = Context.getBaseElementType(T);\n  Diagnoser.diagnose(*this, Loc, T);\n  DiagnoseAbstractType(T->getAsCXXRecordDecl());\n  return true;\n}\n\nvoid Sema::DiagnoseAbstractType(const CXXRecordDecl *RD) {\n  // Check if we've already emitted the list of pure virtual functions\n  // for this class.\n  if (PureVirtualClassDiagSet && PureVirtualClassDiagSet->count(RD))\n    return;\n\n  // If the diagnostic is suppressed, don't emit the notes. We're only\n  // going to emit them once, so try to attach them to a diagnostic we're\n  // actually going to show.\n  if (Diags.isLastDiagnosticIgnored())\n    return;\n\n  CXXFinalOverriderMap FinalOverriders;\n  RD->getFinalOverriders(FinalOverriders);\n\n  // Keep a set of seen pure methods so we won't diagnose the same method\n  // more than once.\n  llvm::SmallPtrSet<const CXXMethodDecl *, 8> SeenPureMethods;\n\n  for (CXXFinalOverriderMap::iterator M = FinalOverriders.begin(),\n                                   MEnd = FinalOverriders.end();\n       M != MEnd;\n       ++M) {\n    for (OverridingMethods::iterator SO = M->second.begin(),\n                                  SOEnd = M->second.end();\n         SO != SOEnd; ++SO) {\n      // C++ [class.abstract]p4:\n      //   A class is abstract if it contains or inherits at least one\n      //   pure virtual function for which the final overrider is pure\n      //   virtual.\n\n      //\n      if (SO->second.size() != 1)\n        continue;\n\n      if (!SO->second.front().Method->isPure())\n        continue;\n\n      if (!SeenPureMethods.insert(SO->second.front().Method).second)\n        continue;\n\n      Diag(SO->second.front().Method->getLocation(),\n           diag::note_pure_virtual_function)\n        << SO->second.front().Method->getDeclName() << RD->getDeclName();\n    }\n  }\n\n  if (!PureVirtualClassDiagSet)\n    PureVirtualClassDiagSet.reset(new RecordDeclSetTy);\n  PureVirtualClassDiagSet->insert(RD);\n}\n\nnamespace {\nstruct AbstractUsageInfo {\n  Sema &S;\n  CXXRecordDecl *Record;\n  CanQualType AbstractType;\n  bool Invalid;\n\n  AbstractUsageInfo(Sema &S, CXXRecordDecl *Record)\n    : S(S), Record(Record),\n      AbstractType(S.Context.getCanonicalType(\n                   S.Context.getTypeDeclType(Record))),\n      Invalid(false) {}\n\n  void DiagnoseAbstractType() {\n    if (Invalid) return;\n    S.DiagnoseAbstractType(Record);\n    Invalid = true;\n  }\n\n  void CheckType(const NamedDecl *D, TypeLoc TL, Sema::AbstractDiagSelID Sel);\n};\n\nstruct CheckAbstractUsage {\n  AbstractUsageInfo &Info;\n  const NamedDecl *Ctx;\n\n  CheckAbstractUsage(AbstractUsageInfo &Info, const NamedDecl *Ctx)\n    : Info(Info), Ctx(Ctx) {}\n\n  void Visit(TypeLoc TL, Sema::AbstractDiagSelID Sel) {\n    switch (TL.getTypeLocClass()) {\n#define ABSTRACT_TYPELOC(CLASS, PARENT)\n#define TYPELOC(CLASS, PARENT) \\\n    case TypeLoc::CLASS: Check(TL.castAs<CLASS##TypeLoc>(), Sel); break;\n#include \"clang/AST/TypeLocNodes.def\"\n    }\n  }\n\n  void Check(FunctionProtoTypeLoc TL, Sema::AbstractDiagSelID Sel) {\n    Visit(TL.getReturnLoc(), Sema::AbstractReturnType);\n    for (unsigned I = 0, E = TL.getNumParams(); I != E; ++I) {\n      if (!TL.getParam(I))\n        continue;\n\n      TypeSourceInfo *TSI = TL.getParam(I)->getTypeSourceInfo();\n      if (TSI) Visit(TSI->getTypeLoc(), Sema::AbstractParamType);\n    }\n  }\n\n  void Check(ArrayTypeLoc TL, Sema::AbstractDiagSelID Sel) {\n    Visit(TL.getElementLoc(), Sema::AbstractArrayType);\n  }\n\n  void Check(TemplateSpecializationTypeLoc TL, Sema::AbstractDiagSelID Sel) {\n    // Visit the type parameters from a permissive context.\n    for (unsigned I = 0, E = TL.getNumArgs(); I != E; ++I) {\n      TemplateArgumentLoc TAL = TL.getArgLoc(I);\n      if (TAL.getArgument().getKind() == TemplateArgument::Type)\n        if (TypeSourceInfo *TSI = TAL.getTypeSourceInfo())\n          Visit(TSI->getTypeLoc(), Sema::AbstractNone);\n      // TODO: other template argument types?\n    }\n  }\n\n  // Visit pointee types from a permissive context.\n#define CheckPolymorphic(Type) \\\n  void Check(Type TL, Sema::AbstractDiagSelID Sel) { \\\n    Visit(TL.getNextTypeLoc(), Sema::AbstractNone); \\\n  }\n  CheckPolymorphic(PointerTypeLoc)\n  CheckPolymorphic(ReferenceTypeLoc)\n  CheckPolymorphic(MemberPointerTypeLoc)\n  CheckPolymorphic(BlockPointerTypeLoc)\n  CheckPolymorphic(AtomicTypeLoc)\n\n  /// Handle all the types we haven't given a more specific\n  /// implementation for above.\n  void Check(TypeLoc TL, Sema::AbstractDiagSelID Sel) {\n    // Every other kind of type that we haven't called out already\n    // that has an inner type is either (1) sugar or (2) contains that\n    // inner type in some way as a subobject.\n    if (TypeLoc Next = TL.getNextTypeLoc())\n      return Visit(Next, Sel);\n\n    // If there's no inner type and we're in a permissive context,\n    // don't diagnose.\n    if (Sel == Sema::AbstractNone) return;\n\n    // Check whether the type matches the abstract type.\n    QualType T = TL.getType();\n    if (T->isArrayType()) {\n      Sel = Sema::AbstractArrayType;\n      T = Info.S.Context.getBaseElementType(T);\n    }\n    CanQualType CT = T->getCanonicalTypeUnqualified().getUnqualifiedType();\n    if (CT != Info.AbstractType) return;\n\n    // It matched; do some magic.\n    if (Sel == Sema::AbstractArrayType) {\n      Info.S.Diag(Ctx->getLocation(), diag::err_array_of_abstract_type)\n        << T << TL.getSourceRange();\n    } else {\n      Info.S.Diag(Ctx->getLocation(), diag::err_abstract_type_in_decl)\n        << Sel << T << TL.getSourceRange();\n    }\n    Info.DiagnoseAbstractType();\n  }\n};\n\nvoid AbstractUsageInfo::CheckType(const NamedDecl *D, TypeLoc TL,\n                                  Sema::AbstractDiagSelID Sel) {\n  CheckAbstractUsage(*this, D).Visit(TL, Sel);\n}\n\n}\n\n/// Check for invalid uses of an abstract type in a method declaration.\nstatic void CheckAbstractClassUsage(AbstractUsageInfo &Info,\n                                    CXXMethodDecl *MD) {\n  // No need to do the check on definitions, which require that\n  // the return/param types be complete.\n  if (MD->doesThisDeclarationHaveABody())\n    return;\n\n  // For safety's sake, just ignore it if we don't have type source\n  // information.  This should never happen for non-implicit methods,\n  // but...\n  if (TypeSourceInfo *TSI = MD->getTypeSourceInfo())\n    Info.CheckType(MD, TSI->getTypeLoc(), Sema::AbstractNone);\n}\n\n/// Check for invalid uses of an abstract type within a class definition.\nstatic void CheckAbstractClassUsage(AbstractUsageInfo &Info,\n                                    CXXRecordDecl *RD) {\n  for (auto *D : RD->decls()) {\n    if (D->isImplicit()) continue;\n\n    // Methods and method templates.\n    if (isa<CXXMethodDecl>(D)) {\n      CheckAbstractClassUsage(Info, cast<CXXMethodDecl>(D));\n    } else if (isa<FunctionTemplateDecl>(D)) {\n      FunctionDecl *FD = cast<FunctionTemplateDecl>(D)->getTemplatedDecl();\n      CheckAbstractClassUsage(Info, cast<CXXMethodDecl>(FD));\n\n    // Fields and static variables.\n    } else if (isa<FieldDecl>(D)) {\n      FieldDecl *FD = cast<FieldDecl>(D);\n      if (TypeSourceInfo *TSI = FD->getTypeSourceInfo())\n        Info.CheckType(FD, TSI->getTypeLoc(), Sema::AbstractFieldType);\n    } else if (isa<VarDecl>(D)) {\n      VarDecl *VD = cast<VarDecl>(D);\n      if (TypeSourceInfo *TSI = VD->getTypeSourceInfo())\n        Info.CheckType(VD, TSI->getTypeLoc(), Sema::AbstractVariableType);\n\n    // Nested classes and class templates.\n    } else if (isa<CXXRecordDecl>(D)) {\n      CheckAbstractClassUsage(Info, cast<CXXRecordDecl>(D));\n    } else if (isa<ClassTemplateDecl>(D)) {\n      CheckAbstractClassUsage(Info,\n                             cast<ClassTemplateDecl>(D)->getTemplatedDecl());\n    }\n  }\n}\n\nstatic void ReferenceDllExportedMembers(Sema &S, CXXRecordDecl *Class) {\n  Attr *ClassAttr = getDLLAttr(Class);\n  if (!ClassAttr)\n    return;\n\n  assert(ClassAttr->getKind() == attr::DLLExport);\n\n  TemplateSpecializationKind TSK = Class->getTemplateSpecializationKind();\n\n  if (TSK == TSK_ExplicitInstantiationDeclaration)\n    // Don't go any further if this is just an explicit instantiation\n    // declaration.\n    return;\n\n  // Add a context note to explain how we got to any diagnostics produced below.\n  struct MarkingClassDllexported {\n    Sema &S;\n    MarkingClassDllexported(Sema &S, CXXRecordDecl *Class,\n                            SourceLocation AttrLoc)\n        : S(S) {\n      Sema::CodeSynthesisContext Ctx;\n      Ctx.Kind = Sema::CodeSynthesisContext::MarkingClassDllexported;\n      Ctx.PointOfInstantiation = AttrLoc;\n      Ctx.Entity = Class;\n      S.pushCodeSynthesisContext(Ctx);\n    }\n    ~MarkingClassDllexported() {\n      S.popCodeSynthesisContext();\n    }\n  } MarkingDllexportedContext(S, Class, ClassAttr->getLocation());\n\n  if (S.Context.getTargetInfo().getTriple().isWindowsGNUEnvironment())\n    S.MarkVTableUsed(Class->getLocation(), Class, true);\n\n  for (Decl *Member : Class->decls()) {\n    // Defined static variables that are members of an exported base\n    // class must be marked export too.\n    auto *VD = dyn_cast<VarDecl>(Member);\n    if (VD && Member->getAttr<DLLExportAttr>() &&\n        VD->getStorageClass() == SC_Static &&\n        TSK == TSK_ImplicitInstantiation)\n      S.MarkVariableReferenced(VD->getLocation(), VD);\n\n    auto *MD = dyn_cast<CXXMethodDecl>(Member);\n    if (!MD)\n      continue;\n\n    if (Member->getAttr<DLLExportAttr>()) {\n      if (MD->isUserProvided()) {\n        // Instantiate non-default class member functions ...\n\n        // .. except for certain kinds of template specializations.\n        if (TSK == TSK_ImplicitInstantiation && !ClassAttr->isInherited())\n          continue;\n\n        S.MarkFunctionReferenced(Class->getLocation(), MD);\n\n        // The function will be passed to the consumer when its definition is\n        // encountered.\n      } else if (MD->isExplicitlyDefaulted()) {\n        // Synthesize and instantiate explicitly defaulted methods.\n        S.MarkFunctionReferenced(Class->getLocation(), MD);\n\n        if (TSK != TSK_ExplicitInstantiationDefinition) {\n          // Except for explicit instantiation defs, we will not see the\n          // definition again later, so pass it to the consumer now.\n          S.Consumer.HandleTopLevelDecl(DeclGroupRef(MD));\n        }\n      } else if (!MD->isTrivial() ||\n                 MD->isCopyAssignmentOperator() ||\n                 MD->isMoveAssignmentOperator()) {\n        // Synthesize and instantiate non-trivial implicit methods, and the copy\n        // and move assignment operators. The latter are exported even if they\n        // are trivial, because the address of an operator can be taken and\n        // should compare equal across libraries.\n        S.MarkFunctionReferenced(Class->getLocation(), MD);\n\n        // There is no later point when we will see the definition of this\n        // function, so pass it to the consumer now.\n        S.Consumer.HandleTopLevelDecl(DeclGroupRef(MD));\n      }\n    }\n  }\n}\n\nstatic void checkForMultipleExportedDefaultConstructors(Sema &S,\n                                                        CXXRecordDecl *Class) {\n  // Only the MS ABI has default constructor closures, so we don't need to do\n  // this semantic checking anywhere else.\n  if (!S.Context.getTargetInfo().getCXXABI().isMicrosoft())\n    return;\n\n  CXXConstructorDecl *LastExportedDefaultCtor = nullptr;\n  for (Decl *Member : Class->decls()) {\n    // Look for exported default constructors.\n    auto *CD = dyn_cast<CXXConstructorDecl>(Member);\n    if (!CD || !CD->isDefaultConstructor())\n      continue;\n    auto *Attr = CD->getAttr<DLLExportAttr>();\n    if (!Attr)\n      continue;\n\n    // If the class is non-dependent, mark the default arguments as ODR-used so\n    // that we can properly codegen the constructor closure.\n    if (!Class->isDependentContext()) {\n      for (ParmVarDecl *PD : CD->parameters()) {\n        (void)S.CheckCXXDefaultArgExpr(Attr->getLocation(), CD, PD);\n        S.DiscardCleanupsInEvaluationContext();\n      }\n    }\n\n    if (LastExportedDefaultCtor) {\n      S.Diag(LastExportedDefaultCtor->getLocation(),\n             diag::err_attribute_dll_ambiguous_default_ctor)\n          << Class;\n      S.Diag(CD->getLocation(), diag::note_entity_declared_at)\n          << CD->getDeclName();\n      return;\n    }\n    LastExportedDefaultCtor = CD;\n  }\n}\n\nstatic void checkCUDADeviceBuiltinSurfaceClassTemplate(Sema &S,\n                                                       CXXRecordDecl *Class) {\n  bool ErrorReported = false;\n  auto reportIllegalClassTemplate = [&ErrorReported](Sema &S,\n                                                     ClassTemplateDecl *TD) {\n    if (ErrorReported)\n      return;\n    S.Diag(TD->getLocation(),\n           diag::err_cuda_device_builtin_surftex_cls_template)\n        << /*surface*/ 0 << TD;\n    ErrorReported = true;\n  };\n\n  ClassTemplateDecl *TD = Class->getDescribedClassTemplate();\n  if (!TD) {\n    auto *SD = dyn_cast<ClassTemplateSpecializationDecl>(Class);\n    if (!SD) {\n      S.Diag(Class->getLocation(),\n             diag::err_cuda_device_builtin_surftex_ref_decl)\n          << /*surface*/ 0 << Class;\n      S.Diag(Class->getLocation(),\n             diag::note_cuda_device_builtin_surftex_should_be_template_class)\n          << Class;\n      return;\n    }\n    TD = SD->getSpecializedTemplate();\n  }\n\n  TemplateParameterList *Params = TD->getTemplateParameters();\n  unsigned N = Params->size();\n\n  if (N != 2) {\n    reportIllegalClassTemplate(S, TD);\n    S.Diag(TD->getLocation(),\n           diag::note_cuda_device_builtin_surftex_cls_should_have_n_args)\n        << TD << 2;\n  }\n  if (N > 0 && !isa<TemplateTypeParmDecl>(Params->getParam(0))) {\n    reportIllegalClassTemplate(S, TD);\n    S.Diag(TD->getLocation(),\n           diag::note_cuda_device_builtin_surftex_cls_should_have_match_arg)\n        << TD << /*1st*/ 0 << /*type*/ 0;\n  }\n  if (N > 1) {\n    auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Params->getParam(1));\n    if (!NTTP || !NTTP->getType()->isIntegralOrEnumerationType()) {\n      reportIllegalClassTemplate(S, TD);\n      S.Diag(TD->getLocation(),\n             diag::note_cuda_device_builtin_surftex_cls_should_have_match_arg)\n          << TD << /*2nd*/ 1 << /*integer*/ 1;\n    }\n  }\n}\n\nstatic void checkCUDADeviceBuiltinTextureClassTemplate(Sema &S,\n                                                       CXXRecordDecl *Class) {\n  bool ErrorReported = false;\n  auto reportIllegalClassTemplate = [&ErrorReported](Sema &S,\n                                                     ClassTemplateDecl *TD) {\n    if (ErrorReported)\n      return;\n    S.Diag(TD->getLocation(),\n           diag::err_cuda_device_builtin_surftex_cls_template)\n        << /*texture*/ 1 << TD;\n    ErrorReported = true;\n  };\n\n  ClassTemplateDecl *TD = Class->getDescribedClassTemplate();\n  if (!TD) {\n    auto *SD = dyn_cast<ClassTemplateSpecializationDecl>(Class);\n    if (!SD) {\n      S.Diag(Class->getLocation(),\n             diag::err_cuda_device_builtin_surftex_ref_decl)\n          << /*texture*/ 1 << Class;\n      S.Diag(Class->getLocation(),\n             diag::note_cuda_device_builtin_surftex_should_be_template_class)\n          << Class;\n      return;\n    }\n    TD = SD->getSpecializedTemplate();\n  }\n\n  TemplateParameterList *Params = TD->getTemplateParameters();\n  unsigned N = Params->size();\n\n  if (N != 3) {\n    reportIllegalClassTemplate(S, TD);\n    S.Diag(TD->getLocation(),\n           diag::note_cuda_device_builtin_surftex_cls_should_have_n_args)\n        << TD << 3;\n  }\n  if (N > 0 && !isa<TemplateTypeParmDecl>(Params->getParam(0))) {\n    reportIllegalClassTemplate(S, TD);\n    S.Diag(TD->getLocation(),\n           diag::note_cuda_device_builtin_surftex_cls_should_have_match_arg)\n        << TD << /*1st*/ 0 << /*type*/ 0;\n  }\n  if (N > 1) {\n    auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Params->getParam(1));\n    if (!NTTP || !NTTP->getType()->isIntegralOrEnumerationType()) {\n      reportIllegalClassTemplate(S, TD);\n      S.Diag(TD->getLocation(),\n             diag::note_cuda_device_builtin_surftex_cls_should_have_match_arg)\n          << TD << /*2nd*/ 1 << /*integer*/ 1;\n    }\n  }\n  if (N > 2) {\n    auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Params->getParam(2));\n    if (!NTTP || !NTTP->getType()->isIntegralOrEnumerationType()) {\n      reportIllegalClassTemplate(S, TD);\n      S.Diag(TD->getLocation(),\n             diag::note_cuda_device_builtin_surftex_cls_should_have_match_arg)\n          << TD << /*3rd*/ 2 << /*integer*/ 1;\n    }\n  }\n}\n\nvoid Sema::checkClassLevelCodeSegAttribute(CXXRecordDecl *Class) {\n  // Mark any compiler-generated routines with the implicit code_seg attribute.\n  for (auto *Method : Class->methods()) {\n    if (Method->isUserProvided())\n      continue;\n    if (Attr *A = getImplicitCodeSegOrSectionAttrForFunction(Method, /*IsDefinition=*/true))\n      Method->addAttr(A);\n  }\n}\n\n/// Check class-level dllimport/dllexport attribute.\nvoid Sema::checkClassLevelDLLAttribute(CXXRecordDecl *Class) {\n  Attr *ClassAttr = getDLLAttr(Class);\n\n  // MSVC inherits DLL attributes to partial class template specializations.\n  if (Context.getTargetInfo().shouldDLLImportComdatSymbols() && !ClassAttr) {\n    if (auto *Spec = dyn_cast<ClassTemplatePartialSpecializationDecl>(Class)) {\n      if (Attr *TemplateAttr =\n              getDLLAttr(Spec->getSpecializedTemplate()->getTemplatedDecl())) {\n        auto *A = cast<InheritableAttr>(TemplateAttr->clone(getASTContext()));\n        A->setInherited(true);\n        ClassAttr = A;\n      }\n    }\n  }\n\n  if (!ClassAttr)\n    return;\n\n  if (!Class->isExternallyVisible()) {\n    Diag(Class->getLocation(), diag::err_attribute_dll_not_extern)\n        << Class << ClassAttr;\n    return;\n  }\n\n  if (Context.getTargetInfo().shouldDLLImportComdatSymbols() &&\n      !ClassAttr->isInherited()) {\n    // Diagnose dll attributes on members of class with dll attribute.\n    for (Decl *Member : Class->decls()) {\n      if (!isa<VarDecl>(Member) && !isa<CXXMethodDecl>(Member))\n        continue;\n      InheritableAttr *MemberAttr = getDLLAttr(Member);\n      if (!MemberAttr || MemberAttr->isInherited() || Member->isInvalidDecl())\n        continue;\n\n      Diag(MemberAttr->getLocation(),\n             diag::err_attribute_dll_member_of_dll_class)\n          << MemberAttr << ClassAttr;\n      Diag(ClassAttr->getLocation(), diag::note_previous_attribute);\n      Member->setInvalidDecl();\n    }\n  }\n\n  if (Class->getDescribedClassTemplate())\n    // Don't inherit dll attribute until the template is instantiated.\n    return;\n\n  // The class is either imported or exported.\n  const bool ClassExported = ClassAttr->getKind() == attr::DLLExport;\n\n  // Check if this was a dllimport attribute propagated from a derived class to\n  // a base class template specialization. We don't apply these attributes to\n  // static data members.\n  const bool PropagatedImport =\n      !ClassExported &&\n      cast<DLLImportAttr>(ClassAttr)->wasPropagatedToBaseTemplate();\n\n  TemplateSpecializationKind TSK = Class->getTemplateSpecializationKind();\n\n  // Ignore explicit dllexport on explicit class template instantiation\n  // declarations, except in MinGW mode.\n  if (ClassExported && !ClassAttr->isInherited() &&\n      TSK == TSK_ExplicitInstantiationDeclaration &&\n      !Context.getTargetInfo().getTriple().isWindowsGNUEnvironment()) {\n    Class->dropAttr<DLLExportAttr>();\n    return;\n  }\n\n  // Force declaration of implicit members so they can inherit the attribute.\n  ForceDeclarationOfImplicitMembers(Class);\n\n  // FIXME: MSVC's docs say all bases must be exportable, but this doesn't\n  // seem to be true in practice?\n\n  for (Decl *Member : Class->decls()) {\n    VarDecl *VD = dyn_cast<VarDecl>(Member);\n    CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(Member);\n\n    // Only methods and static fields inherit the attributes.\n    if (!VD && !MD)\n      continue;\n\n    if (MD) {\n      // Don't process deleted methods.\n      if (MD->isDeleted())\n        continue;\n\n      if (MD->isInlined()) {\n        // MinGW does not import or export inline methods. But do it for\n        // template instantiations.\n        if (!Context.getTargetInfo().shouldDLLImportComdatSymbols() &&\n            TSK != TSK_ExplicitInstantiationDeclaration &&\n            TSK != TSK_ExplicitInstantiationDefinition)\n          continue;\n\n        // MSVC versions before 2015 don't export the move assignment operators\n        // and move constructor, so don't attempt to import/export them if\n        // we have a definition.\n        auto *Ctor = dyn_cast<CXXConstructorDecl>(MD);\n        if ((MD->isMoveAssignmentOperator() ||\n             (Ctor && Ctor->isMoveConstructor())) &&\n            !getLangOpts().isCompatibleWithMSVC(LangOptions::MSVC2015))\n          continue;\n\n        // MSVC2015 doesn't export trivial defaulted x-tor but copy assign\n        // operator is exported anyway.\n        if (getLangOpts().isCompatibleWithMSVC(LangOptions::MSVC2015) &&\n            (Ctor || isa<CXXDestructorDecl>(MD)) && MD->isTrivial())\n          continue;\n      }\n    }\n\n    // Don't apply dllimport attributes to static data members of class template\n    // instantiations when the attribute is propagated from a derived class.\n    if (VD && PropagatedImport)\n      continue;\n\n    if (!cast<NamedDecl>(Member)->isExternallyVisible())\n      continue;\n\n    if (!getDLLAttr(Member)) {\n      InheritableAttr *NewAttr = nullptr;\n\n      // Do not export/import inline function when -fno-dllexport-inlines is\n      // passed. But add attribute for later local static var check.\n      if (!getLangOpts().DllExportInlines && MD && MD->isInlined() &&\n          TSK != TSK_ExplicitInstantiationDeclaration &&\n          TSK != TSK_ExplicitInstantiationDefinition) {\n        if (ClassExported) {\n          NewAttr = ::new (getASTContext())\n              DLLExportStaticLocalAttr(getASTContext(), *ClassAttr);\n        } else {\n          NewAttr = ::new (getASTContext())\n              DLLImportStaticLocalAttr(getASTContext(), *ClassAttr);\n        }\n      } else {\n        NewAttr = cast<InheritableAttr>(ClassAttr->clone(getASTContext()));\n      }\n\n      NewAttr->setInherited(true);\n      Member->addAttr(NewAttr);\n\n      if (MD) {\n        // Propagate DLLAttr to friend re-declarations of MD that have already\n        // been constructed.\n        for (FunctionDecl *FD = MD->getMostRecentDecl(); FD;\n             FD = FD->getPreviousDecl()) {\n          if (FD->getFriendObjectKind() == Decl::FOK_None)\n            continue;\n          assert(!getDLLAttr(FD) &&\n                 \"friend re-decl should not already have a DLLAttr\");\n          NewAttr = cast<InheritableAttr>(ClassAttr->clone(getASTContext()));\n          NewAttr->setInherited(true);\n          FD->addAttr(NewAttr);\n        }\n      }\n    }\n  }\n\n  if (ClassExported)\n    DelayedDllExportClasses.push_back(Class);\n}\n\n/// Perform propagation of DLL attributes from a derived class to a\n/// templated base class for MS compatibility.\nvoid Sema::propagateDLLAttrToBaseClassTemplate(\n    CXXRecordDecl *Class, Attr *ClassAttr,\n    ClassTemplateSpecializationDecl *BaseTemplateSpec, SourceLocation BaseLoc) {\n  if (getDLLAttr(\n          BaseTemplateSpec->getSpecializedTemplate()->getTemplatedDecl())) {\n    // If the base class template has a DLL attribute, don't try to change it.\n    return;\n  }\n\n  auto TSK = BaseTemplateSpec->getSpecializationKind();\n  if (!getDLLAttr(BaseTemplateSpec) &&\n      (TSK == TSK_Undeclared || TSK == TSK_ExplicitInstantiationDeclaration ||\n       TSK == TSK_ImplicitInstantiation)) {\n    // The template hasn't been instantiated yet (or it has, but only as an\n    // explicit instantiation declaration or implicit instantiation, which means\n    // we haven't codegenned any members yet), so propagate the attribute.\n    auto *NewAttr = cast<InheritableAttr>(ClassAttr->clone(getASTContext()));\n    NewAttr->setInherited(true);\n    BaseTemplateSpec->addAttr(NewAttr);\n\n    // If this was an import, mark that we propagated it from a derived class to\n    // a base class template specialization.\n    if (auto *ImportAttr = dyn_cast<DLLImportAttr>(NewAttr))\n      ImportAttr->setPropagatedToBaseTemplate();\n\n    // If the template is already instantiated, checkDLLAttributeRedeclaration()\n    // needs to be run again to work see the new attribute. Otherwise this will\n    // get run whenever the template is instantiated.\n    if (TSK != TSK_Undeclared)\n      checkClassLevelDLLAttribute(BaseTemplateSpec);\n\n    return;\n  }\n\n  if (getDLLAttr(BaseTemplateSpec)) {\n    // The template has already been specialized or instantiated with an\n    // attribute, explicitly or through propagation. We should not try to change\n    // it.\n    return;\n  }\n\n  // The template was previously instantiated or explicitly specialized without\n  // a dll attribute, It's too late for us to add an attribute, so warn that\n  // this is unsupported.\n  Diag(BaseLoc, diag::warn_attribute_dll_instantiated_base_class)\n      << BaseTemplateSpec->isExplicitSpecialization();\n  Diag(ClassAttr->getLocation(), diag::note_attribute);\n  if (BaseTemplateSpec->isExplicitSpecialization()) {\n    Diag(BaseTemplateSpec->getLocation(),\n           diag::note_template_class_explicit_specialization_was_here)\n        << BaseTemplateSpec;\n  } else {\n    Diag(BaseTemplateSpec->getPointOfInstantiation(),\n           diag::note_template_class_instantiation_was_here)\n        << BaseTemplateSpec;\n  }\n}\n\n/// Determine the kind of defaulting that would be done for a given function.\n///\n/// If the function is both a default constructor and a copy / move constructor\n/// (due to having a default argument for the first parameter), this picks\n/// CXXDefaultConstructor.\n///\n/// FIXME: Check that case is properly handled by all callers.\nSema::DefaultedFunctionKind\nSema::getDefaultedFunctionKind(const FunctionDecl *FD) {\n  if (auto *MD = dyn_cast<CXXMethodDecl>(FD)) {\n    if (const CXXConstructorDecl *Ctor = dyn_cast<CXXConstructorDecl>(FD)) {\n      if (Ctor->isDefaultConstructor())\n        return Sema::CXXDefaultConstructor;\n\n      if (Ctor->isCopyConstructor())\n        return Sema::CXXCopyConstructor;\n\n      if (Ctor->isMoveConstructor())\n        return Sema::CXXMoveConstructor;\n    }\n\n    if (MD->isCopyAssignmentOperator())\n      return Sema::CXXCopyAssignment;\n\n    if (MD->isMoveAssignmentOperator())\n      return Sema::CXXMoveAssignment;\n\n    if (isa<CXXDestructorDecl>(FD))\n      return Sema::CXXDestructor;\n  }\n\n  switch (FD->getDeclName().getCXXOverloadedOperator()) {\n  case OO_EqualEqual:\n    return DefaultedComparisonKind::Equal;\n\n  case OO_ExclaimEqual:\n    return DefaultedComparisonKind::NotEqual;\n\n  case OO_Spaceship:\n    // No point allowing this if <=> doesn't exist in the current language mode.\n    if (!getLangOpts().CPlusPlus20)\n      break;\n    return DefaultedComparisonKind::ThreeWay;\n\n  case OO_Less:\n  case OO_LessEqual:\n  case OO_Greater:\n  case OO_GreaterEqual:\n    // No point allowing this if <=> doesn't exist in the current language mode.\n    if (!getLangOpts().CPlusPlus20)\n      break;\n    return DefaultedComparisonKind::Relational;\n\n  default:\n    break;\n  }\n\n  // Not defaultable.\n  return DefaultedFunctionKind();\n}\n\nstatic void DefineDefaultedFunction(Sema &S, FunctionDecl *FD,\n                                    SourceLocation DefaultLoc) {\n  Sema::DefaultedFunctionKind DFK = S.getDefaultedFunctionKind(FD);\n  if (DFK.isComparison())\n    return S.DefineDefaultedComparison(DefaultLoc, FD, DFK.asComparison());\n\n  switch (DFK.asSpecialMember()) {\n  case Sema::CXXDefaultConstructor:\n    S.DefineImplicitDefaultConstructor(DefaultLoc,\n                                       cast<CXXConstructorDecl>(FD));\n    break;\n  case Sema::CXXCopyConstructor:\n    S.DefineImplicitCopyConstructor(DefaultLoc, cast<CXXConstructorDecl>(FD));\n    break;\n  case Sema::CXXCopyAssignment:\n    S.DefineImplicitCopyAssignment(DefaultLoc, cast<CXXMethodDecl>(FD));\n    break;\n  case Sema::CXXDestructor:\n    S.DefineImplicitDestructor(DefaultLoc, cast<CXXDestructorDecl>(FD));\n    break;\n  case Sema::CXXMoveConstructor:\n    S.DefineImplicitMoveConstructor(DefaultLoc, cast<CXXConstructorDecl>(FD));\n    break;\n  case Sema::CXXMoveAssignment:\n    S.DefineImplicitMoveAssignment(DefaultLoc, cast<CXXMethodDecl>(FD));\n    break;\n  case Sema::CXXInvalid:\n    llvm_unreachable(\"Invalid special member.\");\n  }\n}\n\n/// Determine whether a type is permitted to be passed or returned in\n/// registers, per C++ [class.temporary]p3.\nstatic bool canPassInRegisters(Sema &S, CXXRecordDecl *D,\n                               TargetInfo::CallingConvKind CCK) {\n  if (D->isDependentType() || D->isInvalidDecl())\n    return false;\n\n  // Clang <= 4 used the pre-C++11 rule, which ignores move operations.\n  // The PS4 platform ABI follows the behavior of Clang 3.2.\n  if (CCK == TargetInfo::CCK_ClangABI4OrPS4)\n    return !D->hasNonTrivialDestructorForCall() &&\n           !D->hasNonTrivialCopyConstructorForCall();\n\n  if (CCK == TargetInfo::CCK_MicrosoftWin64) {\n    bool CopyCtorIsTrivial = false, CopyCtorIsTrivialForCall = false;\n    bool DtorIsTrivialForCall = false;\n\n    // If a class has at least one non-deleted, trivial copy constructor, it\n    // is passed according to the C ABI. Otherwise, it is passed indirectly.\n    //\n    // Note: This permits classes with non-trivial copy or move ctors to be\n    // passed in registers, so long as they *also* have a trivial copy ctor,\n    // which is non-conforming.\n    if (D->needsImplicitCopyConstructor()) {\n      if (!D->defaultedCopyConstructorIsDeleted()) {\n        if (D->hasTrivialCopyConstructor())\n          CopyCtorIsTrivial = true;\n        if (D->hasTrivialCopyConstructorForCall())\n          CopyCtorIsTrivialForCall = true;\n      }\n    } else {\n      for (const CXXConstructorDecl *CD : D->ctors()) {\n        if (CD->isCopyConstructor() && !CD->isDeleted()) {\n          if (CD->isTrivial())\n            CopyCtorIsTrivial = true;\n          if (CD->isTrivialForCall())\n            CopyCtorIsTrivialForCall = true;\n        }\n      }\n    }\n\n    if (D->needsImplicitDestructor()) {\n      if (!D->defaultedDestructorIsDeleted() &&\n          D->hasTrivialDestructorForCall())\n        DtorIsTrivialForCall = true;\n    } else if (const auto *DD = D->getDestructor()) {\n      if (!DD->isDeleted() && DD->isTrivialForCall())\n        DtorIsTrivialForCall = true;\n    }\n\n    // If the copy ctor and dtor are both trivial-for-calls, pass direct.\n    if (CopyCtorIsTrivialForCall && DtorIsTrivialForCall)\n      return true;\n\n    // If a class has a destructor, we'd really like to pass it indirectly\n    // because it allows us to elide copies.  Unfortunately, MSVC makes that\n    // impossible for small types, which it will pass in a single register or\n    // stack slot. Most objects with dtors are large-ish, so handle that early.\n    // We can't call out all large objects as being indirect because there are\n    // multiple x64 calling conventions and the C++ ABI code shouldn't dictate\n    // how we pass large POD types.\n\n    // Note: This permits small classes with nontrivial destructors to be\n    // passed in registers, which is non-conforming.\n    bool isAArch64 = S.Context.getTargetInfo().getTriple().isAArch64();\n    uint64_t TypeSize = isAArch64 ? 128 : 64;\n\n    if (CopyCtorIsTrivial &&\n        S.getASTContext().getTypeSize(D->getTypeForDecl()) <= TypeSize)\n      return true;\n    return false;\n  }\n\n  // Per C++ [class.temporary]p3, the relevant condition is:\n  //   each copy constructor, move constructor, and destructor of X is\n  //   either trivial or deleted, and X has at least one non-deleted copy\n  //   or move constructor\n  bool HasNonDeletedCopyOrMove = false;\n\n  if (D->needsImplicitCopyConstructor() &&\n      !D->defaultedCopyConstructorIsDeleted()) {\n    if (!D->hasTrivialCopyConstructorForCall())\n      return false;\n    HasNonDeletedCopyOrMove = true;\n  }\n\n  if (S.getLangOpts().CPlusPlus11 && D->needsImplicitMoveConstructor() &&\n      !D->defaultedMoveConstructorIsDeleted()) {\n    if (!D->hasTrivialMoveConstructorForCall())\n      return false;\n    HasNonDeletedCopyOrMove = true;\n  }\n\n  if (D->needsImplicitDestructor() && !D->defaultedDestructorIsDeleted() &&\n      !D->hasTrivialDestructorForCall())\n    return false;\n\n  for (const CXXMethodDecl *MD : D->methods()) {\n    if (MD->isDeleted())\n      continue;\n\n    auto *CD = dyn_cast<CXXConstructorDecl>(MD);\n    if (CD && CD->isCopyOrMoveConstructor())\n      HasNonDeletedCopyOrMove = true;\n    else if (!isa<CXXDestructorDecl>(MD))\n      continue;\n\n    if (!MD->isTrivialForCall())\n      return false;\n  }\n\n  return HasNonDeletedCopyOrMove;\n}\n\n/// Report an error regarding overriding, along with any relevant\n/// overridden methods.\n///\n/// \\param DiagID the primary error to report.\n/// \\param MD the overriding method.\nstatic bool\nReportOverrides(Sema &S, unsigned DiagID, const CXXMethodDecl *MD,\n                llvm::function_ref<bool(const CXXMethodDecl *)> Report) {\n  bool IssuedDiagnostic = false;\n  for (const CXXMethodDecl *O : MD->overridden_methods()) {\n    if (Report(O)) {\n      if (!IssuedDiagnostic) {\n        S.Diag(MD->getLocation(), DiagID) << MD->getDeclName();\n        IssuedDiagnostic = true;\n      }\n      S.Diag(O->getLocation(), diag::note_overridden_virtual_function);\n    }\n  }\n  return IssuedDiagnostic;\n}\n\n/// Perform semantic checks on a class definition that has been\n/// completing, introducing implicitly-declared members, checking for\n/// abstract types, etc.\n///\n/// \\param S The scope in which the class was parsed. Null if we didn't just\n///        parse a class definition.\n/// \\param Record The completed class.\nvoid Sema::CheckCompletedCXXClass(Scope *S, CXXRecordDecl *Record) {\n  if (!Record)\n    return;\n\n  if (Record->isAbstract() && !Record->isInvalidDecl()) {\n    AbstractUsageInfo Info(*this, Record);\n    CheckAbstractClassUsage(Info, Record);\n  }\n\n  // If this is not an aggregate type and has no user-declared constructor,\n  // complain about any non-static data members of reference or const scalar\n  // type, since they will never get initializers.\n  if (!Record->isInvalidDecl() && !Record->isDependentType() &&\n      !Record->isAggregate() && !Record->hasUserDeclaredConstructor() &&\n      !Record->isLambda()) {\n    bool Complained = false;\n    for (const auto *F : Record->fields()) {\n      if (F->hasInClassInitializer() || F->isUnnamedBitfield())\n        continue;\n\n      if (F->getType()->isReferenceType() ||\n          (F->getType().isConstQualified() && F->getType()->isScalarType())) {\n        if (!Complained) {\n          Diag(Record->getLocation(), diag::warn_no_constructor_for_refconst)\n            << Record->getTagKind() << Record;\n          Complained = true;\n        }\n\n        Diag(F->getLocation(), diag::note_refconst_member_not_initialized)\n          << F->getType()->isReferenceType()\n          << F->getDeclName();\n      }\n    }\n  }\n\n  if (Record->getIdentifier()) {\n    // C++ [class.mem]p13:\n    //   If T is the name of a class, then each of the following shall have a\n    //   name different from T:\n    //     - every member of every anonymous union that is a member of class T.\n    //\n    // C++ [class.mem]p14:\n    //   In addition, if class T has a user-declared constructor (12.1), every\n    //   non-static data member of class T shall have a name different from T.\n    DeclContext::lookup_result R = Record->lookup(Record->getDeclName());\n    for (DeclContext::lookup_iterator I = R.begin(), E = R.end(); I != E;\n         ++I) {\n      NamedDecl *D = (*I)->getUnderlyingDecl();\n      if (((isa<FieldDecl>(D) || isa<UnresolvedUsingValueDecl>(D)) &&\n           Record->hasUserDeclaredConstructor()) ||\n          isa<IndirectFieldDecl>(D)) {\n        Diag((*I)->getLocation(), diag::err_member_name_of_class)\n          << D->getDeclName();\n        break;\n      }\n    }\n  }\n\n  // Warn if the class has virtual methods but non-virtual public destructor.\n  if (Record->isPolymorphic() && !Record->isDependentType()) {\n    CXXDestructorDecl *dtor = Record->getDestructor();\n    if ((!dtor || (!dtor->isVirtual() && dtor->getAccess() == AS_public)) &&\n        !Record->hasAttr<FinalAttr>())\n      Diag(dtor ? dtor->getLocation() : Record->getLocation(),\n           diag::warn_non_virtual_dtor) << Context.getRecordType(Record);\n  }\n\n  if (Record->isAbstract()) {\n    if (FinalAttr *FA = Record->getAttr<FinalAttr>()) {\n      Diag(Record->getLocation(), diag::warn_abstract_final_class)\n        << FA->isSpelledAsSealed();\n      DiagnoseAbstractType(Record);\n    }\n  }\n\n  // Warn if the class has a final destructor but is not itself marked final.\n  if (!Record->hasAttr<FinalAttr>()) {\n    if (const CXXDestructorDecl *dtor = Record->getDestructor()) {\n      if (const FinalAttr *FA = dtor->getAttr<FinalAttr>()) {\n        Diag(FA->getLocation(), diag::warn_final_dtor_non_final_class)\n            << FA->isSpelledAsSealed()\n            << FixItHint::CreateInsertion(\n                   getLocForEndOfToken(Record->getLocation()),\n                   (FA->isSpelledAsSealed() ? \" sealed\" : \" final\"));\n        Diag(Record->getLocation(),\n             diag::note_final_dtor_non_final_class_silence)\n            << Context.getRecordType(Record) << FA->isSpelledAsSealed();\n      }\n    }\n  }\n\n  // See if trivial_abi has to be dropped.\n  if (Record->hasAttr<TrivialABIAttr>())\n    checkIllFormedTrivialABIStruct(*Record);\n\n  // Set HasTrivialSpecialMemberForCall if the record has attribute\n  // \"trivial_abi\".\n  bool HasTrivialABI = Record->hasAttr<TrivialABIAttr>();\n\n  if (HasTrivialABI)\n    Record->setHasTrivialSpecialMemberForCall();\n\n  // Explicitly-defaulted secondary comparison functions (!=, <, <=, >, >=).\n  // We check these last because they can depend on the properties of the\n  // primary comparison functions (==, <=>).\n  llvm::SmallVector<FunctionDecl*, 5> DefaultedSecondaryComparisons;\n\n  // Perform checks that can't be done until we know all the properties of a\n  // member function (whether it's defaulted, deleted, virtual, overriding,\n  // ...).\n  auto CheckCompletedMemberFunction = [&](CXXMethodDecl *MD) {\n    // A static function cannot override anything.\n    if (MD->getStorageClass() == SC_Static) {\n      if (ReportOverrides(*this, diag::err_static_overrides_virtual, MD,\n                          [](const CXXMethodDecl *) { return true; }))\n        return;\n    }\n\n    // A deleted function cannot override a non-deleted function and vice\n    // versa.\n    if (ReportOverrides(*this,\n                        MD->isDeleted() ? diag::err_deleted_override\n                                        : diag::err_non_deleted_override,\n                        MD, [&](const CXXMethodDecl *V) {\n                          return MD->isDeleted() != V->isDeleted();\n                        })) {\n      if (MD->isDefaulted() && MD->isDeleted())\n        // Explain why this defaulted function was deleted.\n        DiagnoseDeletedDefaultedFunction(MD);\n      return;\n    }\n\n    // A consteval function cannot override a non-consteval function and vice\n    // versa.\n    if (ReportOverrides(*this,\n                        MD->isConsteval() ? diag::err_consteval_override\n                                          : diag::err_non_consteval_override,\n                        MD, [&](const CXXMethodDecl *V) {\n                          return MD->isConsteval() != V->isConsteval();\n                        })) {\n      if (MD->isDefaulted() && MD->isDeleted())\n        // Explain why this defaulted function was deleted.\n        DiagnoseDeletedDefaultedFunction(MD);\n      return;\n    }\n  };\n\n  auto CheckForDefaultedFunction = [&](FunctionDecl *FD) -> bool {\n    if (!FD || FD->isInvalidDecl() || !FD->isExplicitlyDefaulted())\n      return false;\n\n    DefaultedFunctionKind DFK = getDefaultedFunctionKind(FD);\n    if (DFK.asComparison() == DefaultedComparisonKind::NotEqual ||\n        DFK.asComparison() == DefaultedComparisonKind::Relational) {\n      DefaultedSecondaryComparisons.push_back(FD);\n      return true;\n    }\n\n    CheckExplicitlyDefaultedFunction(S, FD);\n    return false;\n  };\n\n  auto CompleteMemberFunction = [&](CXXMethodDecl *M) {\n    // Check whether the explicitly-defaulted members are valid.\n    bool Incomplete = CheckForDefaultedFunction(M);\n\n    // Skip the rest of the checks for a member of a dependent class.\n    if (Record->isDependentType())\n      return;\n\n    // For an explicitly defaulted or deleted special member, we defer\n    // determining triviality until the class is complete. That time is now!\n    CXXSpecialMember CSM = getSpecialMember(M);\n    if (!M->isImplicit() && !M->isUserProvided()) {\n      if (CSM != CXXInvalid) {\n        M->setTrivial(SpecialMemberIsTrivial(M, CSM));\n        // Inform the class that we've finished declaring this member.\n        Record->finishedDefaultedOrDeletedMember(M);\n        M->setTrivialForCall(\n            HasTrivialABI ||\n            SpecialMemberIsTrivial(M, CSM, TAH_ConsiderTrivialABI));\n        Record->setTrivialForCallFlags(M);\n      }\n    }\n\n    // Set triviality for the purpose of calls if this is a user-provided\n    // copy/move constructor or destructor.\n    if ((CSM == CXXCopyConstructor || CSM == CXXMoveConstructor ||\n         CSM == CXXDestructor) && M->isUserProvided()) {\n      M->setTrivialForCall(HasTrivialABI);\n      Record->setTrivialForCallFlags(M);\n    }\n\n    if (!M->isInvalidDecl() && M->isExplicitlyDefaulted() &&\n        M->hasAttr<DLLExportAttr>()) {\n      if (getLangOpts().isCompatibleWithMSVC(LangOptions::MSVC2015) &&\n          M->isTrivial() &&\n          (CSM == CXXDefaultConstructor || CSM == CXXCopyConstructor ||\n           CSM == CXXDestructor))\n        M->dropAttr<DLLExportAttr>();\n\n      if (M->hasAttr<DLLExportAttr>()) {\n        // Define after any fields with in-class initializers have been parsed.\n        DelayedDllExportMemberFunctions.push_back(M);\n      }\n    }\n\n    // Define defaulted constexpr virtual functions that override a base class\n    // function right away.\n    // FIXME: We can defer doing this until the vtable is marked as used.\n    if (M->isDefaulted() && M->isConstexpr() && M->size_overridden_methods())\n      DefineDefaultedFunction(*this, M, M->getLocation());\n\n    if (!Incomplete)\n      CheckCompletedMemberFunction(M);\n  };\n\n  // Check the destructor before any other member function. We need to\n  // determine whether it's trivial in order to determine whether the claas\n  // type is a literal type, which is a prerequisite for determining whether\n  // other special member functions are valid and whether they're implicitly\n  // 'constexpr'.\n  if (CXXDestructorDecl *Dtor = Record->getDestructor())\n    CompleteMemberFunction(Dtor);\n\n  bool HasMethodWithOverrideControl = false,\n       HasOverridingMethodWithoutOverrideControl = false;\n  for (auto *D : Record->decls()) {\n    if (auto *M = dyn_cast<CXXMethodDecl>(D)) {\n      // FIXME: We could do this check for dependent types with non-dependent\n      // bases.\n      if (!Record->isDependentType()) {\n        // See if a method overloads virtual methods in a base\n        // class without overriding any.\n        if (!M->isStatic())\n          DiagnoseHiddenVirtualMethods(M);\n        if (M->hasAttr<OverrideAttr>())\n          HasMethodWithOverrideControl = true;\n        else if (M->size_overridden_methods() > 0)\n          HasOverridingMethodWithoutOverrideControl = true;\n      }\n\n      if (!isa<CXXDestructorDecl>(M))\n        CompleteMemberFunction(M);\n    } else if (auto *F = dyn_cast<FriendDecl>(D)) {\n      CheckForDefaultedFunction(\n          dyn_cast_or_null<FunctionDecl>(F->getFriendDecl()));\n    }\n  }\n\n  if (HasOverridingMethodWithoutOverrideControl) {\n    bool HasInconsistentOverrideControl = HasMethodWithOverrideControl;\n    for (auto *M : Record->methods())\n      DiagnoseAbsenceOfOverrideControl(M, HasInconsistentOverrideControl);\n  }\n\n  // Check the defaulted secondary comparisons after any other member functions.\n  for (FunctionDecl *FD : DefaultedSecondaryComparisons) {\n    CheckExplicitlyDefaultedFunction(S, FD);\n\n    // If this is a member function, we deferred checking it until now.\n    if (auto *MD = dyn_cast<CXXMethodDecl>(FD))\n      CheckCompletedMemberFunction(MD);\n  }\n\n  // ms_struct is a request to use the same ABI rules as MSVC.  Check\n  // whether this class uses any C++ features that are implemented\n  // completely differently in MSVC, and if so, emit a diagnostic.\n  // That diagnostic defaults to an error, but we allow projects to\n  // map it down to a warning (or ignore it).  It's a fairly common\n  // practice among users of the ms_struct pragma to mass-annotate\n  // headers, sweeping up a bunch of types that the project doesn't\n  // really rely on MSVC-compatible layout for.  We must therefore\n  // support \"ms_struct except for C++ stuff\" as a secondary ABI.\n  // Don't emit this diagnostic if the feature was enabled as a\n  // language option (as opposed to via a pragma or attribute), as\n  // the option -mms-bitfields otherwise essentially makes it impossible\n  // to build C++ code, unless this diagnostic is turned off.\n  if (Record->isMsStruct(Context) && !Context.getLangOpts().MSBitfields &&\n      (Record->isPolymorphic() || Record->getNumBases())) {\n    Diag(Record->getLocation(), diag::warn_cxx_ms_struct);\n  }\n\n  checkClassLevelDLLAttribute(Record);\n  checkClassLevelCodeSegAttribute(Record);\n\n  bool ClangABICompat4 =\n      Context.getLangOpts().getClangABICompat() <= LangOptions::ClangABI::Ver4;\n  TargetInfo::CallingConvKind CCK =\n      Context.getTargetInfo().getCallingConvKind(ClangABICompat4);\n  bool CanPass = canPassInRegisters(*this, Record, CCK);\n\n  // Do not change ArgPassingRestrictions if it has already been set to\n  // APK_CanNeverPassInRegs.\n  if (Record->getArgPassingRestrictions() != RecordDecl::APK_CanNeverPassInRegs)\n    Record->setArgPassingRestrictions(CanPass\n                                          ? RecordDecl::APK_CanPassInRegs\n                                          : RecordDecl::APK_CannotPassInRegs);\n\n  // If canPassInRegisters returns true despite the record having a non-trivial\n  // destructor, the record is destructed in the callee. This happens only when\n  // the record or one of its subobjects has a field annotated with trivial_abi\n  // or a field qualified with ObjC __strong/__weak.\n  if (Context.getTargetInfo().getCXXABI().areArgsDestroyedLeftToRightInCallee())\n    Record->setParamDestroyedInCallee(true);\n  else if (Record->hasNonTrivialDestructor())\n    Record->setParamDestroyedInCallee(CanPass);\n\n  if (getLangOpts().ForceEmitVTables) {\n    // If we want to emit all the vtables, we need to mark it as used.  This\n    // is especially required for cases like vtable assumption loads.\n    MarkVTableUsed(Record->getInnerLocStart(), Record);\n  }\n\n  if (getLangOpts().CUDA) {\n    if (Record->hasAttr<CUDADeviceBuiltinSurfaceTypeAttr>())\n      checkCUDADeviceBuiltinSurfaceClassTemplate(*this, Record);\n    else if (Record->hasAttr<CUDADeviceBuiltinTextureTypeAttr>())\n      checkCUDADeviceBuiltinTextureClassTemplate(*this, Record);\n  }\n}\n\n/// Look up the special member function that would be called by a special\n/// member function for a subobject of class type.\n///\n/// \\param Class The class type of the subobject.\n/// \\param CSM The kind of special member function.\n/// \\param FieldQuals If the subobject is a field, its cv-qualifiers.\n/// \\param ConstRHS True if this is a copy operation with a const object\n///        on its RHS, that is, if the argument to the outer special member\n///        function is 'const' and this is not a field marked 'mutable'.\nstatic Sema::SpecialMemberOverloadResult lookupCallFromSpecialMember(\n    Sema &S, CXXRecordDecl *Class, Sema::CXXSpecialMember CSM,\n    unsigned FieldQuals, bool ConstRHS) {\n  unsigned LHSQuals = 0;\n  if (CSM == Sema::CXXCopyAssignment || CSM == Sema::CXXMoveAssignment)\n    LHSQuals = FieldQuals;\n\n  unsigned RHSQuals = FieldQuals;\n  if (CSM == Sema::CXXDefaultConstructor || CSM == Sema::CXXDestructor)\n    RHSQuals = 0;\n  else if (ConstRHS)\n    RHSQuals |= Qualifiers::Const;\n\n  return S.LookupSpecialMember(Class, CSM,\n                               RHSQuals & Qualifiers::Const,\n                               RHSQuals & Qualifiers::Volatile,\n                               false,\n                               LHSQuals & Qualifiers::Const,\n                               LHSQuals & Qualifiers::Volatile);\n}\n\nclass Sema::InheritedConstructorInfo {\n  Sema &S;\n  SourceLocation UseLoc;\n\n  /// A mapping from the base classes through which the constructor was\n  /// inherited to the using shadow declaration in that base class (or a null\n  /// pointer if the constructor was declared in that base class).\n  llvm::DenseMap<CXXRecordDecl *, ConstructorUsingShadowDecl *>\n      InheritedFromBases;\n\npublic:\n  InheritedConstructorInfo(Sema &S, SourceLocation UseLoc,\n                           ConstructorUsingShadowDecl *Shadow)\n      : S(S), UseLoc(UseLoc) {\n    bool DiagnosedMultipleConstructedBases = false;\n    CXXRecordDecl *ConstructedBase = nullptr;\n    UsingDecl *ConstructedBaseUsing = nullptr;\n\n    // Find the set of such base class subobjects and check that there's a\n    // unique constructed subobject.\n    for (auto *D : Shadow->redecls()) {\n      auto *DShadow = cast<ConstructorUsingShadowDecl>(D);\n      auto *DNominatedBase = DShadow->getNominatedBaseClass();\n      auto *DConstructedBase = DShadow->getConstructedBaseClass();\n\n      InheritedFromBases.insert(\n          std::make_pair(DNominatedBase->getCanonicalDecl(),\n                         DShadow->getNominatedBaseClassShadowDecl()));\n      if (DShadow->constructsVirtualBase())\n        InheritedFromBases.insert(\n            std::make_pair(DConstructedBase->getCanonicalDecl(),\n                           DShadow->getConstructedBaseClassShadowDecl()));\n      else\n        assert(DNominatedBase == DConstructedBase);\n\n      // [class.inhctor.init]p2:\n      //   If the constructor was inherited from multiple base class subobjects\n      //   of type B, the program is ill-formed.\n      if (!ConstructedBase) {\n        ConstructedBase = DConstructedBase;\n        ConstructedBaseUsing = D->getUsingDecl();\n      } else if (ConstructedBase != DConstructedBase &&\n                 !Shadow->isInvalidDecl()) {\n        if (!DiagnosedMultipleConstructedBases) {\n          S.Diag(UseLoc, diag::err_ambiguous_inherited_constructor)\n              << Shadow->getTargetDecl();\n          S.Diag(ConstructedBaseUsing->getLocation(),\n               diag::note_ambiguous_inherited_constructor_using)\n              << ConstructedBase;\n          DiagnosedMultipleConstructedBases = true;\n        }\n        S.Diag(D->getUsingDecl()->getLocation(),\n               diag::note_ambiguous_inherited_constructor_using)\n            << DConstructedBase;\n      }\n    }\n\n    if (DiagnosedMultipleConstructedBases)\n      Shadow->setInvalidDecl();\n  }\n\n  /// Find the constructor to use for inherited construction of a base class,\n  /// and whether that base class constructor inherits the constructor from a\n  /// virtual base class (in which case it won't actually invoke it).\n  std::pair<CXXConstructorDecl *, bool>\n  findConstructorForBase(CXXRecordDecl *Base, CXXConstructorDecl *Ctor) const {\n    auto It = InheritedFromBases.find(Base->getCanonicalDecl());\n    if (It == InheritedFromBases.end())\n      return std::make_pair(nullptr, false);\n\n    // This is an intermediary class.\n    if (It->second)\n      return std::make_pair(\n          S.findInheritingConstructor(UseLoc, Ctor, It->second),\n          It->second->constructsVirtualBase());\n\n    // This is the base class from which the constructor was inherited.\n    return std::make_pair(Ctor, false);\n  }\n};\n\n/// Is the special member function which would be selected to perform the\n/// specified operation on the specified class type a constexpr constructor?\nstatic bool\nspecialMemberIsConstexpr(Sema &S, CXXRecordDecl *ClassDecl,\n                         Sema::CXXSpecialMember CSM, unsigned Quals,\n                         bool ConstRHS,\n                         CXXConstructorDecl *InheritedCtor = nullptr,\n                         Sema::InheritedConstructorInfo *Inherited = nullptr) {\n  // If we're inheriting a constructor, see if we need to call it for this base\n  // class.\n  if (InheritedCtor) {\n    assert(CSM == Sema::CXXDefaultConstructor);\n    auto BaseCtor =\n        Inherited->findConstructorForBase(ClassDecl, InheritedCtor).first;\n    if (BaseCtor)\n      return BaseCtor->isConstexpr();\n  }\n\n  if (CSM == Sema::CXXDefaultConstructor)\n    return ClassDecl->hasConstexprDefaultConstructor();\n  if (CSM == Sema::CXXDestructor)\n    return ClassDecl->hasConstexprDestructor();\n\n  Sema::SpecialMemberOverloadResult SMOR =\n      lookupCallFromSpecialMember(S, ClassDecl, CSM, Quals, ConstRHS);\n  if (!SMOR.getMethod())\n    // A constructor we wouldn't select can't be \"involved in initializing\"\n    // anything.\n    return true;\n  return SMOR.getMethod()->isConstexpr();\n}\n\n/// Determine whether the specified special member function would be constexpr\n/// if it were implicitly defined.\nstatic bool defaultedSpecialMemberIsConstexpr(\n    Sema &S, CXXRecordDecl *ClassDecl, Sema::CXXSpecialMember CSM,\n    bool ConstArg, CXXConstructorDecl *InheritedCtor = nullptr,\n    Sema::InheritedConstructorInfo *Inherited = nullptr) {\n  if (!S.getLangOpts().CPlusPlus11)\n    return false;\n\n  // C++11 [dcl.constexpr]p4:\n  // In the definition of a constexpr constructor [...]\n  bool Ctor = true;\n  switch (CSM) {\n  case Sema::CXXDefaultConstructor:\n    if (Inherited)\n      break;\n    // Since default constructor lookup is essentially trivial (and cannot\n    // involve, for instance, template instantiation), we compute whether a\n    // defaulted default constructor is constexpr directly within CXXRecordDecl.\n    //\n    // This is important for performance; we need to know whether the default\n    // constructor is constexpr to determine whether the type is a literal type.\n    return ClassDecl->defaultedDefaultConstructorIsConstexpr();\n\n  case Sema::CXXCopyConstructor:\n  case Sema::CXXMoveConstructor:\n    // For copy or move constructors, we need to perform overload resolution.\n    break;\n\n  case Sema::CXXCopyAssignment:\n  case Sema::CXXMoveAssignment:\n    if (!S.getLangOpts().CPlusPlus14)\n      return false;\n    // In C++1y, we need to perform overload resolution.\n    Ctor = false;\n    break;\n\n  case Sema::CXXDestructor:\n    return ClassDecl->defaultedDestructorIsConstexpr();\n\n  case Sema::CXXInvalid:\n    return false;\n  }\n\n  //   -- if the class is a non-empty union, or for each non-empty anonymous\n  //      union member of a non-union class, exactly one non-static data member\n  //      shall be initialized; [DR1359]\n  //\n  // If we squint, this is guaranteed, since exactly one non-static data member\n  // will be initialized (if the constructor isn't deleted), we just don't know\n  // which one.\n  if (Ctor && ClassDecl->isUnion())\n    return CSM == Sema::CXXDefaultConstructor\n               ? ClassDecl->hasInClassInitializer() ||\n                     !ClassDecl->hasVariantMembers()\n               : true;\n\n  //   -- the class shall not have any virtual base classes;\n  if (Ctor && ClassDecl->getNumVBases())\n    return false;\n\n  // C++1y [class.copy]p26:\n  //   -- [the class] is a literal type, and\n  if (!Ctor && !ClassDecl->isLiteral())\n    return false;\n\n  //   -- every constructor involved in initializing [...] base class\n  //      sub-objects shall be a constexpr constructor;\n  //   -- the assignment operator selected to copy/move each direct base\n  //      class is a constexpr function, and\n  for (const auto &B : ClassDecl->bases()) {\n    const RecordType *BaseType = B.getType()->getAs<RecordType>();\n    if (!BaseType) continue;\n\n    CXXRecordDecl *BaseClassDecl = cast<CXXRecordDecl>(BaseType->getDecl());\n    if (!specialMemberIsConstexpr(S, BaseClassDecl, CSM, 0, ConstArg,\n                                  InheritedCtor, Inherited))\n      return false;\n  }\n\n  //   -- every constructor involved in initializing non-static data members\n  //      [...] shall be a constexpr constructor;\n  //   -- every non-static data member and base class sub-object shall be\n  //      initialized\n  //   -- for each non-static data member of X that is of class type (or array\n  //      thereof), the assignment operator selected to copy/move that member is\n  //      a constexpr function\n  for (const auto *F : ClassDecl->fields()) {\n    if (F->isInvalidDecl())\n      continue;\n    if (CSM == Sema::CXXDefaultConstructor && F->hasInClassInitializer())\n      continue;\n    QualType BaseType = S.Context.getBaseElementType(F->getType());\n    if (const RecordType *RecordTy = BaseType->getAs<RecordType>()) {\n      CXXRecordDecl *FieldRecDecl = cast<CXXRecordDecl>(RecordTy->getDecl());\n      if (!specialMemberIsConstexpr(S, FieldRecDecl, CSM,\n                                    BaseType.getCVRQualifiers(),\n                                    ConstArg && !F->isMutable()))\n        return false;\n    } else if (CSM == Sema::CXXDefaultConstructor) {\n      return false;\n    }\n  }\n\n  // All OK, it's constexpr!\n  return true;\n}\n\nnamespace {\n/// RAII object to register a defaulted function as having its exception\n/// specification computed.\nstruct ComputingExceptionSpec {\n  Sema &S;\n\n  ComputingExceptionSpec(Sema &S, FunctionDecl *FD, SourceLocation Loc)\n      : S(S) {\n    Sema::CodeSynthesisContext Ctx;\n    Ctx.Kind = Sema::CodeSynthesisContext::ExceptionSpecEvaluation;\n    Ctx.PointOfInstantiation = Loc;\n    Ctx.Entity = FD;\n    S.pushCodeSynthesisContext(Ctx);\n  }\n  ~ComputingExceptionSpec() {\n    S.popCodeSynthesisContext();\n  }\n};\n}\n\nstatic Sema::ImplicitExceptionSpecification\nComputeDefaultedSpecialMemberExceptionSpec(\n    Sema &S, SourceLocation Loc, CXXMethodDecl *MD, Sema::CXXSpecialMember CSM,\n    Sema::InheritedConstructorInfo *ICI);\n\nstatic Sema::ImplicitExceptionSpecification\nComputeDefaultedComparisonExceptionSpec(Sema &S, SourceLocation Loc,\n                                        FunctionDecl *FD,\n                                        Sema::DefaultedComparisonKind DCK);\n\nstatic Sema::ImplicitExceptionSpecification\ncomputeImplicitExceptionSpec(Sema &S, SourceLocation Loc, FunctionDecl *FD) {\n  auto DFK = S.getDefaultedFunctionKind(FD);\n  if (DFK.isSpecialMember())\n    return ComputeDefaultedSpecialMemberExceptionSpec(\n        S, Loc, cast<CXXMethodDecl>(FD), DFK.asSpecialMember(), nullptr);\n  if (DFK.isComparison())\n    return ComputeDefaultedComparisonExceptionSpec(S, Loc, FD,\n                                                   DFK.asComparison());\n\n  auto *CD = cast<CXXConstructorDecl>(FD);\n  assert(CD->getInheritedConstructor() &&\n         \"only defaulted functions and inherited constructors have implicit \"\n         \"exception specs\");\n  Sema::InheritedConstructorInfo ICI(\n      S, Loc, CD->getInheritedConstructor().getShadowDecl());\n  return ComputeDefaultedSpecialMemberExceptionSpec(\n      S, Loc, CD, Sema::CXXDefaultConstructor, &ICI);\n}\n\nstatic FunctionProtoType::ExtProtoInfo getImplicitMethodEPI(Sema &S,\n                                                            CXXMethodDecl *MD) {\n  FunctionProtoType::ExtProtoInfo EPI;\n\n  // Build an exception specification pointing back at this member.\n  EPI.ExceptionSpec.Type = EST_Unevaluated;\n  EPI.ExceptionSpec.SourceDecl = MD;\n\n  // Set the calling convention to the default for C++ instance methods.\n  EPI.ExtInfo = EPI.ExtInfo.withCallingConv(\n      S.Context.getDefaultCallingConvention(/*IsVariadic=*/false,\n                                            /*IsCXXMethod=*/true));\n  return EPI;\n}\n\nvoid Sema::EvaluateImplicitExceptionSpec(SourceLocation Loc, FunctionDecl *FD) {\n  const FunctionProtoType *FPT = FD->getType()->castAs<FunctionProtoType>();\n  if (FPT->getExceptionSpecType() != EST_Unevaluated)\n    return;\n\n  // Evaluate the exception specification.\n  auto IES = computeImplicitExceptionSpec(*this, Loc, FD);\n  auto ESI = IES.getExceptionSpec();\n\n  // Update the type of the special member to use it.\n  UpdateExceptionSpec(FD, ESI);\n}\n\nvoid Sema::CheckExplicitlyDefaultedFunction(Scope *S, FunctionDecl *FD) {\n  assert(FD->isExplicitlyDefaulted() && \"not explicitly-defaulted\");\n\n  DefaultedFunctionKind DefKind = getDefaultedFunctionKind(FD);\n  if (!DefKind) {\n    assert(FD->getDeclContext()->isDependentContext());\n    return;\n  }\n\n  if (DefKind.isSpecialMember()\n          ? CheckExplicitlyDefaultedSpecialMember(cast<CXXMethodDecl>(FD),\n                                                  DefKind.asSpecialMember())\n          : CheckExplicitlyDefaultedComparison(S, FD, DefKind.asComparison()))\n    FD->setInvalidDecl();\n}\n\nbool Sema::CheckExplicitlyDefaultedSpecialMember(CXXMethodDecl *MD,\n                                                 CXXSpecialMember CSM) {\n  CXXRecordDecl *RD = MD->getParent();\n\n  assert(MD->isExplicitlyDefaulted() && CSM != CXXInvalid &&\n         \"not an explicitly-defaulted special member\");\n\n  // Defer all checking for special members of a dependent type.\n  if (RD->isDependentType())\n    return false;\n\n  // Whether this was the first-declared instance of the constructor.\n  // This affects whether we implicitly add an exception spec and constexpr.\n  bool First = MD == MD->getCanonicalDecl();\n\n  bool HadError = false;\n\n  // C++11 [dcl.fct.def.default]p1:\n  //   A function that is explicitly defaulted shall\n  //     -- be a special member function [...] (checked elsewhere),\n  //     -- have the same type (except for ref-qualifiers, and except that a\n  //        copy operation can take a non-const reference) as an implicit\n  //        declaration, and\n  //     -- not have default arguments.\n  // C++2a changes the second bullet to instead delete the function if it's\n  // defaulted on its first declaration, unless it's \"an assignment operator,\n  // and its return type differs or its parameter type is not a reference\".\n  bool DeleteOnTypeMismatch = getLangOpts().CPlusPlus20 && First;\n  bool ShouldDeleteForTypeMismatch = false;\n  unsigned ExpectedParams = 1;\n  if (CSM == CXXDefaultConstructor || CSM == CXXDestructor)\n    ExpectedParams = 0;\n  if (MD->getNumParams() != ExpectedParams) {\n    // This checks for default arguments: a copy or move constructor with a\n    // default argument is classified as a default constructor, and assignment\n    // operations and destructors can't have default arguments.\n    Diag(MD->getLocation(), diag::err_defaulted_special_member_params)\n      << CSM << MD->getSourceRange();\n    HadError = true;\n  } else if (MD->isVariadic()) {\n    if (DeleteOnTypeMismatch)\n      ShouldDeleteForTypeMismatch = true;\n    else {\n      Diag(MD->getLocation(), diag::err_defaulted_special_member_variadic)\n        << CSM << MD->getSourceRange();\n      HadError = true;\n    }\n  }\n\n  const FunctionProtoType *Type = MD->getType()->getAs<FunctionProtoType>();\n\n  bool CanHaveConstParam = false;\n  if (CSM == CXXCopyConstructor)\n    CanHaveConstParam = RD->implicitCopyConstructorHasConstParam();\n  else if (CSM == CXXCopyAssignment)\n    CanHaveConstParam = RD->implicitCopyAssignmentHasConstParam();\n\n  QualType ReturnType = Context.VoidTy;\n  if (CSM == CXXCopyAssignment || CSM == CXXMoveAssignment) {\n    // Check for return type matching.\n    ReturnType = Type->getReturnType();\n\n    QualType DeclType = Context.getTypeDeclType(RD);\n    DeclType = Context.getAddrSpaceQualType(DeclType, MD->getMethodQualifiers().getAddressSpace());\n    QualType ExpectedReturnType = Context.getLValueReferenceType(DeclType);\n\n    if (!Context.hasSameType(ReturnType, ExpectedReturnType)) {\n      Diag(MD->getLocation(), diag::err_defaulted_special_member_return_type)\n        << (CSM == CXXMoveAssignment) << ExpectedReturnType;\n      HadError = true;\n    }\n\n    // A defaulted special member cannot have cv-qualifiers.\n    if (Type->getMethodQuals().hasConst() || Type->getMethodQuals().hasVolatile()) {\n      if (DeleteOnTypeMismatch)\n        ShouldDeleteForTypeMismatch = true;\n      else {\n        Diag(MD->getLocation(), diag::err_defaulted_special_member_quals)\n          << (CSM == CXXMoveAssignment) << getLangOpts().CPlusPlus14;\n        HadError = true;\n      }\n    }\n  }\n\n  // Check for parameter type matching.\n  QualType ArgType = ExpectedParams ? Type->getParamType(0) : QualType();\n  bool HasConstParam = false;\n  if (ExpectedParams && ArgType->isReferenceType()) {\n    // Argument must be reference to possibly-const T.\n    QualType ReferentType = ArgType->getPointeeType();\n    HasConstParam = ReferentType.isConstQualified();\n\n    if (ReferentType.isVolatileQualified()) {\n      if (DeleteOnTypeMismatch)\n        ShouldDeleteForTypeMismatch = true;\n      else {\n        Diag(MD->getLocation(),\n             diag::err_defaulted_special_member_volatile_param) << CSM;\n        HadError = true;\n      }\n    }\n\n    if (HasConstParam && !CanHaveConstParam) {\n      if (DeleteOnTypeMismatch)\n        ShouldDeleteForTypeMismatch = true;\n      else if (CSM == CXXCopyConstructor || CSM == CXXCopyAssignment) {\n        Diag(MD->getLocation(),\n             diag::err_defaulted_special_member_copy_const_param)\n          << (CSM == CXXCopyAssignment);\n        // FIXME: Explain why this special member can't be const.\n        HadError = true;\n      } else {\n        Diag(MD->getLocation(),\n             diag::err_defaulted_special_member_move_const_param)\n          << (CSM == CXXMoveAssignment);\n        HadError = true;\n      }\n    }\n  } else if (ExpectedParams) {\n    // A copy assignment operator can take its argument by value, but a\n    // defaulted one cannot.\n    assert(CSM == CXXCopyAssignment && \"unexpected non-ref argument\");\n    Diag(MD->getLocation(), diag::err_defaulted_copy_assign_not_ref);\n    HadError = true;\n  }\n\n  // C++11 [dcl.fct.def.default]p2:\n  //   An explicitly-defaulted function may be declared constexpr only if it\n  //   would have been implicitly declared as constexpr,\n  // Do not apply this rule to members of class templates, since core issue 1358\n  // makes such functions always instantiate to constexpr functions. For\n  // functions which cannot be constexpr (for non-constructors in C++11 and for\n  // destructors in C++14 and C++17), this is checked elsewhere.\n  //\n  // FIXME: This should not apply if the member is deleted.\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, RD, CSM,\n                                                     HasConstParam);\n  if ((getLangOpts().CPlusPlus20 ||\n       (getLangOpts().CPlusPlus14 ? !isa<CXXDestructorDecl>(MD)\n                                  : isa<CXXConstructorDecl>(MD))) &&\n      MD->isConstexpr() && !Constexpr &&\n      MD->getTemplatedKind() == FunctionDecl::TK_NonTemplate) {\n    Diag(MD->getBeginLoc(), MD->isConsteval()\n                                ? diag::err_incorrect_defaulted_consteval\n                                : diag::err_incorrect_defaulted_constexpr)\n        << CSM;\n    // FIXME: Explain why the special member can't be constexpr.\n    HadError = true;\n  }\n\n  if (First) {\n    // C++2a [dcl.fct.def.default]p3:\n    //   If a function is explicitly defaulted on its first declaration, it is\n    //   implicitly considered to be constexpr if the implicit declaration\n    //   would be.\n    MD->setConstexprKind(Constexpr ? (MD->isConsteval()\n                                          ? ConstexprSpecKind::Consteval\n                                          : ConstexprSpecKind::Constexpr)\n                                   : ConstexprSpecKind::Unspecified);\n\n    if (!Type->hasExceptionSpec()) {\n      // C++2a [except.spec]p3:\n      //   If a declaration of a function does not have a noexcept-specifier\n      //   [and] is defaulted on its first declaration, [...] the exception\n      //   specification is as specified below\n      FunctionProtoType::ExtProtoInfo EPI = Type->getExtProtoInfo();\n      EPI.ExceptionSpec.Type = EST_Unevaluated;\n      EPI.ExceptionSpec.SourceDecl = MD;\n      MD->setType(Context.getFunctionType(ReturnType,\n                                          llvm::makeArrayRef(&ArgType,\n                                                             ExpectedParams),\n                                          EPI));\n    }\n  }\n\n  if (ShouldDeleteForTypeMismatch || ShouldDeleteSpecialMember(MD, CSM)) {\n    if (First) {\n      SetDeclDeleted(MD, MD->getLocation());\n      if (!inTemplateInstantiation() && !HadError) {\n        Diag(MD->getLocation(), diag::warn_defaulted_method_deleted) << CSM;\n        if (ShouldDeleteForTypeMismatch) {\n          Diag(MD->getLocation(), diag::note_deleted_type_mismatch) << CSM;\n        } else {\n          ShouldDeleteSpecialMember(MD, CSM, nullptr, /*Diagnose*/true);\n        }\n      }\n      if (ShouldDeleteForTypeMismatch && !HadError) {\n        Diag(MD->getLocation(),\n             diag::warn_cxx17_compat_defaulted_method_type_mismatch) << CSM;\n      }\n    } else {\n      // C++11 [dcl.fct.def.default]p4:\n      //   [For a] user-provided explicitly-defaulted function [...] if such a\n      //   function is implicitly defined as deleted, the program is ill-formed.\n      Diag(MD->getLocation(), diag::err_out_of_line_default_deletes) << CSM;\n      assert(!ShouldDeleteForTypeMismatch && \"deleted non-first decl\");\n      ShouldDeleteSpecialMember(MD, CSM, nullptr, /*Diagnose*/true);\n      HadError = true;\n    }\n  }\n\n  return HadError;\n}\n\nnamespace {\n/// Helper class for building and checking a defaulted comparison.\n///\n/// Defaulted functions are built in two phases:\n///\n///  * First, the set of operations that the function will perform are\n///    identified, and some of them are checked. If any of the checked\n///    operations is invalid in certain ways, the comparison function is\n///    defined as deleted and no body is built.\n///  * Then, if the function is not defined as deleted, the body is built.\n///\n/// This is accomplished by performing two visitation steps over the eventual\n/// body of the function.\ntemplate<typename Derived, typename ResultList, typename Result,\n         typename Subobject>\nclass DefaultedComparisonVisitor {\npublic:\n  using DefaultedComparisonKind = Sema::DefaultedComparisonKind;\n\n  DefaultedComparisonVisitor(Sema &S, CXXRecordDecl *RD, FunctionDecl *FD,\n                             DefaultedComparisonKind DCK)\n      : S(S), RD(RD), FD(FD), DCK(DCK) {\n    if (auto *Info = FD->getDefaultedFunctionInfo()) {\n      // FIXME: Change CreateOverloadedBinOp to take an ArrayRef instead of an\n      // UnresolvedSet to avoid this copy.\n      Fns.assign(Info->getUnqualifiedLookups().begin(),\n                 Info->getUnqualifiedLookups().end());\n    }\n  }\n\n  ResultList visit() {\n    // The type of an lvalue naming a parameter of this function.\n    QualType ParamLvalType =\n        FD->getParamDecl(0)->getType().getNonReferenceType();\n\n    ResultList Results;\n\n    switch (DCK) {\n    case DefaultedComparisonKind::None:\n      llvm_unreachable(\"not a defaulted comparison\");\n\n    case DefaultedComparisonKind::Equal:\n    case DefaultedComparisonKind::ThreeWay:\n      getDerived().visitSubobjects(Results, RD, ParamLvalType.getQualifiers());\n      return Results;\n\n    case DefaultedComparisonKind::NotEqual:\n    case DefaultedComparisonKind::Relational:\n      Results.add(getDerived().visitExpandedSubobject(\n          ParamLvalType, getDerived().getCompleteObject()));\n      return Results;\n    }\n    llvm_unreachable(\"\");\n  }\n\nprotected:\n  Derived &getDerived() { return static_cast<Derived&>(*this); }\n\n  /// Visit the expanded list of subobjects of the given type, as specified in\n  /// C++2a [class.compare.default].\n  ///\n  /// \\return \\c true if the ResultList object said we're done, \\c false if not.\n  bool visitSubobjects(ResultList &Results, CXXRecordDecl *Record,\n                       Qualifiers Quals) {\n    // C++2a [class.compare.default]p4:\n    //   The direct base class subobjects of C\n    for (CXXBaseSpecifier &Base : Record->bases())\n      if (Results.add(getDerived().visitSubobject(\n              S.Context.getQualifiedType(Base.getType(), Quals),\n              getDerived().getBase(&Base))))\n        return true;\n\n    //   followed by the non-static data members of C\n    for (FieldDecl *Field : Record->fields()) {\n      // Recursively expand anonymous structs.\n      if (Field->isAnonymousStructOrUnion()) {\n        if (visitSubobjects(Results, Field->getType()->getAsCXXRecordDecl(),\n                            Quals))\n          return true;\n        continue;\n      }\n\n      // Figure out the type of an lvalue denoting this field.\n      Qualifiers FieldQuals = Quals;\n      if (Field->isMutable())\n        FieldQuals.removeConst();\n      QualType FieldType =\n          S.Context.getQualifiedType(Field->getType(), FieldQuals);\n\n      if (Results.add(getDerived().visitSubobject(\n              FieldType, getDerived().getField(Field))))\n        return true;\n    }\n\n    //   form a list of subobjects.\n    return false;\n  }\n\n  Result visitSubobject(QualType Type, Subobject Subobj) {\n    //   In that list, any subobject of array type is recursively expanded\n    const ArrayType *AT = S.Context.getAsArrayType(Type);\n    if (auto *CAT = dyn_cast_or_null<ConstantArrayType>(AT))\n      return getDerived().visitSubobjectArray(CAT->getElementType(),\n                                              CAT->getSize(), Subobj);\n    return getDerived().visitExpandedSubobject(Type, Subobj);\n  }\n\n  Result visitSubobjectArray(QualType Type, const llvm::APInt &Size,\n                             Subobject Subobj) {\n    return getDerived().visitSubobject(Type, Subobj);\n  }\n\nprotected:\n  Sema &S;\n  CXXRecordDecl *RD;\n  FunctionDecl *FD;\n  DefaultedComparisonKind DCK;\n  UnresolvedSet<16> Fns;\n};\n\n/// Information about a defaulted comparison, as determined by\n/// DefaultedComparisonAnalyzer.\nstruct DefaultedComparisonInfo {\n  bool Deleted = false;\n  bool Constexpr = true;\n  ComparisonCategoryType Category = ComparisonCategoryType::StrongOrdering;\n\n  static DefaultedComparisonInfo deleted() {\n    DefaultedComparisonInfo Deleted;\n    Deleted.Deleted = true;\n    return Deleted;\n  }\n\n  bool add(const DefaultedComparisonInfo &R) {\n    Deleted |= R.Deleted;\n    Constexpr &= R.Constexpr;\n    Category = commonComparisonType(Category, R.Category);\n    return Deleted;\n  }\n};\n\n/// An element in the expanded list of subobjects of a defaulted comparison, as\n/// specified in C++2a [class.compare.default]p4.\nstruct DefaultedComparisonSubobject {\n  enum { CompleteObject, Member, Base } Kind;\n  NamedDecl *Decl;\n  SourceLocation Loc;\n};\n\n/// A visitor over the notional body of a defaulted comparison that determines\n/// whether that body would be deleted or constexpr.\nclass DefaultedComparisonAnalyzer\n    : public DefaultedComparisonVisitor<DefaultedComparisonAnalyzer,\n                                        DefaultedComparisonInfo,\n                                        DefaultedComparisonInfo,\n                                        DefaultedComparisonSubobject> {\npublic:\n  enum DiagnosticKind { NoDiagnostics, ExplainDeleted, ExplainConstexpr };\n\nprivate:\n  DiagnosticKind Diagnose;\n\npublic:\n  using Base = DefaultedComparisonVisitor;\n  using Result = DefaultedComparisonInfo;\n  using Subobject = DefaultedComparisonSubobject;\n\n  friend Base;\n\n  DefaultedComparisonAnalyzer(Sema &S, CXXRecordDecl *RD, FunctionDecl *FD,\n                              DefaultedComparisonKind DCK,\n                              DiagnosticKind Diagnose = NoDiagnostics)\n      : Base(S, RD, FD, DCK), Diagnose(Diagnose) {}\n\n  Result visit() {\n    if ((DCK == DefaultedComparisonKind::Equal ||\n         DCK == DefaultedComparisonKind::ThreeWay) &&\n        RD->hasVariantMembers()) {\n      // C++2a [class.compare.default]p2 [P2002R0]:\n      //   A defaulted comparison operator function for class C is defined as\n      //   deleted if [...] C has variant members.\n      if (Diagnose == ExplainDeleted) {\n        S.Diag(FD->getLocation(), diag::note_defaulted_comparison_union)\n          << FD << RD->isUnion() << RD;\n      }\n      return Result::deleted();\n    }\n\n    return Base::visit();\n  }\n\nprivate:\n  Subobject getCompleteObject() {\n    return Subobject{Subobject::CompleteObject, nullptr, FD->getLocation()};\n  }\n\n  Subobject getBase(CXXBaseSpecifier *Base) {\n    return Subobject{Subobject::Base, Base->getType()->getAsCXXRecordDecl(),\n                     Base->getBaseTypeLoc()};\n  }\n\n  Subobject getField(FieldDecl *Field) {\n    return Subobject{Subobject::Member, Field, Field->getLocation()};\n  }\n\n  Result visitExpandedSubobject(QualType Type, Subobject Subobj) {\n    // C++2a [class.compare.default]p2 [P2002R0]:\n    //   A defaulted <=> or == operator function for class C is defined as\n    //   deleted if any non-static data member of C is of reference type\n    if (Type->isReferenceType()) {\n      if (Diagnose == ExplainDeleted) {\n        S.Diag(Subobj.Loc, diag::note_defaulted_comparison_reference_member)\n            << FD << RD;\n      }\n      return Result::deleted();\n    }\n\n    // [...] Let xi be an lvalue denoting the ith element [...]\n    OpaqueValueExpr Xi(FD->getLocation(), Type, VK_LValue);\n    Expr *Args[] = {&Xi, &Xi};\n\n    // All operators start by trying to apply that same operator recursively.\n    OverloadedOperatorKind OO = FD->getOverloadedOperator();\n    assert(OO != OO_None && \"not an overloaded operator!\");\n    return visitBinaryOperator(OO, Args, Subobj);\n  }\n\n  Result\n  visitBinaryOperator(OverloadedOperatorKind OO, ArrayRef<Expr *> Args,\n                      Subobject Subobj,\n                      OverloadCandidateSet *SpaceshipCandidates = nullptr) {\n    // Note that there is no need to consider rewritten candidates here if\n    // we've already found there is no viable 'operator<=>' candidate (and are\n    // considering synthesizing a '<=>' from '==' and '<').\n    OverloadCandidateSet CandidateSet(\n        FD->getLocation(), OverloadCandidateSet::CSK_Operator,\n        OverloadCandidateSet::OperatorRewriteInfo(\n            OO, /*AllowRewrittenCandidates=*/!SpaceshipCandidates));\n\n    /// C++2a [class.compare.default]p1 [P2002R0]:\n    ///   [...] the defaulted function itself is never a candidate for overload\n    ///   resolution [...]\n    CandidateSet.exclude(FD);\n\n    if (Args[0]->getType()->isOverloadableType())\n      S.LookupOverloadedBinOp(CandidateSet, OO, Fns, Args);\n    else if (OO == OO_EqualEqual ||\n             !Args[0]->getType()->isFunctionPointerType()) {\n      // FIXME: We determine whether this is a valid expression by checking to\n      // see if there's a viable builtin operator candidate for it. That isn't\n      // really what the rules ask us to do, but should give the right results.\n      //\n      // Note that the builtin operator for relational comparisons on function\n      // pointers is the only known case which cannot be used.\n      S.AddBuiltinOperatorCandidates(OO, FD->getLocation(), Args, CandidateSet);\n    }\n\n    Result R;\n\n    OverloadCandidateSet::iterator Best;\n    switch (CandidateSet.BestViableFunction(S, FD->getLocation(), Best)) {\n    case OR_Success: {\n      // C++2a [class.compare.secondary]p2 [P2002R0]:\n      //   The operator function [...] is defined as deleted if [...] the\n      //   candidate selected by overload resolution is not a rewritten\n      //   candidate.\n      if ((DCK == DefaultedComparisonKind::NotEqual ||\n           DCK == DefaultedComparisonKind::Relational) &&\n          !Best->RewriteKind) {\n        if (Diagnose == ExplainDeleted) {\n          S.Diag(Best->Function->getLocation(),\n                 diag::note_defaulted_comparison_not_rewritten_callee)\n              << FD;\n        }\n        return Result::deleted();\n      }\n\n      // Throughout C++2a [class.compare]: if overload resolution does not\n      // result in a usable function, the candidate function is defined as\n      // deleted. This requires that we selected an accessible function.\n      //\n      // Note that this only considers the access of the function when named\n      // within the type of the subobject, and not the access path for any\n      // derived-to-base conversion.\n      CXXRecordDecl *ArgClass = Args[0]->getType()->getAsCXXRecordDecl();\n      if (ArgClass && Best->FoundDecl.getDecl() &&\n          Best->FoundDecl.getDecl()->isCXXClassMember()) {\n        QualType ObjectType = Subobj.Kind == Subobject::Member\n                                  ? Args[0]->getType()\n                                  : S.Context.getRecordType(RD);\n        if (!S.isMemberAccessibleForDeletion(\n                ArgClass, Best->FoundDecl, ObjectType, Subobj.Loc,\n                Diagnose == ExplainDeleted\n                    ? S.PDiag(diag::note_defaulted_comparison_inaccessible)\n                          << FD << Subobj.Kind << Subobj.Decl\n                    : S.PDiag()))\n          return Result::deleted();\n      }\n\n      // C++2a [class.compare.default]p3 [P2002R0]:\n      //   A defaulted comparison function is constexpr-compatible if [...]\n      //   no overlod resolution performed [...] results in a non-constexpr\n      //   function.\n      if (FunctionDecl *BestFD = Best->Function) {\n        assert(!BestFD->isDeleted() && \"wrong overload resolution result\");\n        // If it's not constexpr, explain why not.\n        if (Diagnose == ExplainConstexpr && !BestFD->isConstexpr()) {\n          if (Subobj.Kind != Subobject::CompleteObject)\n            S.Diag(Subobj.Loc, diag::note_defaulted_comparison_not_constexpr)\n              << Subobj.Kind << Subobj.Decl;\n          S.Diag(BestFD->getLocation(),\n                 diag::note_defaulted_comparison_not_constexpr_here);\n          // Bail out after explaining; we don't want any more notes.\n          return Result::deleted();\n        }\n        R.Constexpr &= BestFD->isConstexpr();\n      }\n\n      if (OO == OO_Spaceship && FD->getReturnType()->isUndeducedAutoType()) {\n        if (auto *BestFD = Best->Function) {\n          // If any callee has an undeduced return type, deduce it now.\n          // FIXME: It's not clear how a failure here should be handled. For\n          // now, we produce an eager diagnostic, because that is forward\n          // compatible with most (all?) other reasonable options.\n          if (BestFD->getReturnType()->isUndeducedType() &&\n              S.DeduceReturnType(BestFD, FD->getLocation(),\n                                 /*Diagnose=*/false)) {\n            // Don't produce a duplicate error when asked to explain why the\n            // comparison is deleted: we diagnosed that when initially checking\n            // the defaulted operator.\n            if (Diagnose == NoDiagnostics) {\n              S.Diag(\n                  FD->getLocation(),\n                  diag::err_defaulted_comparison_cannot_deduce_undeduced_auto)\n                  << Subobj.Kind << Subobj.Decl;\n              S.Diag(\n                  Subobj.Loc,\n                  diag::note_defaulted_comparison_cannot_deduce_undeduced_auto)\n                  << Subobj.Kind << Subobj.Decl;\n              S.Diag(BestFD->getLocation(),\n                     diag::note_defaulted_comparison_cannot_deduce_callee)\n                  << Subobj.Kind << Subobj.Decl;\n            }\n            return Result::deleted();\n          }\n          if (auto *Info = S.Context.CompCategories.lookupInfoForType(\n              BestFD->getCallResultType())) {\n            R.Category = Info->Kind;\n          } else {\n            if (Diagnose == ExplainDeleted) {\n              S.Diag(Subobj.Loc, diag::note_defaulted_comparison_cannot_deduce)\n                  << Subobj.Kind << Subobj.Decl\n                  << BestFD->getCallResultType().withoutLocalFastQualifiers();\n              S.Diag(BestFD->getLocation(),\n                     diag::note_defaulted_comparison_cannot_deduce_callee)\n                  << Subobj.Kind << Subobj.Decl;\n            }\n            return Result::deleted();\n          }\n        } else {\n          Optional<ComparisonCategoryType> Cat =\n              getComparisonCategoryForBuiltinCmp(Args[0]->getType());\n          assert(Cat && \"no category for builtin comparison?\");\n          R.Category = *Cat;\n        }\n      }\n\n      // Note that we might be rewriting to a different operator. That call is\n      // not considered until we come to actually build the comparison function.\n      break;\n    }\n\n    case OR_Ambiguous:\n      if (Diagnose == ExplainDeleted) {\n        unsigned Kind = 0;\n        if (FD->getOverloadedOperator() == OO_Spaceship && OO != OO_Spaceship)\n          Kind = OO == OO_EqualEqual ? 1 : 2;\n        CandidateSet.NoteCandidates(\n            PartialDiagnosticAt(\n                Subobj.Loc, S.PDiag(diag::note_defaulted_comparison_ambiguous)\n                                << FD << Kind << Subobj.Kind << Subobj.Decl),\n            S, OCD_AmbiguousCandidates, Args);\n      }\n      R = Result::deleted();\n      break;\n\n    case OR_Deleted:\n      if (Diagnose == ExplainDeleted) {\n        if ((DCK == DefaultedComparisonKind::NotEqual ||\n             DCK == DefaultedComparisonKind::Relational) &&\n            !Best->RewriteKind) {\n          S.Diag(Best->Function->getLocation(),\n                 diag::note_defaulted_comparison_not_rewritten_callee)\n              << FD;\n        } else {\n          S.Diag(Subobj.Loc,\n                 diag::note_defaulted_comparison_calls_deleted)\n              << FD << Subobj.Kind << Subobj.Decl;\n          S.NoteDeletedFunction(Best->Function);\n        }\n      }\n      R = Result::deleted();\n      break;\n\n    case OR_No_Viable_Function:\n      // If there's no usable candidate, we're done unless we can rewrite a\n      // '<=>' in terms of '==' and '<'.\n      if (OO == OO_Spaceship &&\n          S.Context.CompCategories.lookupInfoForType(FD->getReturnType())) {\n        // For any kind of comparison category return type, we need a usable\n        // '==' and a usable '<'.\n        if (!R.add(visitBinaryOperator(OO_EqualEqual, Args, Subobj,\n                                       &CandidateSet)))\n          R.add(visitBinaryOperator(OO_Less, Args, Subobj, &CandidateSet));\n        break;\n      }\n\n      if (Diagnose == ExplainDeleted) {\n        S.Diag(Subobj.Loc, diag::note_defaulted_comparison_no_viable_function)\n            << FD << Subobj.Kind << Subobj.Decl;\n\n        // For a three-way comparison, list both the candidates for the\n        // original operator and the candidates for the synthesized operator.\n        if (SpaceshipCandidates) {\n          SpaceshipCandidates->NoteCandidates(\n              S, Args,\n              SpaceshipCandidates->CompleteCandidates(S, OCD_AllCandidates,\n                                                      Args, FD->getLocation()));\n          S.Diag(Subobj.Loc,\n                 diag::note_defaulted_comparison_no_viable_function_synthesized)\n              << (OO == OO_EqualEqual ? 0 : 1);\n        }\n\n        CandidateSet.NoteCandidates(\n            S, Args,\n            CandidateSet.CompleteCandidates(S, OCD_AllCandidates, Args,\n                                            FD->getLocation()));\n      }\n      R = Result::deleted();\n      break;\n    }\n\n    return R;\n  }\n};\n\n/// A list of statements.\nstruct StmtListResult {\n  bool IsInvalid = false;\n  llvm::SmallVector<Stmt*, 16> Stmts;\n\n  bool add(const StmtResult &S) {\n    IsInvalid |= S.isInvalid();\n    if (IsInvalid)\n      return true;\n    Stmts.push_back(S.get());\n    return false;\n  }\n};\n\n/// A visitor over the notional body of a defaulted comparison that synthesizes\n/// the actual body.\nclass DefaultedComparisonSynthesizer\n    : public DefaultedComparisonVisitor<DefaultedComparisonSynthesizer,\n                                        StmtListResult, StmtResult,\n                                        std::pair<ExprResult, ExprResult>> {\n  SourceLocation Loc;\n  unsigned ArrayDepth = 0;\n\npublic:\n  using Base = DefaultedComparisonVisitor;\n  using ExprPair = std::pair<ExprResult, ExprResult>;\n\n  friend Base;\n\n  DefaultedComparisonSynthesizer(Sema &S, CXXRecordDecl *RD, FunctionDecl *FD,\n                                 DefaultedComparisonKind DCK,\n                                 SourceLocation BodyLoc)\n      : Base(S, RD, FD, DCK), Loc(BodyLoc) {}\n\n  /// Build a suitable function body for this defaulted comparison operator.\n  StmtResult build() {\n    Sema::CompoundScopeRAII CompoundScope(S);\n\n    StmtListResult Stmts = visit();\n    if (Stmts.IsInvalid)\n      return StmtError();\n\n    ExprResult RetVal;\n    switch (DCK) {\n    case DefaultedComparisonKind::None:\n      llvm_unreachable(\"not a defaulted comparison\");\n\n    case DefaultedComparisonKind::Equal: {\n      // C++2a [class.eq]p3:\n      //   [...] compar[e] the corresponding elements [...] until the first\n      //   index i where xi == yi yields [...] false. If no such index exists,\n      //   V is true. Otherwise, V is false.\n      //\n      // Join the comparisons with '&&'s and return the result. Use a right\n      // fold (traversing the conditions right-to-left), because that\n      // short-circuits more naturally.\n      auto OldStmts = std::move(Stmts.Stmts);\n      Stmts.Stmts.clear();\n      ExprResult CmpSoFar;\n      // Finish a particular comparison chain.\n      auto FinishCmp = [&] {\n        if (Expr *Prior = CmpSoFar.get()) {\n          // Convert the last expression to 'return ...;'\n          if (RetVal.isUnset() && Stmts.Stmts.empty())\n            RetVal = CmpSoFar;\n          // Convert any prior comparison to 'if (!(...)) return false;'\n          else if (Stmts.add(buildIfNotCondReturnFalse(Prior)))\n            return true;\n          CmpSoFar = ExprResult();\n        }\n        return false;\n      };\n      for (Stmt *EAsStmt : llvm::reverse(OldStmts)) {\n        Expr *E = dyn_cast<Expr>(EAsStmt);\n        if (!E) {\n          // Found an array comparison.\n          if (FinishCmp() || Stmts.add(EAsStmt))\n            return StmtError();\n          continue;\n        }\n\n        if (CmpSoFar.isUnset()) {\n          CmpSoFar = E;\n          continue;\n        }\n        CmpSoFar = S.CreateBuiltinBinOp(Loc, BO_LAnd, E, CmpSoFar.get());\n        if (CmpSoFar.isInvalid())\n          return StmtError();\n      }\n      if (FinishCmp())\n        return StmtError();\n      std::reverse(Stmts.Stmts.begin(), Stmts.Stmts.end());\n      //   If no such index exists, V is true.\n      if (RetVal.isUnset())\n        RetVal = S.ActOnCXXBoolLiteral(Loc, tok::kw_true);\n      break;\n    }\n\n    case DefaultedComparisonKind::ThreeWay: {\n      // Per C++2a [class.spaceship]p3, as a fallback add:\n      // return static_cast<R>(std::strong_ordering::equal);\n      QualType StrongOrdering = S.CheckComparisonCategoryType(\n          ComparisonCategoryType::StrongOrdering, Loc,\n          Sema::ComparisonCategoryUsage::DefaultedOperator);\n      if (StrongOrdering.isNull())\n        return StmtError();\n      VarDecl *EqualVD = S.Context.CompCategories.getInfoForType(StrongOrdering)\n                             .getValueInfo(ComparisonCategoryResult::Equal)\n                             ->VD;\n      RetVal = getDecl(EqualVD);\n      if (RetVal.isInvalid())\n        return StmtError();\n      RetVal = buildStaticCastToR(RetVal.get());\n      break;\n    }\n\n    case DefaultedComparisonKind::NotEqual:\n    case DefaultedComparisonKind::Relational:\n      RetVal = cast<Expr>(Stmts.Stmts.pop_back_val());\n      break;\n    }\n\n    // Build the final return statement.\n    if (RetVal.isInvalid())\n      return StmtError();\n    StmtResult ReturnStmt = S.BuildReturnStmt(Loc, RetVal.get());\n    if (ReturnStmt.isInvalid())\n      return StmtError();\n    Stmts.Stmts.push_back(ReturnStmt.get());\n\n    return S.ActOnCompoundStmt(Loc, Loc, Stmts.Stmts, /*IsStmtExpr=*/false);\n  }\n\nprivate:\n  ExprResult getDecl(ValueDecl *VD) {\n    return S.BuildDeclarationNameExpr(\n        CXXScopeSpec(), DeclarationNameInfo(VD->getDeclName(), Loc), VD);\n  }\n\n  ExprResult getParam(unsigned I) {\n    ParmVarDecl *PD = FD->getParamDecl(I);\n    return getDecl(PD);\n  }\n\n  ExprPair getCompleteObject() {\n    unsigned Param = 0;\n    ExprResult LHS;\n    if (isa<CXXMethodDecl>(FD)) {\n      // LHS is '*this'.\n      LHS = S.ActOnCXXThis(Loc);\n      if (!LHS.isInvalid())\n        LHS = S.CreateBuiltinUnaryOp(Loc, UO_Deref, LHS.get());\n    } else {\n      LHS = getParam(Param++);\n    }\n    ExprResult RHS = getParam(Param++);\n    assert(Param == FD->getNumParams());\n    return {LHS, RHS};\n  }\n\n  ExprPair getBase(CXXBaseSpecifier *Base) {\n    ExprPair Obj = getCompleteObject();\n    if (Obj.first.isInvalid() || Obj.second.isInvalid())\n      return {ExprError(), ExprError()};\n    CXXCastPath Path = {Base};\n    return {S.ImpCastExprToType(Obj.first.get(), Base->getType(),\n                                CK_DerivedToBase, VK_LValue, &Path),\n            S.ImpCastExprToType(Obj.second.get(), Base->getType(),\n                                CK_DerivedToBase, VK_LValue, &Path)};\n  }\n\n  ExprPair getField(FieldDecl *Field) {\n    ExprPair Obj = getCompleteObject();\n    if (Obj.first.isInvalid() || Obj.second.isInvalid())\n      return {ExprError(), ExprError()};\n\n    DeclAccessPair Found = DeclAccessPair::make(Field, Field->getAccess());\n    DeclarationNameInfo NameInfo(Field->getDeclName(), Loc);\n    return {S.BuildFieldReferenceExpr(Obj.first.get(), /*IsArrow=*/false, Loc,\n                                      CXXScopeSpec(), Field, Found, NameInfo),\n            S.BuildFieldReferenceExpr(Obj.second.get(), /*IsArrow=*/false, Loc,\n                                      CXXScopeSpec(), Field, Found, NameInfo)};\n  }\n\n  // FIXME: When expanding a subobject, register a note in the code synthesis\n  // stack to say which subobject we're comparing.\n\n  StmtResult buildIfNotCondReturnFalse(ExprResult Cond) {\n    if (Cond.isInvalid())\n      return StmtError();\n\n    ExprResult NotCond = S.CreateBuiltinUnaryOp(Loc, UO_LNot, Cond.get());\n    if (NotCond.isInvalid())\n      return StmtError();\n\n    ExprResult False = S.ActOnCXXBoolLiteral(Loc, tok::kw_false);\n    assert(!False.isInvalid() && \"should never fail\");\n    StmtResult ReturnFalse = S.BuildReturnStmt(Loc, False.get());\n    if (ReturnFalse.isInvalid())\n      return StmtError();\n\n    return S.ActOnIfStmt(Loc, false, Loc, nullptr,\n                         S.ActOnCondition(nullptr, Loc, NotCond.get(),\n                                          Sema::ConditionKind::Boolean),\n                         Loc, ReturnFalse.get(), SourceLocation(), nullptr);\n  }\n\n  StmtResult visitSubobjectArray(QualType Type, llvm::APInt Size,\n                                 ExprPair Subobj) {\n    QualType SizeType = S.Context.getSizeType();\n    Size = Size.zextOrTrunc(S.Context.getTypeSize(SizeType));\n\n    // Build 'size_t i$n = 0'.\n    IdentifierInfo *IterationVarName = nullptr;\n    {\n      SmallString<8> Str;\n      llvm::raw_svector_ostream OS(Str);\n      OS << \"i\" << ArrayDepth;\n      IterationVarName = &S.Context.Idents.get(OS.str());\n    }\n    VarDecl *IterationVar = VarDecl::Create(\n        S.Context, S.CurContext, Loc, Loc, IterationVarName, SizeType,\n        S.Context.getTrivialTypeSourceInfo(SizeType, Loc), SC_None);\n    llvm::APInt Zero(S.Context.getTypeSize(SizeType), 0);\n    IterationVar->setInit(\n        IntegerLiteral::Create(S.Context, Zero, SizeType, Loc));\n    Stmt *Init = new (S.Context) DeclStmt(DeclGroupRef(IterationVar), Loc, Loc);\n\n    auto IterRef = [&] {\n      ExprResult Ref = S.BuildDeclarationNameExpr(\n          CXXScopeSpec(), DeclarationNameInfo(IterationVarName, Loc),\n          IterationVar);\n      assert(!Ref.isInvalid() && \"can't reference our own variable?\");\n      return Ref.get();\n    };\n\n    // Build 'i$n != Size'.\n    ExprResult Cond = S.CreateBuiltinBinOp(\n        Loc, BO_NE, IterRef(),\n        IntegerLiteral::Create(S.Context, Size, SizeType, Loc));\n    assert(!Cond.isInvalid() && \"should never fail\");\n\n    // Build '++i$n'.\n    ExprResult Inc = S.CreateBuiltinUnaryOp(Loc, UO_PreInc, IterRef());\n    assert(!Inc.isInvalid() && \"should never fail\");\n\n    // Build 'a[i$n]' and 'b[i$n]'.\n    auto Index = [&](ExprResult E) {\n      if (E.isInvalid())\n        return ExprError();\n      return S.CreateBuiltinArraySubscriptExpr(E.get(), Loc, IterRef(), Loc);\n    };\n    Subobj.first = Index(Subobj.first);\n    Subobj.second = Index(Subobj.second);\n\n    // Compare the array elements.\n    ++ArrayDepth;\n    StmtResult Substmt = visitSubobject(Type, Subobj);\n    --ArrayDepth;\n\n    if (Substmt.isInvalid())\n      return StmtError();\n\n    // For the inner level of an 'operator==', build 'if (!cmp) return false;'.\n    // For outer levels or for an 'operator<=>' we already have a suitable\n    // statement that returns as necessary.\n    if (Expr *ElemCmp = dyn_cast<Expr>(Substmt.get())) {\n      assert(DCK == DefaultedComparisonKind::Equal &&\n             \"should have non-expression statement\");\n      Substmt = buildIfNotCondReturnFalse(ElemCmp);\n      if (Substmt.isInvalid())\n        return StmtError();\n    }\n\n    // Build 'for (...) ...'\n    return S.ActOnForStmt(Loc, Loc, Init,\n                          S.ActOnCondition(nullptr, Loc, Cond.get(),\n                                           Sema::ConditionKind::Boolean),\n                          S.MakeFullDiscardedValueExpr(Inc.get()), Loc,\n                          Substmt.get());\n  }\n\n  StmtResult visitExpandedSubobject(QualType Type, ExprPair Obj) {\n    if (Obj.first.isInvalid() || Obj.second.isInvalid())\n      return StmtError();\n\n    OverloadedOperatorKind OO = FD->getOverloadedOperator();\n    BinaryOperatorKind Opc = BinaryOperator::getOverloadedOpcode(OO);\n    ExprResult Op;\n    if (Type->isOverloadableType())\n      Op = S.CreateOverloadedBinOp(Loc, Opc, Fns, Obj.first.get(),\n                                   Obj.second.get(), /*PerformADL=*/true,\n                                   /*AllowRewrittenCandidates=*/true, FD);\n    else\n      Op = S.CreateBuiltinBinOp(Loc, Opc, Obj.first.get(), Obj.second.get());\n    if (Op.isInvalid())\n      return StmtError();\n\n    switch (DCK) {\n    case DefaultedComparisonKind::None:\n      llvm_unreachable(\"not a defaulted comparison\");\n\n    case DefaultedComparisonKind::Equal:\n      // Per C++2a [class.eq]p2, each comparison is individually contextually\n      // converted to bool.\n      Op = S.PerformContextuallyConvertToBool(Op.get());\n      if (Op.isInvalid())\n        return StmtError();\n      return Op.get();\n\n    case DefaultedComparisonKind::ThreeWay: {\n      // Per C++2a [class.spaceship]p3, form:\n      //   if (R cmp = static_cast<R>(op); cmp != 0)\n      //     return cmp;\n      QualType R = FD->getReturnType();\n      Op = buildStaticCastToR(Op.get());\n      if (Op.isInvalid())\n        return StmtError();\n\n      // R cmp = ...;\n      IdentifierInfo *Name = &S.Context.Idents.get(\"cmp\");\n      VarDecl *VD =\n          VarDecl::Create(S.Context, S.CurContext, Loc, Loc, Name, R,\n                          S.Context.getTrivialTypeSourceInfo(R, Loc), SC_None);\n      S.AddInitializerToDecl(VD, Op.get(), /*DirectInit=*/false);\n      Stmt *InitStmt = new (S.Context) DeclStmt(DeclGroupRef(VD), Loc, Loc);\n\n      // cmp != 0\n      ExprResult VDRef = getDecl(VD);\n      if (VDRef.isInvalid())\n        return StmtError();\n      llvm::APInt ZeroVal(S.Context.getIntWidth(S.Context.IntTy), 0);\n      Expr *Zero =\n          IntegerLiteral::Create(S.Context, ZeroVal, S.Context.IntTy, Loc);\n      ExprResult Comp;\n      if (VDRef.get()->getType()->isOverloadableType())\n        Comp = S.CreateOverloadedBinOp(Loc, BO_NE, Fns, VDRef.get(), Zero, true,\n                                       true, FD);\n      else\n        Comp = S.CreateBuiltinBinOp(Loc, BO_NE, VDRef.get(), Zero);\n      if (Comp.isInvalid())\n        return StmtError();\n      Sema::ConditionResult Cond = S.ActOnCondition(\n          nullptr, Loc, Comp.get(), Sema::ConditionKind::Boolean);\n      if (Cond.isInvalid())\n        return StmtError();\n\n      // return cmp;\n      VDRef = getDecl(VD);\n      if (VDRef.isInvalid())\n        return StmtError();\n      StmtResult ReturnStmt = S.BuildReturnStmt(Loc, VDRef.get());\n      if (ReturnStmt.isInvalid())\n        return StmtError();\n\n      // if (...)\n      return S.ActOnIfStmt(Loc, /*IsConstexpr=*/false, Loc, InitStmt, Cond, Loc,\n                           ReturnStmt.get(),\n                           /*ElseLoc=*/SourceLocation(), /*Else=*/nullptr);\n    }\n\n    case DefaultedComparisonKind::NotEqual:\n    case DefaultedComparisonKind::Relational:\n      // C++2a [class.compare.secondary]p2:\n      //   Otherwise, the operator function yields x @ y.\n      return Op.get();\n    }\n    llvm_unreachable(\"\");\n  }\n\n  /// Build \"static_cast<R>(E)\".\n  ExprResult buildStaticCastToR(Expr *E) {\n    QualType R = FD->getReturnType();\n    assert(!R->isUndeducedType() && \"type should have been deduced already\");\n\n    // Don't bother forming a no-op cast in the common case.\n    if (E->isRValue() && S.Context.hasSameType(E->getType(), R))\n      return E;\n    return S.BuildCXXNamedCast(Loc, tok::kw_static_cast,\n                               S.Context.getTrivialTypeSourceInfo(R, Loc), E,\n                               SourceRange(Loc, Loc), SourceRange(Loc, Loc));\n  }\n};\n}\n\n/// Perform the unqualified lookups that might be needed to form a defaulted\n/// comparison function for the given operator.\nstatic void lookupOperatorsForDefaultedComparison(Sema &Self, Scope *S,\n                                                  UnresolvedSetImpl &Operators,\n                                                  OverloadedOperatorKind Op) {\n  auto Lookup = [&](OverloadedOperatorKind OO) {\n    Self.LookupOverloadedOperatorName(OO, S, Operators);\n  };\n\n  // Every defaulted operator looks up itself.\n  Lookup(Op);\n  // ... and the rewritten form of itself, if any.\n  if (OverloadedOperatorKind ExtraOp = getRewrittenOverloadedOperator(Op))\n    Lookup(ExtraOp);\n\n  // For 'operator<=>', we also form a 'cmp != 0' expression, and might\n  // synthesize a three-way comparison from '<' and '=='. In a dependent\n  // context, we also need to look up '==' in case we implicitly declare a\n  // defaulted 'operator=='.\n  if (Op == OO_Spaceship) {\n    Lookup(OO_ExclaimEqual);\n    Lookup(OO_Less);\n    Lookup(OO_EqualEqual);\n  }\n}\n\nbool Sema::CheckExplicitlyDefaultedComparison(Scope *S, FunctionDecl *FD,\n                                              DefaultedComparisonKind DCK) {\n  assert(DCK != DefaultedComparisonKind::None && \"not a defaulted comparison\");\n\n  CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(FD->getLexicalDeclContext());\n  assert(RD && \"defaulted comparison is not defaulted in a class\");\n\n  // Perform any unqualified lookups we're going to need to default this\n  // function.\n  if (S) {\n    UnresolvedSet<32> Operators;\n    lookupOperatorsForDefaultedComparison(*this, S, Operators,\n                                          FD->getOverloadedOperator());\n    FD->setDefaultedFunctionInfo(FunctionDecl::DefaultedFunctionInfo::Create(\n        Context, Operators.pairs()));\n  }\n\n  // C++2a [class.compare.default]p1:\n  //   A defaulted comparison operator function for some class C shall be a\n  //   non-template function declared in the member-specification of C that is\n  //    -- a non-static const member of C having one parameter of type\n  //       const C&, or\n  //    -- a friend of C having two parameters of type const C& or two\n  //       parameters of type C.\n  QualType ExpectedParmType1 = Context.getRecordType(RD);\n  QualType ExpectedParmType2 =\n      Context.getLValueReferenceType(ExpectedParmType1.withConst());\n  if (isa<CXXMethodDecl>(FD))\n    ExpectedParmType1 = ExpectedParmType2;\n  for (const ParmVarDecl *Param : FD->parameters()) {\n    if (!Param->getType()->isDependentType() &&\n        !Context.hasSameType(Param->getType(), ExpectedParmType1) &&\n        !Context.hasSameType(Param->getType(), ExpectedParmType2)) {\n      // Don't diagnose an implicit 'operator=='; we will have diagnosed the\n      // corresponding defaulted 'operator<=>' already.\n      if (!FD->isImplicit()) {\n        Diag(FD->getLocation(), diag::err_defaulted_comparison_param)\n            << (int)DCK << Param->getType() << ExpectedParmType1\n            << !isa<CXXMethodDecl>(FD)\n            << ExpectedParmType2 << Param->getSourceRange();\n      }\n      return true;\n    }\n  }\n  if (FD->getNumParams() == 2 &&\n      !Context.hasSameType(FD->getParamDecl(0)->getType(),\n                           FD->getParamDecl(1)->getType())) {\n    if (!FD->isImplicit()) {\n      Diag(FD->getLocation(), diag::err_defaulted_comparison_param_mismatch)\n          << (int)DCK\n          << FD->getParamDecl(0)->getType()\n          << FD->getParamDecl(0)->getSourceRange()\n          << FD->getParamDecl(1)->getType()\n          << FD->getParamDecl(1)->getSourceRange();\n    }\n    return true;\n  }\n\n  // ... non-static const member ...\n  if (auto *MD = dyn_cast<CXXMethodDecl>(FD)) {\n    assert(!MD->isStatic() && \"comparison function cannot be a static member\");\n    if (!MD->isConst()) {\n      SourceLocation InsertLoc;\n      if (FunctionTypeLoc Loc = MD->getFunctionTypeLoc())\n        InsertLoc = getLocForEndOfToken(Loc.getRParenLoc());\n      // Don't diagnose an implicit 'operator=='; we will have diagnosed the\n      // corresponding defaulted 'operator<=>' already.\n      if (!MD->isImplicit()) {\n        Diag(MD->getLocation(), diag::err_defaulted_comparison_non_const)\n          << (int)DCK << FixItHint::CreateInsertion(InsertLoc, \" const\");\n      }\n\n      // Add the 'const' to the type to recover.\n      const auto *FPT = MD->getType()->castAs<FunctionProtoType>();\n      FunctionProtoType::ExtProtoInfo EPI = FPT->getExtProtoInfo();\n      EPI.TypeQuals.addConst();\n      MD->setType(Context.getFunctionType(FPT->getReturnType(),\n                                          FPT->getParamTypes(), EPI));\n    }\n  } else {\n    // A non-member function declared in a class must be a friend.\n    assert(FD->getFriendObjectKind() && \"expected a friend declaration\");\n  }\n\n  // C++2a [class.eq]p1, [class.rel]p1:\n  //   A [defaulted comparison other than <=>] shall have a declared return\n  //   type bool.\n  if (DCK != DefaultedComparisonKind::ThreeWay &&\n      !FD->getDeclaredReturnType()->isDependentType() &&\n      !Context.hasSameType(FD->getDeclaredReturnType(), Context.BoolTy)) {\n    Diag(FD->getLocation(), diag::err_defaulted_comparison_return_type_not_bool)\n        << (int)DCK << FD->getDeclaredReturnType() << Context.BoolTy\n        << FD->getReturnTypeSourceRange();\n    return true;\n  }\n  // C++2a [class.spaceship]p2 [P2002R0]:\n  //   Let R be the declared return type [...]. If R is auto, [...]. Otherwise,\n  //   R shall not contain a placeholder type.\n  if (DCK == DefaultedComparisonKind::ThreeWay &&\n      FD->getDeclaredReturnType()->getContainedDeducedType() &&\n      !Context.hasSameType(FD->getDeclaredReturnType(),\n                           Context.getAutoDeductType())) {\n    Diag(FD->getLocation(),\n         diag::err_defaulted_comparison_deduced_return_type_not_auto)\n        << (int)DCK << FD->getDeclaredReturnType() << Context.AutoDeductTy\n        << FD->getReturnTypeSourceRange();\n    return true;\n  }\n\n  // For a defaulted function in a dependent class, defer all remaining checks\n  // until instantiation.\n  if (RD->isDependentType())\n    return false;\n\n  // Determine whether the function should be defined as deleted.\n  DefaultedComparisonInfo Info =\n      DefaultedComparisonAnalyzer(*this, RD, FD, DCK).visit();\n\n  bool First = FD == FD->getCanonicalDecl();\n\n  // If we want to delete the function, then do so; there's nothing else to\n  // check in that case.\n  if (Info.Deleted) {\n    if (!First) {\n      // C++11 [dcl.fct.def.default]p4:\n      //   [For a] user-provided explicitly-defaulted function [...] if such a\n      //   function is implicitly defined as deleted, the program is ill-formed.\n      //\n      // This is really just a consequence of the general rule that you can\n      // only delete a function on its first declaration.\n      Diag(FD->getLocation(), diag::err_non_first_default_compare_deletes)\n          << FD->isImplicit() << (int)DCK;\n      DefaultedComparisonAnalyzer(*this, RD, FD, DCK,\n                                  DefaultedComparisonAnalyzer::ExplainDeleted)\n          .visit();\n      return true;\n    }\n\n    SetDeclDeleted(FD, FD->getLocation());\n    if (!inTemplateInstantiation() && !FD->isImplicit()) {\n      Diag(FD->getLocation(), diag::warn_defaulted_comparison_deleted)\n          << (int)DCK;\n      DefaultedComparisonAnalyzer(*this, RD, FD, DCK,\n                                  DefaultedComparisonAnalyzer::ExplainDeleted)\n          .visit();\n    }\n    return false;\n  }\n\n  // C++2a [class.spaceship]p2:\n  //   The return type is deduced as the common comparison type of R0, R1, ...\n  if (DCK == DefaultedComparisonKind::ThreeWay &&\n      FD->getDeclaredReturnType()->isUndeducedAutoType()) {\n    SourceLocation RetLoc = FD->getReturnTypeSourceRange().getBegin();\n    if (RetLoc.isInvalid())\n      RetLoc = FD->getBeginLoc();\n    // FIXME: Should we really care whether we have the complete type and the\n    // 'enumerator' constants here? A forward declaration seems sufficient.\n    QualType Cat = CheckComparisonCategoryType(\n        Info.Category, RetLoc, ComparisonCategoryUsage::DefaultedOperator);\n    if (Cat.isNull())\n      return true;\n    Context.adjustDeducedFunctionResultType(\n        FD, SubstAutoType(FD->getDeclaredReturnType(), Cat));\n  }\n\n  // C++2a [dcl.fct.def.default]p3 [P2002R0]:\n  //   An explicitly-defaulted function that is not defined as deleted may be\n  //   declared constexpr or consteval only if it is constexpr-compatible.\n  // C++2a [class.compare.default]p3 [P2002R0]:\n  //   A defaulted comparison function is constexpr-compatible if it satisfies\n  //   the requirements for a constexpr function [...]\n  // The only relevant requirements are that the parameter and return types are\n  // literal types. The remaining conditions are checked by the analyzer.\n  if (FD->isConstexpr()) {\n    if (CheckConstexprReturnType(*this, FD, CheckConstexprKind::Diagnose) &&\n        CheckConstexprParameterTypes(*this, FD, CheckConstexprKind::Diagnose) &&\n        !Info.Constexpr) {\n      Diag(FD->getBeginLoc(),\n           diag::err_incorrect_defaulted_comparison_constexpr)\n          << FD->isImplicit() << (int)DCK << FD->isConsteval();\n      DefaultedComparisonAnalyzer(*this, RD, FD, DCK,\n                                  DefaultedComparisonAnalyzer::ExplainConstexpr)\n          .visit();\n    }\n  }\n\n  // C++2a [dcl.fct.def.default]p3 [P2002R0]:\n  //   If a constexpr-compatible function is explicitly defaulted on its first\n  //   declaration, it is implicitly considered to be constexpr.\n  // FIXME: Only applying this to the first declaration seems problematic, as\n  // simple reorderings can affect the meaning of the program.\n  if (First && !FD->isConstexpr() && Info.Constexpr)\n    FD->setConstexprKind(ConstexprSpecKind::Constexpr);\n\n  // C++2a [except.spec]p3:\n  //   If a declaration of a function does not have a noexcept-specifier\n  //   [and] is defaulted on its first declaration, [...] the exception\n  //   specification is as specified below\n  if (FD->getExceptionSpecType() == EST_None) {\n    auto *FPT = FD->getType()->castAs<FunctionProtoType>();\n    FunctionProtoType::ExtProtoInfo EPI = FPT->getExtProtoInfo();\n    EPI.ExceptionSpec.Type = EST_Unevaluated;\n    EPI.ExceptionSpec.SourceDecl = FD;\n    FD->setType(Context.getFunctionType(FPT->getReturnType(),\n                                        FPT->getParamTypes(), EPI));\n  }\n\n  return false;\n}\n\nvoid Sema::DeclareImplicitEqualityComparison(CXXRecordDecl *RD,\n                                             FunctionDecl *Spaceship) {\n  Sema::CodeSynthesisContext Ctx;\n  Ctx.Kind = Sema::CodeSynthesisContext::DeclaringImplicitEqualityComparison;\n  Ctx.PointOfInstantiation = Spaceship->getEndLoc();\n  Ctx.Entity = Spaceship;\n  pushCodeSynthesisContext(Ctx);\n\n  if (FunctionDecl *EqualEqual = SubstSpaceshipAsEqualEqual(RD, Spaceship))\n    EqualEqual->setImplicit();\n\n  popCodeSynthesisContext();\n}\n\nvoid Sema::DefineDefaultedComparison(SourceLocation UseLoc, FunctionDecl *FD,\n                                     DefaultedComparisonKind DCK) {\n  assert(FD->isDefaulted() && !FD->isDeleted() &&\n         !FD->doesThisDeclarationHaveABody());\n  if (FD->willHaveBody() || FD->isInvalidDecl())\n    return;\n\n  SynthesizedFunctionScope Scope(*this, FD);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(UseLoc);\n\n  {\n    // Build and set up the function body.\n    CXXRecordDecl *RD = cast<CXXRecordDecl>(FD->getLexicalParent());\n    SourceLocation BodyLoc =\n        FD->getEndLoc().isValid() ? FD->getEndLoc() : FD->getLocation();\n    StmtResult Body =\n        DefaultedComparisonSynthesizer(*this, RD, FD, DCK, BodyLoc).build();\n    if (Body.isInvalid()) {\n      FD->setInvalidDecl();\n      return;\n    }\n    FD->setBody(Body.get());\n    FD->markUsed(Context);\n  }\n\n  // The exception specification is needed because we are defining the\n  // function. Note that this will reuse the body we just built.\n  ResolveExceptionSpec(UseLoc, FD->getType()->castAs<FunctionProtoType>());\n\n  if (ASTMutationListener *L = getASTMutationListener())\n    L->CompletedImplicitDefinition(FD);\n}\n\nstatic Sema::ImplicitExceptionSpecification\nComputeDefaultedComparisonExceptionSpec(Sema &S, SourceLocation Loc,\n                                        FunctionDecl *FD,\n                                        Sema::DefaultedComparisonKind DCK) {\n  ComputingExceptionSpec CES(S, FD, Loc);\n  Sema::ImplicitExceptionSpecification ExceptSpec(S);\n\n  if (FD->isInvalidDecl())\n    return ExceptSpec;\n\n  // The common case is that we just defined the comparison function. In that\n  // case, just look at whether the body can throw.\n  if (FD->hasBody()) {\n    ExceptSpec.CalledStmt(FD->getBody());\n  } else {\n    // Otherwise, build a body so we can check it. This should ideally only\n    // happen when we're not actually marking the function referenced. (This is\n    // only really important for efficiency: we don't want to build and throw\n    // away bodies for comparison functions more than we strictly need to.)\n\n    // Pretend to synthesize the function body in an unevaluated context.\n    // Note that we can't actually just go ahead and define the function here:\n    // we are not permitted to mark its callees as referenced.\n    Sema::SynthesizedFunctionScope Scope(S, FD);\n    EnterExpressionEvaluationContext Context(\n        S, Sema::ExpressionEvaluationContext::Unevaluated);\n\n    CXXRecordDecl *RD = cast<CXXRecordDecl>(FD->getLexicalParent());\n    SourceLocation BodyLoc =\n        FD->getEndLoc().isValid() ? FD->getEndLoc() : FD->getLocation();\n    StmtResult Body =\n        DefaultedComparisonSynthesizer(S, RD, FD, DCK, BodyLoc).build();\n    if (!Body.isInvalid())\n      ExceptSpec.CalledStmt(Body.get());\n\n    // FIXME: Can we hold onto this body and just transform it to potentially\n    // evaluated when we're asked to define the function rather than rebuilding\n    // it? Either that, or we should only build the bits of the body that we\n    // need (the expressions, not the statements).\n  }\n\n  return ExceptSpec;\n}\n\nvoid Sema::CheckDelayedMemberExceptionSpecs() {\n  decltype(DelayedOverridingExceptionSpecChecks) Overriding;\n  decltype(DelayedEquivalentExceptionSpecChecks) Equivalent;\n\n  std::swap(Overriding, DelayedOverridingExceptionSpecChecks);\n  std::swap(Equivalent, DelayedEquivalentExceptionSpecChecks);\n\n  // Perform any deferred checking of exception specifications for virtual\n  // destructors.\n  for (auto &Check : Overriding)\n    CheckOverridingFunctionExceptionSpec(Check.first, Check.second);\n\n  // Perform any deferred checking of exception specifications for befriended\n  // special members.\n  for (auto &Check : Equivalent)\n    CheckEquivalentExceptionSpec(Check.second, Check.first);\n}\n\nnamespace {\n/// CRTP base class for visiting operations performed by a special member\n/// function (or inherited constructor).\ntemplate<typename Derived>\nstruct SpecialMemberVisitor {\n  Sema &S;\n  CXXMethodDecl *MD;\n  Sema::CXXSpecialMember CSM;\n  Sema::InheritedConstructorInfo *ICI;\n\n  // Properties of the special member, computed for convenience.\n  bool IsConstructor = false, IsAssignment = false, ConstArg = false;\n\n  SpecialMemberVisitor(Sema &S, CXXMethodDecl *MD, Sema::CXXSpecialMember CSM,\n                       Sema::InheritedConstructorInfo *ICI)\n      : S(S), MD(MD), CSM(CSM), ICI(ICI) {\n    switch (CSM) {\n    case Sema::CXXDefaultConstructor:\n    case Sema::CXXCopyConstructor:\n    case Sema::CXXMoveConstructor:\n      IsConstructor = true;\n      break;\n    case Sema::CXXCopyAssignment:\n    case Sema::CXXMoveAssignment:\n      IsAssignment = true;\n      break;\n    case Sema::CXXDestructor:\n      break;\n    case Sema::CXXInvalid:\n      llvm_unreachable(\"invalid special member kind\");\n    }\n\n    if (MD->getNumParams()) {\n      if (const ReferenceType *RT =\n              MD->getParamDecl(0)->getType()->getAs<ReferenceType>())\n        ConstArg = RT->getPointeeType().isConstQualified();\n    }\n  }\n\n  Derived &getDerived() { return static_cast<Derived&>(*this); }\n\n  /// Is this a \"move\" special member?\n  bool isMove() const {\n    return CSM == Sema::CXXMoveConstructor || CSM == Sema::CXXMoveAssignment;\n  }\n\n  /// Look up the corresponding special member in the given class.\n  Sema::SpecialMemberOverloadResult lookupIn(CXXRecordDecl *Class,\n                                             unsigned Quals, bool IsMutable) {\n    return lookupCallFromSpecialMember(S, Class, CSM, Quals,\n                                       ConstArg && !IsMutable);\n  }\n\n  /// Look up the constructor for the specified base class to see if it's\n  /// overridden due to this being an inherited constructor.\n  Sema::SpecialMemberOverloadResult lookupInheritedCtor(CXXRecordDecl *Class) {\n    if (!ICI)\n      return {};\n    assert(CSM == Sema::CXXDefaultConstructor);\n    auto *BaseCtor =\n      cast<CXXConstructorDecl>(MD)->getInheritedConstructor().getConstructor();\n    if (auto *MD = ICI->findConstructorForBase(Class, BaseCtor).first)\n      return MD;\n    return {};\n  }\n\n  /// A base or member subobject.\n  typedef llvm::PointerUnion<CXXBaseSpecifier*, FieldDecl*> Subobject;\n\n  /// Get the location to use for a subobject in diagnostics.\n  static SourceLocation getSubobjectLoc(Subobject Subobj) {\n    // FIXME: For an indirect virtual base, the direct base leading to\n    // the indirect virtual base would be a more useful choice.\n    if (auto *B = Subobj.dyn_cast<CXXBaseSpecifier*>())\n      return B->getBaseTypeLoc();\n    else\n      return Subobj.get<FieldDecl*>()->getLocation();\n  }\n\n  enum BasesToVisit {\n    /// Visit all non-virtual (direct) bases.\n    VisitNonVirtualBases,\n    /// Visit all direct bases, virtual or not.\n    VisitDirectBases,\n    /// Visit all non-virtual bases, and all virtual bases if the class\n    /// is not abstract.\n    VisitPotentiallyConstructedBases,\n    /// Visit all direct or virtual bases.\n    VisitAllBases\n  };\n\n  // Visit the bases and members of the class.\n  bool visit(BasesToVisit Bases) {\n    CXXRecordDecl *RD = MD->getParent();\n\n    if (Bases == VisitPotentiallyConstructedBases)\n      Bases = RD->isAbstract() ? VisitNonVirtualBases : VisitAllBases;\n\n    for (auto &B : RD->bases())\n      if ((Bases == VisitDirectBases || !B.isVirtual()) &&\n          getDerived().visitBase(&B))\n        return true;\n\n    if (Bases == VisitAllBases)\n      for (auto &B : RD->vbases())\n        if (getDerived().visitBase(&B))\n          return true;\n\n    for (auto *F : RD->fields())\n      if (!F->isInvalidDecl() && !F->isUnnamedBitfield() &&\n          getDerived().visitField(F))\n        return true;\n\n    return false;\n  }\n};\n}\n\nnamespace {\nstruct SpecialMemberDeletionInfo\n    : SpecialMemberVisitor<SpecialMemberDeletionInfo> {\n  bool Diagnose;\n\n  SourceLocation Loc;\n\n  bool AllFieldsAreConst;\n\n  SpecialMemberDeletionInfo(Sema &S, CXXMethodDecl *MD,\n                            Sema::CXXSpecialMember CSM,\n                            Sema::InheritedConstructorInfo *ICI, bool Diagnose)\n      : SpecialMemberVisitor(S, MD, CSM, ICI), Diagnose(Diagnose),\n        Loc(MD->getLocation()), AllFieldsAreConst(true) {}\n\n  bool inUnion() const { return MD->getParent()->isUnion(); }\n\n  Sema::CXXSpecialMember getEffectiveCSM() {\n    return ICI ? Sema::CXXInvalid : CSM;\n  }\n\n  bool shouldDeleteForVariantObjCPtrMember(FieldDecl *FD, QualType FieldType);\n\n  bool visitBase(CXXBaseSpecifier *Base) { return shouldDeleteForBase(Base); }\n  bool visitField(FieldDecl *Field) { return shouldDeleteForField(Field); }\n\n  bool shouldDeleteForBase(CXXBaseSpecifier *Base);\n  bool shouldDeleteForField(FieldDecl *FD);\n  bool shouldDeleteForAllConstMembers();\n\n  bool shouldDeleteForClassSubobject(CXXRecordDecl *Class, Subobject Subobj,\n                                     unsigned Quals);\n  bool shouldDeleteForSubobjectCall(Subobject Subobj,\n                                    Sema::SpecialMemberOverloadResult SMOR,\n                                    bool IsDtorCallInCtor);\n\n  bool isAccessible(Subobject Subobj, CXXMethodDecl *D);\n};\n}\n\n/// Is the given special member inaccessible when used on the given\n/// sub-object.\nbool SpecialMemberDeletionInfo::isAccessible(Subobject Subobj,\n                                             CXXMethodDecl *target) {\n  /// If we're operating on a base class, the object type is the\n  /// type of this special member.\n  QualType objectTy;\n  AccessSpecifier access = target->getAccess();\n  if (CXXBaseSpecifier *base = Subobj.dyn_cast<CXXBaseSpecifier*>()) {\n    objectTy = S.Context.getTypeDeclType(MD->getParent());\n    access = CXXRecordDecl::MergeAccess(base->getAccessSpecifier(), access);\n\n  // If we're operating on a field, the object type is the type of the field.\n  } else {\n    objectTy = S.Context.getTypeDeclType(target->getParent());\n  }\n\n  return S.isMemberAccessibleForDeletion(\n      target->getParent(), DeclAccessPair::make(target, access), objectTy);\n}\n\n/// Check whether we should delete a special member due to the implicit\n/// definition containing a call to a special member of a subobject.\nbool SpecialMemberDeletionInfo::shouldDeleteForSubobjectCall(\n    Subobject Subobj, Sema::SpecialMemberOverloadResult SMOR,\n    bool IsDtorCallInCtor) {\n  CXXMethodDecl *Decl = SMOR.getMethod();\n  FieldDecl *Field = Subobj.dyn_cast<FieldDecl*>();\n\n  int DiagKind = -1;\n\n  if (SMOR.getKind() == Sema::SpecialMemberOverloadResult::NoMemberOrDeleted)\n    DiagKind = !Decl ? 0 : 1;\n  else if (SMOR.getKind() == Sema::SpecialMemberOverloadResult::Ambiguous)\n    DiagKind = 2;\n  else if (!isAccessible(Subobj, Decl))\n    DiagKind = 3;\n  else if (!IsDtorCallInCtor && Field && Field->getParent()->isUnion() &&\n           !Decl->isTrivial()) {\n    // A member of a union must have a trivial corresponding special member.\n    // As a weird special case, a destructor call from a union's constructor\n    // must be accessible and non-deleted, but need not be trivial. Such a\n    // destructor is never actually called, but is semantically checked as\n    // if it were.\n    DiagKind = 4;\n  }\n\n  if (DiagKind == -1)\n    return false;\n\n  if (Diagnose) {\n    if (Field) {\n      S.Diag(Field->getLocation(),\n             diag::note_deleted_special_member_class_subobject)\n        << getEffectiveCSM() << MD->getParent() << /*IsField*/true\n        << Field << DiagKind << IsDtorCallInCtor << /*IsObjCPtr*/false;\n    } else {\n      CXXBaseSpecifier *Base = Subobj.get<CXXBaseSpecifier*>();\n      S.Diag(Base->getBeginLoc(),\n             diag::note_deleted_special_member_class_subobject)\n          << getEffectiveCSM() << MD->getParent() << /*IsField*/ false\n          << Base->getType() << DiagKind << IsDtorCallInCtor\n          << /*IsObjCPtr*/false;\n    }\n\n    if (DiagKind == 1)\n      S.NoteDeletedFunction(Decl);\n    // FIXME: Explain inaccessibility if DiagKind == 3.\n  }\n\n  return true;\n}\n\n/// Check whether we should delete a special member function due to having a\n/// direct or virtual base class or non-static data member of class type M.\nbool SpecialMemberDeletionInfo::shouldDeleteForClassSubobject(\n    CXXRecordDecl *Class, Subobject Subobj, unsigned Quals) {\n  FieldDecl *Field = Subobj.dyn_cast<FieldDecl*>();\n  bool IsMutable = Field && Field->isMutable();\n\n  // C++11 [class.ctor]p5:\n  // -- any direct or virtual base class, or non-static data member with no\n  //    brace-or-equal-initializer, has class type M (or array thereof) and\n  //    either M has no default constructor or overload resolution as applied\n  //    to M's default constructor results in an ambiguity or in a function\n  //    that is deleted or inaccessible\n  // C++11 [class.copy]p11, C++11 [class.copy]p23:\n  // -- a direct or virtual base class B that cannot be copied/moved because\n  //    overload resolution, as applied to B's corresponding special member,\n  //    results in an ambiguity or a function that is deleted or inaccessible\n  //    from the defaulted special member\n  // C++11 [class.dtor]p5:\n  // -- any direct or virtual base class [...] has a type with a destructor\n  //    that is deleted or inaccessible\n  if (!(CSM == Sema::CXXDefaultConstructor &&\n        Field && Field->hasInClassInitializer()) &&\n      shouldDeleteForSubobjectCall(Subobj, lookupIn(Class, Quals, IsMutable),\n                                   false))\n    return true;\n\n  // C++11 [class.ctor]p5, C++11 [class.copy]p11:\n  // -- any direct or virtual base class or non-static data member has a\n  //    type with a destructor that is deleted or inaccessible\n  if (IsConstructor) {\n    Sema::SpecialMemberOverloadResult SMOR =\n        S.LookupSpecialMember(Class, Sema::CXXDestructor,\n                              false, false, false, false, false);\n    if (shouldDeleteForSubobjectCall(Subobj, SMOR, true))\n      return true;\n  }\n\n  return false;\n}\n\nbool SpecialMemberDeletionInfo::shouldDeleteForVariantObjCPtrMember(\n    FieldDecl *FD, QualType FieldType) {\n  // The defaulted special functions are defined as deleted if this is a variant\n  // member with a non-trivial ownership type, e.g., ObjC __strong or __weak\n  // type under ARC.\n  if (!FieldType.hasNonTrivialObjCLifetime())\n    return false;\n\n  // Don't make the defaulted default constructor defined as deleted if the\n  // member has an in-class initializer.\n  if (CSM == Sema::CXXDefaultConstructor && FD->hasInClassInitializer())\n    return false;\n\n  if (Diagnose) {\n    auto *ParentClass = cast<CXXRecordDecl>(FD->getParent());\n    S.Diag(FD->getLocation(),\n           diag::note_deleted_special_member_class_subobject)\n        << getEffectiveCSM() << ParentClass << /*IsField*/true\n        << FD << 4 << /*IsDtorCallInCtor*/false << /*IsObjCPtr*/true;\n  }\n\n  return true;\n}\n\n/// Check whether we should delete a special member function due to the class\n/// having a particular direct or virtual base class.\nbool SpecialMemberDeletionInfo::shouldDeleteForBase(CXXBaseSpecifier *Base) {\n  CXXRecordDecl *BaseClass = Base->getType()->getAsCXXRecordDecl();\n  // If program is correct, BaseClass cannot be null, but if it is, the error\n  // must be reported elsewhere.\n  if (!BaseClass)\n    return false;\n  // If we have an inheriting constructor, check whether we're calling an\n  // inherited constructor instead of a default constructor.\n  Sema::SpecialMemberOverloadResult SMOR = lookupInheritedCtor(BaseClass);\n  if (auto *BaseCtor = SMOR.getMethod()) {\n    // Note that we do not check access along this path; other than that,\n    // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);\n    // FIXME: Check that the base has a usable destructor! Sink this into\n    // shouldDeleteForClassSubobject.\n    if (BaseCtor->isDeleted() && Diagnose) {\n      S.Diag(Base->getBeginLoc(),\n             diag::note_deleted_special_member_class_subobject)\n          << getEffectiveCSM() << MD->getParent() << /*IsField*/ false\n          << Base->getType() << /*Deleted*/ 1 << /*IsDtorCallInCtor*/ false\n          << /*IsObjCPtr*/false;\n      S.NoteDeletedFunction(BaseCtor);\n    }\n    return BaseCtor->isDeleted();\n  }\n  return shouldDeleteForClassSubobject(BaseClass, Base, 0);\n}\n\n/// Check whether we should delete a special member function due to the class\n/// having a particular non-static data member.\nbool SpecialMemberDeletionInfo::shouldDeleteForField(FieldDecl *FD) {\n  QualType FieldType = S.Context.getBaseElementType(FD->getType());\n  CXXRecordDecl *FieldRecord = FieldType->getAsCXXRecordDecl();\n\n  if (inUnion() && shouldDeleteForVariantObjCPtrMember(FD, FieldType))\n    return true;\n\n  if (CSM == Sema::CXXDefaultConstructor) {\n    // For a default constructor, all references must be initialized in-class\n    // and, if a union, it must have a non-const member.\n    if (FieldType->isReferenceType() && !FD->hasInClassInitializer()) {\n      if (Diagnose)\n        S.Diag(FD->getLocation(), diag::note_deleted_default_ctor_uninit_field)\n          << !!ICI << MD->getParent() << FD << FieldType << /*Reference*/0;\n      return true;\n    }\n    // C++11 [class.ctor]p5: any non-variant non-static data member of\n    // const-qualified type (or array thereof) with no\n    // brace-or-equal-initializer does not have a user-provided default\n    // constructor.\n    if (!inUnion() && FieldType.isConstQualified() &&\n        !FD->hasInClassInitializer() &&\n        (!FieldRecord || !FieldRecord->hasUserProvidedDefaultConstructor())) {\n      if (Diagnose)\n        S.Diag(FD->getLocation(), diag::note_deleted_default_ctor_uninit_field)\n          << !!ICI << MD->getParent() << FD << FD->getType() << /*Const*/1;\n      return true;\n    }\n\n    if (inUnion() && !FieldType.isConstQualified())\n      AllFieldsAreConst = false;\n  } else if (CSM == Sema::CXXCopyConstructor) {\n    // For a copy constructor, data members must not be of rvalue reference\n    // type.\n    if (FieldType->isRValueReferenceType()) {\n      if (Diagnose)\n        S.Diag(FD->getLocation(), diag::note_deleted_copy_ctor_rvalue_reference)\n          << MD->getParent() << FD << FieldType;\n      return true;\n    }\n  } else if (IsAssignment) {\n    // For an assignment operator, data members must not be of reference type.\n    if (FieldType->isReferenceType()) {\n      if (Diagnose)\n        S.Diag(FD->getLocation(), diag::note_deleted_assign_field)\n          << isMove() << MD->getParent() << FD << FieldType << /*Reference*/0;\n      return true;\n    }\n    if (!FieldRecord && FieldType.isConstQualified()) {\n      // C++11 [class.copy]p23:\n      // -- a non-static data member of const non-class type (or array thereof)\n      if (Diagnose)\n        S.Diag(FD->getLocation(), diag::note_deleted_assign_field)\n          << isMove() << MD->getParent() << FD << FD->getType() << /*Const*/1;\n      return true;\n    }\n  }\n\n  if (FieldRecord) {\n    // Some additional restrictions exist on the variant members.\n    if (!inUnion() && FieldRecord->isUnion() &&\n        FieldRecord->isAnonymousStructOrUnion()) {\n      bool AllVariantFieldsAreConst = true;\n\n      // FIXME: Handle anonymous unions declared within anonymous unions.\n      for (auto *UI : FieldRecord->fields()) {\n        QualType UnionFieldType = S.Context.getBaseElementType(UI->getType());\n\n        if (shouldDeleteForVariantObjCPtrMember(&*UI, UnionFieldType))\n          return true;\n\n        if (!UnionFieldType.isConstQualified())\n          AllVariantFieldsAreConst = false;\n\n        CXXRecordDecl *UnionFieldRecord = UnionFieldType->getAsCXXRecordDecl();\n        if (UnionFieldRecord &&\n            shouldDeleteForClassSubobject(UnionFieldRecord, UI,\n                                          UnionFieldType.getCVRQualifiers()))\n          return true;\n      }\n\n      // At least one member in each anonymous union must be non-const\n      if (CSM == Sema::CXXDefaultConstructor && AllVariantFieldsAreConst &&\n          !FieldRecord->field_empty()) {\n        if (Diagnose)\n          S.Diag(FieldRecord->getLocation(),\n                 diag::note_deleted_default_ctor_all_const)\n            << !!ICI << MD->getParent() << /*anonymous union*/1;\n        return true;\n      }\n\n      // Don't check the implicit member of the anonymous union type.\n      // This is technically non-conformant, but sanity demands it.\n      return false;\n    }\n\n    if (shouldDeleteForClassSubobject(FieldRecord, FD,\n                                      FieldType.getCVRQualifiers()))\n      return true;\n  }\n\n  return false;\n}\n\n/// C++11 [class.ctor] p5:\n///   A defaulted default constructor for a class X is defined as deleted if\n/// X is a union and all of its variant members are of const-qualified type.\nbool SpecialMemberDeletionInfo::shouldDeleteForAllConstMembers() {\n  // This is a silly definition, because it gives an empty union a deleted\n  // default constructor. Don't do that.\n  if (CSM == Sema::CXXDefaultConstructor && inUnion() && AllFieldsAreConst) {\n    bool AnyFields = false;\n    for (auto *F : MD->getParent()->fields())\n      if ((AnyFields = !F->isUnnamedBitfield()))\n        break;\n    if (!AnyFields)\n      return false;\n    if (Diagnose)\n      S.Diag(MD->getParent()->getLocation(),\n             diag::note_deleted_default_ctor_all_const)\n        << !!ICI << MD->getParent() << /*not anonymous union*/0;\n    return true;\n  }\n  return false;\n}\n\n/// Determine whether a defaulted special member function should be defined as\n/// deleted, as specified in C++11 [class.ctor]p5, C++11 [class.copy]p11,\n/// C++11 [class.copy]p23, and C++11 [class.dtor]p5.\nbool Sema::ShouldDeleteSpecialMember(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                                     InheritedConstructorInfo *ICI,\n                                     bool Diagnose) {\n  if (MD->isInvalidDecl())\n    return false;\n  CXXRecordDecl *RD = MD->getParent();\n  assert(!RD->isDependentType() && \"do deletion after instantiation\");\n  if (!LangOpts.CPlusPlus11 || RD->isInvalidDecl())\n    return false;\n\n  // C++11 [expr.lambda.prim]p19:\n  //   The closure type associated with a lambda-expression has a\n  //   deleted (8.4.3) default constructor and a deleted copy\n  //   assignment operator.\n  // C++2a adds back these operators if the lambda has no lambda-capture.\n  if (RD->isLambda() && !RD->lambdaIsDefaultConstructibleAndAssignable() &&\n      (CSM == CXXDefaultConstructor || CSM == CXXCopyAssignment)) {\n    if (Diagnose)\n      Diag(RD->getLocation(), diag::note_lambda_decl);\n    return true;\n  }\n\n  // For an anonymous struct or union, the copy and assignment special members\n  // will never be used, so skip the check. For an anonymous union declared at\n  // namespace scope, the constructor and destructor are used.\n  if (CSM != CXXDefaultConstructor && CSM != CXXDestructor &&\n      RD->isAnonymousStructOrUnion())\n    return false;\n\n  // C++11 [class.copy]p7, p18:\n  //   If the class definition declares a move constructor or move assignment\n  //   operator, an implicitly declared copy constructor or copy assignment\n  //   operator is defined as deleted.\n  if (MD->isImplicit() &&\n      (CSM == CXXCopyConstructor || CSM == CXXCopyAssignment)) {\n    CXXMethodDecl *UserDeclaredMove = nullptr;\n\n    // In Microsoft mode up to MSVC 2013, a user-declared move only causes the\n    // deletion of the corresponding copy operation, not both copy operations.\n    // MSVC 2015 has adopted the standards conforming behavior.\n    bool DeletesOnlyMatchingCopy =\n        getLangOpts().MSVCCompat &&\n        !getLangOpts().isCompatibleWithMSVC(LangOptions::MSVC2015);\n\n    if (RD->hasUserDeclaredMoveConstructor() &&\n        (!DeletesOnlyMatchingCopy || CSM == CXXCopyConstructor)) {\n      if (!Diagnose) return true;\n\n      // Find any user-declared move constructor.\n      for (auto *I : RD->ctors()) {\n        if (I->isMoveConstructor()) {\n          UserDeclaredMove = I;\n          break;\n        }\n      }\n      assert(UserDeclaredMove);\n    } else if (RD->hasUserDeclaredMoveAssignment() &&\n               (!DeletesOnlyMatchingCopy || CSM == CXXCopyAssignment)) {\n      if (!Diagnose) return true;\n\n      // Find any user-declared move assignment operator.\n      for (auto *I : RD->methods()) {\n        if (I->isMoveAssignmentOperator()) {\n          UserDeclaredMove = I;\n          break;\n        }\n      }\n      assert(UserDeclaredMove);\n    }\n\n    if (UserDeclaredMove) {\n      Diag(UserDeclaredMove->getLocation(),\n           diag::note_deleted_copy_user_declared_move)\n        << (CSM == CXXCopyAssignment) << RD\n        << UserDeclaredMove->isMoveAssignmentOperator();\n      return true;\n    }\n  }\n\n  // Do access control from the special member function\n  ContextRAII MethodContext(*this, MD);\n\n  // C++11 [class.dtor]p5:\n  // -- for a virtual destructor, lookup of the non-array deallocation function\n  //    results in an ambiguity or in a function that is deleted or inaccessible\n  if (CSM == CXXDestructor && MD->isVirtual()) {\n    FunctionDecl *OperatorDelete = nullptr;\n    DeclarationName Name =\n      Context.DeclarationNames.getCXXOperatorName(OO_Delete);\n    if (FindDeallocationFunction(MD->getLocation(), MD->getParent(), Name,\n                                 OperatorDelete, /*Diagnose*/false)) {\n      if (Diagnose)\n        Diag(RD->getLocation(), diag::note_deleted_dtor_no_operator_delete);\n      return true;\n    }\n  }\n\n  SpecialMemberDeletionInfo SMI(*this, MD, CSM, ICI, Diagnose);\n\n  // Per DR1611, do not consider virtual bases of constructors of abstract\n  // classes, since we are not going to construct them.\n  // Per DR1658, do not consider virtual bases of destructors of abstract\n  // classes either.\n  // Per DR2180, for assignment operators we only assign (and thus only\n  // consider) direct bases.\n  if (SMI.visit(SMI.IsAssignment ? SMI.VisitDirectBases\n                                 : SMI.VisitPotentiallyConstructedBases))\n    return true;\n\n  if (SMI.shouldDeleteForAllConstMembers())\n    return true;\n\n  if (getLangOpts().CUDA) {\n    // We should delete the special member in CUDA mode if target inference\n    // failed.\n    // For inherited constructors (non-null ICI), CSM may be passed so that MD\n    // is treated as certain special member, which may not reflect what special\n    // member MD really is. However inferCUDATargetForImplicitSpecialMember\n    // expects CSM to match MD, therefore recalculate CSM.\n    assert(ICI || CSM == getSpecialMember(MD));\n    auto RealCSM = CSM;\n    if (ICI)\n      RealCSM = getSpecialMember(MD);\n\n    return inferCUDATargetForImplicitSpecialMember(RD, RealCSM, MD,\n                                                   SMI.ConstArg, Diagnose);\n  }\n\n  return false;\n}\n\nvoid Sema::DiagnoseDeletedDefaultedFunction(FunctionDecl *FD) {\n  DefaultedFunctionKind DFK = getDefaultedFunctionKind(FD);\n  assert(DFK && \"not a defaultable function\");\n  assert(FD->isDefaulted() && FD->isDeleted() && \"not defaulted and deleted\");\n\n  if (DFK.isSpecialMember()) {\n    ShouldDeleteSpecialMember(cast<CXXMethodDecl>(FD), DFK.asSpecialMember(),\n                              nullptr, /*Diagnose=*/true);\n  } else {\n    DefaultedComparisonAnalyzer(\n        *this, cast<CXXRecordDecl>(FD->getLexicalDeclContext()), FD,\n        DFK.asComparison(), DefaultedComparisonAnalyzer::ExplainDeleted)\n        .visit();\n  }\n}\n\n/// Perform lookup for a special member of the specified kind, and determine\n/// whether it is trivial. If the triviality can be determined without the\n/// lookup, skip it. This is intended for use when determining whether a\n/// special member of a containing object is trivial, and thus does not ever\n/// perform overload resolution for default constructors.\n///\n/// If \\p Selected is not \\c NULL, \\c *Selected will be filled in with the\n/// member that was most likely to be intended to be trivial, if any.\n///\n/// If \\p ForCall is true, look at CXXRecord::HasTrivialSpecialMembersForCall to\n/// determine whether the special member is trivial.\nstatic bool findTrivialSpecialMember(Sema &S, CXXRecordDecl *RD,\n                                     Sema::CXXSpecialMember CSM, unsigned Quals,\n                                     bool ConstRHS,\n                                     Sema::TrivialABIHandling TAH,\n                                     CXXMethodDecl **Selected) {\n  if (Selected)\n    *Selected = nullptr;\n\n  switch (CSM) {\n  case Sema::CXXInvalid:\n    llvm_unreachable(\"not a special member\");\n\n  case Sema::CXXDefaultConstructor:\n    // C++11 [class.ctor]p5:\n    //   A default constructor is trivial if:\n    //    - all the [direct subobjects] have trivial default constructors\n    //\n    // Note, no overload resolution is performed in this case.\n    if (RD->hasTrivialDefaultConstructor())\n      return true;\n\n    if (Selected) {\n      // If there's a default constructor which could have been trivial, dig it\n      // out. Otherwise, if there's any user-provided default constructor, point\n      // to that as an example of why there's not a trivial one.\n      CXXConstructorDecl *DefCtor = nullptr;\n      if (RD->needsImplicitDefaultConstructor())\n        S.DeclareImplicitDefaultConstructor(RD);\n      for (auto *CI : RD->ctors()) {\n        if (!CI->isDefaultConstructor())\n          continue;\n        DefCtor = CI;\n        if (!DefCtor->isUserProvided())\n          break;\n      }\n\n      *Selected = DefCtor;\n    }\n\n    return false;\n\n  case Sema::CXXDestructor:\n    // C++11 [class.dtor]p5:\n    //   A destructor is trivial if:\n    //    - all the direct [subobjects] have trivial destructors\n    if (RD->hasTrivialDestructor() ||\n        (TAH == Sema::TAH_ConsiderTrivialABI &&\n         RD->hasTrivialDestructorForCall()))\n      return true;\n\n    if (Selected) {\n      if (RD->needsImplicitDestructor())\n        S.DeclareImplicitDestructor(RD);\n      *Selected = RD->getDestructor();\n    }\n\n    return false;\n\n  case Sema::CXXCopyConstructor:\n    // C++11 [class.copy]p12:\n    //   A copy constructor is trivial if:\n    //    - the constructor selected to copy each direct [subobject] is trivial\n    if (RD->hasTrivialCopyConstructor() ||\n        (TAH == Sema::TAH_ConsiderTrivialABI &&\n         RD->hasTrivialCopyConstructorForCall())) {\n      if (Quals == Qualifiers::Const)\n        // We must either select the trivial copy constructor or reach an\n        // ambiguity; no need to actually perform overload resolution.\n        return true;\n    } else if (!Selected) {\n      return false;\n    }\n    // In C++98, we are not supposed to perform overload resolution here, but we\n    // treat that as a language defect, as suggested on cxx-abi-dev, to treat\n    // cases like B as having a non-trivial copy constructor:\n    //   struct A { template<typename T> A(T&); };\n    //   struct B { mutable A a; };\n    goto NeedOverloadResolution;\n\n  case Sema::CXXCopyAssignment:\n    // C++11 [class.copy]p25:\n    //   A copy assignment operator is trivial if:\n    //    - the assignment operator selected to copy each direct [subobject] is\n    //      trivial\n    if (RD->hasTrivialCopyAssignment()) {\n      if (Quals == Qualifiers::Const)\n        return true;\n    } else if (!Selected) {\n      return false;\n    }\n    // In C++98, we are not supposed to perform overload resolution here, but we\n    // treat that as a language defect.\n    goto NeedOverloadResolution;\n\n  case Sema::CXXMoveConstructor:\n  case Sema::CXXMoveAssignment:\n  NeedOverloadResolution:\n    Sema::SpecialMemberOverloadResult SMOR =\n        lookupCallFromSpecialMember(S, RD, CSM, Quals, ConstRHS);\n\n    // The standard doesn't describe how to behave if the lookup is ambiguous.\n    // We treat it as not making the member non-trivial, just like the standard\n    // mandates for the default constructor. This should rarely matter, because\n    // the member will also be deleted.\n    if (SMOR.getKind() == Sema::SpecialMemberOverloadResult::Ambiguous)\n      return true;\n\n    if (!SMOR.getMethod()) {\n      assert(SMOR.getKind() ==\n             Sema::SpecialMemberOverloadResult::NoMemberOrDeleted);\n      return false;\n    }\n\n    // We deliberately don't check if we found a deleted special member. We're\n    // not supposed to!\n    if (Selected)\n      *Selected = SMOR.getMethod();\n\n    if (TAH == Sema::TAH_ConsiderTrivialABI &&\n        (CSM == Sema::CXXCopyConstructor || CSM == Sema::CXXMoveConstructor))\n      return SMOR.getMethod()->isTrivialForCall();\n    return SMOR.getMethod()->isTrivial();\n  }\n\n  llvm_unreachable(\"unknown special method kind\");\n}\n\nstatic CXXConstructorDecl *findUserDeclaredCtor(CXXRecordDecl *RD) {\n  for (auto *CI : RD->ctors())\n    if (!CI->isImplicit())\n      return CI;\n\n  // Look for constructor templates.\n  typedef CXXRecordDecl::specific_decl_iterator<FunctionTemplateDecl> tmpl_iter;\n  for (tmpl_iter TI(RD->decls_begin()), TE(RD->decls_end()); TI != TE; ++TI) {\n    if (CXXConstructorDecl *CD =\n          dyn_cast<CXXConstructorDecl>(TI->getTemplatedDecl()))\n      return CD;\n  }\n\n  return nullptr;\n}\n\n/// The kind of subobject we are checking for triviality. The values of this\n/// enumeration are used in diagnostics.\nenum TrivialSubobjectKind {\n  /// The subobject is a base class.\n  TSK_BaseClass,\n  /// The subobject is a non-static data member.\n  TSK_Field,\n  /// The object is actually the complete object.\n  TSK_CompleteObject\n};\n\n/// Check whether the special member selected for a given type would be trivial.\nstatic bool checkTrivialSubobjectCall(Sema &S, SourceLocation SubobjLoc,\n                                      QualType SubType, bool ConstRHS,\n                                      Sema::CXXSpecialMember CSM,\n                                      TrivialSubobjectKind Kind,\n                                      Sema::TrivialABIHandling TAH, bool Diagnose) {\n  CXXRecordDecl *SubRD = SubType->getAsCXXRecordDecl();\n  if (!SubRD)\n    return true;\n\n  CXXMethodDecl *Selected;\n  if (findTrivialSpecialMember(S, SubRD, CSM, SubType.getCVRQualifiers(),\n                               ConstRHS, TAH, Diagnose ? &Selected : nullptr))\n    return true;\n\n  if (Diagnose) {\n    if (ConstRHS)\n      SubType.addConst();\n\n    if (!Selected && CSM == Sema::CXXDefaultConstructor) {\n      S.Diag(SubobjLoc, diag::note_nontrivial_no_def_ctor)\n        << Kind << SubType.getUnqualifiedType();\n      if (CXXConstructorDecl *CD = findUserDeclaredCtor(SubRD))\n        S.Diag(CD->getLocation(), diag::note_user_declared_ctor);\n    } else if (!Selected)\n      S.Diag(SubobjLoc, diag::note_nontrivial_no_copy)\n        << Kind << SubType.getUnqualifiedType() << CSM << SubType;\n    else if (Selected->isUserProvided()) {\n      if (Kind == TSK_CompleteObject)\n        S.Diag(Selected->getLocation(), diag::note_nontrivial_user_provided)\n          << Kind << SubType.getUnqualifiedType() << CSM;\n      else {\n        S.Diag(SubobjLoc, diag::note_nontrivial_user_provided)\n          << Kind << SubType.getUnqualifiedType() << CSM;\n        S.Diag(Selected->getLocation(), diag::note_declared_at);\n      }\n    } else {\n      if (Kind != TSK_CompleteObject)\n        S.Diag(SubobjLoc, diag::note_nontrivial_subobject)\n          << Kind << SubType.getUnqualifiedType() << CSM;\n\n      // Explain why the defaulted or deleted special member isn't trivial.\n      S.SpecialMemberIsTrivial(Selected, CSM, Sema::TAH_IgnoreTrivialABI,\n                               Diagnose);\n    }\n  }\n\n  return false;\n}\n\n/// Check whether the members of a class type allow a special member to be\n/// trivial.\nstatic bool checkTrivialClassMembers(Sema &S, CXXRecordDecl *RD,\n                                     Sema::CXXSpecialMember CSM,\n                                     bool ConstArg,\n                                     Sema::TrivialABIHandling TAH,\n                                     bool Diagnose) {\n  for (const auto *FI : RD->fields()) {\n    if (FI->isInvalidDecl() || FI->isUnnamedBitfield())\n      continue;\n\n    QualType FieldType = S.Context.getBaseElementType(FI->getType());\n\n    // Pretend anonymous struct or union members are members of this class.\n    if (FI->isAnonymousStructOrUnion()) {\n      if (!checkTrivialClassMembers(S, FieldType->getAsCXXRecordDecl(),\n                                    CSM, ConstArg, TAH, Diagnose))\n        return false;\n      continue;\n    }\n\n    // C++11 [class.ctor]p5:\n    //   A default constructor is trivial if [...]\n    //    -- no non-static data member of its class has a\n    //       brace-or-equal-initializer\n    if (CSM == Sema::CXXDefaultConstructor && FI->hasInClassInitializer()) {\n      if (Diagnose)\n        S.Diag(FI->getLocation(), diag::note_nontrivial_default_member_init)\n            << FI;\n      return false;\n    }\n\n    // Objective C ARC 4.3.5:\n    //   [...] nontrivally ownership-qualified types are [...] not trivially\n    //   default constructible, copy constructible, move constructible, copy\n    //   assignable, move assignable, or destructible [...]\n    if (FieldType.hasNonTrivialObjCLifetime()) {\n      if (Diagnose)\n        S.Diag(FI->getLocation(), diag::note_nontrivial_objc_ownership)\n          << RD << FieldType.getObjCLifetime();\n      return false;\n    }\n\n    bool ConstRHS = ConstArg && !FI->isMutable();\n    if (!checkTrivialSubobjectCall(S, FI->getLocation(), FieldType, ConstRHS,\n                                   CSM, TSK_Field, TAH, Diagnose))\n      return false;\n  }\n\n  return true;\n}\n\n/// Diagnose why the specified class does not have a trivial special member of\n/// the given kind.\nvoid Sema::DiagnoseNontrivial(const CXXRecordDecl *RD, CXXSpecialMember CSM) {\n  QualType Ty = Context.getRecordType(RD);\n\n  bool ConstArg = (CSM == CXXCopyConstructor || CSM == CXXCopyAssignment);\n  checkTrivialSubobjectCall(*this, RD->getLocation(), Ty, ConstArg, CSM,\n                            TSK_CompleteObject, TAH_IgnoreTrivialABI,\n                            /*Diagnose*/true);\n}\n\n/// Determine whether a defaulted or deleted special member function is trivial,\n/// as specified in C++11 [class.ctor]p5, C++11 [class.copy]p12,\n/// C++11 [class.copy]p25, and C++11 [class.dtor]p5.\nbool Sema::SpecialMemberIsTrivial(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                                  TrivialABIHandling TAH, bool Diagnose) {\n  assert(!MD->isUserProvided() && CSM != CXXInvalid && \"not special enough\");\n\n  CXXRecordDecl *RD = MD->getParent();\n\n  bool ConstArg = false;\n\n  // C++11 [class.copy]p12, p25: [DR1593]\n  //   A [special member] is trivial if [...] its parameter-type-list is\n  //   equivalent to the parameter-type-list of an implicit declaration [...]\n  switch (CSM) {\n  case CXXDefaultConstructor:\n  case CXXDestructor:\n    // Trivial default constructors and destructors cannot have parameters.\n    break;\n\n  case CXXCopyConstructor:\n  case CXXCopyAssignment: {\n    // Trivial copy operations always have const, non-volatile parameter types.\n    ConstArg = true;\n    const ParmVarDecl *Param0 = MD->getParamDecl(0);\n    const ReferenceType *RT = Param0->getType()->getAs<ReferenceType>();\n    if (!RT || RT->getPointeeType().getCVRQualifiers() != Qualifiers::Const) {\n      if (Diagnose)\n        Diag(Param0->getLocation(), diag::note_nontrivial_param_type)\n          << Param0->getSourceRange() << Param0->getType()\n          << Context.getLValueReferenceType(\n               Context.getRecordType(RD).withConst());\n      return false;\n    }\n    break;\n  }\n\n  case CXXMoveConstructor:\n  case CXXMoveAssignment: {\n    // Trivial move operations always have non-cv-qualified parameters.\n    const ParmVarDecl *Param0 = MD->getParamDecl(0);\n    const RValueReferenceType *RT =\n      Param0->getType()->getAs<RValueReferenceType>();\n    if (!RT || RT->getPointeeType().getCVRQualifiers()) {\n      if (Diagnose)\n        Diag(Param0->getLocation(), diag::note_nontrivial_param_type)\n          << Param0->getSourceRange() << Param0->getType()\n          << Context.getRValueReferenceType(Context.getRecordType(RD));\n      return false;\n    }\n    break;\n  }\n\n  case CXXInvalid:\n    llvm_unreachable(\"not a special member\");\n  }\n\n  if (MD->getMinRequiredArguments() < MD->getNumParams()) {\n    if (Diagnose)\n      Diag(MD->getParamDecl(MD->getMinRequiredArguments())->getLocation(),\n           diag::note_nontrivial_default_arg)\n        << MD->getParamDecl(MD->getMinRequiredArguments())->getSourceRange();\n    return false;\n  }\n  if (MD->isVariadic()) {\n    if (Diagnose)\n      Diag(MD->getLocation(), diag::note_nontrivial_variadic);\n    return false;\n  }\n\n  // C++11 [class.ctor]p5, C++11 [class.dtor]p5:\n  //   A copy/move [constructor or assignment operator] is trivial if\n  //    -- the [member] selected to copy/move each direct base class subobject\n  //       is trivial\n  //\n  // C++11 [class.copy]p12, C++11 [class.copy]p25:\n  //   A [default constructor or destructor] is trivial if\n  //    -- all the direct base classes have trivial [default constructors or\n  //       destructors]\n  for (const auto &BI : RD->bases())\n    if (!checkTrivialSubobjectCall(*this, BI.getBeginLoc(), BI.getType(),\n                                   ConstArg, CSM, TSK_BaseClass, TAH, Diagnose))\n      return false;\n\n  // C++11 [class.ctor]p5, C++11 [class.dtor]p5:\n  //   A copy/move [constructor or assignment operator] for a class X is\n  //   trivial if\n  //    -- for each non-static data member of X that is of class type (or array\n  //       thereof), the constructor selected to copy/move that member is\n  //       trivial\n  //\n  // C++11 [class.copy]p12, C++11 [class.copy]p25:\n  //   A [default constructor or destructor] is trivial if\n  //    -- for all of the non-static data members of its class that are of class\n  //       type (or array thereof), each such class has a trivial [default\n  //       constructor or destructor]\n  if (!checkTrivialClassMembers(*this, RD, CSM, ConstArg, TAH, Diagnose))\n    return false;\n\n  // C++11 [class.dtor]p5:\n  //   A destructor is trivial if [...]\n  //    -- the destructor is not virtual\n  if (CSM == CXXDestructor && MD->isVirtual()) {\n    if (Diagnose)\n      Diag(MD->getLocation(), diag::note_nontrivial_virtual_dtor) << RD;\n    return false;\n  }\n\n  // C++11 [class.ctor]p5, C++11 [class.copy]p12, C++11 [class.copy]p25:\n  //   A [special member] for class X is trivial if [...]\n  //    -- class X has no virtual functions and no virtual base classes\n  if (CSM != CXXDestructor && MD->getParent()->isDynamicClass()) {\n    if (!Diagnose)\n      return false;\n\n    if (RD->getNumVBases()) {\n      // Check for virtual bases. We already know that the corresponding\n      // member in all bases is trivial, so vbases must all be direct.\n      CXXBaseSpecifier &BS = *RD->vbases_begin();\n      assert(BS.isVirtual());\n      Diag(BS.getBeginLoc(), diag::note_nontrivial_has_virtual) << RD << 1;\n      return false;\n    }\n\n    // Must have a virtual method.\n    for (const auto *MI : RD->methods()) {\n      if (MI->isVirtual()) {\n        SourceLocation MLoc = MI->getBeginLoc();\n        Diag(MLoc, diag::note_nontrivial_has_virtual) << RD << 0;\n        return false;\n      }\n    }\n\n    llvm_unreachable(\"dynamic class with no vbases and no virtual functions\");\n  }\n\n  // Looks like it's trivial!\n  return true;\n}\n\nnamespace {\nstruct FindHiddenVirtualMethod {\n  Sema *S;\n  CXXMethodDecl *Method;\n  llvm::SmallPtrSet<const CXXMethodDecl *, 8> OverridenAndUsingBaseMethods;\n  SmallVector<CXXMethodDecl *, 8> OverloadedMethods;\n\nprivate:\n  /// Check whether any most overridden method from MD in Methods\n  static bool CheckMostOverridenMethods(\n      const CXXMethodDecl *MD,\n      const llvm::SmallPtrSetImpl<const CXXMethodDecl *> &Methods) {\n    if (MD->size_overridden_methods() == 0)\n      return Methods.count(MD->getCanonicalDecl());\n    for (const CXXMethodDecl *O : MD->overridden_methods())\n      if (CheckMostOverridenMethods(O, Methods))\n        return true;\n    return false;\n  }\n\npublic:\n  /// Member lookup function that determines whether a given C++\n  /// method overloads virtual methods in a base class without overriding any,\n  /// to be used with CXXRecordDecl::lookupInBases().\n  bool operator()(const CXXBaseSpecifier *Specifier, CXXBasePath &Path) {\n    RecordDecl *BaseRecord =\n        Specifier->getType()->castAs<RecordType>()->getDecl();\n\n    DeclarationName Name = Method->getDeclName();\n    assert(Name.getNameKind() == DeclarationName::Identifier);\n\n    bool foundSameNameMethod = false;\n    SmallVector<CXXMethodDecl *, 8> overloadedMethods;\n    for (Path.Decls = BaseRecord->lookup(Name); !Path.Decls.empty();\n         Path.Decls = Path.Decls.slice(1)) {\n      NamedDecl *D = Path.Decls.front();\n      if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(D)) {\n        MD = MD->getCanonicalDecl();\n        foundSameNameMethod = true;\n        // Interested only in hidden virtual methods.\n        if (!MD->isVirtual())\n          continue;\n        // If the method we are checking overrides a method from its base\n        // don't warn about the other overloaded methods. Clang deviates from\n        // GCC by only diagnosing overloads of inherited virtual functions that\n        // do not override any other virtual functions in the base. GCC's\n        // -Woverloaded-virtual diagnoses any derived function hiding a virtual\n        // function from a base class. These cases may be better served by a\n        // warning (not specific to virtual functions) on call sites when the\n        // call would select a different function from the base class, were it\n        // visible.\n        // See FIXME in test/SemaCXX/warn-overload-virtual.cpp for an example.\n        if (!S->IsOverload(Method, MD, false))\n          return true;\n        // Collect the overload only if its hidden.\n        if (!CheckMostOverridenMethods(MD, OverridenAndUsingBaseMethods))\n          overloadedMethods.push_back(MD);\n      }\n    }\n\n    if (foundSameNameMethod)\n      OverloadedMethods.append(overloadedMethods.begin(),\n                               overloadedMethods.end());\n    return foundSameNameMethod;\n  }\n};\n} // end anonymous namespace\n\n/// Add the most overriden methods from MD to Methods\nstatic void AddMostOverridenMethods(const CXXMethodDecl *MD,\n                        llvm::SmallPtrSetImpl<const CXXMethodDecl *>& Methods) {\n  if (MD->size_overridden_methods() == 0)\n    Methods.insert(MD->getCanonicalDecl());\n  else\n    for (const CXXMethodDecl *O : MD->overridden_methods())\n      AddMostOverridenMethods(O, Methods);\n}\n\n/// Check if a method overloads virtual methods in a base class without\n/// overriding any.\nvoid Sema::FindHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods) {\n  if (!MD->getDeclName().isIdentifier())\n    return;\n\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, // true to look in all bases.\n                     /*bool RecordPaths=*/false,\n                     /*bool DetectVirtual=*/false);\n  FindHiddenVirtualMethod FHVM;\n  FHVM.Method = MD;\n  FHVM.S = this;\n\n  // Keep the base methods that were overridden or introduced in the subclass\n  // by 'using' in a set. A base method not in this set is hidden.\n  CXXRecordDecl *DC = MD->getParent();\n  DeclContext::lookup_result R = DC->lookup(MD->getDeclName());\n  for (DeclContext::lookup_iterator I = R.begin(), E = R.end(); I != E; ++I) {\n    NamedDecl *ND = *I;\n    if (UsingShadowDecl *shad = dyn_cast<UsingShadowDecl>(*I))\n      ND = shad->getTargetDecl();\n    if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(ND))\n      AddMostOverridenMethods(MD, FHVM.OverridenAndUsingBaseMethods);\n  }\n\n  if (DC->lookupInBases(FHVM, Paths))\n    OverloadedMethods = FHVM.OverloadedMethods;\n}\n\nvoid Sema::NoteHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods) {\n  for (unsigned i = 0, e = OverloadedMethods.size(); i != e; ++i) {\n    CXXMethodDecl *overloadedMD = OverloadedMethods[i];\n    PartialDiagnostic PD = PDiag(\n         diag::note_hidden_overloaded_virtual_declared_here) << overloadedMD;\n    HandleFunctionTypeMismatch(PD, MD->getType(), overloadedMD->getType());\n    Diag(overloadedMD->getLocation(), PD);\n  }\n}\n\n/// Diagnose methods which overload virtual methods in a base class\n/// without overriding any.\nvoid Sema::DiagnoseHiddenVirtualMethods(CXXMethodDecl *MD) {\n  if (MD->isInvalidDecl())\n    return;\n\n  if (Diags.isIgnored(diag::warn_overloaded_virtual, MD->getLocation()))\n    return;\n\n  SmallVector<CXXMethodDecl *, 8> OverloadedMethods;\n  FindHiddenVirtualMethods(MD, OverloadedMethods);\n  if (!OverloadedMethods.empty()) {\n    Diag(MD->getLocation(), diag::warn_overloaded_virtual)\n      << MD << (OverloadedMethods.size() > 1);\n\n    NoteHiddenVirtualMethods(MD, OverloadedMethods);\n  }\n}\n\nvoid Sema::checkIllFormedTrivialABIStruct(CXXRecordDecl &RD) {\n  auto PrintDiagAndRemoveAttr = [&](unsigned N) {\n    // No diagnostics if this is a template instantiation.\n    if (!isTemplateInstantiation(RD.getTemplateSpecializationKind())) {\n      Diag(RD.getAttr<TrivialABIAttr>()->getLocation(),\n           diag::ext_cannot_use_trivial_abi) << &RD;\n      Diag(RD.getAttr<TrivialABIAttr>()->getLocation(),\n           diag::note_cannot_use_trivial_abi_reason) << &RD << N;\n    }\n    RD.dropAttr<TrivialABIAttr>();\n  };\n\n  // Ill-formed if the copy and move constructors are deleted.\n  auto HasNonDeletedCopyOrMoveConstructor = [&]() {\n    // If the type is dependent, then assume it might have\n    // implicit copy or move ctor because we won't know yet at this point.\n    if (RD.isDependentType())\n      return true;\n    if (RD.needsImplicitCopyConstructor() &&\n        !RD.defaultedCopyConstructorIsDeleted())\n      return true;\n    if (RD.needsImplicitMoveConstructor() &&\n        !RD.defaultedMoveConstructorIsDeleted())\n      return true;\n    for (const CXXConstructorDecl *CD : RD.ctors())\n      if (CD->isCopyOrMoveConstructor() && !CD->isDeleted())\n        return true;\n    return false;\n  };\n\n  if (!HasNonDeletedCopyOrMoveConstructor()) {\n    PrintDiagAndRemoveAttr(0);\n    return;\n  }\n\n  // Ill-formed if the struct has virtual functions.\n  if (RD.isPolymorphic()) {\n    PrintDiagAndRemoveAttr(1);\n    return;\n  }\n\n  for (const auto &B : RD.bases()) {\n    // Ill-formed if the base class is non-trivial for the purpose of calls or a\n    // virtual base.\n    if (!B.getType()->isDependentType() &&\n        !B.getType()->getAsCXXRecordDecl()->canPassInRegisters()) {\n      PrintDiagAndRemoveAttr(2);\n      return;\n    }\n\n    if (B.isVirtual()) {\n      PrintDiagAndRemoveAttr(3);\n      return;\n    }\n  }\n\n  for (const auto *FD : RD.fields()) {\n    // Ill-formed if the field is an ObjectiveC pointer or of a type that is\n    // non-trivial for the purpose of calls.\n    QualType FT = FD->getType();\n    if (FT.getObjCLifetime() == Qualifiers::OCL_Weak) {\n      PrintDiagAndRemoveAttr(4);\n      return;\n    }\n\n    if (const auto *RT = FT->getBaseElementTypeUnsafe()->getAs<RecordType>())\n      if (!RT->isDependentType() &&\n          !cast<CXXRecordDecl>(RT->getDecl())->canPassInRegisters()) {\n        PrintDiagAndRemoveAttr(5);\n        return;\n      }\n  }\n}\n\nvoid Sema::ActOnFinishCXXMemberSpecification(\n    Scope *S, SourceLocation RLoc, Decl *TagDecl, SourceLocation LBrac,\n    SourceLocation RBrac, const ParsedAttributesView &AttrList) {\n  if (!TagDecl)\n    return;\n\n  AdjustDeclIfTemplate(TagDecl);\n\n  for (const ParsedAttr &AL : AttrList) {\n    if (AL.getKind() != ParsedAttr::AT_Visibility)\n      continue;\n    AL.setInvalid();\n    Diag(AL.getLoc(), diag::warn_attribute_after_definition_ignored) << AL;\n  }\n\n  ActOnFields(S, RLoc, TagDecl, llvm::makeArrayRef(\n              // strict aliasing violation!\n              reinterpret_cast<Decl**>(FieldCollector->getCurFields()),\n              FieldCollector->getCurNumFields()), LBrac, RBrac, AttrList);\n\n  CheckCompletedCXXClass(S, cast<CXXRecordDecl>(TagDecl));\n}\n\n/// Find the equality comparison functions that should be implicitly declared\n/// in a given class definition, per C++2a [class.compare.default]p3.\nstatic void findImplicitlyDeclaredEqualityComparisons(\n    ASTContext &Ctx, CXXRecordDecl *RD,\n    llvm::SmallVectorImpl<FunctionDecl *> &Spaceships) {\n  DeclarationName EqEq = Ctx.DeclarationNames.getCXXOperatorName(OO_EqualEqual);\n  if (!RD->lookup(EqEq).empty())\n    // Member operator== explicitly declared: no implicit operator==s.\n    return;\n\n  // Traverse friends looking for an '==' or a '<=>'.\n  for (FriendDecl *Friend : RD->friends()) {\n    FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(Friend->getFriendDecl());\n    if (!FD) continue;\n\n    if (FD->getOverloadedOperator() == OO_EqualEqual) {\n      // Friend operator== explicitly declared: no implicit operator==s.\n      Spaceships.clear();\n      return;\n    }\n\n    if (FD->getOverloadedOperator() == OO_Spaceship &&\n        FD->isExplicitlyDefaulted())\n      Spaceships.push_back(FD);\n  }\n\n  // Look for members named 'operator<=>'.\n  DeclarationName Cmp = Ctx.DeclarationNames.getCXXOperatorName(OO_Spaceship);\n  for (NamedDecl *ND : RD->lookup(Cmp)) {\n    // Note that we could find a non-function here (either a function template\n    // or a using-declaration). Neither case results in an implicit\n    // 'operator=='.\n    if (auto *FD = dyn_cast<FunctionDecl>(ND))\n      if (FD->isExplicitlyDefaulted())\n        Spaceships.push_back(FD);\n  }\n}\n\n/// AddImplicitlyDeclaredMembersToClass - Adds any implicitly-declared\n/// special functions, such as the default constructor, copy\n/// constructor, or destructor, to the given C++ class (C++\n/// [special]p1).  This routine can only be executed just before the\n/// definition of the class is complete.\nvoid Sema::AddImplicitlyDeclaredMembersToClass(CXXRecordDecl *ClassDecl) {\n  // Don't add implicit special members to templated classes.\n  // FIXME: This means unqualified lookups for 'operator=' within a class\n  // template don't work properly.\n  if (!ClassDecl->isDependentType()) {\n    if (ClassDecl->needsImplicitDefaultConstructor()) {\n      ++getASTContext().NumImplicitDefaultConstructors;\n\n      if (ClassDecl->hasInheritedConstructor())\n        DeclareImplicitDefaultConstructor(ClassDecl);\n    }\n\n    if (ClassDecl->needsImplicitCopyConstructor()) {\n      ++getASTContext().NumImplicitCopyConstructors;\n\n      // If the properties or semantics of the copy constructor couldn't be\n      // determined while the class was being declared, force a declaration\n      // of it now.\n      if (ClassDecl->needsOverloadResolutionForCopyConstructor() ||\n          ClassDecl->hasInheritedConstructor())\n        DeclareImplicitCopyConstructor(ClassDecl);\n      // For the MS ABI we need to know whether the copy ctor is deleted. A\n      // prerequisite for deleting the implicit copy ctor is that the class has\n      // a move ctor or move assignment that is either user-declared or whose\n      // semantics are inherited from a subobject. FIXME: We should provide a\n      // more direct way for CodeGen to ask whether the constructor was deleted.\n      else if (Context.getTargetInfo().getCXXABI().isMicrosoft() &&\n               (ClassDecl->hasUserDeclaredMoveConstructor() ||\n                ClassDecl->needsOverloadResolutionForMoveConstructor() ||\n                ClassDecl->hasUserDeclaredMoveAssignment() ||\n                ClassDecl->needsOverloadResolutionForMoveAssignment()))\n        DeclareImplicitCopyConstructor(ClassDecl);\n    }\n\n    if (getLangOpts().CPlusPlus11 &&\n        ClassDecl->needsImplicitMoveConstructor()) {\n      ++getASTContext().NumImplicitMoveConstructors;\n\n      if (ClassDecl->needsOverloadResolutionForMoveConstructor() ||\n          ClassDecl->hasInheritedConstructor())\n        DeclareImplicitMoveConstructor(ClassDecl);\n    }\n\n    if (ClassDecl->needsImplicitCopyAssignment()) {\n      ++getASTContext().NumImplicitCopyAssignmentOperators;\n\n      // If we have a dynamic class, then the copy assignment operator may be\n      // virtual, so we have to declare it immediately. This ensures that, e.g.,\n      // it shows up in the right place in the vtable and that we diagnose\n      // problems with the implicit exception specification.\n      if (ClassDecl->isDynamicClass() ||\n          ClassDecl->needsOverloadResolutionForCopyAssignment() ||\n          ClassDecl->hasInheritedAssignment())\n        DeclareImplicitCopyAssignment(ClassDecl);\n    }\n\n    if (getLangOpts().CPlusPlus11 && ClassDecl->needsImplicitMoveAssignment()) {\n      ++getASTContext().NumImplicitMoveAssignmentOperators;\n\n      // Likewise for the move assignment operator.\n      if (ClassDecl->isDynamicClass() ||\n          ClassDecl->needsOverloadResolutionForMoveAssignment() ||\n          ClassDecl->hasInheritedAssignment())\n        DeclareImplicitMoveAssignment(ClassDecl);\n    }\n\n    if (ClassDecl->needsImplicitDestructor()) {\n      ++getASTContext().NumImplicitDestructors;\n\n      // If we have a dynamic class, then the destructor may be virtual, so we\n      // have to declare the destructor immediately. This ensures that, e.g., it\n      // shows up in the right place in the vtable and that we diagnose problems\n      // with the implicit exception specification.\n      if (ClassDecl->isDynamicClass() ||\n          ClassDecl->needsOverloadResolutionForDestructor())\n        DeclareImplicitDestructor(ClassDecl);\n    }\n  }\n\n  // C++2a [class.compare.default]p3:\n  //   If the member-specification does not explicitly declare any member or\n  //   friend named operator==, an == operator function is declared implicitly\n  //   for each defaulted three-way comparison operator function defined in\n  //   the member-specification\n  // FIXME: Consider doing this lazily.\n  // We do this during the initial parse for a class template, not during\n  // instantiation, so that we can handle unqualified lookups for 'operator=='\n  // when parsing the template.\n  if (getLangOpts().CPlusPlus20 && !inTemplateInstantiation()) {\n    llvm::SmallVector<FunctionDecl *, 4> DefaultedSpaceships;\n    findImplicitlyDeclaredEqualityComparisons(Context, ClassDecl,\n                                              DefaultedSpaceships);\n    for (auto *FD : DefaultedSpaceships)\n      DeclareImplicitEqualityComparison(ClassDecl, FD);\n  }\n}\n\nunsigned\nSema::ActOnReenterTemplateScope(Decl *D,\n                                llvm::function_ref<Scope *()> EnterScope) {\n  if (!D)\n    return 0;\n  AdjustDeclIfTemplate(D);\n\n  // In order to get name lookup right, reenter template scopes in order from\n  // outermost to innermost.\n  SmallVector<TemplateParameterList *, 4> ParameterLists;\n  DeclContext *LookupDC = dyn_cast<DeclContext>(D);\n\n  if (DeclaratorDecl *DD = dyn_cast<DeclaratorDecl>(D)) {\n    for (unsigned i = 0; i < DD->getNumTemplateParameterLists(); ++i)\n      ParameterLists.push_back(DD->getTemplateParameterList(i));\n\n    if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n      if (FunctionTemplateDecl *FTD = FD->getDescribedFunctionTemplate())\n        ParameterLists.push_back(FTD->getTemplateParameters());\n    } else if (VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      LookupDC = VD->getDeclContext();\n\n      if (VarTemplateDecl *VTD = VD->getDescribedVarTemplate())\n        ParameterLists.push_back(VTD->getTemplateParameters());\n      else if (auto *PSD = dyn_cast<VarTemplatePartialSpecializationDecl>(D))\n        ParameterLists.push_back(PSD->getTemplateParameters());\n    }\n  } else if (TagDecl *TD = dyn_cast<TagDecl>(D)) {\n    for (unsigned i = 0; i < TD->getNumTemplateParameterLists(); ++i)\n      ParameterLists.push_back(TD->getTemplateParameterList(i));\n\n    if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(TD)) {\n      if (ClassTemplateDecl *CTD = RD->getDescribedClassTemplate())\n        ParameterLists.push_back(CTD->getTemplateParameters());\n      else if (auto *PSD = dyn_cast<ClassTemplatePartialSpecializationDecl>(D))\n        ParameterLists.push_back(PSD->getTemplateParameters());\n    }\n  }\n  // FIXME: Alias declarations and concepts.\n\n  unsigned Count = 0;\n  Scope *InnermostTemplateScope = nullptr;\n  for (TemplateParameterList *Params : ParameterLists) {\n    // Ignore explicit specializations; they don't contribute to the template\n    // depth.\n    if (Params->size() == 0)\n      continue;\n\n    InnermostTemplateScope = EnterScope();\n    for (NamedDecl *Param : *Params) {\n      if (Param->getDeclName()) {\n        InnermostTemplateScope->AddDecl(Param);\n        IdResolver.AddDecl(Param);\n      }\n    }\n    ++Count;\n  }\n\n  // Associate the new template scopes with the corresponding entities.\n  if (InnermostTemplateScope) {\n    assert(LookupDC && \"no enclosing DeclContext for template lookup\");\n    EnterTemplatedContext(InnermostTemplateScope, LookupDC);\n  }\n\n  return Count;\n}\n\nvoid Sema::ActOnStartDelayedMemberDeclarations(Scope *S, Decl *RecordD) {\n  if (!RecordD) return;\n  AdjustDeclIfTemplate(RecordD);\n  CXXRecordDecl *Record = cast<CXXRecordDecl>(RecordD);\n  PushDeclContext(S, Record);\n}\n\nvoid Sema::ActOnFinishDelayedMemberDeclarations(Scope *S, Decl *RecordD) {\n  if (!RecordD) return;\n  PopDeclContext();\n}\n\n/// This is used to implement the constant expression evaluation part of the\n/// attribute enable_if extension. There is nothing in standard C++ which would\n/// require reentering parameters.\nvoid Sema::ActOnReenterCXXMethodParameter(Scope *S, ParmVarDecl *Param) {\n  if (!Param)\n    return;\n\n  S->AddDecl(Param);\n  if (Param->getDeclName())\n    IdResolver.AddDecl(Param);\n}\n\n/// ActOnStartDelayedCXXMethodDeclaration - We have completed\n/// parsing a top-level (non-nested) C++ class, and we are now\n/// parsing those parts of the given Method declaration that could\n/// not be parsed earlier (C++ [class.mem]p2), such as default\n/// arguments. This action should enter the scope of the given\n/// Method declaration as if we had just parsed the qualified method\n/// name. However, it should not bring the parameters into scope;\n/// that will be performed by ActOnDelayedCXXMethodParameter.\nvoid Sema::ActOnStartDelayedCXXMethodDeclaration(Scope *S, Decl *MethodD) {\n}\n\n/// ActOnDelayedCXXMethodParameter - We've already started a delayed\n/// C++ method declaration. We're (re-)introducing the given\n/// function parameter into scope for use in parsing later parts of\n/// the method declaration. For example, we could see an\n/// ActOnParamDefaultArgument event for this parameter.\nvoid Sema::ActOnDelayedCXXMethodParameter(Scope *S, Decl *ParamD) {\n  if (!ParamD)\n    return;\n\n  ParmVarDecl *Param = cast<ParmVarDecl>(ParamD);\n\n  S->AddDecl(Param);\n  if (Param->getDeclName())\n    IdResolver.AddDecl(Param);\n}\n\n/// ActOnFinishDelayedCXXMethodDeclaration - We have finished\n/// processing the delayed method declaration for Method. The method\n/// declaration is now considered finished. There may be a separate\n/// ActOnStartOfFunctionDef action later (not necessarily\n/// immediately!) for this method, if it was also defined inside the\n/// class body.\nvoid Sema::ActOnFinishDelayedCXXMethodDeclaration(Scope *S, Decl *MethodD) {\n  if (!MethodD)\n    return;\n\n  AdjustDeclIfTemplate(MethodD);\n\n  FunctionDecl *Method = cast<FunctionDecl>(MethodD);\n\n  // Now that we have our default arguments, check the constructor\n  // again. It could produce additional diagnostics or affect whether\n  // the class has implicitly-declared destructors, among other\n  // things.\n  if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(Method))\n    CheckConstructor(Constructor);\n\n  // Check the default arguments, which we may have added.\n  if (!Method->isInvalidDecl())\n    CheckCXXDefaultArguments(Method);\n}\n\n// Emit the given diagnostic for each non-address-space qualifier.\n// Common part of CheckConstructorDeclarator and CheckDestructorDeclarator.\nstatic void checkMethodTypeQualifiers(Sema &S, Declarator &D, unsigned DiagID) {\n  const DeclaratorChunk::FunctionTypeInfo &FTI = D.getFunctionTypeInfo();\n  if (FTI.hasMethodTypeQualifiers() && !D.isInvalidType()) {\n    bool DiagOccured = false;\n    FTI.MethodQualifiers->forEachQualifier(\n        [DiagID, &S, &DiagOccured](DeclSpec::TQ, StringRef QualName,\n                                   SourceLocation SL) {\n          // This diagnostic should be emitted on any qualifier except an addr\n          // space qualifier. However, forEachQualifier currently doesn't visit\n          // addr space qualifiers, so there's no way to write this condition\n          // right now; we just diagnose on everything.\n          S.Diag(SL, DiagID) << QualName << SourceRange(SL);\n          DiagOccured = true;\n        });\n    if (DiagOccured)\n      D.setInvalidType();\n  }\n}\n\n/// CheckConstructorDeclarator - Called by ActOnDeclarator to check\n/// the well-formedness of the constructor declarator @p D with type @p\n/// R. If there are any errors in the declarator, this routine will\n/// emit diagnostics and set the invalid bit to true.  In any case, the type\n/// will be updated to reflect a well-formed type for the constructor and\n/// returned.\nQualType Sema::CheckConstructorDeclarator(Declarator &D, QualType R,\n                                          StorageClass &SC) {\n  bool isVirtual = D.getDeclSpec().isVirtualSpecified();\n\n  // C++ [class.ctor]p3:\n  //   A constructor shall not be virtual (10.3) or static (9.4). A\n  //   constructor can be invoked for a const, volatile or const\n  //   volatile object. A constructor shall not be declared const,\n  //   volatile, or const volatile (9.3.2).\n  if (isVirtual) {\n    if (!D.isInvalidType())\n      Diag(D.getIdentifierLoc(), diag::err_constructor_cannot_be)\n        << \"virtual\" << SourceRange(D.getDeclSpec().getVirtualSpecLoc())\n        << SourceRange(D.getIdentifierLoc());\n    D.setInvalidType();\n  }\n  if (SC == SC_Static) {\n    if (!D.isInvalidType())\n      Diag(D.getIdentifierLoc(), diag::err_constructor_cannot_be)\n        << \"static\" << SourceRange(D.getDeclSpec().getStorageClassSpecLoc())\n        << SourceRange(D.getIdentifierLoc());\n    D.setInvalidType();\n    SC = SC_None;\n  }\n\n  if (unsigned TypeQuals = D.getDeclSpec().getTypeQualifiers()) {\n    diagnoseIgnoredQualifiers(\n        diag::err_constructor_return_type, TypeQuals, SourceLocation(),\n        D.getDeclSpec().getConstSpecLoc(), D.getDeclSpec().getVolatileSpecLoc(),\n        D.getDeclSpec().getRestrictSpecLoc(),\n        D.getDeclSpec().getAtomicSpecLoc());\n    D.setInvalidType();\n  }\n\n  checkMethodTypeQualifiers(*this, D, diag::err_invalid_qualified_constructor);\n\n  // C++0x [class.ctor]p4:\n  //   A constructor shall not be declared with a ref-qualifier.\n  DeclaratorChunk::FunctionTypeInfo &FTI = D.getFunctionTypeInfo();\n  if (FTI.hasRefQualifier()) {\n    Diag(FTI.getRefQualifierLoc(), diag::err_ref_qualifier_constructor)\n      << FTI.RefQualifierIsLValueRef\n      << FixItHint::CreateRemoval(FTI.getRefQualifierLoc());\n    D.setInvalidType();\n  }\n\n  // Rebuild the function type \"R\" without any type qualifiers (in\n  // case any of the errors above fired) and with \"void\" as the\n  // return type, since constructors don't have return types.\n  const FunctionProtoType *Proto = R->castAs<FunctionProtoType>();\n  if (Proto->getReturnType() == Context.VoidTy && !D.isInvalidType())\n    return R;\n\n  FunctionProtoType::ExtProtoInfo EPI = Proto->getExtProtoInfo();\n  EPI.TypeQuals = Qualifiers();\n  EPI.RefQualifier = RQ_None;\n\n  return Context.getFunctionType(Context.VoidTy, Proto->getParamTypes(), EPI);\n}\n\n/// CheckConstructor - Checks a fully-formed constructor for\n/// well-formedness, issuing any diagnostics required. Returns true if\n/// the constructor declarator is invalid.\nvoid Sema::CheckConstructor(CXXConstructorDecl *Constructor) {\n  CXXRecordDecl *ClassDecl\n    = dyn_cast<CXXRecordDecl>(Constructor->getDeclContext());\n  if (!ClassDecl)\n    return Constructor->setInvalidDecl();\n\n  // C++ [class.copy]p3:\n  //   A declaration of a constructor for a class X is ill-formed if\n  //   its first parameter is of type (optionally cv-qualified) X and\n  //   either there are no other parameters or else all other\n  //   parameters have default arguments.\n  if (!Constructor->isInvalidDecl() &&\n      Constructor->hasOneParamOrDefaultArgs() &&\n      Constructor->getTemplateSpecializationKind() !=\n          TSK_ImplicitInstantiation) {\n    QualType ParamType = Constructor->getParamDecl(0)->getType();\n    QualType ClassTy = Context.getTagDeclType(ClassDecl);\n    if (Context.getCanonicalType(ParamType).getUnqualifiedType() == ClassTy) {\n      SourceLocation ParamLoc = Constructor->getParamDecl(0)->getLocation();\n      const char *ConstRef\n        = Constructor->getParamDecl(0)->getIdentifier() ? \"const &\"\n                                                        : \" const &\";\n      Diag(ParamLoc, diag::err_constructor_byvalue_arg)\n        << FixItHint::CreateInsertion(ParamLoc, ConstRef);\n\n      // FIXME: Rather that making the constructor invalid, we should endeavor\n      // to fix the type.\n      Constructor->setInvalidDecl();\n    }\n  }\n}\n\n/// CheckDestructor - Checks a fully-formed destructor definition for\n/// well-formedness, issuing any diagnostics required.  Returns true\n/// on error.\nbool Sema::CheckDestructor(CXXDestructorDecl *Destructor) {\n  CXXRecordDecl *RD = Destructor->getParent();\n\n  if (!Destructor->getOperatorDelete() && Destructor->isVirtual()) {\n    SourceLocation Loc;\n\n    if (!Destructor->isImplicit())\n      Loc = Destructor->getLocation();\n    else\n      Loc = RD->getLocation();\n\n    // If we have a virtual destructor, look up the deallocation function\n    if (FunctionDecl *OperatorDelete =\n            FindDeallocationFunctionForDestructor(Loc, RD)) {\n      Expr *ThisArg = nullptr;\n\n      // If the notional 'delete this' expression requires a non-trivial\n      // conversion from 'this' to the type of a destroying operator delete's\n      // first parameter, perform that conversion now.\n      if (OperatorDelete->isDestroyingOperatorDelete()) {\n        QualType ParamType = OperatorDelete->getParamDecl(0)->getType();\n        if (!declaresSameEntity(ParamType->getAsCXXRecordDecl(), RD)) {\n          // C++ [class.dtor]p13:\n          //   ... as if for the expression 'delete this' appearing in a\n          //   non-virtual destructor of the destructor's class.\n          ContextRAII SwitchContext(*this, Destructor);\n          ExprResult This =\n              ActOnCXXThis(OperatorDelete->getParamDecl(0)->getLocation());\n          assert(!This.isInvalid() && \"couldn't form 'this' expr in dtor?\");\n          This = PerformImplicitConversion(This.get(), ParamType, AA_Passing);\n          if (This.isInvalid()) {\n            // FIXME: Register this as a context note so that it comes out\n            // in the right order.\n            Diag(Loc, diag::note_implicit_delete_this_in_destructor_here);\n            return true;\n          }\n          ThisArg = This.get();\n        }\n      }\n\n      DiagnoseUseOfDecl(OperatorDelete, Loc);\n      MarkFunctionReferenced(Loc, OperatorDelete);\n      Destructor->setOperatorDelete(OperatorDelete, ThisArg);\n    }\n  }\n\n  return false;\n}\n\n/// CheckDestructorDeclarator - Called by ActOnDeclarator to check\n/// the well-formednes of the destructor declarator @p D with type @p\n/// R. If there are any errors in the declarator, this routine will\n/// emit diagnostics and set the declarator to invalid.  Even if this happens,\n/// will be updated to reflect a well-formed type for the destructor and\n/// returned.\nQualType Sema::CheckDestructorDeclarator(Declarator &D, QualType R,\n                                         StorageClass& SC) {\n  // C++ [class.dtor]p1:\n  //   [...] A typedef-name that names a class is a class-name\n  //   (7.1.3); however, a typedef-name that names a class shall not\n  //   be used as the identifier in the declarator for a destructor\n  //   declaration.\n  QualType DeclaratorType = GetTypeFromParser(D.getName().DestructorName);\n  if (const TypedefType *TT = DeclaratorType->getAs<TypedefType>())\n    Diag(D.getIdentifierLoc(), diag::ext_destructor_typedef_name)\n      << DeclaratorType << isa<TypeAliasDecl>(TT->getDecl());\n  else if (const TemplateSpecializationType *TST =\n             DeclaratorType->getAs<TemplateSpecializationType>())\n    if (TST->isTypeAlias())\n      Diag(D.getIdentifierLoc(), diag::ext_destructor_typedef_name)\n        << DeclaratorType << 1;\n\n  // C++ [class.dtor]p2:\n  //   A destructor is used to destroy objects of its class type. A\n  //   destructor takes no parameters, and no return type can be\n  //   specified for it (not even void). The address of a destructor\n  //   shall not be taken. A destructor shall not be static. A\n  //   destructor can be invoked for a const, volatile or const\n  //   volatile object. A destructor shall not be declared const,\n  //   volatile or const volatile (9.3.2).\n  if (SC == SC_Static) {\n    if (!D.isInvalidType())\n      Diag(D.getIdentifierLoc(), diag::err_destructor_cannot_be)\n        << \"static\" << SourceRange(D.getDeclSpec().getStorageClassSpecLoc())\n        << SourceRange(D.getIdentifierLoc())\n        << FixItHint::CreateRemoval(D.getDeclSpec().getStorageClassSpecLoc());\n\n    SC = SC_None;\n  }\n  if (!D.isInvalidType()) {\n    // Destructors don't have return types, but the parser will\n    // happily parse something like:\n    //\n    //   class X {\n    //     float ~X();\n    //   };\n    //\n    // The return type will be eliminated later.\n    if (D.getDeclSpec().hasTypeSpecifier())\n      Diag(D.getIdentifierLoc(), diag::err_destructor_return_type)\n        << SourceRange(D.getDeclSpec().getTypeSpecTypeLoc())\n        << SourceRange(D.getIdentifierLoc());\n    else if (unsigned TypeQuals = D.getDeclSpec().getTypeQualifiers()) {\n      diagnoseIgnoredQualifiers(diag::err_destructor_return_type, TypeQuals,\n                                SourceLocation(),\n                                D.getDeclSpec().getConstSpecLoc(),\n                                D.getDeclSpec().getVolatileSpecLoc(),\n                                D.getDeclSpec().getRestrictSpecLoc(),\n                                D.getDeclSpec().getAtomicSpecLoc());\n      D.setInvalidType();\n    }\n  }\n\n  checkMethodTypeQualifiers(*this, D, diag::err_invalid_qualified_destructor);\n\n  // C++0x [class.dtor]p2:\n  //   A destructor shall not be declared with a ref-qualifier.\n  DeclaratorChunk::FunctionTypeInfo &FTI = D.getFunctionTypeInfo();\n  if (FTI.hasRefQualifier()) {\n    Diag(FTI.getRefQualifierLoc(), diag::err_ref_qualifier_destructor)\n      << FTI.RefQualifierIsLValueRef\n      << FixItHint::CreateRemoval(FTI.getRefQualifierLoc());\n    D.setInvalidType();\n  }\n\n  // Make sure we don't have any parameters.\n  if (FTIHasNonVoidParameters(FTI)) {\n    Diag(D.getIdentifierLoc(), diag::err_destructor_with_params);\n\n    // Delete the parameters.\n    FTI.freeParams();\n    D.setInvalidType();\n  }\n\n  // Make sure the destructor isn't variadic.\n  if (FTI.isVariadic) {\n    Diag(D.getIdentifierLoc(), diag::err_destructor_variadic);\n    D.setInvalidType();\n  }\n\n  // Rebuild the function type \"R\" without any type qualifiers or\n  // parameters (in case any of the errors above fired) and with\n  // \"void\" as the return type, since destructors don't have return\n  // types.\n  if (!D.isInvalidType())\n    return R;\n\n  const FunctionProtoType *Proto = R->castAs<FunctionProtoType>();\n  FunctionProtoType::ExtProtoInfo EPI = Proto->getExtProtoInfo();\n  EPI.Variadic = false;\n  EPI.TypeQuals = Qualifiers();\n  EPI.RefQualifier = RQ_None;\n  return Context.getFunctionType(Context.VoidTy, None, EPI);\n}\n\nstatic void extendLeft(SourceRange &R, SourceRange Before) {\n  if (Before.isInvalid())\n    return;\n  R.setBegin(Before.getBegin());\n  if (R.getEnd().isInvalid())\n    R.setEnd(Before.getEnd());\n}\n\nstatic void extendRight(SourceRange &R, SourceRange After) {\n  if (After.isInvalid())\n    return;\n  if (R.getBegin().isInvalid())\n    R.setBegin(After.getBegin());\n  R.setEnd(After.getEnd());\n}\n\n/// CheckConversionDeclarator - Called by ActOnDeclarator to check the\n/// well-formednes of the conversion function declarator @p D with\n/// type @p R. If there are any errors in the declarator, this routine\n/// will emit diagnostics and return true. Otherwise, it will return\n/// false. Either way, the type @p R will be updated to reflect a\n/// well-formed type for the conversion operator.\nvoid Sema::CheckConversionDeclarator(Declarator &D, QualType &R,\n                                     StorageClass& SC) {\n  // C++ [class.conv.fct]p1:\n  //   Neither parameter types nor return type can be specified. The\n  //   type of a conversion function (8.3.5) is \"function taking no\n  //   parameter returning conversion-type-id.\"\n  if (SC == SC_Static) {\n    if (!D.isInvalidType())\n      Diag(D.getIdentifierLoc(), diag::err_conv_function_not_member)\n        << SourceRange(D.getDeclSpec().getStorageClassSpecLoc())\n        << D.getName().getSourceRange();\n    D.setInvalidType();\n    SC = SC_None;\n  }\n\n  TypeSourceInfo *ConvTSI = nullptr;\n  QualType ConvType =\n      GetTypeFromParser(D.getName().ConversionFunctionId, &ConvTSI);\n\n  const DeclSpec &DS = D.getDeclSpec();\n  if (DS.hasTypeSpecifier() && !D.isInvalidType()) {\n    // Conversion functions don't have return types, but the parser will\n    // happily parse something like:\n    //\n    //   class X {\n    //     float operator bool();\n    //   };\n    //\n    // The return type will be changed later anyway.\n    Diag(D.getIdentifierLoc(), diag::err_conv_function_return_type)\n      << SourceRange(DS.getTypeSpecTypeLoc())\n      << SourceRange(D.getIdentifierLoc());\n    D.setInvalidType();\n  } else if (DS.getTypeQualifiers() && !D.isInvalidType()) {\n    // It's also plausible that the user writes type qualifiers in the wrong\n    // place, such as:\n    //   struct S { const operator int(); };\n    // FIXME: we could provide a fixit to move the qualifiers onto the\n    // conversion type.\n    Diag(D.getIdentifierLoc(), diag::err_conv_function_with_complex_decl)\n        << SourceRange(D.getIdentifierLoc()) << 0;\n    D.setInvalidType();\n  }\n\n  const auto *Proto = R->castAs<FunctionProtoType>();\n\n  // Make sure we don't have any parameters.\n  if (Proto->getNumParams() > 0) {\n    Diag(D.getIdentifierLoc(), diag::err_conv_function_with_params);\n\n    // Delete the parameters.\n    D.getFunctionTypeInfo().freeParams();\n    D.setInvalidType();\n  } else if (Proto->isVariadic()) {\n    Diag(D.getIdentifierLoc(), diag::err_conv_function_variadic);\n    D.setInvalidType();\n  }\n\n  // Diagnose \"&operator bool()\" and other such nonsense.  This\n  // is actually a gcc extension which we don't support.\n  if (Proto->getReturnType() != ConvType) {\n    bool NeedsTypedef = false;\n    SourceRange Before, After;\n\n    // Walk the chunks and extract information on them for our diagnostic.\n    bool PastFunctionChunk = false;\n    for (auto &Chunk : D.type_objects()) {\n      switch (Chunk.Kind) {\n      case DeclaratorChunk::Function:\n        if (!PastFunctionChunk) {\n          if (Chunk.Fun.HasTrailingReturnType) {\n            TypeSourceInfo *TRT = nullptr;\n            GetTypeFromParser(Chunk.Fun.getTrailingReturnType(), &TRT);\n            if (TRT) extendRight(After, TRT->getTypeLoc().getSourceRange());\n          }\n          PastFunctionChunk = true;\n          break;\n        }\n        LLVM_FALLTHROUGH;\n      case DeclaratorChunk::Array:\n        NeedsTypedef = true;\n        extendRight(After, Chunk.getSourceRange());\n        break;\n\n      case DeclaratorChunk::Pointer:\n      case DeclaratorChunk::BlockPointer:\n      case DeclaratorChunk::Reference:\n      case DeclaratorChunk::MemberPointer:\n      case DeclaratorChunk::Pipe:\n        extendLeft(Before, Chunk.getSourceRange());\n        break;\n\n      case DeclaratorChunk::Paren:\n        extendLeft(Before, Chunk.Loc);\n        extendRight(After, Chunk.EndLoc);\n        break;\n      }\n    }\n\n    SourceLocation Loc = Before.isValid() ? Before.getBegin() :\n                         After.isValid()  ? After.getBegin() :\n                                            D.getIdentifierLoc();\n    auto &&DB = Diag(Loc, diag::err_conv_function_with_complex_decl);\n    DB << Before << After;\n\n    if (!NeedsTypedef) {\n      DB << /*don't need a typedef*/0;\n\n      // If we can provide a correct fix-it hint, do so.\n      if (After.isInvalid() && ConvTSI) {\n        SourceLocation InsertLoc =\n            getLocForEndOfToken(ConvTSI->getTypeLoc().getEndLoc());\n        DB << FixItHint::CreateInsertion(InsertLoc, \" \")\n           << FixItHint::CreateInsertionFromRange(\n                  InsertLoc, CharSourceRange::getTokenRange(Before))\n           << FixItHint::CreateRemoval(Before);\n      }\n    } else if (!Proto->getReturnType()->isDependentType()) {\n      DB << /*typedef*/1 << Proto->getReturnType();\n    } else if (getLangOpts().CPlusPlus11) {\n      DB << /*alias template*/2 << Proto->getReturnType();\n    } else {\n      DB << /*might not be fixable*/3;\n    }\n\n    // Recover by incorporating the other type chunks into the result type.\n    // Note, this does *not* change the name of the function. This is compatible\n    // with the GCC extension:\n    //   struct S { &operator int(); } s;\n    //   int &r = s.operator int(); // ok in GCC\n    //   S::operator int&() {} // error in GCC, function name is 'operator int'.\n    ConvType = Proto->getReturnType();\n  }\n\n  // C++ [class.conv.fct]p4:\n  //   The conversion-type-id shall not represent a function type nor\n  //   an array type.\n  if (ConvType->isArrayType()) {\n    Diag(D.getIdentifierLoc(), diag::err_conv_function_to_array);\n    ConvType = Context.getPointerType(ConvType);\n    D.setInvalidType();\n  } else if (ConvType->isFunctionType()) {\n    Diag(D.getIdentifierLoc(), diag::err_conv_function_to_function);\n    ConvType = Context.getPointerType(ConvType);\n    D.setInvalidType();\n  }\n\n  // Rebuild the function type \"R\" without any parameters (in case any\n  // of the errors above fired) and with the conversion type as the\n  // return type.\n  if (D.isInvalidType())\n    R = Context.getFunctionType(ConvType, None, Proto->getExtProtoInfo());\n\n  // C++0x explicit conversion operators.\n  if (DS.hasExplicitSpecifier() && !getLangOpts().CPlusPlus20)\n    Diag(DS.getExplicitSpecLoc(),\n         getLangOpts().CPlusPlus11\n             ? diag::warn_cxx98_compat_explicit_conversion_functions\n             : diag::ext_explicit_conversion_functions)\n        << SourceRange(DS.getExplicitSpecRange());\n}\n\n/// ActOnConversionDeclarator - Called by ActOnDeclarator to complete\n/// the declaration of the given C++ conversion function. This routine\n/// is responsible for recording the conversion function in the C++\n/// class, if possible.\nDecl *Sema::ActOnConversionDeclarator(CXXConversionDecl *Conversion) {\n  assert(Conversion && \"Expected to receive a conversion function declaration\");\n\n  CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(Conversion->getDeclContext());\n\n  // Make sure we aren't redeclaring the conversion function.\n  QualType ConvType = Context.getCanonicalType(Conversion->getConversionType());\n  // C++ [class.conv.fct]p1:\n  //   [...] A conversion function is never used to convert a\n  //   (possibly cv-qualified) object to the (possibly cv-qualified)\n  //   same object type (or a reference to it), to a (possibly\n  //   cv-qualified) base class of that type (or a reference to it),\n  //   or to (possibly cv-qualified) void.\n  QualType ClassType\n    = Context.getCanonicalType(Context.getTypeDeclType(ClassDecl));\n  if (const ReferenceType *ConvTypeRef = ConvType->getAs<ReferenceType>())\n    ConvType = ConvTypeRef->getPointeeType();\n  if (Conversion->getTemplateSpecializationKind() != TSK_Undeclared &&\n      Conversion->getTemplateSpecializationKind() != TSK_ExplicitSpecialization)\n    /* Suppress diagnostics for instantiations. */;\n  else if (Conversion->size_overridden_methods() != 0)\n    /* Suppress diagnostics for overriding virtual function in a base class. */;\n  else if (ConvType->isRecordType()) {\n    ConvType = Context.getCanonicalType(ConvType).getUnqualifiedType();\n    if (ConvType == ClassType)\n      Diag(Conversion->getLocation(), diag::warn_conv_to_self_not_used)\n        << ClassType;\n    else if (IsDerivedFrom(Conversion->getLocation(), ClassType, ConvType))\n      Diag(Conversion->getLocation(), diag::warn_conv_to_base_not_used)\n        <<  ClassType << ConvType;\n  } else if (ConvType->isVoidType()) {\n    Diag(Conversion->getLocation(), diag::warn_conv_to_void_not_used)\n      << ClassType << ConvType;\n  }\n\n  if (FunctionTemplateDecl *ConversionTemplate\n                                = Conversion->getDescribedFunctionTemplate())\n    return ConversionTemplate;\n\n  return Conversion;\n}\n\nnamespace {\n/// Utility class to accumulate and print a diagnostic listing the invalid\n/// specifier(s) on a declaration.\nstruct BadSpecifierDiagnoser {\n  BadSpecifierDiagnoser(Sema &S, SourceLocation Loc, unsigned DiagID)\n      : S(S), Diagnostic(S.Diag(Loc, DiagID)) {}\n  ~BadSpecifierDiagnoser() {\n    Diagnostic << Specifiers;\n  }\n\n  template<typename T> void check(SourceLocation SpecLoc, T Spec) {\n    return check(SpecLoc, DeclSpec::getSpecifierName(Spec));\n  }\n  void check(SourceLocation SpecLoc, DeclSpec::TST Spec) {\n    return check(SpecLoc,\n                 DeclSpec::getSpecifierName(Spec, S.getPrintingPolicy()));\n  }\n  void check(SourceLocation SpecLoc, const char *Spec) {\n    if (SpecLoc.isInvalid()) return;\n    Diagnostic << SourceRange(SpecLoc, SpecLoc);\n    if (!Specifiers.empty()) Specifiers += \" \";\n    Specifiers += Spec;\n  }\n\n  Sema &S;\n  Sema::SemaDiagnosticBuilder Diagnostic;\n  std::string Specifiers;\n};\n}\n\n/// Check the validity of a declarator that we parsed for a deduction-guide.\n/// These aren't actually declarators in the grammar, so we need to check that\n/// the user didn't specify any pieces that are not part of the deduction-guide\n/// grammar.\nvoid Sema::CheckDeductionGuideDeclarator(Declarator &D, QualType &R,\n                                         StorageClass &SC) {\n  TemplateName GuidedTemplate = D.getName().TemplateName.get().get();\n  TemplateDecl *GuidedTemplateDecl = GuidedTemplate.getAsTemplateDecl();\n  assert(GuidedTemplateDecl && \"missing template decl for deduction guide\");\n\n  // C++ [temp.deduct.guide]p3:\n  //   A deduction-gide shall be declared in the same scope as the\n  //   corresponding class template.\n  if (!CurContext->getRedeclContext()->Equals(\n          GuidedTemplateDecl->getDeclContext()->getRedeclContext())) {\n    Diag(D.getIdentifierLoc(), diag::err_deduction_guide_wrong_scope)\n      << GuidedTemplateDecl;\n    Diag(GuidedTemplateDecl->getLocation(), diag::note_template_decl_here);\n  }\n\n  auto &DS = D.getMutableDeclSpec();\n  // We leave 'friend' and 'virtual' to be rejected in the normal way.\n  if (DS.hasTypeSpecifier() || DS.getTypeQualifiers() ||\n      DS.getStorageClassSpecLoc().isValid() || DS.isInlineSpecified() ||\n      DS.isNoreturnSpecified() || DS.hasConstexprSpecifier()) {\n    BadSpecifierDiagnoser Diagnoser(\n        *this, D.getIdentifierLoc(),\n        diag::err_deduction_guide_invalid_specifier);\n\n    Diagnoser.check(DS.getStorageClassSpecLoc(), DS.getStorageClassSpec());\n    DS.ClearStorageClassSpecs();\n    SC = SC_None;\n\n    // 'explicit' is permitted.\n    Diagnoser.check(DS.getInlineSpecLoc(), \"inline\");\n    Diagnoser.check(DS.getNoreturnSpecLoc(), \"_Noreturn\");\n    Diagnoser.check(DS.getConstexprSpecLoc(), \"constexpr\");\n    DS.ClearConstexprSpec();\n\n    Diagnoser.check(DS.getConstSpecLoc(), \"const\");\n    Diagnoser.check(DS.getRestrictSpecLoc(), \"__restrict\");\n    Diagnoser.check(DS.getVolatileSpecLoc(), \"volatile\");\n    Diagnoser.check(DS.getAtomicSpecLoc(), \"_Atomic\");\n    Diagnoser.check(DS.getUnalignedSpecLoc(), \"__unaligned\");\n    DS.ClearTypeQualifiers();\n\n    Diagnoser.check(DS.getTypeSpecComplexLoc(), DS.getTypeSpecComplex());\n    Diagnoser.check(DS.getTypeSpecSignLoc(), DS.getTypeSpecSign());\n    Diagnoser.check(DS.getTypeSpecWidthLoc(), DS.getTypeSpecWidth());\n    Diagnoser.check(DS.getTypeSpecTypeLoc(), DS.getTypeSpecType());\n    DS.ClearTypeSpecType();\n  }\n\n  if (D.isInvalidType())\n    return;\n\n  // Check the declarator is simple enough.\n  bool FoundFunction = false;\n  for (const DeclaratorChunk &Chunk : llvm::reverse(D.type_objects())) {\n    if (Chunk.Kind == DeclaratorChunk::Paren)\n      continue;\n    if (Chunk.Kind != DeclaratorChunk::Function || FoundFunction) {\n      Diag(D.getDeclSpec().getBeginLoc(),\n           diag::err_deduction_guide_with_complex_decl)\n          << D.getSourceRange();\n      break;\n    }\n    if (!Chunk.Fun.hasTrailingReturnType()) {\n      Diag(D.getName().getBeginLoc(),\n           diag::err_deduction_guide_no_trailing_return_type);\n      break;\n    }\n\n    // Check that the return type is written as a specialization of\n    // the template specified as the deduction-guide's name.\n    ParsedType TrailingReturnType = Chunk.Fun.getTrailingReturnType();\n    TypeSourceInfo *TSI = nullptr;\n    QualType RetTy = GetTypeFromParser(TrailingReturnType, &TSI);\n    assert(TSI && \"deduction guide has valid type but invalid return type?\");\n    bool AcceptableReturnType = false;\n    bool MightInstantiateToSpecialization = false;\n    if (auto RetTST =\n            TSI->getTypeLoc().getAs<TemplateSpecializationTypeLoc>()) {\n      TemplateName SpecifiedName = RetTST.getTypePtr()->getTemplateName();\n      bool TemplateMatches =\n          Context.hasSameTemplateName(SpecifiedName, GuidedTemplate);\n      if (SpecifiedName.getKind() == TemplateName::Template && TemplateMatches)\n        AcceptableReturnType = true;\n      else {\n        // This could still instantiate to the right type, unless we know it\n        // names the wrong class template.\n        auto *TD = SpecifiedName.getAsTemplateDecl();\n        MightInstantiateToSpecialization = !(TD && isa<ClassTemplateDecl>(TD) &&\n                                             !TemplateMatches);\n      }\n    } else if (!RetTy.hasQualifiers() && RetTy->isDependentType()) {\n      MightInstantiateToSpecialization = true;\n    }\n\n    if (!AcceptableReturnType) {\n      Diag(TSI->getTypeLoc().getBeginLoc(),\n           diag::err_deduction_guide_bad_trailing_return_type)\n          << GuidedTemplate << TSI->getType()\n          << MightInstantiateToSpecialization\n          << TSI->getTypeLoc().getSourceRange();\n    }\n\n    // Keep going to check that we don't have any inner declarator pieces (we\n    // could still have a function returning a pointer to a function).\n    FoundFunction = true;\n  }\n\n  if (D.isFunctionDefinition())\n    Diag(D.getIdentifierLoc(), diag::err_deduction_guide_defines_function);\n}\n\n//===----------------------------------------------------------------------===//\n// Namespace Handling\n//===----------------------------------------------------------------------===//\n\n/// Diagnose a mismatch in 'inline' qualifiers when a namespace is\n/// reopened.\nstatic void DiagnoseNamespaceInlineMismatch(Sema &S, SourceLocation KeywordLoc,\n                                            SourceLocation Loc,\n                                            IdentifierInfo *II, bool *IsInline,\n                                            NamespaceDecl *PrevNS) {\n  assert(*IsInline != PrevNS->isInline());\n\n  // HACK: Work around a bug in libstdc++4.6's <atomic>, where\n  // std::__atomic[0,1,2] are defined as non-inline namespaces, then reopened as\n  // inline namespaces, with the intention of bringing names into namespace std.\n  //\n  // We support this just well enough to get that case working; this is not\n  // sufficient to support reopening namespaces as inline in general.\n  if (*IsInline && II && II->getName().startswith(\"__atomic\") &&\n      S.getSourceManager().isInSystemHeader(Loc)) {\n    // Mark all prior declarations of the namespace as inline.\n    for (NamespaceDecl *NS = PrevNS->getMostRecentDecl(); NS;\n         NS = NS->getPreviousDecl())\n      NS->setInline(*IsInline);\n    // Patch up the lookup table for the containing namespace. This isn't really\n    // correct, but it's good enough for this particular case.\n    for (auto *I : PrevNS->decls())\n      if (auto *ND = dyn_cast<NamedDecl>(I))\n        PrevNS->getParent()->makeDeclVisibleInContext(ND);\n    return;\n  }\n\n  if (PrevNS->isInline())\n    // The user probably just forgot the 'inline', so suggest that it\n    // be added back.\n    S.Diag(Loc, diag::warn_inline_namespace_reopened_noninline)\n      << FixItHint::CreateInsertion(KeywordLoc, \"inline \");\n  else\n    S.Diag(Loc, diag::err_inline_namespace_mismatch);\n\n  S.Diag(PrevNS->getLocation(), diag::note_previous_definition);\n  *IsInline = PrevNS->isInline();\n}\n\n/// ActOnStartNamespaceDef - This is called at the start of a namespace\n/// definition.\nDecl *Sema::ActOnStartNamespaceDef(\n    Scope *NamespcScope, SourceLocation InlineLoc, SourceLocation NamespaceLoc,\n    SourceLocation IdentLoc, IdentifierInfo *II, SourceLocation LBrace,\n    const ParsedAttributesView &AttrList, UsingDirectiveDecl *&UD) {\n  SourceLocation StartLoc = InlineLoc.isValid() ? InlineLoc : NamespaceLoc;\n  // For anonymous namespace, take the location of the left brace.\n  SourceLocation Loc = II ? IdentLoc : LBrace;\n  bool IsInline = InlineLoc.isValid();\n  bool IsInvalid = false;\n  bool IsStd = false;\n  bool AddToKnown = false;\n  Scope *DeclRegionScope = NamespcScope->getParent();\n\n  NamespaceDecl *PrevNS = nullptr;\n  if (II) {\n    // C++ [namespace.def]p2:\n    //   The identifier in an original-namespace-definition shall not\n    //   have been previously defined in the declarative region in\n    //   which the original-namespace-definition appears. The\n    //   identifier in an original-namespace-definition is the name of\n    //   the namespace. Subsequently in that declarative region, it is\n    //   treated as an original-namespace-name.\n    //\n    // Since namespace names are unique in their scope, and we don't\n    // look through using directives, just look for any ordinary names\n    // as if by qualified name lookup.\n    LookupResult R(*this, II, IdentLoc, LookupOrdinaryName,\n                   ForExternalRedeclaration);\n    LookupQualifiedName(R, CurContext->getRedeclContext());\n    NamedDecl *PrevDecl =\n        R.isSingleResult() ? R.getRepresentativeDecl() : nullptr;\n    PrevNS = dyn_cast_or_null<NamespaceDecl>(PrevDecl);\n\n    if (PrevNS) {\n      // This is an extended namespace definition.\n      if (IsInline != PrevNS->isInline())\n        DiagnoseNamespaceInlineMismatch(*this, NamespaceLoc, Loc, II,\n                                        &IsInline, PrevNS);\n    } else if (PrevDecl) {\n      // This is an invalid name redefinition.\n      Diag(Loc, diag::err_redefinition_different_kind)\n        << II;\n      Diag(PrevDecl->getLocation(), diag::note_previous_definition);\n      IsInvalid = true;\n      // Continue on to push Namespc as current DeclContext and return it.\n    } else if (II->isStr(\"std\") &&\n               CurContext->getRedeclContext()->isTranslationUnit()) {\n      // This is the first \"real\" definition of the namespace \"std\", so update\n      // our cache of the \"std\" namespace to point at this definition.\n      PrevNS = getStdNamespace();\n      IsStd = true;\n      AddToKnown = !IsInline;\n    } else {\n      // We've seen this namespace for the first time.\n      AddToKnown = !IsInline;\n    }\n  } else {\n    // Anonymous namespaces.\n\n    // Determine whether the parent already has an anonymous namespace.\n    DeclContext *Parent = CurContext->getRedeclContext();\n    if (TranslationUnitDecl *TU = dyn_cast<TranslationUnitDecl>(Parent)) {\n      PrevNS = TU->getAnonymousNamespace();\n    } else {\n      NamespaceDecl *ND = cast<NamespaceDecl>(Parent);\n      PrevNS = ND->getAnonymousNamespace();\n    }\n\n    if (PrevNS && IsInline != PrevNS->isInline())\n      DiagnoseNamespaceInlineMismatch(*this, NamespaceLoc, NamespaceLoc, II,\n                                      &IsInline, PrevNS);\n  }\n\n  NamespaceDecl *Namespc = NamespaceDecl::Create(Context, CurContext, IsInline,\n                                                 StartLoc, Loc, II, PrevNS);\n  if (IsInvalid)\n    Namespc->setInvalidDecl();\n\n  ProcessDeclAttributeList(DeclRegionScope, Namespc, AttrList);\n  AddPragmaAttributes(DeclRegionScope, Namespc);\n\n  // FIXME: Should we be merging attributes?\n  if (const VisibilityAttr *Attr = Namespc->getAttr<VisibilityAttr>())\n    PushNamespaceVisibilityAttr(Attr, Loc);\n\n  if (IsStd)\n    StdNamespace = Namespc;\n  if (AddToKnown)\n    KnownNamespaces[Namespc] = false;\n\n  if (II) {\n    PushOnScopeChains(Namespc, DeclRegionScope);\n  } else {\n    // Link the anonymous namespace into its parent.\n    DeclContext *Parent = CurContext->getRedeclContext();\n    if (TranslationUnitDecl *TU = dyn_cast<TranslationUnitDecl>(Parent)) {\n      TU->setAnonymousNamespace(Namespc);\n    } else {\n      cast<NamespaceDecl>(Parent)->setAnonymousNamespace(Namespc);\n    }\n\n    CurContext->addDecl(Namespc);\n\n    // C++ [namespace.unnamed]p1.  An unnamed-namespace-definition\n    //   behaves as if it were replaced by\n    //     namespace unique { /* empty body */ }\n    //     using namespace unique;\n    //     namespace unique { namespace-body }\n    //   where all occurrences of 'unique' in a translation unit are\n    //   replaced by the same identifier and this identifier differs\n    //   from all other identifiers in the entire program.\n\n    // We just create the namespace with an empty name and then add an\n    // implicit using declaration, just like the standard suggests.\n    //\n    // CodeGen enforces the \"universally unique\" aspect by giving all\n    // declarations semantically contained within an anonymous\n    // namespace internal linkage.\n\n    if (!PrevNS) {\n      UD = UsingDirectiveDecl::Create(Context, Parent,\n                                      /* 'using' */ LBrace,\n                                      /* 'namespace' */ SourceLocation(),\n                                      /* qualifier */ NestedNameSpecifierLoc(),\n                                      /* identifier */ SourceLocation(),\n                                      Namespc,\n                                      /* Ancestor */ Parent);\n      UD->setImplicit();\n      Parent->addDecl(UD);\n    }\n  }\n\n  ActOnDocumentableDecl(Namespc);\n\n  // Although we could have an invalid decl (i.e. the namespace name is a\n  // redefinition), push it as current DeclContext and try to continue parsing.\n  // FIXME: We should be able to push Namespc here, so that the each DeclContext\n  // for the namespace has the declarations that showed up in that particular\n  // namespace definition.\n  PushDeclContext(NamespcScope, Namespc);\n  return Namespc;\n}\n\n/// getNamespaceDecl - Returns the namespace a decl represents. If the decl\n/// is a namespace alias, returns the namespace it points to.\nstatic inline NamespaceDecl *getNamespaceDecl(NamedDecl *D) {\n  if (NamespaceAliasDecl *AD = dyn_cast_or_null<NamespaceAliasDecl>(D))\n    return AD->getNamespace();\n  return dyn_cast_or_null<NamespaceDecl>(D);\n}\n\n/// ActOnFinishNamespaceDef - This callback is called after a namespace is\n/// exited. Decl is the DeclTy returned by ActOnStartNamespaceDef.\nvoid Sema::ActOnFinishNamespaceDef(Decl *Dcl, SourceLocation RBrace) {\n  NamespaceDecl *Namespc = dyn_cast_or_null<NamespaceDecl>(Dcl);\n  assert(Namespc && \"Invalid parameter, expected NamespaceDecl\");\n  Namespc->setRBraceLoc(RBrace);\n  PopDeclContext();\n  if (Namespc->hasAttr<VisibilityAttr>())\n    PopPragmaVisibility(true, RBrace);\n  // If this namespace contains an export-declaration, export it now.\n  if (DeferredExportedNamespaces.erase(Namespc))\n    Dcl->setModuleOwnershipKind(Decl::ModuleOwnershipKind::VisibleWhenImported);\n}\n\nCXXRecordDecl *Sema::getStdBadAlloc() const {\n  return cast_or_null<CXXRecordDecl>(\n                                  StdBadAlloc.get(Context.getExternalSource()));\n}\n\nEnumDecl *Sema::getStdAlignValT() const {\n  return cast_or_null<EnumDecl>(StdAlignValT.get(Context.getExternalSource()));\n}\n\nNamespaceDecl *Sema::getStdNamespace() const {\n  return cast_or_null<NamespaceDecl>(\n                                 StdNamespace.get(Context.getExternalSource()));\n}\n\nNamespaceDecl *Sema::lookupStdExperimentalNamespace() {\n  if (!StdExperimentalNamespaceCache) {\n    if (auto Std = getStdNamespace()) {\n      LookupResult Result(*this, &PP.getIdentifierTable().get(\"experimental\"),\n                          SourceLocation(), LookupNamespaceName);\n      if (!LookupQualifiedName(Result, Std) ||\n          !(StdExperimentalNamespaceCache =\n                Result.getAsSingle<NamespaceDecl>()))\n        Result.suppressDiagnostics();\n    }\n  }\n  return StdExperimentalNamespaceCache;\n}\n\nnamespace {\n\nenum UnsupportedSTLSelect {\n  USS_InvalidMember,\n  USS_MissingMember,\n  USS_NonTrivial,\n  USS_Other\n};\n\nstruct InvalidSTLDiagnoser {\n  Sema &S;\n  SourceLocation Loc;\n  QualType TyForDiags;\n\n  QualType operator()(UnsupportedSTLSelect Sel = USS_Other, StringRef Name = \"\",\n                      const VarDecl *VD = nullptr) {\n    {\n      auto D = S.Diag(Loc, diag::err_std_compare_type_not_supported)\n               << TyForDiags << ((int)Sel);\n      if (Sel == USS_InvalidMember || Sel == USS_MissingMember) {\n        assert(!Name.empty());\n        D << Name;\n      }\n    }\n    if (Sel == USS_InvalidMember) {\n      S.Diag(VD->getLocation(), diag::note_var_declared_here)\n          << VD << VD->getSourceRange();\n    }\n    return QualType();\n  }\n};\n} // namespace\n\nQualType Sema::CheckComparisonCategoryType(ComparisonCategoryType Kind,\n                                           SourceLocation Loc,\n                                           ComparisonCategoryUsage Usage) {\n  assert(getLangOpts().CPlusPlus &&\n         \"Looking for comparison category type outside of C++.\");\n\n  // Use an elaborated type for diagnostics which has a name containing the\n  // prepended 'std' namespace but not any inline namespace names.\n  auto TyForDiags = [&](ComparisonCategoryInfo *Info) {\n    auto *NNS =\n        NestedNameSpecifier::Create(Context, nullptr, getStdNamespace());\n    return Context.getElaboratedType(ETK_None, NNS, Info->getType());\n  };\n\n  // Check if we've already successfully checked the comparison category type\n  // before. If so, skip checking it again.\n  ComparisonCategoryInfo *Info = Context.CompCategories.lookupInfo(Kind);\n  if (Info && FullyCheckedComparisonCategories[static_cast<unsigned>(Kind)]) {\n    // The only thing we need to check is that the type has a reachable\n    // definition in the current context.\n    if (RequireCompleteType(Loc, TyForDiags(Info), diag::err_incomplete_type))\n      return QualType();\n\n    return Info->getType();\n  }\n\n  // If lookup failed\n  if (!Info) {\n    std::string NameForDiags = \"std::\";\n    NameForDiags += ComparisonCategories::getCategoryString(Kind);\n    Diag(Loc, diag::err_implied_comparison_category_type_not_found)\n        << NameForDiags << (int)Usage;\n    return QualType();\n  }\n\n  assert(Info->Kind == Kind);\n  assert(Info->Record);\n\n  // Update the Record decl in case we encountered a forward declaration on our\n  // first pass. FIXME: This is a bit of a hack.\n  if (Info->Record->hasDefinition())\n    Info->Record = Info->Record->getDefinition();\n\n  if (RequireCompleteType(Loc, TyForDiags(Info), diag::err_incomplete_type))\n    return QualType();\n\n  InvalidSTLDiagnoser UnsupportedSTLError{*this, Loc, TyForDiags(Info)};\n\n  if (!Info->Record->isTriviallyCopyable())\n    return UnsupportedSTLError(USS_NonTrivial);\n\n  for (const CXXBaseSpecifier &BaseSpec : Info->Record->bases()) {\n    CXXRecordDecl *Base = BaseSpec.getType()->getAsCXXRecordDecl();\n    // Tolerate empty base classes.\n    if (Base->isEmpty())\n      continue;\n    // Reject STL implementations which have at least one non-empty base.\n    return UnsupportedSTLError();\n  }\n\n  // Check that the STL has implemented the types using a single integer field.\n  // This expectation allows better codegen for builtin operators. We require:\n  //   (1) The class has exactly one field.\n  //   (2) The field is an integral or enumeration type.\n  auto FIt = Info->Record->field_begin(), FEnd = Info->Record->field_end();\n  if (std::distance(FIt, FEnd) != 1 ||\n      !FIt->getType()->isIntegralOrEnumerationType()) {\n    return UnsupportedSTLError();\n  }\n\n  // Build each of the require values and store them in Info.\n  for (ComparisonCategoryResult CCR :\n       ComparisonCategories::getPossibleResultsForType(Kind)) {\n    StringRef MemName = ComparisonCategories::getResultString(CCR);\n    ComparisonCategoryInfo::ValueInfo *ValInfo = Info->lookupValueInfo(CCR);\n\n    if (!ValInfo)\n      return UnsupportedSTLError(USS_MissingMember, MemName);\n\n    VarDecl *VD = ValInfo->VD;\n    assert(VD && \"should not be null!\");\n\n    // Attempt to diagnose reasons why the STL definition of this type\n    // might be foobar, including it failing to be a constant expression.\n    // TODO Handle more ways the lookup or result can be invalid.\n    if (!VD->isStaticDataMember() ||\n        !VD->isUsableInConstantExpressions(Context))\n      return UnsupportedSTLError(USS_InvalidMember, MemName, VD);\n\n    // Attempt to evaluate the var decl as a constant expression and extract\n    // the value of its first field as a ICE. If this fails, the STL\n    // implementation is not supported.\n    if (!ValInfo->hasValidIntValue())\n      return UnsupportedSTLError();\n\n    MarkVariableReferenced(Loc, VD);\n  }\n\n  // We've successfully built the required types and expressions. Update\n  // the cache and return the newly cached value.\n  FullyCheckedComparisonCategories[static_cast<unsigned>(Kind)] = true;\n  return Info->getType();\n}\n\n/// Retrieve the special \"std\" namespace, which may require us to\n/// implicitly define the namespace.\nNamespaceDecl *Sema::getOrCreateStdNamespace() {\n  if (!StdNamespace) {\n    // The \"std\" namespace has not yet been defined, so build one implicitly.\n    StdNamespace = NamespaceDecl::Create(Context,\n                                         Context.getTranslationUnitDecl(),\n                                         /*Inline=*/false,\n                                         SourceLocation(), SourceLocation(),\n                                         &PP.getIdentifierTable().get(\"std\"),\n                                         /*PrevDecl=*/nullptr);\n    getStdNamespace()->setImplicit(true);\n  }\n\n  return getStdNamespace();\n}\n\nbool Sema::isStdInitializerList(QualType Ty, QualType *Element) {\n  assert(getLangOpts().CPlusPlus &&\n         \"Looking for std::initializer_list outside of C++.\");\n\n  // We're looking for implicit instantiations of\n  // template <typename E> class std::initializer_list.\n\n  if (!StdNamespace) // If we haven't seen namespace std yet, this can't be it.\n    return false;\n\n  ClassTemplateDecl *Template = nullptr;\n  const TemplateArgument *Arguments = nullptr;\n\n  if (const RecordType *RT = Ty->getAs<RecordType>()) {\n\n    ClassTemplateSpecializationDecl *Specialization =\n        dyn_cast<ClassTemplateSpecializationDecl>(RT->getDecl());\n    if (!Specialization)\n      return false;\n\n    Template = Specialization->getSpecializedTemplate();\n    Arguments = Specialization->getTemplateArgs().data();\n  } else if (const TemplateSpecializationType *TST =\n                 Ty->getAs<TemplateSpecializationType>()) {\n    Template = dyn_cast_or_null<ClassTemplateDecl>(\n        TST->getTemplateName().getAsTemplateDecl());\n    Arguments = TST->getArgs();\n  }\n  if (!Template)\n    return false;\n\n  if (!StdInitializerList) {\n    // Haven't recognized std::initializer_list yet, maybe this is it.\n    CXXRecordDecl *TemplateClass = Template->getTemplatedDecl();\n    if (TemplateClass->getIdentifier() !=\n            &PP.getIdentifierTable().get(\"initializer_list\") ||\n        !getStdNamespace()->InEnclosingNamespaceSetOf(\n            TemplateClass->getDeclContext()))\n      return false;\n    // This is a template called std::initializer_list, but is it the right\n    // template?\n    TemplateParameterList *Params = Template->getTemplateParameters();\n    if (Params->getMinRequiredArguments() != 1)\n      return false;\n    if (!isa<TemplateTypeParmDecl>(Params->getParam(0)))\n      return false;\n\n    // It's the right template.\n    StdInitializerList = Template;\n  }\n\n  if (Template->getCanonicalDecl() != StdInitializerList->getCanonicalDecl())\n    return false;\n\n  // This is an instance of std::initializer_list. Find the argument type.\n  if (Element)\n    *Element = Arguments[0].getAsType();\n  return true;\n}\n\nstatic ClassTemplateDecl *LookupStdInitializerList(Sema &S, SourceLocation Loc){\n  NamespaceDecl *Std = S.getStdNamespace();\n  if (!Std) {\n    S.Diag(Loc, diag::err_implied_std_initializer_list_not_found);\n    return nullptr;\n  }\n\n  LookupResult Result(S, &S.PP.getIdentifierTable().get(\"initializer_list\"),\n                      Loc, Sema::LookupOrdinaryName);\n  if (!S.LookupQualifiedName(Result, Std)) {\n    S.Diag(Loc, diag::err_implied_std_initializer_list_not_found);\n    return nullptr;\n  }\n  ClassTemplateDecl *Template = Result.getAsSingle<ClassTemplateDecl>();\n  if (!Template) {\n    Result.suppressDiagnostics();\n    // We found something weird. Complain about the first thing we found.\n    NamedDecl *Found = *Result.begin();\n    S.Diag(Found->getLocation(), diag::err_malformed_std_initializer_list);\n    return nullptr;\n  }\n\n  // We found some template called std::initializer_list. Now verify that it's\n  // correct.\n  TemplateParameterList *Params = Template->getTemplateParameters();\n  if (Params->getMinRequiredArguments() != 1 ||\n      !isa<TemplateTypeParmDecl>(Params->getParam(0))) {\n    S.Diag(Template->getLocation(), diag::err_malformed_std_initializer_list);\n    return nullptr;\n  }\n\n  return Template;\n}\n\nQualType Sema::BuildStdInitializerList(QualType Element, SourceLocation Loc) {\n  if (!StdInitializerList) {\n    StdInitializerList = LookupStdInitializerList(*this, Loc);\n    if (!StdInitializerList)\n      return QualType();\n  }\n\n  TemplateArgumentListInfo Args(Loc, Loc);\n  Args.addArgument(TemplateArgumentLoc(TemplateArgument(Element),\n                                       Context.getTrivialTypeSourceInfo(Element,\n                                                                        Loc)));\n  return Context.getCanonicalType(\n      CheckTemplateIdType(TemplateName(StdInitializerList), Loc, Args));\n}\n\nbool Sema::isInitListConstructor(const FunctionDecl *Ctor) {\n  // C++ [dcl.init.list]p2:\n  //   A constructor is an initializer-list constructor if its first parameter\n  //   is of type std::initializer_list<E> or reference to possibly cv-qualified\n  //   std::initializer_list<E> for some type E, and either there are no other\n  //   parameters or else all other parameters have default arguments.\n  if (!Ctor->hasOneParamOrDefaultArgs())\n    return false;\n\n  QualType ArgType = Ctor->getParamDecl(0)->getType();\n  if (const ReferenceType *RT = ArgType->getAs<ReferenceType>())\n    ArgType = RT->getPointeeType().getUnqualifiedType();\n\n  return isStdInitializerList(ArgType, nullptr);\n}\n\n/// Determine whether a using statement is in a context where it will be\n/// apply in all contexts.\nstatic bool IsUsingDirectiveInToplevelContext(DeclContext *CurContext) {\n  switch (CurContext->getDeclKind()) {\n    case Decl::TranslationUnit:\n      return true;\n    case Decl::LinkageSpec:\n      return IsUsingDirectiveInToplevelContext(CurContext->getParent());\n    default:\n      return false;\n  }\n}\n\nnamespace {\n\n// Callback to only accept typo corrections that are namespaces.\nclass NamespaceValidatorCCC final : public CorrectionCandidateCallback {\npublic:\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    if (NamedDecl *ND = candidate.getCorrectionDecl())\n      return isa<NamespaceDecl>(ND) || isa<NamespaceAliasDecl>(ND);\n    return false;\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<NamespaceValidatorCCC>(*this);\n  }\n};\n\n}\n\nstatic bool TryNamespaceTypoCorrection(Sema &S, LookupResult &R, Scope *Sc,\n                                       CXXScopeSpec &SS,\n                                       SourceLocation IdentLoc,\n                                       IdentifierInfo *Ident) {\n  R.clear();\n  NamespaceValidatorCCC CCC{};\n  if (TypoCorrection Corrected =\n          S.CorrectTypo(R.getLookupNameInfo(), R.getLookupKind(), Sc, &SS, CCC,\n                        Sema::CTK_ErrorRecovery)) {\n    if (DeclContext *DC = S.computeDeclContext(SS, false)) {\n      std::string CorrectedStr(Corrected.getAsString(S.getLangOpts()));\n      bool DroppedSpecifier = Corrected.WillReplaceSpecifier() &&\n                              Ident->getName().equals(CorrectedStr);\n      S.diagnoseTypo(Corrected,\n                     S.PDiag(diag::err_using_directive_member_suggest)\n                       << Ident << DC << DroppedSpecifier << SS.getRange(),\n                     S.PDiag(diag::note_namespace_defined_here));\n    } else {\n      S.diagnoseTypo(Corrected,\n                     S.PDiag(diag::err_using_directive_suggest) << Ident,\n                     S.PDiag(diag::note_namespace_defined_here));\n    }\n    R.addDecl(Corrected.getFoundDecl());\n    return true;\n  }\n  return false;\n}\n\nDecl *Sema::ActOnUsingDirective(Scope *S, SourceLocation UsingLoc,\n                                SourceLocation NamespcLoc, CXXScopeSpec &SS,\n                                SourceLocation IdentLoc,\n                                IdentifierInfo *NamespcName,\n                                const ParsedAttributesView &AttrList) {\n  assert(!SS.isInvalid() && \"Invalid CXXScopeSpec.\");\n  assert(NamespcName && \"Invalid NamespcName.\");\n  assert(IdentLoc.isValid() && \"Invalid NamespceName location.\");\n\n  // This can only happen along a recovery path.\n  while (S->isTemplateParamScope())\n    S = S->getParent();\n  assert(S->getFlags() & Scope::DeclScope && \"Invalid Scope.\");\n\n  UsingDirectiveDecl *UDir = nullptr;\n  NestedNameSpecifier *Qualifier = nullptr;\n  if (SS.isSet())\n    Qualifier = SS.getScopeRep();\n\n  // Lookup namespace name.\n  LookupResult R(*this, NamespcName, IdentLoc, LookupNamespaceName);\n  LookupParsedName(R, S, &SS);\n  if (R.isAmbiguous())\n    return nullptr;\n\n  if (R.empty()) {\n    R.clear();\n    // Allow \"using namespace std;\" or \"using namespace ::std;\" even if\n    // \"std\" hasn't been defined yet, for GCC compatibility.\n    if ((!Qualifier || Qualifier->getKind() == NestedNameSpecifier::Global) &&\n        NamespcName->isStr(\"std\")) {\n      Diag(IdentLoc, diag::ext_using_undefined_std);\n      R.addDecl(getOrCreateStdNamespace());\n      R.resolveKind();\n    }\n    // Otherwise, attempt typo correction.\n    else TryNamespaceTypoCorrection(*this, R, S, SS, IdentLoc, NamespcName);\n  }\n\n  if (!R.empty()) {\n    NamedDecl *Named = R.getRepresentativeDecl();\n    NamespaceDecl *NS = R.getAsSingle<NamespaceDecl>();\n    assert(NS && \"expected namespace decl\");\n\n    // The use of a nested name specifier may trigger deprecation warnings.\n    DiagnoseUseOfDecl(Named, IdentLoc);\n\n    // C++ [namespace.udir]p1:\n    //   A using-directive specifies that the names in the nominated\n    //   namespace can be used in the scope in which the\n    //   using-directive appears after the using-directive. During\n    //   unqualified name lookup (3.4.1), the names appear as if they\n    //   were declared in the nearest enclosing namespace which\n    //   contains both the using-directive and the nominated\n    //   namespace. [Note: in this context, \"contains\" means \"contains\n    //   directly or indirectly\". ]\n\n    // Find enclosing context containing both using-directive and\n    // nominated namespace.\n    DeclContext *CommonAncestor = NS;\n    while (CommonAncestor && !CommonAncestor->Encloses(CurContext))\n      CommonAncestor = CommonAncestor->getParent();\n\n    UDir = UsingDirectiveDecl::Create(Context, CurContext, UsingLoc, NamespcLoc,\n                                      SS.getWithLocInContext(Context),\n                                      IdentLoc, Named, CommonAncestor);\n\n    if (IsUsingDirectiveInToplevelContext(CurContext) &&\n        !SourceMgr.isInMainFile(SourceMgr.getExpansionLoc(IdentLoc))) {\n      Diag(IdentLoc, diag::warn_using_directive_in_header);\n    }\n\n    PushUsingDirective(S, UDir);\n  } else {\n    Diag(IdentLoc, diag::err_expected_namespace_name) << SS.getRange();\n  }\n\n  if (UDir)\n    ProcessDeclAttributeList(S, UDir, AttrList);\n\n  return UDir;\n}\n\nvoid Sema::PushUsingDirective(Scope *S, UsingDirectiveDecl *UDir) {\n  // If the scope has an associated entity and the using directive is at\n  // namespace or translation unit scope, add the UsingDirectiveDecl into\n  // its lookup structure so qualified name lookup can find it.\n  DeclContext *Ctx = S->getEntity();\n  if (Ctx && !Ctx->isFunctionOrMethod())\n    Ctx->addDecl(UDir);\n  else\n    // Otherwise, it is at block scope. The using-directives will affect lookup\n    // only to the end of the scope.\n    S->PushUsingDirective(UDir);\n}\n\nDecl *Sema::ActOnUsingDeclaration(Scope *S, AccessSpecifier AS,\n                                  SourceLocation UsingLoc,\n                                  SourceLocation TypenameLoc, CXXScopeSpec &SS,\n                                  UnqualifiedId &Name,\n                                  SourceLocation EllipsisLoc,\n                                  const ParsedAttributesView &AttrList) {\n  assert(S->getFlags() & Scope::DeclScope && \"Invalid Scope.\");\n\n  if (SS.isEmpty()) {\n    Diag(Name.getBeginLoc(), diag::err_using_requires_qualname);\n    return nullptr;\n  }\n\n  switch (Name.getKind()) {\n  case UnqualifiedIdKind::IK_ImplicitSelfParam:\n  case UnqualifiedIdKind::IK_Identifier:\n  case UnqualifiedIdKind::IK_OperatorFunctionId:\n  case UnqualifiedIdKind::IK_LiteralOperatorId:\n  case UnqualifiedIdKind::IK_ConversionFunctionId:\n    break;\n\n  case UnqualifiedIdKind::IK_ConstructorName:\n  case UnqualifiedIdKind::IK_ConstructorTemplateId:\n    // C++11 inheriting constructors.\n    Diag(Name.getBeginLoc(),\n         getLangOpts().CPlusPlus11\n             ? diag::warn_cxx98_compat_using_decl_constructor\n             : diag::err_using_decl_constructor)\n        << SS.getRange();\n\n    if (getLangOpts().CPlusPlus11) break;\n\n    return nullptr;\n\n  case UnqualifiedIdKind::IK_DestructorName:\n    Diag(Name.getBeginLoc(), diag::err_using_decl_destructor) << SS.getRange();\n    return nullptr;\n\n  case UnqualifiedIdKind::IK_TemplateId:\n    Diag(Name.getBeginLoc(), diag::err_using_decl_template_id)\n        << SourceRange(Name.TemplateId->LAngleLoc, Name.TemplateId->RAngleLoc);\n    return nullptr;\n\n  case UnqualifiedIdKind::IK_DeductionGuideName:\n    llvm_unreachable(\"cannot parse qualified deduction guide name\");\n  }\n\n  DeclarationNameInfo TargetNameInfo = GetNameFromUnqualifiedId(Name);\n  DeclarationName TargetName = TargetNameInfo.getName();\n  if (!TargetName)\n    return nullptr;\n\n  // Warn about access declarations.\n  if (UsingLoc.isInvalid()) {\n    Diag(Name.getBeginLoc(), getLangOpts().CPlusPlus11\n                                 ? diag::err_access_decl\n                                 : diag::warn_access_decl_deprecated)\n        << FixItHint::CreateInsertion(SS.getRange().getBegin(), \"using \");\n  }\n\n  if (EllipsisLoc.isInvalid()) {\n    if (DiagnoseUnexpandedParameterPack(SS, UPPC_UsingDeclaration) ||\n        DiagnoseUnexpandedParameterPack(TargetNameInfo, UPPC_UsingDeclaration))\n      return nullptr;\n  } else {\n    if (!SS.getScopeRep()->containsUnexpandedParameterPack() &&\n        !TargetNameInfo.containsUnexpandedParameterPack()) {\n      Diag(EllipsisLoc, diag::err_pack_expansion_without_parameter_packs)\n        << SourceRange(SS.getBeginLoc(), TargetNameInfo.getEndLoc());\n      EllipsisLoc = SourceLocation();\n    }\n  }\n\n  NamedDecl *UD =\n      BuildUsingDeclaration(S, AS, UsingLoc, TypenameLoc.isValid(), TypenameLoc,\n                            SS, TargetNameInfo, EllipsisLoc, AttrList,\n                            /*IsInstantiation*/false);\n  if (UD)\n    PushOnScopeChains(UD, S, /*AddToContext*/ false);\n\n  return UD;\n}\n\n/// Determine whether a using declaration considers the given\n/// declarations as \"equivalent\", e.g., if they are redeclarations of\n/// the same entity or are both typedefs of the same type.\nstatic bool\nIsEquivalentForUsingDecl(ASTContext &Context, NamedDecl *D1, NamedDecl *D2) {\n  if (D1->getCanonicalDecl() == D2->getCanonicalDecl())\n    return true;\n\n  if (TypedefNameDecl *TD1 = dyn_cast<TypedefNameDecl>(D1))\n    if (TypedefNameDecl *TD2 = dyn_cast<TypedefNameDecl>(D2))\n      return Context.hasSameType(TD1->getUnderlyingType(),\n                                 TD2->getUnderlyingType());\n\n  return false;\n}\n\n\n/// Determines whether to create a using shadow decl for a particular\n/// decl, given the set of decls existing prior to this using lookup.\nbool Sema::CheckUsingShadowDecl(UsingDecl *Using, NamedDecl *Orig,\n                                const LookupResult &Previous,\n                                UsingShadowDecl *&PrevShadow) {\n  // Diagnose finding a decl which is not from a base class of the\n  // current class.  We do this now because there are cases where this\n  // function will silently decide not to build a shadow decl, which\n  // will pre-empt further diagnostics.\n  //\n  // We don't need to do this in C++11 because we do the check once on\n  // the qualifier.\n  //\n  // FIXME: diagnose the following if we care enough:\n  //   struct A { int foo; };\n  //   struct B : A { using A::foo; };\n  //   template <class T> struct C : A {};\n  //   template <class T> struct D : C<T> { using B::foo; } // <---\n  // This is invalid (during instantiation) in C++03 because B::foo\n  // resolves to the using decl in B, which is not a base class of D<T>.\n  // We can't diagnose it immediately because C<T> is an unknown\n  // specialization.  The UsingShadowDecl in D<T> then points directly\n  // to A::foo, which will look well-formed when we instantiate.\n  // The right solution is to not collapse the shadow-decl chain.\n  if (!getLangOpts().CPlusPlus11 && CurContext->isRecord()) {\n    DeclContext *OrigDC = Orig->getDeclContext();\n\n    // Handle enums and anonymous structs.\n    if (isa<EnumDecl>(OrigDC)) OrigDC = OrigDC->getParent();\n    CXXRecordDecl *OrigRec = cast<CXXRecordDecl>(OrigDC);\n    while (OrigRec->isAnonymousStructOrUnion())\n      OrigRec = cast<CXXRecordDecl>(OrigRec->getDeclContext());\n\n    if (cast<CXXRecordDecl>(CurContext)->isProvablyNotDerivedFrom(OrigRec)) {\n      if (OrigDC == CurContext) {\n        Diag(Using->getLocation(),\n             diag::err_using_decl_nested_name_specifier_is_current_class)\n          << Using->getQualifierLoc().getSourceRange();\n        Diag(Orig->getLocation(), diag::note_using_decl_target);\n        Using->setInvalidDecl();\n        return true;\n      }\n\n      Diag(Using->getQualifierLoc().getBeginLoc(),\n           diag::err_using_decl_nested_name_specifier_is_not_base_class)\n        << Using->getQualifier()\n        << cast<CXXRecordDecl>(CurContext)\n        << Using->getQualifierLoc().getSourceRange();\n      Diag(Orig->getLocation(), diag::note_using_decl_target);\n      Using->setInvalidDecl();\n      return true;\n    }\n  }\n\n  if (Previous.empty()) return false;\n\n  NamedDecl *Target = Orig;\n  if (isa<UsingShadowDecl>(Target))\n    Target = cast<UsingShadowDecl>(Target)->getTargetDecl();\n\n  // If the target happens to be one of the previous declarations, we\n  // don't have a conflict.\n  //\n  // FIXME: but we might be increasing its access, in which case we\n  // should redeclare it.\n  NamedDecl *NonTag = nullptr, *Tag = nullptr;\n  bool FoundEquivalentDecl = false;\n  for (LookupResult::iterator I = Previous.begin(), E = Previous.end();\n         I != E; ++I) {\n    NamedDecl *D = (*I)->getUnderlyingDecl();\n    // We can have UsingDecls in our Previous results because we use the same\n    // LookupResult for checking whether the UsingDecl itself is a valid\n    // redeclaration.\n    if (isa<UsingDecl>(D) || isa<UsingPackDecl>(D))\n      continue;\n\n    if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {\n      // C++ [class.mem]p19:\n      //   If T is the name of a class, then [every named member other than\n      //   a non-static data member] shall have a name different from T\n      if (RD->isInjectedClassName() && !isa<FieldDecl>(Target) &&\n          !isa<IndirectFieldDecl>(Target) &&\n          !isa<UnresolvedUsingValueDecl>(Target) &&\n          DiagnoseClassNameShadow(\n              CurContext,\n              DeclarationNameInfo(Using->getDeclName(), Using->getLocation())))\n        return true;\n    }\n\n    if (IsEquivalentForUsingDecl(Context, D, Target)) {\n      if (UsingShadowDecl *Shadow = dyn_cast<UsingShadowDecl>(*I))\n        PrevShadow = Shadow;\n      FoundEquivalentDecl = true;\n    } else if (isEquivalentInternalLinkageDeclaration(D, Target)) {\n      // We don't conflict with an existing using shadow decl of an equivalent\n      // declaration, but we're not a redeclaration of it.\n      FoundEquivalentDecl = true;\n    }\n\n    if (isVisible(D))\n      (isa<TagDecl>(D) ? Tag : NonTag) = D;\n  }\n\n  if (FoundEquivalentDecl)\n    return false;\n\n  if (FunctionDecl *FD = Target->getAsFunction()) {\n    NamedDecl *OldDecl = nullptr;\n    switch (CheckOverload(nullptr, FD, Previous, OldDecl,\n                          /*IsForUsingDecl*/ true)) {\n    case Ovl_Overload:\n      return false;\n\n    case Ovl_NonFunction:\n      Diag(Using->getLocation(), diag::err_using_decl_conflict);\n      break;\n\n    // We found a decl with the exact signature.\n    case Ovl_Match:\n      // If we're in a record, we want to hide the target, so we\n      // return true (without a diagnostic) to tell the caller not to\n      // build a shadow decl.\n      if (CurContext->isRecord())\n        return true;\n\n      // If we're not in a record, this is an error.\n      Diag(Using->getLocation(), diag::err_using_decl_conflict);\n      break;\n    }\n\n    Diag(Target->getLocation(), diag::note_using_decl_target);\n    Diag(OldDecl->getLocation(), diag::note_using_decl_conflict);\n    Using->setInvalidDecl();\n    return true;\n  }\n\n  // Target is not a function.\n\n  if (isa<TagDecl>(Target)) {\n    // No conflict between a tag and a non-tag.\n    if (!Tag) return false;\n\n    Diag(Using->getLocation(), diag::err_using_decl_conflict);\n    Diag(Target->getLocation(), diag::note_using_decl_target);\n    Diag(Tag->getLocation(), diag::note_using_decl_conflict);\n    Using->setInvalidDecl();\n    return true;\n  }\n\n  // No conflict between a tag and a non-tag.\n  if (!NonTag) return false;\n\n  Diag(Using->getLocation(), diag::err_using_decl_conflict);\n  Diag(Target->getLocation(), diag::note_using_decl_target);\n  Diag(NonTag->getLocation(), diag::note_using_decl_conflict);\n  Using->setInvalidDecl();\n  return true;\n}\n\n/// Determine whether a direct base class is a virtual base class.\nstatic bool isVirtualDirectBase(CXXRecordDecl *Derived, CXXRecordDecl *Base) {\n  if (!Derived->getNumVBases())\n    return false;\n  for (auto &B : Derived->bases())\n    if (B.getType()->getAsCXXRecordDecl() == Base)\n      return B.isVirtual();\n  llvm_unreachable(\"not a direct base class\");\n}\n\n/// Builds a shadow declaration corresponding to a 'using' declaration.\nUsingShadowDecl *Sema::BuildUsingShadowDecl(Scope *S,\n                                            UsingDecl *UD,\n                                            NamedDecl *Orig,\n                                            UsingShadowDecl *PrevDecl) {\n  // If we resolved to another shadow declaration, just coalesce them.\n  NamedDecl *Target = Orig;\n  if (isa<UsingShadowDecl>(Target)) {\n    Target = cast<UsingShadowDecl>(Target)->getTargetDecl();\n    assert(!isa<UsingShadowDecl>(Target) && \"nested shadow declaration\");\n  }\n\n  NamedDecl *NonTemplateTarget = Target;\n  if (auto *TargetTD = dyn_cast<TemplateDecl>(Target))\n    NonTemplateTarget = TargetTD->getTemplatedDecl();\n\n  UsingShadowDecl *Shadow;\n  if (NonTemplateTarget && isa<CXXConstructorDecl>(NonTemplateTarget)) {\n    bool IsVirtualBase =\n        isVirtualDirectBase(cast<CXXRecordDecl>(CurContext),\n                            UD->getQualifier()->getAsRecordDecl());\n    Shadow = ConstructorUsingShadowDecl::Create(\n        Context, CurContext, UD->getLocation(), UD, Orig, IsVirtualBase);\n  } else {\n    Shadow = UsingShadowDecl::Create(Context, CurContext, UD->getLocation(), UD,\n                                     Target);\n  }\n  UD->addShadowDecl(Shadow);\n\n  Shadow->setAccess(UD->getAccess());\n  if (Orig->isInvalidDecl() || UD->isInvalidDecl())\n    Shadow->setInvalidDecl();\n\n  Shadow->setPreviousDecl(PrevDecl);\n\n  if (S)\n    PushOnScopeChains(Shadow, S);\n  else\n    CurContext->addDecl(Shadow);\n\n\n  return Shadow;\n}\n\n/// Hides a using shadow declaration.  This is required by the current\n/// using-decl implementation when a resolvable using declaration in a\n/// class is followed by a declaration which would hide or override\n/// one or more of the using decl's targets; for example:\n///\n///   struct Base { void foo(int); };\n///   struct Derived : Base {\n///     using Base::foo;\n///     void foo(int);\n///   };\n///\n/// The governing language is C++03 [namespace.udecl]p12:\n///\n///   When a using-declaration brings names from a base class into a\n///   derived class scope, member functions in the derived class\n///   override and/or hide member functions with the same name and\n///   parameter types in a base class (rather than conflicting).\n///\n/// There are two ways to implement this:\n///   (1) optimistically create shadow decls when they're not hidden\n///       by existing declarations, or\n///   (2) don't create any shadow decls (or at least don't make them\n///       visible) until we've fully parsed/instantiated the class.\n/// The problem with (1) is that we might have to retroactively remove\n/// a shadow decl, which requires several O(n) operations because the\n/// decl structures are (very reasonably) not designed for removal.\n/// (2) avoids this but is very fiddly and phase-dependent.\nvoid Sema::HideUsingShadowDecl(Scope *S, UsingShadowDecl *Shadow) {\n  if (Shadow->getDeclName().getNameKind() ==\n        DeclarationName::CXXConversionFunctionName)\n    cast<CXXRecordDecl>(Shadow->getDeclContext())->removeConversion(Shadow);\n\n  // Remove it from the DeclContext...\n  Shadow->getDeclContext()->removeDecl(Shadow);\n\n  // ...and the scope, if applicable...\n  if (S) {\n    S->RemoveDecl(Shadow);\n    IdResolver.RemoveDecl(Shadow);\n  }\n\n  // ...and the using decl.\n  Shadow->getUsingDecl()->removeShadowDecl(Shadow);\n\n  // TODO: complain somehow if Shadow was used.  It shouldn't\n  // be possible for this to happen, because...?\n}\n\n/// Find the base specifier for a base class with the given type.\nstatic CXXBaseSpecifier *findDirectBaseWithType(CXXRecordDecl *Derived,\n                                                QualType DesiredBase,\n                                                bool &AnyDependentBases) {\n  // Check whether the named type is a direct base class.\n  CanQualType CanonicalDesiredBase = DesiredBase->getCanonicalTypeUnqualified()\n    .getUnqualifiedType();\n  for (auto &Base : Derived->bases()) {\n    CanQualType BaseType = Base.getType()->getCanonicalTypeUnqualified();\n    if (CanonicalDesiredBase == BaseType)\n      return &Base;\n    if (BaseType->isDependentType())\n      AnyDependentBases = true;\n  }\n  return nullptr;\n}\n\nnamespace {\nclass UsingValidatorCCC final : public CorrectionCandidateCallback {\npublic:\n  UsingValidatorCCC(bool HasTypenameKeyword, bool IsInstantiation,\n                    NestedNameSpecifier *NNS, CXXRecordDecl *RequireMemberOf)\n      : HasTypenameKeyword(HasTypenameKeyword),\n        IsInstantiation(IsInstantiation), OldNNS(NNS),\n        RequireMemberOf(RequireMemberOf) {}\n\n  bool ValidateCandidate(const TypoCorrection &Candidate) override {\n    NamedDecl *ND = Candidate.getCorrectionDecl();\n\n    // Keywords are not valid here.\n    if (!ND || isa<NamespaceDecl>(ND))\n      return false;\n\n    // Completely unqualified names are invalid for a 'using' declaration.\n    if (Candidate.WillReplaceSpecifier() && !Candidate.getCorrectionSpecifier())\n      return false;\n\n    // FIXME: Don't correct to a name that CheckUsingDeclRedeclaration would\n    // reject.\n\n    if (RequireMemberOf) {\n      auto *FoundRecord = dyn_cast<CXXRecordDecl>(ND);\n      if (FoundRecord && FoundRecord->isInjectedClassName()) {\n        // No-one ever wants a using-declaration to name an injected-class-name\n        // of a base class, unless they're declaring an inheriting constructor.\n        ASTContext &Ctx = ND->getASTContext();\n        if (!Ctx.getLangOpts().CPlusPlus11)\n          return false;\n        QualType FoundType = Ctx.getRecordType(FoundRecord);\n\n        // Check that the injected-class-name is named as a member of its own\n        // type; we don't want to suggest 'using Derived::Base;', since that\n        // means something else.\n        NestedNameSpecifier *Specifier =\n            Candidate.WillReplaceSpecifier()\n                ? Candidate.getCorrectionSpecifier()\n                : OldNNS;\n        if (!Specifier->getAsType() ||\n            !Ctx.hasSameType(QualType(Specifier->getAsType(), 0), FoundType))\n          return false;\n\n        // Check that this inheriting constructor declaration actually names a\n        // direct base class of the current class.\n        bool AnyDependentBases = false;\n        if (!findDirectBaseWithType(RequireMemberOf,\n                                    Ctx.getRecordType(FoundRecord),\n                                    AnyDependentBases) &&\n            !AnyDependentBases)\n          return false;\n      } else {\n        auto *RD = dyn_cast<CXXRecordDecl>(ND->getDeclContext());\n        if (!RD || RequireMemberOf->isProvablyNotDerivedFrom(RD))\n          return false;\n\n        // FIXME: Check that the base class member is accessible?\n      }\n    } else {\n      auto *FoundRecord = dyn_cast<CXXRecordDecl>(ND);\n      if (FoundRecord && FoundRecord->isInjectedClassName())\n        return false;\n    }\n\n    if (isa<TypeDecl>(ND))\n      return HasTypenameKeyword || !IsInstantiation;\n\n    return !HasTypenameKeyword;\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<UsingValidatorCCC>(*this);\n  }\n\nprivate:\n  bool HasTypenameKeyword;\n  bool IsInstantiation;\n  NestedNameSpecifier *OldNNS;\n  CXXRecordDecl *RequireMemberOf;\n};\n} // end anonymous namespace\n\n/// Builds a using declaration.\n///\n/// \\param IsInstantiation - Whether this call arises from an\n///   instantiation of an unresolved using declaration.  We treat\n///   the lookup differently for these declarations.\nNamedDecl *Sema::BuildUsingDeclaration(\n    Scope *S, AccessSpecifier AS, SourceLocation UsingLoc,\n    bool HasTypenameKeyword, SourceLocation TypenameLoc, CXXScopeSpec &SS,\n    DeclarationNameInfo NameInfo, SourceLocation EllipsisLoc,\n    const ParsedAttributesView &AttrList, bool IsInstantiation) {\n  assert(!SS.isInvalid() && \"Invalid CXXScopeSpec.\");\n  SourceLocation IdentLoc = NameInfo.getLoc();\n  assert(IdentLoc.isValid() && \"Invalid TargetName location.\");\n\n  // FIXME: We ignore attributes for now.\n\n  // For an inheriting constructor declaration, the name of the using\n  // declaration is the name of a constructor in this class, not in the\n  // base class.\n  DeclarationNameInfo UsingName = NameInfo;\n  if (UsingName.getName().getNameKind() == DeclarationName::CXXConstructorName)\n    if (auto *RD = dyn_cast<CXXRecordDecl>(CurContext))\n      UsingName.setName(Context.DeclarationNames.getCXXConstructorName(\n          Context.getCanonicalType(Context.getRecordType(RD))));\n\n  // Do the redeclaration lookup in the current scope.\n  LookupResult Previous(*this, UsingName, LookupUsingDeclName,\n                        ForVisibleRedeclaration);\n  Previous.setHideTags(false);\n  if (S) {\n    LookupName(Previous, S);\n\n    // It is really dumb that we have to do this.\n    LookupResult::Filter F = Previous.makeFilter();\n    while (F.hasNext()) {\n      NamedDecl *D = F.next();\n      if (!isDeclInScope(D, CurContext, S))\n        F.erase();\n      // If we found a local extern declaration that's not ordinarily visible,\n      // and this declaration is being added to a non-block scope, ignore it.\n      // We're only checking for scope conflicts here, not also for violations\n      // of the linkage rules.\n      else if (!CurContext->isFunctionOrMethod() && D->isLocalExternDecl() &&\n               !(D->getIdentifierNamespace() & Decl::IDNS_Ordinary))\n        F.erase();\n    }\n    F.done();\n  } else {\n    assert(IsInstantiation && \"no scope in non-instantiation\");\n    if (CurContext->isRecord())\n      LookupQualifiedName(Previous, CurContext);\n    else {\n      // No redeclaration check is needed here; in non-member contexts we\n      // diagnosed all possible conflicts with other using-declarations when\n      // building the template:\n      //\n      // For a dependent non-type using declaration, the only valid case is\n      // if we instantiate to a single enumerator. We check for conflicts\n      // between shadow declarations we introduce, and we check in the template\n      // definition for conflicts between a non-type using declaration and any\n      // other declaration, which together covers all cases.\n      //\n      // A dependent typename using declaration will never successfully\n      // instantiate, since it will always name a class member, so we reject\n      // that in the template definition.\n    }\n  }\n\n  // Check for invalid redeclarations.\n  if (CheckUsingDeclRedeclaration(UsingLoc, HasTypenameKeyword,\n                                  SS, IdentLoc, Previous))\n    return nullptr;\n\n  // Check for bad qualifiers.\n  if (CheckUsingDeclQualifier(UsingLoc, HasTypenameKeyword, SS, NameInfo,\n                              IdentLoc))\n    return nullptr;\n\n  DeclContext *LookupContext = computeDeclContext(SS);\n  NamedDecl *D;\n  NestedNameSpecifierLoc QualifierLoc = SS.getWithLocInContext(Context);\n  if (!LookupContext || EllipsisLoc.isValid()) {\n    if (HasTypenameKeyword) {\n      // FIXME: not all declaration name kinds are legal here\n      D = UnresolvedUsingTypenameDecl::Create(Context, CurContext,\n                                              UsingLoc, TypenameLoc,\n                                              QualifierLoc,\n                                              IdentLoc, NameInfo.getName(),\n                                              EllipsisLoc);\n    } else {\n      D = UnresolvedUsingValueDecl::Create(Context, CurContext, UsingLoc,\n                                           QualifierLoc, NameInfo, EllipsisLoc);\n    }\n    D->setAccess(AS);\n    CurContext->addDecl(D);\n    return D;\n  }\n\n  auto Build = [&](bool Invalid) {\n    UsingDecl *UD =\n        UsingDecl::Create(Context, CurContext, UsingLoc, QualifierLoc,\n                          UsingName, HasTypenameKeyword);\n    UD->setAccess(AS);\n    CurContext->addDecl(UD);\n    UD->setInvalidDecl(Invalid);\n    return UD;\n  };\n  auto BuildInvalid = [&]{ return Build(true); };\n  auto BuildValid = [&]{ return Build(false); };\n\n  if (RequireCompleteDeclContext(SS, LookupContext))\n    return BuildInvalid();\n\n  // Look up the target name.\n  LookupResult R(*this, NameInfo, LookupOrdinaryName);\n\n  // Unlike most lookups, we don't always want to hide tag\n  // declarations: tag names are visible through the using declaration\n  // even if hidden by ordinary names, *except* in a dependent context\n  // where it's important for the sanity of two-phase lookup.\n  if (!IsInstantiation)\n    R.setHideTags(false);\n\n  // For the purposes of this lookup, we have a base object type\n  // equal to that of the current context.\n  if (CurContext->isRecord()) {\n    R.setBaseObjectType(\n                   Context.getTypeDeclType(cast<CXXRecordDecl>(CurContext)));\n  }\n\n  LookupQualifiedName(R, LookupContext);\n\n  // Try to correct typos if possible. If constructor name lookup finds no\n  // results, that means the named class has no explicit constructors, and we\n  // suppressed declaring implicit ones (probably because it's dependent or\n  // invalid).\n  if (R.empty() &&\n      NameInfo.getName().getNameKind() != DeclarationName::CXXConstructorName) {\n    // HACK: Work around a bug in libstdc++'s detection of ::gets. Sometimes\n    // it will believe that glibc provides a ::gets in cases where it does not,\n    // and will try to pull it into namespace std with a using-declaration.\n    // Just ignore the using-declaration in that case.\n    auto *II = NameInfo.getName().getAsIdentifierInfo();\n    if (getLangOpts().CPlusPlus14 && II && II->isStr(\"gets\") &&\n        CurContext->isStdNamespace() &&\n        isa<TranslationUnitDecl>(LookupContext) &&\n        getSourceManager().isInSystemHeader(UsingLoc))\n      return nullptr;\n    UsingValidatorCCC CCC(HasTypenameKeyword, IsInstantiation, SS.getScopeRep(),\n                          dyn_cast<CXXRecordDecl>(CurContext));\n    if (TypoCorrection Corrected =\n            CorrectTypo(R.getLookupNameInfo(), R.getLookupKind(), S, &SS, CCC,\n                        CTK_ErrorRecovery)) {\n      // We reject candidates where DroppedSpecifier == true, hence the\n      // literal '0' below.\n      diagnoseTypo(Corrected, PDiag(diag::err_no_member_suggest)\n                                << NameInfo.getName() << LookupContext << 0\n                                << SS.getRange());\n\n      // If we picked a correction with no attached Decl we can't do anything\n      // useful with it, bail out.\n      NamedDecl *ND = Corrected.getCorrectionDecl();\n      if (!ND)\n        return BuildInvalid();\n\n      // If we corrected to an inheriting constructor, handle it as one.\n      auto *RD = dyn_cast<CXXRecordDecl>(ND);\n      if (RD && RD->isInjectedClassName()) {\n        // The parent of the injected class name is the class itself.\n        RD = cast<CXXRecordDecl>(RD->getParent());\n\n        // Fix up the information we'll use to build the using declaration.\n        if (Corrected.WillReplaceSpecifier()) {\n          NestedNameSpecifierLocBuilder Builder;\n          Builder.MakeTrivial(Context, Corrected.getCorrectionSpecifier(),\n                              QualifierLoc.getSourceRange());\n          QualifierLoc = Builder.getWithLocInContext(Context);\n        }\n\n        // In this case, the name we introduce is the name of a derived class\n        // constructor.\n        auto *CurClass = cast<CXXRecordDecl>(CurContext);\n        UsingName.setName(Context.DeclarationNames.getCXXConstructorName(\n            Context.getCanonicalType(Context.getRecordType(CurClass))));\n        UsingName.setNamedTypeInfo(nullptr);\n        for (auto *Ctor : LookupConstructors(RD))\n          R.addDecl(Ctor);\n        R.resolveKind();\n      } else {\n        // FIXME: Pick up all the declarations if we found an overloaded\n        // function.\n        UsingName.setName(ND->getDeclName());\n        R.addDecl(ND);\n      }\n    } else {\n      Diag(IdentLoc, diag::err_no_member)\n        << NameInfo.getName() << LookupContext << SS.getRange();\n      return BuildInvalid();\n    }\n  }\n\n  if (R.isAmbiguous())\n    return BuildInvalid();\n\n  if (HasTypenameKeyword) {\n    // If we asked for a typename and got a non-type decl, error out.\n    if (!R.getAsSingle<TypeDecl>()) {\n      Diag(IdentLoc, diag::err_using_typename_non_type);\n      for (LookupResult::iterator I = R.begin(), E = R.end(); I != E; ++I)\n        Diag((*I)->getUnderlyingDecl()->getLocation(),\n             diag::note_using_decl_target);\n      return BuildInvalid();\n    }\n  } else {\n    // If we asked for a non-typename and we got a type, error out,\n    // but only if this is an instantiation of an unresolved using\n    // decl.  Otherwise just silently find the type name.\n    if (IsInstantiation && R.getAsSingle<TypeDecl>()) {\n      Diag(IdentLoc, diag::err_using_dependent_value_is_type);\n      Diag(R.getFoundDecl()->getLocation(), diag::note_using_decl_target);\n      return BuildInvalid();\n    }\n  }\n\n  // C++14 [namespace.udecl]p6:\n  // A using-declaration shall not name a namespace.\n  if (R.getAsSingle<NamespaceDecl>()) {\n    Diag(IdentLoc, diag::err_using_decl_can_not_refer_to_namespace)\n      << SS.getRange();\n    return BuildInvalid();\n  }\n\n  // C++14 [namespace.udecl]p7:\n  // A using-declaration shall not name a scoped enumerator.\n  if (auto *ED = R.getAsSingle<EnumConstantDecl>()) {\n    if (cast<EnumDecl>(ED->getDeclContext())->isScoped()) {\n      Diag(IdentLoc, diag::err_using_decl_can_not_refer_to_scoped_enum)\n        << SS.getRange();\n      return BuildInvalid();\n    }\n  }\n\n  UsingDecl *UD = BuildValid();\n\n  // Some additional rules apply to inheriting constructors.\n  if (UsingName.getName().getNameKind() ==\n        DeclarationName::CXXConstructorName) {\n    // Suppress access diagnostics; the access check is instead performed at the\n    // point of use for an inheriting constructor.\n    R.suppressDiagnostics();\n    if (CheckInheritingConstructorUsingDecl(UD))\n      return UD;\n  }\n\n  for (LookupResult::iterator I = R.begin(), E = R.end(); I != E; ++I) {\n    UsingShadowDecl *PrevDecl = nullptr;\n    if (!CheckUsingShadowDecl(UD, *I, Previous, PrevDecl))\n      BuildUsingShadowDecl(S, UD, *I, PrevDecl);\n  }\n\n  return UD;\n}\n\nNamedDecl *Sema::BuildUsingPackDecl(NamedDecl *InstantiatedFrom,\n                                    ArrayRef<NamedDecl *> Expansions) {\n  assert(isa<UnresolvedUsingValueDecl>(InstantiatedFrom) ||\n         isa<UnresolvedUsingTypenameDecl>(InstantiatedFrom) ||\n         isa<UsingPackDecl>(InstantiatedFrom));\n\n  auto *UPD =\n      UsingPackDecl::Create(Context, CurContext, InstantiatedFrom, Expansions);\n  UPD->setAccess(InstantiatedFrom->getAccess());\n  CurContext->addDecl(UPD);\n  return UPD;\n}\n\n/// Additional checks for a using declaration referring to a constructor name.\nbool Sema::CheckInheritingConstructorUsingDecl(UsingDecl *UD) {\n  assert(!UD->hasTypename() && \"expecting a constructor name\");\n\n  const Type *SourceType = UD->getQualifier()->getAsType();\n  assert(SourceType &&\n         \"Using decl naming constructor doesn't have type in scope spec.\");\n  CXXRecordDecl *TargetClass = cast<CXXRecordDecl>(CurContext);\n\n  // Check whether the named type is a direct base class.\n  bool AnyDependentBases = false;\n  auto *Base = findDirectBaseWithType(TargetClass, QualType(SourceType, 0),\n                                      AnyDependentBases);\n  if (!Base && !AnyDependentBases) {\n    Diag(UD->getUsingLoc(),\n         diag::err_using_decl_constructor_not_in_direct_base)\n      << UD->getNameInfo().getSourceRange()\n      << QualType(SourceType, 0) << TargetClass;\n    UD->setInvalidDecl();\n    return true;\n  }\n\n  if (Base)\n    Base->setInheritConstructors();\n\n  return false;\n}\n\n/// Checks that the given using declaration is not an invalid\n/// redeclaration.  Note that this is checking only for the using decl\n/// itself, not for any ill-formedness among the UsingShadowDecls.\nbool Sema::CheckUsingDeclRedeclaration(SourceLocation UsingLoc,\n                                       bool HasTypenameKeyword,\n                                       const CXXScopeSpec &SS,\n                                       SourceLocation NameLoc,\n                                       const LookupResult &Prev) {\n  NestedNameSpecifier *Qual = SS.getScopeRep();\n\n  // C++03 [namespace.udecl]p8:\n  // C++0x [namespace.udecl]p10:\n  //   A using-declaration is a declaration and can therefore be used\n  //   repeatedly where (and only where) multiple declarations are\n  //   allowed.\n  //\n  // That's in non-member contexts.\n  if (!CurContext->getRedeclContext()->isRecord()) {\n    // A dependent qualifier outside a class can only ever resolve to an\n    // enumeration type. Therefore it conflicts with any other non-type\n    // declaration in the same scope.\n    // FIXME: How should we check for dependent type-type conflicts at block\n    // scope?\n    if (Qual->isDependent() && !HasTypenameKeyword) {\n      for (auto *D : Prev) {\n        if (!isa<TypeDecl>(D) && !isa<UsingDecl>(D) && !isa<UsingPackDecl>(D)) {\n          bool OldCouldBeEnumerator =\n              isa<UnresolvedUsingValueDecl>(D) || isa<EnumConstantDecl>(D);\n          Diag(NameLoc,\n               OldCouldBeEnumerator ? diag::err_redefinition\n                                    : diag::err_redefinition_different_kind)\n              << Prev.getLookupName();\n          Diag(D->getLocation(), diag::note_previous_definition);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  for (LookupResult::iterator I = Prev.begin(), E = Prev.end(); I != E; ++I) {\n    NamedDecl *D = *I;\n\n    bool DTypename;\n    NestedNameSpecifier *DQual;\n    if (UsingDecl *UD = dyn_cast<UsingDecl>(D)) {\n      DTypename = UD->hasTypename();\n      DQual = UD->getQualifier();\n    } else if (UnresolvedUsingValueDecl *UD\n                 = dyn_cast<UnresolvedUsingValueDecl>(D)) {\n      DTypename = false;\n      DQual = UD->getQualifier();\n    } else if (UnresolvedUsingTypenameDecl *UD\n                 = dyn_cast<UnresolvedUsingTypenameDecl>(D)) {\n      DTypename = true;\n      DQual = UD->getQualifier();\n    } else continue;\n\n    // using decls differ if one says 'typename' and the other doesn't.\n    // FIXME: non-dependent using decls?\n    if (HasTypenameKeyword != DTypename) continue;\n\n    // using decls differ if they name different scopes (but note that\n    // template instantiation can cause this check to trigger when it\n    // didn't before instantiation).\n    if (Context.getCanonicalNestedNameSpecifier(Qual) !=\n        Context.getCanonicalNestedNameSpecifier(DQual))\n      continue;\n\n    Diag(NameLoc, diag::err_using_decl_redeclaration) << SS.getRange();\n    Diag(D->getLocation(), diag::note_using_decl) << 1;\n    return true;\n  }\n\n  return false;\n}\n\n\n/// Checks that the given nested-name qualifier used in a using decl\n/// in the current context is appropriately related to the current\n/// scope.  If an error is found, diagnoses it and returns true.\nbool Sema::CheckUsingDeclQualifier(SourceLocation UsingLoc,\n                                   bool HasTypename,\n                                   const CXXScopeSpec &SS,\n                                   const DeclarationNameInfo &NameInfo,\n                                   SourceLocation NameLoc) {\n  DeclContext *NamedContext = computeDeclContext(SS);\n\n  if (!CurContext->isRecord()) {\n    // C++03 [namespace.udecl]p3:\n    // C++0x [namespace.udecl]p8:\n    //   A using-declaration for a class member shall be a member-declaration.\n\n    // If we weren't able to compute a valid scope, it might validly be a\n    // dependent class scope or a dependent enumeration unscoped scope. If\n    // we have a 'typename' keyword, the scope must resolve to a class type.\n    if ((HasTypename && !NamedContext) ||\n        (NamedContext && NamedContext->getRedeclContext()->isRecord())) {\n      auto *RD = NamedContext\n                     ? cast<CXXRecordDecl>(NamedContext->getRedeclContext())\n                     : nullptr;\n      if (RD && RequireCompleteDeclContext(const_cast<CXXScopeSpec&>(SS), RD))\n        RD = nullptr;\n\n      Diag(NameLoc, diag::err_using_decl_can_not_refer_to_class_member)\n        << SS.getRange();\n\n      // If we have a complete, non-dependent source type, try to suggest a\n      // way to get the same effect.\n      if (!RD)\n        return true;\n\n      // Find what this using-declaration was referring to.\n      LookupResult R(*this, NameInfo, LookupOrdinaryName);\n      R.setHideTags(false);\n      R.suppressDiagnostics();\n      LookupQualifiedName(R, RD);\n\n      if (R.getAsSingle<TypeDecl>()) {\n        if (getLangOpts().CPlusPlus11) {\n          // Convert 'using X::Y;' to 'using Y = X::Y;'.\n          Diag(SS.getBeginLoc(), diag::note_using_decl_class_member_workaround)\n            << 0 // alias declaration\n            << FixItHint::CreateInsertion(SS.getBeginLoc(),\n                                          NameInfo.getName().getAsString() +\n                                              \" = \");\n        } else {\n          // Convert 'using X::Y;' to 'typedef X::Y Y;'.\n          SourceLocation InsertLoc = getLocForEndOfToken(NameInfo.getEndLoc());\n          Diag(InsertLoc, diag::note_using_decl_class_member_workaround)\n            << 1 // typedef declaration\n            << FixItHint::CreateReplacement(UsingLoc, \"typedef\")\n            << FixItHint::CreateInsertion(\n                   InsertLoc, \" \" + NameInfo.getName().getAsString());\n        }\n      } else if (R.getAsSingle<VarDecl>()) {\n        // Don't provide a fixit outside C++11 mode; we don't want to suggest\n        // repeating the type of the static data member here.\n        FixItHint FixIt;\n        if (getLangOpts().CPlusPlus11) {\n          // Convert 'using X::Y;' to 'auto &Y = X::Y;'.\n          FixIt = FixItHint::CreateReplacement(\n              UsingLoc, \"auto &\" + NameInfo.getName().getAsString() + \" = \");\n        }\n\n        Diag(UsingLoc, diag::note_using_decl_class_member_workaround)\n          << 2 // reference declaration\n          << FixIt;\n      } else if (R.getAsSingle<EnumConstantDecl>()) {\n        // Don't provide a fixit outside C++11 mode; we don't want to suggest\n        // repeating the type of the enumeration here, and we can't do so if\n        // the type is anonymous.\n        FixItHint FixIt;\n        if (getLangOpts().CPlusPlus11) {\n          // Convert 'using X::Y;' to 'auto &Y = X::Y;'.\n          FixIt = FixItHint::CreateReplacement(\n              UsingLoc,\n              \"constexpr auto \" + NameInfo.getName().getAsString() + \" = \");\n        }\n\n        Diag(UsingLoc, diag::note_using_decl_class_member_workaround)\n          << (getLangOpts().CPlusPlus11 ? 4 : 3) // const[expr] variable\n          << FixIt;\n      }\n      return true;\n    }\n\n    // Otherwise, this might be valid.\n    return false;\n  }\n\n  // The current scope is a record.\n\n  // If the named context is dependent, we can't decide much.\n  if (!NamedContext) {\n    // FIXME: in C++0x, we can diagnose if we can prove that the\n    // nested-name-specifier does not refer to a base class, which is\n    // still possible in some cases.\n\n    // Otherwise we have to conservatively report that things might be\n    // okay.\n    return false;\n  }\n\n  if (!NamedContext->isRecord()) {\n    // Ideally this would point at the last name in the specifier,\n    // but we don't have that level of source info.\n    Diag(SS.getRange().getBegin(),\n         diag::err_using_decl_nested_name_specifier_is_not_class)\n      << SS.getScopeRep() << SS.getRange();\n    return true;\n  }\n\n  if (!NamedContext->isDependentContext() &&\n      RequireCompleteDeclContext(const_cast<CXXScopeSpec&>(SS), NamedContext))\n    return true;\n\n  if (getLangOpts().CPlusPlus11) {\n    // C++11 [namespace.udecl]p3:\n    //   In a using-declaration used as a member-declaration, the\n    //   nested-name-specifier shall name a base class of the class\n    //   being defined.\n\n    if (cast<CXXRecordDecl>(CurContext)->isProvablyNotDerivedFrom(\n                                 cast<CXXRecordDecl>(NamedContext))) {\n      if (CurContext == NamedContext) {\n        Diag(NameLoc,\n             diag::err_using_decl_nested_name_specifier_is_current_class)\n          << SS.getRange();\n        return true;\n      }\n\n      if (!cast<CXXRecordDecl>(NamedContext)->isInvalidDecl()) {\n        Diag(SS.getRange().getBegin(),\n             diag::err_using_decl_nested_name_specifier_is_not_base_class)\n          << SS.getScopeRep()\n          << cast<CXXRecordDecl>(CurContext)\n          << SS.getRange();\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  // C++03 [namespace.udecl]p4:\n  //   A using-declaration used as a member-declaration shall refer\n  //   to a member of a base class of the class being defined [etc.].\n\n  // Salient point: SS doesn't have to name a base class as long as\n  // lookup only finds members from base classes.  Therefore we can\n  // diagnose here only if we can prove that that can't happen,\n  // i.e. if the class hierarchies provably don't intersect.\n\n  // TODO: it would be nice if \"definitely valid\" results were cached\n  // in the UsingDecl and UsingShadowDecl so that these checks didn't\n  // need to be repeated.\n\n  llvm::SmallPtrSet<const CXXRecordDecl *, 4> Bases;\n  auto Collect = [&Bases](const CXXRecordDecl *Base) {\n    Bases.insert(Base);\n    return true;\n  };\n\n  // Collect all bases. Return false if we find a dependent base.\n  if (!cast<CXXRecordDecl>(CurContext)->forallBases(Collect))\n    return false;\n\n  // Returns true if the base is dependent or is one of the accumulated base\n  // classes.\n  auto IsNotBase = [&Bases](const CXXRecordDecl *Base) {\n    return !Bases.count(Base);\n  };\n\n  // Return false if the class has a dependent base or if it or one\n  // of its bases is present in the base set of the current context.\n  if (Bases.count(cast<CXXRecordDecl>(NamedContext)) ||\n      !cast<CXXRecordDecl>(NamedContext)->forallBases(IsNotBase))\n    return false;\n\n  Diag(SS.getRange().getBegin(),\n       diag::err_using_decl_nested_name_specifier_is_not_base_class)\n    << SS.getScopeRep()\n    << cast<CXXRecordDecl>(CurContext)\n    << SS.getRange();\n\n  return true;\n}\n\nDecl *Sema::ActOnAliasDeclaration(Scope *S, AccessSpecifier AS,\n                                  MultiTemplateParamsArg TemplateParamLists,\n                                  SourceLocation UsingLoc, UnqualifiedId &Name,\n                                  const ParsedAttributesView &AttrList,\n                                  TypeResult Type, Decl *DeclFromDeclSpec) {\n  // Skip up to the relevant declaration scope.\n  while (S->isTemplateParamScope())\n    S = S->getParent();\n  assert((S->getFlags() & Scope::DeclScope) &&\n         \"got alias-declaration outside of declaration scope\");\n\n  if (Type.isInvalid())\n    return nullptr;\n\n  bool Invalid = false;\n  DeclarationNameInfo NameInfo = GetNameFromUnqualifiedId(Name);\n  TypeSourceInfo *TInfo = nullptr;\n  GetTypeFromParser(Type.get(), &TInfo);\n\n  if (DiagnoseClassNameShadow(CurContext, NameInfo))\n    return nullptr;\n\n  if (DiagnoseUnexpandedParameterPack(Name.StartLocation, TInfo,\n                                      UPPC_DeclarationType)) {\n    Invalid = true;\n    TInfo = Context.getTrivialTypeSourceInfo(Context.IntTy,\n                                             TInfo->getTypeLoc().getBeginLoc());\n  }\n\n  LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                        TemplateParamLists.size()\n                            ? forRedeclarationInCurContext()\n                            : ForVisibleRedeclaration);\n  LookupName(Previous, S);\n\n  // Warn about shadowing the name of a template parameter.\n  if (Previous.isSingleResult() &&\n      Previous.getFoundDecl()->isTemplateParameter()) {\n    DiagnoseTemplateParameterShadow(Name.StartLocation,Previous.getFoundDecl());\n    Previous.clear();\n  }\n\n  assert(Name.Kind == UnqualifiedIdKind::IK_Identifier &&\n         \"name in alias declaration must be an identifier\");\n  TypeAliasDecl *NewTD = TypeAliasDecl::Create(Context, CurContext, UsingLoc,\n                                               Name.StartLocation,\n                                               Name.Identifier, TInfo);\n\n  NewTD->setAccess(AS);\n\n  if (Invalid)\n    NewTD->setInvalidDecl();\n\n  ProcessDeclAttributeList(S, NewTD, AttrList);\n  AddPragmaAttributes(S, NewTD);\n\n  CheckTypedefForVariablyModifiedType(S, NewTD);\n  Invalid |= NewTD->isInvalidDecl();\n\n  bool Redeclaration = false;\n\n  NamedDecl *NewND;\n  if (TemplateParamLists.size()) {\n    TypeAliasTemplateDecl *OldDecl = nullptr;\n    TemplateParameterList *OldTemplateParams = nullptr;\n\n    if (TemplateParamLists.size() != 1) {\n      Diag(UsingLoc, diag::err_alias_template_extra_headers)\n        << SourceRange(TemplateParamLists[1]->getTemplateLoc(),\n         TemplateParamLists[TemplateParamLists.size()-1]->getRAngleLoc());\n    }\n    TemplateParameterList *TemplateParams = TemplateParamLists[0];\n\n    // Check that we can declare a template here.\n    if (CheckTemplateDeclScope(S, TemplateParams))\n      return nullptr;\n\n    // Only consider previous declarations in the same scope.\n    FilterLookupForScope(Previous, CurContext, S, /*ConsiderLinkage*/false,\n                         /*ExplicitInstantiationOrSpecialization*/false);\n    if (!Previous.empty()) {\n      Redeclaration = true;\n\n      OldDecl = Previous.getAsSingle<TypeAliasTemplateDecl>();\n      if (!OldDecl && !Invalid) {\n        Diag(UsingLoc, diag::err_redefinition_different_kind)\n          << Name.Identifier;\n\n        NamedDecl *OldD = Previous.getRepresentativeDecl();\n        if (OldD->getLocation().isValid())\n          Diag(OldD->getLocation(), diag::note_previous_definition);\n\n        Invalid = true;\n      }\n\n      if (!Invalid && OldDecl && !OldDecl->isInvalidDecl()) {\n        if (TemplateParameterListsAreEqual(TemplateParams,\n                                           OldDecl->getTemplateParameters(),\n                                           /*Complain=*/true,\n                                           TPL_TemplateMatch))\n          OldTemplateParams =\n              OldDecl->getMostRecentDecl()->getTemplateParameters();\n        else\n          Invalid = true;\n\n        TypeAliasDecl *OldTD = OldDecl->getTemplatedDecl();\n        if (!Invalid &&\n            !Context.hasSameType(OldTD->getUnderlyingType(),\n                                 NewTD->getUnderlyingType())) {\n          // FIXME: The C++0x standard does not clearly say this is ill-formed,\n          // but we can't reasonably accept it.\n          Diag(NewTD->getLocation(), diag::err_redefinition_different_typedef)\n            << 2 << NewTD->getUnderlyingType() << OldTD->getUnderlyingType();\n          if (OldTD->getLocation().isValid())\n            Diag(OldTD->getLocation(), diag::note_previous_definition);\n          Invalid = true;\n        }\n      }\n    }\n\n    // Merge any previous default template arguments into our parameters,\n    // and check the parameter list.\n    if (CheckTemplateParameterList(TemplateParams, OldTemplateParams,\n                                   TPC_TypeAliasTemplate))\n      return nullptr;\n\n    TypeAliasTemplateDecl *NewDecl =\n      TypeAliasTemplateDecl::Create(Context, CurContext, UsingLoc,\n                                    Name.Identifier, TemplateParams,\n                                    NewTD);\n    NewTD->setDescribedAliasTemplate(NewDecl);\n\n    NewDecl->setAccess(AS);\n\n    if (Invalid)\n      NewDecl->setInvalidDecl();\n    else if (OldDecl) {\n      NewDecl->setPreviousDecl(OldDecl);\n      CheckRedeclarationModuleOwnership(NewDecl, OldDecl);\n    }\n\n    NewND = NewDecl;\n  } else {\n    if (auto *TD = dyn_cast_or_null<TagDecl>(DeclFromDeclSpec)) {\n      setTagNameForLinkagePurposes(TD, NewTD);\n      handleTagNumbering(TD, S);\n    }\n    ActOnTypedefNameDecl(S, CurContext, NewTD, Previous, Redeclaration);\n    NewND = NewTD;\n  }\n\n  PushOnScopeChains(NewND, S);\n  ActOnDocumentableDecl(NewND);\n  return NewND;\n}\n\nDecl *Sema::ActOnNamespaceAliasDef(Scope *S, SourceLocation NamespaceLoc,\n                                   SourceLocation AliasLoc,\n                                   IdentifierInfo *Alias, CXXScopeSpec &SS,\n                                   SourceLocation IdentLoc,\n                                   IdentifierInfo *Ident) {\n\n  // Lookup the namespace name.\n  LookupResult R(*this, Ident, IdentLoc, LookupNamespaceName);\n  LookupParsedName(R, S, &SS);\n\n  if (R.isAmbiguous())\n    return nullptr;\n\n  if (R.empty()) {\n    if (!TryNamespaceTypoCorrection(*this, R, S, SS, IdentLoc, Ident)) {\n      Diag(IdentLoc, diag::err_expected_namespace_name) << SS.getRange();\n      return nullptr;\n    }\n  }\n  assert(!R.isAmbiguous() && !R.empty());\n  NamedDecl *ND = R.getRepresentativeDecl();\n\n  // Check if we have a previous declaration with the same name.\n  LookupResult PrevR(*this, Alias, AliasLoc, LookupOrdinaryName,\n                     ForVisibleRedeclaration);\n  LookupName(PrevR, S);\n\n  // Check we're not shadowing a template parameter.\n  if (PrevR.isSingleResult() && PrevR.getFoundDecl()->isTemplateParameter()) {\n    DiagnoseTemplateParameterShadow(AliasLoc, PrevR.getFoundDecl());\n    PrevR.clear();\n  }\n\n  // Filter out any other lookup result from an enclosing scope.\n  FilterLookupForScope(PrevR, CurContext, S, /*ConsiderLinkage*/false,\n                       /*AllowInlineNamespace*/false);\n\n  // Find the previous declaration and check that we can redeclare it.\n  NamespaceAliasDecl *Prev = nullptr;\n  if (PrevR.isSingleResult()) {\n    NamedDecl *PrevDecl = PrevR.getRepresentativeDecl();\n    if (NamespaceAliasDecl *AD = dyn_cast<NamespaceAliasDecl>(PrevDecl)) {\n      // We already have an alias with the same name that points to the same\n      // namespace; check that it matches.\n      if (AD->getNamespace()->Equals(getNamespaceDecl(ND))) {\n        Prev = AD;\n      } else if (isVisible(PrevDecl)) {\n        Diag(AliasLoc, diag::err_redefinition_different_namespace_alias)\n          << Alias;\n        Diag(AD->getLocation(), diag::note_previous_namespace_alias)\n          << AD->getNamespace();\n        return nullptr;\n      }\n    } else if (isVisible(PrevDecl)) {\n      unsigned DiagID = isa<NamespaceDecl>(PrevDecl->getUnderlyingDecl())\n                            ? diag::err_redefinition\n                            : diag::err_redefinition_different_kind;\n      Diag(AliasLoc, DiagID) << Alias;\n      Diag(PrevDecl->getLocation(), diag::note_previous_definition);\n      return nullptr;\n    }\n  }\n\n  // The use of a nested name specifier may trigger deprecation warnings.\n  DiagnoseUseOfDecl(ND, IdentLoc);\n\n  NamespaceAliasDecl *AliasDecl =\n    NamespaceAliasDecl::Create(Context, CurContext, NamespaceLoc, AliasLoc,\n                               Alias, SS.getWithLocInContext(Context),\n                               IdentLoc, ND);\n  if (Prev)\n    AliasDecl->setPreviousDecl(Prev);\n\n  PushOnScopeChains(AliasDecl, S);\n  return AliasDecl;\n}\n\nnamespace {\nstruct SpecialMemberExceptionSpecInfo\n    : SpecialMemberVisitor<SpecialMemberExceptionSpecInfo> {\n  SourceLocation Loc;\n  Sema::ImplicitExceptionSpecification ExceptSpec;\n\n  SpecialMemberExceptionSpecInfo(Sema &S, CXXMethodDecl *MD,\n                                 Sema::CXXSpecialMember CSM,\n                                 Sema::InheritedConstructorInfo *ICI,\n                                 SourceLocation Loc)\n      : SpecialMemberVisitor(S, MD, CSM, ICI), Loc(Loc), ExceptSpec(S) {}\n\n  bool visitBase(CXXBaseSpecifier *Base);\n  bool visitField(FieldDecl *FD);\n\n  void visitClassSubobject(CXXRecordDecl *Class, Subobject Subobj,\n                           unsigned Quals);\n\n  void visitSubobjectCall(Subobject Subobj,\n                          Sema::SpecialMemberOverloadResult SMOR);\n};\n}\n\nbool SpecialMemberExceptionSpecInfo::visitBase(CXXBaseSpecifier *Base) {\n  auto *RT = Base->getType()->getAs<RecordType>();\n  if (!RT)\n    return false;\n\n  auto *BaseClass = cast<CXXRecordDecl>(RT->getDecl());\n  Sema::SpecialMemberOverloadResult SMOR = lookupInheritedCtor(BaseClass);\n  if (auto *BaseCtor = SMOR.getMethod()) {\n    visitSubobjectCall(Base, BaseCtor);\n    return false;\n  }\n\n  visitClassSubobject(BaseClass, Base, 0);\n  return false;\n}\n\nbool SpecialMemberExceptionSpecInfo::visitField(FieldDecl *FD) {\n  if (CSM == Sema::CXXDefaultConstructor && FD->hasInClassInitializer()) {\n    Expr *E = FD->getInClassInitializer();\n    if (!E)\n      // FIXME: It's a little wasteful to build and throw away a\n      // CXXDefaultInitExpr here.\n      // FIXME: We should have a single context note pointing at Loc, and\n      // this location should be MD->getLocation() instead, since that's\n      // the location where we actually use the default init expression.\n      E = S.BuildCXXDefaultInitExpr(Loc, FD).get();\n    if (E)\n      ExceptSpec.CalledExpr(E);\n  } else if (auto *RT = S.Context.getBaseElementType(FD->getType())\n                            ->getAs<RecordType>()) {\n    visitClassSubobject(cast<CXXRecordDecl>(RT->getDecl()), FD,\n                        FD->getType().getCVRQualifiers());\n  }\n  return false;\n}\n\nvoid SpecialMemberExceptionSpecInfo::visitClassSubobject(CXXRecordDecl *Class,\n                                                         Subobject Subobj,\n                                                         unsigned Quals) {\n  FieldDecl *Field = Subobj.dyn_cast<FieldDecl*>();\n  bool IsMutable = Field && Field->isMutable();\n  visitSubobjectCall(Subobj, lookupIn(Class, Quals, IsMutable));\n}\n\nvoid SpecialMemberExceptionSpecInfo::visitSubobjectCall(\n    Subobject Subobj, Sema::SpecialMemberOverloadResult SMOR) {\n  // Note, if lookup fails, it doesn't matter what exception specification we\n  // choose because the special member will be deleted.\n  if (CXXMethodDecl *MD = SMOR.getMethod())\n    ExceptSpec.CalledDecl(getSubobjectLoc(Subobj), MD);\n}\n\nbool Sema::tryResolveExplicitSpecifier(ExplicitSpecifier &ExplicitSpec) {\n  llvm::APSInt Result;\n  ExprResult Converted = CheckConvertedConstantExpression(\n      ExplicitSpec.getExpr(), Context.BoolTy, Result, CCEK_ExplicitBool);\n  ExplicitSpec.setExpr(Converted.get());\n  if (Converted.isUsable() && !Converted.get()->isValueDependent()) {\n    ExplicitSpec.setKind(Result.getBoolValue()\n                             ? ExplicitSpecKind::ResolvedTrue\n                             : ExplicitSpecKind::ResolvedFalse);\n    return true;\n  }\n  ExplicitSpec.setKind(ExplicitSpecKind::Unresolved);\n  return false;\n}\n\nExplicitSpecifier Sema::ActOnExplicitBoolSpecifier(Expr *ExplicitExpr) {\n  ExplicitSpecifier ES(ExplicitExpr, ExplicitSpecKind::Unresolved);\n  if (!ExplicitExpr->isTypeDependent())\n    tryResolveExplicitSpecifier(ES);\n  return ES;\n}\n\nstatic Sema::ImplicitExceptionSpecification\nComputeDefaultedSpecialMemberExceptionSpec(\n    Sema &S, SourceLocation Loc, CXXMethodDecl *MD, Sema::CXXSpecialMember CSM,\n    Sema::InheritedConstructorInfo *ICI) {\n  ComputingExceptionSpec CES(S, MD, Loc);\n\n  CXXRecordDecl *ClassDecl = MD->getParent();\n\n  // C++ [except.spec]p14:\n  //   An implicitly declared special member function (Clause 12) shall have an\n  //   exception-specification. [...]\n  SpecialMemberExceptionSpecInfo Info(S, MD, CSM, ICI, MD->getLocation());\n  if (ClassDecl->isInvalidDecl())\n    return Info.ExceptSpec;\n\n  // FIXME: If this diagnostic fires, we're probably missing a check for\n  // attempting to resolve an exception specification before it's known\n  // at a higher level.\n  if (S.RequireCompleteType(MD->getLocation(),\n                            S.Context.getRecordType(ClassDecl),\n                            diag::err_exception_spec_incomplete_type))\n    return Info.ExceptSpec;\n\n  // C++1z [except.spec]p7:\n  //   [Look for exceptions thrown by] a constructor selected [...] to\n  //   initialize a potentially constructed subobject,\n  // C++1z [except.spec]p8:\n  //   The exception specification for an implicitly-declared destructor, or a\n  //   destructor without a noexcept-specifier, is potentially-throwing if and\n  //   only if any of the destructors for any of its potentially constructed\n  //   subojects is potentially throwing.\n  // FIXME: We respect the first rule but ignore the \"potentially constructed\"\n  // in the second rule to resolve a core issue (no number yet) that would have\n  // us reject:\n  //   struct A { virtual void f() = 0; virtual ~A() noexcept(false) = 0; };\n  //   struct B : A {};\n  //   struct C : B { void f(); };\n  // ... due to giving B::~B() a non-throwing exception specification.\n  Info.visit(Info.IsConstructor ? Info.VisitPotentiallyConstructedBases\n                                : Info.VisitAllBases);\n\n  return Info.ExceptSpec;\n}\n\nnamespace {\n/// RAII object to register a special member as being currently declared.\nstruct DeclaringSpecialMember {\n  Sema &S;\n  Sema::SpecialMemberDecl D;\n  Sema::ContextRAII SavedContext;\n  bool WasAlreadyBeingDeclared;\n\n  DeclaringSpecialMember(Sema &S, CXXRecordDecl *RD, Sema::CXXSpecialMember CSM)\n      : S(S), D(RD, CSM), SavedContext(S, RD) {\n    WasAlreadyBeingDeclared = !S.SpecialMembersBeingDeclared.insert(D).second;\n    if (WasAlreadyBeingDeclared)\n      // This almost never happens, but if it does, ensure that our cache\n      // doesn't contain a stale result.\n      S.SpecialMemberCache.clear();\n    else {\n      // Register a note to be produced if we encounter an error while\n      // declaring the special member.\n      Sema::CodeSynthesisContext Ctx;\n      Ctx.Kind = Sema::CodeSynthesisContext::DeclaringSpecialMember;\n      // FIXME: We don't have a location to use here. Using the class's\n      // location maintains the fiction that we declare all special members\n      // with the class, but (1) it's not clear that lying about that helps our\n      // users understand what's going on, and (2) there may be outer contexts\n      // on the stack (some of which are relevant) and printing them exposes\n      // our lies.\n      Ctx.PointOfInstantiation = RD->getLocation();\n      Ctx.Entity = RD;\n      Ctx.SpecialMember = CSM;\n      S.pushCodeSynthesisContext(Ctx);\n    }\n  }\n  ~DeclaringSpecialMember() {\n    if (!WasAlreadyBeingDeclared) {\n      S.SpecialMembersBeingDeclared.erase(D);\n      S.popCodeSynthesisContext();\n    }\n  }\n\n  /// Are we already trying to declare this special member?\n  bool isAlreadyBeingDeclared() const {\n    return WasAlreadyBeingDeclared;\n  }\n};\n}\n\nvoid Sema::CheckImplicitSpecialMemberDeclaration(Scope *S, FunctionDecl *FD) {\n  // Look up any existing declarations, but don't trigger declaration of all\n  // implicit special members with this name.\n  DeclarationName Name = FD->getDeclName();\n  LookupResult R(*this, Name, SourceLocation(), LookupOrdinaryName,\n                 ForExternalRedeclaration);\n  for (auto *D : FD->getParent()->lookup(Name))\n    if (auto *Acceptable = R.getAcceptableDecl(D))\n      R.addDecl(Acceptable);\n  R.resolveKind();\n  R.suppressDiagnostics();\n\n  CheckFunctionDeclaration(S, FD, R, /*IsMemberSpecialization*/false);\n}\n\nvoid Sema::setupImplicitSpecialMemberType(CXXMethodDecl *SpecialMem,\n                                          QualType ResultTy,\n                                          ArrayRef<QualType> Args) {\n  // Build an exception specification pointing back at this constructor.\n  FunctionProtoType::ExtProtoInfo EPI = getImplicitMethodEPI(*this, SpecialMem);\n\n  LangAS AS = getDefaultCXXMethodAddrSpace();\n  if (AS != LangAS::Default) {\n    EPI.TypeQuals.addAddressSpace(AS);\n  }\n\n  auto QT = Context.getFunctionType(ResultTy, Args, EPI);\n  SpecialMem->setType(QT);\n}\n\nCXXConstructorDecl *Sema::DeclareImplicitDefaultConstructor(\n                                                     CXXRecordDecl *ClassDecl) {\n  // C++ [class.ctor]p5:\n  //   A default constructor for a class X is a constructor of class X\n  //   that can be called without an argument. If there is no\n  //   user-declared constructor for class X, a default constructor is\n  //   implicitly declared. An implicitly-declared default constructor\n  //   is an inline public member of its class.\n  assert(ClassDecl->needsImplicitDefaultConstructor() &&\n         \"Should not build implicit default constructor!\");\n\n  DeclaringSpecialMember DSM(*this, ClassDecl, CXXDefaultConstructor);\n  if (DSM.isAlreadyBeingDeclared())\n    return nullptr;\n\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,\n                                                     CXXDefaultConstructor,\n                                                     false);\n\n  // Create the actual constructor declaration.\n  CanQualType ClassType\n    = Context.getCanonicalType(Context.getTypeDeclType(ClassDecl));\n  SourceLocation ClassLoc = ClassDecl->getLocation();\n  DeclarationName Name\n    = Context.DeclarationNames.getCXXConstructorName(ClassType);\n  DeclarationNameInfo NameInfo(Name, ClassLoc);\n  CXXConstructorDecl *DefaultCon = CXXConstructorDecl::Create(\n      Context, ClassDecl, ClassLoc, NameInfo, /*Type*/ QualType(),\n      /*TInfo=*/nullptr, ExplicitSpecifier(),\n      /*isInline=*/true, /*isImplicitlyDeclared=*/true,\n      Constexpr ? ConstexprSpecKind::Constexpr\n                : ConstexprSpecKind::Unspecified);\n  DefaultCon->setAccess(AS_public);\n  DefaultCon->setDefaulted();\n\n  if (getLangOpts().CUDA) {\n    inferCUDATargetForImplicitSpecialMember(ClassDecl, CXXDefaultConstructor,\n                                            DefaultCon,\n                                            /* ConstRHS */ false,\n                                            /* Diagnose */ false);\n  }\n\n  setupImplicitSpecialMemberType(DefaultCon, Context.VoidTy, None);\n\n  // We don't need to use SpecialMemberIsTrivial here; triviality for default\n  // constructors is easy to compute.\n  DefaultCon->setTrivial(ClassDecl->hasTrivialDefaultConstructor());\n\n  // Note that we have declared this constructor.\n  ++getASTContext().NumImplicitDefaultConstructorsDeclared;\n\n  Scope *S = getScopeForContext(ClassDecl);\n  CheckImplicitSpecialMemberDeclaration(S, DefaultCon);\n\n  if (ShouldDeleteSpecialMember(DefaultCon, CXXDefaultConstructor))\n    SetDeclDeleted(DefaultCon, ClassLoc);\n\n  if (S)\n    PushOnScopeChains(DefaultCon, S, false);\n  ClassDecl->addDecl(DefaultCon);\n\n  return DefaultCon;\n}\n\nvoid Sema::DefineImplicitDefaultConstructor(SourceLocation CurrentLocation,\n                                            CXXConstructorDecl *Constructor) {\n  assert((Constructor->isDefaulted() && Constructor->isDefaultConstructor() &&\n          !Constructor->doesThisDeclarationHaveABody() &&\n          !Constructor->isDeleted()) &&\n    \"DefineImplicitDefaultConstructor - call it for implicit default ctor\");\n  if (Constructor->willHaveBody() || Constructor->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = Constructor->getParent();\n  assert(ClassDecl && \"DefineImplicitDefaultConstructor - invalid constructor\");\n\n  SynthesizedFunctionScope Scope(*this, Constructor);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       Constructor->getType()->castAs<FunctionProtoType>());\n  MarkVTableUsed(CurrentLocation, ClassDecl);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  if (SetCtorInitializers(Constructor, /*AnyErrors=*/false)) {\n    Constructor->setInvalidDecl();\n    return;\n  }\n\n  SourceLocation Loc = Constructor->getEndLoc().isValid()\n                           ? Constructor->getEndLoc()\n                           : Constructor->getLocation();\n  Constructor->setBody(new (Context) CompoundStmt(Loc));\n  Constructor->markUsed(Context);\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(Constructor);\n  }\n\n  DiagnoseUninitializedFields(*this, Constructor);\n}\n\nvoid Sema::ActOnFinishDelayedMemberInitializers(Decl *D) {\n  // Perform any delayed checks on exception specifications.\n  CheckDelayedMemberExceptionSpecs();\n}\n\n/// Find or create the fake constructor we synthesize to model constructing an\n/// object of a derived class via a constructor of a base class.\nCXXConstructorDecl *\nSema::findInheritingConstructor(SourceLocation Loc,\n                                CXXConstructorDecl *BaseCtor,\n                                ConstructorUsingShadowDecl *Shadow) {\n  CXXRecordDecl *Derived = Shadow->getParent();\n  SourceLocation UsingLoc = Shadow->getLocation();\n\n  // FIXME: Add a new kind of DeclarationName for an inherited constructor.\n  // For now we use the name of the base class constructor as a member of the\n  // derived class to indicate a (fake) inherited constructor name.\n  DeclarationName Name = BaseCtor->getDeclName();\n\n  // Check to see if we already have a fake constructor for this inherited\n  // constructor call.\n  for (NamedDecl *Ctor : Derived->lookup(Name))\n    if (declaresSameEntity(cast<CXXConstructorDecl>(Ctor)\n                               ->getInheritedConstructor()\n                               .getConstructor(),\n                           BaseCtor))\n      return cast<CXXConstructorDecl>(Ctor);\n\n  DeclarationNameInfo NameInfo(Name, UsingLoc);\n  TypeSourceInfo *TInfo =\n      Context.getTrivialTypeSourceInfo(BaseCtor->getType(), UsingLoc);\n  FunctionProtoTypeLoc ProtoLoc =\n      TInfo->getTypeLoc().IgnoreParens().castAs<FunctionProtoTypeLoc>();\n\n  // Check the inherited constructor is valid and find the list of base classes\n  // from which it was inherited.\n  InheritedConstructorInfo ICI(*this, Loc, Shadow);\n\n  bool Constexpr =\n      BaseCtor->isConstexpr() &&\n      defaultedSpecialMemberIsConstexpr(*this, Derived, CXXDefaultConstructor,\n                                        false, BaseCtor, &ICI);\n\n  CXXConstructorDecl *DerivedCtor = CXXConstructorDecl::Create(\n      Context, Derived, UsingLoc, NameInfo, TInfo->getType(), TInfo,\n      BaseCtor->getExplicitSpecifier(), /*isInline=*/true,\n      /*isImplicitlyDeclared=*/true,\n      Constexpr ? BaseCtor->getConstexprKind() : ConstexprSpecKind::Unspecified,\n      InheritedConstructor(Shadow, BaseCtor),\n      BaseCtor->getTrailingRequiresClause());\n  if (Shadow->isInvalidDecl())\n    DerivedCtor->setInvalidDecl();\n\n  // Build an unevaluated exception specification for this fake constructor.\n  const FunctionProtoType *FPT = TInfo->getType()->castAs<FunctionProtoType>();\n  FunctionProtoType::ExtProtoInfo EPI = FPT->getExtProtoInfo();\n  EPI.ExceptionSpec.Type = EST_Unevaluated;\n  EPI.ExceptionSpec.SourceDecl = DerivedCtor;\n  DerivedCtor->setType(Context.getFunctionType(FPT->getReturnType(),\n                                               FPT->getParamTypes(), EPI));\n\n  // Build the parameter declarations.\n  SmallVector<ParmVarDecl *, 16> ParamDecls;\n  for (unsigned I = 0, N = FPT->getNumParams(); I != N; ++I) {\n    TypeSourceInfo *TInfo =\n        Context.getTrivialTypeSourceInfo(FPT->getParamType(I), UsingLoc);\n    ParmVarDecl *PD = ParmVarDecl::Create(\n        Context, DerivedCtor, UsingLoc, UsingLoc, /*IdentifierInfo=*/nullptr,\n        FPT->getParamType(I), TInfo, SC_None, /*DefArg=*/nullptr);\n    PD->setScopeInfo(0, I);\n    PD->setImplicit();\n    // Ensure attributes are propagated onto parameters (this matters for\n    // format, pass_object_size, ...).\n    mergeDeclAttributes(PD, BaseCtor->getParamDecl(I));\n    ParamDecls.push_back(PD);\n    ProtoLoc.setParam(I, PD);\n  }\n\n  // Set up the new constructor.\n  assert(!BaseCtor->isDeleted() && \"should not use deleted constructor\");\n  DerivedCtor->setAccess(BaseCtor->getAccess());\n  DerivedCtor->setParams(ParamDecls);\n  Derived->addDecl(DerivedCtor);\n\n  if (ShouldDeleteSpecialMember(DerivedCtor, CXXDefaultConstructor, &ICI))\n    SetDeclDeleted(DerivedCtor, UsingLoc);\n\n  return DerivedCtor;\n}\n\nvoid Sema::NoteDeletedInheritingConstructor(CXXConstructorDecl *Ctor) {\n  InheritedConstructorInfo ICI(*this, Ctor->getLocation(),\n                               Ctor->getInheritedConstructor().getShadowDecl());\n  ShouldDeleteSpecialMember(Ctor, CXXDefaultConstructor, &ICI,\n                            /*Diagnose*/true);\n}\n\nvoid Sema::DefineInheritingConstructor(SourceLocation CurrentLocation,\n                                       CXXConstructorDecl *Constructor) {\n  CXXRecordDecl *ClassDecl = Constructor->getParent();\n  assert(Constructor->getInheritedConstructor() &&\n         !Constructor->doesThisDeclarationHaveABody() &&\n         !Constructor->isDeleted());\n  if (Constructor->willHaveBody() || Constructor->isInvalidDecl())\n    return;\n\n  // Initializations are performed \"as if by a defaulted default constructor\",\n  // so enter the appropriate scope.\n  SynthesizedFunctionScope Scope(*this, Constructor);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       Constructor->getType()->castAs<FunctionProtoType>());\n  MarkVTableUsed(CurrentLocation, ClassDecl);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  ConstructorUsingShadowDecl *Shadow =\n      Constructor->getInheritedConstructor().getShadowDecl();\n  CXXConstructorDecl *InheritedCtor =\n      Constructor->getInheritedConstructor().getConstructor();\n\n  // [class.inhctor.init]p1:\n  //   initialization proceeds as if a defaulted default constructor is used to\n  //   initialize the D object and each base class subobject from which the\n  //   constructor was inherited\n\n  InheritedConstructorInfo ICI(*this, CurrentLocation, Shadow);\n  CXXRecordDecl *RD = Shadow->getParent();\n  SourceLocation InitLoc = Shadow->getLocation();\n\n  // Build explicit initializers for all base classes from which the\n  // constructor was inherited.\n  SmallVector<CXXCtorInitializer*, 8> Inits;\n  for (bool VBase : {false, true}) {\n    for (CXXBaseSpecifier &B : VBase ? RD->vbases() : RD->bases()) {\n      if (B.isVirtual() != VBase)\n        continue;\n\n      auto *BaseRD = B.getType()->getAsCXXRecordDecl();\n      if (!BaseRD)\n        continue;\n\n      auto BaseCtor = ICI.findConstructorForBase(BaseRD, InheritedCtor);\n      if (!BaseCtor.first)\n        continue;\n\n      MarkFunctionReferenced(CurrentLocation, BaseCtor.first);\n      ExprResult Init = new (Context) CXXInheritedCtorInitExpr(\n          InitLoc, B.getType(), BaseCtor.first, VBase, BaseCtor.second);\n\n      auto *TInfo = Context.getTrivialTypeSourceInfo(B.getType(), InitLoc);\n      Inits.push_back(new (Context) CXXCtorInitializer(\n          Context, TInfo, VBase, InitLoc, Init.get(), InitLoc,\n          SourceLocation()));\n    }\n  }\n\n  // We now proceed as if for a defaulted default constructor, with the relevant\n  // initializers replaced.\n\n  if (SetCtorInitializers(Constructor, /*AnyErrors*/false, Inits)) {\n    Constructor->setInvalidDecl();\n    return;\n  }\n\n  Constructor->setBody(new (Context) CompoundStmt(InitLoc));\n  Constructor->markUsed(Context);\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(Constructor);\n  }\n\n  DiagnoseUninitializedFields(*this, Constructor);\n}\n\nCXXDestructorDecl *Sema::DeclareImplicitDestructor(CXXRecordDecl *ClassDecl) {\n  // C++ [class.dtor]p2:\n  //   If a class has no user-declared destructor, a destructor is\n  //   declared implicitly. An implicitly-declared destructor is an\n  //   inline public member of its class.\n  assert(ClassDecl->needsImplicitDestructor());\n\n  DeclaringSpecialMember DSM(*this, ClassDecl, CXXDestructor);\n  if (DSM.isAlreadyBeingDeclared())\n    return nullptr;\n\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,\n                                                     CXXDestructor,\n                                                     false);\n\n  // Create the actual destructor declaration.\n  CanQualType ClassType\n    = Context.getCanonicalType(Context.getTypeDeclType(ClassDecl));\n  SourceLocation ClassLoc = ClassDecl->getLocation();\n  DeclarationName Name\n    = Context.DeclarationNames.getCXXDestructorName(ClassType);\n  DeclarationNameInfo NameInfo(Name, ClassLoc);\n  CXXDestructorDecl *Destructor =\n      CXXDestructorDecl::Create(Context, ClassDecl, ClassLoc, NameInfo,\n                                QualType(), nullptr, /*isInline=*/true,\n                                /*isImplicitlyDeclared=*/true,\n                                Constexpr ? ConstexprSpecKind::Constexpr\n                                          : ConstexprSpecKind::Unspecified);\n  Destructor->setAccess(AS_public);\n  Destructor->setDefaulted();\n\n  if (getLangOpts().CUDA) {\n    inferCUDATargetForImplicitSpecialMember(ClassDecl, CXXDestructor,\n                                            Destructor,\n                                            /* ConstRHS */ false,\n                                            /* Diagnose */ false);\n  }\n\n  setupImplicitSpecialMemberType(Destructor, Context.VoidTy, None);\n\n  // We don't need to use SpecialMemberIsTrivial here; triviality for\n  // destructors is easy to compute.\n  Destructor->setTrivial(ClassDecl->hasTrivialDestructor());\n  Destructor->setTrivialForCall(ClassDecl->hasAttr<TrivialABIAttr>() ||\n                                ClassDecl->hasTrivialDestructorForCall());\n\n  // Note that we have declared this destructor.\n  ++getASTContext().NumImplicitDestructorsDeclared;\n\n  Scope *S = getScopeForContext(ClassDecl);\n  CheckImplicitSpecialMemberDeclaration(S, Destructor);\n\n  // We can't check whether an implicit destructor is deleted before we complete\n  // the definition of the class, because its validity depends on the alignment\n  // of the class. We'll check this from ActOnFields once the class is complete.\n  if (ClassDecl->isCompleteDefinition() &&\n      ShouldDeleteSpecialMember(Destructor, CXXDestructor))\n    SetDeclDeleted(Destructor, ClassLoc);\n\n  // Introduce this destructor into its scope.\n  if (S)\n    PushOnScopeChains(Destructor, S, false);\n  ClassDecl->addDecl(Destructor);\n\n  return Destructor;\n}\n\nvoid Sema::DefineImplicitDestructor(SourceLocation CurrentLocation,\n                                    CXXDestructorDecl *Destructor) {\n  assert((Destructor->isDefaulted() &&\n          !Destructor->doesThisDeclarationHaveABody() &&\n          !Destructor->isDeleted()) &&\n         \"DefineImplicitDestructor - call it for implicit default dtor\");\n  if (Destructor->willHaveBody() || Destructor->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = Destructor->getParent();\n  assert(ClassDecl && \"DefineImplicitDestructor - invalid destructor\");\n\n  SynthesizedFunctionScope Scope(*this, Destructor);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       Destructor->getType()->castAs<FunctionProtoType>());\n  MarkVTableUsed(CurrentLocation, ClassDecl);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  MarkBaseAndMemberDestructorsReferenced(Destructor->getLocation(),\n                                         Destructor->getParent());\n\n  if (CheckDestructor(Destructor)) {\n    Destructor->setInvalidDecl();\n    return;\n  }\n\n  SourceLocation Loc = Destructor->getEndLoc().isValid()\n                           ? Destructor->getEndLoc()\n                           : Destructor->getLocation();\n  Destructor->setBody(new (Context) CompoundStmt(Loc));\n  Destructor->markUsed(Context);\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(Destructor);\n  }\n}\n\nvoid Sema::CheckCompleteDestructorVariant(SourceLocation CurrentLocation,\n                                          CXXDestructorDecl *Destructor) {\n  if (Destructor->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = Destructor->getParent();\n  assert(Context.getTargetInfo().getCXXABI().isMicrosoft() &&\n         \"implicit complete dtors unneeded outside MS ABI\");\n  assert(ClassDecl->getNumVBases() > 0 &&\n         \"complete dtor only exists for classes with vbases\");\n\n  SynthesizedFunctionScope Scope(*this, Destructor);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  MarkVirtualBaseDestructorsReferenced(Destructor->getLocation(), ClassDecl);\n}\n\n/// Perform any semantic analysis which needs to be delayed until all\n/// pending class member declarations have been parsed.\nvoid Sema::ActOnFinishCXXMemberDecls() {\n  // If the context is an invalid C++ class, just suppress these checks.\n  if (CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(CurContext)) {\n    if (Record->isInvalidDecl()) {\n      DelayedOverridingExceptionSpecChecks.clear();\n      DelayedEquivalentExceptionSpecChecks.clear();\n      return;\n    }\n    checkForMultipleExportedDefaultConstructors(*this, Record);\n  }\n}\n\nvoid Sema::ActOnFinishCXXNonNestedClass() {\n  referenceDLLExportedClassMethods();\n\n  if (!DelayedDllExportMemberFunctions.empty()) {\n    SmallVector<CXXMethodDecl*, 4> WorkList;\n    std::swap(DelayedDllExportMemberFunctions, WorkList);\n    for (CXXMethodDecl *M : WorkList) {\n      DefineDefaultedFunction(*this, M, M->getLocation());\n\n      // Pass the method to the consumer to get emitted. This is not necessary\n      // for explicit instantiation definitions, as they will get emitted\n      // anyway.\n      if (M->getParent()->getTemplateSpecializationKind() !=\n          TSK_ExplicitInstantiationDefinition)\n        ActOnFinishInlineFunctionDef(M);\n    }\n  }\n}\n\nvoid Sema::referenceDLLExportedClassMethods() {\n  if (!DelayedDllExportClasses.empty()) {\n    // Calling ReferenceDllExportedMembers might cause the current function to\n    // be called again, so use a local copy of DelayedDllExportClasses.\n    SmallVector<CXXRecordDecl *, 4> WorkList;\n    std::swap(DelayedDllExportClasses, WorkList);\n    for (CXXRecordDecl *Class : WorkList)\n      ReferenceDllExportedMembers(*this, Class);\n  }\n}\n\nvoid Sema::AdjustDestructorExceptionSpec(CXXDestructorDecl *Destructor) {\n  assert(getLangOpts().CPlusPlus11 &&\n         \"adjusting dtor exception specs was introduced in c++11\");\n\n  if (Destructor->isDependentContext())\n    return;\n\n  // C++11 [class.dtor]p3:\n  //   A declaration of a destructor that does not have an exception-\n  //   specification is implicitly considered to have the same exception-\n  //   specification as an implicit declaration.\n  const auto *DtorType = Destructor->getType()->castAs<FunctionProtoType>();\n  if (DtorType->hasExceptionSpec())\n    return;\n\n  // Replace the destructor's type, building off the existing one. Fortunately,\n  // the only thing of interest in the destructor type is its extended info.\n  // The return and arguments are fixed.\n  FunctionProtoType::ExtProtoInfo EPI = DtorType->getExtProtoInfo();\n  EPI.ExceptionSpec.Type = EST_Unevaluated;\n  EPI.ExceptionSpec.SourceDecl = Destructor;\n  Destructor->setType(Context.getFunctionType(Context.VoidTy, None, EPI));\n\n  // FIXME: If the destructor has a body that could throw, and the newly created\n  // spec doesn't allow exceptions, we should emit a warning, because this\n  // change in behavior can break conforming C++03 programs at runtime.\n  // However, we don't have a body or an exception specification yet, so it\n  // needs to be done somewhere else.\n}\n\nnamespace {\n/// An abstract base class for all helper classes used in building the\n//  copy/move operators. These classes serve as factory functions and help us\n//  avoid using the same Expr* in the AST twice.\nclass ExprBuilder {\n  ExprBuilder(const ExprBuilder&) = delete;\n  ExprBuilder &operator=(const ExprBuilder&) = delete;\n\nprotected:\n  static Expr *assertNotNull(Expr *E) {\n    assert(E && \"Expression construction must not fail.\");\n    return E;\n  }\n\npublic:\n  ExprBuilder() {}\n  virtual ~ExprBuilder() {}\n\n  virtual Expr *build(Sema &S, SourceLocation Loc) const = 0;\n};\n\nclass RefBuilder: public ExprBuilder {\n  VarDecl *Var;\n  QualType VarType;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(S.BuildDeclRefExpr(Var, VarType, VK_LValue, Loc));\n  }\n\n  RefBuilder(VarDecl *Var, QualType VarType)\n      : Var(Var), VarType(VarType) {}\n};\n\nclass ThisBuilder: public ExprBuilder {\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(S.ActOnCXXThis(Loc).getAs<Expr>());\n  }\n};\n\nclass CastBuilder: public ExprBuilder {\n  const ExprBuilder &Builder;\n  QualType Type;\n  ExprValueKind Kind;\n  const CXXCastPath &Path;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(S.ImpCastExprToType(Builder.build(S, Loc), Type,\n                                             CK_UncheckedDerivedToBase, Kind,\n                                             &Path).get());\n  }\n\n  CastBuilder(const ExprBuilder &Builder, QualType Type, ExprValueKind Kind,\n              const CXXCastPath &Path)\n      : Builder(Builder), Type(Type), Kind(Kind), Path(Path) {}\n};\n\nclass DerefBuilder: public ExprBuilder {\n  const ExprBuilder &Builder;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(\n        S.CreateBuiltinUnaryOp(Loc, UO_Deref, Builder.build(S, Loc)).get());\n  }\n\n  DerefBuilder(const ExprBuilder &Builder) : Builder(Builder) {}\n};\n\nclass MemberBuilder: public ExprBuilder {\n  const ExprBuilder &Builder;\n  QualType Type;\n  CXXScopeSpec SS;\n  bool IsArrow;\n  LookupResult &MemberLookup;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(S.BuildMemberReferenceExpr(\n        Builder.build(S, Loc), Type, Loc, IsArrow, SS, SourceLocation(),\n        nullptr, MemberLookup, nullptr, nullptr).get());\n  }\n\n  MemberBuilder(const ExprBuilder &Builder, QualType Type, bool IsArrow,\n                LookupResult &MemberLookup)\n      : Builder(Builder), Type(Type), IsArrow(IsArrow),\n        MemberLookup(MemberLookup) {}\n};\n\nclass MoveCastBuilder: public ExprBuilder {\n  const ExprBuilder &Builder;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(CastForMoving(S, Builder.build(S, Loc)));\n  }\n\n  MoveCastBuilder(const ExprBuilder &Builder) : Builder(Builder) {}\n};\n\nclass LvalueConvBuilder: public ExprBuilder {\n  const ExprBuilder &Builder;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(\n        S.DefaultLvalueConversion(Builder.build(S, Loc)).get());\n  }\n\n  LvalueConvBuilder(const ExprBuilder &Builder) : Builder(Builder) {}\n};\n\nclass SubscriptBuilder: public ExprBuilder {\n  const ExprBuilder &Base;\n  const ExprBuilder &Index;\n\npublic:\n  Expr *build(Sema &S, SourceLocation Loc) const override {\n    return assertNotNull(S.CreateBuiltinArraySubscriptExpr(\n        Base.build(S, Loc), Loc, Index.build(S, Loc), Loc).get());\n  }\n\n  SubscriptBuilder(const ExprBuilder &Base, const ExprBuilder &Index)\n      : Base(Base), Index(Index) {}\n};\n\n} // end anonymous namespace\n\n/// When generating a defaulted copy or move assignment operator, if a field\n/// should be copied with __builtin_memcpy rather than via explicit assignments,\n/// do so. This optimization only applies for arrays of scalars, and for arrays\n/// of class type where the selected copy/move-assignment operator is trivial.\nstatic StmtResult\nbuildMemcpyForAssignmentOp(Sema &S, SourceLocation Loc, QualType T,\n                           const ExprBuilder &ToB, const ExprBuilder &FromB) {\n  // Compute the size of the memory buffer to be copied.\n  QualType SizeType = S.Context.getSizeType();\n  llvm::APInt Size(S.Context.getTypeSize(SizeType),\n                   S.Context.getTypeSizeInChars(T).getQuantity());\n\n  // Take the address of the field references for \"from\" and \"to\". We\n  // directly construct UnaryOperators here because semantic analysis\n  // does not permit us to take the address of an xvalue.\n  Expr *From = FromB.build(S, Loc);\n  From = UnaryOperator::Create(\n      S.Context, From, UO_AddrOf, S.Context.getPointerType(From->getType()),\n      VK_RValue, OK_Ordinary, Loc, false, S.CurFPFeatureOverrides());\n  Expr *To = ToB.build(S, Loc);\n  To = UnaryOperator::Create(\n      S.Context, To, UO_AddrOf, S.Context.getPointerType(To->getType()),\n      VK_RValue, OK_Ordinary, Loc, false, S.CurFPFeatureOverrides());\n\n  const Type *E = T->getBaseElementTypeUnsafe();\n  bool NeedsCollectableMemCpy =\n      E->isRecordType() &&\n      E->castAs<RecordType>()->getDecl()->hasObjectMember();\n\n  // Create a reference to the __builtin_objc_memmove_collectable function\n  StringRef MemCpyName = NeedsCollectableMemCpy ?\n    \"__builtin_objc_memmove_collectable\" :\n    \"__builtin_memcpy\";\n  LookupResult R(S, &S.Context.Idents.get(MemCpyName), Loc,\n                 Sema::LookupOrdinaryName);\n  S.LookupName(R, S.TUScope, true);\n\n  FunctionDecl *MemCpy = R.getAsSingle<FunctionDecl>();\n  if (!MemCpy)\n    // Something went horribly wrong earlier, and we will have complained\n    // about it.\n    return StmtError();\n\n  ExprResult MemCpyRef = S.BuildDeclRefExpr(MemCpy, S.Context.BuiltinFnTy,\n                                            VK_RValue, Loc, nullptr);\n  assert(MemCpyRef.isUsable() && \"Builtin reference cannot fail\");\n\n  Expr *CallArgs[] = {\n    To, From, IntegerLiteral::Create(S.Context, Size, SizeType, Loc)\n  };\n  ExprResult Call = S.BuildCallExpr(/*Scope=*/nullptr, MemCpyRef.get(),\n                                    Loc, CallArgs, Loc);\n\n  assert(!Call.isInvalid() && \"Call to __builtin_memcpy cannot fail!\");\n  return Call.getAs<Stmt>();\n}\n\n/// Builds a statement that copies/moves the given entity from \\p From to\n/// \\c To.\n///\n/// This routine is used to copy/move the members of a class with an\n/// implicitly-declared copy/move assignment operator. When the entities being\n/// copied are arrays, this routine builds for loops to copy them.\n///\n/// \\param S The Sema object used for type-checking.\n///\n/// \\param Loc The location where the implicit copy/move is being generated.\n///\n/// \\param T The type of the expressions being copied/moved. Both expressions\n/// must have this type.\n///\n/// \\param To The expression we are copying/moving to.\n///\n/// \\param From The expression we are copying/moving from.\n///\n/// \\param CopyingBaseSubobject Whether we're copying/moving a base subobject.\n/// Otherwise, it's a non-static member subobject.\n///\n/// \\param Copying Whether we're copying or moving.\n///\n/// \\param Depth Internal parameter recording the depth of the recursion.\n///\n/// \\returns A statement or a loop that copies the expressions, or StmtResult(0)\n/// if a memcpy should be used instead.\nstatic StmtResult\nbuildSingleCopyAssignRecursively(Sema &S, SourceLocation Loc, QualType T,\n                                 const ExprBuilder &To, const ExprBuilder &From,\n                                 bool CopyingBaseSubobject, bool Copying,\n                                 unsigned Depth = 0) {\n  // C++11 [class.copy]p28:\n  //   Each subobject is assigned in the manner appropriate to its type:\n  //\n  //     - if the subobject is of class type, as if by a call to operator= with\n  //       the subobject as the object expression and the corresponding\n  //       subobject of x as a single function argument (as if by explicit\n  //       qualification; that is, ignoring any possible virtual overriding\n  //       functions in more derived classes);\n  //\n  // C++03 [class.copy]p13:\n  //     - if the subobject is of class type, the copy assignment operator for\n  //       the class is used (as if by explicit qualification; that is,\n  //       ignoring any possible virtual overriding functions in more derived\n  //       classes);\n  if (const RecordType *RecordTy = T->getAs<RecordType>()) {\n    CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(RecordTy->getDecl());\n\n    // Look for operator=.\n    DeclarationName Name\n      = S.Context.DeclarationNames.getCXXOperatorName(OO_Equal);\n    LookupResult OpLookup(S, Name, Loc, Sema::LookupOrdinaryName);\n    S.LookupQualifiedName(OpLookup, ClassDecl, false);\n\n    // Prior to C++11, filter out any result that isn't a copy/move-assignment\n    // operator.\n    if (!S.getLangOpts().CPlusPlus11) {\n      LookupResult::Filter F = OpLookup.makeFilter();\n      while (F.hasNext()) {\n        NamedDecl *D = F.next();\n        if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(D))\n          if (Method->isCopyAssignmentOperator() ||\n              (!Copying && Method->isMoveAssignmentOperator()))\n            continue;\n\n        F.erase();\n      }\n      F.done();\n    }\n\n    // Suppress the protected check (C++ [class.protected]) for each of the\n    // assignment operators we found. This strange dance is required when\n    // we're assigning via a base classes's copy-assignment operator. To\n    // ensure that we're getting the right base class subobject (without\n    // ambiguities), we need to cast \"this\" to that subobject type; to\n    // ensure that we don't go through the virtual call mechanism, we need\n    // to qualify the operator= name with the base class (see below). However,\n    // this means that if the base class has a protected copy assignment\n    // operator, the protected member access check will fail. So, we\n    // rewrite \"protected\" access to \"public\" access in this case, since we\n    // know by construction that we're calling from a derived class.\n    if (CopyingBaseSubobject) {\n      for (LookupResult::iterator L = OpLookup.begin(), LEnd = OpLookup.end();\n           L != LEnd; ++L) {\n        if (L.getAccess() == AS_protected)\n          L.setAccess(AS_public);\n      }\n    }\n\n    // Create the nested-name-specifier that will be used to qualify the\n    // reference to operator=; this is required to suppress the virtual\n    // call mechanism.\n    CXXScopeSpec SS;\n    const Type *CanonicalT = S.Context.getCanonicalType(T.getTypePtr());\n    SS.MakeTrivial(S.Context,\n                   NestedNameSpecifier::Create(S.Context, nullptr, false,\n                                               CanonicalT),\n                   Loc);\n\n    // Create the reference to operator=.\n    ExprResult OpEqualRef\n      = S.BuildMemberReferenceExpr(To.build(S, Loc), T, Loc, /*IsArrow=*/false,\n                                   SS, /*TemplateKWLoc=*/SourceLocation(),\n                                   /*FirstQualifierInScope=*/nullptr,\n                                   OpLookup,\n                                   /*TemplateArgs=*/nullptr, /*S*/nullptr,\n                                   /*SuppressQualifierCheck=*/true);\n    if (OpEqualRef.isInvalid())\n      return StmtError();\n\n    // Build the call to the assignment operator.\n\n    Expr *FromInst = From.build(S, Loc);\n    ExprResult Call = S.BuildCallToMemberFunction(/*Scope=*/nullptr,\n                                                  OpEqualRef.getAs<Expr>(),\n                                                  Loc, FromInst, Loc);\n    if (Call.isInvalid())\n      return StmtError();\n\n    // If we built a call to a trivial 'operator=' while copying an array,\n    // bail out. We'll replace the whole shebang with a memcpy.\n    CXXMemberCallExpr *CE = dyn_cast<CXXMemberCallExpr>(Call.get());\n    if (CE && CE->getMethodDecl()->isTrivial() && Depth)\n      return StmtResult((Stmt*)nullptr);\n\n    // Convert to an expression-statement, and clean up any produced\n    // temporaries.\n    return S.ActOnExprStmt(Call);\n  }\n\n  //     - if the subobject is of scalar type, the built-in assignment\n  //       operator is used.\n  const ConstantArrayType *ArrayTy = S.Context.getAsConstantArrayType(T);\n  if (!ArrayTy) {\n    ExprResult Assignment = S.CreateBuiltinBinOp(\n        Loc, BO_Assign, To.build(S, Loc), From.build(S, Loc));\n    if (Assignment.isInvalid())\n      return StmtError();\n    return S.ActOnExprStmt(Assignment);\n  }\n\n  //     - if the subobject is an array, each element is assigned, in the\n  //       manner appropriate to the element type;\n\n  // Construct a loop over the array bounds, e.g.,\n  //\n  //   for (__SIZE_TYPE__ i0 = 0; i0 != array-size; ++i0)\n  //\n  // that will copy each of the array elements.\n  QualType SizeType = S.Context.getSizeType();\n\n  // Create the iteration variable.\n  IdentifierInfo *IterationVarName = nullptr;\n  {\n    SmallString<8> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << \"__i\" << Depth;\n    IterationVarName = &S.Context.Idents.get(OS.str());\n  }\n  VarDecl *IterationVar = VarDecl::Create(S.Context, S.CurContext, Loc, Loc,\n                                          IterationVarName, SizeType,\n                            S.Context.getTrivialTypeSourceInfo(SizeType, Loc),\n                                          SC_None);\n\n  // Initialize the iteration variable to zero.\n  llvm::APInt Zero(S.Context.getTypeSize(SizeType), 0);\n  IterationVar->setInit(IntegerLiteral::Create(S.Context, Zero, SizeType, Loc));\n\n  // Creates a reference to the iteration variable.\n  RefBuilder IterationVarRef(IterationVar, SizeType);\n  LvalueConvBuilder IterationVarRefRVal(IterationVarRef);\n\n  // Create the DeclStmt that holds the iteration variable.\n  Stmt *InitStmt = new (S.Context) DeclStmt(DeclGroupRef(IterationVar),Loc,Loc);\n\n  // Subscript the \"from\" and \"to\" expressions with the iteration variable.\n  SubscriptBuilder FromIndexCopy(From, IterationVarRefRVal);\n  MoveCastBuilder FromIndexMove(FromIndexCopy);\n  const ExprBuilder *FromIndex;\n  if (Copying)\n    FromIndex = &FromIndexCopy;\n  else\n    FromIndex = &FromIndexMove;\n\n  SubscriptBuilder ToIndex(To, IterationVarRefRVal);\n\n  // Build the copy/move for an individual element of the array.\n  StmtResult Copy =\n    buildSingleCopyAssignRecursively(S, Loc, ArrayTy->getElementType(),\n                                     ToIndex, *FromIndex, CopyingBaseSubobject,\n                                     Copying, Depth + 1);\n  // Bail out if copying fails or if we determined that we should use memcpy.\n  if (Copy.isInvalid() || !Copy.get())\n    return Copy;\n\n  // Create the comparison against the array bound.\n  llvm::APInt Upper\n    = ArrayTy->getSize().zextOrTrunc(S.Context.getTypeSize(SizeType));\n  Expr *Comparison = BinaryOperator::Create(\n      S.Context, IterationVarRefRVal.build(S, Loc),\n      IntegerLiteral::Create(S.Context, Upper, SizeType, Loc), BO_NE,\n      S.Context.BoolTy, VK_RValue, OK_Ordinary, Loc, S.CurFPFeatureOverrides());\n\n  // Create the pre-increment of the iteration variable. We can determine\n  // whether the increment will overflow based on the value of the array\n  // bound.\n  Expr *Increment = UnaryOperator::Create(\n      S.Context, IterationVarRef.build(S, Loc), UO_PreInc, SizeType, VK_LValue,\n      OK_Ordinary, Loc, Upper.isMaxValue(), S.CurFPFeatureOverrides());\n\n  // Construct the loop that copies all elements of this array.\n  return S.ActOnForStmt(\n      Loc, Loc, InitStmt,\n      S.ActOnCondition(nullptr, Loc, Comparison, Sema::ConditionKind::Boolean),\n      S.MakeFullDiscardedValueExpr(Increment), Loc, Copy.get());\n}\n\nstatic StmtResult\nbuildSingleCopyAssign(Sema &S, SourceLocation Loc, QualType T,\n                      const ExprBuilder &To, const ExprBuilder &From,\n                      bool CopyingBaseSubobject, bool Copying) {\n  // Maybe we should use a memcpy?\n  if (T->isArrayType() && !T.isConstQualified() && !T.isVolatileQualified() &&\n      T.isTriviallyCopyableType(S.Context))\n    return buildMemcpyForAssignmentOp(S, Loc, T, To, From);\n\n  StmtResult Result(buildSingleCopyAssignRecursively(S, Loc, T, To, From,\n                                                     CopyingBaseSubobject,\n                                                     Copying, 0));\n\n  // If we ended up picking a trivial assignment operator for an array of a\n  // non-trivially-copyable class type, just emit a memcpy.\n  if (!Result.isInvalid() && !Result.get())\n    return buildMemcpyForAssignmentOp(S, Loc, T, To, From);\n\n  return Result;\n}\n\nCXXMethodDecl *Sema::DeclareImplicitCopyAssignment(CXXRecordDecl *ClassDecl) {\n  // Note: The following rules are largely analoguous to the copy\n  // constructor rules. Note that virtual bases are not taken into account\n  // for determining the argument type of the operator. Note also that\n  // operators taking an object instead of a reference are allowed.\n  assert(ClassDecl->needsImplicitCopyAssignment());\n\n  DeclaringSpecialMember DSM(*this, ClassDecl, CXXCopyAssignment);\n  if (DSM.isAlreadyBeingDeclared())\n    return nullptr;\n\n  QualType ArgType = Context.getTypeDeclType(ClassDecl);\n  LangAS AS = getDefaultCXXMethodAddrSpace();\n  if (AS != LangAS::Default)\n    ArgType = Context.getAddrSpaceQualType(ArgType, AS);\n  QualType RetType = Context.getLValueReferenceType(ArgType);\n  bool Const = ClassDecl->implicitCopyAssignmentHasConstParam();\n  if (Const)\n    ArgType = ArgType.withConst();\n\n  ArgType = Context.getLValueReferenceType(ArgType);\n\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,\n                                                     CXXCopyAssignment,\n                                                     Const);\n\n  //   An implicitly-declared copy assignment operator is an inline public\n  //   member of its class.\n  DeclarationName Name = Context.DeclarationNames.getCXXOperatorName(OO_Equal);\n  SourceLocation ClassLoc = ClassDecl->getLocation();\n  DeclarationNameInfo NameInfo(Name, ClassLoc);\n  CXXMethodDecl *CopyAssignment = CXXMethodDecl::Create(\n      Context, ClassDecl, ClassLoc, NameInfo, QualType(),\n      /*TInfo=*/nullptr, /*StorageClass=*/SC_None,\n      /*isInline=*/true,\n      Constexpr ? ConstexprSpecKind::Constexpr : ConstexprSpecKind::Unspecified,\n      SourceLocation());\n  CopyAssignment->setAccess(AS_public);\n  CopyAssignment->setDefaulted();\n  CopyAssignment->setImplicit();\n\n  if (getLangOpts().CUDA) {\n    inferCUDATargetForImplicitSpecialMember(ClassDecl, CXXCopyAssignment,\n                                            CopyAssignment,\n                                            /* ConstRHS */ Const,\n                                            /* Diagnose */ false);\n  }\n\n  setupImplicitSpecialMemberType(CopyAssignment, RetType, ArgType);\n\n  // Add the parameter to the operator.\n  ParmVarDecl *FromParam = ParmVarDecl::Create(Context, CopyAssignment,\n                                               ClassLoc, ClassLoc,\n                                               /*Id=*/nullptr, ArgType,\n                                               /*TInfo=*/nullptr, SC_None,\n                                               nullptr);\n  CopyAssignment->setParams(FromParam);\n\n  CopyAssignment->setTrivial(\n    ClassDecl->needsOverloadResolutionForCopyAssignment()\n      ? SpecialMemberIsTrivial(CopyAssignment, CXXCopyAssignment)\n      : ClassDecl->hasTrivialCopyAssignment());\n\n  // Note that we have added this copy-assignment operator.\n  ++getASTContext().NumImplicitCopyAssignmentOperatorsDeclared;\n\n  Scope *S = getScopeForContext(ClassDecl);\n  CheckImplicitSpecialMemberDeclaration(S, CopyAssignment);\n\n  if (ShouldDeleteSpecialMember(CopyAssignment, CXXCopyAssignment)) {\n    ClassDecl->setImplicitCopyAssignmentIsDeleted();\n    SetDeclDeleted(CopyAssignment, ClassLoc);\n  }\n\n  if (S)\n    PushOnScopeChains(CopyAssignment, S, false);\n  ClassDecl->addDecl(CopyAssignment);\n\n  return CopyAssignment;\n}\n\n/// Diagnose an implicit copy operation for a class which is odr-used, but\n/// which is deprecated because the class has a user-declared copy constructor,\n/// copy assignment operator, or destructor.\nstatic void diagnoseDeprecatedCopyOperation(Sema &S, CXXMethodDecl *CopyOp) {\n  assert(CopyOp->isImplicit());\n\n  CXXRecordDecl *RD = CopyOp->getParent();\n  CXXMethodDecl *UserDeclaredOperation = nullptr;\n\n  // In Microsoft mode, assignment operations don't affect constructors and\n  // vice versa.\n  if (RD->hasUserDeclaredDestructor()) {\n    UserDeclaredOperation = RD->getDestructor();\n  } else if (!isa<CXXConstructorDecl>(CopyOp) &&\n             RD->hasUserDeclaredCopyConstructor() &&\n             !S.getLangOpts().MSVCCompat) {\n    // Find any user-declared copy constructor.\n    for (auto *I : RD->ctors()) {\n      if (I->isCopyConstructor()) {\n        UserDeclaredOperation = I;\n        break;\n      }\n    }\n    assert(UserDeclaredOperation);\n  } else if (isa<CXXConstructorDecl>(CopyOp) &&\n             RD->hasUserDeclaredCopyAssignment() &&\n             !S.getLangOpts().MSVCCompat) {\n    // Find any user-declared move assignment operator.\n    for (auto *I : RD->methods()) {\n      if (I->isCopyAssignmentOperator()) {\n        UserDeclaredOperation = I;\n        break;\n      }\n    }\n    assert(UserDeclaredOperation);\n  }\n\n  if (UserDeclaredOperation && UserDeclaredOperation->isUserProvided()) {\n    S.Diag(UserDeclaredOperation->getLocation(),\n           isa<CXXDestructorDecl>(UserDeclaredOperation)\n               ? diag::warn_deprecated_copy_dtor_operation\n               : diag::warn_deprecated_copy_operation)\n        << RD << /*copy assignment*/ !isa<CXXConstructorDecl>(CopyOp);\n  }\n}\n\nvoid Sema::DefineImplicitCopyAssignment(SourceLocation CurrentLocation,\n                                        CXXMethodDecl *CopyAssignOperator) {\n  assert((CopyAssignOperator->isDefaulted() &&\n          CopyAssignOperator->isOverloadedOperator() &&\n          CopyAssignOperator->getOverloadedOperator() == OO_Equal &&\n          !CopyAssignOperator->doesThisDeclarationHaveABody() &&\n          !CopyAssignOperator->isDeleted()) &&\n         \"DefineImplicitCopyAssignment called for wrong function\");\n  if (CopyAssignOperator->willHaveBody() || CopyAssignOperator->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = CopyAssignOperator->getParent();\n  if (ClassDecl->isInvalidDecl()) {\n    CopyAssignOperator->setInvalidDecl();\n    return;\n  }\n\n  SynthesizedFunctionScope Scope(*this, CopyAssignOperator);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       CopyAssignOperator->getType()->castAs<FunctionProtoType>());\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  // C++11 [class.copy]p18:\n  //   The [definition of an implicitly declared copy assignment operator] is\n  //   deprecated if the class has a user-declared copy constructor or a\n  //   user-declared destructor.\n  if (getLangOpts().CPlusPlus11 && CopyAssignOperator->isImplicit())\n    diagnoseDeprecatedCopyOperation(*this, CopyAssignOperator);\n\n  // C++0x [class.copy]p30:\n  //   The implicitly-defined or explicitly-defaulted copy assignment operator\n  //   for a non-union class X performs memberwise copy assignment of its\n  //   subobjects. The direct base classes of X are assigned first, in the\n  //   order of their declaration in the base-specifier-list, and then the\n  //   immediate non-static data members of X are assigned, in the order in\n  //   which they were declared in the class definition.\n\n  // The statements that form the synthesized function body.\n  SmallVector<Stmt*, 8> Statements;\n\n  // The parameter for the \"other\" object, which we are copying from.\n  ParmVarDecl *Other = CopyAssignOperator->getParamDecl(0);\n  Qualifiers OtherQuals = Other->getType().getQualifiers();\n  QualType OtherRefType = Other->getType();\n  if (const LValueReferenceType *OtherRef\n                                = OtherRefType->getAs<LValueReferenceType>()) {\n    OtherRefType = OtherRef->getPointeeType();\n    OtherQuals = OtherRefType.getQualifiers();\n  }\n\n  // Our location for everything implicitly-generated.\n  SourceLocation Loc = CopyAssignOperator->getEndLoc().isValid()\n                           ? CopyAssignOperator->getEndLoc()\n                           : CopyAssignOperator->getLocation();\n\n  // Builds a DeclRefExpr for the \"other\" object.\n  RefBuilder OtherRef(Other, OtherRefType);\n\n  // Builds the \"this\" pointer.\n  ThisBuilder This;\n\n  // Assign base classes.\n  bool Invalid = false;\n  for (auto &Base : ClassDecl->bases()) {\n    // Form the assignment:\n    //   static_cast<Base*>(this)->Base::operator=(static_cast<Base&>(other));\n    QualType BaseType = Base.getType().getUnqualifiedType();\n    if (!BaseType->isRecordType()) {\n      Invalid = true;\n      continue;\n    }\n\n    CXXCastPath BasePath;\n    BasePath.push_back(&Base);\n\n    // Construct the \"from\" expression, which is an implicit cast to the\n    // appropriately-qualified base type.\n    CastBuilder From(OtherRef, Context.getQualifiedType(BaseType, OtherQuals),\n                     VK_LValue, BasePath);\n\n    // Dereference \"this\".\n    DerefBuilder DerefThis(This);\n    CastBuilder To(DerefThis,\n                   Context.getQualifiedType(\n                       BaseType, CopyAssignOperator->getMethodQualifiers()),\n                   VK_LValue, BasePath);\n\n    // Build the copy.\n    StmtResult Copy = buildSingleCopyAssign(*this, Loc, BaseType,\n                                            To, From,\n                                            /*CopyingBaseSubobject=*/true,\n                                            /*Copying=*/true);\n    if (Copy.isInvalid()) {\n      CopyAssignOperator->setInvalidDecl();\n      return;\n    }\n\n    // Success! Record the copy.\n    Statements.push_back(Copy.getAs<Expr>());\n  }\n\n  // Assign non-static members.\n  for (auto *Field : ClassDecl->fields()) {\n    // FIXME: We should form some kind of AST representation for the implied\n    // memcpy in a union copy operation.\n    if (Field->isUnnamedBitfield() || Field->getParent()->isUnion())\n      continue;\n\n    if (Field->isInvalidDecl()) {\n      Invalid = true;\n      continue;\n    }\n\n    // Check for members of reference type; we can't copy those.\n    if (Field->getType()->isReferenceType()) {\n      Diag(ClassDecl->getLocation(), diag::err_uninitialized_member_for_assign)\n        << Context.getTagDeclType(ClassDecl) << 0 << Field->getDeclName();\n      Diag(Field->getLocation(), diag::note_declared_at);\n      Invalid = true;\n      continue;\n    }\n\n    // Check for members of const-qualified, non-class type.\n    QualType BaseType = Context.getBaseElementType(Field->getType());\n    if (!BaseType->getAs<RecordType>() && BaseType.isConstQualified()) {\n      Diag(ClassDecl->getLocation(), diag::err_uninitialized_member_for_assign)\n        << Context.getTagDeclType(ClassDecl) << 1 << Field->getDeclName();\n      Diag(Field->getLocation(), diag::note_declared_at);\n      Invalid = true;\n      continue;\n    }\n\n    // Suppress assigning zero-width bitfields.\n    if (Field->isZeroLengthBitField(Context))\n      continue;\n\n    QualType FieldType = Field->getType().getNonReferenceType();\n    if (FieldType->isIncompleteArrayType()) {\n      assert(ClassDecl->hasFlexibleArrayMember() &&\n             \"Incomplete array type is not valid\");\n      continue;\n    }\n\n    // Build references to the field in the object we're copying from and to.\n    CXXScopeSpec SS; // Intentionally empty\n    LookupResult MemberLookup(*this, Field->getDeclName(), Loc,\n                              LookupMemberName);\n    MemberLookup.addDecl(Field);\n    MemberLookup.resolveKind();\n\n    MemberBuilder From(OtherRef, OtherRefType, /*IsArrow=*/false, MemberLookup);\n\n    MemberBuilder To(This, getCurrentThisType(), /*IsArrow=*/true, MemberLookup);\n\n    // Build the copy of this field.\n    StmtResult Copy = buildSingleCopyAssign(*this, Loc, FieldType,\n                                            To, From,\n                                            /*CopyingBaseSubobject=*/false,\n                                            /*Copying=*/true);\n    if (Copy.isInvalid()) {\n      CopyAssignOperator->setInvalidDecl();\n      return;\n    }\n\n    // Success! Record the copy.\n    Statements.push_back(Copy.getAs<Stmt>());\n  }\n\n  if (!Invalid) {\n    // Add a \"return *this;\"\n    ExprResult ThisObj = CreateBuiltinUnaryOp(Loc, UO_Deref, This.build(*this, Loc));\n\n    StmtResult Return = BuildReturnStmt(Loc, ThisObj.get());\n    if (Return.isInvalid())\n      Invalid = true;\n    else\n      Statements.push_back(Return.getAs<Stmt>());\n  }\n\n  if (Invalid) {\n    CopyAssignOperator->setInvalidDecl();\n    return;\n  }\n\n  StmtResult Body;\n  {\n    CompoundScopeRAII CompoundScope(*this);\n    Body = ActOnCompoundStmt(Loc, Loc, Statements,\n                             /*isStmtExpr=*/false);\n    assert(!Body.isInvalid() && \"Compound statement creation cannot fail\");\n  }\n  CopyAssignOperator->setBody(Body.getAs<Stmt>());\n  CopyAssignOperator->markUsed(Context);\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(CopyAssignOperator);\n  }\n}\n\nCXXMethodDecl *Sema::DeclareImplicitMoveAssignment(CXXRecordDecl *ClassDecl) {\n  assert(ClassDecl->needsImplicitMoveAssignment());\n\n  DeclaringSpecialMember DSM(*this, ClassDecl, CXXMoveAssignment);\n  if (DSM.isAlreadyBeingDeclared())\n    return nullptr;\n\n  // Note: The following rules are largely analoguous to the move\n  // constructor rules.\n\n  QualType ArgType = Context.getTypeDeclType(ClassDecl);\n  LangAS AS = getDefaultCXXMethodAddrSpace();\n  if (AS != LangAS::Default)\n    ArgType = Context.getAddrSpaceQualType(ArgType, AS);\n  QualType RetType = Context.getLValueReferenceType(ArgType);\n  ArgType = Context.getRValueReferenceType(ArgType);\n\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,\n                                                     CXXMoveAssignment,\n                                                     false);\n\n  //   An implicitly-declared move assignment operator is an inline public\n  //   member of its class.\n  DeclarationName Name = Context.DeclarationNames.getCXXOperatorName(OO_Equal);\n  SourceLocation ClassLoc = ClassDecl->getLocation();\n  DeclarationNameInfo NameInfo(Name, ClassLoc);\n  CXXMethodDecl *MoveAssignment = CXXMethodDecl::Create(\n      Context, ClassDecl, ClassLoc, NameInfo, QualType(),\n      /*TInfo=*/nullptr, /*StorageClass=*/SC_None,\n      /*isInline=*/true,\n      Constexpr ? ConstexprSpecKind::Constexpr : ConstexprSpecKind::Unspecified,\n      SourceLocation());\n  MoveAssignment->setAccess(AS_public);\n  MoveAssignment->setDefaulted();\n  MoveAssignment->setImplicit();\n\n  if (getLangOpts().CUDA) {\n    inferCUDATargetForImplicitSpecialMember(ClassDecl, CXXMoveAssignment,\n                                            MoveAssignment,\n                                            /* ConstRHS */ false,\n                                            /* Diagnose */ false);\n  }\n\n  // Build an exception specification pointing back at this member.\n  FunctionProtoType::ExtProtoInfo EPI =\n      getImplicitMethodEPI(*this, MoveAssignment);\n  MoveAssignment->setType(Context.getFunctionType(RetType, ArgType, EPI));\n\n  // Add the parameter to the operator.\n  ParmVarDecl *FromParam = ParmVarDecl::Create(Context, MoveAssignment,\n                                               ClassLoc, ClassLoc,\n                                               /*Id=*/nullptr, ArgType,\n                                               /*TInfo=*/nullptr, SC_None,\n                                               nullptr);\n  MoveAssignment->setParams(FromParam);\n\n  MoveAssignment->setTrivial(\n    ClassDecl->needsOverloadResolutionForMoveAssignment()\n      ? SpecialMemberIsTrivial(MoveAssignment, CXXMoveAssignment)\n      : ClassDecl->hasTrivialMoveAssignment());\n\n  // Note that we have added this copy-assignment operator.\n  ++getASTContext().NumImplicitMoveAssignmentOperatorsDeclared;\n\n  Scope *S = getScopeForContext(ClassDecl);\n  CheckImplicitSpecialMemberDeclaration(S, MoveAssignment);\n\n  if (ShouldDeleteSpecialMember(MoveAssignment, CXXMoveAssignment)) {\n    ClassDecl->setImplicitMoveAssignmentIsDeleted();\n    SetDeclDeleted(MoveAssignment, ClassLoc);\n  }\n\n  if (S)\n    PushOnScopeChains(MoveAssignment, S, false);\n  ClassDecl->addDecl(MoveAssignment);\n\n  return MoveAssignment;\n}\n\n/// Check if we're implicitly defining a move assignment operator for a class\n/// with virtual bases. Such a move assignment might move-assign the virtual\n/// base multiple times.\nstatic void checkMoveAssignmentForRepeatedMove(Sema &S, CXXRecordDecl *Class,\n                                               SourceLocation CurrentLocation) {\n  assert(!Class->isDependentContext() && \"should not define dependent move\");\n\n  // Only a virtual base could get implicitly move-assigned multiple times.\n  // Only a non-trivial move assignment can observe this. We only want to\n  // diagnose if we implicitly define an assignment operator that assigns\n  // two base classes, both of which move-assign the same virtual base.\n  if (Class->getNumVBases() == 0 || Class->hasTrivialMoveAssignment() ||\n      Class->getNumBases() < 2)\n    return;\n\n  llvm::SmallVector<CXXBaseSpecifier *, 16> Worklist;\n  typedef llvm::DenseMap<CXXRecordDecl*, CXXBaseSpecifier*> VBaseMap;\n  VBaseMap VBases;\n\n  for (auto &BI : Class->bases()) {\n    Worklist.push_back(&BI);\n    while (!Worklist.empty()) {\n      CXXBaseSpecifier *BaseSpec = Worklist.pop_back_val();\n      CXXRecordDecl *Base = BaseSpec->getType()->getAsCXXRecordDecl();\n\n      // If the base has no non-trivial move assignment operators,\n      // we don't care about moves from it.\n      if (!Base->hasNonTrivialMoveAssignment())\n        continue;\n\n      // If there's nothing virtual here, skip it.\n      if (!BaseSpec->isVirtual() && !Base->getNumVBases())\n        continue;\n\n      // If we're not actually going to call a move assignment for this base,\n      // or the selected move assignment is trivial, skip it.\n      Sema::SpecialMemberOverloadResult SMOR =\n        S.LookupSpecialMember(Base, Sema::CXXMoveAssignment,\n                              /*ConstArg*/false, /*VolatileArg*/false,\n                              /*RValueThis*/true, /*ConstThis*/false,\n                              /*VolatileThis*/false);\n      if (!SMOR.getMethod() || SMOR.getMethod()->isTrivial() ||\n          !SMOR.getMethod()->isMoveAssignmentOperator())\n        continue;\n\n      if (BaseSpec->isVirtual()) {\n        // We're going to move-assign this virtual base, and its move\n        // assignment operator is not trivial. If this can happen for\n        // multiple distinct direct bases of Class, diagnose it. (If it\n        // only happens in one base, we'll diagnose it when synthesizing\n        // that base class's move assignment operator.)\n        CXXBaseSpecifier *&Existing =\n            VBases.insert(std::make_pair(Base->getCanonicalDecl(), &BI))\n                .first->second;\n        if (Existing && Existing != &BI) {\n          S.Diag(CurrentLocation, diag::warn_vbase_moved_multiple_times)\n            << Class << Base;\n          S.Diag(Existing->getBeginLoc(), diag::note_vbase_moved_here)\n              << (Base->getCanonicalDecl() ==\n                  Existing->getType()->getAsCXXRecordDecl()->getCanonicalDecl())\n              << Base << Existing->getType() << Existing->getSourceRange();\n          S.Diag(BI.getBeginLoc(), diag::note_vbase_moved_here)\n              << (Base->getCanonicalDecl() ==\n                  BI.getType()->getAsCXXRecordDecl()->getCanonicalDecl())\n              << Base << BI.getType() << BaseSpec->getSourceRange();\n\n          // Only diagnose each vbase once.\n          Existing = nullptr;\n        }\n      } else {\n        // Only walk over bases that have defaulted move assignment operators.\n        // We assume that any user-provided move assignment operator handles\n        // the multiple-moves-of-vbase case itself somehow.\n        if (!SMOR.getMethod()->isDefaulted())\n          continue;\n\n        // We're going to move the base classes of Base. Add them to the list.\n        for (auto &BI : Base->bases())\n          Worklist.push_back(&BI);\n      }\n    }\n  }\n}\n\nvoid Sema::DefineImplicitMoveAssignment(SourceLocation CurrentLocation,\n                                        CXXMethodDecl *MoveAssignOperator) {\n  assert((MoveAssignOperator->isDefaulted() &&\n          MoveAssignOperator->isOverloadedOperator() &&\n          MoveAssignOperator->getOverloadedOperator() == OO_Equal &&\n          !MoveAssignOperator->doesThisDeclarationHaveABody() &&\n          !MoveAssignOperator->isDeleted()) &&\n         \"DefineImplicitMoveAssignment called for wrong function\");\n  if (MoveAssignOperator->willHaveBody() || MoveAssignOperator->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = MoveAssignOperator->getParent();\n  if (ClassDecl->isInvalidDecl()) {\n    MoveAssignOperator->setInvalidDecl();\n    return;\n  }\n\n  // C++0x [class.copy]p28:\n  //   The implicitly-defined or move assignment operator for a non-union class\n  //   X performs memberwise move assignment of its subobjects. The direct base\n  //   classes of X are assigned first, in the order of their declaration in the\n  //   base-specifier-list, and then the immediate non-static data members of X\n  //   are assigned, in the order in which they were declared in the class\n  //   definition.\n\n  // Issue a warning if our implicit move assignment operator will move\n  // from a virtual base more than once.\n  checkMoveAssignmentForRepeatedMove(*this, ClassDecl, CurrentLocation);\n\n  SynthesizedFunctionScope Scope(*this, MoveAssignOperator);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       MoveAssignOperator->getType()->castAs<FunctionProtoType>());\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  // The statements that form the synthesized function body.\n  SmallVector<Stmt*, 8> Statements;\n\n  // The parameter for the \"other\" object, which we are move from.\n  ParmVarDecl *Other = MoveAssignOperator->getParamDecl(0);\n  QualType OtherRefType =\n      Other->getType()->castAs<RValueReferenceType>()->getPointeeType();\n\n  // Our location for everything implicitly-generated.\n  SourceLocation Loc = MoveAssignOperator->getEndLoc().isValid()\n                           ? MoveAssignOperator->getEndLoc()\n                           : MoveAssignOperator->getLocation();\n\n  // Builds a reference to the \"other\" object.\n  RefBuilder OtherRef(Other, OtherRefType);\n  // Cast to rvalue.\n  MoveCastBuilder MoveOther(OtherRef);\n\n  // Builds the \"this\" pointer.\n  ThisBuilder This;\n\n  // Assign base classes.\n  bool Invalid = false;\n  for (auto &Base : ClassDecl->bases()) {\n    // C++11 [class.copy]p28:\n    //   It is unspecified whether subobjects representing virtual base classes\n    //   are assigned more than once by the implicitly-defined copy assignment\n    //   operator.\n    // FIXME: Do not assign to a vbase that will be assigned by some other base\n    // class. For a move-assignment, this can result in the vbase being moved\n    // multiple times.\n\n    // Form the assignment:\n    //   static_cast<Base*>(this)->Base::operator=(static_cast<Base&&>(other));\n    QualType BaseType = Base.getType().getUnqualifiedType();\n    if (!BaseType->isRecordType()) {\n      Invalid = true;\n      continue;\n    }\n\n    CXXCastPath BasePath;\n    BasePath.push_back(&Base);\n\n    // Construct the \"from\" expression, which is an implicit cast to the\n    // appropriately-qualified base type.\n    CastBuilder From(OtherRef, BaseType, VK_XValue, BasePath);\n\n    // Dereference \"this\".\n    DerefBuilder DerefThis(This);\n\n    // Implicitly cast \"this\" to the appropriately-qualified base type.\n    CastBuilder To(DerefThis,\n                   Context.getQualifiedType(\n                       BaseType, MoveAssignOperator->getMethodQualifiers()),\n                   VK_LValue, BasePath);\n\n    // Build the move.\n    StmtResult Move = buildSingleCopyAssign(*this, Loc, BaseType,\n                                            To, From,\n                                            /*CopyingBaseSubobject=*/true,\n                                            /*Copying=*/false);\n    if (Move.isInvalid()) {\n      MoveAssignOperator->setInvalidDecl();\n      return;\n    }\n\n    // Success! Record the move.\n    Statements.push_back(Move.getAs<Expr>());\n  }\n\n  // Assign non-static members.\n  for (auto *Field : ClassDecl->fields()) {\n    // FIXME: We should form some kind of AST representation for the implied\n    // memcpy in a union copy operation.\n    if (Field->isUnnamedBitfield() || Field->getParent()->isUnion())\n      continue;\n\n    if (Field->isInvalidDecl()) {\n      Invalid = true;\n      continue;\n    }\n\n    // Check for members of reference type; we can't move those.\n    if (Field->getType()->isReferenceType()) {\n      Diag(ClassDecl->getLocation(), diag::err_uninitialized_member_for_assign)\n        << Context.getTagDeclType(ClassDecl) << 0 << Field->getDeclName();\n      Diag(Field->getLocation(), diag::note_declared_at);\n      Invalid = true;\n      continue;\n    }\n\n    // Check for members of const-qualified, non-class type.\n    QualType BaseType = Context.getBaseElementType(Field->getType());\n    if (!BaseType->getAs<RecordType>() && BaseType.isConstQualified()) {\n      Diag(ClassDecl->getLocation(), diag::err_uninitialized_member_for_assign)\n        << Context.getTagDeclType(ClassDecl) << 1 << Field->getDeclName();\n      Diag(Field->getLocation(), diag::note_declared_at);\n      Invalid = true;\n      continue;\n    }\n\n    // Suppress assigning zero-width bitfields.\n    if (Field->isZeroLengthBitField(Context))\n      continue;\n\n    QualType FieldType = Field->getType().getNonReferenceType();\n    if (FieldType->isIncompleteArrayType()) {\n      assert(ClassDecl->hasFlexibleArrayMember() &&\n             \"Incomplete array type is not valid\");\n      continue;\n    }\n\n    // Build references to the field in the object we're copying from and to.\n    LookupResult MemberLookup(*this, Field->getDeclName(), Loc,\n                              LookupMemberName);\n    MemberLookup.addDecl(Field);\n    MemberLookup.resolveKind();\n    MemberBuilder From(MoveOther, OtherRefType,\n                       /*IsArrow=*/false, MemberLookup);\n    MemberBuilder To(This, getCurrentThisType(),\n                     /*IsArrow=*/true, MemberLookup);\n\n    assert(!From.build(*this, Loc)->isLValue() && // could be xvalue or prvalue\n        \"Member reference with rvalue base must be rvalue except for reference \"\n        \"members, which aren't allowed for move assignment.\");\n\n    // Build the move of this field.\n    StmtResult Move = buildSingleCopyAssign(*this, Loc, FieldType,\n                                            To, From,\n                                            /*CopyingBaseSubobject=*/false,\n                                            /*Copying=*/false);\n    if (Move.isInvalid()) {\n      MoveAssignOperator->setInvalidDecl();\n      return;\n    }\n\n    // Success! Record the copy.\n    Statements.push_back(Move.getAs<Stmt>());\n  }\n\n  if (!Invalid) {\n    // Add a \"return *this;\"\n    ExprResult ThisObj =\n        CreateBuiltinUnaryOp(Loc, UO_Deref, This.build(*this, Loc));\n\n    StmtResult Return = BuildReturnStmt(Loc, ThisObj.get());\n    if (Return.isInvalid())\n      Invalid = true;\n    else\n      Statements.push_back(Return.getAs<Stmt>());\n  }\n\n  if (Invalid) {\n    MoveAssignOperator->setInvalidDecl();\n    return;\n  }\n\n  StmtResult Body;\n  {\n    CompoundScopeRAII CompoundScope(*this);\n    Body = ActOnCompoundStmt(Loc, Loc, Statements,\n                             /*isStmtExpr=*/false);\n    assert(!Body.isInvalid() && \"Compound statement creation cannot fail\");\n  }\n  MoveAssignOperator->setBody(Body.getAs<Stmt>());\n  MoveAssignOperator->markUsed(Context);\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(MoveAssignOperator);\n  }\n}\n\nCXXConstructorDecl *Sema::DeclareImplicitCopyConstructor(\n                                                    CXXRecordDecl *ClassDecl) {\n  // C++ [class.copy]p4:\n  //   If the class definition does not explicitly declare a copy\n  //   constructor, one is declared implicitly.\n  assert(ClassDecl->needsImplicitCopyConstructor());\n\n  DeclaringSpecialMember DSM(*this, ClassDecl, CXXCopyConstructor);\n  if (DSM.isAlreadyBeingDeclared())\n    return nullptr;\n\n  QualType ClassType = Context.getTypeDeclType(ClassDecl);\n  QualType ArgType = ClassType;\n  bool Const = ClassDecl->implicitCopyConstructorHasConstParam();\n  if (Const)\n    ArgType = ArgType.withConst();\n\n  LangAS AS = getDefaultCXXMethodAddrSpace();\n  if (AS != LangAS::Default)\n    ArgType = Context.getAddrSpaceQualType(ArgType, AS);\n\n  ArgType = Context.getLValueReferenceType(ArgType);\n\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,\n                                                     CXXCopyConstructor,\n                                                     Const);\n\n  DeclarationName Name\n    = Context.DeclarationNames.getCXXConstructorName(\n                                           Context.getCanonicalType(ClassType));\n  SourceLocation ClassLoc = ClassDecl->getLocation();\n  DeclarationNameInfo NameInfo(Name, ClassLoc);\n\n  //   An implicitly-declared copy constructor is an inline public\n  //   member of its class.\n  CXXConstructorDecl *CopyConstructor = CXXConstructorDecl::Create(\n      Context, ClassDecl, ClassLoc, NameInfo, QualType(), /*TInfo=*/nullptr,\n      ExplicitSpecifier(),\n      /*isInline=*/true,\n      /*isImplicitlyDeclared=*/true,\n      Constexpr ? ConstexprSpecKind::Constexpr\n                : ConstexprSpecKind::Unspecified);\n  CopyConstructor->setAccess(AS_public);\n  CopyConstructor->setDefaulted();\n\n  if (getLangOpts().CUDA) {\n    inferCUDATargetForImplicitSpecialMember(ClassDecl, CXXCopyConstructor,\n                                            CopyConstructor,\n                                            /* ConstRHS */ Const,\n                                            /* Diagnose */ false);\n  }\n\n  setupImplicitSpecialMemberType(CopyConstructor, Context.VoidTy, ArgType);\n\n  // Add the parameter to the constructor.\n  ParmVarDecl *FromParam = ParmVarDecl::Create(Context, CopyConstructor,\n                                               ClassLoc, ClassLoc,\n                                               /*IdentifierInfo=*/nullptr,\n                                               ArgType, /*TInfo=*/nullptr,\n                                               SC_None, nullptr);\n  CopyConstructor->setParams(FromParam);\n\n  CopyConstructor->setTrivial(\n      ClassDecl->needsOverloadResolutionForCopyConstructor()\n          ? SpecialMemberIsTrivial(CopyConstructor, CXXCopyConstructor)\n          : ClassDecl->hasTrivialCopyConstructor());\n\n  CopyConstructor->setTrivialForCall(\n      ClassDecl->hasAttr<TrivialABIAttr>() ||\n      (ClassDecl->needsOverloadResolutionForCopyConstructor()\n           ? SpecialMemberIsTrivial(CopyConstructor, CXXCopyConstructor,\n             TAH_ConsiderTrivialABI)\n           : ClassDecl->hasTrivialCopyConstructorForCall()));\n\n  // Note that we have declared this constructor.\n  ++getASTContext().NumImplicitCopyConstructorsDeclared;\n\n  Scope *S = getScopeForContext(ClassDecl);\n  CheckImplicitSpecialMemberDeclaration(S, CopyConstructor);\n\n  if (ShouldDeleteSpecialMember(CopyConstructor, CXXCopyConstructor)) {\n    ClassDecl->setImplicitCopyConstructorIsDeleted();\n    SetDeclDeleted(CopyConstructor, ClassLoc);\n  }\n\n  if (S)\n    PushOnScopeChains(CopyConstructor, S, false);\n  ClassDecl->addDecl(CopyConstructor);\n\n  return CopyConstructor;\n}\n\nvoid Sema::DefineImplicitCopyConstructor(SourceLocation CurrentLocation,\n                                         CXXConstructorDecl *CopyConstructor) {\n  assert((CopyConstructor->isDefaulted() &&\n          CopyConstructor->isCopyConstructor() &&\n          !CopyConstructor->doesThisDeclarationHaveABody() &&\n          !CopyConstructor->isDeleted()) &&\n         \"DefineImplicitCopyConstructor - call it for implicit copy ctor\");\n  if (CopyConstructor->willHaveBody() || CopyConstructor->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = CopyConstructor->getParent();\n  assert(ClassDecl && \"DefineImplicitCopyConstructor - invalid constructor\");\n\n  SynthesizedFunctionScope Scope(*this, CopyConstructor);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       CopyConstructor->getType()->castAs<FunctionProtoType>());\n  MarkVTableUsed(CurrentLocation, ClassDecl);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  // C++11 [class.copy]p7:\n  //   The [definition of an implicitly declared copy constructor] is\n  //   deprecated if the class has a user-declared copy assignment operator\n  //   or a user-declared destructor.\n  if (getLangOpts().CPlusPlus11 && CopyConstructor->isImplicit())\n    diagnoseDeprecatedCopyOperation(*this, CopyConstructor);\n\n  if (SetCtorInitializers(CopyConstructor, /*AnyErrors=*/false)) {\n    CopyConstructor->setInvalidDecl();\n  }  else {\n    SourceLocation Loc = CopyConstructor->getEndLoc().isValid()\n                             ? CopyConstructor->getEndLoc()\n                             : CopyConstructor->getLocation();\n    Sema::CompoundScopeRAII CompoundScope(*this);\n    CopyConstructor->setBody(\n        ActOnCompoundStmt(Loc, Loc, None, /*isStmtExpr=*/false).getAs<Stmt>());\n    CopyConstructor->markUsed(Context);\n  }\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(CopyConstructor);\n  }\n}\n\nCXXConstructorDecl *Sema::DeclareImplicitMoveConstructor(\n                                                    CXXRecordDecl *ClassDecl) {\n  assert(ClassDecl->needsImplicitMoveConstructor());\n\n  DeclaringSpecialMember DSM(*this, ClassDecl, CXXMoveConstructor);\n  if (DSM.isAlreadyBeingDeclared())\n    return nullptr;\n\n  QualType ClassType = Context.getTypeDeclType(ClassDecl);\n\n  QualType ArgType = ClassType;\n  LangAS AS = getDefaultCXXMethodAddrSpace();\n  if (AS != LangAS::Default)\n    ArgType = Context.getAddrSpaceQualType(ClassType, AS);\n  ArgType = Context.getRValueReferenceType(ArgType);\n\n  bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,\n                                                     CXXMoveConstructor,\n                                                     false);\n\n  DeclarationName Name\n    = Context.DeclarationNames.getCXXConstructorName(\n                                           Context.getCanonicalType(ClassType));\n  SourceLocation ClassLoc = ClassDecl->getLocation();\n  DeclarationNameInfo NameInfo(Name, ClassLoc);\n\n  // C++11 [class.copy]p11:\n  //   An implicitly-declared copy/move constructor is an inline public\n  //   member of its class.\n  CXXConstructorDecl *MoveConstructor = CXXConstructorDecl::Create(\n      Context, ClassDecl, ClassLoc, NameInfo, QualType(), /*TInfo=*/nullptr,\n      ExplicitSpecifier(),\n      /*isInline=*/true,\n      /*isImplicitlyDeclared=*/true,\n      Constexpr ? ConstexprSpecKind::Constexpr\n                : ConstexprSpecKind::Unspecified);\n  MoveConstructor->setAccess(AS_public);\n  MoveConstructor->setDefaulted();\n\n  if (getLangOpts().CUDA) {\n    inferCUDATargetForImplicitSpecialMember(ClassDecl, CXXMoveConstructor,\n                                            MoveConstructor,\n                                            /* ConstRHS */ false,\n                                            /* Diagnose */ false);\n  }\n\n  setupImplicitSpecialMemberType(MoveConstructor, Context.VoidTy, ArgType);\n\n  // Add the parameter to the constructor.\n  ParmVarDecl *FromParam = ParmVarDecl::Create(Context, MoveConstructor,\n                                               ClassLoc, ClassLoc,\n                                               /*IdentifierInfo=*/nullptr,\n                                               ArgType, /*TInfo=*/nullptr,\n                                               SC_None, nullptr);\n  MoveConstructor->setParams(FromParam);\n\n  MoveConstructor->setTrivial(\n      ClassDecl->needsOverloadResolutionForMoveConstructor()\n          ? SpecialMemberIsTrivial(MoveConstructor, CXXMoveConstructor)\n          : ClassDecl->hasTrivialMoveConstructor());\n\n  MoveConstructor->setTrivialForCall(\n      ClassDecl->hasAttr<TrivialABIAttr>() ||\n      (ClassDecl->needsOverloadResolutionForMoveConstructor()\n           ? SpecialMemberIsTrivial(MoveConstructor, CXXMoveConstructor,\n                                    TAH_ConsiderTrivialABI)\n           : ClassDecl->hasTrivialMoveConstructorForCall()));\n\n  // Note that we have declared this constructor.\n  ++getASTContext().NumImplicitMoveConstructorsDeclared;\n\n  Scope *S = getScopeForContext(ClassDecl);\n  CheckImplicitSpecialMemberDeclaration(S, MoveConstructor);\n\n  if (ShouldDeleteSpecialMember(MoveConstructor, CXXMoveConstructor)) {\n    ClassDecl->setImplicitMoveConstructorIsDeleted();\n    SetDeclDeleted(MoveConstructor, ClassLoc);\n  }\n\n  if (S)\n    PushOnScopeChains(MoveConstructor, S, false);\n  ClassDecl->addDecl(MoveConstructor);\n\n  return MoveConstructor;\n}\n\nvoid Sema::DefineImplicitMoveConstructor(SourceLocation CurrentLocation,\n                                         CXXConstructorDecl *MoveConstructor) {\n  assert((MoveConstructor->isDefaulted() &&\n          MoveConstructor->isMoveConstructor() &&\n          !MoveConstructor->doesThisDeclarationHaveABody() &&\n          !MoveConstructor->isDeleted()) &&\n         \"DefineImplicitMoveConstructor - call it for implicit move ctor\");\n  if (MoveConstructor->willHaveBody() || MoveConstructor->isInvalidDecl())\n    return;\n\n  CXXRecordDecl *ClassDecl = MoveConstructor->getParent();\n  assert(ClassDecl && \"DefineImplicitMoveConstructor - invalid constructor\");\n\n  SynthesizedFunctionScope Scope(*this, MoveConstructor);\n\n  // The exception specification is needed because we are defining the\n  // function.\n  ResolveExceptionSpec(CurrentLocation,\n                       MoveConstructor->getType()->castAs<FunctionProtoType>());\n  MarkVTableUsed(CurrentLocation, ClassDecl);\n\n  // Add a context note for diagnostics produced after this point.\n  Scope.addContextNote(CurrentLocation);\n\n  if (SetCtorInitializers(MoveConstructor, /*AnyErrors=*/false)) {\n    MoveConstructor->setInvalidDecl();\n  } else {\n    SourceLocation Loc = MoveConstructor->getEndLoc().isValid()\n                             ? MoveConstructor->getEndLoc()\n                             : MoveConstructor->getLocation();\n    Sema::CompoundScopeRAII CompoundScope(*this);\n    MoveConstructor->setBody(ActOnCompoundStmt(\n        Loc, Loc, None, /*isStmtExpr=*/ false).getAs<Stmt>());\n    MoveConstructor->markUsed(Context);\n  }\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(MoveConstructor);\n  }\n}\n\nbool Sema::isImplicitlyDeleted(FunctionDecl *FD) {\n  return FD->isDeleted() && FD->isDefaulted() && isa<CXXMethodDecl>(FD);\n}\n\nvoid Sema::DefineImplicitLambdaToFunctionPointerConversion(\n                            SourceLocation CurrentLocation,\n                            CXXConversionDecl *Conv) {\n  SynthesizedFunctionScope Scope(*this, Conv);\n  assert(!Conv->getReturnType()->isUndeducedType());\n\n  QualType ConvRT = Conv->getType()->getAs<FunctionType>()->getReturnType();\n  CallingConv CC =\n      ConvRT->getPointeeType()->getAs<FunctionType>()->getCallConv();\n\n  CXXRecordDecl *Lambda = Conv->getParent();\n  FunctionDecl *CallOp = Lambda->getLambdaCallOperator();\n  FunctionDecl *Invoker = Lambda->getLambdaStaticInvoker(CC);\n\n  if (auto *TemplateArgs = Conv->getTemplateSpecializationArgs()) {\n    CallOp = InstantiateFunctionDeclaration(\n        CallOp->getDescribedFunctionTemplate(), TemplateArgs, CurrentLocation);\n    if (!CallOp)\n      return;\n\n    Invoker = InstantiateFunctionDeclaration(\n        Invoker->getDescribedFunctionTemplate(), TemplateArgs, CurrentLocation);\n    if (!Invoker)\n      return;\n  }\n\n  if (CallOp->isInvalidDecl())\n    return;\n\n  // Mark the call operator referenced (and add to pending instantiations\n  // if necessary).\n  // For both the conversion and static-invoker template specializations\n  // we construct their body's in this function, so no need to add them\n  // to the PendingInstantiations.\n  MarkFunctionReferenced(CurrentLocation, CallOp);\n\n  // Fill in the __invoke function with a dummy implementation. IR generation\n  // will fill in the actual details. Update its type in case it contained\n  // an 'auto'.\n  Invoker->markUsed(Context);\n  Invoker->setReferenced();\n  Invoker->setType(Conv->getReturnType()->getPointeeType());\n  Invoker->setBody(new (Context) CompoundStmt(Conv->getLocation()));\n\n  // Construct the body of the conversion function { return __invoke; }.\n  Expr *FunctionRef = BuildDeclRefExpr(Invoker, Invoker->getType(),\n                                       VK_LValue, Conv->getLocation());\n  assert(FunctionRef && \"Can't refer to __invoke function?\");\n  Stmt *Return = BuildReturnStmt(Conv->getLocation(), FunctionRef).get();\n  Conv->setBody(CompoundStmt::Create(Context, Return, Conv->getLocation(),\n                                     Conv->getLocation()));\n  Conv->markUsed(Context);\n  Conv->setReferenced();\n\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(Conv);\n    L->CompletedImplicitDefinition(Invoker);\n  }\n}\n\n\n\nvoid Sema::DefineImplicitLambdaToBlockPointerConversion(\n       SourceLocation CurrentLocation,\n       CXXConversionDecl *Conv)\n{\n  assert(!Conv->getParent()->isGenericLambda());\n\n  SynthesizedFunctionScope Scope(*this, Conv);\n\n  // Copy-initialize the lambda object as needed to capture it.\n  Expr *This = ActOnCXXThis(CurrentLocation).get();\n  Expr *DerefThis =CreateBuiltinUnaryOp(CurrentLocation, UO_Deref, This).get();\n\n  ExprResult BuildBlock = BuildBlockForLambdaConversion(CurrentLocation,\n                                                        Conv->getLocation(),\n                                                        Conv, DerefThis);\n\n  // If we're not under ARC, make sure we still get the _Block_copy/autorelease\n  // behavior.  Note that only the general conversion function does this\n  // (since it's unusable otherwise); in the case where we inline the\n  // block literal, it has block literal lifetime semantics.\n  if (!BuildBlock.isInvalid() && !getLangOpts().ObjCAutoRefCount)\n    BuildBlock = ImplicitCastExpr::Create(\n        Context, BuildBlock.get()->getType(), CK_CopyAndAutoreleaseBlockObject,\n        BuildBlock.get(), nullptr, VK_RValue, FPOptionsOverride());\n\n  if (BuildBlock.isInvalid()) {\n    Diag(CurrentLocation, diag::note_lambda_to_block_conv);\n    Conv->setInvalidDecl();\n    return;\n  }\n\n  // Create the return statement that returns the block from the conversion\n  // function.\n  StmtResult Return = BuildReturnStmt(Conv->getLocation(), BuildBlock.get());\n  if (Return.isInvalid()) {\n    Diag(CurrentLocation, diag::note_lambda_to_block_conv);\n    Conv->setInvalidDecl();\n    return;\n  }\n\n  // Set the body of the conversion function.\n  Stmt *ReturnS = Return.get();\n  Conv->setBody(CompoundStmt::Create(Context, ReturnS, Conv->getLocation(),\n                                     Conv->getLocation()));\n  Conv->markUsed(Context);\n\n  // We're done; notify the mutation listener, if any.\n  if (ASTMutationListener *L = getASTMutationListener()) {\n    L->CompletedImplicitDefinition(Conv);\n  }\n}\n\n/// Determine whether the given list arguments contains exactly one\n/// \"real\" (non-default) argument.\nstatic bool hasOneRealArgument(MultiExprArg Args) {\n  switch (Args.size()) {\n  case 0:\n    return false;\n\n  default:\n    if (!Args[1]->isDefaultArgument())\n      return false;\n\n    LLVM_FALLTHROUGH;\n  case 1:\n    return !Args[0]->isDefaultArgument();\n  }\n\n  return false;\n}\n\nExprResult\nSema::BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                            NamedDecl *FoundDecl,\n                            CXXConstructorDecl *Constructor,\n                            MultiExprArg ExprArgs,\n                            bool HadMultipleCandidates,\n                            bool IsListInitialization,\n                            bool IsStdInitListInitialization,\n                            bool RequiresZeroInit,\n                            unsigned ConstructKind,\n                            SourceRange ParenRange) {\n  bool Elidable = false;\n\n  // C++0x [class.copy]p34:\n  //   When certain criteria are met, an implementation is allowed to\n  //   omit the copy/move construction of a class object, even if the\n  //   copy/move constructor and/or destructor for the object have\n  //   side effects. [...]\n  //     - when a temporary class object that has not been bound to a\n  //       reference (12.2) would be copied/moved to a class object\n  //       with the same cv-unqualified type, the copy/move operation\n  //       can be omitted by constructing the temporary object\n  //       directly into the target of the omitted copy/move\n  if (ConstructKind == CXXConstructExpr::CK_Complete && Constructor &&\n      Constructor->isCopyOrMoveConstructor() && hasOneRealArgument(ExprArgs)) {\n    Expr *SubExpr = ExprArgs[0];\n    Elidable = SubExpr->isTemporaryObject(\n        Context, cast<CXXRecordDecl>(FoundDecl->getDeclContext()));\n  }\n\n  return BuildCXXConstructExpr(ConstructLoc, DeclInitType,\n                               FoundDecl, Constructor,\n                               Elidable, ExprArgs, HadMultipleCandidates,\n                               IsListInitialization,\n                               IsStdInitListInitialization, RequiresZeroInit,\n                               ConstructKind, ParenRange);\n}\n\nExprResult\nSema::BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                            NamedDecl *FoundDecl,\n                            CXXConstructorDecl *Constructor,\n                            bool Elidable,\n                            MultiExprArg ExprArgs,\n                            bool HadMultipleCandidates,\n                            bool IsListInitialization,\n                            bool IsStdInitListInitialization,\n                            bool RequiresZeroInit,\n                            unsigned ConstructKind,\n                            SourceRange ParenRange) {\n  if (auto *Shadow = dyn_cast<ConstructorUsingShadowDecl>(FoundDecl)) {\n    Constructor = findInheritingConstructor(ConstructLoc, Constructor, Shadow);\n    if (DiagnoseUseOfDecl(Constructor, ConstructLoc))\n      return ExprError();\n  }\n\n  return BuildCXXConstructExpr(\n      ConstructLoc, DeclInitType, Constructor, Elidable, ExprArgs,\n      HadMultipleCandidates, IsListInitialization, IsStdInitListInitialization,\n      RequiresZeroInit, ConstructKind, ParenRange);\n}\n\n/// BuildCXXConstructExpr - Creates a complete call to a constructor,\n/// including handling of its default argument expressions.\nExprResult\nSema::BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                            CXXConstructorDecl *Constructor,\n                            bool Elidable,\n                            MultiExprArg ExprArgs,\n                            bool HadMultipleCandidates,\n                            bool IsListInitialization,\n                            bool IsStdInitListInitialization,\n                            bool RequiresZeroInit,\n                            unsigned ConstructKind,\n                            SourceRange ParenRange) {\n  assert(declaresSameEntity(\n             Constructor->getParent(),\n             DeclInitType->getBaseElementTypeUnsafe()->getAsCXXRecordDecl()) &&\n         \"given constructor for wrong type\");\n  MarkFunctionReferenced(ConstructLoc, Constructor);\n  if (getLangOpts().CUDA && !CheckCUDACall(ConstructLoc, Constructor))\n    return ExprError();\n  if (getLangOpts().SYCLIsDevice &&\n      !checkSYCLDeviceFunction(ConstructLoc, Constructor))\n    return ExprError();\n\n  return CheckForImmediateInvocation(\n      CXXConstructExpr::Create(\n          Context, DeclInitType, ConstructLoc, Constructor, Elidable, ExprArgs,\n          HadMultipleCandidates, IsListInitialization,\n          IsStdInitListInitialization, RequiresZeroInit,\n          static_cast<CXXConstructExpr::ConstructionKind>(ConstructKind),\n          ParenRange),\n      Constructor);\n}\n\nExprResult Sema::BuildCXXDefaultInitExpr(SourceLocation Loc, FieldDecl *Field) {\n  assert(Field->hasInClassInitializer());\n\n  // If we already have the in-class initializer nothing needs to be done.\n  if (Field->getInClassInitializer())\n    return CXXDefaultInitExpr::Create(Context, Loc, Field, CurContext);\n\n  // If we might have already tried and failed to instantiate, don't try again.\n  if (Field->isInvalidDecl())\n    return ExprError();\n\n  // Maybe we haven't instantiated the in-class initializer. Go check the\n  // pattern FieldDecl to see if it has one.\n  CXXRecordDecl *ParentRD = cast<CXXRecordDecl>(Field->getParent());\n\n  if (isTemplateInstantiation(ParentRD->getTemplateSpecializationKind())) {\n    CXXRecordDecl *ClassPattern = ParentRD->getTemplateInstantiationPattern();\n    DeclContext::lookup_result Lookup =\n        ClassPattern->lookup(Field->getDeclName());\n\n    FieldDecl *Pattern = nullptr;\n    for (auto L : Lookup) {\n      if (isa<FieldDecl>(L)) {\n        Pattern = cast<FieldDecl>(L);\n        break;\n      }\n    }\n    assert(Pattern && \"We must have set the Pattern!\");\n\n    if (!Pattern->hasInClassInitializer() ||\n        InstantiateInClassInitializer(Loc, Field, Pattern,\n                                      getTemplateInstantiationArgs(Field))) {\n      // Don't diagnose this again.\n      Field->setInvalidDecl();\n      return ExprError();\n    }\n    return CXXDefaultInitExpr::Create(Context, Loc, Field, CurContext);\n  }\n\n  // DR1351:\n  //   If the brace-or-equal-initializer of a non-static data member\n  //   invokes a defaulted default constructor of its class or of an\n  //   enclosing class in a potentially evaluated subexpression, the\n  //   program is ill-formed.\n  //\n  // This resolution is unworkable: the exception specification of the\n  // default constructor can be needed in an unevaluated context, in\n  // particular, in the operand of a noexcept-expression, and we can be\n  // unable to compute an exception specification for an enclosed class.\n  //\n  // Any attempt to resolve the exception specification of a defaulted default\n  // constructor before the initializer is lexically complete will ultimately\n  // come here at which point we can diagnose it.\n  RecordDecl *OutermostClass = ParentRD->getOuterLexicalRecordContext();\n  Diag(Loc, diag::err_default_member_initializer_not_yet_parsed)\n      << OutermostClass << Field;\n  Diag(Field->getEndLoc(),\n       diag::note_default_member_initializer_not_yet_parsed);\n  // Recover by marking the field invalid, unless we're in a SFINAE context.\n  if (!isSFINAEContext())\n    Field->setInvalidDecl();\n  return ExprError();\n}\n\nvoid Sema::FinalizeVarWithDestructor(VarDecl *VD, const RecordType *Record) {\n  if (VD->isInvalidDecl()) return;\n  // If initializing the variable failed, don't also diagnose problems with\n  // the desctructor, they're likely related.\n  if (VD->getInit() && VD->getInit()->containsErrors())\n    return;\n\n  CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(Record->getDecl());\n  if (ClassDecl->isInvalidDecl()) return;\n  if (ClassDecl->hasIrrelevantDestructor()) return;\n  if (ClassDecl->isDependentContext()) return;\n\n  if (VD->isNoDestroy(getASTContext()))\n    return;\n\n  CXXDestructorDecl *Destructor = LookupDestructor(ClassDecl);\n\n  // If this is an array, we'll require the destructor during initialization, so\n  // we can skip over this. We still want to emit exit-time destructor warnings\n  // though.\n  if (!VD->getType()->isArrayType()) {\n    MarkFunctionReferenced(VD->getLocation(), Destructor);\n    CheckDestructorAccess(VD->getLocation(), Destructor,\n                          PDiag(diag::err_access_dtor_var)\n                              << VD->getDeclName() << VD->getType());\n    DiagnoseUseOfDecl(Destructor, VD->getLocation());\n  }\n\n  if (Destructor->isTrivial()) return;\n\n  // If the destructor is constexpr, check whether the variable has constant\n  // destruction now.\n  if (Destructor->isConstexpr()) {\n    bool HasConstantInit = false;\n    if (VD->getInit() && !VD->getInit()->isValueDependent())\n      HasConstantInit = VD->evaluateValue();\n    SmallVector<PartialDiagnosticAt, 8> Notes;\n    if (!VD->evaluateDestruction(Notes) && VD->isConstexpr() &&\n        HasConstantInit) {\n      Diag(VD->getLocation(),\n           diag::err_constexpr_var_requires_const_destruction) << VD;\n      for (unsigned I = 0, N = Notes.size(); I != N; ++I)\n        Diag(Notes[I].first, Notes[I].second);\n    }\n  }\n\n  if (!VD->hasGlobalStorage()) return;\n\n  // Emit warning for non-trivial dtor in global scope (a real global,\n  // class-static, function-static).\n  Diag(VD->getLocation(), diag::warn_exit_time_destructor);\n\n  // TODO: this should be re-enabled for static locals by !CXAAtExit\n  if (!VD->isStaticLocal())\n    Diag(VD->getLocation(), diag::warn_global_destructor);\n}\n\n/// Given a constructor and the set of arguments provided for the\n/// constructor, convert the arguments and add any required default arguments\n/// to form a proper call to this constructor.\n///\n/// \\returns true if an error occurred, false otherwise.\nbool Sema::CompleteConstructorCall(CXXConstructorDecl *Constructor,\n                                   QualType DeclInitType, MultiExprArg ArgsPtr,\n                                   SourceLocation Loc,\n                                   SmallVectorImpl<Expr *> &ConvertedArgs,\n                                   bool AllowExplicit,\n                                   bool IsListInitialization) {\n  // FIXME: This duplicates a lot of code from Sema::ConvertArgumentsForCall.\n  unsigned NumArgs = ArgsPtr.size();\n  Expr **Args = ArgsPtr.data();\n\n  const auto *Proto = Constructor->getType()->castAs<FunctionProtoType>();\n  unsigned NumParams = Proto->getNumParams();\n\n  // If too few arguments are available, we'll fill in the rest with defaults.\n  if (NumArgs < NumParams)\n    ConvertedArgs.reserve(NumParams);\n  else\n    ConvertedArgs.reserve(NumArgs);\n\n  VariadicCallType CallType =\n    Proto->isVariadic() ? VariadicConstructor : VariadicDoesNotApply;\n  SmallVector<Expr *, 8> AllArgs;\n  bool Invalid = GatherArgumentsForCall(Loc, Constructor,\n                                        Proto, 0,\n                                        llvm::makeArrayRef(Args, NumArgs),\n                                        AllArgs,\n                                        CallType, AllowExplicit,\n                                        IsListInitialization);\n  ConvertedArgs.append(AllArgs.begin(), AllArgs.end());\n\n  DiagnoseSentinelCalls(Constructor, Loc, AllArgs);\n\n  CheckConstructorCall(Constructor, DeclInitType,\n                       llvm::makeArrayRef(AllArgs.data(), AllArgs.size()),\n                       Proto, Loc);\n\n  return Invalid;\n}\n\nstatic inline bool\nCheckOperatorNewDeleteDeclarationScope(Sema &SemaRef,\n                                       const FunctionDecl *FnDecl) {\n  const DeclContext *DC = FnDecl->getDeclContext()->getRedeclContext();\n  if (isa<NamespaceDecl>(DC)) {\n    return SemaRef.Diag(FnDecl->getLocation(),\n                        diag::err_operator_new_delete_declared_in_namespace)\n      << FnDecl->getDeclName();\n  }\n\n  if (isa<TranslationUnitDecl>(DC) &&\n      FnDecl->getStorageClass() == SC_Static) {\n    return SemaRef.Diag(FnDecl->getLocation(),\n                        diag::err_operator_new_delete_declared_static)\n      << FnDecl->getDeclName();\n  }\n\n  return false;\n}\n\nstatic CanQualType RemoveAddressSpaceFromPtr(Sema &SemaRef,\n                                             const PointerType *PtrTy) {\n  auto &Ctx = SemaRef.Context;\n  Qualifiers PtrQuals = PtrTy->getPointeeType().getQualifiers();\n  PtrQuals.removeAddressSpace();\n  return Ctx.getPointerType(Ctx.getCanonicalType(Ctx.getQualifiedType(\n      PtrTy->getPointeeType().getUnqualifiedType(), PtrQuals)));\n}\n\nstatic inline bool\nCheckOperatorNewDeleteTypes(Sema &SemaRef, const FunctionDecl *FnDecl,\n                            CanQualType ExpectedResultType,\n                            CanQualType ExpectedFirstParamType,\n                            unsigned DependentParamTypeDiag,\n                            unsigned InvalidParamTypeDiag) {\n  QualType ResultType =\n      FnDecl->getType()->castAs<FunctionType>()->getReturnType();\n\n  if (SemaRef.getLangOpts().OpenCLCPlusPlus) {\n    // The operator is valid on any address space for OpenCL.\n    // Drop address space from actual and expected result types.\n    if (const auto *PtrTy = ResultType->getAs<PointerType>())\n      ResultType = RemoveAddressSpaceFromPtr(SemaRef, PtrTy);\n\n    if (auto ExpectedPtrTy = ExpectedResultType->getAs<PointerType>())\n      ExpectedResultType = RemoveAddressSpaceFromPtr(SemaRef, ExpectedPtrTy);\n  }\n\n  // Check that the result type is what we expect.\n  if (SemaRef.Context.getCanonicalType(ResultType) != ExpectedResultType) {\n    // Reject even if the type is dependent; an operator delete function is\n    // required to have a non-dependent result type.\n    return SemaRef.Diag(\n               FnDecl->getLocation(),\n               ResultType->isDependentType()\n                   ? diag::err_operator_new_delete_dependent_result_type\n                   : diag::err_operator_new_delete_invalid_result_type)\n           << FnDecl->getDeclName() << ExpectedResultType;\n  }\n\n  // A function template must have at least 2 parameters.\n  if (FnDecl->getDescribedFunctionTemplate() && FnDecl->getNumParams() < 2)\n    return SemaRef.Diag(FnDecl->getLocation(),\n                      diag::err_operator_new_delete_template_too_few_parameters)\n        << FnDecl->getDeclName();\n\n  // The function decl must have at least 1 parameter.\n  if (FnDecl->getNumParams() == 0)\n    return SemaRef.Diag(FnDecl->getLocation(),\n                        diag::err_operator_new_delete_too_few_parameters)\n      << FnDecl->getDeclName();\n\n  QualType FirstParamType = FnDecl->getParamDecl(0)->getType();\n  if (SemaRef.getLangOpts().OpenCLCPlusPlus) {\n    // The operator is valid on any address space for OpenCL.\n    // Drop address space from actual and expected first parameter types.\n    if (const auto *PtrTy =\n            FnDecl->getParamDecl(0)->getType()->getAs<PointerType>())\n      FirstParamType = RemoveAddressSpaceFromPtr(SemaRef, PtrTy);\n\n    if (auto ExpectedPtrTy = ExpectedFirstParamType->getAs<PointerType>())\n      ExpectedFirstParamType =\n          RemoveAddressSpaceFromPtr(SemaRef, ExpectedPtrTy);\n  }\n\n  // Check that the first parameter type is what we expect.\n  if (SemaRef.Context.getCanonicalType(FirstParamType).getUnqualifiedType() !=\n      ExpectedFirstParamType) {\n    // The first parameter type is not allowed to be dependent. As a tentative\n    // DR resolution, we allow a dependent parameter type if it is the right\n    // type anyway, to allow destroying operator delete in class templates.\n    return SemaRef.Diag(FnDecl->getLocation(), FirstParamType->isDependentType()\n                                                   ? DependentParamTypeDiag\n                                                   : InvalidParamTypeDiag)\n           << FnDecl->getDeclName() << ExpectedFirstParamType;\n  }\n\n  return false;\n}\n\nstatic bool\nCheckOperatorNewDeclaration(Sema &SemaRef, const FunctionDecl *FnDecl) {\n  // C++ [basic.stc.dynamic.allocation]p1:\n  //   A program is ill-formed if an allocation function is declared in a\n  //   namespace scope other than global scope or declared static in global\n  //   scope.\n  if (CheckOperatorNewDeleteDeclarationScope(SemaRef, FnDecl))\n    return true;\n\n  CanQualType SizeTy =\n    SemaRef.Context.getCanonicalType(SemaRef.Context.getSizeType());\n\n  // C++ [basic.stc.dynamic.allocation]p1:\n  //  The return type shall be void*. The first parameter shall have type\n  //  std::size_t.\n  if (CheckOperatorNewDeleteTypes(SemaRef, FnDecl, SemaRef.Context.VoidPtrTy,\n                                  SizeTy,\n                                  diag::err_operator_new_dependent_param_type,\n                                  diag::err_operator_new_param_type))\n    return true;\n\n  // C++ [basic.stc.dynamic.allocation]p1:\n  //  The first parameter shall not have an associated default argument.\n  if (FnDecl->getParamDecl(0)->hasDefaultArg())\n    return SemaRef.Diag(FnDecl->getLocation(),\n                        diag::err_operator_new_default_arg)\n      << FnDecl->getDeclName() << FnDecl->getParamDecl(0)->getDefaultArgRange();\n\n  return false;\n}\n\nstatic bool\nCheckOperatorDeleteDeclaration(Sema &SemaRef, FunctionDecl *FnDecl) {\n  // C++ [basic.stc.dynamic.deallocation]p1:\n  //   A program is ill-formed if deallocation functions are declared in a\n  //   namespace scope other than global scope or declared static in global\n  //   scope.\n  if (CheckOperatorNewDeleteDeclarationScope(SemaRef, FnDecl))\n    return true;\n\n  auto *MD = dyn_cast<CXXMethodDecl>(FnDecl);\n\n  // C++ P0722:\n  //   Within a class C, the first parameter of a destroying operator delete\n  //   shall be of type C *. The first parameter of any other deallocation\n  //   function shall be of type void *.\n  CanQualType ExpectedFirstParamType =\n      MD && MD->isDestroyingOperatorDelete()\n          ? SemaRef.Context.getCanonicalType(SemaRef.Context.getPointerType(\n                SemaRef.Context.getRecordType(MD->getParent())))\n          : SemaRef.Context.VoidPtrTy;\n\n  // C++ [basic.stc.dynamic.deallocation]p2:\n  //   Each deallocation function shall return void\n  if (CheckOperatorNewDeleteTypes(\n          SemaRef, FnDecl, SemaRef.Context.VoidTy, ExpectedFirstParamType,\n          diag::err_operator_delete_dependent_param_type,\n          diag::err_operator_delete_param_type))\n    return true;\n\n  // C++ P0722:\n  //   A destroying operator delete shall be a usual deallocation function.\n  if (MD && !MD->getParent()->isDependentContext() &&\n      MD->isDestroyingOperatorDelete() &&\n      !SemaRef.isUsualDeallocationFunction(MD)) {\n    SemaRef.Diag(MD->getLocation(),\n                 diag::err_destroying_operator_delete_not_usual);\n    return true;\n  }\n\n  return false;\n}\n\n/// CheckOverloadedOperatorDeclaration - Check whether the declaration\n/// of this overloaded operator is well-formed. If so, returns false;\n/// otherwise, emits appropriate diagnostics and returns true.\nbool Sema::CheckOverloadedOperatorDeclaration(FunctionDecl *FnDecl) {\n  assert(FnDecl && FnDecl->isOverloadedOperator() &&\n         \"Expected an overloaded operator declaration\");\n\n  OverloadedOperatorKind Op = FnDecl->getOverloadedOperator();\n\n  // C++ [over.oper]p5:\n  //   The allocation and deallocation functions, operator new,\n  //   operator new[], operator delete and operator delete[], are\n  //   described completely in 3.7.3. The attributes and restrictions\n  //   found in the rest of this subclause do not apply to them unless\n  //   explicitly stated in 3.7.3.\n  if (Op == OO_Delete || Op == OO_Array_Delete)\n    return CheckOperatorDeleteDeclaration(*this, FnDecl);\n\n  if (Op == OO_New || Op == OO_Array_New)\n    return CheckOperatorNewDeclaration(*this, FnDecl);\n\n  // C++ [over.oper]p6:\n  //   An operator function shall either be a non-static member\n  //   function or be a non-member function and have at least one\n  //   parameter whose type is a class, a reference to a class, an\n  //   enumeration, or a reference to an enumeration.\n  if (CXXMethodDecl *MethodDecl = dyn_cast<CXXMethodDecl>(FnDecl)) {\n    if (MethodDecl->isStatic())\n      return Diag(FnDecl->getLocation(),\n                  diag::err_operator_overload_static) << FnDecl->getDeclName();\n  } else {\n    bool ClassOrEnumParam = false;\n    for (auto Param : FnDecl->parameters()) {\n      QualType ParamType = Param->getType().getNonReferenceType();\n      if (ParamType->isDependentType() || ParamType->isRecordType() ||\n          ParamType->isEnumeralType()) {\n        ClassOrEnumParam = true;\n        break;\n      }\n    }\n\n    if (!ClassOrEnumParam)\n      return Diag(FnDecl->getLocation(),\n                  diag::err_operator_overload_needs_class_or_enum)\n        << FnDecl->getDeclName();\n  }\n\n  // C++ [over.oper]p8:\n  //   An operator function cannot have default arguments (8.3.6),\n  //   except where explicitly stated below.\n  //\n  // Only the function-call operator allows default arguments\n  // (C++ [over.call]p1).\n  if (Op != OO_Call) {\n    for (auto Param : FnDecl->parameters()) {\n      if (Param->hasDefaultArg())\n        return Diag(Param->getLocation(),\n                    diag::err_operator_overload_default_arg)\n          << FnDecl->getDeclName() << Param->getDefaultArgRange();\n    }\n  }\n\n  static const bool OperatorUses[NUM_OVERLOADED_OPERATORS][3] = {\n    { false, false, false }\n#define OVERLOADED_OPERATOR(Name,Spelling,Token,Unary,Binary,MemberOnly) \\\n    , { Unary, Binary, MemberOnly }\n#include \"clang/Basic/OperatorKinds.def\"\n  };\n\n  bool CanBeUnaryOperator = OperatorUses[Op][0];\n  bool CanBeBinaryOperator = OperatorUses[Op][1];\n  bool MustBeMemberOperator = OperatorUses[Op][2];\n\n  // C++ [over.oper]p8:\n  //   [...] Operator functions cannot have more or fewer parameters\n  //   than the number required for the corresponding operator, as\n  //   described in the rest of this subclause.\n  unsigned NumParams = FnDecl->getNumParams()\n                     + (isa<CXXMethodDecl>(FnDecl)? 1 : 0);\n  if (Op != OO_Call &&\n      ((NumParams == 1 && !CanBeUnaryOperator) ||\n       (NumParams == 2 && !CanBeBinaryOperator) ||\n       (NumParams < 1) || (NumParams > 2))) {\n    // We have the wrong number of parameters.\n    unsigned ErrorKind;\n    if (CanBeUnaryOperator && CanBeBinaryOperator) {\n      ErrorKind = 2;  // 2 -> unary or binary.\n    } else if (CanBeUnaryOperator) {\n      ErrorKind = 0;  // 0 -> unary\n    } else {\n      assert(CanBeBinaryOperator &&\n             \"All non-call overloaded operators are unary or binary!\");\n      ErrorKind = 1;  // 1 -> binary\n    }\n\n    return Diag(FnDecl->getLocation(), diag::err_operator_overload_must_be)\n      << FnDecl->getDeclName() << NumParams << ErrorKind;\n  }\n\n  // Overloaded operators other than operator() cannot be variadic.\n  if (Op != OO_Call &&\n      FnDecl->getType()->castAs<FunctionProtoType>()->isVariadic()) {\n    return Diag(FnDecl->getLocation(), diag::err_operator_overload_variadic)\n      << FnDecl->getDeclName();\n  }\n\n  // Some operators must be non-static member functions.\n  if (MustBeMemberOperator && !isa<CXXMethodDecl>(FnDecl)) {\n    return Diag(FnDecl->getLocation(),\n                diag::err_operator_overload_must_be_member)\n      << FnDecl->getDeclName();\n  }\n\n  // C++ [over.inc]p1:\n  //   The user-defined function called operator++ implements the\n  //   prefix and postfix ++ operator. If this function is a member\n  //   function with no parameters, or a non-member function with one\n  //   parameter of class or enumeration type, it defines the prefix\n  //   increment operator ++ for objects of that type. If the function\n  //   is a member function with one parameter (which shall be of type\n  //   int) or a non-member function with two parameters (the second\n  //   of which shall be of type int), it defines the postfix\n  //   increment operator ++ for objects of that type.\n  if ((Op == OO_PlusPlus || Op == OO_MinusMinus) && NumParams == 2) {\n    ParmVarDecl *LastParam = FnDecl->getParamDecl(FnDecl->getNumParams() - 1);\n    QualType ParamType = LastParam->getType();\n\n    if (!ParamType->isSpecificBuiltinType(BuiltinType::Int) &&\n        !ParamType->isDependentType())\n      return Diag(LastParam->getLocation(),\n                  diag::err_operator_overload_post_incdec_must_be_int)\n        << LastParam->getType() << (Op == OO_MinusMinus);\n  }\n\n  return false;\n}\n\nstatic bool\ncheckLiteralOperatorTemplateParameterList(Sema &SemaRef,\n                                          FunctionTemplateDecl *TpDecl) {\n  TemplateParameterList *TemplateParams = TpDecl->getTemplateParameters();\n\n  // Must have one or two template parameters.\n  if (TemplateParams->size() == 1) {\n    NonTypeTemplateParmDecl *PmDecl =\n        dyn_cast<NonTypeTemplateParmDecl>(TemplateParams->getParam(0));\n\n    // The template parameter must be a char parameter pack.\n    if (PmDecl && PmDecl->isTemplateParameterPack() &&\n        SemaRef.Context.hasSameType(PmDecl->getType(), SemaRef.Context.CharTy))\n      return false;\n\n    // C++20 [over.literal]p5:\n    //   A string literal operator template is a literal operator template\n    //   whose template-parameter-list comprises a single non-type\n    //   template-parameter of class type.\n    //\n    // As a DR resolution, we also allow placeholders for deduced class\n    // template specializations.\n    if (SemaRef.getLangOpts().CPlusPlus20 &&\n        !PmDecl->isTemplateParameterPack() &&\n        (PmDecl->getType()->isRecordType() ||\n         PmDecl->getType()->getAs<DeducedTemplateSpecializationType>()))\n      return false;\n  } else if (TemplateParams->size() == 2) {\n    TemplateTypeParmDecl *PmType =\n        dyn_cast<TemplateTypeParmDecl>(TemplateParams->getParam(0));\n    NonTypeTemplateParmDecl *PmArgs =\n        dyn_cast<NonTypeTemplateParmDecl>(TemplateParams->getParam(1));\n\n    // The second template parameter must be a parameter pack with the\n    // first template parameter as its type.\n    if (PmType && PmArgs && !PmType->isTemplateParameterPack() &&\n        PmArgs->isTemplateParameterPack()) {\n      const TemplateTypeParmType *TArgs =\n          PmArgs->getType()->getAs<TemplateTypeParmType>();\n      if (TArgs && TArgs->getDepth() == PmType->getDepth() &&\n          TArgs->getIndex() == PmType->getIndex()) {\n        if (!SemaRef.inTemplateInstantiation())\n          SemaRef.Diag(TpDecl->getLocation(),\n                       diag::ext_string_literal_operator_template);\n        return false;\n      }\n    }\n  }\n\n  SemaRef.Diag(TpDecl->getTemplateParameters()->getSourceRange().getBegin(),\n               diag::err_literal_operator_template)\n      << TpDecl->getTemplateParameters()->getSourceRange();\n  return true;\n}\n\n/// CheckLiteralOperatorDeclaration - Check whether the declaration\n/// of this literal operator function is well-formed. If so, returns\n/// false; otherwise, emits appropriate diagnostics and returns true.\nbool Sema::CheckLiteralOperatorDeclaration(FunctionDecl *FnDecl) {\n  if (isa<CXXMethodDecl>(FnDecl)) {\n    Diag(FnDecl->getLocation(), diag::err_literal_operator_outside_namespace)\n      << FnDecl->getDeclName();\n    return true;\n  }\n\n  if (FnDecl->isExternC()) {\n    Diag(FnDecl->getLocation(), diag::err_literal_operator_extern_c);\n    if (const LinkageSpecDecl *LSD =\n            FnDecl->getDeclContext()->getExternCContext())\n      Diag(LSD->getExternLoc(), diag::note_extern_c_begins_here);\n    return true;\n  }\n\n  // This might be the definition of a literal operator template.\n  FunctionTemplateDecl *TpDecl = FnDecl->getDescribedFunctionTemplate();\n\n  // This might be a specialization of a literal operator template.\n  if (!TpDecl)\n    TpDecl = FnDecl->getPrimaryTemplate();\n\n  // template <char...> type operator \"\" name() and\n  // template <class T, T...> type operator \"\" name() are the only valid\n  // template signatures, and the only valid signatures with no parameters.\n  //\n  // C++20 also allows template <SomeClass T> type operator \"\" name().\n  if (TpDecl) {\n    if (FnDecl->param_size() != 0) {\n      Diag(FnDecl->getLocation(),\n           diag::err_literal_operator_template_with_params);\n      return true;\n    }\n\n    if (checkLiteralOperatorTemplateParameterList(*this, TpDecl))\n      return true;\n\n  } else if (FnDecl->param_size() == 1) {\n    const ParmVarDecl *Param = FnDecl->getParamDecl(0);\n\n    QualType ParamType = Param->getType().getUnqualifiedType();\n\n    // Only unsigned long long int, long double, any character type, and const\n    // char * are allowed as the only parameters.\n    if (ParamType->isSpecificBuiltinType(BuiltinType::ULongLong) ||\n        ParamType->isSpecificBuiltinType(BuiltinType::LongDouble) ||\n        Context.hasSameType(ParamType, Context.CharTy) ||\n        Context.hasSameType(ParamType, Context.WideCharTy) ||\n        Context.hasSameType(ParamType, Context.Char8Ty) ||\n        Context.hasSameType(ParamType, Context.Char16Ty) ||\n        Context.hasSameType(ParamType, Context.Char32Ty)) {\n    } else if (const PointerType *Ptr = ParamType->getAs<PointerType>()) {\n      QualType InnerType = Ptr->getPointeeType();\n\n      // Pointer parameter must be a const char *.\n      if (!(Context.hasSameType(InnerType.getUnqualifiedType(),\n                                Context.CharTy) &&\n            InnerType.isConstQualified() && !InnerType.isVolatileQualified())) {\n        Diag(Param->getSourceRange().getBegin(),\n             diag::err_literal_operator_param)\n            << ParamType << \"'const char *'\" << Param->getSourceRange();\n        return true;\n      }\n\n    } else if (ParamType->isRealFloatingType()) {\n      Diag(Param->getSourceRange().getBegin(), diag::err_literal_operator_param)\n          << ParamType << Context.LongDoubleTy << Param->getSourceRange();\n      return true;\n\n    } else if (ParamType->isIntegerType()) {\n      Diag(Param->getSourceRange().getBegin(), diag::err_literal_operator_param)\n          << ParamType << Context.UnsignedLongLongTy << Param->getSourceRange();\n      return true;\n\n    } else {\n      Diag(Param->getSourceRange().getBegin(),\n           diag::err_literal_operator_invalid_param)\n          << ParamType << Param->getSourceRange();\n      return true;\n    }\n\n  } else if (FnDecl->param_size() == 2) {\n    FunctionDecl::param_iterator Param = FnDecl->param_begin();\n\n    // First, verify that the first parameter is correct.\n\n    QualType FirstParamType = (*Param)->getType().getUnqualifiedType();\n\n    // Two parameter function must have a pointer to const as a\n    // first parameter; let's strip those qualifiers.\n    const PointerType *PT = FirstParamType->getAs<PointerType>();\n\n    if (!PT) {\n      Diag((*Param)->getSourceRange().getBegin(),\n           diag::err_literal_operator_param)\n          << FirstParamType << \"'const char *'\" << (*Param)->getSourceRange();\n      return true;\n    }\n\n    QualType PointeeType = PT->getPointeeType();\n    // First parameter must be const\n    if (!PointeeType.isConstQualified() || PointeeType.isVolatileQualified()) {\n      Diag((*Param)->getSourceRange().getBegin(),\n           diag::err_literal_operator_param)\n          << FirstParamType << \"'const char *'\" << (*Param)->getSourceRange();\n      return true;\n    }\n\n    QualType InnerType = PointeeType.getUnqualifiedType();\n    // Only const char *, const wchar_t*, const char8_t*, const char16_t*, and\n    // const char32_t* are allowed as the first parameter to a two-parameter\n    // function\n    if (!(Context.hasSameType(InnerType, Context.CharTy) ||\n          Context.hasSameType(InnerType, Context.WideCharTy) ||\n          Context.hasSameType(InnerType, Context.Char8Ty) ||\n          Context.hasSameType(InnerType, Context.Char16Ty) ||\n          Context.hasSameType(InnerType, Context.Char32Ty))) {\n      Diag((*Param)->getSourceRange().getBegin(),\n           diag::err_literal_operator_param)\n          << FirstParamType << \"'const char *'\" << (*Param)->getSourceRange();\n      return true;\n    }\n\n    // Move on to the second and final parameter.\n    ++Param;\n\n    // The second parameter must be a std::size_t.\n    QualType SecondParamType = (*Param)->getType().getUnqualifiedType();\n    if (!Context.hasSameType(SecondParamType, Context.getSizeType())) {\n      Diag((*Param)->getSourceRange().getBegin(),\n           diag::err_literal_operator_param)\n          << SecondParamType << Context.getSizeType()\n          << (*Param)->getSourceRange();\n      return true;\n    }\n  } else {\n    Diag(FnDecl->getLocation(), diag::err_literal_operator_bad_param_count);\n    return true;\n  }\n\n  // Parameters are good.\n\n  // A parameter-declaration-clause containing a default argument is not\n  // equivalent to any of the permitted forms.\n  for (auto Param : FnDecl->parameters()) {\n    if (Param->hasDefaultArg()) {\n      Diag(Param->getDefaultArgRange().getBegin(),\n           diag::err_literal_operator_default_argument)\n        << Param->getDefaultArgRange();\n      break;\n    }\n  }\n\n  StringRef LiteralName\n    = FnDecl->getDeclName().getCXXLiteralIdentifier()->getName();\n  if (LiteralName[0] != '_' &&\n      !getSourceManager().isInSystemHeader(FnDecl->getLocation())) {\n    // C++11 [usrlit.suffix]p1:\n    //   Literal suffix identifiers that do not start with an underscore\n    //   are reserved for future standardization.\n    Diag(FnDecl->getLocation(), diag::warn_user_literal_reserved)\n      << StringLiteralParser::isValidUDSuffix(getLangOpts(), LiteralName);\n  }\n\n  return false;\n}\n\n/// ActOnStartLinkageSpecification - Parsed the beginning of a C++\n/// linkage specification, including the language and (if present)\n/// the '{'. ExternLoc is the location of the 'extern', Lang is the\n/// language string literal. LBraceLoc, if valid, provides the location of\n/// the '{' brace. Otherwise, this linkage specification does not\n/// have any braces.\nDecl *Sema::ActOnStartLinkageSpecification(Scope *S, SourceLocation ExternLoc,\n                                           Expr *LangStr,\n                                           SourceLocation LBraceLoc) {\n  StringLiteral *Lit = cast<StringLiteral>(LangStr);\n  if (!Lit->isAscii()) {\n    Diag(LangStr->getExprLoc(), diag::err_language_linkage_spec_not_ascii)\n      << LangStr->getSourceRange();\n    return nullptr;\n  }\n\n  StringRef Lang = Lit->getString();\n  LinkageSpecDecl::LanguageIDs Language;\n  if (Lang == \"C\")\n    Language = LinkageSpecDecl::lang_c;\n  else if (Lang == \"C++\")\n    Language = LinkageSpecDecl::lang_cxx;\n  else {\n    Diag(LangStr->getExprLoc(), diag::err_language_linkage_spec_unknown)\n      << LangStr->getSourceRange();\n    return nullptr;\n  }\n\n  // FIXME: Add all the various semantics of linkage specifications\n\n  LinkageSpecDecl *D = LinkageSpecDecl::Create(Context, CurContext, ExternLoc,\n                                               LangStr->getExprLoc(), Language,\n                                               LBraceLoc.isValid());\n  CurContext->addDecl(D);\n  PushDeclContext(S, D);\n  return D;\n}\n\n/// ActOnFinishLinkageSpecification - Complete the definition of\n/// the C++ linkage specification LinkageSpec. If RBraceLoc is\n/// valid, it's the position of the closing '}' brace in a linkage\n/// specification that uses braces.\nDecl *Sema::ActOnFinishLinkageSpecification(Scope *S,\n                                            Decl *LinkageSpec,\n                                            SourceLocation RBraceLoc) {\n  if (RBraceLoc.isValid()) {\n    LinkageSpecDecl* LSDecl = cast<LinkageSpecDecl>(LinkageSpec);\n    LSDecl->setRBraceLoc(RBraceLoc);\n  }\n  PopDeclContext();\n  return LinkageSpec;\n}\n\nDecl *Sema::ActOnEmptyDeclaration(Scope *S,\n                                  const ParsedAttributesView &AttrList,\n                                  SourceLocation SemiLoc) {\n  Decl *ED = EmptyDecl::Create(Context, CurContext, SemiLoc);\n  // Attribute declarations appertain to empty declaration so we handle\n  // them here.\n  ProcessDeclAttributeList(S, ED, AttrList);\n\n  CurContext->addDecl(ED);\n  return ED;\n}\n\n/// Perform semantic analysis for the variable declaration that\n/// occurs within a C++ catch clause, returning the newly-created\n/// variable.\nVarDecl *Sema::BuildExceptionDeclaration(Scope *S,\n                                         TypeSourceInfo *TInfo,\n                                         SourceLocation StartLoc,\n                                         SourceLocation Loc,\n                                         IdentifierInfo *Name) {\n  bool Invalid = false;\n  QualType ExDeclType = TInfo->getType();\n\n  // Arrays and functions decay.\n  if (ExDeclType->isArrayType())\n    ExDeclType = Context.getArrayDecayedType(ExDeclType);\n  else if (ExDeclType->isFunctionType())\n    ExDeclType = Context.getPointerType(ExDeclType);\n\n  // C++ 15.3p1: The exception-declaration shall not denote an incomplete type.\n  // The exception-declaration shall not denote a pointer or reference to an\n  // incomplete type, other than [cv] void*.\n  // N2844 forbids rvalue references.\n  if (!ExDeclType->isDependentType() && ExDeclType->isRValueReferenceType()) {\n    Diag(Loc, diag::err_catch_rvalue_ref);\n    Invalid = true;\n  }\n\n  if (ExDeclType->isVariablyModifiedType()) {\n    Diag(Loc, diag::err_catch_variably_modified) << ExDeclType;\n    Invalid = true;\n  }\n\n  QualType BaseType = ExDeclType;\n  int Mode = 0; // 0 for direct type, 1 for pointer, 2 for reference\n  unsigned DK = diag::err_catch_incomplete;\n  if (const PointerType *Ptr = BaseType->getAs<PointerType>()) {\n    BaseType = Ptr->getPointeeType();\n    Mode = 1;\n    DK = diag::err_catch_incomplete_ptr;\n  } else if (const ReferenceType *Ref = BaseType->getAs<ReferenceType>()) {\n    // For the purpose of error recovery, we treat rvalue refs like lvalue refs.\n    BaseType = Ref->getPointeeType();\n    Mode = 2;\n    DK = diag::err_catch_incomplete_ref;\n  }\n  if (!Invalid && (Mode == 0 || !BaseType->isVoidType()) &&\n      !BaseType->isDependentType() && RequireCompleteType(Loc, BaseType, DK))\n    Invalid = true;\n\n  if (!Invalid && Mode != 1 && BaseType->isSizelessType()) {\n    Diag(Loc, diag::err_catch_sizeless) << (Mode == 2 ? 1 : 0) << BaseType;\n    Invalid = true;\n  }\n\n  if (!Invalid && !ExDeclType->isDependentType() &&\n      RequireNonAbstractType(Loc, ExDeclType,\n                             diag::err_abstract_type_in_decl,\n                             AbstractVariableType))\n    Invalid = true;\n\n  // Only the non-fragile NeXT runtime currently supports C++ catches\n  // of ObjC types, and no runtime supports catching ObjC types by value.\n  if (!Invalid && getLangOpts().ObjC) {\n    QualType T = ExDeclType;\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      T = RT->getPointeeType();\n\n    if (T->isObjCObjectType()) {\n      Diag(Loc, diag::err_objc_object_catch);\n      Invalid = true;\n    } else if (T->isObjCObjectPointerType()) {\n      // FIXME: should this be a test for macosx-fragile specifically?\n      if (getLangOpts().ObjCRuntime.isFragile())\n        Diag(Loc, diag::warn_objc_pointer_cxx_catch_fragile);\n    }\n  }\n\n  VarDecl *ExDecl = VarDecl::Create(Context, CurContext, StartLoc, Loc, Name,\n                                    ExDeclType, TInfo, SC_None);\n  ExDecl->setExceptionVariable(true);\n\n  // In ARC, infer 'retaining' for variables of retainable type.\n  if (getLangOpts().ObjCAutoRefCount && inferObjCARCLifetime(ExDecl))\n    Invalid = true;\n\n  if (!Invalid && !ExDeclType->isDependentType()) {\n    if (const RecordType *recordType = ExDeclType->getAs<RecordType>()) {\n      // Insulate this from anything else we might currently be parsing.\n      EnterExpressionEvaluationContext scope(\n          *this, ExpressionEvaluationContext::PotentiallyEvaluated);\n\n      // C++ [except.handle]p16:\n      //   The object declared in an exception-declaration or, if the\n      //   exception-declaration does not specify a name, a temporary (12.2) is\n      //   copy-initialized (8.5) from the exception object. [...]\n      //   The object is destroyed when the handler exits, after the destruction\n      //   of any automatic objects initialized within the handler.\n      //\n      // We just pretend to initialize the object with itself, then make sure\n      // it can be destroyed later.\n      QualType initType = Context.getExceptionObjectType(ExDeclType);\n\n      InitializedEntity entity =\n        InitializedEntity::InitializeVariable(ExDecl);\n      InitializationKind initKind =\n        InitializationKind::CreateCopy(Loc, SourceLocation());\n\n      Expr *opaqueValue =\n        new (Context) OpaqueValueExpr(Loc, initType, VK_LValue, OK_Ordinary);\n      InitializationSequence sequence(*this, entity, initKind, opaqueValue);\n      ExprResult result = sequence.Perform(*this, entity, initKind, opaqueValue);\n      if (result.isInvalid())\n        Invalid = true;\n      else {\n        // If the constructor used was non-trivial, set this as the\n        // \"initializer\".\n        CXXConstructExpr *construct = result.getAs<CXXConstructExpr>();\n        if (!construct->getConstructor()->isTrivial()) {\n          Expr *init = MaybeCreateExprWithCleanups(construct);\n          ExDecl->setInit(init);\n        }\n\n        // And make sure it's destructable.\n        FinalizeVarWithDestructor(ExDecl, recordType);\n      }\n    }\n  }\n\n  if (Invalid)\n    ExDecl->setInvalidDecl();\n\n  return ExDecl;\n}\n\n/// ActOnExceptionDeclarator - Parsed the exception-declarator in a C++ catch\n/// handler.\nDecl *Sema::ActOnExceptionDeclarator(Scope *S, Declarator &D) {\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  bool Invalid = D.isInvalidType();\n\n  // Check for unexpanded parameter packs.\n  if (DiagnoseUnexpandedParameterPack(D.getIdentifierLoc(), TInfo,\n                                      UPPC_ExceptionType)) {\n    TInfo = Context.getTrivialTypeSourceInfo(Context.IntTy,\n                                             D.getIdentifierLoc());\n    Invalid = true;\n  }\n\n  IdentifierInfo *II = D.getIdentifier();\n  if (NamedDecl *PrevDecl = LookupSingleName(S, II, D.getIdentifierLoc(),\n                                             LookupOrdinaryName,\n                                             ForVisibleRedeclaration)) {\n    // The scope should be freshly made just for us. There is just no way\n    // it contains any previous declaration, except for function parameters in\n    // a function-try-block's catch statement.\n    assert(!S->isDeclScope(PrevDecl));\n    if (isDeclInScope(PrevDecl, CurContext, S)) {\n      Diag(D.getIdentifierLoc(), diag::err_redefinition)\n        << D.getIdentifier();\n      Diag(PrevDecl->getLocation(), diag::note_previous_definition);\n      Invalid = true;\n    } else if (PrevDecl->isTemplateParameter())\n      // Maybe we will complain about the shadowed template parameter.\n      DiagnoseTemplateParameterShadow(D.getIdentifierLoc(), PrevDecl);\n  }\n\n  if (D.getCXXScopeSpec().isSet() && !Invalid) {\n    Diag(D.getIdentifierLoc(), diag::err_qualified_catch_declarator)\n      << D.getCXXScopeSpec().getRange();\n    Invalid = true;\n  }\n\n  VarDecl *ExDecl = BuildExceptionDeclaration(\n      S, TInfo, D.getBeginLoc(), D.getIdentifierLoc(), D.getIdentifier());\n  if (Invalid)\n    ExDecl->setInvalidDecl();\n\n  // Add the exception declaration into this scope.\n  if (II)\n    PushOnScopeChains(ExDecl, S);\n  else\n    CurContext->addDecl(ExDecl);\n\n  ProcessDeclAttributes(S, ExDecl, D);\n  return ExDecl;\n}\n\nDecl *Sema::ActOnStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                         Expr *AssertExpr,\n                                         Expr *AssertMessageExpr,\n                                         SourceLocation RParenLoc) {\n  StringLiteral *AssertMessage =\n      AssertMessageExpr ? cast<StringLiteral>(AssertMessageExpr) : nullptr;\n\n  if (DiagnoseUnexpandedParameterPack(AssertExpr, UPPC_StaticAssertExpression))\n    return nullptr;\n\n  return BuildStaticAssertDeclaration(StaticAssertLoc, AssertExpr,\n                                      AssertMessage, RParenLoc, false);\n}\n\nDecl *Sema::BuildStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                         Expr *AssertExpr,\n                                         StringLiteral *AssertMessage,\n                                         SourceLocation RParenLoc,\n                                         bool Failed) {\n  assert(AssertExpr != nullptr && \"Expected non-null condition\");\n  if (!AssertExpr->isTypeDependent() && !AssertExpr->isValueDependent() &&\n      !Failed) {\n    // In a static_assert-declaration, the constant-expression shall be a\n    // constant expression that can be contextually converted to bool.\n    ExprResult Converted = PerformContextuallyConvertToBool(AssertExpr);\n    if (Converted.isInvalid())\n      Failed = true;\n\n    ExprResult FullAssertExpr =\n        ActOnFinishFullExpr(Converted.get(), StaticAssertLoc,\n                            /*DiscardedValue*/ false,\n                            /*IsConstexpr*/ true);\n    if (FullAssertExpr.isInvalid())\n      Failed = true;\n    else\n      AssertExpr = FullAssertExpr.get();\n\n    llvm::APSInt Cond;\n    if (!Failed && VerifyIntegerConstantExpression(\n                       AssertExpr, &Cond,\n                       diag::err_static_assert_expression_is_not_constant)\n                       .isInvalid())\n      Failed = true;\n\n    if (!Failed && !Cond) {\n      SmallString<256> MsgBuffer;\n      llvm::raw_svector_ostream Msg(MsgBuffer);\n      if (AssertMessage)\n        AssertMessage->printPretty(Msg, nullptr, getPrintingPolicy());\n\n      Expr *InnerCond = nullptr;\n      std::string InnerCondDescription;\n      std::tie(InnerCond, InnerCondDescription) =\n        findFailedBooleanCondition(Converted.get());\n      if (InnerCond && isa<ConceptSpecializationExpr>(InnerCond)) {\n        // Drill down into concept specialization expressions to see why they\n        // weren't satisfied.\n        Diag(StaticAssertLoc, diag::err_static_assert_failed)\n          << !AssertMessage << Msg.str() << AssertExpr->getSourceRange();\n        ConstraintSatisfaction Satisfaction;\n        if (!CheckConstraintSatisfaction(InnerCond, Satisfaction))\n          DiagnoseUnsatisfiedConstraint(Satisfaction);\n      } else if (InnerCond && !isa<CXXBoolLiteralExpr>(InnerCond)\n                           && !isa<IntegerLiteral>(InnerCond)) {\n        Diag(StaticAssertLoc, diag::err_static_assert_requirement_failed)\n          << InnerCondDescription << !AssertMessage\n          << Msg.str() << InnerCond->getSourceRange();\n      } else {\n        Diag(StaticAssertLoc, diag::err_static_assert_failed)\n          << !AssertMessage << Msg.str() << AssertExpr->getSourceRange();\n      }\n      Failed = true;\n    }\n  } else {\n    ExprResult FullAssertExpr = ActOnFinishFullExpr(AssertExpr, StaticAssertLoc,\n                                                    /*DiscardedValue*/false,\n                                                    /*IsConstexpr*/true);\n    if (FullAssertExpr.isInvalid())\n      Failed = true;\n    else\n      AssertExpr = FullAssertExpr.get();\n  }\n\n  Decl *Decl = StaticAssertDecl::Create(Context, CurContext, StaticAssertLoc,\n                                        AssertExpr, AssertMessage, RParenLoc,\n                                        Failed);\n\n  CurContext->addDecl(Decl);\n  return Decl;\n}\n\n/// Perform semantic analysis of the given friend type declaration.\n///\n/// \\returns A friend declaration that.\nFriendDecl *Sema::CheckFriendTypeDecl(SourceLocation LocStart,\n                                      SourceLocation FriendLoc,\n                                      TypeSourceInfo *TSInfo) {\n  assert(TSInfo && \"NULL TypeSourceInfo for friend type declaration\");\n\n  QualType T = TSInfo->getType();\n  SourceRange TypeRange = TSInfo->getTypeLoc().getLocalSourceRange();\n\n  // C++03 [class.friend]p2:\n  //   An elaborated-type-specifier shall be used in a friend declaration\n  //   for a class.*\n  //\n  //   * The class-key of the elaborated-type-specifier is required.\n  if (!CodeSynthesisContexts.empty()) {\n    // Do not complain about the form of friend template types during any kind\n    // of code synthesis. For template instantiation, we will have complained\n    // when the template was defined.\n  } else {\n    if (!T->isElaboratedTypeSpecifier()) {\n      // If we evaluated the type to a record type, suggest putting\n      // a tag in front.\n      if (const RecordType *RT = T->getAs<RecordType>()) {\n        RecordDecl *RD = RT->getDecl();\n\n        SmallString<16> InsertionText(\" \");\n        InsertionText += RD->getKindName();\n\n        Diag(TypeRange.getBegin(),\n             getLangOpts().CPlusPlus11 ?\n               diag::warn_cxx98_compat_unelaborated_friend_type :\n               diag::ext_unelaborated_friend_type)\n          << (unsigned) RD->getTagKind()\n          << T\n          << FixItHint::CreateInsertion(getLocForEndOfToken(FriendLoc),\n                                        InsertionText);\n      } else {\n        Diag(FriendLoc,\n             getLangOpts().CPlusPlus11 ?\n               diag::warn_cxx98_compat_nonclass_type_friend :\n               diag::ext_nonclass_type_friend)\n          << T\n          << TypeRange;\n      }\n    } else if (T->getAs<EnumType>()) {\n      Diag(FriendLoc,\n           getLangOpts().CPlusPlus11 ?\n             diag::warn_cxx98_compat_enum_friend :\n             diag::ext_enum_friend)\n        << T\n        << TypeRange;\n    }\n\n    // C++11 [class.friend]p3:\n    //   A friend declaration that does not declare a function shall have one\n    //   of the following forms:\n    //     friend elaborated-type-specifier ;\n    //     friend simple-type-specifier ;\n    //     friend typename-specifier ;\n    if (getLangOpts().CPlusPlus11 && LocStart != FriendLoc)\n      Diag(FriendLoc, diag::err_friend_not_first_in_declaration) << T;\n  }\n\n  //   If the type specifier in a friend declaration designates a (possibly\n  //   cv-qualified) class type, that class is declared as a friend; otherwise,\n  //   the friend declaration is ignored.\n  return FriendDecl::Create(Context, CurContext,\n                            TSInfo->getTypeLoc().getBeginLoc(), TSInfo,\n                            FriendLoc);\n}\n\n/// Handle a friend tag declaration where the scope specifier was\n/// templated.\nDecl *Sema::ActOnTemplatedFriendTag(Scope *S, SourceLocation FriendLoc,\n                                    unsigned TagSpec, SourceLocation TagLoc,\n                                    CXXScopeSpec &SS, IdentifierInfo *Name,\n                                    SourceLocation NameLoc,\n                                    const ParsedAttributesView &Attr,\n                                    MultiTemplateParamsArg TempParamLists) {\n  TagTypeKind Kind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n\n  bool IsMemberSpecialization = false;\n  bool Invalid = false;\n\n  if (TemplateParameterList *TemplateParams =\n          MatchTemplateParametersToScopeSpecifier(\n              TagLoc, NameLoc, SS, nullptr, TempParamLists, /*friend*/ true,\n              IsMemberSpecialization, Invalid)) {\n    if (TemplateParams->size() > 0) {\n      // This is a declaration of a class template.\n      if (Invalid)\n        return nullptr;\n\n      return CheckClassTemplate(S, TagSpec, TUK_Friend, TagLoc, SS, Name,\n                                NameLoc, Attr, TemplateParams, AS_public,\n                                /*ModulePrivateLoc=*/SourceLocation(),\n                                FriendLoc, TempParamLists.size() - 1,\n                                TempParamLists.data()).get();\n    } else {\n      // The \"template<>\" header is extraneous.\n      Diag(TemplateParams->getTemplateLoc(), diag::err_template_tag_noparams)\n        << TypeWithKeyword::getTagTypeKindName(Kind) << Name;\n      IsMemberSpecialization = true;\n    }\n  }\n\n  if (Invalid) return nullptr;\n\n  bool isAllExplicitSpecializations = true;\n  for (unsigned I = TempParamLists.size(); I-- > 0; ) {\n    if (TempParamLists[I]->size()) {\n      isAllExplicitSpecializations = false;\n      break;\n    }\n  }\n\n  // FIXME: don't ignore attributes.\n\n  // If it's explicit specializations all the way down, just forget\n  // about the template header and build an appropriate non-templated\n  // friend.  TODO: for source fidelity, remember the headers.\n  if (isAllExplicitSpecializations) {\n    if (SS.isEmpty()) {\n      bool Owned = false;\n      bool IsDependent = false;\n      return ActOnTag(S, TagSpec, TUK_Friend, TagLoc, SS, Name, NameLoc,\n                      Attr, AS_public,\n                      /*ModulePrivateLoc=*/SourceLocation(),\n                      MultiTemplateParamsArg(), Owned, IsDependent,\n                      /*ScopedEnumKWLoc=*/SourceLocation(),\n                      /*ScopedEnumUsesClassTag=*/false,\n                      /*UnderlyingType=*/TypeResult(),\n                      /*IsTypeSpecifier=*/false,\n                      /*IsTemplateParamOrArg=*/false);\n    }\n\n    NestedNameSpecifierLoc QualifierLoc = SS.getWithLocInContext(Context);\n    ElaboratedTypeKeyword Keyword\n      = TypeWithKeyword::getKeywordForTagTypeKind(Kind);\n    QualType T = CheckTypenameType(Keyword, TagLoc, QualifierLoc,\n                                   *Name, NameLoc);\n    if (T.isNull())\n      return nullptr;\n\n    TypeSourceInfo *TSI = Context.CreateTypeSourceInfo(T);\n    if (isa<DependentNameType>(T)) {\n      DependentNameTypeLoc TL =\n          TSI->getTypeLoc().castAs<DependentNameTypeLoc>();\n      TL.setElaboratedKeywordLoc(TagLoc);\n      TL.setQualifierLoc(QualifierLoc);\n      TL.setNameLoc(NameLoc);\n    } else {\n      ElaboratedTypeLoc TL = TSI->getTypeLoc().castAs<ElaboratedTypeLoc>();\n      TL.setElaboratedKeywordLoc(TagLoc);\n      TL.setQualifierLoc(QualifierLoc);\n      TL.getNamedTypeLoc().castAs<TypeSpecTypeLoc>().setNameLoc(NameLoc);\n    }\n\n    FriendDecl *Friend = FriendDecl::Create(Context, CurContext, NameLoc,\n                                            TSI, FriendLoc, TempParamLists);\n    Friend->setAccess(AS_public);\n    CurContext->addDecl(Friend);\n    return Friend;\n  }\n\n  assert(SS.isNotEmpty() && \"valid templated tag with no SS and no direct?\");\n\n\n\n  // Handle the case of a templated-scope friend class.  e.g.\n  //   template <class T> class A<T>::B;\n  // FIXME: we don't support these right now.\n  Diag(NameLoc, diag::warn_template_qualified_friend_unsupported)\n    << SS.getScopeRep() << SS.getRange() << cast<CXXRecordDecl>(CurContext);\n  ElaboratedTypeKeyword ETK = TypeWithKeyword::getKeywordForTagTypeKind(Kind);\n  QualType T = Context.getDependentNameType(ETK, SS.getScopeRep(), Name);\n  TypeSourceInfo *TSI = Context.CreateTypeSourceInfo(T);\n  DependentNameTypeLoc TL = TSI->getTypeLoc().castAs<DependentNameTypeLoc>();\n  TL.setElaboratedKeywordLoc(TagLoc);\n  TL.setQualifierLoc(SS.getWithLocInContext(Context));\n  TL.setNameLoc(NameLoc);\n\n  FriendDecl *Friend = FriendDecl::Create(Context, CurContext, NameLoc,\n                                          TSI, FriendLoc, TempParamLists);\n  Friend->setAccess(AS_public);\n  Friend->setUnsupportedFriend(true);\n  CurContext->addDecl(Friend);\n  return Friend;\n}\n\n/// Handle a friend type declaration.  This works in tandem with\n/// ActOnTag.\n///\n/// Notes on friend class templates:\n///\n/// We generally treat friend class declarations as if they were\n/// declaring a class.  So, for example, the elaborated type specifier\n/// in a friend declaration is required to obey the restrictions of a\n/// class-head (i.e. no typedefs in the scope chain), template\n/// parameters are required to match up with simple template-ids, &c.\n/// However, unlike when declaring a template specialization, it's\n/// okay to refer to a template specialization without an empty\n/// template parameter declaration, e.g.\n///   friend class A<T>::B<unsigned>;\n/// We permit this as a special case; if there are any template\n/// parameters present at all, require proper matching, i.e.\n///   template <> template \\<class T> friend class A<int>::B;\nDecl *Sema::ActOnFriendTypeDecl(Scope *S, const DeclSpec &DS,\n                                MultiTemplateParamsArg TempParams) {\n  SourceLocation Loc = DS.getBeginLoc();\n\n  assert(DS.isFriendSpecified());\n  assert(DS.getStorageClassSpec() == DeclSpec::SCS_unspecified);\n\n  // C++ [class.friend]p3:\n  // A friend declaration that does not declare a function shall have one of\n  // the following forms:\n  //     friend elaborated-type-specifier ;\n  //     friend simple-type-specifier ;\n  //     friend typename-specifier ;\n  //\n  // Any declaration with a type qualifier does not have that form. (It's\n  // legal to specify a qualified type as a friend, you just can't write the\n  // keywords.)\n  if (DS.getTypeQualifiers()) {\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_const)\n      Diag(DS.getConstSpecLoc(), diag::err_friend_decl_spec) << \"const\";\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_volatile)\n      Diag(DS.getVolatileSpecLoc(), diag::err_friend_decl_spec) << \"volatile\";\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_restrict)\n      Diag(DS.getRestrictSpecLoc(), diag::err_friend_decl_spec) << \"restrict\";\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_atomic)\n      Diag(DS.getAtomicSpecLoc(), diag::err_friend_decl_spec) << \"_Atomic\";\n    if (DS.getTypeQualifiers() & DeclSpec::TQ_unaligned)\n      Diag(DS.getUnalignedSpecLoc(), diag::err_friend_decl_spec) << \"__unaligned\";\n  }\n\n  // Try to convert the decl specifier to a type.  This works for\n  // friend templates because ActOnTag never produces a ClassTemplateDecl\n  // for a TUK_Friend.\n  Declarator TheDeclarator(DS, DeclaratorContext::Member);\n  TypeSourceInfo *TSI = GetTypeForDeclarator(TheDeclarator, S);\n  QualType T = TSI->getType();\n  if (TheDeclarator.isInvalidType())\n    return nullptr;\n\n  if (DiagnoseUnexpandedParameterPack(Loc, TSI, UPPC_FriendDeclaration))\n    return nullptr;\n\n  // This is definitely an error in C++98.  It's probably meant to\n  // be forbidden in C++0x, too, but the specification is just\n  // poorly written.\n  //\n  // The problem is with declarations like the following:\n  //   template <T> friend A<T>::foo;\n  // where deciding whether a class C is a friend or not now hinges\n  // on whether there exists an instantiation of A that causes\n  // 'foo' to equal C.  There are restrictions on class-heads\n  // (which we declare (by fiat) elaborated friend declarations to\n  // be) that makes this tractable.\n  //\n  // FIXME: handle \"template <> friend class A<T>;\", which\n  // is possibly well-formed?  Who even knows?\n  if (TempParams.size() && !T->isElaboratedTypeSpecifier()) {\n    Diag(Loc, diag::err_tagless_friend_type_template)\n      << DS.getSourceRange();\n    return nullptr;\n  }\n\n  // C++98 [class.friend]p1: A friend of a class is a function\n  //   or class that is not a member of the class . . .\n  // This is fixed in DR77, which just barely didn't make the C++03\n  // deadline.  It's also a very silly restriction that seriously\n  // affects inner classes and which nobody else seems to implement;\n  // thus we never diagnose it, not even in -pedantic.\n  //\n  // But note that we could warn about it: it's always useless to\n  // friend one of your own members (it's not, however, worthless to\n  // friend a member of an arbitrary specialization of your template).\n\n  Decl *D;\n  if (!TempParams.empty())\n    D = FriendTemplateDecl::Create(Context, CurContext, Loc,\n                                   TempParams,\n                                   TSI,\n                                   DS.getFriendSpecLoc());\n  else\n    D = CheckFriendTypeDecl(Loc, DS.getFriendSpecLoc(), TSI);\n\n  if (!D)\n    return nullptr;\n\n  D->setAccess(AS_public);\n  CurContext->addDecl(D);\n\n  return D;\n}\n\nNamedDecl *Sema::ActOnFriendFunctionDecl(Scope *S, Declarator &D,\n                                        MultiTemplateParamsArg TemplateParams) {\n  const DeclSpec &DS = D.getDeclSpec();\n\n  assert(DS.isFriendSpecified());\n  assert(DS.getStorageClassSpec() == DeclSpec::SCS_unspecified);\n\n  SourceLocation Loc = D.getIdentifierLoc();\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n\n  // C++ [class.friend]p1\n  //   A friend of a class is a function or class....\n  // Note that this sees through typedefs, which is intended.\n  // It *doesn't* see through dependent types, which is correct\n  // according to [temp.arg.type]p3:\n  //   If a declaration acquires a function type through a\n  //   type dependent on a template-parameter and this causes\n  //   a declaration that does not use the syntactic form of a\n  //   function declarator to have a function type, the program\n  //   is ill-formed.\n  if (!TInfo->getType()->isFunctionType()) {\n    Diag(Loc, diag::err_unexpected_friend);\n\n    // It might be worthwhile to try to recover by creating an\n    // appropriate declaration.\n    return nullptr;\n  }\n\n  // C++ [namespace.memdef]p3\n  //  - If a friend declaration in a non-local class first declares a\n  //    class or function, the friend class or function is a member\n  //    of the innermost enclosing namespace.\n  //  - The name of the friend is not found by simple name lookup\n  //    until a matching declaration is provided in that namespace\n  //    scope (either before or after the class declaration granting\n  //    friendship).\n  //  - If a friend function is called, its name may be found by the\n  //    name lookup that considers functions from namespaces and\n  //    classes associated with the types of the function arguments.\n  //  - When looking for a prior declaration of a class or a function\n  //    declared as a friend, scopes outside the innermost enclosing\n  //    namespace scope are not considered.\n\n  CXXScopeSpec &SS = D.getCXXScopeSpec();\n  DeclarationNameInfo NameInfo = GetNameForDeclarator(D);\n  assert(NameInfo.getName());\n\n  // Check for unexpanded parameter packs.\n  if (DiagnoseUnexpandedParameterPack(Loc, TInfo, UPPC_FriendDeclaration) ||\n      DiagnoseUnexpandedParameterPack(NameInfo, UPPC_FriendDeclaration) ||\n      DiagnoseUnexpandedParameterPack(SS, UPPC_FriendDeclaration))\n    return nullptr;\n\n  // The context we found the declaration in, or in which we should\n  // create the declaration.\n  DeclContext *DC;\n  Scope *DCScope = S;\n  LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                        ForExternalRedeclaration);\n\n  // There are five cases here.\n  //   - There's no scope specifier and we're in a local class. Only look\n  //     for functions declared in the immediately-enclosing block scope.\n  // We recover from invalid scope qualifiers as if they just weren't there.\n  FunctionDecl *FunctionContainingLocalClass = nullptr;\n  if ((SS.isInvalid() || !SS.isSet()) &&\n      (FunctionContainingLocalClass =\n           cast<CXXRecordDecl>(CurContext)->isLocalClass())) {\n    // C++11 [class.friend]p11:\n    //   If a friend declaration appears in a local class and the name\n    //   specified is an unqualified name, a prior declaration is\n    //   looked up without considering scopes that are outside the\n    //   innermost enclosing non-class scope. For a friend function\n    //   declaration, if there is no prior declaration, the program is\n    //   ill-formed.\n\n    // Find the innermost enclosing non-class scope. This is the block\n    // scope containing the local class definition (or for a nested class,\n    // the outer local class).\n    DCScope = S->getFnParent();\n\n    // Look up the function name in the scope.\n    Previous.clear(LookupLocalFriendName);\n    LookupName(Previous, S, /*AllowBuiltinCreation*/false);\n\n    if (!Previous.empty()) {\n      // All possible previous declarations must have the same context:\n      // either they were declared at block scope or they are members of\n      // one of the enclosing local classes.\n      DC = Previous.getRepresentativeDecl()->getDeclContext();\n    } else {\n      // This is ill-formed, but provide the context that we would have\n      // declared the function in, if we were permitted to, for error recovery.\n      DC = FunctionContainingLocalClass;\n    }\n    adjustContextForLocalExternDecl(DC);\n\n    // C++ [class.friend]p6:\n    //   A function can be defined in a friend declaration of a class if and\n    //   only if the class is a non-local class (9.8), the function name is\n    //   unqualified, and the function has namespace scope.\n    if (D.isFunctionDefinition()) {\n      Diag(NameInfo.getBeginLoc(), diag::err_friend_def_in_local_class);\n    }\n\n  //   - There's no scope specifier, in which case we just go to the\n  //     appropriate scope and look for a function or function template\n  //     there as appropriate.\n  } else if (SS.isInvalid() || !SS.isSet()) {\n    // C++11 [namespace.memdef]p3:\n    //   If the name in a friend declaration is neither qualified nor\n    //   a template-id and the declaration is a function or an\n    //   elaborated-type-specifier, the lookup to determine whether\n    //   the entity has been previously declared shall not consider\n    //   any scopes outside the innermost enclosing namespace.\n    bool isTemplateId =\n        D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId;\n\n    // Find the appropriate context according to the above.\n    DC = CurContext;\n\n    // Skip class contexts.  If someone can cite chapter and verse\n    // for this behavior, that would be nice --- it's what GCC and\n    // EDG do, and it seems like a reasonable intent, but the spec\n    // really only says that checks for unqualified existing\n    // declarations should stop at the nearest enclosing namespace,\n    // not that they should only consider the nearest enclosing\n    // namespace.\n    while (DC->isRecord())\n      DC = DC->getParent();\n\n    DeclContext *LookupDC = DC;\n    while (LookupDC->isTransparentContext())\n      LookupDC = LookupDC->getParent();\n\n    while (true) {\n      LookupQualifiedName(Previous, LookupDC);\n\n      if (!Previous.empty()) {\n        DC = LookupDC;\n        break;\n      }\n\n      if (isTemplateId) {\n        if (isa<TranslationUnitDecl>(LookupDC)) break;\n      } else {\n        if (LookupDC->isFileContext()) break;\n      }\n      LookupDC = LookupDC->getParent();\n    }\n\n    DCScope = getScopeForDeclContext(S, DC);\n\n  //   - There's a non-dependent scope specifier, in which case we\n  //     compute it and do a previous lookup there for a function\n  //     or function template.\n  } else if (!SS.getScopeRep()->isDependent()) {\n    DC = computeDeclContext(SS);\n    if (!DC) return nullptr;\n\n    if (RequireCompleteDeclContext(SS, DC)) return nullptr;\n\n    LookupQualifiedName(Previous, DC);\n\n    // C++ [class.friend]p1: A friend of a class is a function or\n    //   class that is not a member of the class . . .\n    if (DC->Equals(CurContext))\n      Diag(DS.getFriendSpecLoc(),\n           getLangOpts().CPlusPlus11 ?\n             diag::warn_cxx98_compat_friend_is_member :\n             diag::err_friend_is_member);\n\n    if (D.isFunctionDefinition()) {\n      // C++ [class.friend]p6:\n      //   A function can be defined in a friend declaration of a class if and\n      //   only if the class is a non-local class (9.8), the function name is\n      //   unqualified, and the function has namespace scope.\n      //\n      // FIXME: We should only do this if the scope specifier names the\n      // innermost enclosing namespace; otherwise the fixit changes the\n      // meaning of the code.\n      SemaDiagnosticBuilder DB\n        = Diag(SS.getRange().getBegin(), diag::err_qualified_friend_def);\n\n      DB << SS.getScopeRep();\n      if (DC->isFileContext())\n        DB << FixItHint::CreateRemoval(SS.getRange());\n      SS.clear();\n    }\n\n  //   - There's a scope specifier that does not match any template\n  //     parameter lists, in which case we use some arbitrary context,\n  //     create a method or method template, and wait for instantiation.\n  //   - There's a scope specifier that does match some template\n  //     parameter lists, which we don't handle right now.\n  } else {\n    if (D.isFunctionDefinition()) {\n      // C++ [class.friend]p6:\n      //   A function can be defined in a friend declaration of a class if and\n      //   only if the class is a non-local class (9.8), the function name is\n      //   unqualified, and the function has namespace scope.\n      Diag(SS.getRange().getBegin(), diag::err_qualified_friend_def)\n        << SS.getScopeRep();\n    }\n\n    DC = CurContext;\n    assert(isa<CXXRecordDecl>(DC) && \"friend declaration not in class?\");\n  }\n\n  if (!DC->isRecord()) {\n    int DiagArg = -1;\n    switch (D.getName().getKind()) {\n    case UnqualifiedIdKind::IK_ConstructorTemplateId:\n    case UnqualifiedIdKind::IK_ConstructorName:\n      DiagArg = 0;\n      break;\n    case UnqualifiedIdKind::IK_DestructorName:\n      DiagArg = 1;\n      break;\n    case UnqualifiedIdKind::IK_ConversionFunctionId:\n      DiagArg = 2;\n      break;\n    case UnqualifiedIdKind::IK_DeductionGuideName:\n      DiagArg = 3;\n      break;\n    case UnqualifiedIdKind::IK_Identifier:\n    case UnqualifiedIdKind::IK_ImplicitSelfParam:\n    case UnqualifiedIdKind::IK_LiteralOperatorId:\n    case UnqualifiedIdKind::IK_OperatorFunctionId:\n    case UnqualifiedIdKind::IK_TemplateId:\n      break;\n    }\n    // This implies that it has to be an operator or function.\n    if (DiagArg >= 0) {\n      Diag(Loc, diag::err_introducing_special_friend) << DiagArg;\n      return nullptr;\n    }\n  }\n\n  // FIXME: This is an egregious hack to cope with cases where the scope stack\n  // does not contain the declaration context, i.e., in an out-of-line\n  // definition of a class.\n  Scope FakeDCScope(S, Scope::DeclScope, Diags);\n  if (!DCScope) {\n    FakeDCScope.setEntity(DC);\n    DCScope = &FakeDCScope;\n  }\n\n  bool AddToScope = true;\n  NamedDecl *ND = ActOnFunctionDeclarator(DCScope, D, DC, TInfo, Previous,\n                                          TemplateParams, AddToScope);\n  if (!ND) return nullptr;\n\n  assert(ND->getLexicalDeclContext() == CurContext);\n\n  // If we performed typo correction, we might have added a scope specifier\n  // and changed the decl context.\n  DC = ND->getDeclContext();\n\n  // Add the function declaration to the appropriate lookup tables,\n  // adjusting the redeclarations list as necessary.  We don't\n  // want to do this yet if the friending class is dependent.\n  //\n  // Also update the scope-based lookup if the target context's\n  // lookup context is in lexical scope.\n  if (!CurContext->isDependentContext()) {\n    DC = DC->getRedeclContext();\n    DC->makeDeclVisibleInContext(ND);\n    if (Scope *EnclosingScope = getScopeForDeclContext(S, DC))\n      PushOnScopeChains(ND, EnclosingScope, /*AddToContext=*/ false);\n  }\n\n  FriendDecl *FrD = FriendDecl::Create(Context, CurContext,\n                                       D.getIdentifierLoc(), ND,\n                                       DS.getFriendSpecLoc());\n  FrD->setAccess(AS_public);\n  CurContext->addDecl(FrD);\n\n  if (ND->isInvalidDecl()) {\n    FrD->setInvalidDecl();\n  } else {\n    if (DC->isRecord()) CheckFriendAccess(ND);\n\n    FunctionDecl *FD;\n    if (FunctionTemplateDecl *FTD = dyn_cast<FunctionTemplateDecl>(ND))\n      FD = FTD->getTemplatedDecl();\n    else\n      FD = cast<FunctionDecl>(ND);\n\n    // C++11 [dcl.fct.default]p4: If a friend declaration specifies a\n    // default argument expression, that declaration shall be a definition\n    // and shall be the only declaration of the function or function\n    // template in the translation unit.\n    if (functionDeclHasDefaultArgument(FD)) {\n      // We can't look at FD->getPreviousDecl() because it may not have been set\n      // if we're in a dependent context. If the function is known to be a\n      // redeclaration, we will have narrowed Previous down to the right decl.\n      if (D.isRedeclaration()) {\n        Diag(FD->getLocation(), diag::err_friend_decl_with_def_arg_redeclared);\n        Diag(Previous.getRepresentativeDecl()->getLocation(),\n             diag::note_previous_declaration);\n      } else if (!D.isFunctionDefinition())\n        Diag(FD->getLocation(), diag::err_friend_decl_with_def_arg_must_be_def);\n    }\n\n    // Mark templated-scope function declarations as unsupported.\n    if (FD->getNumTemplateParameterLists() && SS.isValid()) {\n      Diag(FD->getLocation(), diag::warn_template_qualified_friend_unsupported)\n        << SS.getScopeRep() << SS.getRange()\n        << cast<CXXRecordDecl>(CurContext);\n      FrD->setUnsupportedFriend(true);\n    }\n  }\n\n  return ND;\n}\n\nvoid Sema::SetDeclDeleted(Decl *Dcl, SourceLocation DelLoc) {\n  AdjustDeclIfTemplate(Dcl);\n\n  FunctionDecl *Fn = dyn_cast_or_null<FunctionDecl>(Dcl);\n  if (!Fn) {\n    Diag(DelLoc, diag::err_deleted_non_function);\n    return;\n  }\n\n  // Deleted function does not have a body.\n  Fn->setWillHaveBody(false);\n\n  if (const FunctionDecl *Prev = Fn->getPreviousDecl()) {\n    // Don't consider the implicit declaration we generate for explicit\n    // specializations. FIXME: Do not generate these implicit declarations.\n    if ((Prev->getTemplateSpecializationKind() != TSK_ExplicitSpecialization ||\n         Prev->getPreviousDecl()) &&\n        !Prev->isDefined()) {\n      Diag(DelLoc, diag::err_deleted_decl_not_first);\n      Diag(Prev->getLocation().isInvalid() ? DelLoc : Prev->getLocation(),\n           Prev->isImplicit() ? diag::note_previous_implicit_declaration\n                              : diag::note_previous_declaration);\n      // We can't recover from this; the declaration might have already\n      // been used.\n      Fn->setInvalidDecl();\n      return;\n    }\n\n    // To maintain the invariant that functions are only deleted on their first\n    // declaration, mark the implicitly-instantiated declaration of the\n    // explicitly-specialized function as deleted instead of marking the\n    // instantiated redeclaration.\n    Fn = Fn->getCanonicalDecl();\n  }\n\n  // dllimport/dllexport cannot be deleted.\n  if (const InheritableAttr *DLLAttr = getDLLAttr(Fn)) {\n    Diag(Fn->getLocation(), diag::err_attribute_dll_deleted) << DLLAttr;\n    Fn->setInvalidDecl();\n  }\n\n  // C++11 [basic.start.main]p3:\n  //   A program that defines main as deleted [...] is ill-formed.\n  if (Fn->isMain())\n    Diag(DelLoc, diag::err_deleted_main);\n\n  // C++11 [dcl.fct.def.delete]p4:\n  //  A deleted function is implicitly inline.\n  Fn->setImplicitlyInline();\n  Fn->setDeletedAsWritten();\n}\n\nvoid Sema::SetDeclDefaulted(Decl *Dcl, SourceLocation DefaultLoc) {\n  if (!Dcl || Dcl->isInvalidDecl())\n    return;\n\n  auto *FD = dyn_cast<FunctionDecl>(Dcl);\n  if (!FD) {\n    if (auto *FTD = dyn_cast<FunctionTemplateDecl>(Dcl)) {\n      if (getDefaultedFunctionKind(FTD->getTemplatedDecl()).isComparison()) {\n        Diag(DefaultLoc, diag::err_defaulted_comparison_template);\n        return;\n      }\n    }\n\n    Diag(DefaultLoc, diag::err_default_special_members)\n        << getLangOpts().CPlusPlus20;\n    return;\n  }\n\n  // Reject if this can't possibly be a defaultable function.\n  DefaultedFunctionKind DefKind = getDefaultedFunctionKind(FD);\n  if (!DefKind &&\n      // A dependent function that doesn't locally look defaultable can\n      // still instantiate to a defaultable function if it's a constructor\n      // or assignment operator.\n      (!FD->isDependentContext() ||\n       (!isa<CXXConstructorDecl>(FD) &&\n        FD->getDeclName().getCXXOverloadedOperator() != OO_Equal))) {\n    Diag(DefaultLoc, diag::err_default_special_members)\n        << getLangOpts().CPlusPlus20;\n    return;\n  }\n\n  if (DefKind.isComparison() &&\n      !isa<CXXRecordDecl>(FD->getLexicalDeclContext())) {\n    Diag(FD->getLocation(), diag::err_defaulted_comparison_out_of_class)\n        << (int)DefKind.asComparison();\n    return;\n  }\n\n  // Issue compatibility warning. We already warned if the operator is\n  // 'operator<=>' when parsing the '<=>' token.\n  if (DefKind.isComparison() &&\n      DefKind.asComparison() != DefaultedComparisonKind::ThreeWay) {\n    Diag(DefaultLoc, getLangOpts().CPlusPlus20\n                         ? diag::warn_cxx17_compat_defaulted_comparison\n                         : diag::ext_defaulted_comparison);\n  }\n\n  FD->setDefaulted();\n  FD->setExplicitlyDefaulted();\n\n  // Defer checking functions that are defaulted in a dependent context.\n  if (FD->isDependentContext())\n    return;\n\n  // Unset that we will have a body for this function. We might not,\n  // if it turns out to be trivial, and we don't need this marking now\n  // that we've marked it as defaulted.\n  FD->setWillHaveBody(false);\n\n  // If this definition appears within the record, do the checking when\n  // the record is complete. This is always the case for a defaulted\n  // comparison.\n  if (DefKind.isComparison())\n    return;\n  auto *MD = cast<CXXMethodDecl>(FD);\n\n  const FunctionDecl *Primary = FD;\n  if (const FunctionDecl *Pattern = FD->getTemplateInstantiationPattern())\n    // Ask the template instantiation pattern that actually had the\n    // '= default' on it.\n    Primary = Pattern;\n\n  // If the method was defaulted on its first declaration, we will have\n  // already performed the checking in CheckCompletedCXXClass. Such a\n  // declaration doesn't trigger an implicit definition.\n  if (Primary->getCanonicalDecl()->isDefaulted())\n    return;\n\n  // FIXME: Once we support defining comparisons out of class, check for a\n  // defaulted comparison here.\n  if (CheckExplicitlyDefaultedSpecialMember(MD, DefKind.asSpecialMember()))\n    MD->setInvalidDecl();\n  else\n    DefineDefaultedFunction(*this, MD, DefaultLoc);\n}\n\nstatic void SearchForReturnInStmt(Sema &Self, Stmt *S) {\n  for (Stmt *SubStmt : S->children()) {\n    if (!SubStmt)\n      continue;\n    if (isa<ReturnStmt>(SubStmt))\n      Self.Diag(SubStmt->getBeginLoc(),\n                diag::err_return_in_constructor_handler);\n    if (!isa<Expr>(SubStmt))\n      SearchForReturnInStmt(Self, SubStmt);\n  }\n}\n\nvoid Sema::DiagnoseReturnInConstructorExceptionHandler(CXXTryStmt *TryBlock) {\n  for (unsigned I = 0, E = TryBlock->getNumHandlers(); I != E; ++I) {\n    CXXCatchStmt *Handler = TryBlock->getHandler(I);\n    SearchForReturnInStmt(*this, Handler);\n  }\n}\n\nbool Sema::CheckOverridingFunctionAttributes(const CXXMethodDecl *New,\n                                             const CXXMethodDecl *Old) {\n  const auto *NewFT = New->getType()->castAs<FunctionProtoType>();\n  const auto *OldFT = Old->getType()->castAs<FunctionProtoType>();\n\n  if (OldFT->hasExtParameterInfos()) {\n    for (unsigned I = 0, E = OldFT->getNumParams(); I != E; ++I)\n      // A parameter of the overriding method should be annotated with noescape\n      // if the corresponding parameter of the overridden method is annotated.\n      if (OldFT->getExtParameterInfo(I).isNoEscape() &&\n          !NewFT->getExtParameterInfo(I).isNoEscape()) {\n        Diag(New->getParamDecl(I)->getLocation(),\n             diag::warn_overriding_method_missing_noescape);\n        Diag(Old->getParamDecl(I)->getLocation(),\n             diag::note_overridden_marked_noescape);\n      }\n  }\n\n  // Virtual overrides must have the same code_seg.\n  const auto *OldCSA = Old->getAttr<CodeSegAttr>();\n  const auto *NewCSA = New->getAttr<CodeSegAttr>();\n  if ((NewCSA || OldCSA) &&\n      (!OldCSA || !NewCSA || NewCSA->getName() != OldCSA->getName())) {\n    Diag(New->getLocation(), diag::err_mismatched_code_seg_override);\n    Diag(Old->getLocation(), diag::note_previous_declaration);\n    return true;\n  }\n\n  CallingConv NewCC = NewFT->getCallConv(), OldCC = OldFT->getCallConv();\n\n  // If the calling conventions match, everything is fine\n  if (NewCC == OldCC)\n    return false;\n\n  // If the calling conventions mismatch because the new function is static,\n  // suppress the calling convention mismatch error; the error about static\n  // function override (err_static_overrides_virtual from\n  // Sema::CheckFunctionDeclaration) is more clear.\n  if (New->getStorageClass() == SC_Static)\n    return false;\n\n  Diag(New->getLocation(),\n       diag::err_conflicting_overriding_cc_attributes)\n    << New->getDeclName() << New->getType() << Old->getType();\n  Diag(Old->getLocation(), diag::note_overridden_virtual_function);\n  return true;\n}\n\nbool Sema::CheckOverridingFunctionReturnType(const CXXMethodDecl *New,\n                                             const CXXMethodDecl *Old) {\n  QualType NewTy = New->getType()->castAs<FunctionType>()->getReturnType();\n  QualType OldTy = Old->getType()->castAs<FunctionType>()->getReturnType();\n\n  if (Context.hasSameType(NewTy, OldTy) ||\n      NewTy->isDependentType() || OldTy->isDependentType())\n    return false;\n\n  // Check if the return types are covariant\n  QualType NewClassTy, OldClassTy;\n\n  /// Both types must be pointers or references to classes.\n  if (const PointerType *NewPT = NewTy->getAs<PointerType>()) {\n    if (const PointerType *OldPT = OldTy->getAs<PointerType>()) {\n      NewClassTy = NewPT->getPointeeType();\n      OldClassTy = OldPT->getPointeeType();\n    }\n  } else if (const ReferenceType *NewRT = NewTy->getAs<ReferenceType>()) {\n    if (const ReferenceType *OldRT = OldTy->getAs<ReferenceType>()) {\n      if (NewRT->getTypeClass() == OldRT->getTypeClass()) {\n        NewClassTy = NewRT->getPointeeType();\n        OldClassTy = OldRT->getPointeeType();\n      }\n    }\n  }\n\n  // The return types aren't either both pointers or references to a class type.\n  if (NewClassTy.isNull()) {\n    Diag(New->getLocation(),\n         diag::err_different_return_type_for_overriding_virtual_function)\n        << New->getDeclName() << NewTy << OldTy\n        << New->getReturnTypeSourceRange();\n    Diag(Old->getLocation(), diag::note_overridden_virtual_function)\n        << Old->getReturnTypeSourceRange();\n\n    return true;\n  }\n\n  if (!Context.hasSameUnqualifiedType(NewClassTy, OldClassTy)) {\n    // C++14 [class.virtual]p8:\n    //   If the class type in the covariant return type of D::f differs from\n    //   that of B::f, the class type in the return type of D::f shall be\n    //   complete at the point of declaration of D::f or shall be the class\n    //   type D.\n    if (const RecordType *RT = NewClassTy->getAs<RecordType>()) {\n      if (!RT->isBeingDefined() &&\n          RequireCompleteType(New->getLocation(), NewClassTy,\n                              diag::err_covariant_return_incomplete,\n                              New->getDeclName()))\n        return true;\n    }\n\n    // Check if the new class derives from the old class.\n    if (!IsDerivedFrom(New->getLocation(), NewClassTy, OldClassTy)) {\n      Diag(New->getLocation(), diag::err_covariant_return_not_derived)\n          << New->getDeclName() << NewTy << OldTy\n          << New->getReturnTypeSourceRange();\n      Diag(Old->getLocation(), diag::note_overridden_virtual_function)\n          << Old->getReturnTypeSourceRange();\n      return true;\n    }\n\n    // Check if we the conversion from derived to base is valid.\n    if (CheckDerivedToBaseConversion(\n            NewClassTy, OldClassTy,\n            diag::err_covariant_return_inaccessible_base,\n            diag::err_covariant_return_ambiguous_derived_to_base_conv,\n            New->getLocation(), New->getReturnTypeSourceRange(),\n            New->getDeclName(), nullptr)) {\n      // FIXME: this note won't trigger for delayed access control\n      // diagnostics, and it's impossible to get an undelayed error\n      // here from access control during the original parse because\n      // the ParsingDeclSpec/ParsingDeclarator are still in scope.\n      Diag(Old->getLocation(), diag::note_overridden_virtual_function)\n          << Old->getReturnTypeSourceRange();\n      return true;\n    }\n  }\n\n  // The qualifiers of the return types must be the same.\n  if (NewTy.getLocalCVRQualifiers() != OldTy.getLocalCVRQualifiers()) {\n    Diag(New->getLocation(),\n         diag::err_covariant_return_type_different_qualifications)\n        << New->getDeclName() << NewTy << OldTy\n        << New->getReturnTypeSourceRange();\n    Diag(Old->getLocation(), diag::note_overridden_virtual_function)\n        << Old->getReturnTypeSourceRange();\n    return true;\n  }\n\n\n  // The new class type must have the same or less qualifiers as the old type.\n  if (NewClassTy.isMoreQualifiedThan(OldClassTy)) {\n    Diag(New->getLocation(),\n         diag::err_covariant_return_type_class_type_more_qualified)\n        << New->getDeclName() << NewTy << OldTy\n        << New->getReturnTypeSourceRange();\n    Diag(Old->getLocation(), diag::note_overridden_virtual_function)\n        << Old->getReturnTypeSourceRange();\n    return true;\n  }\n\n  return false;\n}\n\n/// Mark the given method pure.\n///\n/// \\param Method the method to be marked pure.\n///\n/// \\param InitRange the source range that covers the \"0\" initializer.\nbool Sema::CheckPureMethod(CXXMethodDecl *Method, SourceRange InitRange) {\n  SourceLocation EndLoc = InitRange.getEnd();\n  if (EndLoc.isValid())\n    Method->setRangeEnd(EndLoc);\n\n  if (Method->isVirtual() || Method->getParent()->isDependentContext()) {\n    Method->setPure();\n    return false;\n  }\n\n  if (!Method->isInvalidDecl())\n    Diag(Method->getLocation(), diag::err_non_virtual_pure)\n      << Method->getDeclName() << InitRange;\n  return true;\n}\n\nvoid Sema::ActOnPureSpecifier(Decl *D, SourceLocation ZeroLoc) {\n  if (D->getFriendObjectKind())\n    Diag(D->getLocation(), diag::err_pure_friend);\n  else if (auto *M = dyn_cast<CXXMethodDecl>(D))\n    CheckPureMethod(M, ZeroLoc);\n  else\n    Diag(D->getLocation(), diag::err_illegal_initializer);\n}\n\n/// Determine whether the given declaration is a global variable or\n/// static data member.\nstatic bool isNonlocalVariable(const Decl *D) {\n  if (const VarDecl *Var = dyn_cast_or_null<VarDecl>(D))\n    return Var->hasGlobalStorage();\n\n  return false;\n}\n\n/// Invoked when we are about to parse an initializer for the declaration\n/// 'Dcl'.\n///\n/// After this method is called, according to [C++ 3.4.1p13], if 'Dcl' is a\n/// static data member of class X, names should be looked up in the scope of\n/// class X. If the declaration had a scope specifier, a scope will have\n/// been created and passed in for this purpose. Otherwise, S will be null.\nvoid Sema::ActOnCXXEnterDeclInitializer(Scope *S, Decl *D) {\n  // If there is no declaration, there was an error parsing it.\n  if (!D || D->isInvalidDecl())\n    return;\n\n  // We will always have a nested name specifier here, but this declaration\n  // might not be out of line if the specifier names the current namespace:\n  //   extern int n;\n  //   int ::n = 0;\n  if (S && D->isOutOfLine())\n    EnterDeclaratorContext(S, D->getDeclContext());\n\n  // If we are parsing the initializer for a static data member, push a\n  // new expression evaluation context that is associated with this static\n  // data member.\n  if (isNonlocalVariable(D))\n    PushExpressionEvaluationContext(\n        ExpressionEvaluationContext::PotentiallyEvaluated, D);\n}\n\n/// Invoked after we are finished parsing an initializer for the declaration D.\nvoid Sema::ActOnCXXExitDeclInitializer(Scope *S, Decl *D) {\n  // If there is no declaration, there was an error parsing it.\n  if (!D || D->isInvalidDecl())\n    return;\n\n  if (isNonlocalVariable(D))\n    PopExpressionEvaluationContext();\n\n  if (S && D->isOutOfLine())\n    ExitDeclaratorContext(S);\n}\n\n/// ActOnCXXConditionDeclarationExpr - Parsed a condition declaration of a\n/// C++ if/switch/while/for statement.\n/// e.g: \"if (int x = f()) {...}\"\nDeclResult Sema::ActOnCXXConditionDeclaration(Scope *S, Declarator &D) {\n  // C++ 6.4p2:\n  // The declarator shall not specify a function or an array.\n  // The type-specifier-seq shall not contain typedef and shall not declare a\n  // new class or enumeration.\n  assert(D.getDeclSpec().getStorageClassSpec() != DeclSpec::SCS_typedef &&\n         \"Parser allowed 'typedef' as storage class of condition decl.\");\n\n  Decl *Dcl = ActOnDeclarator(S, D);\n  if (!Dcl)\n    return true;\n\n  if (isa<FunctionDecl>(Dcl)) { // The declarator shall not specify a function.\n    Diag(Dcl->getLocation(), diag::err_invalid_use_of_function_type)\n      << D.getSourceRange();\n    return true;\n  }\n\n  return Dcl;\n}\n\nvoid Sema::LoadExternalVTableUses() {\n  if (!ExternalSource)\n    return;\n\n  SmallVector<ExternalVTableUse, 4> VTables;\n  ExternalSource->ReadUsedVTables(VTables);\n  SmallVector<VTableUse, 4> NewUses;\n  for (unsigned I = 0, N = VTables.size(); I != N; ++I) {\n    llvm::DenseMap<CXXRecordDecl *, bool>::iterator Pos\n      = VTablesUsed.find(VTables[I].Record);\n    // Even if a definition wasn't required before, it may be required now.\n    if (Pos != VTablesUsed.end()) {\n      if (!Pos->second && VTables[I].DefinitionRequired)\n        Pos->second = true;\n      continue;\n    }\n\n    VTablesUsed[VTables[I].Record] = VTables[I].DefinitionRequired;\n    NewUses.push_back(VTableUse(VTables[I].Record, VTables[I].Location));\n  }\n\n  VTableUses.insert(VTableUses.begin(), NewUses.begin(), NewUses.end());\n}\n\nvoid Sema::MarkVTableUsed(SourceLocation Loc, CXXRecordDecl *Class,\n                          bool DefinitionRequired) {\n  // Ignore any vtable uses in unevaluated operands or for classes that do\n  // not have a vtable.\n  if (!Class->isDynamicClass() || Class->isDependentContext() ||\n      CurContext->isDependentContext() || isUnevaluatedContext())\n    return;\n  // Do not mark as used if compiling for the device outside of the target\n  // region.\n  if (TUKind != TU_Prefix && LangOpts.OpenMP && LangOpts.OpenMPIsDevice &&\n      !isInOpenMPDeclareTargetContext() &&\n      !isInOpenMPTargetExecutionDirective()) {\n    if (!DefinitionRequired)\n      MarkVirtualMembersReferenced(Loc, Class);\n    return;\n  }\n\n  // Try to insert this class into the map.\n  LoadExternalVTableUses();\n  Class = Class->getCanonicalDecl();\n  std::pair<llvm::DenseMap<CXXRecordDecl *, bool>::iterator, bool>\n    Pos = VTablesUsed.insert(std::make_pair(Class, DefinitionRequired));\n  if (!Pos.second) {\n    // If we already had an entry, check to see if we are promoting this vtable\n    // to require a definition. If so, we need to reappend to the VTableUses\n    // list, since we may have already processed the first entry.\n    if (DefinitionRequired && !Pos.first->second) {\n      Pos.first->second = true;\n    } else {\n      // Otherwise, we can early exit.\n      return;\n    }\n  } else {\n    // The Microsoft ABI requires that we perform the destructor body\n    // checks (i.e. operator delete() lookup) when the vtable is marked used, as\n    // the deleting destructor is emitted with the vtable, not with the\n    // destructor definition as in the Itanium ABI.\n    if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n      CXXDestructorDecl *DD = Class->getDestructor();\n      if (DD && DD->isVirtual() && !DD->isDeleted()) {\n        if (Class->hasUserDeclaredDestructor() && !DD->isDefined()) {\n          // If this is an out-of-line declaration, marking it referenced will\n          // not do anything. Manually call CheckDestructor to look up operator\n          // delete().\n          ContextRAII SavedContext(*this, DD);\n          CheckDestructor(DD);\n        } else {\n          MarkFunctionReferenced(Loc, Class->getDestructor());\n        }\n      }\n    }\n  }\n\n  // Local classes need to have their virtual members marked\n  // immediately. For all other classes, we mark their virtual members\n  // at the end of the translation unit.\n  if (Class->isLocalClass())\n    MarkVirtualMembersReferenced(Loc, Class);\n  else\n    VTableUses.push_back(std::make_pair(Class, Loc));\n}\n\nbool Sema::DefineUsedVTables() {\n  LoadExternalVTableUses();\n  if (VTableUses.empty())\n    return false;\n\n  // Note: The VTableUses vector could grow as a result of marking\n  // the members of a class as \"used\", so we check the size each\n  // time through the loop and prefer indices (which are stable) to\n  // iterators (which are not).\n  bool DefinedAnything = false;\n  for (unsigned I = 0; I != VTableUses.size(); ++I) {\n    CXXRecordDecl *Class = VTableUses[I].first->getDefinition();\n    if (!Class)\n      continue;\n    TemplateSpecializationKind ClassTSK =\n        Class->getTemplateSpecializationKind();\n\n    SourceLocation Loc = VTableUses[I].second;\n\n    bool DefineVTable = true;\n\n    // If this class has a key function, but that key function is\n    // defined in another translation unit, we don't need to emit the\n    // vtable even though we're using it.\n    const CXXMethodDecl *KeyFunction = Context.getCurrentKeyFunction(Class);\n    if (KeyFunction && !KeyFunction->hasBody()) {\n      // The key function is in another translation unit.\n      DefineVTable = false;\n      TemplateSpecializationKind TSK =\n          KeyFunction->getTemplateSpecializationKind();\n      assert(TSK != TSK_ExplicitInstantiationDefinition &&\n             TSK != TSK_ImplicitInstantiation &&\n             \"Instantiations don't have key functions\");\n      (void)TSK;\n    } else if (!KeyFunction) {\n      // If we have a class with no key function that is the subject\n      // of an explicit instantiation declaration, suppress the\n      // vtable; it will live with the explicit instantiation\n      // definition.\n      bool IsExplicitInstantiationDeclaration =\n          ClassTSK == TSK_ExplicitInstantiationDeclaration;\n      for (auto R : Class->redecls()) {\n        TemplateSpecializationKind TSK\n          = cast<CXXRecordDecl>(R)->getTemplateSpecializationKind();\n        if (TSK == TSK_ExplicitInstantiationDeclaration)\n          IsExplicitInstantiationDeclaration = true;\n        else if (TSK == TSK_ExplicitInstantiationDefinition) {\n          IsExplicitInstantiationDeclaration = false;\n          break;\n        }\n      }\n\n      if (IsExplicitInstantiationDeclaration)\n        DefineVTable = false;\n    }\n\n    // The exception specifications for all virtual members may be needed even\n    // if we are not providing an authoritative form of the vtable in this TU.\n    // We may choose to emit it available_externally anyway.\n    if (!DefineVTable) {\n      MarkVirtualMemberExceptionSpecsNeeded(Loc, Class);\n      continue;\n    }\n\n    // Mark all of the virtual members of this class as referenced, so\n    // that we can build a vtable. Then, tell the AST consumer that a\n    // vtable for this class is required.\n    DefinedAnything = true;\n    MarkVirtualMembersReferenced(Loc, Class);\n    CXXRecordDecl *Canonical = Class->getCanonicalDecl();\n    if (VTablesUsed[Canonical])\n      Consumer.HandleVTable(Class);\n\n    // Warn if we're emitting a weak vtable. The vtable will be weak if there is\n    // no key function or the key function is inlined. Don't warn in C++ ABIs\n    // that lack key functions, since the user won't be able to make one.\n    if (Context.getTargetInfo().getCXXABI().hasKeyFunctions() &&\n        Class->isExternallyVisible() && ClassTSK != TSK_ImplicitInstantiation) {\n      const FunctionDecl *KeyFunctionDef = nullptr;\n      if (!KeyFunction || (KeyFunction->hasBody(KeyFunctionDef) &&\n                           KeyFunctionDef->isInlined())) {\n        Diag(Class->getLocation(),\n             ClassTSK == TSK_ExplicitInstantiationDefinition\n                 ? diag::warn_weak_template_vtable\n                 : diag::warn_weak_vtable)\n            << Class;\n      }\n    }\n  }\n  VTableUses.clear();\n\n  return DefinedAnything;\n}\n\nvoid Sema::MarkVirtualMemberExceptionSpecsNeeded(SourceLocation Loc,\n                                                 const CXXRecordDecl *RD) {\n  for (const auto *I : RD->methods())\n    if (I->isVirtual() && !I->isPure())\n      ResolveExceptionSpec(Loc, I->getType()->castAs<FunctionProtoType>());\n}\n\nvoid Sema::MarkVirtualMembersReferenced(SourceLocation Loc,\n                                        const CXXRecordDecl *RD,\n                                        bool ConstexprOnly) {\n  // Mark all functions which will appear in RD's vtable as used.\n  CXXFinalOverriderMap FinalOverriders;\n  RD->getFinalOverriders(FinalOverriders);\n  for (CXXFinalOverriderMap::const_iterator I = FinalOverriders.begin(),\n                                            E = FinalOverriders.end();\n       I != E; ++I) {\n    for (OverridingMethods::const_iterator OI = I->second.begin(),\n                                           OE = I->second.end();\n         OI != OE; ++OI) {\n      assert(OI->second.size() > 0 && \"no final overrider\");\n      CXXMethodDecl *Overrider = OI->second.front().Method;\n\n      // C++ [basic.def.odr]p2:\n      //   [...] A virtual member function is used if it is not pure. [...]\n      if (!Overrider->isPure() && (!ConstexprOnly || Overrider->isConstexpr()))\n        MarkFunctionReferenced(Loc, Overrider);\n    }\n  }\n\n  // Only classes that have virtual bases need a VTT.\n  if (RD->getNumVBases() == 0)\n    return;\n\n  for (const auto &I : RD->bases()) {\n    const auto *Base =\n        cast<CXXRecordDecl>(I.getType()->castAs<RecordType>()->getDecl());\n    if (Base->getNumVBases() == 0)\n      continue;\n    MarkVirtualMembersReferenced(Loc, Base);\n  }\n}\n\n/// SetIvarInitializers - This routine builds initialization ASTs for the\n/// Objective-C implementation whose ivars need be initialized.\nvoid Sema::SetIvarInitializers(ObjCImplementationDecl *ObjCImplementation) {\n  if (!getLangOpts().CPlusPlus)\n    return;\n  if (ObjCInterfaceDecl *OID = ObjCImplementation->getClassInterface()) {\n    SmallVector<ObjCIvarDecl*, 8> ivars;\n    CollectIvarsToConstructOrDestruct(OID, ivars);\n    if (ivars.empty())\n      return;\n    SmallVector<CXXCtorInitializer*, 32> AllToInit;\n    for (unsigned i = 0; i < ivars.size(); i++) {\n      FieldDecl *Field = ivars[i];\n      if (Field->isInvalidDecl())\n        continue;\n\n      CXXCtorInitializer *Member;\n      InitializedEntity InitEntity = InitializedEntity::InitializeMember(Field);\n      InitializationKind InitKind =\n        InitializationKind::CreateDefault(ObjCImplementation->getLocation());\n\n      InitializationSequence InitSeq(*this, InitEntity, InitKind, None);\n      ExprResult MemberInit =\n        InitSeq.Perform(*this, InitEntity, InitKind, None);\n      MemberInit = MaybeCreateExprWithCleanups(MemberInit);\n      // Note, MemberInit could actually come back empty if no initialization\n      // is required (e.g., because it would call a trivial default constructor)\n      if (!MemberInit.get() || MemberInit.isInvalid())\n        continue;\n\n      Member =\n        new (Context) CXXCtorInitializer(Context, Field, SourceLocation(),\n                                         SourceLocation(),\n                                         MemberInit.getAs<Expr>(),\n                                         SourceLocation());\n      AllToInit.push_back(Member);\n\n      // Be sure that the destructor is accessible and is marked as referenced.\n      if (const RecordType *RecordTy =\n              Context.getBaseElementType(Field->getType())\n                  ->getAs<RecordType>()) {\n        CXXRecordDecl *RD = cast<CXXRecordDecl>(RecordTy->getDecl());\n        if (CXXDestructorDecl *Destructor = LookupDestructor(RD)) {\n          MarkFunctionReferenced(Field->getLocation(), Destructor);\n          CheckDestructorAccess(Field->getLocation(), Destructor,\n                            PDiag(diag::err_access_dtor_ivar)\n                              << Context.getBaseElementType(Field->getType()));\n        }\n      }\n    }\n    ObjCImplementation->setIvarInitializers(Context,\n                                            AllToInit.data(), AllToInit.size());\n  }\n}\n\nstatic\nvoid DelegatingCycleHelper(CXXConstructorDecl* Ctor,\n                           llvm::SmallPtrSet<CXXConstructorDecl*, 4> &Valid,\n                           llvm::SmallPtrSet<CXXConstructorDecl*, 4> &Invalid,\n                           llvm::SmallPtrSet<CXXConstructorDecl*, 4> &Current,\n                           Sema &S) {\n  if (Ctor->isInvalidDecl())\n    return;\n\n  CXXConstructorDecl *Target = Ctor->getTargetConstructor();\n\n  // Target may not be determinable yet, for instance if this is a dependent\n  // call in an uninstantiated template.\n  if (Target) {\n    const FunctionDecl *FNTarget = nullptr;\n    (void)Target->hasBody(FNTarget);\n    Target = const_cast<CXXConstructorDecl*>(\n      cast_or_null<CXXConstructorDecl>(FNTarget));\n  }\n\n  CXXConstructorDecl *Canonical = Ctor->getCanonicalDecl(),\n                     // Avoid dereferencing a null pointer here.\n                     *TCanonical = Target? Target->getCanonicalDecl() : nullptr;\n\n  if (!Current.insert(Canonical).second)\n    return;\n\n  // We know that beyond here, we aren't chaining into a cycle.\n  if (!Target || !Target->isDelegatingConstructor() ||\n      Target->isInvalidDecl() || Valid.count(TCanonical)) {\n    Valid.insert(Current.begin(), Current.end());\n    Current.clear();\n  // We've hit a cycle.\n  } else if (TCanonical == Canonical || Invalid.count(TCanonical) ||\n             Current.count(TCanonical)) {\n    // If we haven't diagnosed this cycle yet, do so now.\n    if (!Invalid.count(TCanonical)) {\n      S.Diag((*Ctor->init_begin())->getSourceLocation(),\n             diag::warn_delegating_ctor_cycle)\n        << Ctor;\n\n      // Don't add a note for a function delegating directly to itself.\n      if (TCanonical != Canonical)\n        S.Diag(Target->getLocation(), diag::note_it_delegates_to);\n\n      CXXConstructorDecl *C = Target;\n      while (C->getCanonicalDecl() != Canonical) {\n        const FunctionDecl *FNTarget = nullptr;\n        (void)C->getTargetConstructor()->hasBody(FNTarget);\n        assert(FNTarget && \"Ctor cycle through bodiless function\");\n\n        C = const_cast<CXXConstructorDecl*>(\n          cast<CXXConstructorDecl>(FNTarget));\n        S.Diag(C->getLocation(), diag::note_which_delegates_to);\n      }\n    }\n\n    Invalid.insert(Current.begin(), Current.end());\n    Current.clear();\n  } else {\n    DelegatingCycleHelper(Target, Valid, Invalid, Current, S);\n  }\n}\n\n\nvoid Sema::CheckDelegatingCtorCycles() {\n  llvm::SmallPtrSet<CXXConstructorDecl*, 4> Valid, Invalid, Current;\n\n  for (DelegatingCtorDeclsType::iterator\n         I = DelegatingCtorDecls.begin(ExternalSource),\n         E = DelegatingCtorDecls.end();\n       I != E; ++I)\n    DelegatingCycleHelper(*I, Valid, Invalid, Current, *this);\n\n  for (auto CI = Invalid.begin(), CE = Invalid.end(); CI != CE; ++CI)\n    (*CI)->setInvalidDecl();\n}\n\nnamespace {\n  /// AST visitor that finds references to the 'this' expression.\n  class FindCXXThisExpr : public RecursiveASTVisitor<FindCXXThisExpr> {\n    Sema &S;\n\n  public:\n    explicit FindCXXThisExpr(Sema &S) : S(S) { }\n\n    bool VisitCXXThisExpr(CXXThisExpr *E) {\n      S.Diag(E->getLocation(), diag::err_this_static_member_func)\n        << E->isImplicit();\n      return false;\n    }\n  };\n}\n\nbool Sema::checkThisInStaticMemberFunctionType(CXXMethodDecl *Method) {\n  TypeSourceInfo *TSInfo = Method->getTypeSourceInfo();\n  if (!TSInfo)\n    return false;\n\n  TypeLoc TL = TSInfo->getTypeLoc();\n  FunctionProtoTypeLoc ProtoTL = TL.getAs<FunctionProtoTypeLoc>();\n  if (!ProtoTL)\n    return false;\n\n  // C++11 [expr.prim.general]p3:\n  //   [The expression this] shall not appear before the optional\n  //   cv-qualifier-seq and it shall not appear within the declaration of a\n  //   static member function (although its type and value category are defined\n  //   within a static member function as they are within a non-static member\n  //   function). [ Note: this is because declaration matching does not occur\n  //  until the complete declarator is known. - end note ]\n  const FunctionProtoType *Proto = ProtoTL.getTypePtr();\n  FindCXXThisExpr Finder(*this);\n\n  // If the return type came after the cv-qualifier-seq, check it now.\n  if (Proto->hasTrailingReturn() &&\n      !Finder.TraverseTypeLoc(ProtoTL.getReturnLoc()))\n    return true;\n\n  // Check the exception specification.\n  if (checkThisInStaticMemberFunctionExceptionSpec(Method))\n    return true;\n\n  // Check the trailing requires clause\n  if (Expr *E = Method->getTrailingRequiresClause())\n    if (!Finder.TraverseStmt(E))\n      return true;\n\n  return checkThisInStaticMemberFunctionAttributes(Method);\n}\n\nbool Sema::checkThisInStaticMemberFunctionExceptionSpec(CXXMethodDecl *Method) {\n  TypeSourceInfo *TSInfo = Method->getTypeSourceInfo();\n  if (!TSInfo)\n    return false;\n\n  TypeLoc TL = TSInfo->getTypeLoc();\n  FunctionProtoTypeLoc ProtoTL = TL.getAs<FunctionProtoTypeLoc>();\n  if (!ProtoTL)\n    return false;\n\n  const FunctionProtoType *Proto = ProtoTL.getTypePtr();\n  FindCXXThisExpr Finder(*this);\n\n  switch (Proto->getExceptionSpecType()) {\n  case EST_Unparsed:\n  case EST_Uninstantiated:\n  case EST_Unevaluated:\n  case EST_BasicNoexcept:\n  case EST_NoThrow:\n  case EST_DynamicNone:\n  case EST_MSAny:\n  case EST_None:\n    break;\n\n  case EST_DependentNoexcept:\n  case EST_NoexceptFalse:\n  case EST_NoexceptTrue:\n    if (!Finder.TraverseStmt(Proto->getNoexceptExpr()))\n      return true;\n    LLVM_FALLTHROUGH;\n\n  case EST_Dynamic:\n    for (const auto &E : Proto->exceptions()) {\n      if (!Finder.TraverseType(E))\n        return true;\n    }\n    break;\n  }\n\n  return false;\n}\n\nbool Sema::checkThisInStaticMemberFunctionAttributes(CXXMethodDecl *Method) {\n  FindCXXThisExpr Finder(*this);\n\n  // Check attributes.\n  for (const auto *A : Method->attrs()) {\n    // FIXME: This should be emitted by tblgen.\n    Expr *Arg = nullptr;\n    ArrayRef<Expr *> Args;\n    if (const auto *G = dyn_cast<GuardedByAttr>(A))\n      Arg = G->getArg();\n    else if (const auto *G = dyn_cast<PtGuardedByAttr>(A))\n      Arg = G->getArg();\n    else if (const auto *AA = dyn_cast<AcquiredAfterAttr>(A))\n      Args = llvm::makeArrayRef(AA->args_begin(), AA->args_size());\n    else if (const auto *AB = dyn_cast<AcquiredBeforeAttr>(A))\n      Args = llvm::makeArrayRef(AB->args_begin(), AB->args_size());\n    else if (const auto *ETLF = dyn_cast<ExclusiveTrylockFunctionAttr>(A)) {\n      Arg = ETLF->getSuccessValue();\n      Args = llvm::makeArrayRef(ETLF->args_begin(), ETLF->args_size());\n    } else if (const auto *STLF = dyn_cast<SharedTrylockFunctionAttr>(A)) {\n      Arg = STLF->getSuccessValue();\n      Args = llvm::makeArrayRef(STLF->args_begin(), STLF->args_size());\n    } else if (const auto *LR = dyn_cast<LockReturnedAttr>(A))\n      Arg = LR->getArg();\n    else if (const auto *LE = dyn_cast<LocksExcludedAttr>(A))\n      Args = llvm::makeArrayRef(LE->args_begin(), LE->args_size());\n    else if (const auto *RC = dyn_cast<RequiresCapabilityAttr>(A))\n      Args = llvm::makeArrayRef(RC->args_begin(), RC->args_size());\n    else if (const auto *AC = dyn_cast<AcquireCapabilityAttr>(A))\n      Args = llvm::makeArrayRef(AC->args_begin(), AC->args_size());\n    else if (const auto *AC = dyn_cast<TryAcquireCapabilityAttr>(A))\n      Args = llvm::makeArrayRef(AC->args_begin(), AC->args_size());\n    else if (const auto *RC = dyn_cast<ReleaseCapabilityAttr>(A))\n      Args = llvm::makeArrayRef(RC->args_begin(), RC->args_size());\n\n    if (Arg && !Finder.TraverseStmt(Arg))\n      return true;\n\n    for (unsigned I = 0, N = Args.size(); I != N; ++I) {\n      if (!Finder.TraverseStmt(Args[I]))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nvoid Sema::checkExceptionSpecification(\n    bool IsTopLevel, ExceptionSpecificationType EST,\n    ArrayRef<ParsedType> DynamicExceptions,\n    ArrayRef<SourceRange> DynamicExceptionRanges, Expr *NoexceptExpr,\n    SmallVectorImpl<QualType> &Exceptions,\n    FunctionProtoType::ExceptionSpecInfo &ESI) {\n  Exceptions.clear();\n  ESI.Type = EST;\n  if (EST == EST_Dynamic) {\n    Exceptions.reserve(DynamicExceptions.size());\n    for (unsigned ei = 0, ee = DynamicExceptions.size(); ei != ee; ++ei) {\n      // FIXME: Preserve type source info.\n      QualType ET = GetTypeFromParser(DynamicExceptions[ei]);\n\n      if (IsTopLevel) {\n        SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n        collectUnexpandedParameterPacks(ET, Unexpanded);\n        if (!Unexpanded.empty()) {\n          DiagnoseUnexpandedParameterPacks(\n              DynamicExceptionRanges[ei].getBegin(), UPPC_ExceptionType,\n              Unexpanded);\n          continue;\n        }\n      }\n\n      // Check that the type is valid for an exception spec, and\n      // drop it if not.\n      if (!CheckSpecifiedExceptionType(ET, DynamicExceptionRanges[ei]))\n        Exceptions.push_back(ET);\n    }\n    ESI.Exceptions = Exceptions;\n    return;\n  }\n\n  if (isComputedNoexcept(EST)) {\n    assert((NoexceptExpr->isTypeDependent() ||\n            NoexceptExpr->getType()->getCanonicalTypeUnqualified() ==\n            Context.BoolTy) &&\n           \"Parser should have made sure that the expression is boolean\");\n    if (IsTopLevel && DiagnoseUnexpandedParameterPack(NoexceptExpr)) {\n      ESI.Type = EST_BasicNoexcept;\n      return;\n    }\n\n    ESI.NoexceptExpr = NoexceptExpr;\n    return;\n  }\n}\n\nvoid Sema::actOnDelayedExceptionSpecification(Decl *MethodD,\n             ExceptionSpecificationType EST,\n             SourceRange SpecificationRange,\n             ArrayRef<ParsedType> DynamicExceptions,\n             ArrayRef<SourceRange> DynamicExceptionRanges,\n             Expr *NoexceptExpr) {\n  if (!MethodD)\n    return;\n\n  // Dig out the method we're referring to.\n  if (FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(MethodD))\n    MethodD = FunTmpl->getTemplatedDecl();\n\n  CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(MethodD);\n  if (!Method)\n    return;\n\n  // Check the exception specification.\n  llvm::SmallVector<QualType, 4> Exceptions;\n  FunctionProtoType::ExceptionSpecInfo ESI;\n  checkExceptionSpecification(/*IsTopLevel*/true, EST, DynamicExceptions,\n                              DynamicExceptionRanges, NoexceptExpr, Exceptions,\n                              ESI);\n\n  // Update the exception specification on the function type.\n  Context.adjustExceptionSpec(Method, ESI, /*AsWritten*/true);\n\n  if (Method->isStatic())\n    checkThisInStaticMemberFunctionExceptionSpec(Method);\n\n  if (Method->isVirtual()) {\n    // Check overrides, which we previously had to delay.\n    for (const CXXMethodDecl *O : Method->overridden_methods())\n      CheckOverridingFunctionExceptionSpec(Method, O);\n  }\n}\n\n/// HandleMSProperty - Analyze a __delcspec(property) field of a C++ class.\n///\nMSPropertyDecl *Sema::HandleMSProperty(Scope *S, RecordDecl *Record,\n                                       SourceLocation DeclStart, Declarator &D,\n                                       Expr *BitWidth,\n                                       InClassInitStyle InitStyle,\n                                       AccessSpecifier AS,\n                                       const ParsedAttr &MSPropertyAttr) {\n  IdentifierInfo *II = D.getIdentifier();\n  if (!II) {\n    Diag(DeclStart, diag::err_anonymous_property);\n    return nullptr;\n  }\n  SourceLocation Loc = D.getIdentifierLoc();\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType T = TInfo->getType();\n  if (getLangOpts().CPlusPlus) {\n    CheckExtraCXXDefaultArguments(D);\n\n    if (DiagnoseUnexpandedParameterPack(D.getIdentifierLoc(), TInfo,\n                                        UPPC_DataMemberType)) {\n      D.setInvalidType();\n      T = Context.IntTy;\n      TInfo = Context.getTrivialTypeSourceInfo(T, Loc);\n    }\n  }\n\n  DiagnoseFunctionSpecifiers(D.getDeclSpec());\n\n  if (D.getDeclSpec().isInlineSpecified())\n    Diag(D.getDeclSpec().getInlineSpecLoc(), diag::err_inline_non_function)\n        << getLangOpts().CPlusPlus17;\n  if (DeclSpec::TSCS TSCS = D.getDeclSpec().getThreadStorageClassSpec())\n    Diag(D.getDeclSpec().getThreadStorageClassSpecLoc(),\n         diag::err_invalid_thread)\n      << DeclSpec::getSpecifierName(TSCS);\n\n  // Check to see if this name was declared as a member previously\n  NamedDecl *PrevDecl = nullptr;\n  LookupResult Previous(*this, II, Loc, LookupMemberName,\n                        ForVisibleRedeclaration);\n  LookupName(Previous, S);\n  switch (Previous.getResultKind()) {\n  case LookupResult::Found:\n  case LookupResult::FoundUnresolvedValue:\n    PrevDecl = Previous.getAsSingle<NamedDecl>();\n    break;\n\n  case LookupResult::FoundOverloaded:\n    PrevDecl = Previous.getRepresentativeDecl();\n    break;\n\n  case LookupResult::NotFound:\n  case LookupResult::NotFoundInCurrentInstantiation:\n  case LookupResult::Ambiguous:\n    break;\n  }\n\n  if (PrevDecl && PrevDecl->isTemplateParameter()) {\n    // Maybe we will complain about the shadowed template parameter.\n    DiagnoseTemplateParameterShadow(D.getIdentifierLoc(), PrevDecl);\n    // Just pretend that we didn't see the previous declaration.\n    PrevDecl = nullptr;\n  }\n\n  if (PrevDecl && !isDeclInScope(PrevDecl, Record, S))\n    PrevDecl = nullptr;\n\n  SourceLocation TSSL = D.getBeginLoc();\n  MSPropertyDecl *NewPD =\n      MSPropertyDecl::Create(Context, Record, Loc, II, T, TInfo, TSSL,\n                             MSPropertyAttr.getPropertyDataGetter(),\n                             MSPropertyAttr.getPropertyDataSetter());\n  ProcessDeclAttributes(TUScope, NewPD, D);\n  NewPD->setAccess(AS);\n\n  if (NewPD->isInvalidDecl())\n    Record->setInvalidDecl();\n\n  if (D.getDeclSpec().isModulePrivateSpecified())\n    NewPD->setModulePrivate();\n\n  if (NewPD->isInvalidDecl() && PrevDecl) {\n    // Don't introduce NewFD into scope; there's already something\n    // with the same name in the same scope.\n  } else if (II) {\n    PushOnScopeChains(NewPD, S);\n  } else\n    Record->addDecl(NewPD);\n\n  return NewPD;\n}\n\nvoid Sema::ActOnStartFunctionDeclarationDeclarator(\n    Declarator &Declarator, unsigned TemplateParameterDepth) {\n  auto &Info = InventedParameterInfos.emplace_back();\n  TemplateParameterList *ExplicitParams = nullptr;\n  ArrayRef<TemplateParameterList *> ExplicitLists =\n      Declarator.getTemplateParameterLists();\n  if (!ExplicitLists.empty()) {\n    bool IsMemberSpecialization, IsInvalid;\n    ExplicitParams = MatchTemplateParametersToScopeSpecifier(\n        Declarator.getBeginLoc(), Declarator.getIdentifierLoc(),\n        Declarator.getCXXScopeSpec(), /*TemplateId=*/nullptr,\n        ExplicitLists, /*IsFriend=*/false, IsMemberSpecialization, IsInvalid,\n        /*SuppressDiagnostic=*/true);\n  }\n  if (ExplicitParams) {\n    Info.AutoTemplateParameterDepth = ExplicitParams->getDepth();\n    for (NamedDecl *Param : *ExplicitParams)\n      Info.TemplateParams.push_back(Param);\n    Info.NumExplicitTemplateParams = ExplicitParams->size();\n  } else {\n    Info.AutoTemplateParameterDepth = TemplateParameterDepth;\n    Info.NumExplicitTemplateParams = 0;\n  }\n}\n\nvoid Sema::ActOnFinishFunctionDeclarationDeclarator(Declarator &Declarator) {\n  auto &FSI = InventedParameterInfos.back();\n  if (FSI.TemplateParams.size() > FSI.NumExplicitTemplateParams) {\n    if (FSI.NumExplicitTemplateParams != 0) {\n      TemplateParameterList *ExplicitParams =\n          Declarator.getTemplateParameterLists().back();\n      Declarator.setInventedTemplateParameterList(\n          TemplateParameterList::Create(\n              Context, ExplicitParams->getTemplateLoc(),\n              ExplicitParams->getLAngleLoc(), FSI.TemplateParams,\n              ExplicitParams->getRAngleLoc(),\n              ExplicitParams->getRequiresClause()));\n    } else {\n      Declarator.setInventedTemplateParameterList(\n          TemplateParameterList::Create(\n              Context, SourceLocation(), SourceLocation(), FSI.TemplateParams,\n              SourceLocation(), /*RequiresClause=*/nullptr));\n    }\n  }\n  InventedParameterInfos.pop_back();\n}\n"}}, "reports": [{"events": [{"location": {"col": 26, "file": 20, "line": 997}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "2215abeff2dd08ed25ba593de43989f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 20, "line": 997}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "20d9cbd212b877f60ae8b61576557742", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 20, "line": 1296}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "eb4f6bbe135508781bf6abfb6b43de23", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 20, "line": 1296}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "736fc02c16953b33da2c14780ca3ae7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 20, "line": 1380}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "f7d2eae9f2557f07642f3e827c91b8d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 20, "line": 1380}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "7247abf70cc4afa884f5b82cfcfed835", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 20, "line": 1648}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "f5eeaee22c45ec27f50b7505c61e0bba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 20, "line": 1648}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "0cdb6aa0db4a3ba6fbb3b114d1538808", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 20, "line": 5990}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "5a10db66eb17bc233397e815a7f45c2e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 20, "line": 5990}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "1ea445afb5faaf43cc7b38a99b6a544f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 20, "line": 6044}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "5a10db66eb17bc233397e815a7f45c2e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 20, "line": 6044}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "1ea445afb5faaf43cc7b38a99b6a544f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 7564}, "message": "default constructor 'DefaultedComparisonInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "241efe8f3de005a14e05c0d5c4bbbfbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 7564}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "e565eef00bf3f2ddc3e80dc75d720e70", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 7564}, "message": "move constructor 'DefaultedComparisonInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "30b272de17710d468d91814edeb4ec7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 20, "line": 8116}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "f41687e0bea64cd1d6f04bb1dd7cb429", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 20, "line": 8116}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "5640acd2e4744df5efb32e324e48bc70", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 20, "line": 8135}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "793c19ea252702c9346c84eedf9803b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 20, "line": 8135}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "64aa06b4817c91f5c94bf2167c0765d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 20, "line": 8278}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "005f5199809020a025d8296322606e1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 20, "line": 8278}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "767f59e41234e02db127c2d6e8876af0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 13518}, "message": "destructor '~DerefBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "74739e2311daede3528bd897b89cc21c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 13550}, "message": "destructor '~MoveCastBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "0b54bcab809aa2c5deb572ca9f606b8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 13561}, "message": "destructor '~LvalueConvBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "2e5bb129a5a9a1c39294cff8f90ada6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 13573}, "message": "destructor '~SubscriptBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp", "reportHash": "a6b1153f5ed1f8cea4f5c695e7242bde", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
