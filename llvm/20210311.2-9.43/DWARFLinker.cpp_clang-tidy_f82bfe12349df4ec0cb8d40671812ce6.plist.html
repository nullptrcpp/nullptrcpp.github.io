<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "content": "//==- include/llvm/CodeGen/AccelTable.h - Accelerator Tables -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing accelerator tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_ACCELTABLE_H\n#define LLVM_CODEGEN_ACCELTABLE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/DJB.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\n/// The DWARF and Apple accelerator tables are an indirect hash table optimized\n/// for null lookup rather than access to known data. The Apple accelerator\n/// tables are a precursor of the newer DWARF v5 accelerator tables. Both\n/// formats share common design ideas.\n///\n/// The Apple accelerator table are output into an on-disk format that looks\n/// like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  BUCKETS         |\n/// |------------------|\n/// |  HASHES          |\n/// |------------------|\n/// |  OFFSETS         |\n/// |------------------|\n/// |  DATA            |\n/// `------------------'\n///\n/// The header contains a magic number, version, type of hash function,\n/// the number of buckets, total number of hashes, and room for a special struct\n/// of data and the length of that struct.\n///\n/// The buckets contain an index (e.g. 6) into the hashes array. The hashes\n/// section contains all of the 32-bit hash values in contiguous memory, and the\n/// offsets contain the offset into the data area for the particular hash.\n///\n/// For a lookup example, we could hash a function name and take it modulo the\n/// number of buckets giving us our bucket. From there we take the bucket value\n/// as an index into the hashes table and look at each successive hash as long\n/// as the hash value is still the same modulo result (bucket value) as earlier.\n/// If we have a match we look at that same entry in the offsets table and grab\n/// the offset in the data for our final match.\n///\n/// The DWARF v5 accelerator table consists of zero or more name indices that\n/// are output into an on-disk format that looks like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  CU LIST         |\n/// |------------------|\n/// |  LOCAL TU LIST   |\n/// |------------------|\n/// |  FOREIGN TU LIST |\n/// |------------------|\n/// |  HASH TABLE      |\n/// |------------------|\n/// |  NAME TABLE      |\n/// |------------------|\n/// |  ABBREV TABLE    |\n/// |------------------|\n/// |  ENTRY POOL      |\n/// `------------------'\n///\n/// For the full documentation please refer to the DWARF 5 standard.\n///\n///\n/// This file defines the class template AccelTable, which is represents an\n/// abstract view of an Accelerator table, without any notion of an on-disk\n/// layout. This class is parameterized by an entry type, which should derive\n/// from AccelTableData. This is the type of individual entries in the table,\n/// and it should store the data necessary to emit them. AppleAccelTableData is\n/// the base class for Apple Accelerator Table entries, which have a uniform\n/// structure based on a sequence of Atoms. There are different sub-classes\n/// derived from AppleAccelTable, which differ in the set of Atoms and how they\n/// obtain their values.\n///\n/// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable\n/// function.\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DwarfCompileUnit;\nclass DwarfDebug;\n\n/// Interface which the different types of accelerator table data have to\n/// conform. It serves as a base class for different values of the template\n/// argument of the AccelTable class template.\nclass AccelTableData {\npublic:\n  virtual ~AccelTableData() = default;\n\n  bool operator<(const AccelTableData &Other) const {\n    return order() < Other.order();\n  }\n\n    // Subclasses should implement:\n    // static uint32_t hash(StringRef Name);\n\n#ifndef NDEBUG\n  virtual void print(raw_ostream &OS) const = 0;\n#endif\nprotected:\n  virtual uint64_t order() const = 0;\n};\n\n/// A base class holding non-template-dependant functionality of the AccelTable\n/// class. Clients should not use this class directly but rather instantiate\n/// AccelTable with a type derived from AccelTableData.\nclass AccelTableBase {\npublic:\n  using HashFn = uint32_t(StringRef);\n\n  /// Represents a group of entries with identical name (and hence, hash value).\n  struct HashData {\n    DwarfStringPoolEntryRef Name;\n    uint32_t HashValue;\n    std::vector<AccelTableData *> Values;\n    MCSymbol *Sym;\n\n    HashData(DwarfStringPoolEntryRef Name, HashFn *Hash)\n        : Name(Name), HashValue(Hash(Name.getString())) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  using HashList = std::vector<HashData *>;\n  using BucketList = std::vector<HashList>;\n\nprotected:\n  /// Allocator for HashData and Values.\n  BumpPtrAllocator Allocator;\n\n  using StringEntries = StringMap<HashData, BumpPtrAllocator &>;\n  StringEntries Entries;\n\n  HashFn *Hash;\n  uint32_t BucketCount;\n  uint32_t UniqueHashCount;\n\n  HashList Hashes;\n  BucketList Buckets;\n\n  void computeBucketCount();\n\n  AccelTableBase(HashFn *Hash) : Entries(Allocator), Hash(Hash) {}\n\npublic:\n  void finalize(AsmPrinter *Asm, StringRef Prefix);\n  ArrayRef<HashList> getBuckets() const { return Buckets; }\n  uint32_t getBucketCount() const { return BucketCount; }\n  uint32_t getUniqueHashCount() const { return UniqueHashCount; }\n  uint32_t getUniqueNameCount() const { return Entries.size(); }\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const;\n  void dump() const { print(dbgs()); }\n#endif\n\n  AccelTableBase(const AccelTableBase &) = delete;\n  void operator=(const AccelTableBase &) = delete;\n};\n\n/// This class holds an abstract representation of an Accelerator Table,\n/// consisting of a sequence of buckets, each bucket containint a sequence of\n/// HashData entries. The class is parameterized by the type of entries it\n/// holds. The type template parameter also defines the hash function to use for\n/// hashing names.\ntemplate <typename DataT> class AccelTable : public AccelTableBase {\npublic:\n  AccelTable() : AccelTableBase(DataT::hash) {}\n\n  template <typename... Types>\n  void addName(DwarfStringPoolEntryRef Name, Types &&... Args);\n};\n\ntemplate <typename AccelTableDataT>\ntemplate <typename... Types>\nvoid AccelTable<AccelTableDataT>::addName(DwarfStringPoolEntryRef Name,\n                                          Types &&... Args) {\n  assert(Buckets.empty() && \"Already finalized!\");\n  // If the string is in the list already then add this die to the list\n  // otherwise add a new one.\n  auto Iter = Entries.try_emplace(Name.getString(), Name, Hash).first;\n  assert(Iter->second.Name == Name);\n  Iter->second.Values.push_back(\n      new (Allocator) AccelTableDataT(std::forward<Types>(Args)...));\n}\n\n/// A base class for different implementations of Data classes for Apple\n/// Accelerator Tables. The columns in the table are defined by the static Atoms\n/// variable defined on the subclasses.\nclass AppleAccelTableData : public AccelTableData {\npublic:\n  /// An Atom defines the form of the data in an Apple accelerator table.\n  /// Conceptually it is a column in the accelerator consisting of a type and a\n  /// specification of the form of its data.\n  struct Atom {\n    /// Atom Type.\n    const uint16_t Type;\n    /// DWARF Form.\n    const uint16_t Form;\n\n    constexpr Atom(uint16_t Type, uint16_t Form) : Type(Type), Form(Form) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  // Subclasses should define:\n  // static constexpr Atom Atoms[];\n\n  virtual void emit(AsmPrinter *Asm) const = 0;\n\n  static uint32_t hash(StringRef Buffer) { return djbHash(Buffer); }\n};\n\n/// The Data class implementation for DWARF v5 accelerator table. Unlike the\n/// Apple Data classes, this class is just a DIE wrapper, and does not know to\n/// serialize itself. The complete serialization logic is in the\n/// emitDWARF5AccelTable function.\nclass DWARF5AccelTableData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableData(const DIE &Die) : Die(Die) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  const DIE &getDie() const { return Die; }\n  uint64_t getDieOffset() const { return Die.getOffset(); }\n  unsigned getDieTag() const { return Die.getTag(); }\n\nprotected:\n  const DIE &Die;\n\n  uint64_t order() const override { return Die.getOffset(); }\n};\n\nclass DWARF5AccelTableStaticData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableStaticData(uint64_t DieOffset, unsigned DieTag,\n                             unsigned CUIndex)\n      : DieOffset(DieOffset), DieTag(DieTag), CUIndex(CUIndex) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  uint64_t getDieOffset() const { return DieOffset; }\n  unsigned getDieTag() const { return DieTag; }\n  unsigned getCUIndex() const { return CUIndex; }\n\nprotected:\n  uint64_t DieOffset;\n  unsigned DieTag;\n  unsigned CUIndex;\n\n  uint64_t order() const override { return DieOffset; }\n};\n\nvoid emitAppleAccelTableImpl(AsmPrinter *Asm, AccelTableBase &Contents,\n                             StringRef Prefix, const MCSymbol *SecBegin,\n                             ArrayRef<AppleAccelTableData::Atom> Atoms);\n\n/// Emit an Apple Accelerator Table consisting of entries in the specified\n/// AccelTable. The DataT template parameter should be derived from\n/// AppleAccelTableData.\ntemplate <typename DataT>\nvoid emitAppleAccelTable(AsmPrinter *Asm, AccelTable<DataT> &Contents,\n                         StringRef Prefix, const MCSymbol *SecBegin) {\n  static_assert(std::is_convertible<DataT *, AppleAccelTableData *>::value, \"\");\n  emitAppleAccelTableImpl(Asm, Contents, Prefix, SecBegin, DataT::Atoms);\n}\n\nvoid emitDWARF5AccelTable(AsmPrinter *Asm,\n                          AccelTable<DWARF5AccelTableData> &Contents,\n                          const DwarfDebug &DD,\n                          ArrayRef<std::unique_ptr<DwarfCompileUnit>> CUs);\n\nvoid emitDWARF5AccelTable(\n    AsmPrinter *Asm, AccelTable<DWARF5AccelTableStaticData> &Contents,\n    ArrayRef<MCSymbol *> CUs,\n    llvm::function_ref<unsigned(const DWARF5AccelTableStaticData &)>\n        getCUIndexForEntry);\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with just a DIE reference.\nclass AppleAccelTableOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableOffsetData(const DIE &D) : Die(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Die.getOffset(); }\n\n  const DIE &Die;\n};\n\n/// Accelerator table data implementation for Apple type accelerator tables.\nclass AppleAccelTableTypeData : public AppleAccelTableOffsetData {\npublic:\n  AppleAccelTableTypeData(const DIE &D) : AppleAccelTableOffsetData(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(dwarf::DW_ATOM_type_flags, dwarf::DW_FORM_data1)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n};\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableStaticOffsetData(uint32_t Offset) : Offset(Offset) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t Offset;\n};\n\n/// Accelerator table data implementation for type accelerator tables with\n/// a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticTypeData : public AppleAccelTableStaticOffsetData {\npublic:\n  AppleAccelTableStaticTypeData(uint32_t Offset, uint16_t Tag,\n                                bool ObjCClassIsImplementation,\n                                uint32_t QualifiedNameHash)\n      : AppleAccelTableStaticOffsetData(Offset),\n        QualifiedNameHash(QualifiedNameHash), Tag(Tag),\n        ObjCClassIsImplementation(ObjCClassIsImplementation) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(5, dwarf::DW_FORM_data1), Atom(6, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t QualifiedNameHash;\n  uint16_t Tag;\n  bool ObjCClassIsImplementation;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_ACCELTABLE_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "content": "//===- lib/CodeGen/DIE.h - DWARF Info Entries -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Data structures for DWARF info entries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DIE_H\n#define LLVM_CODEGEN_DIE_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIEUnit;\nclass DwarfCompileUnit;\nclass MCExpr;\nclass MCSection;\nclass MCSymbol;\nclass raw_ostream;\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation data, describes one attribute of a Dwarf abbreviation.\nclass DIEAbbrevData {\n  /// Dwarf attribute code.\n  dwarf::Attribute Attribute;\n\n  /// Dwarf form code.\n  dwarf::Form Form;\n\n  /// Dwarf attribute value for DW_FORM_implicit_const\n  int64_t Value = 0;\n\npublic:\n  DIEAbbrevData(dwarf::Attribute A, dwarf::Form F)\n      : Attribute(A), Form(F) {}\n  DIEAbbrevData(dwarf::Attribute A, int64_t V)\n      : Attribute(A), Form(dwarf::DW_FORM_implicit_const), Value(V) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  int64_t getValue() const { return Value; }\n  /// @}\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation, describes the organization of a debug information\n/// object.\nclass DIEAbbrev : public FoldingSetNode {\n  /// Unique number for node.\n  unsigned Number = 0;\n\n  /// Dwarf tag code.\n  dwarf::Tag Tag;\n\n  /// Whether or not this node has children.\n  ///\n  /// This cheats a bit in all of the uses since the values in the standard\n  /// are 0 and 1 for no children and children respectively.\n  bool Children;\n\n  /// Raw data bytes for abbreviation.\n  SmallVector<DIEAbbrevData, 12> Data;\n\npublic:\n  DIEAbbrev(dwarf::Tag T, bool C) : Tag(T), Children(C) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Tag getTag() const { return Tag; }\n  unsigned getNumber() const { return Number; }\n  bool hasChildren() const { return Children; }\n  const SmallVectorImpl<DIEAbbrevData> &getData() const { return Data; }\n  void setChildrenFlag(bool hasChild) { Children = hasChild; }\n  void setNumber(unsigned N) { Number = N; }\n  /// @}\n\n  /// Adds another set of attribute information to the abbreviation.\n  void AddAttribute(dwarf::Attribute Attribute, dwarf::Form Form) {\n    Data.push_back(DIEAbbrevData(Attribute, Form));\n  }\n\n  /// Adds attribute with DW_FORM_implicit_const value\n  void AddImplicitConstAttribute(dwarf::Attribute Attribute, int64_t Value) {\n    Data.push_back(DIEAbbrevData(Attribute, Value));\n  }\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Print the abbreviation using the specified asm printer.\n  void Emit(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Helps unique DIEAbbrev objects and assigns abbreviation numbers.\n///\n/// This class will unique the DIE abbreviations for a llvm::DIE object and\n/// assign a unique abbreviation number to each unique DIEAbbrev object it\n/// finds. The resulting collection of DIEAbbrev objects can then be emitted\n/// into the .debug_abbrev section.\nclass DIEAbbrevSet {\n  /// The bump allocator to use when creating DIEAbbrev objects in the uniqued\n  /// storage container.\n  BumpPtrAllocator &Alloc;\n  /// FoldingSet that uniques the abbreviations.\n  FoldingSet<DIEAbbrev> AbbreviationsSet;\n  /// A list of all the unique abbreviations in use.\n  std::vector<DIEAbbrev *> Abbreviations;\n\npublic:\n  DIEAbbrevSet(BumpPtrAllocator &A) : Alloc(A) {}\n  ~DIEAbbrevSet();\n\n  /// Generate the abbreviation declaration for a DIE and return a pointer to\n  /// the generated abbreviation.\n  ///\n  /// \\param Die the debug info entry to generate the abbreviation for.\n  /// \\returns A reference to the uniqued abbreviation declaration that is\n  /// owned by this class.\n  DIEAbbrev &uniqueAbbreviation(DIE &Die);\n\n  /// Print all abbreviations using the specified asm printer.\n  void Emit(const AsmPrinter *AP, MCSection *Section) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An integer value DIE.\n///\nclass DIEInteger {\n  uint64_t Integer;\n\npublic:\n  explicit DIEInteger(uint64_t I) : Integer(I) {}\n\n  /// Choose the best form for integer.\n  static dwarf::Form BestForm(bool IsSigned, uint64_t Int) {\n    if (IsSigned) {\n      const int64_t SignedInt = Int;\n      if ((char)Int == SignedInt)\n        return dwarf::DW_FORM_data1;\n      if ((short)Int == SignedInt)\n        return dwarf::DW_FORM_data2;\n      if ((int)Int == SignedInt)\n        return dwarf::DW_FORM_data4;\n    } else {\n      if ((unsigned char)Int == Int)\n        return dwarf::DW_FORM_data1;\n      if ((unsigned short)Int == Int)\n        return dwarf::DW_FORM_data2;\n      if ((unsigned int)Int == Int)\n        return dwarf::DW_FORM_data4;\n    }\n    return dwarf::DW_FORM_data8;\n  }\n\n  uint64_t getValue() const { return Integer; }\n  void setValue(uint64_t Val) { Integer = Val; }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An expression DIE.\nclass DIEExpr {\n  const MCExpr *Expr;\n\npublic:\n  explicit DIEExpr(const MCExpr *E) : Expr(E) {}\n\n  /// Get MCExpr.\n  const MCExpr *getValue() const { return Expr; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A label DIE.\nclass DIELabel {\n  const MCSymbol *Label;\n\npublic:\n  explicit DIELabel(const MCSymbol *L) : Label(L) {}\n\n  /// Get MCSymbol.\n  const MCSymbol *getValue() const { return Label; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEBaseTypeRef {\n  const DwarfCompileUnit *CU;\n  const uint64_t Index;\n  static constexpr unsigned ULEB128PadSize = 4;\n\npublic:\n  explicit DIEBaseTypeRef(const DwarfCompileUnit *TheCU, uint64_t Idx)\n    : CU(TheCU), Index(Idx) {}\n\n  /// EmitValue - Emit base type reference.\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  /// SizeOf - Determine size of the base type reference in bytes.\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n  uint64_t getIndex() const { return Index; }\n};\n\n//===--------------------------------------------------------------------===//\n/// A simple label difference DIE.\n///\nclass DIEDelta {\n  const MCSymbol *LabelHi;\n  const MCSymbol *LabelLo;\n\npublic:\n  DIEDelta(const MCSymbol *Hi, const MCSymbol *Lo) : LabelHi(Hi), LabelLo(Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for string pool string values.\n///\n/// This class is used with the DW_FORM_strp and DW_FORM_GNU_str_index forms.\nclass DIEString {\n  DwarfStringPoolEntryRef S;\n\npublic:\n  DIEString(DwarfStringPoolEntryRef S) : S(S) {}\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S.getString(); }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for inline string values.\n///\n/// This class is used with the DW_FORM_string form.\nclass DIEInlineString {\n  StringRef S;\n\npublic:\n  template <typename Allocator>\n  explicit DIEInlineString(StringRef Str, Allocator &A) : S(Str.copy(A)) {}\n\n  ~DIEInlineString() = default;\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A pointer to another debug information entry.  An instance of this class can\n/// also be used as a proxy for a debug information entry not yet defined\n/// (ie. types.)\nclass DIEEntry {\n  DIE *Entry;\n\npublic:\n  DIEEntry() = delete;\n  explicit DIEEntry(DIE &E) : Entry(&E) {}\n\n  DIE &getEntry() const { return *Entry; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a pointer to a location list in the debug_loc\n/// section.\nclass DIELocList {\n  /// Index into the .debug_loc vector.\n  size_t Index;\n\npublic:\n  DIELocList(size_t I) : Index(I) {}\n\n  /// Grab the current index out.\n  size_t getValue() const { return Index; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEAddrOffset {\n  DIEInteger Addr;\n  DIEDelta Offset;\n\npublic:\n  explicit DIEAddrOffset(uint64_t Idx, const MCSymbol *Hi, const MCSymbol *Lo)\n      : Addr(Idx), Offset(Hi, Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A debug information entry value. Some of these roughly correlate\n/// to DWARF attribute classes.\nclass DIEBlock;\nclass DIELoc;\nclass DIEValue {\npublic:\n  enum Type {\n    isNone,\n#define HANDLE_DIEVALUE(T) is##T,\n#include \"llvm/CodeGen/DIEValue.def\"\n  };\n\nprivate:\n  /// Type of data stored in the value.\n  Type Ty = isNone;\n  dwarf::Attribute Attribute = (dwarf::Attribute)0;\n  dwarf::Form Form = (dwarf::Form)0;\n\n  /// Storage for the value.\n  ///\n  /// All values that aren't standard layout (or are larger than 8 bytes)\n  /// should be stored by reference instead of by value.\n  using ValTy =\n      AlignedCharArrayUnion<DIEInteger, DIEString, DIEExpr, DIELabel,\n                            DIEDelta *, DIEEntry, DIEBlock *, DIELoc *,\n                            DIELocList, DIEBaseTypeRef *, DIEAddrOffset *>;\n\n  static_assert(sizeof(ValTy) <= sizeof(uint64_t) ||\n                    sizeof(ValTy) <= sizeof(void *),\n                \"Expected all large types to be stored via pointer\");\n\n  /// Underlying stored value.\n  ValTy Val;\n\n  template <class T> void construct(T V) {\n    static_assert(std::is_standard_layout<T>::value ||\n                      std::is_pointer<T>::value,\n                  \"Expected standard layout or pointer\");\n    new (reinterpret_cast<void *>(&Val)) T(V);\n  }\n\n  template <class T> T *get() { return reinterpret_cast<T *>(&Val); }\n  template <class T> const T *get() const {\n    return reinterpret_cast<const T *>(&Val);\n  }\n  template <class T> void destruct() { get<T>()->~T(); }\n\n  /// Destroy the underlying value.\n  ///\n  /// This should get optimized down to a no-op.  We could skip it if we could\n  /// add a static assert on \\a std::is_trivially_copyable(), but we currently\n  /// support versions of GCC that don't understand that.\n  void destroyVal() {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<DIE##T>();                                                        \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<const DIE##T *>();                                                \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\n  /// Copy the underlying value.\n  ///\n  /// This should get optimized down to a simple copy.  We need to actually\n  /// construct the value, rather than calling memcpy, to satisfy strict\n  /// aliasing rules.\n  void copyVal(const DIEValue &X) {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    construct<DIE##T>(*X.get<DIE##T>());                                       \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    construct<const DIE##T *>(*X.get<const DIE##T *>());                       \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\npublic:\n  DIEValue() = default;\n\n  DIEValue(const DIEValue &X) : Ty(X.Ty), Attribute(X.Attribute), Form(X.Form) {\n    copyVal(X);\n  }\n\n  DIEValue &operator=(const DIEValue &X) {\n    destroyVal();\n    Ty = X.Ty;\n    Attribute = X.Attribute;\n    Form = X.Form;\n    copyVal(X);\n    return *this;\n  }\n\n  ~DIEValue() { destroyVal(); }\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T &V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    construct<DIE##T>(V);                                                      \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    assert(V && \"Expected valid value\");                                       \\\n    construct<const DIE##T *>(V);                                              \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Accessors.\n  /// @{\n  Type getType() const { return Ty; }\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  explicit operator bool() const { return Ty; }\n  /// @}\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return *get<DIE##T>();                                                     \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return **get<const DIE##T *>();                                            \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Emit value via the Dwarf writer.\n  void emitValue(const AsmPrinter *AP) const;\n\n  /// Return the size of a value in bytes.\n  unsigned SizeOf(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\nstruct IntrusiveBackListNode {\n  PointerIntPair<IntrusiveBackListNode *, 1> Next;\n\n  IntrusiveBackListNode() : Next(this, true) {}\n\n  IntrusiveBackListNode *getNext() const {\n    return Next.getInt() ? nullptr : Next.getPointer();\n  }\n};\n\nstruct IntrusiveBackListBase {\n  using Node = IntrusiveBackListNode;\n\n  Node *Last = nullptr;\n\n  bool empty() const { return !Last; }\n\n  void push_back(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next = Last->Next;\n      Last->Next.setPointerAndInt(&N, false);\n    }\n    Last = &N;\n  }\n\n  void push_front(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next.setPointerAndInt(Last->Next.getPointer(), false);\n      Last->Next.setPointerAndInt(&N, true);\n    } else {\n      Last = &N;\n    }\n  }\n};\n\ntemplate <class T> class IntrusiveBackList : IntrusiveBackListBase {\npublic:\n  using IntrusiveBackListBase::empty;\n\n  void push_back(T &N) { IntrusiveBackListBase::push_back(N); }\n  void push_front(T &N) { IntrusiveBackListBase::push_front(N); }\n  T &back() { return *static_cast<T *>(Last); }\n  const T &back() const { return *static_cast<T *>(Last); }\n  T &front() {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n  const T &front() const {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n\n  void takeNodes(IntrusiveBackList<T> &Other) {\n    if (Other.empty())\n      return;\n\n    T *FirstNode = static_cast<T *>(Other.Last->Next.getPointer());\n    T *IterNode = FirstNode;\n    do {\n      // Keep a pointer to the node and increment the iterator.\n      T *TmpNode = IterNode;\n      IterNode = static_cast<T *>(IterNode->Next.getPointer());\n\n      // Unlink the node and push it back to this list.\n      TmpNode->Next.setPointerAndInt(TmpNode, true);\n      push_back(*TmpNode);\n    } while (IterNode != FirstNode);\n\n    Other.Last = nullptr;\n  }\n\n  class const_iterator;\n  class iterator\n      : public iterator_facade_base<iterator, std::forward_iterator_tag, T> {\n    friend class const_iterator;\n\n    Node *N = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(T *N) : N(N) {}\n\n    iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    T &operator*() const { return *static_cast<T *>(N); }\n\n    bool operator==(const iterator &X) const { return N == X.N; }\n  };\n\n  class const_iterator\n      : public iterator_facade_base<const_iterator, std::forward_iterator_tag,\n                                    const T> {\n    const Node *N = nullptr;\n\n  public:\n    const_iterator() = default;\n    // Placate MSVC by explicitly scoping 'iterator'.\n    const_iterator(typename IntrusiveBackList<T>::iterator X) : N(X.N) {}\n    explicit const_iterator(const T *N) : N(N) {}\n\n    const_iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    const T &operator*() const { return *static_cast<const T *>(N); }\n\n    bool operator==(const const_iterator &X) const { return N == X.N; }\n  };\n\n  iterator begin() {\n    return Last ? iterator(static_cast<T *>(Last->Next.getPointer())) : end();\n  }\n  const_iterator begin() const {\n    return const_cast<IntrusiveBackList *>(this)->begin();\n  }\n  iterator end() { return iterator(); }\n  const_iterator end() const { return const_iterator(); }\n\n  static iterator toIterator(T &N) { return iterator(&N); }\n  static const_iterator toIterator(const T &N) { return const_iterator(&N); }\n};\n\n/// A list of DIE values.\n///\n/// This is a singly-linked list, but instead of reversing the order of\n/// insertion, we keep a pointer to the back of the list so we can push in\n/// order.\n///\n/// There are two main reasons to choose a linked list over a customized\n/// vector-like data structure.\n///\n///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a\n///     linked list here makes this way easier to accomplish.\n///  2. Carrying an extra pointer per \\a DIEValue isn't expensive.  45% of DIEs\n///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be\n///     over-allocated by 50% on average anyway, the same cost as the\n///     linked-list node.\nclass DIEValueList {\n  struct Node : IntrusiveBackListNode {\n    DIEValue V;\n\n    explicit Node(DIEValue V) : V(V) {}\n  };\n\n  using ListTy = IntrusiveBackList<Node>;\n\n  ListTy List;\n\npublic:\n  class const_value_iterator;\n  class value_iterator\n      : public iterator_adaptor_base<value_iterator, ListTy::iterator,\n                                     std::forward_iterator_tag, DIEValue> {\n    friend class const_value_iterator;\n\n    using iterator_adaptor =\n        iterator_adaptor_base<value_iterator, ListTy::iterator,\n                              std::forward_iterator_tag, DIEValue>;\n\n  public:\n    value_iterator() = default;\n    explicit value_iterator(ListTy::iterator X) : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  class const_value_iterator : public iterator_adaptor_base<\n                                   const_value_iterator, ListTy::const_iterator,\n                                   std::forward_iterator_tag, const DIEValue> {\n    using iterator_adaptor =\n        iterator_adaptor_base<const_value_iterator, ListTy::const_iterator,\n                              std::forward_iterator_tag, const DIEValue>;\n\n  public:\n    const_value_iterator() = default;\n    const_value_iterator(DIEValueList::value_iterator X)\n        : iterator_adaptor(X.wrapped()) {}\n    explicit const_value_iterator(ListTy::const_iterator X)\n        : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    const DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  using value_range = iterator_range<value_iterator>;\n  using const_value_range = iterator_range<const_value_iterator>;\n\n  value_iterator addValue(BumpPtrAllocator &Alloc, const DIEValue &V) {\n    List.push_back(*new (Alloc) Node(V));\n    return value_iterator(ListTy::toIterator(List.back()));\n  }\n  template <class T>\n  value_iterator addValue(BumpPtrAllocator &Alloc, dwarf::Attribute Attribute,\n                    dwarf::Form Form, T &&Value) {\n    return addValue(Alloc, DIEValue(Attribute, Form, std::forward<T>(Value)));\n  }\n\n  /// Take ownership of the nodes in \\p Other, and append them to the back of\n  /// the list.\n  void takeValues(DIEValueList &Other) { List.takeNodes(Other.List); }\n\n  value_range values() {\n    return make_range(value_iterator(List.begin()), value_iterator(List.end()));\n  }\n  const_value_range values() const {\n    return make_range(const_value_iterator(List.begin()),\n                      const_value_iterator(List.end()));\n  }\n};\n\n//===--------------------------------------------------------------------===//\n/// A structured debug information entry.  Has an abbreviation which\n/// describes its organization.\nclass DIE : IntrusiveBackListNode, public DIEValueList {\n  friend class IntrusiveBackList<DIE>;\n  friend class DIEUnit;\n\n  /// Dwarf unit relative offset.\n  unsigned Offset = 0;\n  /// Size of instance + children.\n  unsigned Size = 0;\n  unsigned AbbrevNumber = ~0u;\n  /// Dwarf tag code.\n  dwarf::Tag Tag = (dwarf::Tag)0;\n  /// Set to true to force a DIE to emit an abbreviation that says it has\n  /// children even when it doesn't. This is used for unit testing purposes.\n  bool ForceChildren = false;\n  /// Children DIEs.\n  IntrusiveBackList<DIE> Children;\n\n  /// The owner is either the parent DIE for children of other DIEs, or a\n  /// DIEUnit which contains this DIE as its unit DIE.\n  PointerUnion<DIE *, DIEUnit *> Owner;\n\n  explicit DIE(dwarf::Tag Tag) : Tag(Tag) {}\n\npublic:\n  DIE() = delete;\n  DIE(const DIE &RHS) = delete;\n  DIE(DIE &&RHS) = delete;\n  DIE &operator=(const DIE &RHS) = delete;\n  DIE &operator=(const DIE &&RHS) = delete;\n\n  static DIE *get(BumpPtrAllocator &Alloc, dwarf::Tag Tag) {\n    return new (Alloc) DIE(Tag);\n  }\n\n  // Accessors.\n  unsigned getAbbrevNumber() const { return AbbrevNumber; }\n  dwarf::Tag getTag() const { return Tag; }\n  /// Get the compile/type unit relative offset of this DIE.\n  unsigned getOffset() const { return Offset; }\n  unsigned getSize() const { return Size; }\n  bool hasChildren() const { return ForceChildren || !Children.empty(); }\n  void setForceChildren(bool B) { ForceChildren = B; }\n\n  using child_iterator = IntrusiveBackList<DIE>::iterator;\n  using const_child_iterator = IntrusiveBackList<DIE>::const_iterator;\n  using child_range = iterator_range<child_iterator>;\n  using const_child_range = iterator_range<const_child_iterator>;\n\n  child_range children() {\n    return make_range(Children.begin(), Children.end());\n  }\n  const_child_range children() const {\n    return make_range(Children.begin(), Children.end());\n  }\n\n  DIE *getParent() const;\n\n  /// Generate the abbreviation for this DIE.\n  ///\n  /// Calculate the abbreviation for this, which should be uniqued and\n  /// eventually used to call \\a setAbbrevNumber().\n  DIEAbbrev generateAbbrev() const;\n\n  /// Set the abbreviation number for this DIE.\n  void setAbbrevNumber(unsigned I) { AbbrevNumber = I; }\n\n  /// Get the absolute offset within the .debug_info or .debug_types section\n  /// for this DIE.\n  uint64_t getDebugSectionOffset() const;\n\n  /// Compute the offset of this DIE and all its children.\n  ///\n  /// This function gets called just before we are going to generate the debug\n  /// information and gives each DIE a chance to figure out its CU relative DIE\n  /// offset, unique its abbreviation and fill in the abbreviation code, and\n  /// return the unit offset that points to where the next DIE will be emitted\n  /// within the debug unit section. After this function has been called for all\n  /// DIE objects, the DWARF can be generated since all DIEs will be able to\n  /// properly refer to other DIE objects since all DIEs have calculated their\n  /// offsets.\n  ///\n  /// \\param AP AsmPrinter to use when calculating sizes.\n  /// \\param AbbrevSet the abbreviation used to unique DIE abbreviations.\n  /// \\param CUOffset the compile/type unit relative offset in bytes.\n  /// \\returns the offset for the DIE that follows this DIE within the\n  /// current compile/type unit.\n  unsigned computeOffsetsAndAbbrevs(const AsmPrinter *AP,\n                                    DIEAbbrevSet &AbbrevSet, unsigned CUOffset);\n\n  /// Climb up the parent chain to get the compile unit or type unit DIE that\n  /// this DIE belongs to.\n  ///\n  /// \\returns the compile or type unit DIE that owns this DIE, or NULL if\n  /// this DIE hasn't been added to a unit DIE.\n  const DIE *getUnitDie() const;\n\n  /// Climb up the parent chain to get the compile unit or type unit that this\n  /// DIE belongs to.\n  ///\n  /// \\returns the DIEUnit that represents the compile or type unit that owns\n  /// this DIE, or NULL if this DIE hasn't been added to a unit DIE.\n  DIEUnit *getUnit() const;\n\n  void setOffset(unsigned O) { Offset = O; }\n  void setSize(unsigned S) { Size = S; }\n\n  /// Add a child to the DIE.\n  DIE &addChild(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_back(*Child);\n    return Children.back();\n  }\n\n  DIE &addChildFront(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_front(*Child);\n    return Children.front();\n  }\n\n  /// Find a value in the DIE with the attribute given.\n  ///\n  /// Returns a default-constructed DIEValue (where \\a DIEValue::getType()\n  /// gives \\a DIEValue::isNone) if no such attribute exists.\n  DIEValue findAttribute(dwarf::Attribute Attribute) const;\n\n  void print(raw_ostream &O, unsigned IndentCount = 0) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a compile or type unit.\nclass DIEUnit {\n  /// The compile unit or type unit DIE. This variable must be an instance of\n  /// DIE so that we can calculate the DIEUnit from any DIE by traversing the\n  /// parent backchain and getting the Unit DIE, and then casting itself to a\n  /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without\n  /// having to store a pointer to the DIEUnit in each DIE instance.\n  DIE Die;\n  /// The section this unit will be emitted in. This may or may not be set to\n  /// a valid section depending on the client that is emitting DWARF.\n  MCSection *Section;\n  uint64_t Offset; /// .debug_info or .debug_types absolute section offset.\nprotected:\n  virtual ~DIEUnit() = default;\n\npublic:\n  explicit DIEUnit(dwarf::Tag UnitTag);\n  DIEUnit(const DIEUnit &RHS) = delete;\n  DIEUnit(DIEUnit &&RHS) = delete;\n  void operator=(const DIEUnit &RHS) = delete;\n  void operator=(const DIEUnit &&RHS) = delete;\n  /// Set the section that this DIEUnit will be emitted into.\n  ///\n  /// This function is used by some clients to set the section. Not all clients\n  /// that emit DWARF use this section variable.\n  void setSection(MCSection *Section) {\n    assert(!this->Section);\n    this->Section = Section;\n  }\n\n  virtual const MCSymbol *getCrossSectionRelativeBaseAddress() const {\n    return nullptr;\n  }\n\n  /// Return the section that this DIEUnit will be emitted into.\n  ///\n  /// \\returns Section pointer which can be NULL.\n  MCSection *getSection() const { return Section; }\n  void setDebugSectionOffset(uint64_t O) { Offset = O; }\n  uint64_t getDebugSectionOffset() const { return Offset; }\n  DIE &getUnitDie() { return Die; }\n  const DIE &getUnitDie() const { return Die; }\n};\n\nstruct BasicDIEUnit final : DIEUnit {\n  explicit BasicDIEUnit(dwarf::Tag UnitTag) : DIEUnit(UnitTag) {}\n};\n\n//===--------------------------------------------------------------------===//\n/// DIELoc - Represents an expression location.\n//\nclass DIELoc : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIELoc() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm(unsigned DwarfVersion) const {\n    if (DwarfVersion > 3)\n      return dwarf::DW_FORM_exprloc;\n    // Pre-DWARF4 location expressions were blocks and not exprloc.\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// DIEBlock - Represents a block of values.\n//\nclass DIEBlock : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIEBlock() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm() const {\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_DIE_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h", "content": "//===- NonRelocatableStringpool.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_NONRELOCATABLESTRINGPOOL_H\n#define LLVM_CODEGEN_NONRELOCATABLESTRINGPOOL_H\n\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\n/// A string table that doesn't need relocations.\n///\n/// Use this class when a string table doesn't need relocations.\n/// This class provides this ability by just associating offsets with strings.\nclass NonRelocatableStringpool {\npublic:\n  /// Entries are stored into the StringMap and simply linked together through\n  /// the second element of this pair in order to keep track of insertion\n  /// order.\n  using MapTy = StringMap<DwarfStringPoolEntry, BumpPtrAllocator>;\n\n  NonRelocatableStringpool(\n      std::function<StringRef(StringRef Input)> Translator = nullptr,\n      bool PutEmptyString = false)\n      : Translator(Translator) {\n    if (PutEmptyString)\n      EmptyString = getEntry(\"\");\n  }\n\n  DwarfStringPoolEntryRef getEntry(StringRef S);\n\n  /// Get the offset of string \\p S in the string table. This can insert a new\n  /// element or return the offset of a pre-existing one.\n  uint64_t getStringOffset(StringRef S) { return getEntry(S).getOffset(); }\n\n  /// Get permanent storage for \\p S (but do not necessarily emit \\p S in the\n  /// output section). A latter call to getStringOffset() with the same string\n  /// will chain it though.\n  ///\n  /// \\returns The StringRef that points to permanent storage to use\n  /// in place of \\p S.\n  StringRef internString(StringRef S);\n\n  uint64_t getSize() { return CurrentEndOffset; }\n\n  /// Return the list of strings to be emitted. This does not contain the\n  /// strings which were added via internString only.\n  std::vector<DwarfStringPoolEntryRef> getEntriesForEmission() const;\n\nprivate:\n  MapTy Strings;\n  uint64_t CurrentEndOffset = 0;\n  unsigned NumEntries = 0;\n  DwarfStringPoolEntryRef EmptyString;\n  std::function<StringRef(StringRef Input)> Translator;\n};\n\n/// Helper for making strong types.\ntemplate <typename T, typename S> class StrongType : public T {\npublic:\n  template <typename... Args>\n  explicit StrongType(Args... A) : T(std::forward<Args>(A)...) {}\n};\n\n/// It's very easy to introduce bugs by passing the wrong string pool.\n/// By using strong types the interface enforces that the right\n/// kind of pool is used.\nstruct UniqueTag {};\nstruct OffsetsTag {};\nusing UniquingStringPool = StrongType<NonRelocatableStringpool, UniqueTag>;\nusing OffsetsStringPool = StrongType<NonRelocatableStringpool, OffsetsTag>;\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_NONRELOCATABLESTRINGPOOL_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "content": "//===- DWARFLinker.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DWARFLINKER_DWARFLINKER_H\n#define LLVM_DWARFLINKER_DWARFLINKER_H\n\n#include \"llvm/CodeGen/AccelTable.h\"\n#include \"llvm/CodeGen/NonRelocatableStringpool.h\"\n#include \"llvm/DWARFLinker/DWARFLinkerDeclContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFCompileUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFContext.h\"\n#include \"llvm/MC/MCDwarf.h\"\n#include <map>\n\nnamespace llvm {\n\nenum class DwarfLinkerClient { Dsymutil, LLD, General };\n\n/// The kind of accelerator tables we should emit.\nenum class AccelTableKind {\n  Apple,   ///< .apple_names, .apple_namespaces, .apple_types, .apple_objc.\n  Dwarf,   ///< DWARF v5 .debug_names.\n  Default, ///< Dwarf for DWARF5 or later, Apple otherwise.\n};\n\n/// Partial address range. Besides an offset, only the\n/// HighPC is stored. The structure is stored in a map where the LowPC is the\n/// key.\nstruct ObjFileAddressRange {\n  /// Function HighPC.\n  uint64_t HighPC;\n  /// Offset to apply to the linked address.\n  /// should be 0 for not-linked object file.\n  int64_t Offset;\n\n  ObjFileAddressRange(uint64_t EndPC, int64_t Offset)\n      : HighPC(EndPC), Offset(Offset) {}\n\n  ObjFileAddressRange() : HighPC(0), Offset(0) {}\n};\n\n/// Map LowPC to ObjFileAddressRange.\nusing RangesTy = std::map<uint64_t, ObjFileAddressRange>;\n\n/// AddressesMap represents information about valid addresses used\n/// by debug information. Valid addresses are those which points to\n/// live code sections. i.e. relocations for these addresses point\n/// into sections which would be/are placed into resulting binary.\nclass AddressesMap {\npublic:\n  virtual ~AddressesMap();\n\n  /// Returns true if represented addresses are from linked file.\n  /// Returns false if represented addresses are from not-linked\n  /// object file.\n  virtual bool areRelocationsResolved() const = 0;\n\n  /// Checks that there are valid relocations against a .debug_info\n  /// section.\n  virtual bool hasValidRelocs() = 0;\n\n  /// Checks that the specified DIE has a DW_AT_Location attribute\n  /// that references into a live code section.\n  ///\n  /// \\returns true and sets Info.InDebugMap if it is the case.\n  virtual bool hasLiveMemoryLocation(const DWARFDie &DIE,\n                                     CompileUnit::DIEInfo &Info) = 0;\n\n  /// Checks that the specified DIE has a DW_AT_Low_pc attribute\n  /// that references into a live code section.\n  ///\n  /// \\returns true and sets Info.InDebugMap if it is the case.\n  virtual bool hasLiveAddressRange(const DWARFDie &DIE,\n                                   CompileUnit::DIEInfo &Info) = 0;\n\n  /// Apply the valid relocations to the buffer \\p Data, taking into\n  /// account that Data is at \\p BaseOffset in the debug_info section.\n  ///\n  /// \\returns true whether any reloc has been applied.\n  virtual bool applyValidRelocs(MutableArrayRef<char> Data, uint64_t BaseOffset,\n                                bool IsLittleEndian) = 0;\n\n  /// Relocate the given address offset if a valid relocation exists.\n  virtual llvm::Expected<uint64_t> relocateIndexedAddr(uint64_t StartOffset,\n                                                       uint64_t EndOffset) = 0;\n\n  /// Returns all valid functions address ranges(i.e., those ranges\n  /// which points to sections with code).\n  virtual RangesTy &getValidAddressRanges() = 0;\n\n  /// Erases all data.\n  virtual void clear() = 0;\n};\n\n/// DwarfEmitter presents interface to generate all debug info tables.\nclass DwarfEmitter {\npublic:\n  virtual ~DwarfEmitter();\n\n  /// Emit DIE containing warnings.\n  virtual void emitPaperTrailWarningsDie(DIE &Die) = 0;\n\n  /// Emit section named SecName with data SecData.\n  virtual void emitSectionContents(StringRef SecData, StringRef SecName) = 0;\n\n  /// Emit the abbreviation table \\p Abbrevs to the debug_abbrev section.\n  virtual void\n  emitAbbrevs(const std::vector<std::unique_ptr<DIEAbbrev>> &Abbrevs,\n              unsigned DwarfVersion) = 0;\n\n  /// Emit the string table described by \\p Pool.\n  virtual void emitStrings(const NonRelocatableStringpool &Pool) = 0;\n\n  /// Emit DWARF debug names.\n  virtual void\n  emitDebugNames(AccelTable<DWARF5AccelTableStaticData> &Table) = 0;\n\n  /// Emit Apple namespaces accelerator table.\n  virtual void\n  emitAppleNamespaces(AccelTable<AppleAccelTableStaticOffsetData> &Table) = 0;\n\n  /// Emit Apple names accelerator table.\n  virtual void\n  emitAppleNames(AccelTable<AppleAccelTableStaticOffsetData> &Table) = 0;\n\n  /// Emit Apple Objective-C accelerator table.\n  virtual void\n  emitAppleObjc(AccelTable<AppleAccelTableStaticOffsetData> &Table) = 0;\n\n  /// Emit Apple type accelerator table.\n  virtual void\n  emitAppleTypes(AccelTable<AppleAccelTableStaticTypeData> &Table) = 0;\n\n  /// Emit debug_ranges for \\p FuncRange by translating the\n  /// original \\p Entries.\n  virtual void emitRangesEntries(\n      int64_t UnitPcOffset, uint64_t OrigLowPc,\n      const FunctionIntervals::const_iterator &FuncRange,\n      const std::vector<DWARFDebugRangeList::RangeListEntry> &Entries,\n      unsigned AddressSize) = 0;\n\n  /// Emit debug_aranges entries for \\p Unit and if \\p DoRangesSection is true,\n  /// also emit the debug_ranges entries for the DW_TAG_compile_unit's\n  /// DW_AT_ranges attribute.\n  virtual void emitUnitRangesEntries(CompileUnit &Unit,\n                                     bool DoRangesSection) = 0;\n\n  /// Copy the debug_line over to the updated binary while unobfuscating the\n  /// file names and directories.\n  virtual void translateLineTable(DataExtractor LineData, uint64_t Offset) = 0;\n\n  /// Emit the line table described in \\p Rows into the debug_line section.\n  virtual void emitLineTableForUnit(MCDwarfLineTableParams Params,\n                                    StringRef PrologueBytes,\n                                    unsigned MinInstLength,\n                                    std::vector<DWARFDebugLine::Row> &Rows,\n                                    unsigned AdddressSize) = 0;\n\n  /// Emit the .debug_pubnames contribution for \\p Unit.\n  virtual void emitPubNamesForUnit(const CompileUnit &Unit) = 0;\n\n  /// Emit the .debug_pubtypes contribution for \\p Unit.\n  virtual void emitPubTypesForUnit(const CompileUnit &Unit) = 0;\n\n  /// Emit a CIE.\n  virtual void emitCIE(StringRef CIEBytes) = 0;\n\n  /// Emit an FDE with data \\p Bytes.\n  virtual void emitFDE(uint32_t CIEOffset, uint32_t AddreSize, uint32_t Address,\n                       StringRef Bytes) = 0;\n\n  /// Emit the debug_loc contribution for \\p Unit by copying the entries from\n  /// \\p Dwarf and offsetting them. Update the location attributes to point to\n  /// the new entries.\n  virtual void emitLocationsForUnit(\n      const CompileUnit &Unit, DWARFContext &Dwarf,\n      std::function<void(StringRef, SmallVectorImpl<uint8_t> &)>\n          ProcessExpr) = 0;\n\n  /// Emit the compilation unit header for \\p Unit in the\n  /// debug_info section.\n  ///\n  /// As a side effect, this also switches the current Dwarf version\n  /// of the MC layer to the one of U.getOrigUnit().\n  virtual void emitCompileUnitHeader(CompileUnit &Unit,\n                                     unsigned DwarfVersion) = 0;\n\n  /// Recursively emit the DIE tree rooted at \\p Die.\n  virtual void emitDIE(DIE &Die) = 0;\n\n  /// Returns size of generated .debug_line section.\n  virtual uint64_t getLineSectionSize() const = 0;\n\n  /// Returns size of generated .debug_frame section.\n  virtual uint64_t getFrameSectionSize() const = 0;\n\n  /// Returns size of generated .debug_ranges section.\n  virtual uint64_t getRangesSectionSize() const = 0;\n\n  /// Returns size of generated .debug_info section.\n  virtual uint64_t getDebugInfoSectionSize() const = 0;\n};\n\nusing UnitListTy = std::vector<std::unique_ptr<CompileUnit>>;\n\n/// this class represents DWARF information for source file\n/// and it`s address map.\nclass DWARFFile {\npublic:\n  DWARFFile(StringRef Name, DWARFContext *Dwarf, AddressesMap *Addresses,\n            const std::vector<std::string> &Warnings)\n      : FileName(Name), Dwarf(Dwarf), Addresses(Addresses), Warnings(Warnings) {\n  }\n\n  /// object file name.\n  StringRef FileName;\n  /// source DWARF information.\n  DWARFContext *Dwarf = nullptr;\n  /// helpful address information(list of valid address ranges, relocations).\n  AddressesMap *Addresses = nullptr;\n  /// warnings for object file.\n  const std::vector<std::string> &Warnings;\n};\n\ntypedef std::function<void(const Twine &Warning, StringRef Context,\n                           const DWARFDie *DIE)>\n    messageHandler;\ntypedef std::function<ErrorOr<DWARFFile &>(StringRef ContainerName,\n                                           StringRef Path)>\n    objFileLoader;\ntypedef std::map<std::string, std::string> swiftInterfacesMap;\ntypedef std::map<std::string, std::string> objectPrefixMap;\n\n/// The core of the Dwarf linking logic.\n///\n/// The generation of the dwarf information from the object files will be\n/// driven by the selection of 'root DIEs', which are DIEs that\n/// describe variables or functions that resolves to the corresponding\n/// code section(and thus have entries in the Addresses map). All the debug\n/// information that will be generated(the DIEs, but also the line\n/// tables, ranges, ...) is derived from that set of root DIEs.\n///\n/// The root DIEs are identified because they contain relocations that\n/// points to code section(the low_pc for a function, the location for\n/// a variable). These relocations are called ValidRelocs in the\n/// AddressesInfo and are gathered as a very first step when we start\n/// processing a object file.\nclass DWARFLinker {\npublic:\n  DWARFLinker(DwarfEmitter *Emitter,\n              DwarfLinkerClient ClientID = DwarfLinkerClient::General)\n      : TheDwarfEmitter(Emitter), DwarfLinkerClientID(ClientID) {}\n\n  /// Add object file to be linked.\n  void addObjectFile(DWARFFile &File);\n\n  /// Link debug info for added objFiles. Object\n  /// files are linked all together.\n  bool link();\n\n  /// A number of methods setting various linking options:\n\n  /// Allows to generate log of linking process to the standard output.\n  void setVerbosity(bool Verbose) { Options.Verbose = Verbose; }\n\n  /// Print statistics to standard output.\n  void setStatistics(bool Statistics) { Options.Statistics = Statistics; }\n\n  /// Do not emit linked dwarf info.\n  void setNoOutput(bool NoOut) { Options.NoOutput = NoOut; }\n\n  /// Do not unique types according to ODR.\n  void setNoODR(bool NoODR) { Options.NoODR = NoODR; }\n\n  /// update existing DWARF info(for the linked binary).\n  void setUpdate(bool Update) { Options.Update = Update; }\n\n  /// Use specified number of threads for parallel files linking.\n  void setNumThreads(unsigned NumThreads) { Options.Threads = NumThreads; }\n\n  /// Set kind of accelerator tables to be generated.\n  void setAccelTableKind(AccelTableKind Kind) {\n    Options.TheAccelTableKind = Kind;\n  }\n\n  /// Set prepend path for clang modules.\n  void setPrependPath(const std::string &Ppath) { Options.PrependPath = Ppath; }\n\n  /// Set translator which would be used for strings.\n  void\n  setStringsTranslator(std::function<StringRef(StringRef)> StringsTranslator) {\n    this->StringsTranslator = StringsTranslator;\n  }\n\n  /// Set estimated objects files amount, for preliminary data allocation.\n  void setEstimatedObjfilesAmount(unsigned ObjFilesNum) {\n    ObjectContexts.reserve(ObjFilesNum);\n  }\n\n  /// Set warning handler which would be used to report warnings.\n  void setWarningHandler(messageHandler Handler) {\n    Options.WarningHandler = Handler;\n  }\n\n  /// Set error handler which would be used to report errors.\n  void setErrorHandler(messageHandler Handler) {\n    Options.ErrorHandler = Handler;\n  }\n\n  /// Set object files loader which would be used to load\n  /// additional objects for splitted dwarf.\n  void setObjFileLoader(objFileLoader Loader) {\n    Options.ObjFileLoader = Loader;\n  }\n\n  /// Set map for Swift interfaces.\n  void setSwiftInterfacesMap(swiftInterfacesMap *Map) {\n    Options.ParseableSwiftInterfaces = Map;\n  }\n\n  /// Set prefix map for objects.\n  void setObjectPrefixMap(objectPrefixMap *Map) {\n    Options.ObjectPrefixMap = Map;\n  }\n\nprivate:\n  /// Flags passed to DwarfLinker::lookForDIEsToKeep\n  enum TraversalFlags {\n    TF_Keep = 1 << 0,            ///< Mark the traversed DIEs as kept.\n    TF_InFunctionScope = 1 << 1, ///< Current scope is a function scope.\n    TF_DependencyWalk = 1 << 2,  ///< Walking the dependencies of a kept DIE.\n    TF_ParentWalk = 1 << 3,      ///< Walking up the parents of a kept DIE.\n    TF_ODR = 1 << 4,             ///< Use the ODR while keeping dependents.\n    TF_SkipPC = 1 << 5,          ///< Skip all location attributes.\n  };\n\n  /// The  distinct types of work performed by the work loop.\n  enum class WorklistItemType {\n    /// Given a DIE, look for DIEs to be kept.\n    LookForDIEsToKeep,\n    /// Given a DIE, look for children of this DIE to be kept.\n    LookForChildDIEsToKeep,\n    /// Given a DIE, look for DIEs referencing this DIE to be kept.\n    LookForRefDIEsToKeep,\n    /// Given a DIE, look for parent DIEs to be kept.\n    LookForParentDIEsToKeep,\n    /// Given a DIE, update its incompleteness based on whether its children are\n    /// incomplete.\n    UpdateChildIncompleteness,\n    /// Given a DIE, update its incompleteness based on whether the DIEs it\n    /// references are incomplete.\n    UpdateRefIncompleteness,\n  };\n\n  /// This class represents an item in the work list. The type defines what kind\n  /// of work needs to be performed when processing the current item. The flags\n  /// and info fields are optional based on the type.\n  struct WorklistItem {\n    DWARFDie Die;\n    WorklistItemType Type;\n    CompileUnit &CU;\n    unsigned Flags;\n    union {\n      const unsigned AncestorIdx;\n      CompileUnit::DIEInfo *OtherInfo;\n    };\n\n    WorklistItem(DWARFDie Die, CompileUnit &CU, unsigned Flags,\n                 WorklistItemType T = WorklistItemType::LookForDIEsToKeep)\n        : Die(Die), Type(T), CU(CU), Flags(Flags), AncestorIdx(0) {}\n\n    WorklistItem(DWARFDie Die, CompileUnit &CU, WorklistItemType T,\n                 CompileUnit::DIEInfo *OtherInfo = nullptr)\n        : Die(Die), Type(T), CU(CU), Flags(0), OtherInfo(OtherInfo) {}\n\n    WorklistItem(unsigned AncestorIdx, CompileUnit &CU, unsigned Flags)\n        : Die(), Type(WorklistItemType::LookForParentDIEsToKeep), CU(CU),\n          Flags(Flags), AncestorIdx(AncestorIdx) {}\n  };\n\n  /// returns true if we need to translate strings.\n  bool needToTranslateStrings() { return StringsTranslator != nullptr; }\n\n  void reportWarning(const Twine &Warning, const DWARFFile &File,\n                     const DWARFDie *DIE = nullptr) const {\n    if (Options.WarningHandler != nullptr)\n      Options.WarningHandler(Warning, File.FileName, DIE);\n  }\n\n  void reportError(const Twine &Warning, const DWARFFile &File,\n                   const DWARFDie *DIE = nullptr) const {\n    if (Options.ErrorHandler != nullptr)\n      Options.ErrorHandler(Warning, File.FileName, DIE);\n  }\n\n  /// Remembers the oldest and newest DWARF version we've seen in a unit.\n  void updateDwarfVersion(unsigned Version) {\n    MaxDwarfVersion = std::max(MaxDwarfVersion, Version);\n    MinDwarfVersion = std::min(MinDwarfVersion, Version);\n  }\n\n  /// Remembers the kinds of accelerator tables we've seen in a unit.\n  void updateAccelKind(DWARFContext &Dwarf);\n\n  /// Emit warnings as Dwarf compile units to leave a trail after linking.\n  bool emitPaperTrailWarnings(const DWARFFile &File,\n                              OffsetsStringPool &StringPool);\n\n  void copyInvariantDebugSection(DWARFContext &Dwarf);\n\n  /// Keeps track of data associated with one object during linking.\n  struct LinkContext {\n    DWARFFile &File;\n    UnitListTy CompileUnits;\n    bool Skip = false;\n\n    LinkContext(DWARFFile &File) : File(File) {}\n\n    /// Clear part of the context that's no longer needed when we're done with\n    /// the debug object.\n    void clear() {\n      CompileUnits.clear();\n      File.Addresses->clear();\n    }\n  };\n\n  /// Called before emitting object data\n  void cleanupAuxiliarryData(LinkContext &Context);\n\n  /// Look at the parent of the given DIE and decide whether they should be\n  /// kept.\n  void lookForParentDIEsToKeep(unsigned AncestorIdx, CompileUnit &CU,\n                               unsigned Flags,\n                               SmallVectorImpl<WorklistItem> &Worklist);\n\n  /// Look at the children of the given DIE and decide whether they should be\n  /// kept.\n  void lookForChildDIEsToKeep(const DWARFDie &Die, CompileUnit &CU,\n                              unsigned Flags,\n                              SmallVectorImpl<WorklistItem> &Worklist);\n\n  /// Look at DIEs referenced by the given DIE and decide whether they should be\n  /// kept. All DIEs referenced though attributes should be kept.\n  void lookForRefDIEsToKeep(const DWARFDie &Die, CompileUnit &CU,\n                            unsigned Flags, const UnitListTy &Units,\n                            const DWARFFile &File,\n                            SmallVectorImpl<WorklistItem> &Worklist);\n\n  /// \\defgroup FindRootDIEs Find DIEs corresponding to Address map entries.\n  ///\n  /// @{\n  /// Recursively walk the \\p DIE tree and look for DIEs to\n  /// keep. Store that information in \\p CU's DIEInfo.\n  ///\n  /// The return value indicates whether the DIE is incomplete.\n  void lookForDIEsToKeep(AddressesMap &RelocMgr, RangesTy &Ranges,\n                         const UnitListTy &Units, const DWARFDie &DIE,\n                         const DWARFFile &File, CompileUnit &CU,\n                         unsigned Flags);\n\n  /// If this compile unit is really a skeleton CU that points to a\n  /// clang module, register it in ClangModules and return true.\n  ///\n  /// A skeleton CU is a CU without children, a DW_AT_gnu_dwo_name\n  /// pointing to the module, and a DW_AT_gnu_dwo_id with the module\n  /// hash.\n  bool registerModuleReference(DWARFDie CUDie, const DWARFUnit &Unit,\n                               const DWARFFile &File,\n                               OffsetsStringPool &OffsetsStringPool,\n                               DeclContextTree &ODRContexts,\n                               uint64_t ModulesEndOffset, unsigned &UnitID,\n                               bool IsLittleEndian, unsigned Indent = 0,\n                               bool Quiet = false);\n\n  /// Recursively add the debug info in this clang module .pcm\n  /// file (and all the modules imported by it in a bottom-up fashion)\n  /// to Units.\n  Error loadClangModule(DWARFDie CUDie, StringRef FilePath,\n                        StringRef ModuleName, uint64_t DwoId,\n                        const DWARFFile &File,\n                        OffsetsStringPool &OffsetsStringPool,\n                        DeclContextTree &ODRContexts, uint64_t ModulesEndOffset,\n                        unsigned &UnitID, bool IsLittleEndian,\n                        unsigned Indent = 0, bool Quiet = false);\n\n  /// Mark the passed DIE as well as all the ones it depends on as kept.\n  void keepDIEAndDependencies(AddressesMap &RelocMgr, RangesTy &Ranges,\n                              const UnitListTy &Units, const DWARFDie &DIE,\n                              CompileUnit::DIEInfo &MyInfo,\n                              const DWARFFile &File, CompileUnit &CU,\n                              bool UseODR);\n\n  unsigned shouldKeepDIE(AddressesMap &RelocMgr, RangesTy &Ranges,\n                         const DWARFDie &DIE, const DWARFFile &File,\n                         CompileUnit &Unit, CompileUnit::DIEInfo &MyInfo,\n                         unsigned Flags);\n\n  /// Check if a variable describing DIE should be kept.\n  /// \\returns updated TraversalFlags.\n  unsigned shouldKeepVariableDIE(AddressesMap &RelocMgr, const DWARFDie &DIE,\n                                 CompileUnit::DIEInfo &MyInfo, unsigned Flags);\n\n  unsigned shouldKeepSubprogramDIE(AddressesMap &RelocMgr, RangesTy &Ranges,\n                                   const DWARFDie &DIE, const DWARFFile &File,\n                                   CompileUnit &Unit,\n                                   CompileUnit::DIEInfo &MyInfo,\n                                   unsigned Flags);\n\n  /// Resolve the DIE attribute reference that has been extracted in \\p\n  /// RefValue. The resulting DIE might be in another CompileUnit which is\n  /// stored into \\p ReferencedCU. \\returns null if resolving fails for any\n  /// reason.\n  DWARFDie resolveDIEReference(const DWARFFile &File, const UnitListTy &Units,\n                               const DWARFFormValue &RefValue,\n                               const DWARFDie &DIE, CompileUnit *&RefCU);\n\n  /// @}\n\n  /// \\defgroup Methods used to link the debug information\n  ///\n  /// @{\n\n  struct DWARFLinkerOptions;\n\n  class DIECloner {\n    DWARFLinker &Linker;\n    DwarfEmitter *Emitter;\n    DWARFFile &ObjFile;\n\n    /// Allocator used for all the DIEValue objects.\n    BumpPtrAllocator &DIEAlloc;\n\n    std::vector<std::unique_ptr<CompileUnit>> &CompileUnits;\n\n    bool Update;\n\n  public:\n    DIECloner(DWARFLinker &Linker, DwarfEmitter *Emitter, DWARFFile &ObjFile,\n              BumpPtrAllocator &DIEAlloc,\n              std::vector<std::unique_ptr<CompileUnit>> &CompileUnits,\n              bool Update)\n        : Linker(Linker), Emitter(Emitter), ObjFile(ObjFile),\n          DIEAlloc(DIEAlloc), CompileUnits(CompileUnits), Update(Update) {}\n\n    /// Recursively clone \\p InputDIE into an tree of DIE objects\n    /// where useless (as decided by lookForDIEsToKeep()) bits have been\n    /// stripped out and addresses have been rewritten according to the\n    /// address map.\n    ///\n    /// \\param OutOffset is the offset the cloned DIE in the output\n    /// compile unit.\n    /// \\param PCOffset (while cloning a function scope) is the offset\n    /// applied to the entry point of the function to get the linked address.\n    /// \\param Die the output DIE to use, pass NULL to create one.\n    /// \\returns the root of the cloned tree or null if nothing was selected.\n    DIE *cloneDIE(const DWARFDie &InputDIE, const DWARFFile &File,\n                  CompileUnit &U, OffsetsStringPool &StringPool,\n                  int64_t PCOffset, uint32_t OutOffset, unsigned Flags,\n                  bool IsLittleEndian, DIE *Die = nullptr);\n\n    /// Construct the output DIE tree by cloning the DIEs we\n    /// chose to keep above. If there are no valid relocs, then there's\n    /// nothing to clone/emit.\n    uint64_t cloneAllCompileUnits(DWARFContext &DwarfContext,\n                                  const DWARFFile &File,\n                                  OffsetsStringPool &StringPool,\n                                  bool IsLittleEndian);\n\n  private:\n    using AttributeSpec = DWARFAbbreviationDeclaration::AttributeSpec;\n\n    /// Information gathered and exchanged between the various\n    /// clone*Attributes helpers about the attributes of a particular DIE.\n    struct AttributesInfo {\n      /// Names.\n      DwarfStringPoolEntryRef Name, MangledName, NameWithoutTemplate;\n\n      /// Offsets in the string pool.\n      uint32_t NameOffset = 0;\n      uint32_t MangledNameOffset = 0;\n\n      /// Value of AT_low_pc in the input DIE\n      uint64_t OrigLowPc = std::numeric_limits<uint64_t>::max();\n\n      /// Value of AT_high_pc in the input DIE\n      uint64_t OrigHighPc = 0;\n\n      /// Value of DW_AT_call_return_pc in the input DIE\n      uint64_t OrigCallReturnPc = 0;\n\n      /// Value of DW_AT_call_pc in the input DIE\n      uint64_t OrigCallPc = 0;\n\n      /// Offset to apply to PC addresses inside a function.\n      int64_t PCOffset = 0;\n\n      /// Does the DIE have a low_pc attribute?\n      bool HasLowPc = false;\n\n      /// Does the DIE have a ranges attribute?\n      bool HasRanges = false;\n\n      /// Is this DIE only a declaration?\n      bool IsDeclaration = false;\n\n      AttributesInfo() = default;\n    };\n\n    /// Helper for cloneDIE.\n    unsigned cloneAttribute(DIE &Die, const DWARFDie &InputDIE,\n                            const DWARFFile &File, CompileUnit &U,\n                            OffsetsStringPool &StringPool,\n                            const DWARFFormValue &Val,\n                            const AttributeSpec AttrSpec, unsigned AttrSize,\n                            AttributesInfo &AttrInfo, bool IsLittleEndian);\n\n    /// Clone a string attribute described by \\p AttrSpec and add\n    /// it to \\p Die.\n    /// \\returns the size of the new attribute.\n    unsigned cloneStringAttribute(DIE &Die, AttributeSpec AttrSpec,\n                                  const DWARFFormValue &Val, const DWARFUnit &U,\n                                  OffsetsStringPool &StringPool,\n                                  AttributesInfo &Info);\n\n    /// Clone an attribute referencing another DIE and add\n    /// it to \\p Die.\n    /// \\returns the size of the new attribute.\n    unsigned cloneDieReferenceAttribute(DIE &Die, const DWARFDie &InputDIE,\n                                        AttributeSpec AttrSpec,\n                                        unsigned AttrSize,\n                                        const DWARFFormValue &Val,\n                                        const DWARFFile &File,\n                                        CompileUnit &Unit);\n\n    /// Clone a DWARF expression that may be referencing another DIE.\n    void cloneExpression(DataExtractor &Data, DWARFExpression Expression,\n                         const DWARFFile &File, CompileUnit &Unit,\n                         SmallVectorImpl<uint8_t> &OutputBuffer);\n\n    /// Clone an attribute referencing another DIE and add\n    /// it to \\p Die.\n    /// \\returns the size of the new attribute.\n    unsigned cloneBlockAttribute(DIE &Die, const DWARFFile &File,\n                                 CompileUnit &Unit, AttributeSpec AttrSpec,\n                                 const DWARFFormValue &Val, unsigned AttrSize,\n                                 bool IsLittleEndian);\n\n    /// Clone an attribute referencing another DIE and add\n    /// it to \\p Die.\n    /// \\returns the size of the new attribute.\n    unsigned cloneAddressAttribute(DIE &Die, AttributeSpec AttrSpec,\n                                   const DWARFFormValue &Val,\n                                   const CompileUnit &Unit,\n                                   AttributesInfo &Info);\n\n    /// Clone a scalar attribute  and add it to \\p Die.\n    /// \\returns the size of the new attribute.\n    unsigned cloneScalarAttribute(DIE &Die, const DWARFDie &InputDIE,\n                                  const DWARFFile &File, CompileUnit &U,\n                                  AttributeSpec AttrSpec,\n                                  const DWARFFormValue &Val, unsigned AttrSize,\n                                  AttributesInfo &Info);\n\n    /// Get the potential name and mangled name for the entity\n    /// described by \\p Die and store them in \\Info if they are not\n    /// already there.\n    /// \\returns is a name was found.\n    bool getDIENames(const DWARFDie &Die, AttributesInfo &Info,\n                     OffsetsStringPool &StringPool, bool StripTemplate = false);\n\n    /// Create a copy of abbreviation Abbrev.\n    void copyAbbrev(const DWARFAbbreviationDeclaration &Abbrev, bool hasODR);\n\n    uint32_t hashFullyQualifiedName(DWARFDie DIE, CompileUnit &U,\n                                    const DWARFFile &File,\n                                    int RecurseDepth = 0);\n\n    /// Helper for cloneDIE.\n    void addObjCAccelerator(CompileUnit &Unit, const DIE *Die,\n                            DwarfStringPoolEntryRef Name,\n                            OffsetsStringPool &StringPool, bool SkipPubSection);\n  };\n\n  /// Assign an abbreviation number to \\p Abbrev\n  void assignAbbrev(DIEAbbrev &Abbrev);\n\n  /// Compute and emit debug_ranges section for \\p Unit, and\n  /// patch the attributes referencing it.\n  void patchRangesForUnit(const CompileUnit &Unit, DWARFContext &Dwarf,\n                          const DWARFFile &File) const;\n\n  /// Generate and emit the DW_AT_ranges attribute for a compile_unit if it had\n  /// one.\n  void generateUnitRanges(CompileUnit &Unit) const;\n\n  /// Extract the line tables from the original dwarf, extract the relevant\n  /// parts according to the linked function ranges and emit the result in the\n  /// debug_line section.\n  void patchLineTableForUnit(CompileUnit &Unit, DWARFContext &OrigDwarf,\n                             const DWARFFile &File);\n\n  /// Emit the accelerator entries for \\p Unit.\n  void emitAcceleratorEntriesForUnit(CompileUnit &Unit);\n  void emitDwarfAcceleratorEntriesForUnit(CompileUnit &Unit);\n  void emitAppleAcceleratorEntriesForUnit(CompileUnit &Unit);\n\n  /// Patch the frame info for an object file and emit it.\n  void patchFrameInfoForObject(const DWARFFile &, RangesTy &Ranges,\n                               DWARFContext &, unsigned AddressSize);\n\n  /// FoldingSet that uniques the abbreviations.\n  FoldingSet<DIEAbbrev> AbbreviationsSet;\n\n  /// Storage for the unique Abbreviations.\n  /// This is passed to AsmPrinter::emitDwarfAbbrevs(), thus it cannot be\n  /// changed to a vector of unique_ptrs.\n  std::vector<std::unique_ptr<DIEAbbrev>> Abbreviations;\n\n  /// DIELoc objects that need to be destructed (but not freed!).\n  std::vector<DIELoc *> DIELocs;\n\n  /// DIEBlock objects that need to be destructed (but not freed!).\n  std::vector<DIEBlock *> DIEBlocks;\n\n  /// Allocator used for all the DIEValue objects.\n  BumpPtrAllocator DIEAlloc;\n  /// @}\n\n  DwarfEmitter *TheDwarfEmitter;\n  std::vector<LinkContext> ObjectContexts;\n\n  unsigned MaxDwarfVersion = 0;\n  unsigned MinDwarfVersion = std::numeric_limits<unsigned>::max();\n\n  bool AtLeastOneAppleAccelTable = false;\n  bool AtLeastOneDwarfAccelTable = false;\n\n  /// The CIEs that have been emitted in the output section. The actual CIE\n  /// data serves a the key to this StringMap, this takes care of comparing the\n  /// semantics of CIEs defined in different object files.\n  StringMap<uint32_t> EmittedCIEs;\n\n  /// Offset of the last CIE that has been emitted in the output\n  /// debug_frame section.\n  uint32_t LastCIEOffset = 0;\n\n  /// Apple accelerator tables.\n  AccelTable<DWARF5AccelTableStaticData> DebugNames;\n  AccelTable<AppleAccelTableStaticOffsetData> AppleNames;\n  AccelTable<AppleAccelTableStaticOffsetData> AppleNamespaces;\n  AccelTable<AppleAccelTableStaticOffsetData> AppleObjc;\n  AccelTable<AppleAccelTableStaticTypeData> AppleTypes;\n\n  /// Mapping the PCM filename to the DwoId.\n  StringMap<uint64_t> ClangModules;\n\n  DwarfLinkerClient DwarfLinkerClientID;\n\n  std::function<StringRef(StringRef)> StringsTranslator = nullptr;\n\n  /// linking options\n  struct DWARFLinkerOptions {\n    /// Generate processing log to the standard output.\n    bool Verbose = false;\n\n    /// Print statistics.\n    bool Statistics = false;\n\n    /// Skip emitting output\n    bool NoOutput = false;\n\n    /// Do not unique types according to ODR\n    bool NoODR = false;\n\n    /// Update\n    bool Update = false;\n\n    /// Number of threads.\n    unsigned Threads = 1;\n\n    /// The accelerator table kind\n    AccelTableKind TheAccelTableKind = AccelTableKind::Default;\n\n    /// Prepend path for the clang modules.\n    std::string PrependPath;\n\n    // warning handler\n    messageHandler WarningHandler = nullptr;\n\n    // error handler\n    messageHandler ErrorHandler = nullptr;\n\n    objFileLoader ObjFileLoader = nullptr;\n\n    /// A list of all .swiftinterface files referenced by the debug\n    /// info, mapping Module name to path on disk. The entries need to\n    /// be uniqued and sorted and there are only few entries expected\n    /// per compile unit, which is why this is a std::map.\n    /// this is dsymutil specific fag.\n    swiftInterfacesMap *ParseableSwiftInterfaces = nullptr;\n\n    /// A list of remappings to apply to file paths.\n    objectPrefixMap *ObjectPrefixMap = nullptr;\n  } Options;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DWARFLINKER_DWARFLINKER_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerCompileUnit.h", "content": "//===- DWARFLinkerCompileUnit.h ---------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DWARFLINKER_DWARFLINKERCOMPILEUNIT_H\n#define LLVM_DWARFLINKER_DWARFLINKERCOMPILEUNIT_H\n\n#include \"llvm/ADT/IntervalMap.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnit.h\"\n#include \"llvm/Support/DataExtractor.h\"\n\nnamespace llvm {\n\nclass DeclContext;\n\ntemplate <typename KeyT, typename ValT>\nusing HalfOpenIntervalMap =\n    IntervalMap<KeyT, ValT, IntervalMapImpl::NodeSizer<KeyT, ValT>::LeafSize,\n                IntervalMapHalfOpenInfo<KeyT>>;\n\nusing FunctionIntervals = HalfOpenIntervalMap<uint64_t, int64_t>;\n\n// FIXME: Delete this structure.\nstruct PatchLocation {\n  DIE::value_iterator I;\n\n  PatchLocation() = default;\n  PatchLocation(DIE::value_iterator I) : I(I) {}\n\n  void set(uint64_t New) const {\n    assert(I);\n    const auto &Old = *I;\n    assert(Old.getType() == DIEValue::isInteger);\n    *I = DIEValue(Old.getAttribute(), Old.getForm(), DIEInteger(New));\n  }\n\n  uint64_t get() const {\n    assert(I);\n    return I->getDIEInteger().getValue();\n  }\n};\n\n/// Stores all information relating to a compile unit, be it in its original\n/// instance in the object file to its brand new cloned and generated DIE tree.\nclass CompileUnit {\npublic:\n  /// Information gathered about a DIE in the object file.\n  struct DIEInfo {\n    /// Address offset to apply to the described entity.\n    int64_t AddrAdjust;\n\n    /// ODR Declaration context.\n    DeclContext *Ctxt;\n\n    /// Cloned version of that DIE.\n    DIE *Clone;\n\n    /// The index of this DIE's parent.\n    uint32_t ParentIdx;\n\n    /// Is the DIE part of the linked output?\n    bool Keep : 1;\n\n    /// Was this DIE's entity found in the map?\n    bool InDebugMap : 1;\n\n    /// Is this a pure forward declaration we can strip?\n    bool Prune : 1;\n\n    /// Does DIE transitively refer an incomplete decl?\n    bool Incomplete : 1;\n  };\n\n  CompileUnit(DWARFUnit &OrigUnit, unsigned ID, bool CanUseODR,\n              StringRef ClangModuleName)\n      : OrigUnit(OrigUnit), ID(ID), Ranges(RangeAlloc),\n        ClangModuleName(ClangModuleName) {\n    Info.resize(OrigUnit.getNumDIEs());\n\n    auto CUDie = OrigUnit.getUnitDIE(false);\n    if (!CUDie) {\n      HasODR = false;\n      return;\n    }\n    if (auto Lang = dwarf::toUnsigned(CUDie.find(dwarf::DW_AT_language)))\n      HasODR = CanUseODR && (*Lang == dwarf::DW_LANG_C_plus_plus ||\n                             *Lang == dwarf::DW_LANG_C_plus_plus_03 ||\n                             *Lang == dwarf::DW_LANG_C_plus_plus_11 ||\n                             *Lang == dwarf::DW_LANG_C_plus_plus_14 ||\n                             *Lang == dwarf::DW_LANG_ObjC_plus_plus);\n    else\n      HasODR = false;\n  }\n\n  DWARFUnit &getOrigUnit() const { return OrigUnit; }\n\n  unsigned getUniqueID() const { return ID; }\n\n  void createOutputDIE() { NewUnit.emplace(OrigUnit.getUnitDIE().getTag()); }\n\n  DIE *getOutputUnitDIE() const {\n    if (NewUnit)\n      return &const_cast<BasicDIEUnit &>(*NewUnit).getUnitDie();\n    return nullptr;\n  }\n\n  bool hasODR() const { return HasODR; }\n  bool isClangModule() const { return !ClangModuleName.empty(); }\n  uint16_t getLanguage();\n  /// Return the DW_AT_LLVM_sysroot of the compile unit or an empty StringRef.\n  StringRef getSysRoot();\n\n  const std::string &getClangModuleName() const { return ClangModuleName; }\n\n  DIEInfo &getInfo(unsigned Idx) { return Info[Idx]; }\n  const DIEInfo &getInfo(unsigned Idx) const { return Info[Idx]; }\n\n  DIEInfo &getInfo(const DWARFDie &Die) {\n    unsigned Idx = getOrigUnit().getDIEIndex(Die);\n    return Info[Idx];\n  }\n\n  uint64_t getStartOffset() const { return StartOffset; }\n  uint64_t getNextUnitOffset() const { return NextUnitOffset; }\n  void setStartOffset(uint64_t DebugInfoSize) { StartOffset = DebugInfoSize; }\n\n  uint64_t getLowPc() const { return LowPc; }\n  uint64_t getHighPc() const { return HighPc; }\n  bool hasLabelAt(uint64_t Addr) const { return Labels.count(Addr); }\n\n  Optional<PatchLocation> getUnitRangesAttribute() const {\n    return UnitRangeAttribute;\n  }\n\n  const FunctionIntervals &getFunctionRanges() const { return Ranges; }\n\n  const std::vector<PatchLocation> &getRangesAttributes() const {\n    return RangeAttributes;\n  }\n\n  const std::vector<std::pair<PatchLocation, int64_t>> &\n  getLocationAttributes() const {\n    return LocationAttributes;\n  }\n\n  void setHasInterestingContent() { HasInterestingContent = true; }\n  bool hasInterestingContent() { return HasInterestingContent; }\n\n  /// Mark every DIE in this unit as kept. This function also\n  /// marks variables as InDebugMap so that they appear in the\n  /// reconstructed accelerator tables.\n  void markEverythingAsKept();\n\n  /// Compute the end offset for this unit. Must be called after the CU's DIEs\n  /// have been cloned.  \\returns the next unit offset (which is also the\n  /// current debug_info section size).\n  uint64_t computeNextUnitOffset(uint16_t DwarfVersion);\n\n  /// Keep track of a forward reference to DIE \\p Die in \\p RefUnit by \\p\n  /// Attr. The attribute should be fixed up later to point to the absolute\n  /// offset of \\p Die in the debug_info section or to the canonical offset of\n  /// \\p Ctxt if it is non-null.\n  void noteForwardReference(DIE *Die, const CompileUnit *RefUnit,\n                            DeclContext *Ctxt, PatchLocation Attr);\n\n  /// Apply all fixups recorded by noteForwardReference().\n  void fixupForwardReferences();\n\n  /// Add the low_pc of a label that is relocated by applying\n  /// offset \\p PCOffset.\n  void addLabelLowPc(uint64_t LabelLowPc, int64_t PcOffset);\n\n  /// Add a function range [\\p LowPC, \\p HighPC) that is relocated by applying\n  /// offset \\p PCOffset.\n  void addFunctionRange(uint64_t LowPC, uint64_t HighPC, int64_t PCOffset);\n\n  /// Keep track of a DW_AT_range attribute that we will need to patch up later.\n  void noteRangeAttribute(const DIE &Die, PatchLocation Attr);\n\n  /// Keep track of a location attribute pointing to a location list in the\n  /// debug_loc section.\n  void noteLocationAttribute(PatchLocation Attr, int64_t PcOffset);\n\n  /// Add a name accelerator entry for \\a Die with \\a Name.\n  void addNamespaceAccelerator(const DIE *Die, DwarfStringPoolEntryRef Name);\n\n  /// Add a name accelerator entry for \\a Die with \\a Name.\n  void addNameAccelerator(const DIE *Die, DwarfStringPoolEntryRef Name,\n                          bool SkipPubnamesSection = false);\n\n  /// Add various accelerator entries for \\p Die with \\p Name which is stored\n  /// in the string table at \\p Offset. \\p Name must be an Objective-C\n  /// selector.\n  void addObjCAccelerator(const DIE *Die, DwarfStringPoolEntryRef Name,\n                          bool SkipPubnamesSection = false);\n\n  /// Add a type accelerator entry for \\p Die with \\p Name which is stored in\n  /// the string table at \\p Offset.\n  void addTypeAccelerator(const DIE *Die, DwarfStringPoolEntryRef Name,\n                          bool ObjcClassImplementation,\n                          uint32_t QualifiedNameHash);\n\n  struct AccelInfo {\n    /// Name of the entry.\n    DwarfStringPoolEntryRef Name;\n\n    /// DIE this entry describes.\n    const DIE *Die;\n\n    /// Hash of the fully qualified name.\n    uint32_t QualifiedNameHash;\n\n    /// Emit this entry only in the apple_* sections.\n    bool SkipPubSection;\n\n    /// Is this an ObjC class implementation?\n    bool ObjcClassImplementation;\n\n    AccelInfo(DwarfStringPoolEntryRef Name, const DIE *Die,\n              bool SkipPubSection = false)\n        : Name(Name), Die(Die), SkipPubSection(SkipPubSection) {}\n\n    AccelInfo(DwarfStringPoolEntryRef Name, const DIE *Die,\n              uint32_t QualifiedNameHash, bool ObjCClassIsImplementation)\n        : Name(Name), Die(Die), QualifiedNameHash(QualifiedNameHash),\n          SkipPubSection(false),\n          ObjcClassImplementation(ObjCClassIsImplementation) {}\n  };\n\n  const std::vector<AccelInfo> &getPubnames() const { return Pubnames; }\n  const std::vector<AccelInfo> &getPubtypes() const { return Pubtypes; }\n  const std::vector<AccelInfo> &getNamespaces() const { return Namespaces; }\n  const std::vector<AccelInfo> &getObjC() const { return ObjC; }\n\n  MCSymbol *getLabelBegin() { return LabelBegin; }\n  void setLabelBegin(MCSymbol *S) { LabelBegin = S; }\n\nprivate:\n  DWARFUnit &OrigUnit;\n  unsigned ID;\n  std::vector<DIEInfo> Info; ///< DIE info indexed by DIE index.\n  Optional<BasicDIEUnit> NewUnit;\n  MCSymbol *LabelBegin = nullptr;\n\n  uint64_t StartOffset;\n  uint64_t NextUnitOffset;\n\n  uint64_t LowPc = std::numeric_limits<uint64_t>::max();\n  uint64_t HighPc = 0;\n\n  /// A list of attributes to fixup with the absolute offset of\n  /// a DIE in the debug_info section.\n  ///\n  /// The offsets for the attributes in this array couldn't be set while\n  /// cloning because for cross-cu forward references the target DIE's offset\n  /// isn't known you emit the reference attribute.\n  std::vector<\n      std::tuple<DIE *, const CompileUnit *, DeclContext *, PatchLocation>>\n      ForwardDIEReferences;\n\n  FunctionIntervals::Allocator RangeAlloc;\n\n  /// The ranges in that interval map are the PC ranges for\n  /// functions in this unit, associated with the PC offset to apply\n  /// to the addresses to get the linked address.\n  FunctionIntervals Ranges;\n\n  /// The DW_AT_low_pc of each DW_TAG_label.\n  SmallDenseMap<uint64_t, uint64_t, 1> Labels;\n\n  /// DW_AT_ranges attributes to patch after we have gathered\n  /// all the unit's function addresses.\n  /// @{\n  std::vector<PatchLocation> RangeAttributes;\n  Optional<PatchLocation> UnitRangeAttribute;\n  /// @}\n\n  /// Location attributes that need to be transferred from the\n  /// original debug_loc section to the liked one. They are stored\n  /// along with the PC offset that is to be applied to their\n  /// function's address.\n  std::vector<std::pair<PatchLocation, int64_t>> LocationAttributes;\n\n  /// Accelerator entries for the unit, both for the pub*\n  /// sections and the apple* ones.\n  /// @{\n  std::vector<AccelInfo> Pubnames;\n  std::vector<AccelInfo> Pubtypes;\n  std::vector<AccelInfo> Namespaces;\n  std::vector<AccelInfo> ObjC;\n  /// @}\n\n  /// Is this unit subject to the ODR rule?\n  bool HasODR;\n\n  /// Did a DIE actually contain a valid reloc?\n  bool HasInterestingContent;\n\n  /// The DW_AT_language of this unit.\n  uint16_t Language = 0;\n\n  /// The DW_AT_LLVM_sysroot of this unit.\n  std::string SysRoot;\n\n  /// If this is a Clang module, this holds the module's name.\n  std::string ClangModuleName;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DWARFLINKER_DWARFLINKERCOMPILEUNIT_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerDeclContext.h", "content": "//===- DWARFLinkerDeclContext.h ---------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DWARFLINKER_DWARFLINKERDECLCONTEXT_H\n#define LLVM_DWARFLINKER_DWARFLINKERDECLCONTEXT_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/CodeGen/NonRelocatableStringpool.h\"\n#include \"llvm/DWARFLinker/DWARFLinkerCompileUnit.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLine.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDie.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n\nnamespace llvm {\n\nstruct DeclMapInfo;\n\n/// Small helper that resolves and caches file paths. This helps reduce the\n/// number of calls to realpath which is expensive. We assume the input are\n/// files, and cache the realpath of their parent. This way we can quickly\n/// resolve different files under the same path.\nclass CachedPathResolver {\npublic:\n  /// Resolve a path by calling realpath and cache its result. The returned\n  /// StringRef is interned in the given \\p StringPool.\n  StringRef resolve(const std::string &Path,\n                    NonRelocatableStringpool &StringPool) {\n    StringRef FileName = sys::path::filename(Path);\n    StringRef ParentPath = sys::path::parent_path(Path);\n\n    // If the ParentPath has not yet been resolved, resolve and cache it for\n    // future look-ups.\n    if (!ResolvedPaths.count(ParentPath)) {\n      SmallString<256> RealPath;\n      sys::fs::real_path(ParentPath, RealPath);\n      ResolvedPaths.insert(\n          {ParentPath, std::string(RealPath.c_str(), RealPath.size())});\n    }\n\n    // Join the file name again with the resolved path.\n    SmallString<256> ResolvedPath(ResolvedPaths[ParentPath]);\n    sys::path::append(ResolvedPath, FileName);\n    return StringPool.internString(ResolvedPath);\n  }\n\nprivate:\n  StringMap<std::string> ResolvedPaths;\n};\n\n/// A DeclContext is a named program scope that is used for ODR uniquing of\n/// types.\n///\n/// The set of DeclContext for the ODR-subject parts of a Dwarf link is\n/// expanded (and uniqued) with each new object file processed. We need to\n/// determine the context of each DIE in an linked object file to see if the\n/// corresponding type has already been emitted.\n///\n/// The contexts are conceptually organized as a tree (eg. a function scope is\n/// contained in a namespace scope that contains other scopes), but\n/// storing/accessing them in an actual tree is too inefficient: we need to be\n/// able to very quickly query a context for a given child context by name.\n/// Storing a StringMap in each DeclContext would be too space inefficient.\n///\n/// The solution here is to give each DeclContext a link to its parent (this\n/// allows to walk up the tree), but to query the existence of a specific\n/// DeclContext using a separate DenseMap keyed on the hash of the fully\n/// qualified name of the context.\nclass DeclContext {\npublic:\n  using Map = DenseSet<DeclContext *, DeclMapInfo>;\n\n  DeclContext() : DefinedInClangModule(0), Parent(*this) {}\n\n  DeclContext(unsigned Hash, uint32_t Line, uint32_t ByteSize, uint16_t Tag,\n              StringRef Name, StringRef File, const DeclContext &Parent,\n              DWARFDie LastSeenDIE = DWARFDie(), unsigned CUId = 0)\n      : QualifiedNameHash(Hash), Line(Line), ByteSize(ByteSize), Tag(Tag),\n        DefinedInClangModule(0), Name(Name), File(File), Parent(Parent),\n        LastSeenDIE(LastSeenDIE), LastSeenCompileUnitID(CUId) {}\n\n  uint32_t getQualifiedNameHash() const { return QualifiedNameHash; }\n\n  bool setLastSeenDIE(CompileUnit &U, const DWARFDie &Die);\n\n  uint32_t getCanonicalDIEOffset() const { return CanonicalDIEOffset; }\n  void setCanonicalDIEOffset(uint32_t Offset) { CanonicalDIEOffset = Offset; }\n\n  bool isDefinedInClangModule() const { return DefinedInClangModule; }\n  void setDefinedInClangModule(bool Val) { DefinedInClangModule = Val; }\n\n  uint16_t getTag() const { return Tag; }\n\nprivate:\n  friend DeclMapInfo;\n\n  unsigned QualifiedNameHash = 0;\n  uint32_t Line = 0;\n  uint32_t ByteSize = 0;\n  uint16_t Tag = dwarf::DW_TAG_compile_unit;\n  unsigned DefinedInClangModule : 1;\n  StringRef Name;\n  StringRef File;\n  const DeclContext &Parent;\n  DWARFDie LastSeenDIE;\n  uint32_t LastSeenCompileUnitID = 0;\n  uint32_t CanonicalDIEOffset = 0;\n};\n\n/// This class gives a tree-like API to the DenseMap that stores the\n/// DeclContext objects. It holds the BumpPtrAllocator where these objects will\n/// be allocated.\nclass DeclContextTree {\npublic:\n  /// Get the child of \\a Context described by \\a DIE in \\a Unit. The\n  /// required strings will be interned in \\a StringPool.\n  /// \\returns The child DeclContext along with one bit that is set if\n  /// this context is invalid.\n  ///\n  /// An invalid context means it shouldn't be considered for uniquing, but its\n  /// not returning null, because some children of that context might be\n  /// uniquing candidates.\n  ///\n  /// FIXME: The invalid bit along the return value is to emulate some\n  /// dsymutil-classic functionality.\n  PointerIntPair<DeclContext *, 1> getChildDeclContext(DeclContext &Context,\n                                                       const DWARFDie &DIE,\n                                                       CompileUnit &Unit,\n                                                       bool InClangModule);\n\n  DeclContext &getRoot() { return Root; }\n\nprivate:\n  BumpPtrAllocator Allocator;\n  DeclContext Root;\n  DeclContext::Map Contexts;\n\n  /// Cached resolved paths from the line table.\n  /// The key is <UniqueUnitID, FileIdx>.\n  using ResolvedPathsMap = DenseMap<std::pair<unsigned, unsigned>, StringRef>;\n  ResolvedPathsMap ResolvedPaths;\n\n  /// Helper that resolves and caches fragments of file paths.\n  CachedPathResolver PathResolver;\n\n  /// String pool keeping real path bodies.\n  NonRelocatableStringpool StringPool;\n\n  StringRef getResolvedPath(CompileUnit &CU, unsigned FileNum,\n                            const DWARFDebugLine::LineTable &LineTable);\n};\n\n/// Info type for the DenseMap storing the DeclContext pointers.\nstruct DeclMapInfo : private DenseMapInfo<DeclContext *> {\n  using DenseMapInfo<DeclContext *>::getEmptyKey;\n  using DenseMapInfo<DeclContext *>::getTombstoneKey;\n\n  static unsigned getHashValue(const DeclContext *Ctxt) {\n    return Ctxt->QualifiedNameHash;\n  }\n\n  static bool isEqual(const DeclContext *LHS, const DeclContext *RHS) {\n    if (RHS == getEmptyKey() || RHS == getTombstoneKey())\n      return RHS == LHS;\n    return LHS->QualifiedNameHash == RHS->QualifiedNameHash &&\n           LHS->Line == RHS->Line && LHS->ByteSize == RHS->ByteSize &&\n           LHS->Name.data() == RHS->Name.data() &&\n           LHS->File.data() == RHS->File.data() &&\n           LHS->Parent.QualifiedNameHash == RHS->Parent.QualifiedNameHash;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DWARFLINKER_DWARFLINKERDECLCONTEXT_H\n"}, "94": {"id": 94, "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "content": "//=== DWARFLinker.cpp -----------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/DWARFLinker/DWARFLinker.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/CodeGen/NonRelocatableStringpool.h\"\n#include \"llvm/DWARFLinker/DWARFLinkerDeclContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLine.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDie.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFSection.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnit.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/LEB128.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/ThreadPool.h\"\n#include <vector>\n\nnamespace llvm {\n\n/// Hold the input and output of the debug info size in bytes.\nstruct DebugInfoSize {\n  uint64_t Input;\n  uint64_t Output;\n};\n\n/// Compute the total size of the debug info.\nstatic uint64_t getDebugInfoSize(DWARFContext &Dwarf) {\n  uint64_t Size = 0;\n  for (auto &Unit : Dwarf.compile_units()) {\n    Size += Unit->getLength();\n  }\n  return Size;\n}\n\n/// Similar to DWARFUnitSection::getUnitForOffset(), but returning our\n/// CompileUnit object instead.\nstatic CompileUnit *getUnitForOffset(const UnitListTy &Units, uint64_t Offset) {\n  auto CU = llvm::upper_bound(\n      Units, Offset, [](uint64_t LHS, const std::unique_ptr<CompileUnit> &RHS) {\n        return LHS < RHS->getOrigUnit().getNextUnitOffset();\n      });\n  return CU != Units.end() ? CU->get() : nullptr;\n}\n\n/// Resolve the DIE attribute reference that has been extracted in \\p RefValue.\n/// The resulting DIE might be in another CompileUnit which is stored into \\p\n/// ReferencedCU. \\returns null if resolving fails for any reason.\nDWARFDie DWARFLinker::resolveDIEReference(const DWARFFile &File,\n                                          const UnitListTy &Units,\n                                          const DWARFFormValue &RefValue,\n                                          const DWARFDie &DIE,\n                                          CompileUnit *&RefCU) {\n  assert(RefValue.isFormClass(DWARFFormValue::FC_Reference));\n  uint64_t RefOffset = *RefValue.getAsReference();\n  if ((RefCU = getUnitForOffset(Units, RefOffset)))\n    if (const auto RefDie = RefCU->getOrigUnit().getDIEForOffset(RefOffset)) {\n      // In a file with broken references, an attribute might point to a NULL\n      // DIE.\n      if (!RefDie.isNULL())\n        return RefDie;\n    }\n\n  reportWarning(\"could not find referenced DIE\", File, &DIE);\n  return DWARFDie();\n}\n\n/// \\returns whether the passed \\a Attr type might contain a DIE reference\n/// suitable for ODR uniquing.\nstatic bool isODRAttribute(uint16_t Attr) {\n  switch (Attr) {\n  default:\n    return false;\n  case dwarf::DW_AT_type:\n  case dwarf::DW_AT_containing_type:\n  case dwarf::DW_AT_specification:\n  case dwarf::DW_AT_abstract_origin:\n  case dwarf::DW_AT_import:\n    return true;\n  }\n  llvm_unreachable(\"Improper attribute.\");\n}\n\nstatic bool isTypeTag(uint16_t Tag) {\n  switch (Tag) {\n  case dwarf::DW_TAG_array_type:\n  case dwarf::DW_TAG_class_type:\n  case dwarf::DW_TAG_enumeration_type:\n  case dwarf::DW_TAG_pointer_type:\n  case dwarf::DW_TAG_reference_type:\n  case dwarf::DW_TAG_string_type:\n  case dwarf::DW_TAG_structure_type:\n  case dwarf::DW_TAG_subroutine_type:\n  case dwarf::DW_TAG_typedef:\n  case dwarf::DW_TAG_union_type:\n  case dwarf::DW_TAG_ptr_to_member_type:\n  case dwarf::DW_TAG_set_type:\n  case dwarf::DW_TAG_subrange_type:\n  case dwarf::DW_TAG_base_type:\n  case dwarf::DW_TAG_const_type:\n  case dwarf::DW_TAG_constant:\n  case dwarf::DW_TAG_file_type:\n  case dwarf::DW_TAG_namelist:\n  case dwarf::DW_TAG_packed_type:\n  case dwarf::DW_TAG_volatile_type:\n  case dwarf::DW_TAG_restrict_type:\n  case dwarf::DW_TAG_atomic_type:\n  case dwarf::DW_TAG_interface_type:\n  case dwarf::DW_TAG_unspecified_type:\n  case dwarf::DW_TAG_shared_type:\n    return true;\n  default:\n    break;\n  }\n  return false;\n}\n\nAddressesMap::~AddressesMap() {}\n\nDwarfEmitter::~DwarfEmitter() {}\n\nstatic Optional<StringRef> StripTemplateParameters(StringRef Name) {\n  // We are looking for template parameters to strip from Name. e.g.\n  //\n  //  operator<<B>\n  //\n  // We look for > at the end but if it does not contain any < then we\n  // have something like operator>>. We check for the operator<=> case.\n  if (!Name.endswith(\">\") || Name.count(\"<\") == 0 || Name.endswith(\"<=>\"))\n    return {};\n\n  // How many < until we have the start of the template parameters.\n  size_t NumLeftAnglesToSkip = 1;\n\n  // If we have operator<=> then we need to skip its < as well.\n  NumLeftAnglesToSkip += Name.count(\"<=>\");\n\n  size_t RightAngleCount = Name.count('>');\n  size_t LeftAngleCount = Name.count('<');\n\n  // If we have more < than > we have operator< or operator<<\n  // we to account for their < as well.\n  if (LeftAngleCount > RightAngleCount)\n    NumLeftAnglesToSkip += LeftAngleCount - RightAngleCount;\n\n  size_t StartOfTemplate = 0;\n  while (NumLeftAnglesToSkip--)\n    StartOfTemplate = Name.find('<', StartOfTemplate) + 1;\n\n  return Name.substr(0, StartOfTemplate - 1);\n}\n\nbool DWARFLinker::DIECloner::getDIENames(const DWARFDie &Die,\n                                         AttributesInfo &Info,\n                                         OffsetsStringPool &StringPool,\n                                         bool StripTemplate) {\n  // This function will be called on DIEs having low_pcs and\n  // ranges. As getting the name might be more expansive, filter out\n  // blocks directly.\n  if (Die.getTag() == dwarf::DW_TAG_lexical_block)\n    return false;\n\n  if (!Info.MangledName)\n    if (const char *MangledName = Die.getLinkageName())\n      Info.MangledName = StringPool.getEntry(MangledName);\n\n  if (!Info.Name)\n    if (const char *Name = Die.getShortName())\n      Info.Name = StringPool.getEntry(Name);\n\n  if (!Info.MangledName)\n    Info.MangledName = Info.Name;\n\n  if (StripTemplate && Info.Name && Info.MangledName != Info.Name) {\n    StringRef Name = Info.Name.getString();\n    if (Optional<StringRef> StrippedName = StripTemplateParameters(Name))\n      Info.NameWithoutTemplate = StringPool.getEntry(*StrippedName);\n  }\n\n  return Info.Name || Info.MangledName;\n}\n\n/// Resolve the relative path to a build artifact referenced by DWARF by\n/// applying DW_AT_comp_dir.\nstatic void resolveRelativeObjectPath(SmallVectorImpl<char> &Buf, DWARFDie CU) {\n  sys::path::append(Buf, dwarf::toString(CU.find(dwarf::DW_AT_comp_dir), \"\"));\n}\n\n/// Collect references to parseable Swift interfaces in imported\n/// DW_TAG_module blocks.\nstatic void analyzeImportedModule(\n    const DWARFDie &DIE, CompileUnit &CU,\n    swiftInterfacesMap *ParseableSwiftInterfaces,\n    std::function<void(const Twine &, const DWARFDie &)> ReportWarning) {\n  if (CU.getLanguage() != dwarf::DW_LANG_Swift)\n    return;\n\n  if (!ParseableSwiftInterfaces)\n    return;\n\n  StringRef Path = dwarf::toStringRef(DIE.find(dwarf::DW_AT_LLVM_include_path));\n  if (!Path.endswith(\".swiftinterface\"))\n    return;\n  // Don't track interfaces that are part of the SDK.\n  StringRef SysRoot = dwarf::toStringRef(DIE.find(dwarf::DW_AT_LLVM_sysroot));\n  if (SysRoot.empty())\n    SysRoot = CU.getSysRoot();\n  if (!SysRoot.empty() && Path.startswith(SysRoot))\n    return;\n  if (Optional<DWARFFormValue> Val = DIE.find(dwarf::DW_AT_name))\n    if (Optional<const char *> Name = Val->getAsCString()) {\n      auto &Entry = (*ParseableSwiftInterfaces)[*Name];\n      // The prepend path is applied later when copying.\n      DWARFDie CUDie = CU.getOrigUnit().getUnitDIE();\n      SmallString<128> ResolvedPath;\n      if (sys::path::is_relative(Path))\n        resolveRelativeObjectPath(ResolvedPath, CUDie);\n      sys::path::append(ResolvedPath, Path);\n      if (!Entry.empty() && Entry != ResolvedPath)\n        ReportWarning(\n            Twine(\"Conflicting parseable interfaces for Swift Module \") +\n                *Name + \": \" + Entry + \" and \" + Path,\n            DIE);\n      Entry = std::string(ResolvedPath.str());\n    }\n}\n\n/// The distinct types of work performed by the work loop in\n/// analyzeContextInfo.\nenum class ContextWorklistItemType : uint8_t {\n  AnalyzeContextInfo,\n  UpdateChildPruning,\n  UpdatePruning,\n};\n\n/// This class represents an item in the work list. The type defines what kind\n/// of work needs to be performed when processing the current item. Everything\n/// but the Type and Die fields are optional based on the type.\nstruct ContextWorklistItem {\n  DWARFDie Die;\n  unsigned ParentIdx;\n  union {\n    CompileUnit::DIEInfo *OtherInfo;\n    DeclContext *Context;\n  };\n  ContextWorklistItemType Type;\n  bool InImportedModule;\n\n  ContextWorklistItem(DWARFDie Die, ContextWorklistItemType T,\n                      CompileUnit::DIEInfo *OtherInfo = nullptr)\n      : Die(Die), ParentIdx(0), OtherInfo(OtherInfo), Type(T),\n        InImportedModule(false) {}\n\n  ContextWorklistItem(DWARFDie Die, DeclContext *Context, unsigned ParentIdx,\n                      bool InImportedModule)\n      : Die(Die), ParentIdx(ParentIdx), Context(Context),\n        Type(ContextWorklistItemType::AnalyzeContextInfo),\n        InImportedModule(InImportedModule) {}\n};\n\nstatic bool updatePruning(const DWARFDie &Die, CompileUnit &CU,\n                          uint64_t ModulesEndOffset) {\n  CompileUnit::DIEInfo &Info = CU.getInfo(Die);\n\n  // Prune this DIE if it is either a forward declaration inside a\n  // DW_TAG_module or a DW_TAG_module that contains nothing but\n  // forward declarations.\n  Info.Prune &= (Die.getTag() == dwarf::DW_TAG_module) ||\n                (isTypeTag(Die.getTag()) &&\n                 dwarf::toUnsigned(Die.find(dwarf::DW_AT_declaration), 0));\n\n  // Only prune forward declarations inside a DW_TAG_module for which a\n  // definition exists elsewhere.\n  if (ModulesEndOffset == 0)\n    Info.Prune &= Info.Ctxt && Info.Ctxt->getCanonicalDIEOffset();\n  else\n    Info.Prune &= Info.Ctxt && Info.Ctxt->getCanonicalDIEOffset() > 0 &&\n                  Info.Ctxt->getCanonicalDIEOffset() <= ModulesEndOffset;\n\n  return Info.Prune;\n}\n\nstatic void updateChildPruning(const DWARFDie &Die, CompileUnit &CU,\n                               CompileUnit::DIEInfo &ChildInfo) {\n  CompileUnit::DIEInfo &Info = CU.getInfo(Die);\n  Info.Prune &= ChildInfo.Prune;\n}\n\n/// Recursive helper to build the global DeclContext information and\n/// gather the child->parent relationships in the original compile unit.\n///\n/// This function uses the same work list approach as lookForDIEsToKeep.\n///\n/// \\return true when this DIE and all of its children are only\n/// forward declarations to types defined in external clang modules\n/// (i.e., forward declarations that are children of a DW_TAG_module).\nstatic bool analyzeContextInfo(\n    const DWARFDie &DIE, unsigned ParentIdx, CompileUnit &CU,\n    DeclContext *CurrentDeclContext, DeclContextTree &Contexts,\n    uint64_t ModulesEndOffset, swiftInterfacesMap *ParseableSwiftInterfaces,\n    std::function<void(const Twine &, const DWARFDie &)> ReportWarning,\n    bool InImportedModule = false) {\n  // LIFO work list.\n  std::vector<ContextWorklistItem> Worklist;\n  Worklist.emplace_back(DIE, CurrentDeclContext, ParentIdx, InImportedModule);\n\n  while (!Worklist.empty()) {\n    ContextWorklistItem Current = Worklist.back();\n    Worklist.pop_back();\n\n    switch (Current.Type) {\n    case ContextWorklistItemType::UpdatePruning:\n      updatePruning(Current.Die, CU, ModulesEndOffset);\n      continue;\n    case ContextWorklistItemType::UpdateChildPruning:\n      updateChildPruning(Current.Die, CU, *Current.OtherInfo);\n      continue;\n    case ContextWorklistItemType::AnalyzeContextInfo:\n      break;\n    }\n\n    unsigned Idx = CU.getOrigUnit().getDIEIndex(Current.Die);\n    CompileUnit::DIEInfo &Info = CU.getInfo(Idx);\n\n    // Clang imposes an ODR on modules(!) regardless of the language:\n    //  \"The module-id should consist of only a single identifier,\n    //   which provides the name of the module being defined. Each\n    //   module shall have a single definition.\"\n    //\n    // This does not extend to the types inside the modules:\n    //  \"[I]n C, this implies that if two structs are defined in\n    //   different submodules with the same name, those two types are\n    //   distinct types (but may be compatible types if their\n    //   definitions match).\"\n    //\n    // We treat non-C++ modules like namespaces for this reason.\n    if (Current.Die.getTag() == dwarf::DW_TAG_module &&\n        Current.ParentIdx == 0 &&\n        dwarf::toString(Current.Die.find(dwarf::DW_AT_name), \"\") !=\n            CU.getClangModuleName()) {\n      Current.InImportedModule = true;\n      analyzeImportedModule(Current.Die, CU, ParseableSwiftInterfaces,\n                            ReportWarning);\n    }\n\n    Info.ParentIdx = Current.ParentIdx;\n    bool InClangModule = CU.isClangModule() || Current.InImportedModule;\n    if (CU.hasODR() || InClangModule) {\n      if (Current.Context) {\n        auto PtrInvalidPair = Contexts.getChildDeclContext(\n            *Current.Context, Current.Die, CU, InClangModule);\n        Current.Context = PtrInvalidPair.getPointer();\n        Info.Ctxt =\n            PtrInvalidPair.getInt() ? nullptr : PtrInvalidPair.getPointer();\n        if (Info.Ctxt)\n          Info.Ctxt->setDefinedInClangModule(InClangModule);\n      } else\n        Info.Ctxt = Current.Context = nullptr;\n    }\n\n    Info.Prune = Current.InImportedModule;\n    // Add children in reverse order to the worklist to effectively process\n    // them in order.\n    Worklist.emplace_back(Current.Die, ContextWorklistItemType::UpdatePruning);\n    for (auto Child : reverse(Current.Die.children())) {\n      CompileUnit::DIEInfo &ChildInfo = CU.getInfo(Child);\n      Worklist.emplace_back(\n          Current.Die, ContextWorklistItemType::UpdateChildPruning, &ChildInfo);\n      Worklist.emplace_back(Child, Current.Context, Idx,\n                            Current.InImportedModule);\n    }\n  }\n\n  return CU.getInfo(DIE).Prune;\n}\n\nstatic bool dieNeedsChildrenToBeMeaningful(uint32_t Tag) {\n  switch (Tag) {\n  default:\n    return false;\n  case dwarf::DW_TAG_class_type:\n  case dwarf::DW_TAG_common_block:\n  case dwarf::DW_TAG_lexical_block:\n  case dwarf::DW_TAG_structure_type:\n  case dwarf::DW_TAG_subprogram:\n  case dwarf::DW_TAG_subroutine_type:\n  case dwarf::DW_TAG_union_type:\n    return true;\n  }\n  llvm_unreachable(\"Invalid Tag\");\n}\n\nvoid DWARFLinker::cleanupAuxiliarryData(LinkContext &Context) {\n  Context.clear();\n\n  for (auto I = DIEBlocks.begin(), E = DIEBlocks.end(); I != E; ++I)\n    (*I)->~DIEBlock();\n  for (auto I = DIELocs.begin(), E = DIELocs.end(); I != E; ++I)\n    (*I)->~DIELoc();\n\n  DIEBlocks.clear();\n  DIELocs.clear();\n  DIEAlloc.Reset();\n}\n\n/// Check if a variable describing DIE should be kept.\n/// \\returns updated TraversalFlags.\nunsigned DWARFLinker::shouldKeepVariableDIE(AddressesMap &RelocMgr,\n                                            const DWARFDie &DIE,\n                                            CompileUnit::DIEInfo &MyInfo,\n                                            unsigned Flags) {\n  const auto *Abbrev = DIE.getAbbreviationDeclarationPtr();\n\n  // Global variables with constant value can always be kept.\n  if (!(Flags & TF_InFunctionScope) &&\n      Abbrev->findAttributeIndex(dwarf::DW_AT_const_value)) {\n    MyInfo.InDebugMap = true;\n    return Flags | TF_Keep;\n  }\n\n  // See if there is a relocation to a valid debug map entry inside\n  // this variable's location. The order is important here. We want to\n  // always check if the variable has a valid relocation, so that the\n  // DIEInfo is filled. However, we don't want a static variable in a\n  // function to force us to keep the enclosing function.\n  if (!RelocMgr.hasLiveMemoryLocation(DIE, MyInfo) ||\n      (Flags & TF_InFunctionScope))\n    return Flags;\n\n  if (Options.Verbose) {\n    outs() << \"Keeping variable DIE:\";\n    DIDumpOptions DumpOpts;\n    DumpOpts.ChildRecurseDepth = 0;\n    DumpOpts.Verbose = Options.Verbose;\n    DIE.dump(outs(), 8 /* Indent */, DumpOpts);\n  }\n\n  return Flags | TF_Keep;\n}\n\n/// Check if a function describing DIE should be kept.\n/// \\returns updated TraversalFlags.\nunsigned DWARFLinker::shouldKeepSubprogramDIE(\n    AddressesMap &RelocMgr, RangesTy &Ranges, const DWARFDie &DIE,\n    const DWARFFile &File, CompileUnit &Unit, CompileUnit::DIEInfo &MyInfo,\n    unsigned Flags) {\n  Flags |= TF_InFunctionScope;\n\n  auto LowPc = dwarf::toAddress(DIE.find(dwarf::DW_AT_low_pc));\n  if (!LowPc)\n    return Flags;\n\n  assert(LowPc.hasValue() && \"low_pc attribute is not an address.\");\n  if (!RelocMgr.hasLiveAddressRange(DIE, MyInfo))\n    return Flags;\n\n  if (Options.Verbose) {\n    outs() << \"Keeping subprogram DIE:\";\n    DIDumpOptions DumpOpts;\n    DumpOpts.ChildRecurseDepth = 0;\n    DumpOpts.Verbose = Options.Verbose;\n    DIE.dump(outs(), 8 /* Indent */, DumpOpts);\n  }\n\n  if (DIE.getTag() == dwarf::DW_TAG_label) {\n    if (Unit.hasLabelAt(*LowPc))\n      return Flags;\n\n    DWARFUnit &OrigUnit = Unit.getOrigUnit();\n    // FIXME: dsymutil-classic compat. dsymutil-classic doesn't consider labels\n    // that don't fall into the CU's aranges. This is wrong IMO. Debug info\n    // generation bugs aside, this is really wrong in the case of labels, where\n    // a label marking the end of a function will have a PC == CU's high_pc.\n    if (dwarf::toAddress(OrigUnit.getUnitDIE().find(dwarf::DW_AT_high_pc))\n            .getValueOr(UINT64_MAX) <= LowPc)\n      return Flags;\n    Unit.addLabelLowPc(*LowPc, MyInfo.AddrAdjust);\n    return Flags | TF_Keep;\n  }\n\n  Flags |= TF_Keep;\n\n  Optional<uint64_t> HighPc = DIE.getHighPC(*LowPc);\n  if (!HighPc) {\n    reportWarning(\"Function without high_pc. Range will be discarded.\\n\", File,\n                  &DIE);\n    return Flags;\n  }\n\n  // Replace the debug map range with a more accurate one.\n  Ranges[*LowPc] = ObjFileAddressRange(*HighPc, MyInfo.AddrAdjust);\n  Unit.addFunctionRange(*LowPc, *HighPc, MyInfo.AddrAdjust);\n  return Flags;\n}\n\n/// Check if a DIE should be kept.\n/// \\returns updated TraversalFlags.\nunsigned DWARFLinker::shouldKeepDIE(AddressesMap &RelocMgr, RangesTy &Ranges,\n                                    const DWARFDie &DIE, const DWARFFile &File,\n                                    CompileUnit &Unit,\n                                    CompileUnit::DIEInfo &MyInfo,\n                                    unsigned Flags) {\n  switch (DIE.getTag()) {\n  case dwarf::DW_TAG_constant:\n  case dwarf::DW_TAG_variable:\n    return shouldKeepVariableDIE(RelocMgr, DIE, MyInfo, Flags);\n  case dwarf::DW_TAG_subprogram:\n  case dwarf::DW_TAG_label:\n    return shouldKeepSubprogramDIE(RelocMgr, Ranges, DIE, File, Unit, MyInfo,\n                                   Flags);\n  case dwarf::DW_TAG_base_type:\n    // DWARF Expressions may reference basic types, but scanning them\n    // is expensive. Basic types are tiny, so just keep all of them.\n  case dwarf::DW_TAG_imported_module:\n  case dwarf::DW_TAG_imported_declaration:\n  case dwarf::DW_TAG_imported_unit:\n    // We always want to keep these.\n    return Flags | TF_Keep;\n  default:\n    break;\n  }\n\n  return Flags;\n}\n\n/// Helper that updates the completeness of the current DIE based on the\n/// completeness of one of its children. It depends on the incompleteness of\n/// the children already being computed.\nstatic void updateChildIncompleteness(const DWARFDie &Die, CompileUnit &CU,\n                                      CompileUnit::DIEInfo &ChildInfo) {\n  switch (Die.getTag()) {\n  case dwarf::DW_TAG_structure_type:\n  case dwarf::DW_TAG_class_type:\n    break;\n  default:\n    return;\n  }\n\n  CompileUnit::DIEInfo &MyInfo = CU.getInfo(Die);\n\n  if (ChildInfo.Incomplete || ChildInfo.Prune)\n    MyInfo.Incomplete = true;\n}\n\n/// Helper that updates the completeness of the current DIE based on the\n/// completeness of the DIEs it references. It depends on the incompleteness of\n/// the referenced DIE already being computed.\nstatic void updateRefIncompleteness(const DWARFDie &Die, CompileUnit &CU,\n                                    CompileUnit::DIEInfo &RefInfo) {\n  switch (Die.getTag()) {\n  case dwarf::DW_TAG_typedef:\n  case dwarf::DW_TAG_member:\n  case dwarf::DW_TAG_reference_type:\n  case dwarf::DW_TAG_ptr_to_member_type:\n  case dwarf::DW_TAG_pointer_type:\n    break;\n  default:\n    return;\n  }\n\n  CompileUnit::DIEInfo &MyInfo = CU.getInfo(Die);\n\n  if (MyInfo.Incomplete)\n    return;\n\n  if (RefInfo.Incomplete)\n    MyInfo.Incomplete = true;\n}\n\n/// Look at the children of the given DIE and decide whether they should be\n/// kept.\nvoid DWARFLinker::lookForChildDIEsToKeep(\n    const DWARFDie &Die, CompileUnit &CU, unsigned Flags,\n    SmallVectorImpl<WorklistItem> &Worklist) {\n  // The TF_ParentWalk flag tells us that we are currently walking up the\n  // parent chain of a required DIE, and we don't want to mark all the children\n  // of the parents as kept (consider for example a DW_TAG_namespace node in\n  // the parent chain). There are however a set of DIE types for which we want\n  // to ignore that directive and still walk their children.\n  if (dieNeedsChildrenToBeMeaningful(Die.getTag()))\n    Flags &= ~DWARFLinker::TF_ParentWalk;\n\n  // We're finished if this DIE has no children or we're walking the parent\n  // chain.\n  if (!Die.hasChildren() || (Flags & DWARFLinker::TF_ParentWalk))\n    return;\n\n  // Add children in reverse order to the worklist to effectively process them\n  // in order.\n  for (auto Child : reverse(Die.children())) {\n    // Add a worklist item before every child to calculate incompleteness right\n    // after the current child is processed.\n    CompileUnit::DIEInfo &ChildInfo = CU.getInfo(Child);\n    Worklist.emplace_back(Die, CU, WorklistItemType::UpdateChildIncompleteness,\n                          &ChildInfo);\n    Worklist.emplace_back(Child, CU, Flags);\n  }\n}\n\n/// Look at DIEs referenced by the given DIE and decide whether they should be\n/// kept. All DIEs referenced though attributes should be kept.\nvoid DWARFLinker::lookForRefDIEsToKeep(\n    const DWARFDie &Die, CompileUnit &CU, unsigned Flags,\n    const UnitListTy &Units, const DWARFFile &File,\n    SmallVectorImpl<WorklistItem> &Worklist) {\n  bool UseOdr = (Flags & DWARFLinker::TF_DependencyWalk)\n                    ? (Flags & DWARFLinker::TF_ODR)\n                    : CU.hasODR();\n  DWARFUnit &Unit = CU.getOrigUnit();\n  DWARFDataExtractor Data = Unit.getDebugInfoExtractor();\n  const auto *Abbrev = Die.getAbbreviationDeclarationPtr();\n  uint64_t Offset = Die.getOffset() + getULEB128Size(Abbrev->getCode());\n\n  SmallVector<std::pair<DWARFDie, CompileUnit &>, 4> ReferencedDIEs;\n  for (const auto &AttrSpec : Abbrev->attributes()) {\n    DWARFFormValue Val(AttrSpec.Form);\n    if (!Val.isFormClass(DWARFFormValue::FC_Reference) ||\n        AttrSpec.Attr == dwarf::DW_AT_sibling) {\n      DWARFFormValue::skipValue(AttrSpec.Form, Data, &Offset,\n                                Unit.getFormParams());\n      continue;\n    }\n\n    Val.extractValue(Data, &Offset, Unit.getFormParams(), &Unit);\n    CompileUnit *ReferencedCU;\n    if (auto RefDie =\n            resolveDIEReference(File, Units, Val, Die, ReferencedCU)) {\n      CompileUnit::DIEInfo &Info = ReferencedCU->getInfo(RefDie);\n      bool IsModuleRef = Info.Ctxt && Info.Ctxt->getCanonicalDIEOffset() &&\n                         Info.Ctxt->isDefinedInClangModule();\n      // If the referenced DIE has a DeclContext that has already been\n      // emitted, then do not keep the one in this CU. We'll link to\n      // the canonical DIE in cloneDieReferenceAttribute.\n      //\n      // FIXME: compatibility with dsymutil-classic. UseODR shouldn't\n      // be necessary and could be advantageously replaced by\n      // ReferencedCU->hasODR() && CU.hasODR().\n      //\n      // FIXME: compatibility with dsymutil-classic. There is no\n      // reason not to unique ref_addr references.\n      if (AttrSpec.Form != dwarf::DW_FORM_ref_addr && (UseOdr || IsModuleRef) &&\n          Info.Ctxt &&\n          Info.Ctxt != ReferencedCU->getInfo(Info.ParentIdx).Ctxt &&\n          Info.Ctxt->getCanonicalDIEOffset() && isODRAttribute(AttrSpec.Attr))\n        continue;\n\n      // Keep a module forward declaration if there is no definition.\n      if (!(isODRAttribute(AttrSpec.Attr) && Info.Ctxt &&\n            Info.Ctxt->getCanonicalDIEOffset()))\n        Info.Prune = false;\n      ReferencedDIEs.emplace_back(RefDie, *ReferencedCU);\n    }\n  }\n\n  unsigned ODRFlag = UseOdr ? DWARFLinker::TF_ODR : 0;\n\n  // Add referenced DIEs in reverse order to the worklist to effectively\n  // process them in order.\n  for (auto &P : reverse(ReferencedDIEs)) {\n    // Add a worklist item before every child to calculate incompleteness right\n    // after the current child is processed.\n    CompileUnit::DIEInfo &Info = P.second.getInfo(P.first);\n    Worklist.emplace_back(Die, CU, WorklistItemType::UpdateRefIncompleteness,\n                          &Info);\n    Worklist.emplace_back(P.first, P.second,\n                          DWARFLinker::TF_Keep |\n                              DWARFLinker::TF_DependencyWalk | ODRFlag);\n  }\n}\n\n/// Look at the parent of the given DIE and decide whether they should be kept.\nvoid DWARFLinker::lookForParentDIEsToKeep(\n    unsigned AncestorIdx, CompileUnit &CU, unsigned Flags,\n    SmallVectorImpl<WorklistItem> &Worklist) {\n  // Stop if we encounter an ancestor that's already marked as kept.\n  if (CU.getInfo(AncestorIdx).Keep)\n    return;\n\n  DWARFUnit &Unit = CU.getOrigUnit();\n  DWARFDie ParentDIE = Unit.getDIEAtIndex(AncestorIdx);\n  Worklist.emplace_back(CU.getInfo(AncestorIdx).ParentIdx, CU, Flags);\n  Worklist.emplace_back(ParentDIE, CU, Flags);\n}\n\n/// Recursively walk the \\p DIE tree and look for DIEs to keep. Store that\n/// information in \\p CU's DIEInfo.\n///\n/// This function is the entry point of the DIE selection algorithm. It is\n/// expected to walk the DIE tree in file order and (though the mediation of\n/// its helper) call hasValidRelocation() on each DIE that might be a 'root\n/// DIE' (See DwarfLinker class comment).\n///\n/// While walking the dependencies of root DIEs, this function is also called,\n/// but during these dependency walks the file order is not respected. The\n/// TF_DependencyWalk flag tells us which kind of traversal we are currently\n/// doing.\n///\n/// The recursive algorithm is implemented iteratively as a work list because\n/// very deep recursion could exhaust the stack for large projects. The work\n/// list acts as a scheduler for different types of work that need to be\n/// performed.\n///\n/// The recursive nature of the algorithm is simulated by running the \"main\"\n/// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs\n/// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or\n/// fixing up a computed property (UpdateChildIncompleteness,\n/// UpdateRefIncompleteness).\n///\n/// The return value indicates whether the DIE is incomplete.\nvoid DWARFLinker::lookForDIEsToKeep(AddressesMap &AddressesMap,\n                                    RangesTy &Ranges, const UnitListTy &Units,\n                                    const DWARFDie &Die, const DWARFFile &File,\n                                    CompileUnit &Cu, unsigned Flags) {\n  // LIFO work list.\n  SmallVector<WorklistItem, 4> Worklist;\n  Worklist.emplace_back(Die, Cu, Flags);\n\n  while (!Worklist.empty()) {\n    WorklistItem Current = Worklist.pop_back_val();\n\n    // Look at the worklist type to decide what kind of work to perform.\n    switch (Current.Type) {\n    case WorklistItemType::UpdateChildIncompleteness:\n      updateChildIncompleteness(Current.Die, Current.CU, *Current.OtherInfo);\n      continue;\n    case WorklistItemType::UpdateRefIncompleteness:\n      updateRefIncompleteness(Current.Die, Current.CU, *Current.OtherInfo);\n      continue;\n    case WorklistItemType::LookForChildDIEsToKeep:\n      lookForChildDIEsToKeep(Current.Die, Current.CU, Current.Flags, Worklist);\n      continue;\n    case WorklistItemType::LookForRefDIEsToKeep:\n      lookForRefDIEsToKeep(Current.Die, Current.CU, Current.Flags, Units, File,\n                           Worklist);\n      continue;\n    case WorklistItemType::LookForParentDIEsToKeep:\n      lookForParentDIEsToKeep(Current.AncestorIdx, Current.CU, Current.Flags,\n                              Worklist);\n      continue;\n    case WorklistItemType::LookForDIEsToKeep:\n      break;\n    }\n\n    unsigned Idx = Current.CU.getOrigUnit().getDIEIndex(Current.Die);\n    CompileUnit::DIEInfo &MyInfo = Current.CU.getInfo(Idx);\n\n    if (MyInfo.Prune)\n      continue;\n\n    // If the Keep flag is set, we are marking a required DIE's dependencies.\n    // If our target is already marked as kept, we're all set.\n    bool AlreadyKept = MyInfo.Keep;\n    if ((Current.Flags & TF_DependencyWalk) && AlreadyKept)\n      continue;\n\n    // We must not call shouldKeepDIE while called from keepDIEAndDependencies,\n    // because it would screw up the relocation finding logic.\n    if (!(Current.Flags & TF_DependencyWalk))\n      Current.Flags = shouldKeepDIE(AddressesMap, Ranges, Current.Die, File,\n                                    Current.CU, MyInfo, Current.Flags);\n\n    // Finish by looking for child DIEs. Because of the LIFO worklist we need\n    // to schedule that work before any subsequent items are added to the\n    // worklist.\n    Worklist.emplace_back(Current.Die, Current.CU, Current.Flags,\n                          WorklistItemType::LookForChildDIEsToKeep);\n\n    if (AlreadyKept || !(Current.Flags & TF_Keep))\n      continue;\n\n    // If it is a newly kept DIE mark it as well as all its dependencies as\n    // kept.\n    MyInfo.Keep = true;\n\n    // We're looking for incomplete types.\n    MyInfo.Incomplete =\n        Current.Die.getTag() != dwarf::DW_TAG_subprogram &&\n        Current.Die.getTag() != dwarf::DW_TAG_member &&\n        dwarf::toUnsigned(Current.Die.find(dwarf::DW_AT_declaration), 0);\n\n    // After looking at the parent chain, look for referenced DIEs. Because of\n    // the LIFO worklist we need to schedule that work before any subsequent\n    // items are added to the worklist.\n    Worklist.emplace_back(Current.Die, Current.CU, Current.Flags,\n                          WorklistItemType::LookForRefDIEsToKeep);\n\n    bool UseOdr = (Current.Flags & TF_DependencyWalk) ? (Current.Flags & TF_ODR)\n                                                      : Current.CU.hasODR();\n    unsigned ODRFlag = UseOdr ? TF_ODR : 0;\n    unsigned ParFlags = TF_ParentWalk | TF_Keep | TF_DependencyWalk | ODRFlag;\n\n    // Now schedule the parent walk.\n    Worklist.emplace_back(MyInfo.ParentIdx, Current.CU, ParFlags);\n  }\n}\n\n/// Assign an abbreviation number to \\p Abbrev.\n///\n/// Our DIEs get freed after every DebugMapObject has been processed,\n/// thus the FoldingSet we use to unique DIEAbbrevs cannot refer to\n/// the instances hold by the DIEs. When we encounter an abbreviation\n/// that we don't know, we create a permanent copy of it.\nvoid DWARFLinker::assignAbbrev(DIEAbbrev &Abbrev) {\n  // Check the set for priors.\n  FoldingSetNodeID ID;\n  Abbrev.Profile(ID);\n  void *InsertToken;\n  DIEAbbrev *InSet = AbbreviationsSet.FindNodeOrInsertPos(ID, InsertToken);\n\n  // If it's newly added.\n  if (InSet) {\n    // Assign existing abbreviation number.\n    Abbrev.setNumber(InSet->getNumber());\n  } else {\n    // Add to abbreviation list.\n    Abbreviations.push_back(\n        std::make_unique<DIEAbbrev>(Abbrev.getTag(), Abbrev.hasChildren()));\n    for (const auto &Attr : Abbrev.getData())\n      Abbreviations.back()->AddAttribute(Attr.getAttribute(), Attr.getForm());\n    AbbreviationsSet.InsertNode(Abbreviations.back().get(), InsertToken);\n    // Assign the unique abbreviation number.\n    Abbrev.setNumber(Abbreviations.size());\n    Abbreviations.back()->setNumber(Abbreviations.size());\n  }\n}\n\nunsigned DWARFLinker::DIECloner::cloneStringAttribute(\n    DIE &Die, AttributeSpec AttrSpec, const DWARFFormValue &Val,\n    const DWARFUnit &U, OffsetsStringPool &StringPool, AttributesInfo &Info) {\n  Optional<const char *> String = Val.getAsCString();\n  if (!String)\n    return 0;\n\n  // Switch everything to out of line strings.\n  auto StringEntry = StringPool.getEntry(*String);\n\n  // Update attributes info.\n  if (AttrSpec.Attr == dwarf::DW_AT_name)\n    Info.Name = StringEntry;\n  else if (AttrSpec.Attr == dwarf::DW_AT_MIPS_linkage_name ||\n           AttrSpec.Attr == dwarf::DW_AT_linkage_name)\n    Info.MangledName = StringEntry;\n\n  Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr), dwarf::DW_FORM_strp,\n               DIEInteger(StringEntry.getOffset()));\n\n  return 4;\n}\n\nunsigned DWARFLinker::DIECloner::cloneDieReferenceAttribute(\n    DIE &Die, const DWARFDie &InputDIE, AttributeSpec AttrSpec,\n    unsigned AttrSize, const DWARFFormValue &Val, const DWARFFile &File,\n    CompileUnit &Unit) {\n  const DWARFUnit &U = Unit.getOrigUnit();\n  uint64_t Ref = *Val.getAsReference();\n\n  DIE *NewRefDie = nullptr;\n  CompileUnit *RefUnit = nullptr;\n  DeclContext *Ctxt = nullptr;\n\n  DWARFDie RefDie =\n      Linker.resolveDIEReference(File, CompileUnits, Val, InputDIE, RefUnit);\n\n  // If the referenced DIE is not found,  drop the attribute.\n  if (!RefDie || AttrSpec.Attr == dwarf::DW_AT_sibling)\n    return 0;\n\n  CompileUnit::DIEInfo &RefInfo = RefUnit->getInfo(RefDie);\n\n  // If we already have emitted an equivalent DeclContext, just point\n  // at it.\n  if (isODRAttribute(AttrSpec.Attr)) {\n    Ctxt = RefInfo.Ctxt;\n    if (Ctxt && Ctxt->getCanonicalDIEOffset()) {\n      DIEInteger Attr(Ctxt->getCanonicalDIEOffset());\n      Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n                   dwarf::DW_FORM_ref_addr, Attr);\n      return U.getRefAddrByteSize();\n    }\n  }\n\n  if (!RefInfo.Clone) {\n    assert(Ref > InputDIE.getOffset());\n    // We haven't cloned this DIE yet. Just create an empty one and\n    // store it. It'll get really cloned when we process it.\n    RefInfo.Clone = DIE::get(DIEAlloc, dwarf::Tag(RefDie.getTag()));\n  }\n  NewRefDie = RefInfo.Clone;\n\n  if (AttrSpec.Form == dwarf::DW_FORM_ref_addr ||\n      (Unit.hasODR() && isODRAttribute(AttrSpec.Attr))) {\n    // We cannot currently rely on a DIEEntry to emit ref_addr\n    // references, because the implementation calls back to DwarfDebug\n    // to find the unit offset. (We don't have a DwarfDebug)\n    // FIXME: we should be able to design DIEEntry reliance on\n    // DwarfDebug away.\n    uint64_t Attr;\n    if (Ref < InputDIE.getOffset()) {\n      // We must have already cloned that DIE.\n      uint32_t NewRefOffset =\n          RefUnit->getStartOffset() + NewRefDie->getOffset();\n      Attr = NewRefOffset;\n      Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n                   dwarf::DW_FORM_ref_addr, DIEInteger(Attr));\n    } else {\n      // A forward reference. Note and fixup later.\n      Attr = 0xBADDEF;\n      Unit.noteForwardReference(\n          NewRefDie, RefUnit, Ctxt,\n          Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n                       dwarf::DW_FORM_ref_addr, DIEInteger(Attr)));\n    }\n    return U.getRefAddrByteSize();\n  }\n\n  Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n               dwarf::Form(AttrSpec.Form), DIEEntry(*NewRefDie));\n\n  return AttrSize;\n}\n\nvoid DWARFLinker::DIECloner::cloneExpression(\n    DataExtractor &Data, DWARFExpression Expression, const DWARFFile &File,\n    CompileUnit &Unit, SmallVectorImpl<uint8_t> &OutputBuffer) {\n  using Encoding = DWARFExpression::Operation::Encoding;\n\n  uint64_t OpOffset = 0;\n  for (auto &Op : Expression) {\n    auto Description = Op.getDescription();\n    // DW_OP_const_type is variable-length and has 3\n    // operands. DWARFExpression thus far only supports 2.\n    auto Op0 = Description.Op[0];\n    auto Op1 = Description.Op[1];\n    if ((Op0 == Encoding::BaseTypeRef && Op1 != Encoding::SizeNA) ||\n        (Op1 == Encoding::BaseTypeRef && Op0 != Encoding::Size1))\n      Linker.reportWarning(\"Unsupported DW_OP encoding.\", File);\n\n    if ((Op0 == Encoding::BaseTypeRef && Op1 == Encoding::SizeNA) ||\n        (Op1 == Encoding::BaseTypeRef && Op0 == Encoding::Size1)) {\n      // This code assumes that the other non-typeref operand fits into 1 byte.\n      assert(OpOffset < Op.getEndOffset());\n      uint32_t ULEBsize = Op.getEndOffset() - OpOffset - 1;\n      assert(ULEBsize <= 16);\n\n      // Copy over the operation.\n      OutputBuffer.push_back(Op.getCode());\n      uint64_t RefOffset;\n      if (Op1 == Encoding::SizeNA) {\n        RefOffset = Op.getRawOperand(0);\n      } else {\n        OutputBuffer.push_back(Op.getRawOperand(0));\n        RefOffset = Op.getRawOperand(1);\n      }\n      uint32_t Offset = 0;\n      // Look up the base type. For DW_OP_convert, the operand may be 0 to\n      // instead indicate the generic type. The same holds for\n      // DW_OP_reinterpret, which is currently not supported.\n      if (RefOffset > 0 || Op.getCode() != dwarf::DW_OP_convert) {\n        auto RefDie = Unit.getOrigUnit().getDIEForOffset(RefOffset);\n        CompileUnit::DIEInfo &Info = Unit.getInfo(RefDie);\n        if (DIE *Clone = Info.Clone)\n          Offset = Clone->getOffset();\n        else\n          Linker.reportWarning(\n              \"base type ref doesn't point to DW_TAG_base_type.\", File);\n      }\n      uint8_t ULEB[16];\n      unsigned RealSize = encodeULEB128(Offset, ULEB, ULEBsize);\n      if (RealSize > ULEBsize) {\n        // Emit the generic type as a fallback.\n        RealSize = encodeULEB128(0, ULEB, ULEBsize);\n        Linker.reportWarning(\"base type ref doesn't fit.\", File);\n      }\n      assert(RealSize == ULEBsize && \"padding failed\");\n      ArrayRef<uint8_t> ULEBbytes(ULEB, ULEBsize);\n      OutputBuffer.append(ULEBbytes.begin(), ULEBbytes.end());\n    } else {\n      // Copy over everything else unmodified.\n      StringRef Bytes = Data.getData().slice(OpOffset, Op.getEndOffset());\n      OutputBuffer.append(Bytes.begin(), Bytes.end());\n    }\n    OpOffset = Op.getEndOffset();\n  }\n}\n\nunsigned DWARFLinker::DIECloner::cloneBlockAttribute(\n    DIE &Die, const DWARFFile &File, CompileUnit &Unit, AttributeSpec AttrSpec,\n    const DWARFFormValue &Val, unsigned AttrSize, bool IsLittleEndian) {\n  DIEValueList *Attr;\n  DIEValue Value;\n  DIELoc *Loc = nullptr;\n  DIEBlock *Block = nullptr;\n  if (AttrSpec.Form == dwarf::DW_FORM_exprloc) {\n    Loc = new (DIEAlloc) DIELoc;\n    Linker.DIELocs.push_back(Loc);\n  } else {\n    Block = new (DIEAlloc) DIEBlock;\n    Linker.DIEBlocks.push_back(Block);\n  }\n  Attr = Loc ? static_cast<DIEValueList *>(Loc)\n             : static_cast<DIEValueList *>(Block);\n\n  if (Loc)\n    Value = DIEValue(dwarf::Attribute(AttrSpec.Attr),\n                     dwarf::Form(AttrSpec.Form), Loc);\n  else\n    Value = DIEValue(dwarf::Attribute(AttrSpec.Attr),\n                     dwarf::Form(AttrSpec.Form), Block);\n\n  // If the block is a DWARF Expression, clone it into the temporary\n  // buffer using cloneExpression(), otherwise copy the data directly.\n  SmallVector<uint8_t, 32> Buffer;\n  ArrayRef<uint8_t> Bytes = *Val.getAsBlock();\n  if (DWARFAttribute::mayHaveLocationDescription(AttrSpec.Attr) &&\n      (Val.isFormClass(DWARFFormValue::FC_Block) ||\n       Val.isFormClass(DWARFFormValue::FC_Exprloc))) {\n    DWARFUnit &OrigUnit = Unit.getOrigUnit();\n    DataExtractor Data(StringRef((const char *)Bytes.data(), Bytes.size()),\n                       IsLittleEndian, OrigUnit.getAddressByteSize());\n    DWARFExpression Expr(Data, OrigUnit.getAddressByteSize(),\n                         OrigUnit.getFormParams().Format);\n    cloneExpression(Data, Expr, File, Unit, Buffer);\n    Bytes = Buffer;\n  }\n  for (auto Byte : Bytes)\n    Attr->addValue(DIEAlloc, static_cast<dwarf::Attribute>(0),\n                   dwarf::DW_FORM_data1, DIEInteger(Byte));\n\n  // FIXME: If DIEBlock and DIELoc just reuses the Size field of\n  // the DIE class, this \"if\" could be replaced by\n  // Attr->setSize(Bytes.size()).\n  if (Loc)\n    Loc->setSize(Bytes.size());\n  else\n    Block->setSize(Bytes.size());\n\n  Die.addValue(DIEAlloc, Value);\n  return AttrSize;\n}\n\nunsigned DWARFLinker::DIECloner::cloneAddressAttribute(\n    DIE &Die, AttributeSpec AttrSpec, const DWARFFormValue &Val,\n    const CompileUnit &Unit, AttributesInfo &Info) {\n  if (LLVM_UNLIKELY(Linker.Options.Update)) {\n    if (AttrSpec.Attr == dwarf::DW_AT_low_pc)\n      Info.HasLowPc = true;\n    Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n                 dwarf::Form(AttrSpec.Form), DIEInteger(Val.getRawUValue()));\n    return Unit.getOrigUnit().getAddressByteSize();\n  }\n\n  dwarf::Form Form = AttrSpec.Form;\n  uint64_t Addr = 0;\n  if (Form == dwarf::DW_FORM_addrx) {\n    if (Optional<uint64_t> AddrOffsetSectionBase =\n            Unit.getOrigUnit().getAddrOffsetSectionBase()) {\n      uint64_t StartOffset = *AddrOffsetSectionBase + Val.getRawUValue();\n      uint64_t EndOffset =\n          StartOffset + Unit.getOrigUnit().getAddressByteSize();\n      if (llvm::Expected<uint64_t> RelocAddr =\n              ObjFile.Addresses->relocateIndexedAddr(StartOffset, EndOffset))\n        Addr = *RelocAddr;\n      else\n        Linker.reportWarning(toString(RelocAddr.takeError()), ObjFile);\n    } else\n      Linker.reportWarning(\"no base offset for address table\", ObjFile);\n\n    // If this is an indexed address emit the debug_info address.\n    Form = dwarf::DW_FORM_addr;\n  } else\n    Addr = *Val.getAsAddress();\n\n  if (AttrSpec.Attr == dwarf::DW_AT_low_pc) {\n    if (Die.getTag() == dwarf::DW_TAG_inlined_subroutine ||\n        Die.getTag() == dwarf::DW_TAG_lexical_block)\n      // The low_pc of a block or inline subroutine might get\n      // relocated because it happens to match the low_pc of the\n      // enclosing subprogram. To prevent issues with that, always use\n      // the low_pc from the input DIE if relocations have been applied.\n      Addr = (Info.OrigLowPc != std::numeric_limits<uint64_t>::max()\n                  ? Info.OrigLowPc\n                  : Addr) +\n             Info.PCOffset;\n    else if (Die.getTag() == dwarf::DW_TAG_compile_unit) {\n      Addr = Unit.getLowPc();\n      if (Addr == std::numeric_limits<uint64_t>::max())\n        return 0;\n    }\n    Info.HasLowPc = true;\n  } else if (AttrSpec.Attr == dwarf::DW_AT_high_pc) {\n    if (Die.getTag() == dwarf::DW_TAG_compile_unit) {\n      if (uint64_t HighPc = Unit.getHighPc())\n        Addr = HighPc;\n      else\n        return 0;\n    } else\n      // If we have a high_pc recorded for the input DIE, use\n      // it. Otherwise (when no relocations where applied) just use the\n      // one we just decoded.\n      Addr = (Info.OrigHighPc ? Info.OrigHighPc : Addr) + Info.PCOffset;\n  } else if (AttrSpec.Attr == dwarf::DW_AT_call_return_pc) {\n    // Relocate a return PC address within a call site entry.\n    if (Die.getTag() == dwarf::DW_TAG_call_site)\n      Addr = (Info.OrigCallReturnPc ? Info.OrigCallReturnPc : Addr) +\n             Info.PCOffset;\n  } else if (AttrSpec.Attr == dwarf::DW_AT_call_pc) {\n    // Relocate the address of a branch instruction within a call site entry.\n    if (Die.getTag() == dwarf::DW_TAG_call_site)\n      Addr = (Info.OrigCallPc ? Info.OrigCallPc : Addr) + Info.PCOffset;\n  }\n\n  Die.addValue(DIEAlloc, static_cast<dwarf::Attribute>(AttrSpec.Attr),\n               static_cast<dwarf::Form>(Form), DIEInteger(Addr));\n  return Unit.getOrigUnit().getAddressByteSize();\n}\n\nunsigned DWARFLinker::DIECloner::cloneScalarAttribute(\n    DIE &Die, const DWARFDie &InputDIE, const DWARFFile &File,\n    CompileUnit &Unit, AttributeSpec AttrSpec, const DWARFFormValue &Val,\n    unsigned AttrSize, AttributesInfo &Info) {\n  uint64_t Value;\n\n  if (LLVM_UNLIKELY(Linker.Options.Update)) {\n    if (auto OptionalValue = Val.getAsUnsignedConstant())\n      Value = *OptionalValue;\n    else if (auto OptionalValue = Val.getAsSignedConstant())\n      Value = *OptionalValue;\n    else if (auto OptionalValue = Val.getAsSectionOffset())\n      Value = *OptionalValue;\n    else {\n      Linker.reportWarning(\n          \"Unsupported scalar attribute form. Dropping attribute.\", File,\n          &InputDIE);\n      return 0;\n    }\n    if (AttrSpec.Attr == dwarf::DW_AT_declaration && Value)\n      Info.IsDeclaration = true;\n    Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n                 dwarf::Form(AttrSpec.Form), DIEInteger(Value));\n    return AttrSize;\n  }\n\n  if (AttrSpec.Attr == dwarf::DW_AT_high_pc &&\n      Die.getTag() == dwarf::DW_TAG_compile_unit) {\n    if (Unit.getLowPc() == -1ULL)\n      return 0;\n    // Dwarf >= 4 high_pc is an size, not an address.\n    Value = Unit.getHighPc() - Unit.getLowPc();\n  } else if (AttrSpec.Form == dwarf::DW_FORM_sec_offset)\n    Value = *Val.getAsSectionOffset();\n  else if (AttrSpec.Form == dwarf::DW_FORM_sdata)\n    Value = *Val.getAsSignedConstant();\n  else if (auto OptionalValue = Val.getAsUnsignedConstant())\n    Value = *OptionalValue;\n  else {\n    Linker.reportWarning(\n        \"Unsupported scalar attribute form. Dropping attribute.\", File,\n        &InputDIE);\n    return 0;\n  }\n  PatchLocation Patch =\n      Die.addValue(DIEAlloc, dwarf::Attribute(AttrSpec.Attr),\n                   dwarf::Form(AttrSpec.Form), DIEInteger(Value));\n  if (AttrSpec.Attr == dwarf::DW_AT_ranges) {\n    Unit.noteRangeAttribute(Die, Patch);\n    Info.HasRanges = true;\n  }\n\n  // A more generic way to check for location attributes would be\n  // nice, but it's very unlikely that any other attribute needs a\n  // location list.\n  // FIXME: use DWARFAttribute::mayHaveLocationDescription().\n  else if (AttrSpec.Attr == dwarf::DW_AT_location ||\n           AttrSpec.Attr == dwarf::DW_AT_frame_base) {\n    Unit.noteLocationAttribute(Patch, Info.PCOffset);\n  } else if (AttrSpec.Attr == dwarf::DW_AT_declaration && Value)\n    Info.IsDeclaration = true;\n\n  return AttrSize;\n}\n\n/// Clone \\p InputDIE's attribute described by \\p AttrSpec with\n/// value \\p Val, and add it to \\p Die.\n/// \\returns the size of the cloned attribute.\nunsigned DWARFLinker::DIECloner::cloneAttribute(\n    DIE &Die, const DWARFDie &InputDIE, const DWARFFile &File,\n    CompileUnit &Unit, OffsetsStringPool &StringPool, const DWARFFormValue &Val,\n    const AttributeSpec AttrSpec, unsigned AttrSize, AttributesInfo &Info,\n    bool IsLittleEndian) {\n  const DWARFUnit &U = Unit.getOrigUnit();\n\n  switch (AttrSpec.Form) {\n  case dwarf::DW_FORM_strp:\n  case dwarf::DW_FORM_string:\n  case dwarf::DW_FORM_strx:\n  case dwarf::DW_FORM_strx1:\n  case dwarf::DW_FORM_strx2:\n  case dwarf::DW_FORM_strx3:\n  case dwarf::DW_FORM_strx4:\n    return cloneStringAttribute(Die, AttrSpec, Val, U, StringPool, Info);\n  case dwarf::DW_FORM_ref_addr:\n  case dwarf::DW_FORM_ref1:\n  case dwarf::DW_FORM_ref2:\n  case dwarf::DW_FORM_ref4:\n  case dwarf::DW_FORM_ref8:\n    return cloneDieReferenceAttribute(Die, InputDIE, AttrSpec, AttrSize, Val,\n                                      File, Unit);\n  case dwarf::DW_FORM_block:\n  case dwarf::DW_FORM_block1:\n  case dwarf::DW_FORM_block2:\n  case dwarf::DW_FORM_block4:\n  case dwarf::DW_FORM_exprloc:\n    return cloneBlockAttribute(Die, File, Unit, AttrSpec, Val, AttrSize,\n                               IsLittleEndian);\n  case dwarf::DW_FORM_addr:\n  case dwarf::DW_FORM_addrx:\n    return cloneAddressAttribute(Die, AttrSpec, Val, Unit, Info);\n  case dwarf::DW_FORM_data1:\n  case dwarf::DW_FORM_data2:\n  case dwarf::DW_FORM_data4:\n  case dwarf::DW_FORM_data8:\n  case dwarf::DW_FORM_udata:\n  case dwarf::DW_FORM_sdata:\n  case dwarf::DW_FORM_sec_offset:\n  case dwarf::DW_FORM_flag:\n  case dwarf::DW_FORM_flag_present:\n    return cloneScalarAttribute(Die, InputDIE, File, Unit, AttrSpec, Val,\n                                AttrSize, Info);\n  default:\n    Linker.reportWarning(\"Unsupported attribute form \" +\n                             dwarf::FormEncodingString(AttrSpec.Form) +\n                             \" in cloneAttribute. Dropping.\",\n                         File, &InputDIE);\n  }\n\n  return 0;\n}\n\nstatic bool isObjCSelector(StringRef Name) {\n  return Name.size() > 2 && (Name[0] == '-' || Name[0] == '+') &&\n         (Name[1] == '[');\n}\n\nvoid DWARFLinker::DIECloner::addObjCAccelerator(CompileUnit &Unit,\n                                                const DIE *Die,\n                                                DwarfStringPoolEntryRef Name,\n                                                OffsetsStringPool &StringPool,\n                                                bool SkipPubSection) {\n  assert(isObjCSelector(Name.getString()) && \"not an objc selector\");\n  // Objective C method or class function.\n  // \"- [Class(Category) selector :withArg ...]\"\n  StringRef ClassNameStart(Name.getString().drop_front(2));\n  size_t FirstSpace = ClassNameStart.find(' ');\n  if (FirstSpace == StringRef::npos)\n    return;\n\n  StringRef SelectorStart(ClassNameStart.data() + FirstSpace + 1);\n  if (!SelectorStart.size())\n    return;\n\n  StringRef Selector(SelectorStart.data(), SelectorStart.size() - 1);\n  Unit.addNameAccelerator(Die, StringPool.getEntry(Selector), SkipPubSection);\n\n  // Add an entry for the class name that points to this\n  // method/class function.\n  StringRef ClassName(ClassNameStart.data(), FirstSpace);\n  Unit.addObjCAccelerator(Die, StringPool.getEntry(ClassName), SkipPubSection);\n\n  if (ClassName[ClassName.size() - 1] == ')') {\n    size_t OpenParens = ClassName.find('(');\n    if (OpenParens != StringRef::npos) {\n      StringRef ClassNameNoCategory(ClassName.data(), OpenParens);\n      Unit.addObjCAccelerator(Die, StringPool.getEntry(ClassNameNoCategory),\n                              SkipPubSection);\n\n      std::string MethodNameNoCategory(Name.getString().data(), OpenParens + 2);\n      // FIXME: The missing space here may be a bug, but\n      //        dsymutil-classic also does it this way.\n      MethodNameNoCategory.append(std::string(SelectorStart));\n      Unit.addNameAccelerator(Die, StringPool.getEntry(MethodNameNoCategory),\n                              SkipPubSection);\n    }\n  }\n}\n\nstatic bool\nshouldSkipAttribute(DWARFAbbreviationDeclaration::AttributeSpec AttrSpec,\n                    uint16_t Tag, bool InDebugMap, bool SkipPC,\n                    bool InFunctionScope) {\n  switch (AttrSpec.Attr) {\n  default:\n    return false;\n  case dwarf::DW_AT_low_pc:\n  case dwarf::DW_AT_high_pc:\n  case dwarf::DW_AT_ranges:\n    return SkipPC;\n  case dwarf::DW_AT_str_offsets_base:\n    // FIXME: Use the string offset table with Dwarf 5.\n    return true;\n  case dwarf::DW_AT_location:\n  case dwarf::DW_AT_frame_base:\n    // FIXME: for some reason dsymutil-classic keeps the location attributes\n    // when they are of block type (i.e. not location lists). This is totally\n    // wrong for globals where we will keep a wrong address. It is mostly\n    // harmless for locals, but there is no point in keeping these anyway when\n    // the function wasn't linked.\n    return (SkipPC || (!InFunctionScope && Tag == dwarf::DW_TAG_variable &&\n                       !InDebugMap)) &&\n           !DWARFFormValue(AttrSpec.Form).isFormClass(DWARFFormValue::FC_Block);\n  }\n}\n\nDIE *DWARFLinker::DIECloner::cloneDIE(const DWARFDie &InputDIE,\n                                      const DWARFFile &File, CompileUnit &Unit,\n                                      OffsetsStringPool &StringPool,\n                                      int64_t PCOffset, uint32_t OutOffset,\n                                      unsigned Flags, bool IsLittleEndian,\n                                      DIE *Die) {\n  DWARFUnit &U = Unit.getOrigUnit();\n  unsigned Idx = U.getDIEIndex(InputDIE);\n  CompileUnit::DIEInfo &Info = Unit.getInfo(Idx);\n\n  // Should the DIE appear in the output?\n  if (!Unit.getInfo(Idx).Keep)\n    return nullptr;\n\n  uint64_t Offset = InputDIE.getOffset();\n  assert(!(Die && Info.Clone) && \"Can't supply a DIE and a cloned DIE\");\n  if (!Die) {\n    // The DIE might have been already created by a forward reference\n    // (see cloneDieReferenceAttribute()).\n    if (!Info.Clone)\n      Info.Clone = DIE::get(DIEAlloc, dwarf::Tag(InputDIE.getTag()));\n    Die = Info.Clone;\n  }\n\n  assert(Die->getTag() == InputDIE.getTag());\n  Die->setOffset(OutOffset);\n  if ((Unit.hasODR() || Unit.isClangModule()) && !Info.Incomplete &&\n      Die->getTag() != dwarf::DW_TAG_namespace && Info.Ctxt &&\n      Info.Ctxt != Unit.getInfo(Info.ParentIdx).Ctxt &&\n      !Info.Ctxt->getCanonicalDIEOffset()) {\n    // We are about to emit a DIE that is the root of its own valid\n    // DeclContext tree. Make the current offset the canonical offset\n    // for this context.\n    Info.Ctxt->setCanonicalDIEOffset(OutOffset + Unit.getStartOffset());\n  }\n\n  // Extract and clone every attribute.\n  DWARFDataExtractor Data = U.getDebugInfoExtractor();\n  // Point to the next DIE (generally there is always at least a NULL\n  // entry after the current one). If this is a lone\n  // DW_TAG_compile_unit without any children, point to the next unit.\n  uint64_t NextOffset = (Idx + 1 < U.getNumDIEs())\n                            ? U.getDIEAtIndex(Idx + 1).getOffset()\n                            : U.getNextUnitOffset();\n  AttributesInfo AttrInfo;\n\n  // We could copy the data only if we need to apply a relocation to it. After\n  // testing, it seems there is no performance downside to doing the copy\n  // unconditionally, and it makes the code simpler.\n  SmallString<40> DIECopy(Data.getData().substr(Offset, NextOffset - Offset));\n  Data =\n      DWARFDataExtractor(DIECopy, Data.isLittleEndian(), Data.getAddressSize());\n\n  // Modify the copy with relocated addresses.\n  if (ObjFile.Addresses->areRelocationsResolved() &&\n      ObjFile.Addresses->applyValidRelocs(DIECopy, Offset,\n                                          Data.isLittleEndian())) {\n    // If we applied relocations, we store the value of high_pc that was\n    // potentially stored in the input DIE. If high_pc is an address\n    // (Dwarf version == 2), then it might have been relocated to a\n    // totally unrelated value (because the end address in the object\n    // file might be start address of another function which got moved\n    // independently by the linker). The computation of the actual\n    // high_pc value is done in cloneAddressAttribute().\n    AttrInfo.OrigHighPc =\n        dwarf::toAddress(InputDIE.find(dwarf::DW_AT_high_pc), 0);\n    // Also store the low_pc. It might get relocated in an\n    // inline_subprogram that happens at the beginning of its\n    // inlining function.\n    AttrInfo.OrigLowPc = dwarf::toAddress(InputDIE.find(dwarf::DW_AT_low_pc),\n                                          std::numeric_limits<uint64_t>::max());\n    AttrInfo.OrigCallReturnPc =\n        dwarf::toAddress(InputDIE.find(dwarf::DW_AT_call_return_pc), 0);\n    AttrInfo.OrigCallPc =\n        dwarf::toAddress(InputDIE.find(dwarf::DW_AT_call_pc), 0);\n  }\n\n  // Reset the Offset to 0 as we will be working on the local copy of\n  // the data.\n  Offset = 0;\n\n  const auto *Abbrev = InputDIE.getAbbreviationDeclarationPtr();\n  Offset += getULEB128Size(Abbrev->getCode());\n\n  // We are entering a subprogram. Get and propagate the PCOffset.\n  if (Die->getTag() == dwarf::DW_TAG_subprogram)\n    PCOffset = Info.AddrAdjust;\n  AttrInfo.PCOffset = PCOffset;\n\n  if (Abbrev->getTag() == dwarf::DW_TAG_subprogram) {\n    Flags |= TF_InFunctionScope;\n    if (!Info.InDebugMap && LLVM_LIKELY(!Update))\n      Flags |= TF_SkipPC;\n  }\n\n  bool Copied = false;\n  for (const auto &AttrSpec : Abbrev->attributes()) {\n    if (LLVM_LIKELY(!Update) &&\n        shouldSkipAttribute(AttrSpec, Die->getTag(), Info.InDebugMap,\n                            Flags & TF_SkipPC, Flags & TF_InFunctionScope)) {\n      DWARFFormValue::skipValue(AttrSpec.Form, Data, &Offset,\n                                U.getFormParams());\n      // FIXME: dsymutil-classic keeps the old abbreviation around\n      // even if it's not used. We can remove this (and the copyAbbrev\n      // helper) as soon as bit-for-bit compatibility is not a goal anymore.\n      if (!Copied) {\n        copyAbbrev(*InputDIE.getAbbreviationDeclarationPtr(), Unit.hasODR());\n        Copied = true;\n      }\n      continue;\n    }\n\n    DWARFFormValue Val(AttrSpec.Form);\n    uint64_t AttrSize = Offset;\n    Val.extractValue(Data, &Offset, U.getFormParams(), &U);\n    AttrSize = Offset - AttrSize;\n\n    OutOffset += cloneAttribute(*Die, InputDIE, File, Unit, StringPool, Val,\n                                AttrSpec, AttrSize, AttrInfo, IsLittleEndian);\n  }\n\n  // Look for accelerator entries.\n  uint16_t Tag = InputDIE.getTag();\n  // FIXME: This is slightly wrong. An inline_subroutine without a\n  // low_pc, but with AT_ranges might be interesting to get into the\n  // accelerator tables too. For now stick with dsymutil's behavior.\n  if ((Info.InDebugMap || AttrInfo.HasLowPc || AttrInfo.HasRanges) &&\n      Tag != dwarf::DW_TAG_compile_unit &&\n      getDIENames(InputDIE, AttrInfo, StringPool,\n                  Tag != dwarf::DW_TAG_inlined_subroutine)) {\n    if (AttrInfo.MangledName && AttrInfo.MangledName != AttrInfo.Name)\n      Unit.addNameAccelerator(Die, AttrInfo.MangledName,\n                              Tag == dwarf::DW_TAG_inlined_subroutine);\n    if (AttrInfo.Name) {\n      if (AttrInfo.NameWithoutTemplate)\n        Unit.addNameAccelerator(Die, AttrInfo.NameWithoutTemplate,\n                                /* SkipPubSection */ true);\n      Unit.addNameAccelerator(Die, AttrInfo.Name,\n                              Tag == dwarf::DW_TAG_inlined_subroutine);\n    }\n    if (AttrInfo.Name && isObjCSelector(AttrInfo.Name.getString()))\n      addObjCAccelerator(Unit, Die, AttrInfo.Name, StringPool,\n                         /* SkipPubSection =*/true);\n\n  } else if (Tag == dwarf::DW_TAG_namespace) {\n    if (!AttrInfo.Name)\n      AttrInfo.Name = StringPool.getEntry(\"(anonymous namespace)\");\n    Unit.addNamespaceAccelerator(Die, AttrInfo.Name);\n  } else if (isTypeTag(Tag) && !AttrInfo.IsDeclaration &&\n             getDIENames(InputDIE, AttrInfo, StringPool) && AttrInfo.Name &&\n             AttrInfo.Name.getString()[0]) {\n    uint32_t Hash = hashFullyQualifiedName(InputDIE, Unit, File);\n    uint64_t RuntimeLang =\n        dwarf::toUnsigned(InputDIE.find(dwarf::DW_AT_APPLE_runtime_class))\n            .getValueOr(0);\n    bool ObjCClassIsImplementation =\n        (RuntimeLang == dwarf::DW_LANG_ObjC ||\n         RuntimeLang == dwarf::DW_LANG_ObjC_plus_plus) &&\n        dwarf::toUnsigned(InputDIE.find(dwarf::DW_AT_APPLE_objc_complete_type))\n            .getValueOr(0);\n    Unit.addTypeAccelerator(Die, AttrInfo.Name, ObjCClassIsImplementation,\n                            Hash);\n  }\n\n  // Determine whether there are any children that we want to keep.\n  bool HasChildren = false;\n  for (auto Child : InputDIE.children()) {\n    unsigned Idx = U.getDIEIndex(Child);\n    if (Unit.getInfo(Idx).Keep) {\n      HasChildren = true;\n      break;\n    }\n  }\n\n  DIEAbbrev NewAbbrev = Die->generateAbbrev();\n  if (HasChildren)\n    NewAbbrev.setChildrenFlag(dwarf::DW_CHILDREN_yes);\n  // Assign a permanent abbrev number\n  Linker.assignAbbrev(NewAbbrev);\n  Die->setAbbrevNumber(NewAbbrev.getNumber());\n\n  // Add the size of the abbreviation number to the output offset.\n  OutOffset += getULEB128Size(Die->getAbbrevNumber());\n\n  if (!HasChildren) {\n    // Update our size.\n    Die->setSize(OutOffset - Die->getOffset());\n    return Die;\n  }\n\n  // Recursively clone children.\n  for (auto Child : InputDIE.children()) {\n    if (DIE *Clone = cloneDIE(Child, File, Unit, StringPool, PCOffset,\n                              OutOffset, Flags, IsLittleEndian)) {\n      Die->addChild(Clone);\n      OutOffset = Clone->getOffset() + Clone->getSize();\n    }\n  }\n\n  // Account for the end of children marker.\n  OutOffset += sizeof(int8_t);\n  // Update our size.\n  Die->setSize(OutOffset - Die->getOffset());\n  return Die;\n}\n\n/// Patch the input object file relevant debug_ranges entries\n/// and emit them in the output file. Update the relevant attributes\n/// to point at the new entries.\nvoid DWARFLinker::patchRangesForUnit(const CompileUnit &Unit,\n                                     DWARFContext &OrigDwarf,\n                                     const DWARFFile &File) const {\n  DWARFDebugRangeList RangeList;\n  const auto &FunctionRanges = Unit.getFunctionRanges();\n  unsigned AddressSize = Unit.getOrigUnit().getAddressByteSize();\n  DWARFDataExtractor RangeExtractor(OrigDwarf.getDWARFObj(),\n                                    OrigDwarf.getDWARFObj().getRangesSection(),\n                                    OrigDwarf.isLittleEndian(), AddressSize);\n  auto InvalidRange = FunctionRanges.end(), CurrRange = InvalidRange;\n  DWARFUnit &OrigUnit = Unit.getOrigUnit();\n  auto OrigUnitDie = OrigUnit.getUnitDIE(false);\n  uint64_t OrigLowPc =\n      dwarf::toAddress(OrigUnitDie.find(dwarf::DW_AT_low_pc), -1ULL);\n  // Ranges addresses are based on the unit's low_pc. Compute the\n  // offset we need to apply to adapt to the new unit's low_pc.\n  int64_t UnitPcOffset = 0;\n  if (OrigLowPc != -1ULL)\n    UnitPcOffset = int64_t(OrigLowPc) - Unit.getLowPc();\n\n  for (const auto &RangeAttribute : Unit.getRangesAttributes()) {\n    uint64_t Offset = RangeAttribute.get();\n    RangeAttribute.set(TheDwarfEmitter->getRangesSectionSize());\n    if (Error E = RangeList.extract(RangeExtractor, &Offset)) {\n      llvm::consumeError(std::move(E));\n      reportWarning(\"invalid range list ignored.\", File);\n      RangeList.clear();\n    }\n    const auto &Entries = RangeList.getEntries();\n    if (!Entries.empty()) {\n      const DWARFDebugRangeList::RangeListEntry &First = Entries.front();\n\n      if (CurrRange == InvalidRange ||\n          First.StartAddress + OrigLowPc < CurrRange.start() ||\n          First.StartAddress + OrigLowPc >= CurrRange.stop()) {\n        CurrRange = FunctionRanges.find(First.StartAddress + OrigLowPc);\n        if (CurrRange == InvalidRange ||\n            CurrRange.start() > First.StartAddress + OrigLowPc) {\n          reportWarning(\"no mapping for range.\", File);\n          continue;\n        }\n      }\n    }\n\n    TheDwarfEmitter->emitRangesEntries(UnitPcOffset, OrigLowPc, CurrRange,\n                                       Entries, AddressSize);\n  }\n}\n\n/// Generate the debug_aranges entries for \\p Unit and if the\n/// unit has a DW_AT_ranges attribute, also emit the debug_ranges\n/// contribution for this attribute.\n/// FIXME: this could actually be done right in patchRangesForUnit,\n/// but for the sake of initial bit-for-bit compatibility with legacy\n/// dsymutil, we have to do it in a delayed pass.\nvoid DWARFLinker::generateUnitRanges(CompileUnit &Unit) const {\n  auto Attr = Unit.getUnitRangesAttribute();\n  if (Attr)\n    Attr->set(TheDwarfEmitter->getRangesSectionSize());\n  TheDwarfEmitter->emitUnitRangesEntries(Unit, static_cast<bool>(Attr));\n}\n\n/// Insert the new line info sequence \\p Seq into the current\n/// set of already linked line info \\p Rows.\nstatic void insertLineSequence(std::vector<DWARFDebugLine::Row> &Seq,\n                               std::vector<DWARFDebugLine::Row> &Rows) {\n  if (Seq.empty())\n    return;\n\n  if (!Rows.empty() && Rows.back().Address < Seq.front().Address) {\n    llvm::append_range(Rows, Seq);\n    Seq.clear();\n    return;\n  }\n\n  object::SectionedAddress Front = Seq.front().Address;\n  auto InsertPoint = partition_point(\n      Rows, [=](const DWARFDebugLine::Row &O) { return O.Address < Front; });\n\n  // FIXME: this only removes the unneeded end_sequence if the\n  // sequences have been inserted in order. Using a global sort like\n  // described in patchLineTableForUnit() and delaying the end_sequene\n  // elimination to emitLineTableForUnit() we can get rid of all of them.\n  if (InsertPoint != Rows.end() && InsertPoint->Address == Front &&\n      InsertPoint->EndSequence) {\n    *InsertPoint = Seq.front();\n    Rows.insert(InsertPoint + 1, Seq.begin() + 1, Seq.end());\n  } else {\n    Rows.insert(InsertPoint, Seq.begin(), Seq.end());\n  }\n\n  Seq.clear();\n}\n\nstatic void patchStmtList(DIE &Die, DIEInteger Offset) {\n  for (auto &V : Die.values())\n    if (V.getAttribute() == dwarf::DW_AT_stmt_list) {\n      V = DIEValue(V.getAttribute(), V.getForm(), Offset);\n      return;\n    }\n\n  llvm_unreachable(\"Didn't find DW_AT_stmt_list in cloned DIE!\");\n}\n\n/// Extract the line table for \\p Unit from \\p OrigDwarf, and\n/// recreate a relocated version of these for the address ranges that\n/// are present in the binary.\nvoid DWARFLinker::patchLineTableForUnit(CompileUnit &Unit,\n                                        DWARFContext &OrigDwarf,\n                                        const DWARFFile &File) {\n  DWARFDie CUDie = Unit.getOrigUnit().getUnitDIE();\n  auto StmtList = dwarf::toSectionOffset(CUDie.find(dwarf::DW_AT_stmt_list));\n  if (!StmtList)\n    return;\n\n  // Update the cloned DW_AT_stmt_list with the correct debug_line offset.\n  if (auto *OutputDIE = Unit.getOutputUnitDIE())\n    patchStmtList(*OutputDIE,\n                  DIEInteger(TheDwarfEmitter->getLineSectionSize()));\n\n  RangesTy &Ranges = File.Addresses->getValidAddressRanges();\n\n  // Parse the original line info for the unit.\n  DWARFDebugLine::LineTable LineTable;\n  uint64_t StmtOffset = *StmtList;\n  DWARFDataExtractor LineExtractor(\n      OrigDwarf.getDWARFObj(), OrigDwarf.getDWARFObj().getLineSection(),\n      OrigDwarf.isLittleEndian(), Unit.getOrigUnit().getAddressByteSize());\n  if (needToTranslateStrings())\n    return TheDwarfEmitter->translateLineTable(LineExtractor, StmtOffset);\n\n  if (Error Err =\n          LineTable.parse(LineExtractor, &StmtOffset, OrigDwarf,\n                          &Unit.getOrigUnit(), OrigDwarf.getWarningHandler()))\n    OrigDwarf.getWarningHandler()(std::move(Err));\n\n  // This vector is the output line table.\n  std::vector<DWARFDebugLine::Row> NewRows;\n  NewRows.reserve(LineTable.Rows.size());\n\n  // Current sequence of rows being extracted, before being inserted\n  // in NewRows.\n  std::vector<DWARFDebugLine::Row> Seq;\n  const auto &FunctionRanges = Unit.getFunctionRanges();\n  auto InvalidRange = FunctionRanges.end(), CurrRange = InvalidRange;\n\n  // FIXME: This logic is meant to generate exactly the same output as\n  // Darwin's classic dsymutil. There is a nicer way to implement this\n  // by simply putting all the relocated line info in NewRows and simply\n  // sorting NewRows before passing it to emitLineTableForUnit. This\n  // should be correct as sequences for a function should stay\n  // together in the sorted output. There are a few corner cases that\n  // look suspicious though, and that required to implement the logic\n  // this way. Revisit that once initial validation is finished.\n\n  // Iterate over the object file line info and extract the sequences\n  // that correspond to linked functions.\n  for (auto &Row : LineTable.Rows) {\n    // Check whether we stepped out of the range. The range is\n    // half-open, but consider accept the end address of the range if\n    // it is marked as end_sequence in the input (because in that\n    // case, the relocation offset is accurate and that entry won't\n    // serve as the start of another function).\n    if (CurrRange == InvalidRange || Row.Address.Address < CurrRange.start() ||\n        Row.Address.Address > CurrRange.stop() ||\n        (Row.Address.Address == CurrRange.stop() && !Row.EndSequence)) {\n      // We just stepped out of a known range. Insert a end_sequence\n      // corresponding to the end of the range.\n      uint64_t StopAddress = CurrRange != InvalidRange\n                                 ? CurrRange.stop() + CurrRange.value()\n                                 : -1ULL;\n      CurrRange = FunctionRanges.find(Row.Address.Address);\n      bool CurrRangeValid =\n          CurrRange != InvalidRange && CurrRange.start() <= Row.Address.Address;\n      if (!CurrRangeValid) {\n        CurrRange = InvalidRange;\n        if (StopAddress != -1ULL) {\n          // Try harder by looking in the Address ranges map.\n          // There are corner cases where this finds a\n          // valid entry. It's unclear if this is right or wrong, but\n          // for now do as dsymutil.\n          // FIXME: Understand exactly what cases this addresses and\n          // potentially remove it along with the Ranges map.\n          auto Range = Ranges.lower_bound(Row.Address.Address);\n          if (Range != Ranges.begin() && Range != Ranges.end())\n            --Range;\n\n          if (Range != Ranges.end() && Range->first <= Row.Address.Address &&\n              Range->second.HighPC >= Row.Address.Address) {\n            StopAddress = Row.Address.Address + Range->second.Offset;\n          }\n        }\n      }\n      if (StopAddress != -1ULL && !Seq.empty()) {\n        // Insert end sequence row with the computed end address, but\n        // the same line as the previous one.\n        auto NextLine = Seq.back();\n        NextLine.Address.Address = StopAddress;\n        NextLine.EndSequence = 1;\n        NextLine.PrologueEnd = 0;\n        NextLine.BasicBlock = 0;\n        NextLine.EpilogueBegin = 0;\n        Seq.push_back(NextLine);\n        insertLineSequence(Seq, NewRows);\n      }\n\n      if (!CurrRangeValid)\n        continue;\n    }\n\n    // Ignore empty sequences.\n    if (Row.EndSequence && Seq.empty())\n      continue;\n\n    // Relocate row address and add it to the current sequence.\n    Row.Address.Address += CurrRange.value();\n    Seq.emplace_back(Row);\n\n    if (Row.EndSequence)\n      insertLineSequence(Seq, NewRows);\n  }\n\n  // Finished extracting, now emit the line tables.\n  // FIXME: LLVM hard-codes its prologue values. We just copy the\n  // prologue over and that works because we act as both producer and\n  // consumer. It would be nicer to have a real configurable line\n  // table emitter.\n  if (LineTable.Prologue.getVersion() < 2 ||\n      LineTable.Prologue.getVersion() > 5 ||\n      LineTable.Prologue.DefaultIsStmt != DWARF2_LINE_DEFAULT_IS_STMT ||\n      LineTable.Prologue.OpcodeBase > 13)\n    reportWarning(\"line table parameters mismatch. Cannot emit.\", File);\n  else {\n    uint32_t PrologueEnd = *StmtList + 10 + LineTable.Prologue.PrologueLength;\n    // DWARF v5 has an extra 2 bytes of information before the header_length\n    // field.\n    if (LineTable.Prologue.getVersion() == 5)\n      PrologueEnd += 2;\n    StringRef LineData = OrigDwarf.getDWARFObj().getLineSection().Data;\n    MCDwarfLineTableParams Params;\n    Params.DWARF2LineOpcodeBase = LineTable.Prologue.OpcodeBase;\n    Params.DWARF2LineBase = LineTable.Prologue.LineBase;\n    Params.DWARF2LineRange = LineTable.Prologue.LineRange;\n    TheDwarfEmitter->emitLineTableForUnit(\n        Params, LineData.slice(*StmtList + 4, PrologueEnd),\n        LineTable.Prologue.MinInstLength, NewRows,\n        Unit.getOrigUnit().getAddressByteSize());\n  }\n}\n\nvoid DWARFLinker::emitAcceleratorEntriesForUnit(CompileUnit &Unit) {\n  switch (Options.TheAccelTableKind) {\n  case AccelTableKind::Apple:\n    emitAppleAcceleratorEntriesForUnit(Unit);\n    break;\n  case AccelTableKind::Dwarf:\n    emitDwarfAcceleratorEntriesForUnit(Unit);\n    break;\n  case AccelTableKind::Default:\n    llvm_unreachable(\"The default must be updated to a concrete value.\");\n    break;\n  }\n}\n\nvoid DWARFLinker::emitAppleAcceleratorEntriesForUnit(CompileUnit &Unit) {\n  // Add namespaces.\n  for (const auto &Namespace : Unit.getNamespaces())\n    AppleNamespaces.addName(Namespace.Name,\n                            Namespace.Die->getOffset() + Unit.getStartOffset());\n\n  /// Add names.\n  TheDwarfEmitter->emitPubNamesForUnit(Unit);\n  for (const auto &Pubname : Unit.getPubnames())\n    AppleNames.addName(Pubname.Name,\n                       Pubname.Die->getOffset() + Unit.getStartOffset());\n\n  /// Add types.\n  TheDwarfEmitter->emitPubTypesForUnit(Unit);\n  for (const auto &Pubtype : Unit.getPubtypes())\n    AppleTypes.addName(\n        Pubtype.Name, Pubtype.Die->getOffset() + Unit.getStartOffset(),\n        Pubtype.Die->getTag(),\n        Pubtype.ObjcClassImplementation ? dwarf::DW_FLAG_type_implementation\n                                        : 0,\n        Pubtype.QualifiedNameHash);\n\n  /// Add ObjC names.\n  for (const auto &ObjC : Unit.getObjC())\n    AppleObjc.addName(ObjC.Name, ObjC.Die->getOffset() + Unit.getStartOffset());\n}\n\nvoid DWARFLinker::emitDwarfAcceleratorEntriesForUnit(CompileUnit &Unit) {\n  for (const auto &Namespace : Unit.getNamespaces())\n    DebugNames.addName(Namespace.Name, Namespace.Die->getOffset(),\n                       Namespace.Die->getTag(), Unit.getUniqueID());\n  for (const auto &Pubname : Unit.getPubnames())\n    DebugNames.addName(Pubname.Name, Pubname.Die->getOffset(),\n                       Pubname.Die->getTag(), Unit.getUniqueID());\n  for (const auto &Pubtype : Unit.getPubtypes())\n    DebugNames.addName(Pubtype.Name, Pubtype.Die->getOffset(),\n                       Pubtype.Die->getTag(), Unit.getUniqueID());\n}\n\n/// Read the frame info stored in the object, and emit the\n/// patched frame descriptions for the resulting file.\n///\n/// This is actually pretty easy as the data of the CIEs and FDEs can\n/// be considered as black boxes and moved as is. The only thing to do\n/// is to patch the addresses in the headers.\nvoid DWARFLinker::patchFrameInfoForObject(const DWARFFile &File,\n                                          RangesTy &Ranges,\n                                          DWARFContext &OrigDwarf,\n                                          unsigned AddrSize) {\n  StringRef FrameData = OrigDwarf.getDWARFObj().getFrameSection().Data;\n  if (FrameData.empty())\n    return;\n\n  DataExtractor Data(FrameData, OrigDwarf.isLittleEndian(), 0);\n  uint64_t InputOffset = 0;\n\n  // Store the data of the CIEs defined in this object, keyed by their\n  // offsets.\n  DenseMap<uint64_t, StringRef> LocalCIES;\n\n  while (Data.isValidOffset(InputOffset)) {\n    uint64_t EntryOffset = InputOffset;\n    uint32_t InitialLength = Data.getU32(&InputOffset);\n    if (InitialLength == 0xFFFFFFFF)\n      return reportWarning(\"Dwarf64 bits no supported\", File);\n\n    uint32_t CIEId = Data.getU32(&InputOffset);\n    if (CIEId == 0xFFFFFFFF) {\n      // This is a CIE, store it.\n      StringRef CIEData = FrameData.substr(EntryOffset, InitialLength + 4);\n      LocalCIES[EntryOffset] = CIEData;\n      // The -4 is to account for the CIEId we just read.\n      InputOffset += InitialLength - 4;\n      continue;\n    }\n\n    uint32_t Loc = Data.getUnsigned(&InputOffset, AddrSize);\n\n    // Some compilers seem to emit frame info that doesn't start at\n    // the function entry point, thus we can't just lookup the address\n    // in the debug map. Use the AddressInfo's range map to see if the FDE\n    // describes something that we can relocate.\n    auto Range = Ranges.upper_bound(Loc);\n    if (Range != Ranges.begin())\n      --Range;\n    if (Range == Ranges.end() || Range->first > Loc ||\n        Range->second.HighPC <= Loc) {\n      // The +4 is to account for the size of the InitialLength field itself.\n      InputOffset = EntryOffset + InitialLength + 4;\n      continue;\n    }\n\n    // This is an FDE, and we have a mapping.\n    // Have we already emitted a corresponding CIE?\n    StringRef CIEData = LocalCIES[CIEId];\n    if (CIEData.empty())\n      return reportWarning(\"Inconsistent debug_frame content. Dropping.\", File);\n\n    // Look if we already emitted a CIE that corresponds to the\n    // referenced one (the CIE data is the key of that lookup).\n    auto IteratorInserted = EmittedCIEs.insert(\n        std::make_pair(CIEData, TheDwarfEmitter->getFrameSectionSize()));\n    // If there is no CIE yet for this ID, emit it.\n    if (IteratorInserted.second ||\n        // FIXME: dsymutil-classic only caches the last used CIE for\n        // reuse. Mimic that behavior for now. Just removing that\n        // second half of the condition and the LastCIEOffset variable\n        // makes the code DTRT.\n        LastCIEOffset != IteratorInserted.first->getValue()) {\n      LastCIEOffset = TheDwarfEmitter->getFrameSectionSize();\n      IteratorInserted.first->getValue() = LastCIEOffset;\n      TheDwarfEmitter->emitCIE(CIEData);\n    }\n\n    // Emit the FDE with updated address and CIE pointer.\n    // (4 + AddrSize) is the size of the CIEId + initial_location\n    // fields that will get reconstructed by emitFDE().\n    unsigned FDERemainingBytes = InitialLength - (4 + AddrSize);\n    TheDwarfEmitter->emitFDE(IteratorInserted.first->getValue(), AddrSize,\n                             Loc + Range->second.Offset,\n                             FrameData.substr(InputOffset, FDERemainingBytes));\n    InputOffset += FDERemainingBytes;\n  }\n}\n\nvoid DWARFLinker::DIECloner::copyAbbrev(\n    const DWARFAbbreviationDeclaration &Abbrev, bool HasODR) {\n  DIEAbbrev Copy(dwarf::Tag(Abbrev.getTag()),\n                 dwarf::Form(Abbrev.hasChildren()));\n\n  for (const auto &Attr : Abbrev.attributes()) {\n    uint16_t Form = Attr.Form;\n    if (HasODR && isODRAttribute(Attr.Attr))\n      Form = dwarf::DW_FORM_ref_addr;\n    Copy.AddAttribute(dwarf::Attribute(Attr.Attr), dwarf::Form(Form));\n  }\n\n  Linker.assignAbbrev(Copy);\n}\n\nuint32_t DWARFLinker::DIECloner::hashFullyQualifiedName(DWARFDie DIE,\n                                                        CompileUnit &U,\n                                                        const DWARFFile &File,\n                                                        int ChildRecurseDepth) {\n  const char *Name = nullptr;\n  DWARFUnit *OrigUnit = &U.getOrigUnit();\n  CompileUnit *CU = &U;\n  Optional<DWARFFormValue> Ref;\n\n  while (1) {\n    if (const char *CurrentName = DIE.getName(DINameKind::ShortName))\n      Name = CurrentName;\n\n    if (!(Ref = DIE.find(dwarf::DW_AT_specification)) &&\n        !(Ref = DIE.find(dwarf::DW_AT_abstract_origin)))\n      break;\n\n    if (!Ref->isFormClass(DWARFFormValue::FC_Reference))\n      break;\n\n    CompileUnit *RefCU;\n    if (auto RefDIE =\n            Linker.resolveDIEReference(File, CompileUnits, *Ref, DIE, RefCU)) {\n      CU = RefCU;\n      OrigUnit = &RefCU->getOrigUnit();\n      DIE = RefDIE;\n    }\n  }\n\n  unsigned Idx = OrigUnit->getDIEIndex(DIE);\n  if (!Name && DIE.getTag() == dwarf::DW_TAG_namespace)\n    Name = \"(anonymous namespace)\";\n\n  if (CU->getInfo(Idx).ParentIdx == 0 ||\n      // FIXME: dsymutil-classic compatibility. Ignore modules.\n      CU->getOrigUnit().getDIEAtIndex(CU->getInfo(Idx).ParentIdx).getTag() ==\n          dwarf::DW_TAG_module)\n    return djbHash(Name ? Name : \"\", djbHash(ChildRecurseDepth ? \"\" : \"::\"));\n\n  DWARFDie Die = OrigUnit->getDIEAtIndex(CU->getInfo(Idx).ParentIdx);\n  return djbHash(\n      (Name ? Name : \"\"),\n      djbHash((Name ? \"::\" : \"\"),\n              hashFullyQualifiedName(Die, *CU, File, ++ChildRecurseDepth)));\n}\n\nstatic uint64_t getDwoId(const DWARFDie &CUDie, const DWARFUnit &Unit) {\n  auto DwoId = dwarf::toUnsigned(\n      CUDie.find({dwarf::DW_AT_dwo_id, dwarf::DW_AT_GNU_dwo_id}));\n  if (DwoId)\n    return *DwoId;\n  return 0;\n}\n\nstatic std::string remapPath(StringRef Path,\n                             const objectPrefixMap &ObjectPrefixMap) {\n  if (ObjectPrefixMap.empty())\n    return Path.str();\n\n  SmallString<256> p = Path;\n  for (const auto &Entry : ObjectPrefixMap)\n    if (llvm::sys::path::replace_path_prefix(p, Entry.first, Entry.second))\n      break;\n  return p.str().str();\n}\n\nbool DWARFLinker::registerModuleReference(DWARFDie CUDie, const DWARFUnit &Unit,\n                                          const DWARFFile &File,\n                                          OffsetsStringPool &StringPool,\n                                          DeclContextTree &ODRContexts,\n                                          uint64_t ModulesEndOffset,\n                                          unsigned &UnitID, bool IsLittleEndian,\n                                          unsigned Indent, bool Quiet) {\n  std::string PCMfile = dwarf::toString(\n      CUDie.find({dwarf::DW_AT_dwo_name, dwarf::DW_AT_GNU_dwo_name}), \"\");\n  if (PCMfile.empty())\n    return false;\n  if (Options.ObjectPrefixMap)\n    PCMfile = remapPath(PCMfile, *Options.ObjectPrefixMap);\n\n  // Clang module DWARF skeleton CUs abuse this for the path to the module.\n  uint64_t DwoId = getDwoId(CUDie, Unit);\n\n  std::string Name = dwarf::toString(CUDie.find(dwarf::DW_AT_name), \"\");\n  if (Name.empty()) {\n    if (!Quiet)\n      reportWarning(\"Anonymous module skeleton CU for \" + PCMfile, File);\n    return true;\n  }\n\n  if (!Quiet && Options.Verbose) {\n    outs().indent(Indent);\n    outs() << \"Found clang module reference \" << PCMfile;\n  }\n\n  auto Cached = ClangModules.find(PCMfile);\n  if (Cached != ClangModules.end()) {\n    // FIXME: Until PR27449 (https://llvm.org/bugs/show_bug.cgi?id=27449) is\n    // fixed in clang, only warn about DWO_id mismatches in verbose mode.\n    // ASTFileSignatures will change randomly when a module is rebuilt.\n    if (!Quiet && Options.Verbose && (Cached->second != DwoId))\n      reportWarning(Twine(\"hash mismatch: this object file was built against a \"\n                          \"different version of the module \") +\n                        PCMfile,\n                    File);\n    if (!Quiet && Options.Verbose)\n      outs() << \" [cached].\\n\";\n    return true;\n  }\n  if (!Quiet && Options.Verbose)\n    outs() << \" ...\\n\";\n\n  // Cyclic dependencies are disallowed by Clang, but we still\n  // shouldn't run into an infinite loop, so mark it as processed now.\n  ClangModules.insert({PCMfile, DwoId});\n\n  if (Error E = loadClangModule(CUDie, PCMfile, Name, DwoId, File, StringPool,\n                                ODRContexts, ModulesEndOffset, UnitID,\n                                IsLittleEndian, Indent + 2, Quiet)) {\n    consumeError(std::move(E));\n    return false;\n  }\n  return true;\n}\n\nError DWARFLinker::loadClangModule(\n    DWARFDie CUDie, StringRef Filename, StringRef ModuleName, uint64_t DwoId,\n    const DWARFFile &File, OffsetsStringPool &StringPool,\n    DeclContextTree &ODRContexts, uint64_t ModulesEndOffset, unsigned &UnitID,\n    bool IsLittleEndian, unsigned Indent, bool Quiet) {\n  /// Using a SmallString<0> because loadClangModule() is recursive.\n  SmallString<0> Path(Options.PrependPath);\n  if (sys::path::is_relative(Filename))\n    resolveRelativeObjectPath(Path, CUDie);\n  sys::path::append(Path, Filename);\n  // Don't use the cached binary holder because we have no thread-safety\n  // guarantee and the lifetime is limited.\n\n  if (Options.ObjFileLoader == nullptr)\n    return Error::success();\n\n  auto ErrOrObj = Options.ObjFileLoader(File.FileName, Path);\n  if (!ErrOrObj)\n    return Error::success();\n\n  std::unique_ptr<CompileUnit> Unit;\n\n  for (const auto &CU : ErrOrObj->Dwarf->compile_units()) {\n    updateDwarfVersion(CU->getVersion());\n    // Recursively get all modules imported by this one.\n    auto CUDie = CU->getUnitDIE(false);\n    if (!CUDie)\n      continue;\n    if (!registerModuleReference(CUDie, *CU, File, StringPool, ODRContexts,\n                                 ModulesEndOffset, UnitID, IsLittleEndian,\n                                 Indent, Quiet)) {\n      if (Unit) {\n        std::string Err =\n            (Filename +\n             \": Clang modules are expected to have exactly 1 compile unit.\\n\")\n                .str();\n        reportError(Err, File);\n        return make_error<StringError>(Err, inconvertibleErrorCode());\n      }\n      // FIXME: Until PR27449 (https://llvm.org/bugs/show_bug.cgi?id=27449) is\n      // fixed in clang, only warn about DWO_id mismatches in verbose mode.\n      // ASTFileSignatures will change randomly when a module is rebuilt.\n      uint64_t PCMDwoId = getDwoId(CUDie, *CU);\n      if (PCMDwoId != DwoId) {\n        if (!Quiet && Options.Verbose)\n          reportWarning(\n              Twine(\"hash mismatch: this object file was built against a \"\n                    \"different version of the module \") +\n                  Filename,\n              File);\n        // Update the cache entry with the DwoId of the module loaded from disk.\n        ClangModules[Filename] = PCMDwoId;\n      }\n\n      // Add this module.\n      Unit = std::make_unique<CompileUnit>(*CU, UnitID++, !Options.NoODR,\n                                           ModuleName);\n      Unit->setHasInterestingContent();\n      analyzeContextInfo(CUDie, 0, *Unit, &ODRContexts.getRoot(), ODRContexts,\n                         ModulesEndOffset, Options.ParseableSwiftInterfaces,\n                         [&](const Twine &Warning, const DWARFDie &DIE) {\n                           reportWarning(Warning, File, &DIE);\n                         });\n      // Keep everything.\n      Unit->markEverythingAsKept();\n    }\n  }\n  assert(Unit && \"CompileUnit is not set!\");\n  if (!Unit->getOrigUnit().getUnitDIE().hasChildren())\n    return Error::success();\n  if (!Quiet && Options.Verbose) {\n    outs().indent(Indent);\n    outs() << \"cloning .debug_info from \" << Filename << \"\\n\";\n  }\n\n  UnitListTy CompileUnits;\n  CompileUnits.push_back(std::move(Unit));\n  assert(TheDwarfEmitter);\n  DIECloner(*this, TheDwarfEmitter, *ErrOrObj, DIEAlloc, CompileUnits,\n            Options.Update)\n      .cloneAllCompileUnits(*(ErrOrObj->Dwarf), File, StringPool,\n                            IsLittleEndian);\n  return Error::success();\n}\n\nuint64_t DWARFLinker::DIECloner::cloneAllCompileUnits(\n    DWARFContext &DwarfContext, const DWARFFile &File,\n    OffsetsStringPool &StringPool, bool IsLittleEndian) {\n  uint64_t OutputDebugInfoSize =\n      Linker.Options.NoOutput ? 0 : Emitter->getDebugInfoSectionSize();\n  const uint64_t StartOutputDebugInfoSize = OutputDebugInfoSize;\n\n  for (auto &CurrentUnit : CompileUnits) {\n    const uint16_t DwarfVersion = CurrentUnit->getOrigUnit().getVersion();\n    const uint32_t UnitHeaderSize = DwarfVersion >= 5 ? 12 : 11;\n    auto InputDIE = CurrentUnit->getOrigUnit().getUnitDIE();\n    CurrentUnit->setStartOffset(OutputDebugInfoSize);\n    if (!InputDIE) {\n      OutputDebugInfoSize = CurrentUnit->computeNextUnitOffset(DwarfVersion);\n      continue;\n    }\n    if (CurrentUnit->getInfo(0).Keep) {\n      // Clone the InputDIE into your Unit DIE in our compile unit since it\n      // already has a DIE inside of it.\n      CurrentUnit->createOutputDIE();\n      cloneDIE(InputDIE, File, *CurrentUnit, StringPool, 0 /* PC offset */,\n               UnitHeaderSize, 0, IsLittleEndian,\n               CurrentUnit->getOutputUnitDIE());\n    }\n\n    OutputDebugInfoSize = CurrentUnit->computeNextUnitOffset(DwarfVersion);\n\n    if (!Linker.Options.NoOutput) {\n      assert(Emitter);\n\n      if (LLVM_LIKELY(!Linker.Options.Update) ||\n          Linker.needToTranslateStrings())\n        Linker.patchLineTableForUnit(*CurrentUnit, DwarfContext, File);\n\n      Linker.emitAcceleratorEntriesForUnit(*CurrentUnit);\n\n      if (LLVM_UNLIKELY(Linker.Options.Update))\n        continue;\n\n      Linker.patchRangesForUnit(*CurrentUnit, DwarfContext, File);\n      auto ProcessExpr = [&](StringRef Bytes,\n                             SmallVectorImpl<uint8_t> &Buffer) {\n        DWARFUnit &OrigUnit = CurrentUnit->getOrigUnit();\n        DataExtractor Data(Bytes, IsLittleEndian,\n                           OrigUnit.getAddressByteSize());\n        cloneExpression(Data,\n                        DWARFExpression(Data, OrigUnit.getAddressByteSize(),\n                                        OrigUnit.getFormParams().Format),\n                        File, *CurrentUnit, Buffer);\n      };\n      Emitter->emitLocationsForUnit(*CurrentUnit, DwarfContext, ProcessExpr);\n    }\n  }\n\n  if (!Linker.Options.NoOutput) {\n    assert(Emitter);\n    // Emit all the compile unit's debug information.\n    for (auto &CurrentUnit : CompileUnits) {\n      if (LLVM_LIKELY(!Linker.Options.Update))\n        Linker.generateUnitRanges(*CurrentUnit);\n\n      CurrentUnit->fixupForwardReferences();\n\n      if (!CurrentUnit->getOutputUnitDIE())\n        continue;\n\n      unsigned DwarfVersion = CurrentUnit->getOrigUnit().getVersion();\n\n      assert(Emitter->getDebugInfoSectionSize() ==\n             CurrentUnit->getStartOffset());\n      Emitter->emitCompileUnitHeader(*CurrentUnit, DwarfVersion);\n      Emitter->emitDIE(*CurrentUnit->getOutputUnitDIE());\n      assert(Emitter->getDebugInfoSectionSize() ==\n             CurrentUnit->computeNextUnitOffset(DwarfVersion));\n    }\n  }\n\n  return OutputDebugInfoSize - StartOutputDebugInfoSize;\n}\n\nvoid DWARFLinker::updateAccelKind(DWARFContext &Dwarf) {\n  if (Options.TheAccelTableKind != AccelTableKind::Default)\n    return;\n\n  auto &DwarfObj = Dwarf.getDWARFObj();\n\n  if (!AtLeastOneDwarfAccelTable &&\n      (!DwarfObj.getAppleNamesSection().Data.empty() ||\n       !DwarfObj.getAppleTypesSection().Data.empty() ||\n       !DwarfObj.getAppleNamespacesSection().Data.empty() ||\n       !DwarfObj.getAppleObjCSection().Data.empty())) {\n    AtLeastOneAppleAccelTable = true;\n  }\n\n  if (!AtLeastOneDwarfAccelTable && !DwarfObj.getNamesSection().Data.empty()) {\n    AtLeastOneDwarfAccelTable = true;\n  }\n}\n\nbool DWARFLinker::emitPaperTrailWarnings(const DWARFFile &File,\n                                         OffsetsStringPool &StringPool) {\n\n  if (File.Warnings.empty())\n    return false;\n\n  DIE *CUDie = DIE::get(DIEAlloc, dwarf::DW_TAG_compile_unit);\n  CUDie->setOffset(11);\n  StringRef Producer;\n  StringRef WarningHeader;\n\n  switch (DwarfLinkerClientID) {\n  case DwarfLinkerClient::Dsymutil:\n    Producer = StringPool.internString(\"dsymutil\");\n    WarningHeader = \"dsymutil_warning\";\n    break;\n\n  default:\n    Producer = StringPool.internString(\"dwarfopt\");\n    WarningHeader = \"dwarfopt_warning\";\n    break;\n  }\n\n  StringRef FileName = StringPool.internString(File.FileName);\n  CUDie->addValue(DIEAlloc, dwarf::DW_AT_producer, dwarf::DW_FORM_strp,\n                  DIEInteger(StringPool.getStringOffset(Producer)));\n  DIEBlock *String = new (DIEAlloc) DIEBlock();\n  DIEBlocks.push_back(String);\n  for (auto &C : FileName)\n    String->addValue(DIEAlloc, dwarf::Attribute(0), dwarf::DW_FORM_data1,\n                     DIEInteger(C));\n  String->addValue(DIEAlloc, dwarf::Attribute(0), dwarf::DW_FORM_data1,\n                   DIEInteger(0));\n\n  CUDie->addValue(DIEAlloc, dwarf::DW_AT_name, dwarf::DW_FORM_string, String);\n  for (const auto &Warning : File.Warnings) {\n    DIE &ConstDie = CUDie->addChild(DIE::get(DIEAlloc, dwarf::DW_TAG_constant));\n    ConstDie.addValue(DIEAlloc, dwarf::DW_AT_name, dwarf::DW_FORM_strp,\n                      DIEInteger(StringPool.getStringOffset(WarningHeader)));\n    ConstDie.addValue(DIEAlloc, dwarf::DW_AT_artificial, dwarf::DW_FORM_flag,\n                      DIEInteger(1));\n    ConstDie.addValue(DIEAlloc, dwarf::DW_AT_const_value, dwarf::DW_FORM_strp,\n                      DIEInteger(StringPool.getStringOffset(Warning)));\n  }\n  unsigned Size = 4 /* FORM_strp */ + FileName.size() + 1 +\n                  File.Warnings.size() * (4 + 1 + 4) + 1 /* End of children */;\n  DIEAbbrev Abbrev = CUDie->generateAbbrev();\n  assignAbbrev(Abbrev);\n  CUDie->setAbbrevNumber(Abbrev.getNumber());\n  Size += getULEB128Size(Abbrev.getNumber());\n  // Abbreviation ordering needed for classic compatibility.\n  for (auto &Child : CUDie->children()) {\n    Abbrev = Child.generateAbbrev();\n    assignAbbrev(Abbrev);\n    Child.setAbbrevNumber(Abbrev.getNumber());\n    Size += getULEB128Size(Abbrev.getNumber());\n  }\n  CUDie->setSize(Size);\n  TheDwarfEmitter->emitPaperTrailWarningsDie(*CUDie);\n\n  return true;\n}\n\nvoid DWARFLinker::copyInvariantDebugSection(DWARFContext &Dwarf) {\n  if (!needToTranslateStrings())\n    TheDwarfEmitter->emitSectionContents(\n        Dwarf.getDWARFObj().getLineSection().Data, \"debug_line\");\n  TheDwarfEmitter->emitSectionContents(Dwarf.getDWARFObj().getLocSection().Data,\n                                       \"debug_loc\");\n  TheDwarfEmitter->emitSectionContents(\n      Dwarf.getDWARFObj().getRangesSection().Data, \"debug_ranges\");\n  TheDwarfEmitter->emitSectionContents(\n      Dwarf.getDWARFObj().getFrameSection().Data, \"debug_frame\");\n  TheDwarfEmitter->emitSectionContents(Dwarf.getDWARFObj().getArangesSection(),\n                                       \"debug_aranges\");\n}\n\nvoid DWARFLinker::addObjectFile(DWARFFile &File) {\n  ObjectContexts.emplace_back(LinkContext(File));\n\n  if (ObjectContexts.back().File.Dwarf)\n    updateAccelKind(*ObjectContexts.back().File.Dwarf);\n}\n\nbool DWARFLinker::link() {\n  assert(Options.NoOutput || TheDwarfEmitter);\n\n  // A unique ID that identifies each compile unit.\n  unsigned UnitID = 0;\n\n  // First populate the data structure we need for each iteration of the\n  // parallel loop.\n  unsigned NumObjects = ObjectContexts.size();\n\n  // This Dwarf string pool which is used for emission. It must be used\n  // serially as the order of calling getStringOffset matters for\n  // reproducibility.\n  OffsetsStringPool OffsetsStringPool(StringsTranslator, true);\n\n  // ODR Contexts for the optimize.\n  DeclContextTree ODRContexts;\n\n  // If we haven't decided on an accelerator table kind yet, we base ourselves\n  // on the DWARF we have seen so far. At this point we haven't pulled in debug\n  // information from modules yet, so it is technically possible that they\n  // would affect the decision. However, as they're built with the same\n  // compiler and flags, it is safe to assume that they will follow the\n  // decision made here.\n  if (Options.TheAccelTableKind == AccelTableKind::Default) {\n    if (AtLeastOneDwarfAccelTable && !AtLeastOneAppleAccelTable)\n      Options.TheAccelTableKind = AccelTableKind::Dwarf;\n    else\n      Options.TheAccelTableKind = AccelTableKind::Apple;\n  }\n\n  for (LinkContext &OptContext : ObjectContexts) {\n    if (Options.Verbose) {\n      if (DwarfLinkerClientID == DwarfLinkerClient::Dsymutil)\n        outs() << \"DEBUG MAP OBJECT: \" << OptContext.File.FileName << \"\\n\";\n      else\n        outs() << \"OBJECT FILE: \" << OptContext.File.FileName << \"\\n\";\n    }\n\n    if (emitPaperTrailWarnings(OptContext.File, OffsetsStringPool))\n      continue;\n\n    if (!OptContext.File.Dwarf)\n      continue;\n    // Look for relocations that correspond to address map entries.\n\n    // there was findvalidrelocations previously ... probably we need to gather\n    // info here\n    if (LLVM_LIKELY(!Options.Update) &&\n        !OptContext.File.Addresses->hasValidRelocs()) {\n      if (Options.Verbose)\n        outs() << \"No valid relocations found. Skipping.\\n\";\n\n      // Set \"Skip\" flag as a signal to other loops that we should not\n      // process this iteration.\n      OptContext.Skip = true;\n      continue;\n    }\n\n    // Setup access to the debug info.\n    if (!OptContext.File.Dwarf)\n      continue;\n\n    // In a first phase, just read in the debug info and load all clang modules.\n    OptContext.CompileUnits.reserve(\n        OptContext.File.Dwarf->getNumCompileUnits());\n\n    for (const auto &CU : OptContext.File.Dwarf->compile_units()) {\n      updateDwarfVersion(CU->getVersion());\n      auto CUDie = CU->getUnitDIE(false);\n      if (Options.Verbose) {\n        outs() << \"Input compilation unit:\";\n        DIDumpOptions DumpOpts;\n        DumpOpts.ChildRecurseDepth = 0;\n        DumpOpts.Verbose = Options.Verbose;\n        CUDie.dump(outs(), 0, DumpOpts);\n      }\n      if (CUDie && !LLVM_UNLIKELY(Options.Update))\n        registerModuleReference(CUDie, *CU, OptContext.File, OffsetsStringPool,\n                                ODRContexts, 0, UnitID,\n                                OptContext.File.Dwarf->isLittleEndian());\n    }\n  }\n\n  // If we haven't seen any CUs, pick an arbitrary valid Dwarf version anyway.\n  if (MaxDwarfVersion == 0)\n    MaxDwarfVersion = 3;\n\n  // At this point we know how much data we have emitted. We use this value to\n  // compare canonical DIE offsets in analyzeContextInfo to see if a definition\n  // is already emitted, without being affected by canonical die offsets set\n  // later. This prevents undeterminism when analyze and clone execute\n  // concurrently, as clone set the canonical DIE offset and analyze reads it.\n  const uint64_t ModulesEndOffset =\n      Options.NoOutput ? 0 : TheDwarfEmitter->getDebugInfoSectionSize();\n\n  // These variables manage the list of processed object files.\n  // The mutex and condition variable are to ensure that this is thread safe.\n  std::mutex ProcessedFilesMutex;\n  std::condition_variable ProcessedFilesConditionVariable;\n  BitVector ProcessedFiles(NumObjects, false);\n\n  //  Analyzing the context info is particularly expensive so it is executed in\n  //  parallel with emitting the previous compile unit.\n  auto AnalyzeLambda = [&](size_t I) {\n    auto &Context = ObjectContexts[I];\n\n    if (Context.Skip || !Context.File.Dwarf)\n      return;\n\n    for (const auto &CU : Context.File.Dwarf->compile_units()) {\n      updateDwarfVersion(CU->getVersion());\n      // The !registerModuleReference() condition effectively skips\n      // over fully resolved skeleton units. This second pass of\n      // registerModuleReferences doesn't do any new work, but it\n      // will collect top-level errors, which are suppressed. Module\n      // warnings were already displayed in the first iteration.\n      bool Quiet = true;\n      auto CUDie = CU->getUnitDIE(false);\n      if (!CUDie || LLVM_UNLIKELY(Options.Update) ||\n          !registerModuleReference(CUDie, *CU, Context.File, OffsetsStringPool,\n                                   ODRContexts, ModulesEndOffset, UnitID,\n                                   Quiet)) {\n        Context.CompileUnits.push_back(std::make_unique<CompileUnit>(\n            *CU, UnitID++, !Options.NoODR && !Options.Update, \"\"));\n      }\n    }\n\n    // Now build the DIE parent links that we will use during the next phase.\n    for (auto &CurrentUnit : Context.CompileUnits) {\n      auto CUDie = CurrentUnit->getOrigUnit().getUnitDIE();\n      if (!CUDie)\n        continue;\n      analyzeContextInfo(CurrentUnit->getOrigUnit().getUnitDIE(), 0,\n                         *CurrentUnit, &ODRContexts.getRoot(), ODRContexts,\n                         ModulesEndOffset, Options.ParseableSwiftInterfaces,\n                         [&](const Twine &Warning, const DWARFDie &DIE) {\n                           reportWarning(Warning, Context.File, &DIE);\n                         });\n    }\n  };\n\n  // For each object file map how many bytes were emitted.\n  StringMap<DebugInfoSize> SizeByObject;\n\n  // And then the remaining work in serial again.\n  // Note, although this loop runs in serial, it can run in parallel with\n  // the analyzeContextInfo loop so long as we process files with indices >=\n  // than those processed by analyzeContextInfo.\n  auto CloneLambda = [&](size_t I) {\n    auto &OptContext = ObjectContexts[I];\n    if (OptContext.Skip || !OptContext.File.Dwarf)\n      return;\n\n    // Then mark all the DIEs that need to be present in the generated output\n    // and collect some information about them.\n    // Note that this loop can not be merged with the previous one because\n    // cross-cu references require the ParentIdx to be setup for every CU in\n    // the object file before calling this.\n    if (LLVM_UNLIKELY(Options.Update)) {\n      for (auto &CurrentUnit : OptContext.CompileUnits)\n        CurrentUnit->markEverythingAsKept();\n      copyInvariantDebugSection(*OptContext.File.Dwarf);\n    } else {\n      for (auto &CurrentUnit : OptContext.CompileUnits)\n        lookForDIEsToKeep(*OptContext.File.Addresses,\n                          OptContext.File.Addresses->getValidAddressRanges(),\n                          OptContext.CompileUnits,\n                          CurrentUnit->getOrigUnit().getUnitDIE(),\n                          OptContext.File, *CurrentUnit, 0);\n    }\n\n    // The calls to applyValidRelocs inside cloneDIE will walk the reloc\n    // array again (in the same way findValidRelocsInDebugInfo() did). We\n    // need to reset the NextValidReloc index to the beginning.\n    if (OptContext.File.Addresses->hasValidRelocs() ||\n        LLVM_UNLIKELY(Options.Update)) {\n      SizeByObject[OptContext.File.FileName].Input =\n          getDebugInfoSize(*OptContext.File.Dwarf);\n      SizeByObject[OptContext.File.FileName].Output =\n          DIECloner(*this, TheDwarfEmitter, OptContext.File, DIEAlloc,\n                    OptContext.CompileUnits, Options.Update)\n              .cloneAllCompileUnits(*OptContext.File.Dwarf, OptContext.File,\n                                    OffsetsStringPool,\n                                    OptContext.File.Dwarf->isLittleEndian());\n    }\n    if (!Options.NoOutput && !OptContext.CompileUnits.empty() &&\n        LLVM_LIKELY(!Options.Update))\n      patchFrameInfoForObject(\n          OptContext.File, OptContext.File.Addresses->getValidAddressRanges(),\n          *OptContext.File.Dwarf,\n          OptContext.CompileUnits[0]->getOrigUnit().getAddressByteSize());\n\n    // Clean-up before starting working on the next object.\n    cleanupAuxiliarryData(OptContext);\n  };\n\n  auto EmitLambda = [&]() {\n    // Emit everything that's global.\n    if (!Options.NoOutput) {\n      TheDwarfEmitter->emitAbbrevs(Abbreviations, MaxDwarfVersion);\n      TheDwarfEmitter->emitStrings(OffsetsStringPool);\n      switch (Options.TheAccelTableKind) {\n      case AccelTableKind::Apple:\n        TheDwarfEmitter->emitAppleNames(AppleNames);\n        TheDwarfEmitter->emitAppleNamespaces(AppleNamespaces);\n        TheDwarfEmitter->emitAppleTypes(AppleTypes);\n        TheDwarfEmitter->emitAppleObjc(AppleObjc);\n        break;\n      case AccelTableKind::Dwarf:\n        TheDwarfEmitter->emitDebugNames(DebugNames);\n        break;\n      case AccelTableKind::Default:\n        llvm_unreachable(\"Default should have already been resolved.\");\n        break;\n      }\n    }\n  };\n\n  auto AnalyzeAll = [&]() {\n    for (unsigned I = 0, E = NumObjects; I != E; ++I) {\n      AnalyzeLambda(I);\n\n      std::unique_lock<std::mutex> LockGuard(ProcessedFilesMutex);\n      ProcessedFiles.set(I);\n      ProcessedFilesConditionVariable.notify_one();\n    }\n  };\n\n  auto CloneAll = [&]() {\n    for (unsigned I = 0, E = NumObjects; I != E; ++I) {\n      {\n        std::unique_lock<std::mutex> LockGuard(ProcessedFilesMutex);\n        if (!ProcessedFiles[I]) {\n          ProcessedFilesConditionVariable.wait(\n              LockGuard, [&]() { return ProcessedFiles[I]; });\n        }\n      }\n\n      CloneLambda(I);\n    }\n    EmitLambda();\n  };\n\n  // To limit memory usage in the single threaded case, analyze and clone are\n  // run sequentially so the OptContext is freed after processing each object\n  // in endDebugObject.\n  if (Options.Threads == 1) {\n    for (unsigned I = 0, E = NumObjects; I != E; ++I) {\n      AnalyzeLambda(I);\n      CloneLambda(I);\n    }\n    EmitLambda();\n  } else {\n    ThreadPool Pool(hardware_concurrency(2));\n    Pool.async(AnalyzeAll);\n    Pool.async(CloneAll);\n    Pool.wait();\n  }\n\n  if (Options.Statistics) {\n    // Create a vector sorted in descending order by output size.\n    std::vector<std::pair<StringRef, DebugInfoSize>> Sorted;\n    for (auto &E : SizeByObject)\n      Sorted.emplace_back(E.first(), E.second);\n    llvm::sort(Sorted, [](auto &LHS, auto &RHS) {\n      return LHS.second.Output > RHS.second.Output;\n    });\n\n    auto ComputePercentange = [](int64_t Input, int64_t Output) -> float {\n      const float Difference = Output - Input;\n      const float Sum = Input + Output;\n      if (Sum == 0)\n        return 0;\n      return (Difference / (Sum / 2));\n    };\n\n    int64_t InputTotal = 0;\n    int64_t OutputTotal = 0;\n    const char *FormatStr = \"{0,-45} {1,10}b  {2,10}b {3,8:P}\\n\";\n\n    // Print header.\n    outs() << \".debug_info section size (in bytes)\\n\";\n    outs() << \"----------------------------------------------------------------\"\n              \"---------------\\n\";\n    outs() << \"Filename                                           Object       \"\n              \"  dSYM   Change\\n\";\n    outs() << \"----------------------------------------------------------------\"\n              \"---------------\\n\";\n\n    // Print body.\n    for (auto &E : Sorted) {\n      InputTotal += E.second.Input;\n      OutputTotal += E.second.Output;\n      llvm::outs() << formatv(\n          FormatStr, sys::path::filename(E.first).take_back(45), E.second.Input,\n          E.second.Output, ComputePercentange(E.second.Input, E.second.Output));\n    }\n    // Print total and footer.\n    outs() << \"----------------------------------------------------------------\"\n              \"---------------\\n\";\n    llvm::outs() << formatv(FormatStr, \"Total\", InputTotal, OutputTotal,\n                            ComputePercentange(InputTotal, OutputTotal));\n    outs() << \"----------------------------------------------------------------\"\n              \"---------------\\n\\n\";\n  }\n\n  return true;\n}\n\n} // namespace llvm\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 7, "line": 133}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "7370fb41e59627185044b2eb10bad70c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 140}, "message": "destructor '~HashData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "1054ada3ee319a427febd7cf91c73786", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 49}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "a6d521e194518ff0afdb1ae2f5cb002a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 163}, "message": "move constructor 'DIEInteger' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "ecd81e749fa2744770bee399eb3aa39a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 922}, "message": "destructor '~DIELoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "051aa8c14ff4fab3e8ca4bef5fef45e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 959}, "message": "destructor '~DIEBlock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "cfe70553210be1a2761bd8faf629db7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 33, "line": 67}, "message": "destructor '~StrongType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h", "reportHash": "4ff754228098767833ebf05b10273fe0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 34}, "message": "destructor '~ObjFileAddressRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "b97731e0f6974c468f4627d48be55c88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 34}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "c22a9c6796f94c8d4a22259b850ac0dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 363}, "message": "destructor '~WorklistItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "d544eb05bda4f46923ea3403fe3faba3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 363}, "message": "move constructor 'WorklistItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "ac0f31f2b1409f0e037161abc56aea93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 34, "line": 368}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "b73720184e16d5f87f58736e3d717cab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 34, "line": 368}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "2c5255aefa9d067484f9d702b1303589", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 417}, "message": "destructor '~LinkContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "359b1bcc9e57c7d31ad27f8c7029e764", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 417}, "message": "move constructor 'LinkContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "f37c399698b01101a6c95b842d7e668a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 34, "line": 530}, "message": "destructor '~DIECloner' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinker.h", "reportHash": "5edaa1c9858d68999c32c2d8d6f00c72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 50}, "message": "destructor '~CompileUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerCompileUnit.h", "reportHash": "7ece3742f4e02e849d015b55d2f4addc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 31}, "message": "destructor '~CachedPathResolver' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerDeclContext.h", "reportHash": "0161f8f20be2259af6bc43e4b449ca39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 77}, "message": "destructor '~DeclContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerDeclContext.h", "reportHash": "04d85a3feff6880e51163c3b9d542b05", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 121}, "message": "destructor '~DeclContextTree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerDeclContext.h", "reportHash": "823e59009e6009bfc5057f4df5223ed2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 38}, "message": "default constructor 'DebugInfoSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "e9f2345dd00bf131ac5383178f0a2cce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 38}, "message": "destructor '~DebugInfoSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "fa37f635b6b229a3736c3c655e430998", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 38}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "389ff9010b312a72c24b8a1707d01c6c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 38}, "message": "move constructor 'DebugInfoSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "25809c1ed11352c696a33581b16179c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 94, "line": 56}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "9311c7799844c1e7d5ccbfd31b4f6936", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 94, "line": 56}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "900191ca9843849524c6b45a14027587", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 255}, "message": "destructor '~ContextWorklistItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "f4dbc6ac40f5961cbf59d175c580e69a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 255}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "72b97a77622c4dd2e9d170b1418c58ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 255}, "message": "move constructor 'ContextWorklistItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "49054bc182f6e30a5223aa8bb0a96193", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 94, "line": 258}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "bdb5e232ab2c28d081c5218131d7950c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 94, "line": 258}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "9b02b758871badd713def48ed7e4f06e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 94, "line": 258}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "f88e55bf5ec867257e9dbfcad41f56b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 94, "line": 1615}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "8c08964a115a1e60580c8e273a0a9859", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 94, "line": 1615}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "d6a527ba13f9af16497d3e3002fda5b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2127}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "3a6b030b233e69091562a17fdec2ee84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2127}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "a0b1a6fdb7c15a5bb334af4a2c13b2ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2192}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "a0fe7f87168ebb65f56a1b2e00bf320c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2192}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "0defd3e93e782a1a7948c60acb1cb204", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 94, "line": 2439}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "0ce2be66601487eae8ea9cf3619a37e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 94, "line": 2439}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "7539b5b33ac596f29e438c4e8781d10b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2471}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "3a6b030b233e69091562a17fdec2ee84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2471}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "a0b1a6fdb7c15a5bb334af4a2c13b2ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 94, "line": 2484}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "48bcdebe6e99c1efe621bf5a9eb9b126", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 94, "line": 2484}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "45054a653167694731dbbc44aaa3bee4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 94, "line": 2532}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "fd57429a5618e1eb6b9dc24702fd5c06", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 94, "line": 2532}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "8e98a200d6ab900067385f3e7ab62dd4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 94, "line": 2554}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "ef9ddc29294447ff51e857293c2379f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 94, "line": 2554}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "b68a9079467406d24f7ca5c1c1b41ffe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 94, "line": 2564}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "63b6b786b7052713754f3ba7e37bcc53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 94, "line": 2564}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "63affd6f6ec7907f1e11f0d30c35d554", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2570}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "d1b2801ac8586477ba08441f071f4caa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 94, "line": 2570}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "15fae39a36e5f377021cdec7f65c7e27", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 94, "line": 2600}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "84d5e5569ff4b5ed09d7f34306cc42f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 94, "line": 2600}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "f0e16f6d8c45f72b394a35f5e44bd25b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 94, "line": 2604}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "60a4781b19a01feb3d23dcc97002c535", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 94, "line": 2604}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DWARFLinker/DWARFLinker.cpp", "reportHash": "f6ef42eeab203c4771fb1b507f2a4f2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
