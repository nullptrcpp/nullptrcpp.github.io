<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopBuilder.h", "content": "//===- polly/ScopBuilder.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Create a polyhedral description for a static control flow region.\n//\n// The pass creates a polyhedral description of the Scops detected by the SCoP\n// detection derived from their LLVM-IR code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SCOPBUILDER_H\n#define POLLY_SCOPBUILDER_H\n\n#include \"polly/ScopInfo.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SetVector.h\"\n\nnamespace polly {\nusing llvm::SmallSetVector;\n\nclass ScopDetection;\n\n/// Command line switch whether to model read-only accesses.\nextern bool ModelReadOnlyScalars;\n\n/// Build the Polly IR (Scop and ScopStmt) on a Region.\nclass ScopBuilder {\n\n  /// The AAResults to build AliasSetTracker.\n  AAResults &AA;\n\n  /// Target data for element size computing.\n  const DataLayout &DL;\n\n  /// DominatorTree to reason about guaranteed execution.\n  DominatorTree &DT;\n\n  /// LoopInfo for information about loops.\n  LoopInfo &LI;\n\n  /// Valid Regions for Scop\n  ScopDetection &SD;\n\n  /// The ScalarEvolution to help building Scop.\n  ScalarEvolution &SE;\n\n  /// An optimization diagnostic interface to add optimization remarks.\n  OptimizationRemarkEmitter &ORE;\n\n  /// Set of instructions that might read any memory location.\n  SmallVector<std::pair<ScopStmt *, Instruction *>, 16> GlobalReads;\n\n  /// Set of all accessed array base pointers.\n  SmallSetVector<Value *, 16> ArrayBasePointers;\n\n  // The Scop\n  std::unique_ptr<Scop> scop;\n\n  /// Collection to hold taken assumptions.\n  ///\n  /// There are two reasons why we want to record assumptions first before we\n  /// add them to the assumed/invalid context:\n  ///   1) If the SCoP is not profitable or otherwise invalid without the\n  ///      assumed/invalid context we do not have to compute it.\n  ///   2) Information about the context are gathered rather late in the SCoP\n  ///      construction (basically after we know all parameters), thus the user\n  ///      might see overly complicated assumptions to be taken while they will\n  ///      only be simplified later on.\n  RecordedAssumptionsTy RecordedAssumptions;\n\n  // Methods for pattern matching against Fortran code generated by dragonegg.\n  // @{\n\n  /// Try to match for the descriptor of a Fortran array whose allocation\n  /// is not visible. That is, we can see the load/store into the memory, but\n  /// we don't actually know where the memory is allocated. If ALLOCATE had been\n  /// called on the Fortran array, then we will see the lowered malloc() call.\n  /// If not, this is dubbed as an \"invisible allocation\".\n  ///\n  /// \"<descriptor>\" is the descriptor of the Fortran array.\n  ///\n  /// Pattern match for \"@descriptor\":\n  ///  1. %mem = load double*, double** bitcast (%\"struct.array1_real(kind=8)\"*\n  ///    <descriptor> to double**), align 32\n  ///\n  ///  2. [%slot = getelementptr inbounds i8, i8* %mem, i64 <index>]\n  ///  2 is optional because if you are writing to the 0th index, you don't\n  ///     need a GEP.\n  ///\n  ///  3.1 store/load <memtype> <val>, <memtype>* %slot\n  ///  3.2 store/load <memtype> <val>, <memtype>* %mem\n  ///\n  /// @see polly::MemoryAccess, polly::ScopArrayInfo\n  ///\n  /// @note assumes -polly-canonicalize has been run.\n  ///\n  /// @param Inst The LoadInst/StoreInst that accesses the memory.\n  ///\n  /// @returns Reference to <descriptor> on success, nullptr on failure.\n  Value *findFADAllocationInvisible(MemAccInst Inst);\n\n  /// Try to match for the descriptor of a Fortran array whose allocation\n  /// call is visible. When we have a Fortran array, we try to look for a\n  /// Fortran array where we can see the lowered ALLOCATE call. ALLOCATE\n  /// is materialized as a malloc(...) which we pattern match for.\n  ///\n  /// Pattern match for \"%untypedmem\":\n  ///  1. %untypedmem = i8* @malloc(...)\n  ///\n  ///  2. %typedmem = bitcast i8* %untypedmem to <memtype>\n  ///\n  ///  3. [%slot = getelementptr inbounds i8, i8* %typedmem, i64 <index>]\n  ///  3 is optional because if you are writing to the 0th index, you don't\n  ///     need a GEP.\n  ///\n  ///  4.1 store/load <memtype> <val>, <memtype>* %slot, align 8\n  ///  4.2 store/load <memtype> <val>, <memtype>* %mem, align 8\n  ///\n  /// @see polly::MemoryAccess, polly::ScopArrayInfo\n  ///\n  /// @note assumes -polly-canonicalize has been run.\n  ///\n  /// @param Inst The LoadInst/StoreInst that accesses the memory.\n  ///\n  /// @returns Reference to %untypedmem on success, nullptr on failure.\n  Value *findFADAllocationVisible(MemAccInst Inst);\n\n  // @}\n\n  // Build the SCoP for Region @p R.\n  void buildScop(Region &R, AssumptionCache &AC);\n\n  /// Adjust the dimensions of @p Dom that was constructed for @p OldL\n  ///        to be compatible to domains constructed for loop @p NewL.\n  ///\n  /// This function assumes @p NewL and @p OldL are equal or there is a CFG\n  /// edge from @p OldL to @p NewL.\n  isl::set adjustDomainDimensions(isl::set Dom, Loop *OldL, Loop *NewL);\n\n  /// Compute the domain for each basic block in @p R.\n  ///\n  /// @param R                The region we currently traverse.\n  /// @param InvalidDomainMap BB to InvalidDomain map for the BB of current\n  ///                         region.\n  ///\n  /// @returns True if there was no problem and false otherwise.\n  bool buildDomains(Region *R,\n                    DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Compute the branching constraints for each basic block in @p R.\n  ///\n  /// @param R                The region we currently build branching conditions\n  ///                         for.\n  /// @param InvalidDomainMap BB to InvalidDomain map for the BB of current\n  ///                         region.\n  ///\n  /// @returns True if there was no problem and false otherwise.\n  bool buildDomainsWithBranchConstraints(\n      Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Build the conditions sets for the terminator @p TI in the @p Domain.\n  ///\n  /// This will fill @p ConditionSets with the conditions under which control\n  /// will be moved from @p TI to its successors. Hence, @p ConditionSets will\n  /// have as many elements as @p TI has successors.\n  bool buildConditionSets(BasicBlock *BB, Instruction *TI, Loop *L,\n                          __isl_keep isl_set *Domain,\n                          DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                          SmallVectorImpl<__isl_give isl_set *> &ConditionSets);\n\n  /// Build the conditions sets for the branch condition @p Condition in\n  /// the @p Domain.\n  ///\n  /// This will fill @p ConditionSets with the conditions under which control\n  /// will be moved from @p TI to its successors. Hence, @p ConditionSets will\n  /// have as many elements as @p TI has successors. If @p TI is nullptr the\n  /// context under which @p Condition is true/false will be returned as the\n  /// new elements of @p ConditionSets.\n  bool buildConditionSets(BasicBlock *BB, Value *Condition, Instruction *TI,\n                          Loop *L, __isl_keep isl_set *Domain,\n                          DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                          SmallVectorImpl<__isl_give isl_set *> &ConditionSets);\n\n  /// Build the conditions sets for the switch @p SI in the @p Domain.\n  ///\n  /// This will fill @p ConditionSets with the conditions under which control\n  /// will be moved from @p SI to its successors. Hence, @p ConditionSets will\n  /// have as many elements as @p SI has successors.\n  bool buildConditionSets(BasicBlock *BB, SwitchInst *SI, Loop *L,\n                          __isl_keep isl_set *Domain,\n                          DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                          SmallVectorImpl<__isl_give isl_set *> &ConditionSets);\n\n  /// Build condition sets for unsigned ICmpInst(s).\n  /// Special handling is required for unsigned operands to ensure that if\n  /// MSB (aka the Sign bit) is set for an operands in an unsigned ICmpInst\n  /// it should wrap around.\n  ///\n  /// @param IsStrictUpperBound holds information on the predicate relation\n  /// between TestVal and UpperBound, i.e,\n  /// TestVal < UpperBound  OR  TestVal <= UpperBound\n  __isl_give isl_set *buildUnsignedConditionSets(\n      BasicBlock *BB, Value *Condition, __isl_keep isl_set *Domain,\n      const SCEV *SCEV_TestVal, const SCEV *SCEV_UpperBound,\n      DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n      bool IsStrictUpperBound);\n\n  /// Propagate the domain constraints through the region @p R.\n  ///\n  /// @param R                The region we currently build branching\n  /// conditions for.\n  /// @param InvalidDomainMap BB to InvalidDomain map for the BB of current\n  ///                         region.\n  ///\n  /// @returns True if there was no problem and false otherwise.\n  bool propagateDomainConstraints(\n      Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Propagate domains that are known due to graph properties.\n  ///\n  /// As a CFG is mostly structured we use the graph properties to propagate\n  /// domains without the need to compute all path conditions. In particular,\n  /// if a block A dominates a block B and B post-dominates A we know that the\n  /// domain of B is a superset of the domain of A. As we do not have\n  /// post-dominator information available here we use the less precise region\n  /// information. Given a region R, we know that the exit is always executed\n  /// if the entry was executed, thus the domain of the exit is a superset of\n  /// the domain of the entry. In case the exit can only be reached from\n  /// within the region the domains are in fact equal. This function will use\n  /// this property to avoid the generation of condition constraints that\n  /// determine when a branch is taken. If @p BB is a region entry block we\n  /// will propagate its domain to the region exit block. Additionally, we put\n  /// the region exit block in the @p FinishedExitBlocks set so we can later\n  /// skip edges from within the region to that block.\n  ///\n  /// @param BB                 The block for which the domain is currently\n  ///                           propagated.\n  /// @param BBLoop             The innermost affine loop surrounding @p BB.\n  /// @param FinishedExitBlocks Set of region exits the domain was set for.\n  /// @param InvalidDomainMap   BB to InvalidDomain map for the BB of current\n  ///                           region.\n  void propagateDomainConstraintsToRegionExit(\n      BasicBlock *BB, Loop *BBLoop,\n      SmallPtrSetImpl<BasicBlock *> &FinishedExitBlocks,\n      DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Propagate invalid domains of statements through @p R.\n  ///\n  /// This method will propagate invalid statement domains through @p R and at\n  /// the same time add error block domains to them. Additionally, the domains\n  /// of error statements and those only reachable via error statements will\n  /// be replaced by an empty set. Later those will be removed completely.\n  ///\n  /// @param R                The currently traversed region.\n  /// @param InvalidDomainMap BB to InvalidDomain map for the BB of current\n  ///                         region.\n  //\n  /// @returns True if there was no problem and false otherwise.\n  bool propagateInvalidStmtDomains(\n      Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Compute the union of predecessor domains for @p BB.\n  ///\n  /// To compute the union of all domains of predecessors of @p BB this\n  /// function applies similar reasoning on the CFG structure as described for\n  ///   @see propagateDomainConstraintsToRegionExit\n  ///\n  /// @param BB     The block for which the predecessor domains are collected.\n  /// @param Domain The domain under which BB is executed.\n  ///\n  /// @returns The domain under which @p BB is executed.\n  isl::set getPredecessorDomainConstraints(BasicBlock *BB, isl::set Domain);\n\n  /// Add loop carried constraints to the header block of the loop @p L.\n  ///\n  /// @param L                The loop to process.\n  /// @param InvalidDomainMap BB to InvalidDomain map for the BB of current\n  ///                         region.\n  ///\n  /// @returns True if there was no problem and false otherwise.\n  bool addLoopBoundsToHeaderDomain(\n      Loop *L, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Compute the isl representation for the SCEV @p E in this BB.\n  ///\n  /// @param BB               The BB for which isl representation is to be\n  /// computed.\n  /// @param InvalidDomainMap A map of BB to their invalid domains.\n  /// @param E                The SCEV that should be translated.\n  /// @param NonNegative      Flag to indicate the @p E has to be\n  /// non-negative.\n  ///\n  /// Note that this function will also adjust the invalid context\n  /// accordingly.\n  __isl_give isl_pw_aff *\n  getPwAff(BasicBlock *BB, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n           const SCEV *E, bool NonNegative = false);\n\n  /// Create equivalence classes for required invariant accesses.\n  ///\n  /// These classes will consolidate multiple required invariant loads from the\n  /// same address in order to keep the number of dimensions in the SCoP\n  /// description small. For each such class equivalence class only one\n  /// representing element, hence one required invariant load, will be chosen\n  /// and modeled as parameter. The method\n  /// Scop::getRepresentingInvariantLoadSCEV() will replace each element from an\n  /// equivalence class with the representing element that is modeled. As a\n  /// consequence Scop::getIdForParam() will only return an id for the\n  /// representing element of each equivalence class, thus for each required\n  /// invariant location.\n  void buildInvariantEquivalenceClasses();\n\n  /// Try to build a multi-dimensional fixed sized MemoryAccess from the\n  /// Load/Store instruction.\n  ///\n  /// @param Inst       The Load/Store instruction that access the memory\n  /// @param Stmt       The parent statement of the instruction\n  ///\n  /// @returns True if the access could be built, False otherwise.\n  bool buildAccessMultiDimFixed(MemAccInst Inst, ScopStmt *Stmt);\n\n  /// Try to build a multi-dimensional parametric sized MemoryAccess.\n  ///        from the Load/Store instruction.\n  ///\n  /// @param Inst       The Load/Store instruction that access the memory\n  /// @param Stmt       The parent statement of the instruction\n  ///\n  /// @returns True if the access could be built, False otherwise.\n  bool buildAccessMultiDimParam(MemAccInst Inst, ScopStmt *Stmt);\n\n  /// Try to build a MemoryAccess for a memory intrinsic.\n  ///\n  /// @param Inst       The instruction that access the memory\n  /// @param Stmt       The parent statement of the instruction\n  ///\n  /// @returns True if the access could be built, False otherwise.\n  bool buildAccessMemIntrinsic(MemAccInst Inst, ScopStmt *Stmt);\n\n  /// Try to build a MemoryAccess for a call instruction.\n  ///\n  /// @param Inst       The call instruction that access the memory\n  /// @param Stmt       The parent statement of the instruction\n  ///\n  /// @returns True if the access could be built, False otherwise.\n  bool buildAccessCallInst(MemAccInst Inst, ScopStmt *Stmt);\n\n  /// Build a single-dimensional parametric sized MemoryAccess\n  ///        from the Load/Store instruction.\n  ///\n  /// @param Inst       The Load/Store instruction that access the memory\n  /// @param Stmt       The parent statement of the instruction\n  void buildAccessSingleDim(MemAccInst Inst, ScopStmt *Stmt);\n\n  /// Finalize all access relations.\n  ///\n  /// When building up access relations, temporary access relations that\n  /// correctly represent each individual access are constructed. However, these\n  /// access relations can be inconsistent or non-optimal when looking at the\n  /// set of accesses as a whole. This function finalizes the memory accesses\n  /// and constructs a globally consistent state.\n  void finalizeAccesses();\n\n  /// Update access dimensionalities.\n  ///\n  /// When detecting memory accesses different accesses to the same array may\n  /// have built with different dimensionality, as outer zero-values dimensions\n  /// may not have been recognized as separate dimensions. This function goes\n  /// again over all memory accesses and updates their dimensionality to match\n  /// the dimensionality of the underlying ScopArrayInfo object.\n  void updateAccessDimensionality();\n\n  /// Fold size constants to the right.\n  ///\n  /// In case all memory accesses in a given dimension are multiplied with a\n  /// common constant, we can remove this constant from the individual access\n  /// functions and move it to the size of the memory access. We do this as this\n  /// increases the size of the innermost dimension, consequently widens the\n  /// valid range the array subscript in this dimension can evaluate to, and\n  /// as a result increases the likelihood that our delinearization is\n  /// correct.\n  ///\n  /// Example:\n  ///\n  ///    A[][n]\n  ///    S[i,j] -> A[2i][2j+1]\n  ///    S[i,j] -> A[2i][2j]\n  ///\n  ///    =>\n  ///\n  ///    A[][2n]\n  ///    S[i,j] -> A[i][2j+1]\n  ///    S[i,j] -> A[i][2j]\n  ///\n  /// Constants in outer dimensions can arise when the elements of a parametric\n  /// multi-dimensional array are not elementary data types, but e.g.,\n  /// structures.\n  void foldSizeConstantsToRight();\n\n  /// Fold memory accesses to handle parametric offset.\n  ///\n  /// As a post-processing step, we 'fold' memory accesses to parametric\n  /// offsets in the access functions. @see MemoryAccess::foldAccess for\n  /// details.\n  void foldAccessRelations();\n\n  /// Assume that all memory accesses are within bounds.\n  ///\n  /// After we have built a model of all memory accesses, we need to assume\n  /// that the model we built matches reality -- aka. all modeled memory\n  /// accesses always remain within bounds. We do this as last step, after\n  /// all memory accesses have been modeled and canonicalized.\n  void assumeNoOutOfBounds();\n\n  /// Mark arrays that have memory accesses with FortranArrayDescriptor.\n  void markFortranArrays();\n\n  /// Build the alias checks for this SCoP.\n  bool buildAliasChecks();\n\n  /// A vector of memory accesses that belong to an alias group.\n  using AliasGroupTy = SmallVector<MemoryAccess *, 4>;\n\n  /// A vector of alias groups.\n  using AliasGroupVectorTy = SmallVector<AliasGroupTy, 4>;\n\n  /// Build a given alias group and its access data.\n  ///\n  /// @param AliasGroup     The alias group to build.\n  /// @param HasWriteAccess A set of arrays through which memory is not only\n  ///                       read, but also written.\n  //\n  /// @returns True if __no__ error occurred, false otherwise.\n  bool buildAliasGroup(AliasGroupTy &AliasGroup,\n                       DenseSet<const ScopArrayInfo *> HasWriteAccess);\n\n  /// Build all alias groups for this SCoP.\n  ///\n  /// @returns True if __no__ error occurred, false otherwise.\n  bool buildAliasGroups();\n\n  /// Build alias groups for all memory accesses in the Scop.\n  ///\n  /// Using the alias analysis and an alias set tracker we build alias sets\n  /// for all memory accesses inside the Scop. For each alias set we then map\n  /// the aliasing pointers back to the memory accesses we know, thus obtain\n  /// groups of memory accesses which might alias. We also collect the set of\n  /// arrays through which memory is written.\n  ///\n  /// @returns A pair consistent of a vector of alias groups and a set of arrays\n  ///          through which memory is written.\n  std::tuple<AliasGroupVectorTy, DenseSet<const ScopArrayInfo *>>\n  buildAliasGroupsForAccesses();\n\n  ///  Split alias groups by iteration domains.\n  ///\n  ///  We split each group based on the domains of the minimal/maximal accesses.\n  ///  That means two minimal/maximal accesses are only in a group if their\n  ///  access domains intersect. Otherwise, they are in different groups.\n  ///\n  ///  @param AliasGroups The alias groups to split\n  void splitAliasGroupsByDomain(AliasGroupVectorTy &AliasGroups);\n\n  /// Build an instance of MemoryAccess from the Load/Store instruction.\n  ///\n  /// @param Inst       The Load/Store instruction that access the memory\n  /// @param Stmt       The parent statement of the instruction\n  void buildMemoryAccess(MemAccInst Inst, ScopStmt *Stmt);\n\n  /// Analyze and extract the cross-BB scalar dependences (or, dataflow\n  /// dependencies) of an instruction.\n  ///\n  /// @param UserStmt The statement @p Inst resides in.\n  /// @param Inst     The instruction to be analyzed.\n  void buildScalarDependences(ScopStmt *UserStmt, Instruction *Inst);\n\n  /// Build the escaping dependences for @p Inst.\n  ///\n  /// Search for uses of the llvm::Value defined by @p Inst that are not\n  /// within the SCoP. If there is such use, add a SCALAR WRITE such that\n  /// it is available after the SCoP as escaping value.\n  ///\n  /// @param Inst The instruction to be analyzed.\n  void buildEscapingDependences(Instruction *Inst);\n\n  /// Create MemoryAccesses for the given PHI node in the given region.\n  ///\n  /// @param PHIStmt            The statement @p PHI resides in.\n  /// @param PHI                The PHI node to be handled\n  /// @param NonAffineSubRegion The non affine sub-region @p PHI is in.\n  /// @param IsExitBlock        Flag to indicate that @p PHI is in the exit BB.\n  void buildPHIAccesses(ScopStmt *PHIStmt, PHINode *PHI,\n                        Region *NonAffineSubRegion, bool IsExitBlock = false);\n\n  /// Build the access functions for the subregion @p SR.\n  void buildAccessFunctions();\n\n  /// Should an instruction be modeled in a ScopStmt.\n  ///\n  /// @param Inst The instruction to check.\n  /// @param L    The loop in which context the instruction is looked at.\n  ///\n  /// @returns True if the instruction should be modeled.\n  bool shouldModelInst(Instruction *Inst, Loop *L);\n\n  /// Create one or more ScopStmts for @p BB.\n  ///\n  /// Consecutive instructions are associated to the same statement until a\n  /// separator is found.\n  void buildSequentialBlockStmts(BasicBlock *BB, bool SplitOnStore = false);\n\n  /// Create one or more ScopStmts for @p BB using equivalence classes.\n  ///\n  /// Instructions of a basic block that belong to the same equivalence class\n  /// are added to the same statement.\n  void buildEqivClassBlockStmts(BasicBlock *BB);\n\n  /// Create ScopStmt for all BBs and non-affine subregions of @p SR.\n  ///\n  /// @param SR A subregion of @p R.\n  ///\n  /// Some of the statements might be optimized away later when they do not\n  /// access any memory and thus have no effect.\n  void buildStmts(Region &SR);\n\n  /// Build the access functions for the statement @p Stmt in or represented by\n  /// @p BB.\n  ///\n  /// @param Stmt               Statement to add MemoryAccesses to.\n  /// @param BB                 A basic block in @p R.\n  /// @param NonAffineSubRegion The non affine sub-region @p BB is in.\n  void buildAccessFunctions(ScopStmt *Stmt, BasicBlock &BB,\n                            Region *NonAffineSubRegion = nullptr);\n\n  /// Create a new MemoryAccess object and add it to #AccFuncMap.\n  ///\n  /// @param Stmt        The statement where the access takes place.\n  /// @param Inst        The instruction doing the access. It is not necessarily\n  ///                    inside @p BB.\n  /// @param AccType     The kind of access.\n  /// @param BaseAddress The accessed array's base address.\n  /// @param ElemType    The type of the accessed array elements.\n  /// @param Affine      Whether all subscripts are affine expressions.\n  /// @param AccessValue Value read or written.\n  /// @param Subscripts  Access subscripts per dimension.\n  /// @param Sizes       The array dimension's sizes.\n  /// @param Kind        The kind of memory accessed.\n  ///\n  /// @return The created MemoryAccess, or nullptr if the access is not within\n  ///         the SCoP.\n  MemoryAccess *addMemoryAccess(ScopStmt *Stmt, Instruction *Inst,\n                                MemoryAccess::AccessType AccType,\n                                Value *BaseAddress, Type *ElemType, bool Affine,\n                                Value *AccessValue,\n                                ArrayRef<const SCEV *> Subscripts,\n                                ArrayRef<const SCEV *> Sizes, MemoryKind Kind);\n\n  /// Create a MemoryAccess that represents either a LoadInst or\n  /// StoreInst.\n  ///\n  /// @param Stmt        The statement to add the MemoryAccess to.\n  /// @param MemAccInst  The LoadInst or StoreInst.\n  /// @param AccType     The kind of access.\n  /// @param BaseAddress The accessed array's base address.\n  /// @param ElemType    The type of the accessed array elements.\n  /// @param IsAffine    Whether all subscripts are affine expressions.\n  /// @param Subscripts  Access subscripts per dimension.\n  /// @param Sizes       The array dimension's sizes.\n  /// @param AccessValue Value read or written.\n  ///\n  /// @see MemoryKind\n  void addArrayAccess(ScopStmt *Stmt, MemAccInst MemAccInst,\n                      MemoryAccess::AccessType AccType, Value *BaseAddress,\n                      Type *ElemType, bool IsAffine,\n                      ArrayRef<const SCEV *> Subscripts,\n                      ArrayRef<const SCEV *> Sizes, Value *AccessValue);\n\n  /// Create a MemoryAccess for writing an llvm::Instruction.\n  ///\n  /// The access will be created at the position of @p Inst.\n  ///\n  /// @param Inst The instruction to be written.\n  ///\n  /// @see ensureValueRead()\n  /// @see MemoryKind\n  void ensureValueWrite(Instruction *Inst);\n\n  /// Ensure an llvm::Value is available in the BB's statement, creating a\n  /// MemoryAccess for reloading it if necessary.\n  ///\n  /// @param V        The value expected to be loaded.\n  /// @param UserStmt Where to reload the value.\n  ///\n  /// @see ensureValueStore()\n  /// @see MemoryKind\n  void ensureValueRead(Value *V, ScopStmt *UserStmt);\n\n  /// Create a write MemoryAccess for the incoming block of a phi node.\n  ///\n  /// Each of the incoming blocks write their incoming value to be picked in the\n  /// phi's block.\n  ///\n  /// @param PHI           PHINode under consideration.\n  /// @param IncomingStmt  The statement to add the MemoryAccess to.\n  /// @param IncomingBlock Some predecessor block.\n  /// @param IncomingValue @p PHI's value when coming from @p IncomingBlock.\n  /// @param IsExitBlock   When true, uses the .s2a alloca instead of the\n  ///                      .phiops one. Required for values escaping through a\n  ///                      PHINode in the SCoP region's exit block.\n  /// @see addPHIReadAccess()\n  /// @see MemoryKind\n  void ensurePHIWrite(PHINode *PHI, ScopStmt *IncomintStmt,\n                      BasicBlock *IncomingBlock, Value *IncomingValue,\n                      bool IsExitBlock);\n\n  /// Add user provided parameter constraints to context (command line).\n  void addUserContext();\n\n  /// Add user provided parameter constraints to context (source code).\n  void addUserAssumptions(AssumptionCache &AC,\n                          DenseMap<BasicBlock *, isl::set> &InvalidDomainMap);\n\n  /// Add all recorded assumptions to the assumed context.\n  void addRecordedAssumptions();\n\n  /// Create a MemoryAccess for reading the value of a phi.\n  ///\n  /// The modeling assumes that all incoming blocks write their incoming value\n  /// to the same location. Thus, this access will read the incoming block's\n  /// value as instructed by this @p PHI.\n  ///\n  /// @param PHIStmt Statement @p PHI resides in.\n  /// @param PHI     PHINode under consideration; the READ access will be added\n  ///                here.\n  ///\n  /// @see ensurePHIWrite()\n  /// @see MemoryKind\n  void addPHIReadAccess(ScopStmt *PHIStmt, PHINode *PHI);\n\n  /// Wrapper function to calculate minimal/maximal accesses to each array.\n  bool calculateMinMaxAccess(AliasGroupTy AliasGroup,\n                             Scop::MinMaxVectorTy &MinMaxAccesses);\n  /// Build the domain of @p Stmt.\n  void buildDomain(ScopStmt &Stmt);\n\n  /// Fill NestLoops with loops surrounding @p Stmt.\n  void collectSurroundingLoops(ScopStmt &Stmt);\n\n  /// Check for reductions in @p Stmt.\n  ///\n  /// Iterate over all store memory accesses and check for valid binary\n  /// reduction like chains. For all candidates we check if they have the same\n  /// base address and there are no other accesses which overlap with them. The\n  /// base address check rules out impossible reductions candidates early. The\n  /// overlap check, together with the \"only one user\" check in\n  /// collectCandidateReductionLoads, guarantees that none of the intermediate\n  /// results will escape during execution of the loop nest. We basically check\n  /// here that no other memory access can access the same memory as the\n  /// potential reduction.\n  void checkForReductions(ScopStmt &Stmt);\n\n  /// Verify that all required invariant loads have been hoisted.\n  ///\n  /// Invariant load hoisting is not guaranteed to hoist all loads that were\n  /// assumed to be scop invariant during scop detection. This function checks\n  /// for cases where the hoisting failed, but where it would have been\n  /// necessary for our scop modeling to be correct. In case of insufficient\n  /// hoisting the scop is marked as invalid.\n  ///\n  /// In the example below Bound[1] is required to be invariant:\n  ///\n  /// for (int i = 1; i < Bound[0]; i++)\n  ///   for (int j = 1; j < Bound[1]; j++)\n  ///     ...\n  void verifyInvariantLoads();\n\n  /// Hoist invariant memory loads and check for required ones.\n  ///\n  /// We first identify \"common\" invariant loads, thus loads that are invariant\n  /// and can be hoisted. Then we check if all required invariant loads have\n  /// been identified as (common) invariant. A load is a required invariant load\n  /// if it was assumed to be invariant during SCoP detection, e.g., to assume\n  /// loop bounds to be affine or runtime alias checks to be placeable. In case\n  /// a required invariant load was not identified as (common) invariant we will\n  /// drop this SCoP. An example for both \"common\" as well as required invariant\n  /// loads is given below:\n  ///\n  /// for (int i = 1; i < *LB[0]; i++)\n  ///   for (int j = 1; j < *LB[1]; j++)\n  ///     A[i][j] += A[0][0] + (*V);\n  ///\n  /// Common inv. loads: V, A[0][0], LB[0], LB[1]\n  /// Required inv. loads: LB[0], LB[1], (V, if it may alias with A or LB)\n  void hoistInvariantLoads();\n\n  /// Add invariant loads listed in @p InvMAs with the domain of @p Stmt.\n  void addInvariantLoads(ScopStmt &Stmt, InvariantAccessesTy &InvMAs);\n\n  /// Check if @p MA can always be hoisted without execution context.\n  bool canAlwaysBeHoisted(MemoryAccess *MA, bool StmtInvalidCtxIsEmpty,\n                          bool MAInvalidCtxIsEmpty,\n                          bool NonHoistableCtxIsEmpty);\n\n  /// Return true if and only if @p LI is a required invariant load.\n  bool isRequiredInvariantLoad(LoadInst *LI) const {\n    return scop->getRequiredInvariantLoads().count(LI);\n  }\n\n  /// Check if the base ptr of @p MA is in the SCoP but not hoistable.\n  bool hasNonHoistableBasePtrInScop(MemoryAccess *MA, isl::union_map Writes);\n\n  /// Return the context under which the access cannot be hoisted.\n  ///\n  /// @param Access The access to check.\n  /// @param Writes The set of all memory writes in the scop.\n  ///\n  /// @return Return the context under which the access cannot be hoisted or a\n  ///         nullptr if it cannot be hoisted at all.\n  isl::set getNonHoistableCtx(MemoryAccess *Access, isl::union_map Writes);\n\n  /// Collect loads which might form a reduction chain with @p StoreMA.\n  ///\n  /// Check if the stored value for @p StoreMA is a binary operator with one or\n  /// two loads as operands. If the binary operand is commutative & associative,\n  /// used only once (by @p StoreMA) and its load operands are also used only\n  /// once, we have found a possible reduction chain. It starts at an operand\n  /// load and includes the binary operator and @p StoreMA.\n  ///\n  /// Note: We allow only one use to ensure the load and binary operator cannot\n  ///       escape this block or into any other store except @p StoreMA.\n  void collectCandidateReductionLoads(MemoryAccess *StoreMA,\n                                      SmallVectorImpl<MemoryAccess *> &Loads);\n\n  /// Build the access relation of all memory accesses of @p Stmt.\n  void buildAccessRelations(ScopStmt &Stmt);\n\n  /// Canonicalize arrays with base pointers from the same equivalence class.\n  ///\n  /// Some context: in our normal model we assume that each base pointer is\n  /// related to a single specific memory region, where memory regions\n  /// associated with different base pointers are disjoint. Consequently we do\n  /// not need to compute additional data dependences that model possible\n  /// overlaps of these memory regions. To verify our assumption we compute\n  /// alias checks that verify that modeled arrays indeed do not overlap. In\n  /// case an overlap is detected the runtime check fails and we fall back to\n  /// the original code.\n  ///\n  /// In case of arrays where the base pointers are know to be identical,\n  /// because they are dynamically loaded by accesses that are in the same\n  /// invariant load equivalence class, such run-time alias check would always\n  /// be false.\n  ///\n  /// This function makes sure that we do not generate consistently failing\n  /// run-time checks for code that contains distinct arrays with known\n  /// equivalent base pointers. It identifies for each invariant load\n  /// equivalence class a single canonical array and canonicalizes all memory\n  /// accesses that reference arrays that have base pointers that are known to\n  /// be equal to the base pointer of such a canonical array to this canonical\n  /// array.\n  ///\n  /// We currently do not canonicalize arrays for which certain memory accesses\n  /// have been hoisted as loop invariant.\n  void canonicalizeDynamicBasePtrs();\n\n  /// Construct the schedule of this SCoP.\n  void buildSchedule();\n\n  /// A loop stack element to keep track of per-loop information during\n  ///        schedule construction.\n  using LoopStackElementTy = struct LoopStackElement {\n    // The loop for which we keep information.\n    Loop *L;\n\n    // The (possibly incomplete) schedule for this loop.\n    isl::schedule Schedule;\n\n    // The number of basic blocks in the current loop, for which a schedule has\n    // already been constructed.\n    unsigned NumBlocksProcessed;\n\n    LoopStackElement(Loop *L, isl::schedule S, unsigned NumBlocksProcessed)\n        : L(L), Schedule(S), NumBlocksProcessed(NumBlocksProcessed) {}\n  };\n\n  /// The loop stack used for schedule construction.\n  ///\n  /// The loop stack keeps track of schedule information for a set of nested\n  /// loops as well as an (optional) 'nullptr' loop that models the outermost\n  /// schedule dimension. The loops in a loop stack always have a parent-child\n  /// relation where the loop at position n is the parent of the loop at\n  /// position n + 1.\n  using LoopStackTy = SmallVector<LoopStackElementTy, 4>;\n\n  /// Construct schedule information for a given Region and add the\n  ///        derived information to @p LoopStack.\n  ///\n  /// Given a Region we derive schedule information for all RegionNodes\n  /// contained in this region ensuring that the assigned execution times\n  /// correctly model the existing control flow relations.\n  ///\n  /// @param R              The region which to process.\n  /// @param LoopStack      A stack of loops that are currently under\n  ///                       construction.\n  void buildSchedule(Region *R, LoopStackTy &LoopStack);\n\n  /// Build Schedule for the region node @p RN and add the derived\n  ///        information to @p LoopStack.\n  ///\n  /// In case @p RN is a BasicBlock or a non-affine Region, we construct the\n  /// schedule for this @p RN and also finalize loop schedules in case the\n  /// current @p RN completes the loop.\n  ///\n  /// In case @p RN is a not-non-affine Region, we delegate the construction to\n  /// buildSchedule(Region *R, ...).\n  ///\n  /// @param RN             The RegionNode region traversed.\n  /// @param LoopStack      A stack of loops that are currently under\n  ///                       construction.\n  void buildSchedule(RegionNode *RN, LoopStackTy &LoopStack);\n\npublic:\n  explicit ScopBuilder(Region *R, AssumptionCache &AC, AAResults &AA,\n                       const DataLayout &DL, DominatorTree &DT, LoopInfo &LI,\n                       ScopDetection &SD, ScalarEvolution &SE,\n                       OptimizationRemarkEmitter &ORE);\n  ScopBuilder(const ScopBuilder &) = delete;\n  ScopBuilder &operator=(const ScopBuilder &) = delete;\n  ~ScopBuilder() = default;\n\n  /// Try to build the Polly IR of static control part on the current\n  /// SESE-Region.\n  ///\n  /// @return Give up the ownership of the scop object or static control part\n  ///         for the region\n  std::unique_ptr<Scop> getScop() { return std::move(scop); }\n};\n} // end namespace polly\n\n#endif // POLLY_SCOPBUILDER_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopBuilder.cpp", "content": "//===- ScopBuilder.cpp ----------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Create a polyhedral description for a static control flow region.\n//\n// The pass creates a polyhedral description of the Scops detected by the SCoP\n// detection derived from their LLVM-IR code.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"polly/ScopBuilder.h\"\n#include \"polly/Options.h\"\n#include \"polly/ScopDetection.h\"\n#include \"polly/ScopInfo.h\"\n#include \"polly/Support/GICHelper.h\"\n#include \"polly/Support/ISLTools.h\"\n#include \"polly/Support/SCEVValidator.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"polly/Support/VirtualInstruction.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/EquivalenceClasses.h\"\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/ADT/Sequence.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/Loads.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n#include \"llvm/Analysis/RegionInfo.h\"\n#include \"llvm/Analysis/RegionIterator.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n\nusing namespace llvm;\nusing namespace polly;\n\n#define DEBUG_TYPE \"polly-scops\"\n\nSTATISTIC(ScopFound, \"Number of valid Scops\");\nSTATISTIC(RichScopFound, \"Number of Scops containing a loop\");\nSTATISTIC(InfeasibleScops,\n          \"Number of SCoPs with statically infeasible context.\");\n\nbool polly::ModelReadOnlyScalars;\n\n// The maximal number of dimensions we allow during invariant load construction.\n// More complex access ranges will result in very high compile time and are also\n// unlikely to result in good code. This value is very high and should only\n// trigger for corner cases (e.g., the \"dct_luma\" function in h264, SPEC2006).\nstatic int const MaxDimensionsInAccessRange = 9;\n\nstatic cl::opt<bool, true> XModelReadOnlyScalars(\n    \"polly-analyze-read-only-scalars\",\n    cl::desc(\"Model read-only scalar values in the scop description\"),\n    cl::location(ModelReadOnlyScalars), cl::Hidden, cl::ZeroOrMore,\n    cl::init(true), cl::cat(PollyCategory));\n\nstatic cl::opt<int>\n    OptComputeOut(\"polly-analysis-computeout\",\n                  cl::desc(\"Bound the scop analysis by a maximal amount of \"\n                           \"computational steps (0 means no bound)\"),\n                  cl::Hidden, cl::init(800000), cl::ZeroOrMore,\n                  cl::cat(PollyCategory));\n\nstatic cl::opt<bool> PollyAllowDereferenceOfAllFunctionParams(\n    \"polly-allow-dereference-of-all-function-parameters\",\n    cl::desc(\n        \"Treat all parameters to functions that are pointers as dereferencible.\"\n        \" This is useful for invariant load hoisting, since we can generate\"\n        \" less runtime checks. This is only valid if all pointers to functions\"\n        \" are always initialized, so that Polly can choose to hoist\"\n        \" their loads. \"),\n    cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<bool>\n    PollyIgnoreInbounds(\"polly-ignore-inbounds\",\n                        cl::desc(\"Do not take inbounds assumptions at all\"),\n                        cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<unsigned> RunTimeChecksMaxArraysPerGroup(\n    \"polly-rtc-max-arrays-per-group\",\n    cl::desc(\"The maximal number of arrays to compare in each alias group.\"),\n    cl::Hidden, cl::ZeroOrMore, cl::init(20), cl::cat(PollyCategory));\n\nstatic cl::opt<int> RunTimeChecksMaxAccessDisjuncts(\n    \"polly-rtc-max-array-disjuncts\",\n    cl::desc(\"The maximal number of disjunts allowed in memory accesses to \"\n             \"to build RTCs.\"),\n    cl::Hidden, cl::ZeroOrMore, cl::init(8), cl::cat(PollyCategory));\n\nstatic cl::opt<unsigned> RunTimeChecksMaxParameters(\n    \"polly-rtc-max-parameters\",\n    cl::desc(\"The maximal number of parameters allowed in RTCs.\"), cl::Hidden,\n    cl::ZeroOrMore, cl::init(8), cl::cat(PollyCategory));\n\nstatic cl::opt<bool> UnprofitableScalarAccs(\n    \"polly-unprofitable-scalar-accs\",\n    cl::desc(\"Count statements with scalar accesses as not optimizable\"),\n    cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<std::string> UserContextStr(\n    \"polly-context\", cl::value_desc(\"isl parameter set\"),\n    cl::desc(\"Provide additional constraints on the context parameters\"),\n    cl::init(\"\"), cl::cat(PollyCategory));\n\nstatic cl::opt<bool> DetectFortranArrays(\n    \"polly-detect-fortran-arrays\",\n    cl::desc(\"Detect Fortran arrays and use this for code generation\"),\n    cl::Hidden, cl::init(false), cl::cat(PollyCategory));\n\nstatic cl::opt<bool> DetectReductions(\"polly-detect-reductions\",\n                                      cl::desc(\"Detect and exploit reductions\"),\n                                      cl::Hidden, cl::ZeroOrMore,\n                                      cl::init(true), cl::cat(PollyCategory));\n\n// Multiplicative reductions can be disabled separately as these kind of\n// operations can overflow easily. Additive reductions and bit operations\n// are in contrast pretty stable.\nstatic cl::opt<bool> DisableMultiplicativeReductions(\n    \"polly-disable-multiplicative-reductions\",\n    cl::desc(\"Disable multiplicative reductions\"), cl::Hidden, cl::ZeroOrMore,\n    cl::init(false), cl::cat(PollyCategory));\n\nenum class GranularityChoice { BasicBlocks, ScalarIndependence, Stores };\n\nstatic cl::opt<GranularityChoice> StmtGranularity(\n    \"polly-stmt-granularity\",\n    cl::desc(\n        \"Algorithm to use for splitting basic blocks into multiple statements\"),\n    cl::values(clEnumValN(GranularityChoice::BasicBlocks, \"bb\",\n                          \"One statement per basic block\"),\n               clEnumValN(GranularityChoice::ScalarIndependence, \"scalar-indep\",\n                          \"Scalar independence heuristic\"),\n               clEnumValN(GranularityChoice::Stores, \"store\",\n                          \"Store-level granularity\")),\n    cl::init(GranularityChoice::ScalarIndependence), cl::cat(PollyCategory));\n\n/// Helper to treat non-affine regions and basic blocks the same.\n///\n///{\n\n/// Return the block that is the representing block for @p RN.\nstatic inline BasicBlock *getRegionNodeBasicBlock(RegionNode *RN) {\n  return RN->isSubRegion() ? RN->getNodeAs<Region>()->getEntry()\n                           : RN->getNodeAs<BasicBlock>();\n}\n\n/// Return the @p idx'th block that is executed after @p RN.\nstatic inline BasicBlock *\ngetRegionNodeSuccessor(RegionNode *RN, Instruction *TI, unsigned idx) {\n  if (RN->isSubRegion()) {\n    assert(idx == 0);\n    return RN->getNodeAs<Region>()->getExit();\n  }\n  return TI->getSuccessor(idx);\n}\n\nstatic bool containsErrorBlock(RegionNode *RN, const Region &R, LoopInfo &LI,\n                               const DominatorTree &DT) {\n  if (!RN->isSubRegion())\n    return isErrorBlock(*RN->getNodeAs<BasicBlock>(), R, LI, DT);\n  for (BasicBlock *BB : RN->getNodeAs<Region>()->blocks())\n    if (isErrorBlock(*BB, R, LI, DT))\n      return true;\n  return false;\n}\n\n///}\n\n/// Create a map to map from a given iteration to a subsequent iteration.\n///\n/// This map maps from SetSpace -> SetSpace where the dimensions @p Dim\n/// is incremented by one and all other dimensions are equal, e.g.,\n///             [i0, i1, i2, i3] -> [i0, i1, i2 + 1, i3]\n///\n/// if @p Dim is 2 and @p SetSpace has 4 dimensions.\nstatic isl::map createNextIterationMap(isl::space SetSpace, unsigned Dim) {\n  isl::space MapSpace = SetSpace.map_from_set();\n  isl::map NextIterationMap = isl::map::universe(MapSpace);\n  for (auto u : seq<isl_size>(0, NextIterationMap.dim(isl::dim::in)))\n    if (u != (isl_size)Dim)\n      NextIterationMap =\n          NextIterationMap.equate(isl::dim::in, u, isl::dim::out, u);\n  isl::constraint C =\n      isl::constraint::alloc_equality(isl::local_space(MapSpace));\n  C = C.set_constant_si(1);\n  C = C.set_coefficient_si(isl::dim::in, Dim, 1);\n  C = C.set_coefficient_si(isl::dim::out, Dim, -1);\n  NextIterationMap = NextIterationMap.add_constraint(C);\n  return NextIterationMap;\n}\n\n/// Add @p BSet to set @p BoundedParts if @p BSet is bounded.\nstatic isl::set collectBoundedParts(isl::set S) {\n  isl::set BoundedParts = isl::set::empty(S.get_space());\n  for (isl::basic_set BSet : S.get_basic_set_list())\n    if (BSet.is_bounded())\n      BoundedParts = BoundedParts.unite(isl::set(BSet));\n  return BoundedParts;\n}\n\n/// Compute the (un)bounded parts of @p S wrt. to dimension @p Dim.\n///\n/// @returns A separation of @p S into first an unbounded then a bounded subset,\n///          both with regards to the dimension @p Dim.\nstatic std::pair<isl::set, isl::set> partitionSetParts(isl::set S,\n                                                       unsigned Dim) {\n  for (unsigned u = 0, e = S.n_dim(); u < e; u++)\n    S = S.lower_bound_si(isl::dim::set, u, 0);\n\n  unsigned NumDimsS = S.n_dim();\n  isl::set OnlyDimS = S;\n\n  // Remove dimensions that are greater than Dim as they are not interesting.\n  assert(NumDimsS >= Dim + 1);\n  OnlyDimS = OnlyDimS.project_out(isl::dim::set, Dim + 1, NumDimsS - Dim - 1);\n\n  // Create artificial parametric upper bounds for dimensions smaller than Dim\n  // as we are not interested in them.\n  OnlyDimS = OnlyDimS.insert_dims(isl::dim::param, 0, Dim);\n\n  for (unsigned u = 0; u < Dim; u++) {\n    isl::constraint C = isl::constraint::alloc_inequality(\n        isl::local_space(OnlyDimS.get_space()));\n    C = C.set_coefficient_si(isl::dim::param, u, 1);\n    C = C.set_coefficient_si(isl::dim::set, u, -1);\n    OnlyDimS = OnlyDimS.add_constraint(C);\n  }\n\n  // Collect all bounded parts of OnlyDimS.\n  isl::set BoundedParts = collectBoundedParts(OnlyDimS);\n\n  // Create the dimensions greater than Dim again.\n  BoundedParts =\n      BoundedParts.insert_dims(isl::dim::set, Dim + 1, NumDimsS - Dim - 1);\n\n  // Remove the artificial upper bound parameters again.\n  BoundedParts = BoundedParts.remove_dims(isl::dim::param, 0, Dim);\n\n  isl::set UnboundedParts = S.subtract(BoundedParts);\n  return std::make_pair(UnboundedParts, BoundedParts);\n}\n\n/// Create the conditions under which @p L @p Pred @p R is true.\nstatic isl::set buildConditionSet(ICmpInst::Predicate Pred, isl::pw_aff L,\n                                  isl::pw_aff R) {\n  switch (Pred) {\n  case ICmpInst::ICMP_EQ:\n    return L.eq_set(R);\n  case ICmpInst::ICMP_NE:\n    return L.ne_set(R);\n  case ICmpInst::ICMP_SLT:\n    return L.lt_set(R);\n  case ICmpInst::ICMP_SLE:\n    return L.le_set(R);\n  case ICmpInst::ICMP_SGT:\n    return L.gt_set(R);\n  case ICmpInst::ICMP_SGE:\n    return L.ge_set(R);\n  case ICmpInst::ICMP_ULT:\n    return L.lt_set(R);\n  case ICmpInst::ICMP_UGT:\n    return L.gt_set(R);\n  case ICmpInst::ICMP_ULE:\n    return L.le_set(R);\n  case ICmpInst::ICMP_UGE:\n    return L.ge_set(R);\n  default:\n    llvm_unreachable(\"Non integer predicate not supported\");\n  }\n}\n\nisl::set ScopBuilder::adjustDomainDimensions(isl::set Dom, Loop *OldL,\n                                             Loop *NewL) {\n  // If the loops are the same there is nothing to do.\n  if (NewL == OldL)\n    return Dom;\n\n  int OldDepth = scop->getRelativeLoopDepth(OldL);\n  int NewDepth = scop->getRelativeLoopDepth(NewL);\n  // If both loops are non-affine loops there is nothing to do.\n  if (OldDepth == -1 && NewDepth == -1)\n    return Dom;\n\n  // Distinguish three cases:\n  //   1) The depth is the same but the loops are not.\n  //      => One loop was left one was entered.\n  //   2) The depth increased from OldL to NewL.\n  //      => One loop was entered, none was left.\n  //   3) The depth decreased from OldL to NewL.\n  //      => Loops were left were difference of the depths defines how many.\n  if (OldDepth == NewDepth) {\n    assert(OldL->getParentLoop() == NewL->getParentLoop());\n    Dom = Dom.project_out(isl::dim::set, NewDepth, 1);\n    Dom = Dom.add_dims(isl::dim::set, 1);\n  } else if (OldDepth < NewDepth) {\n    assert(OldDepth + 1 == NewDepth);\n    auto &R = scop->getRegion();\n    (void)R;\n    assert(NewL->getParentLoop() == OldL ||\n           ((!OldL || !R.contains(OldL)) && R.contains(NewL)));\n    Dom = Dom.add_dims(isl::dim::set, 1);\n  } else {\n    assert(OldDepth > NewDepth);\n    int Diff = OldDepth - NewDepth;\n    int NumDim = Dom.n_dim();\n    assert(NumDim >= Diff);\n    Dom = Dom.project_out(isl::dim::set, NumDim - Diff, Diff);\n  }\n\n  return Dom;\n}\n\n/// Compute the isl representation for the SCEV @p E in this BB.\n///\n/// @param BB               The BB for which isl representation is to be\n/// computed.\n/// @param InvalidDomainMap A map of BB to their invalid domains.\n/// @param E                The SCEV that should be translated.\n/// @param NonNegative      Flag to indicate the @p E has to be non-negative.\n///\n/// Note that this function will also adjust the invalid context accordingly.\n\n__isl_give isl_pw_aff *\nScopBuilder::getPwAff(BasicBlock *BB,\n                      DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n                      const SCEV *E, bool NonNegative) {\n  PWACtx PWAC = scop->getPwAff(E, BB, NonNegative, &RecordedAssumptions);\n  InvalidDomainMap[BB] = InvalidDomainMap[BB].unite(PWAC.second);\n  return PWAC.first.release();\n}\n\n/// Build condition sets for unsigned ICmpInst(s).\n/// Special handling is required for unsigned operands to ensure that if\n/// MSB (aka the Sign bit) is set for an operands in an unsigned ICmpInst\n/// it should wrap around.\n///\n/// @param IsStrictUpperBound holds information on the predicate relation\n/// between TestVal and UpperBound, i.e,\n/// TestVal < UpperBound  OR  TestVal <= UpperBound\n__isl_give isl_set *ScopBuilder::buildUnsignedConditionSets(\n    BasicBlock *BB, Value *Condition, __isl_keep isl_set *Domain,\n    const SCEV *SCEV_TestVal, const SCEV *SCEV_UpperBound,\n    DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n    bool IsStrictUpperBound) {\n  // Do not take NonNeg assumption on TestVal\n  // as it might have MSB (Sign bit) set.\n  isl_pw_aff *TestVal = getPwAff(BB, InvalidDomainMap, SCEV_TestVal, false);\n  // Take NonNeg assumption on UpperBound.\n  isl_pw_aff *UpperBound =\n      getPwAff(BB, InvalidDomainMap, SCEV_UpperBound, true);\n\n  // 0 <= TestVal\n  isl_set *First =\n      isl_pw_aff_le_set(isl_pw_aff_zero_on_domain(isl_local_space_from_space(\n                            isl_pw_aff_get_domain_space(TestVal))),\n                        isl_pw_aff_copy(TestVal));\n\n  isl_set *Second;\n  if (IsStrictUpperBound)\n    // TestVal < UpperBound\n    Second = isl_pw_aff_lt_set(TestVal, UpperBound);\n  else\n    // TestVal <= UpperBound\n    Second = isl_pw_aff_le_set(TestVal, UpperBound);\n\n  isl_set *ConsequenceCondSet = isl_set_intersect(First, Second);\n  return ConsequenceCondSet;\n}\n\nbool ScopBuilder::buildConditionSets(\n    BasicBlock *BB, SwitchInst *SI, Loop *L, __isl_keep isl_set *Domain,\n    DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n    SmallVectorImpl<__isl_give isl_set *> &ConditionSets) {\n  Value *Condition = getConditionFromTerminator(SI);\n  assert(Condition && \"No condition for switch\");\n\n  isl_pw_aff *LHS, *RHS;\n  LHS = getPwAff(BB, InvalidDomainMap, SE.getSCEVAtScope(Condition, L));\n\n  unsigned NumSuccessors = SI->getNumSuccessors();\n  ConditionSets.resize(NumSuccessors);\n  for (auto &Case : SI->cases()) {\n    unsigned Idx = Case.getSuccessorIndex();\n    ConstantInt *CaseValue = Case.getCaseValue();\n\n    RHS = getPwAff(BB, InvalidDomainMap, SE.getSCEV(CaseValue));\n    isl_set *CaseConditionSet =\n        buildConditionSet(ICmpInst::ICMP_EQ, isl::manage_copy(LHS),\n                          isl::manage(RHS))\n            .release();\n    ConditionSets[Idx] = isl_set_coalesce(\n        isl_set_intersect(CaseConditionSet, isl_set_copy(Domain)));\n  }\n\n  assert(ConditionSets[0] == nullptr && \"Default condition set was set\");\n  isl_set *ConditionSetUnion = isl_set_copy(ConditionSets[1]);\n  for (unsigned u = 2; u < NumSuccessors; u++)\n    ConditionSetUnion =\n        isl_set_union(ConditionSetUnion, isl_set_copy(ConditionSets[u]));\n  ConditionSets[0] = isl_set_subtract(isl_set_copy(Domain), ConditionSetUnion);\n\n  isl_pw_aff_free(LHS);\n\n  return true;\n}\n\nbool ScopBuilder::buildConditionSets(\n    BasicBlock *BB, Value *Condition, Instruction *TI, Loop *L,\n    __isl_keep isl_set *Domain,\n    DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n    SmallVectorImpl<__isl_give isl_set *> &ConditionSets) {\n  isl_set *ConsequenceCondSet = nullptr;\n\n  if (auto Load = dyn_cast<LoadInst>(Condition)) {\n    const SCEV *LHSSCEV = SE.getSCEVAtScope(Load, L);\n    const SCEV *RHSSCEV = SE.getZero(LHSSCEV->getType());\n    bool NonNeg = false;\n    isl_pw_aff *LHS = getPwAff(BB, InvalidDomainMap, LHSSCEV, NonNeg);\n    isl_pw_aff *RHS = getPwAff(BB, InvalidDomainMap, RHSSCEV, NonNeg);\n    ConsequenceCondSet = buildConditionSet(ICmpInst::ICMP_SLE, isl::manage(LHS),\n                                           isl::manage(RHS))\n                             .release();\n  } else if (auto *PHI = dyn_cast<PHINode>(Condition)) {\n    auto *Unique = dyn_cast<ConstantInt>(\n        getUniqueNonErrorValue(PHI, &scop->getRegion(), LI, DT));\n\n    if (Unique->isZero())\n      ConsequenceCondSet = isl_set_empty(isl_set_get_space(Domain));\n    else\n      ConsequenceCondSet = isl_set_universe(isl_set_get_space(Domain));\n  } else if (auto *CCond = dyn_cast<ConstantInt>(Condition)) {\n    if (CCond->isZero())\n      ConsequenceCondSet = isl_set_empty(isl_set_get_space(Domain));\n    else\n      ConsequenceCondSet = isl_set_universe(isl_set_get_space(Domain));\n  } else if (BinaryOperator *BinOp = dyn_cast<BinaryOperator>(Condition)) {\n    auto Opcode = BinOp->getOpcode();\n    assert(Opcode == Instruction::And || Opcode == Instruction::Or);\n\n    bool Valid = buildConditionSets(BB, BinOp->getOperand(0), TI, L, Domain,\n                                    InvalidDomainMap, ConditionSets) &&\n                 buildConditionSets(BB, BinOp->getOperand(1), TI, L, Domain,\n                                    InvalidDomainMap, ConditionSets);\n    if (!Valid) {\n      while (!ConditionSets.empty())\n        isl_set_free(ConditionSets.pop_back_val());\n      return false;\n    }\n\n    isl_set_free(ConditionSets.pop_back_val());\n    isl_set *ConsCondPart0 = ConditionSets.pop_back_val();\n    isl_set_free(ConditionSets.pop_back_val());\n    isl_set *ConsCondPart1 = ConditionSets.pop_back_val();\n\n    if (Opcode == Instruction::And)\n      ConsequenceCondSet = isl_set_intersect(ConsCondPart0, ConsCondPart1);\n    else\n      ConsequenceCondSet = isl_set_union(ConsCondPart0, ConsCondPart1);\n  } else {\n    auto *ICond = dyn_cast<ICmpInst>(Condition);\n    assert(ICond &&\n           \"Condition of exiting branch was neither constant nor ICmp!\");\n\n    Region &R = scop->getRegion();\n\n    isl_pw_aff *LHS, *RHS;\n    // For unsigned comparisons we assumed the signed bit of neither operand\n    // to be set. The comparison is equal to a signed comparison under this\n    // assumption.\n    bool NonNeg = ICond->isUnsigned();\n    const SCEV *LeftOperand = SE.getSCEVAtScope(ICond->getOperand(0), L),\n               *RightOperand = SE.getSCEVAtScope(ICond->getOperand(1), L);\n\n    LeftOperand = tryForwardThroughPHI(LeftOperand, R, SE, LI, DT);\n    RightOperand = tryForwardThroughPHI(RightOperand, R, SE, LI, DT);\n\n    switch (ICond->getPredicate()) {\n    case ICmpInst::ICMP_ULT:\n      ConsequenceCondSet =\n          buildUnsignedConditionSets(BB, Condition, Domain, LeftOperand,\n                                     RightOperand, InvalidDomainMap, true);\n      break;\n    case ICmpInst::ICMP_ULE:\n      ConsequenceCondSet =\n          buildUnsignedConditionSets(BB, Condition, Domain, LeftOperand,\n                                     RightOperand, InvalidDomainMap, false);\n      break;\n    case ICmpInst::ICMP_UGT:\n      ConsequenceCondSet =\n          buildUnsignedConditionSets(BB, Condition, Domain, RightOperand,\n                                     LeftOperand, InvalidDomainMap, true);\n      break;\n    case ICmpInst::ICMP_UGE:\n      ConsequenceCondSet =\n          buildUnsignedConditionSets(BB, Condition, Domain, RightOperand,\n                                     LeftOperand, InvalidDomainMap, false);\n      break;\n    default:\n      LHS = getPwAff(BB, InvalidDomainMap, LeftOperand, NonNeg);\n      RHS = getPwAff(BB, InvalidDomainMap, RightOperand, NonNeg);\n      ConsequenceCondSet = buildConditionSet(ICond->getPredicate(),\n                                             isl::manage(LHS), isl::manage(RHS))\n                               .release();\n      break;\n    }\n  }\n\n  // If no terminator was given we are only looking for parameter constraints\n  // under which @p Condition is true/false.\n  if (!TI)\n    ConsequenceCondSet = isl_set_params(ConsequenceCondSet);\n  assert(ConsequenceCondSet);\n  ConsequenceCondSet = isl_set_coalesce(\n      isl_set_intersect(ConsequenceCondSet, isl_set_copy(Domain)));\n\n  isl_set *AlternativeCondSet = nullptr;\n  bool TooComplex =\n      isl_set_n_basic_set(ConsequenceCondSet) >= MaxDisjunctsInDomain;\n\n  if (!TooComplex) {\n    AlternativeCondSet = isl_set_subtract(isl_set_copy(Domain),\n                                          isl_set_copy(ConsequenceCondSet));\n    TooComplex =\n        isl_set_n_basic_set(AlternativeCondSet) >= MaxDisjunctsInDomain;\n  }\n\n  if (TooComplex) {\n    scop->invalidate(COMPLEXITY, TI ? TI->getDebugLoc() : DebugLoc(),\n                     TI ? TI->getParent() : nullptr /* BasicBlock */);\n    isl_set_free(AlternativeCondSet);\n    isl_set_free(ConsequenceCondSet);\n    return false;\n  }\n\n  ConditionSets.push_back(ConsequenceCondSet);\n  ConditionSets.push_back(isl_set_coalesce(AlternativeCondSet));\n\n  return true;\n}\n\nbool ScopBuilder::buildConditionSets(\n    BasicBlock *BB, Instruction *TI, Loop *L, __isl_keep isl_set *Domain,\n    DenseMap<BasicBlock *, isl::set> &InvalidDomainMap,\n    SmallVectorImpl<__isl_give isl_set *> &ConditionSets) {\n  if (SwitchInst *SI = dyn_cast<SwitchInst>(TI))\n    return buildConditionSets(BB, SI, L, Domain, InvalidDomainMap,\n                              ConditionSets);\n\n  assert(isa<BranchInst>(TI) && \"Terminator was neither branch nor switch.\");\n\n  if (TI->getNumSuccessors() == 1) {\n    ConditionSets.push_back(isl_set_copy(Domain));\n    return true;\n  }\n\n  Value *Condition = getConditionFromTerminator(TI);\n  assert(Condition && \"No condition for Terminator\");\n\n  return buildConditionSets(BB, Condition, TI, L, Domain, InvalidDomainMap,\n                            ConditionSets);\n}\n\nbool ScopBuilder::propagateDomainConstraints(\n    Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  // Iterate over the region R and propagate the domain constrains from the\n  // predecessors to the current node. In contrast to the\n  // buildDomainsWithBranchConstraints function, this one will pull the domain\n  // information from the predecessors instead of pushing it to the successors.\n  // Additionally, we assume the domains to be already present in the domain\n  // map here. However, we iterate again in reverse post order so we know all\n  // predecessors have been visited before a block or non-affine subregion is\n  // visited.\n\n  ReversePostOrderTraversal<Region *> RTraversal(R);\n  for (auto *RN : RTraversal) {\n    // Recurse for affine subregions but go on for basic blocks and non-affine\n    // subregions.\n    if (RN->isSubRegion()) {\n      Region *SubRegion = RN->getNodeAs<Region>();\n      if (!scop->isNonAffineSubRegion(SubRegion)) {\n        if (!propagateDomainConstraints(SubRegion, InvalidDomainMap))\n          return false;\n        continue;\n      }\n    }\n\n    BasicBlock *BB = getRegionNodeBasicBlock(RN);\n    isl::set &Domain = scop->getOrInitEmptyDomain(BB);\n    assert(Domain);\n\n    // Under the union of all predecessor conditions we can reach this block.\n    isl::set PredDom = getPredecessorDomainConstraints(BB, Domain);\n    Domain = Domain.intersect(PredDom).coalesce();\n    Domain = Domain.align_params(scop->getParamSpace());\n\n    Loop *BBLoop = getRegionNodeLoop(RN, LI);\n    if (BBLoop && BBLoop->getHeader() == BB && scop->contains(BBLoop))\n      if (!addLoopBoundsToHeaderDomain(BBLoop, InvalidDomainMap))\n        return false;\n  }\n\n  return true;\n}\n\nvoid ScopBuilder::propagateDomainConstraintsToRegionExit(\n    BasicBlock *BB, Loop *BBLoop,\n    SmallPtrSetImpl<BasicBlock *> &FinishedExitBlocks,\n    DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  // Check if the block @p BB is the entry of a region. If so we propagate it's\n  // domain to the exit block of the region. Otherwise we are done.\n  auto *RI = scop->getRegion().getRegionInfo();\n  auto *BBReg = RI ? RI->getRegionFor(BB) : nullptr;\n  auto *ExitBB = BBReg ? BBReg->getExit() : nullptr;\n  if (!BBReg || BBReg->getEntry() != BB || !scop->contains(ExitBB))\n    return;\n\n  // Do not propagate the domain if there is a loop backedge inside the region\n  // that would prevent the exit block from being executed.\n  auto *L = BBLoop;\n  while (L && scop->contains(L)) {\n    SmallVector<BasicBlock *, 4> LatchBBs;\n    BBLoop->getLoopLatches(LatchBBs);\n    for (auto *LatchBB : LatchBBs)\n      if (BB != LatchBB && BBReg->contains(LatchBB))\n        return;\n    L = L->getParentLoop();\n  }\n\n  isl::set Domain = scop->getOrInitEmptyDomain(BB);\n  assert(Domain && \"Cannot propagate a nullptr\");\n\n  Loop *ExitBBLoop = getFirstNonBoxedLoopFor(ExitBB, LI, scop->getBoxedLoops());\n\n  // Since the dimensions of @p BB and @p ExitBB might be different we have to\n  // adjust the domain before we can propagate it.\n  isl::set AdjustedDomain = adjustDomainDimensions(Domain, BBLoop, ExitBBLoop);\n  isl::set &ExitDomain = scop->getOrInitEmptyDomain(ExitBB);\n\n  // If the exit domain is not yet created we set it otherwise we \"add\" the\n  // current domain.\n  ExitDomain = ExitDomain ? AdjustedDomain.unite(ExitDomain) : AdjustedDomain;\n\n  // Initialize the invalid domain.\n  InvalidDomainMap[ExitBB] = ExitDomain.empty(ExitDomain.get_space());\n\n  FinishedExitBlocks.insert(ExitBB);\n}\n\nisl::set ScopBuilder::getPredecessorDomainConstraints(BasicBlock *BB,\n                                                      isl::set Domain) {\n  // If @p BB is the ScopEntry we are done\n  if (scop->getRegion().getEntry() == BB)\n    return isl::set::universe(Domain.get_space());\n\n  // The region info of this function.\n  auto &RI = *scop->getRegion().getRegionInfo();\n\n  Loop *BBLoop = getFirstNonBoxedLoopFor(BB, LI, scop->getBoxedLoops());\n\n  // A domain to collect all predecessor domains, thus all conditions under\n  // which the block is executed. To this end we start with the empty domain.\n  isl::set PredDom = isl::set::empty(Domain.get_space());\n\n  // Set of regions of which the entry block domain has been propagated to BB.\n  // all predecessors inside any of the regions can be skipped.\n  SmallSet<Region *, 8> PropagatedRegions;\n\n  for (auto *PredBB : predecessors(BB)) {\n    // Skip backedges.\n    if (DT.dominates(BB, PredBB))\n      continue;\n\n    // If the predecessor is in a region we used for propagation we can skip it.\n    auto PredBBInRegion = [PredBB](Region *PR) { return PR->contains(PredBB); };\n    if (std::any_of(PropagatedRegions.begin(), PropagatedRegions.end(),\n                    PredBBInRegion)) {\n      continue;\n    }\n\n    // Check if there is a valid region we can use for propagation, thus look\n    // for a region that contains the predecessor and has @p BB as exit block.\n    auto *PredR = RI.getRegionFor(PredBB);\n    while (PredR->getExit() != BB && !PredR->contains(BB))\n      PredR->getParent();\n\n    // If a valid region for propagation was found use the entry of that region\n    // for propagation, otherwise the PredBB directly.\n    if (PredR->getExit() == BB) {\n      PredBB = PredR->getEntry();\n      PropagatedRegions.insert(PredR);\n    }\n\n    isl::set PredBBDom = scop->getDomainConditions(PredBB);\n    Loop *PredBBLoop =\n        getFirstNonBoxedLoopFor(PredBB, LI, scop->getBoxedLoops());\n    PredBBDom = adjustDomainDimensions(PredBBDom, PredBBLoop, BBLoop);\n    PredDom = PredDom.unite(PredBBDom);\n  }\n\n  return PredDom;\n}\n\nbool ScopBuilder::addLoopBoundsToHeaderDomain(\n    Loop *L, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  int LoopDepth = scop->getRelativeLoopDepth(L);\n  assert(LoopDepth >= 0 && \"Loop in region should have at least depth one\");\n\n  BasicBlock *HeaderBB = L->getHeader();\n  assert(scop->isDomainDefined(HeaderBB));\n  isl::set &HeaderBBDom = scop->getOrInitEmptyDomain(HeaderBB);\n\n  isl::map NextIterationMap =\n      createNextIterationMap(HeaderBBDom.get_space(), LoopDepth);\n\n  isl::set UnionBackedgeCondition = HeaderBBDom.empty(HeaderBBDom.get_space());\n\n  SmallVector<BasicBlock *, 4> LatchBlocks;\n  L->getLoopLatches(LatchBlocks);\n\n  for (BasicBlock *LatchBB : LatchBlocks) {\n    // If the latch is only reachable via error statements we skip it.\n    if (!scop->isDomainDefined(LatchBB))\n      continue;\n\n    isl::set LatchBBDom = scop->getDomainConditions(LatchBB);\n\n    isl::set BackedgeCondition = nullptr;\n\n    Instruction *TI = LatchBB->getTerminator();\n    BranchInst *BI = dyn_cast<BranchInst>(TI);\n    assert(BI && \"Only branch instructions allowed in loop latches\");\n\n    if (BI->isUnconditional())\n      BackedgeCondition = LatchBBDom;\n    else {\n      SmallVector<isl_set *, 8> ConditionSets;\n      int idx = BI->getSuccessor(0) != HeaderBB;\n      if (!buildConditionSets(LatchBB, TI, L, LatchBBDom.get(),\n                              InvalidDomainMap, ConditionSets))\n        return false;\n\n      // Free the non back edge condition set as we do not need it.\n      isl_set_free(ConditionSets[1 - idx]);\n\n      BackedgeCondition = isl::manage(ConditionSets[idx]);\n    }\n\n    int LatchLoopDepth = scop->getRelativeLoopDepth(LI.getLoopFor(LatchBB));\n    assert(LatchLoopDepth >= LoopDepth);\n    BackedgeCondition = BackedgeCondition.project_out(\n        isl::dim::set, LoopDepth + 1, LatchLoopDepth - LoopDepth);\n    UnionBackedgeCondition = UnionBackedgeCondition.unite(BackedgeCondition);\n  }\n\n  isl::map ForwardMap = ForwardMap.lex_le(HeaderBBDom.get_space());\n  for (int i = 0; i < LoopDepth; i++)\n    ForwardMap = ForwardMap.equate(isl::dim::in, i, isl::dim::out, i);\n\n  isl::set UnionBackedgeConditionComplement =\n      UnionBackedgeCondition.complement();\n  UnionBackedgeConditionComplement =\n      UnionBackedgeConditionComplement.lower_bound_si(isl::dim::set, LoopDepth,\n                                                      0);\n  UnionBackedgeConditionComplement =\n      UnionBackedgeConditionComplement.apply(ForwardMap);\n  HeaderBBDom = HeaderBBDom.subtract(UnionBackedgeConditionComplement);\n  HeaderBBDom = HeaderBBDom.apply(NextIterationMap);\n\n  auto Parts = partitionSetParts(HeaderBBDom, LoopDepth);\n  HeaderBBDom = Parts.second;\n\n  // Check if there is a <nsw> tagged AddRec for this loop and if so do not\n  // require a runtime check. The assumption is already implied by the <nsw>\n  // tag.\n  bool RequiresRTC = !scop->hasNSWAddRecForLoop(L);\n\n  isl::set UnboundedCtx = Parts.first.params();\n  recordAssumption(&RecordedAssumptions, INFINITELOOP, UnboundedCtx,\n                   HeaderBB->getTerminator()->getDebugLoc(), AS_RESTRICTION,\n                   nullptr, RequiresRTC);\n  return true;\n}\n\nvoid ScopBuilder::buildInvariantEquivalenceClasses() {\n  DenseMap<std::pair<const SCEV *, Type *>, LoadInst *> EquivClasses;\n\n  const InvariantLoadsSetTy &RIL = scop->getRequiredInvariantLoads();\n  for (LoadInst *LInst : RIL) {\n    const SCEV *PointerSCEV = SE.getSCEV(LInst->getPointerOperand());\n\n    Type *Ty = LInst->getType();\n    LoadInst *&ClassRep = EquivClasses[std::make_pair(PointerSCEV, Ty)];\n    if (ClassRep) {\n      scop->addInvariantLoadMapping(LInst, ClassRep);\n      continue;\n    }\n\n    ClassRep = LInst;\n    scop->addInvariantEquivClass(\n        InvariantEquivClassTy{PointerSCEV, MemoryAccessList(), nullptr, Ty});\n  }\n}\n\nbool ScopBuilder::buildDomains(\n    Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  bool IsOnlyNonAffineRegion = scop->isNonAffineSubRegion(R);\n  auto *EntryBB = R->getEntry();\n  auto *L = IsOnlyNonAffineRegion ? nullptr : LI.getLoopFor(EntryBB);\n  int LD = scop->getRelativeLoopDepth(L);\n  auto *S =\n      isl_set_universe(isl_space_set_alloc(scop->getIslCtx().get(), 0, LD + 1));\n\n  InvalidDomainMap[EntryBB] = isl::manage(isl_set_empty(isl_set_get_space(S)));\n  isl::noexceptions::set Domain = isl::manage(S);\n  scop->setDomain(EntryBB, Domain);\n\n  if (IsOnlyNonAffineRegion)\n    return !containsErrorBlock(R->getNode(), *R, LI, DT);\n\n  if (!buildDomainsWithBranchConstraints(R, InvalidDomainMap))\n    return false;\n\n  if (!propagateDomainConstraints(R, InvalidDomainMap))\n    return false;\n\n  // Error blocks and blocks dominated by them have been assumed to never be\n  // executed. Representing them in the Scop does not add any value. In fact,\n  // it is likely to cause issues during construction of the ScopStmts. The\n  // contents of error blocks have not been verified to be expressible and\n  // will cause problems when building up a ScopStmt for them.\n  // Furthermore, basic blocks dominated by error blocks may reference\n  // instructions in the error block which, if the error block is not modeled,\n  // can themselves not be constructed properly. To this end we will replace\n  // the domains of error blocks and those only reachable via error blocks\n  // with an empty set. Additionally, we will record for each block under which\n  // parameter combination it would be reached via an error block in its\n  // InvalidDomain. This information is needed during load hoisting.\n  if (!propagateInvalidStmtDomains(R, InvalidDomainMap))\n    return false;\n\n  return true;\n}\n\nbool ScopBuilder::buildDomainsWithBranchConstraints(\n    Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  // To create the domain for each block in R we iterate over all blocks and\n  // subregions in R and propagate the conditions under which the current region\n  // element is executed. To this end we iterate in reverse post order over R as\n  // it ensures that we first visit all predecessors of a region node (either a\n  // basic block or a subregion) before we visit the region node itself.\n  // Initially, only the domain for the SCoP region entry block is set and from\n  // there we propagate the current domain to all successors, however we add the\n  // condition that the successor is actually executed next.\n  // As we are only interested in non-loop carried constraints here we can\n  // simply skip loop back edges.\n\n  SmallPtrSet<BasicBlock *, 8> FinishedExitBlocks;\n  ReversePostOrderTraversal<Region *> RTraversal(R);\n  for (auto *RN : RTraversal) {\n    // Recurse for affine subregions but go on for basic blocks and non-affine\n    // subregions.\n    if (RN->isSubRegion()) {\n      Region *SubRegion = RN->getNodeAs<Region>();\n      if (!scop->isNonAffineSubRegion(SubRegion)) {\n        if (!buildDomainsWithBranchConstraints(SubRegion, InvalidDomainMap))\n          return false;\n        continue;\n      }\n    }\n\n    if (containsErrorBlock(RN, scop->getRegion(), LI, DT))\n      scop->notifyErrorBlock();\n    ;\n\n    BasicBlock *BB = getRegionNodeBasicBlock(RN);\n    Instruction *TI = BB->getTerminator();\n\n    if (isa<UnreachableInst>(TI))\n      continue;\n\n    if (!scop->isDomainDefined(BB))\n      continue;\n    isl::set Domain = scop->getDomainConditions(BB);\n\n    scop->updateMaxLoopDepth(isl_set_n_dim(Domain.get()));\n\n    auto *BBLoop = getRegionNodeLoop(RN, LI);\n    // Propagate the domain from BB directly to blocks that have a superset\n    // domain, at the moment only region exit nodes of regions that start in BB.\n    propagateDomainConstraintsToRegionExit(BB, BBLoop, FinishedExitBlocks,\n                                           InvalidDomainMap);\n\n    // If all successors of BB have been set a domain through the propagation\n    // above we do not need to build condition sets but can just skip this\n    // block. However, it is important to note that this is a local property\n    // with regards to the region @p R. To this end FinishedExitBlocks is a\n    // local variable.\n    auto IsFinishedRegionExit = [&FinishedExitBlocks](BasicBlock *SuccBB) {\n      return FinishedExitBlocks.count(SuccBB);\n    };\n    if (std::all_of(succ_begin(BB), succ_end(BB), IsFinishedRegionExit))\n      continue;\n\n    // Build the condition sets for the successor nodes of the current region\n    // node. If it is a non-affine subregion we will always execute the single\n    // exit node, hence the single entry node domain is the condition set. For\n    // basic blocks we use the helper function buildConditionSets.\n    SmallVector<isl_set *, 8> ConditionSets;\n    if (RN->isSubRegion())\n      ConditionSets.push_back(Domain.copy());\n    else if (!buildConditionSets(BB, TI, BBLoop, Domain.get(), InvalidDomainMap,\n                                 ConditionSets))\n      return false;\n\n    // Now iterate over the successors and set their initial domain based on\n    // their condition set. We skip back edges here and have to be careful when\n    // we leave a loop not to keep constraints over a dimension that doesn't\n    // exist anymore.\n    assert(RN->isSubRegion() || TI->getNumSuccessors() == ConditionSets.size());\n    for (unsigned u = 0, e = ConditionSets.size(); u < e; u++) {\n      isl::set CondSet = isl::manage(ConditionSets[u]);\n      BasicBlock *SuccBB = getRegionNodeSuccessor(RN, TI, u);\n\n      // Skip blocks outside the region.\n      if (!scop->contains(SuccBB))\n        continue;\n\n      // If we propagate the domain of some block to \"SuccBB\" we do not have to\n      // adjust the domain.\n      if (FinishedExitBlocks.count(SuccBB))\n        continue;\n\n      // Skip back edges.\n      if (DT.dominates(SuccBB, BB))\n        continue;\n\n      Loop *SuccBBLoop =\n          getFirstNonBoxedLoopFor(SuccBB, LI, scop->getBoxedLoops());\n\n      CondSet = adjustDomainDimensions(CondSet, BBLoop, SuccBBLoop);\n\n      // Set the domain for the successor or merge it with an existing domain in\n      // case there are multiple paths (without loop back edges) to the\n      // successor block.\n      isl::set &SuccDomain = scop->getOrInitEmptyDomain(SuccBB);\n\n      if (SuccDomain) {\n        SuccDomain = SuccDomain.unite(CondSet).coalesce();\n      } else {\n        // Initialize the invalid domain.\n        InvalidDomainMap[SuccBB] = CondSet.empty(CondSet.get_space());\n        SuccDomain = CondSet;\n      }\n\n      SuccDomain = SuccDomain.detect_equalities();\n\n      // Check if the maximal number of domain disjunctions was reached.\n      // In case this happens we will clean up and bail.\n      if (SuccDomain.n_basic_set() < MaxDisjunctsInDomain)\n        continue;\n\n      scop->invalidate(COMPLEXITY, DebugLoc());\n      while (++u < ConditionSets.size())\n        isl_set_free(ConditionSets[u]);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool ScopBuilder::propagateInvalidStmtDomains(\n    Region *R, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  ReversePostOrderTraversal<Region *> RTraversal(R);\n  for (auto *RN : RTraversal) {\n\n    // Recurse for affine subregions but go on for basic blocks and non-affine\n    // subregions.\n    if (RN->isSubRegion()) {\n      Region *SubRegion = RN->getNodeAs<Region>();\n      if (!scop->isNonAffineSubRegion(SubRegion)) {\n        propagateInvalidStmtDomains(SubRegion, InvalidDomainMap);\n        continue;\n      }\n    }\n\n    bool ContainsErrorBlock = containsErrorBlock(RN, scop->getRegion(), LI, DT);\n    BasicBlock *BB = getRegionNodeBasicBlock(RN);\n    isl::set &Domain = scop->getOrInitEmptyDomain(BB);\n    assert(Domain && \"Cannot propagate a nullptr\");\n\n    isl::set InvalidDomain = InvalidDomainMap[BB];\n\n    bool IsInvalidBlock = ContainsErrorBlock || Domain.is_subset(InvalidDomain);\n\n    if (!IsInvalidBlock) {\n      InvalidDomain = InvalidDomain.intersect(Domain);\n    } else {\n      InvalidDomain = Domain;\n      isl::set DomPar = Domain.params();\n      recordAssumption(&RecordedAssumptions, ERRORBLOCK, DomPar,\n                       BB->getTerminator()->getDebugLoc(), AS_RESTRICTION);\n      Domain = isl::set::empty(Domain.get_space());\n    }\n\n    if (InvalidDomain.is_empty()) {\n      InvalidDomainMap[BB] = InvalidDomain;\n      continue;\n    }\n\n    auto *BBLoop = getRegionNodeLoop(RN, LI);\n    auto *TI = BB->getTerminator();\n    unsigned NumSuccs = RN->isSubRegion() ? 1 : TI->getNumSuccessors();\n    for (unsigned u = 0; u < NumSuccs; u++) {\n      auto *SuccBB = getRegionNodeSuccessor(RN, TI, u);\n\n      // Skip successors outside the SCoP.\n      if (!scop->contains(SuccBB))\n        continue;\n\n      // Skip backedges.\n      if (DT.dominates(SuccBB, BB))\n        continue;\n\n      Loop *SuccBBLoop =\n          getFirstNonBoxedLoopFor(SuccBB, LI, scop->getBoxedLoops());\n\n      auto AdjustedInvalidDomain =\n          adjustDomainDimensions(InvalidDomain, BBLoop, SuccBBLoop);\n\n      isl::set SuccInvalidDomain = InvalidDomainMap[SuccBB];\n      SuccInvalidDomain = SuccInvalidDomain.unite(AdjustedInvalidDomain);\n      SuccInvalidDomain = SuccInvalidDomain.coalesce();\n\n      InvalidDomainMap[SuccBB] = SuccInvalidDomain;\n\n      // Check if the maximal number of domain disjunctions was reached.\n      // In case this happens we will bail.\n      if (SuccInvalidDomain.n_basic_set() < MaxDisjunctsInDomain)\n        continue;\n\n      InvalidDomainMap.erase(BB);\n      scop->invalidate(COMPLEXITY, TI->getDebugLoc(), TI->getParent());\n      return false;\n    }\n\n    InvalidDomainMap[BB] = InvalidDomain;\n  }\n\n  return true;\n}\n\nvoid ScopBuilder::buildPHIAccesses(ScopStmt *PHIStmt, PHINode *PHI,\n                                   Region *NonAffineSubRegion,\n                                   bool IsExitBlock) {\n  // PHI nodes that are in the exit block of the region, hence if IsExitBlock is\n  // true, are not modeled as ordinary PHI nodes as they are not part of the\n  // region. However, we model the operands in the predecessor blocks that are\n  // part of the region as regular scalar accesses.\n\n  // If we can synthesize a PHI we can skip it, however only if it is in\n  // the region. If it is not it can only be in the exit block of the region.\n  // In this case we model the operands but not the PHI itself.\n  auto *Scope = LI.getLoopFor(PHI->getParent());\n  if (!IsExitBlock && canSynthesize(PHI, *scop, &SE, Scope))\n    return;\n\n  // PHI nodes are modeled as if they had been demoted prior to the SCoP\n  // detection. Hence, the PHI is a load of a new memory location in which the\n  // incoming value was written at the end of the incoming basic block.\n  bool OnlyNonAffineSubRegionOperands = true;\n  for (unsigned u = 0; u < PHI->getNumIncomingValues(); u++) {\n    Value *Op = PHI->getIncomingValue(u);\n    BasicBlock *OpBB = PHI->getIncomingBlock(u);\n    ScopStmt *OpStmt = scop->getIncomingStmtFor(PHI->getOperandUse(u));\n\n    // Do not build PHI dependences inside a non-affine subregion, but make\n    // sure that the necessary scalar values are still made available.\n    if (NonAffineSubRegion && NonAffineSubRegion->contains(OpBB)) {\n      auto *OpInst = dyn_cast<Instruction>(Op);\n      if (!OpInst || !NonAffineSubRegion->contains(OpInst))\n        ensureValueRead(Op, OpStmt);\n      continue;\n    }\n\n    OnlyNonAffineSubRegionOperands = false;\n    ensurePHIWrite(PHI, OpStmt, OpBB, Op, IsExitBlock);\n  }\n\n  if (!OnlyNonAffineSubRegionOperands && !IsExitBlock) {\n    addPHIReadAccess(PHIStmt, PHI);\n  }\n}\n\nvoid ScopBuilder::buildScalarDependences(ScopStmt *UserStmt,\n                                         Instruction *Inst) {\n  assert(!isa<PHINode>(Inst));\n\n  // Pull-in required operands.\n  for (Use &Op : Inst->operands())\n    ensureValueRead(Op.get(), UserStmt);\n}\n\n// Create a sequence of two schedules. Either argument may be null and is\n// interpreted as the empty schedule. Can also return null if both schedules are\n// empty.\nstatic isl::schedule combineInSequence(isl::schedule Prev, isl::schedule Succ) {\n  if (!Prev)\n    return Succ;\n  if (!Succ)\n    return Prev;\n\n  return Prev.sequence(Succ);\n}\n\n// Create an isl_multi_union_aff that defines an identity mapping from the\n// elements of USet to their N-th dimension.\n//\n// # Example:\n//\n//            Domain: { A[i,j]; B[i,j,k] }\n//                 N: 1\n//\n// Resulting Mapping: { {A[i,j] -> [(j)]; B[i,j,k] -> [(j)] }\n//\n// @param USet   A union set describing the elements for which to generate a\n//               mapping.\n// @param N      The dimension to map to.\n// @returns      A mapping from USet to its N-th dimension.\nstatic isl::multi_union_pw_aff mapToDimension(isl::union_set USet, int N) {\n  assert(N >= 0);\n  assert(USet);\n  assert(!USet.is_empty());\n\n  auto Result = isl::union_pw_multi_aff::empty(USet.get_space());\n\n  for (isl::set S : USet.get_set_list()) {\n    int Dim = S.dim(isl::dim::set);\n    auto PMA = isl::pw_multi_aff::project_out_map(S.get_space(), isl::dim::set,\n                                                  N, Dim - N);\n    if (N > 1)\n      PMA = PMA.drop_dims(isl::dim::out, 0, N - 1);\n\n    Result = Result.add_pw_multi_aff(PMA);\n  }\n\n  return isl::multi_union_pw_aff(isl::union_pw_multi_aff(Result));\n}\n\nvoid ScopBuilder::buildSchedule() {\n  Loop *L = getLoopSurroundingScop(*scop, LI);\n  LoopStackTy LoopStack({LoopStackElementTy(L, nullptr, 0)});\n  buildSchedule(scop->getRegion().getNode(), LoopStack);\n  assert(LoopStack.size() == 1 && LoopStack.back().L == L);\n  scop->setScheduleTree(LoopStack[0].Schedule);\n}\n\n/// To generate a schedule for the elements in a Region we traverse the Region\n/// in reverse-post-order and add the contained RegionNodes in traversal order\n/// to the schedule of the loop that is currently at the top of the LoopStack.\n/// For loop-free codes, this results in a correct sequential ordering.\n///\n/// Example:\n///           bb1(0)\n///         /     \\.\n///      bb2(1)   bb3(2)\n///         \\    /  \\.\n///          bb4(3)  bb5(4)\n///             \\   /\n///              bb6(5)\n///\n/// Including loops requires additional processing. Whenever a loop header is\n/// encountered, the corresponding loop is added to the @p LoopStack. Starting\n/// from an empty schedule, we first process all RegionNodes that are within\n/// this loop and complete the sequential schedule at this loop-level before\n/// processing about any other nodes. To implement this\n/// loop-nodes-first-processing, the reverse post-order traversal is\n/// insufficient. Hence, we additionally check if the traversal yields\n/// sub-regions or blocks that are outside the last loop on the @p LoopStack.\n/// These region-nodes are then queue and only traverse after the all nodes\n/// within the current loop have been processed.\nvoid ScopBuilder::buildSchedule(Region *R, LoopStackTy &LoopStack) {\n  Loop *OuterScopLoop = getLoopSurroundingScop(*scop, LI);\n\n  ReversePostOrderTraversal<Region *> RTraversal(R);\n  std::deque<RegionNode *> WorkList(RTraversal.begin(), RTraversal.end());\n  std::deque<RegionNode *> DelayList;\n  bool LastRNWaiting = false;\n\n  // Iterate over the region @p R in reverse post-order but queue\n  // sub-regions/blocks iff they are not part of the last encountered but not\n  // completely traversed loop. The variable LastRNWaiting is a flag to indicate\n  // that we queued the last sub-region/block from the reverse post-order\n  // iterator. If it is set we have to explore the next sub-region/block from\n  // the iterator (if any) to guarantee progress. If it is not set we first try\n  // the next queued sub-region/blocks.\n  while (!WorkList.empty() || !DelayList.empty()) {\n    RegionNode *RN;\n\n    if ((LastRNWaiting && !WorkList.empty()) || DelayList.empty()) {\n      RN = WorkList.front();\n      WorkList.pop_front();\n      LastRNWaiting = false;\n    } else {\n      RN = DelayList.front();\n      DelayList.pop_front();\n    }\n\n    Loop *L = getRegionNodeLoop(RN, LI);\n    if (!scop->contains(L))\n      L = OuterScopLoop;\n\n    Loop *LastLoop = LoopStack.back().L;\n    if (LastLoop != L) {\n      if (LastLoop && !LastLoop->contains(L)) {\n        LastRNWaiting = true;\n        DelayList.push_back(RN);\n        continue;\n      }\n      LoopStack.push_back({L, nullptr, 0});\n    }\n    buildSchedule(RN, LoopStack);\n  }\n}\n\nvoid ScopBuilder::buildSchedule(RegionNode *RN, LoopStackTy &LoopStack) {\n  if (RN->isSubRegion()) {\n    auto *LocalRegion = RN->getNodeAs<Region>();\n    if (!scop->isNonAffineSubRegion(LocalRegion)) {\n      buildSchedule(LocalRegion, LoopStack);\n      return;\n    }\n  }\n\n  assert(LoopStack.rbegin() != LoopStack.rend());\n  auto LoopData = LoopStack.rbegin();\n  LoopData->NumBlocksProcessed += getNumBlocksInRegionNode(RN);\n\n  for (auto *Stmt : scop->getStmtListFor(RN)) {\n    isl::union_set UDomain{Stmt->getDomain()};\n    auto StmtSchedule = isl::schedule::from_domain(UDomain);\n    LoopData->Schedule = combineInSequence(LoopData->Schedule, StmtSchedule);\n  }\n\n  // Check if we just processed the last node in this loop. If we did, finalize\n  // the loop by:\n  //\n  //   - adding new schedule dimensions\n  //   - folding the resulting schedule into the parent loop schedule\n  //   - dropping the loop schedule from the LoopStack.\n  //\n  // Then continue to check surrounding loops, which might also have been\n  // completed by this node.\n  size_t Dimension = LoopStack.size();\n  while (LoopData->L &&\n         LoopData->NumBlocksProcessed == getNumBlocksInLoop(LoopData->L)) {\n    isl::schedule Schedule = LoopData->Schedule;\n    auto NumBlocksProcessed = LoopData->NumBlocksProcessed;\n\n    assert(std::next(LoopData) != LoopStack.rend());\n    ++LoopData;\n    --Dimension;\n\n    if (Schedule) {\n      isl::union_set Domain = Schedule.get_domain();\n      isl::multi_union_pw_aff MUPA = mapToDimension(Domain, Dimension);\n      Schedule = Schedule.insert_partial_schedule(MUPA);\n      LoopData->Schedule = combineInSequence(LoopData->Schedule, Schedule);\n    }\n\n    LoopData->NumBlocksProcessed += NumBlocksProcessed;\n  }\n  // Now pop all loops processed up there from the LoopStack\n  LoopStack.erase(LoopStack.begin() + Dimension, LoopStack.end());\n}\n\nvoid ScopBuilder::buildEscapingDependences(Instruction *Inst) {\n  // Check for uses of this instruction outside the scop. Because we do not\n  // iterate over such instructions and therefore did not \"ensure\" the existence\n  // of a write, we must determine such use here.\n  if (scop->isEscaping(Inst))\n    ensureValueWrite(Inst);\n}\n\n/// Check that a value is a Fortran Array descriptor.\n///\n/// We check if V has the following structure:\n/// %\"struct.array1_real(kind=8)\" = type { i8*, i<zz>, i<zz>,\n///                                   [<num> x %struct.descriptor_dimension] }\n///\n///\n/// %struct.descriptor_dimension = type { i<zz>, i<zz>, i<zz> }\n///\n/// 1. V's type name starts with \"struct.array\"\n/// 2. V's type has layout as shown.\n/// 3. Final member of V's type has name \"struct.descriptor_dimension\",\n/// 4. \"struct.descriptor_dimension\" has layout as shown.\n/// 5. Consistent use of i<zz> where <zz> is some fixed integer number.\n///\n/// We are interested in such types since this is the code that dragonegg\n/// generates for Fortran array descriptors.\n///\n/// @param V the Value to be checked.\n///\n/// @returns True if V is a Fortran array descriptor, False otherwise.\nbool isFortranArrayDescriptor(Value *V) {\n  PointerType *PTy = dyn_cast<PointerType>(V->getType());\n\n  if (!PTy)\n    return false;\n\n  Type *Ty = PTy->getElementType();\n  assert(Ty && \"Ty expected to be initialized\");\n  auto *StructArrTy = dyn_cast<StructType>(Ty);\n\n  if (!(StructArrTy && StructArrTy->hasName()))\n    return false;\n\n  if (!StructArrTy->getName().startswith(\"struct.array\"))\n    return false;\n\n  if (StructArrTy->getNumElements() != 4)\n    return false;\n\n  const ArrayRef<Type *> ArrMemberTys = StructArrTy->elements();\n\n  // i8* match\n  if (ArrMemberTys[0] != Type::getInt8PtrTy(V->getContext()))\n    return false;\n\n  // Get a reference to the int type and check that all the members\n  // share the same int type\n  Type *IntTy = ArrMemberTys[1];\n  if (ArrMemberTys[2] != IntTy)\n    return false;\n\n  // type: [<num> x %struct.descriptor_dimension]\n  ArrayType *DescriptorDimArrayTy = dyn_cast<ArrayType>(ArrMemberTys[3]);\n  if (!DescriptorDimArrayTy)\n    return false;\n\n  // type: %struct.descriptor_dimension := type { ixx, ixx, ixx }\n  StructType *DescriptorDimTy =\n      dyn_cast<StructType>(DescriptorDimArrayTy->getElementType());\n\n  if (!(DescriptorDimTy && DescriptorDimTy->hasName()))\n    return false;\n\n  if (DescriptorDimTy->getName() != \"struct.descriptor_dimension\")\n    return false;\n\n  if (DescriptorDimTy->getNumElements() != 3)\n    return false;\n\n  for (auto MemberTy : DescriptorDimTy->elements()) {\n    if (MemberTy != IntTy)\n      return false;\n  }\n\n  return true;\n}\n\nValue *ScopBuilder::findFADAllocationVisible(MemAccInst Inst) {\n  // match: 4.1 & 4.2 store/load\n  if (!isa<LoadInst>(Inst) && !isa<StoreInst>(Inst))\n    return nullptr;\n\n  // match: 4\n  if (Inst.getAlignment() != 8)\n    return nullptr;\n\n  Value *Address = Inst.getPointerOperand();\n\n  const BitCastInst *Bitcast = nullptr;\n  // [match: 3]\n  if (auto *Slot = dyn_cast<GetElementPtrInst>(Address)) {\n    Value *TypedMem = Slot->getPointerOperand();\n    // match: 2\n    Bitcast = dyn_cast<BitCastInst>(TypedMem);\n  } else {\n    // match: 2\n    Bitcast = dyn_cast<BitCastInst>(Address);\n  }\n\n  if (!Bitcast)\n    return nullptr;\n\n  auto *MallocMem = Bitcast->getOperand(0);\n\n  // match: 1\n  auto *MallocCall = dyn_cast<CallInst>(MallocMem);\n  if (!MallocCall)\n    return nullptr;\n\n  Function *MallocFn = MallocCall->getCalledFunction();\n  if (!(MallocFn && MallocFn->hasName() && MallocFn->getName() == \"malloc\"))\n    return nullptr;\n\n  // Find all uses the malloc'd memory.\n  // We are looking for a \"store\" into a struct with the type being the Fortran\n  // descriptor type\n  for (auto user : MallocMem->users()) {\n    /// match: 5\n    auto *MallocStore = dyn_cast<StoreInst>(user);\n    if (!MallocStore)\n      continue;\n\n    auto *DescriptorGEP =\n        dyn_cast<GEPOperator>(MallocStore->getPointerOperand());\n    if (!DescriptorGEP)\n      continue;\n\n    // match: 5\n    auto DescriptorType =\n        dyn_cast<StructType>(DescriptorGEP->getSourceElementType());\n    if (!(DescriptorType && DescriptorType->hasName()))\n      continue;\n\n    Value *Descriptor = dyn_cast<Value>(DescriptorGEP->getPointerOperand());\n\n    if (!Descriptor)\n      continue;\n\n    if (!isFortranArrayDescriptor(Descriptor))\n      continue;\n\n    return Descriptor;\n  }\n\n  return nullptr;\n}\n\nValue *ScopBuilder::findFADAllocationInvisible(MemAccInst Inst) {\n  // match: 3\n  if (!isa<LoadInst>(Inst) && !isa<StoreInst>(Inst))\n    return nullptr;\n\n  Value *Slot = Inst.getPointerOperand();\n\n  LoadInst *MemLoad = nullptr;\n  // [match: 2]\n  if (auto *SlotGEP = dyn_cast<GetElementPtrInst>(Slot)) {\n    // match: 1\n    MemLoad = dyn_cast<LoadInst>(SlotGEP->getPointerOperand());\n  } else {\n    // match: 1\n    MemLoad = dyn_cast<LoadInst>(Slot);\n  }\n\n  if (!MemLoad)\n    return nullptr;\n\n  auto *BitcastOperator =\n      dyn_cast<BitCastOperator>(MemLoad->getPointerOperand());\n  if (!BitcastOperator)\n    return nullptr;\n\n  Value *Descriptor = dyn_cast<Value>(BitcastOperator->getOperand(0));\n  if (!Descriptor)\n    return nullptr;\n\n  if (!isFortranArrayDescriptor(Descriptor))\n    return nullptr;\n\n  return Descriptor;\n}\n\nvoid ScopBuilder::addRecordedAssumptions() {\n  for (auto &AS : llvm::reverse(RecordedAssumptions)) {\n\n    if (!AS.BB) {\n      scop->addAssumption(AS.Kind, AS.Set, AS.Loc, AS.Sign,\n                          nullptr /* BasicBlock */, AS.RequiresRTC);\n      continue;\n    }\n\n    // If the domain was deleted the assumptions are void.\n    isl_set *Dom = scop->getDomainConditions(AS.BB).release();\n    if (!Dom)\n      continue;\n\n    // If a basic block was given use its domain to simplify the assumption.\n    // In case of restrictions we know they only have to hold on the domain,\n    // thus we can intersect them with the domain of the block. However, for\n    // assumptions the domain has to imply them, thus:\n    //                     _              _____\n    //   Dom => S   <==>   A v B   <==>   A - B\n    //\n    // To avoid the complement we will register A - B as a restriction not an\n    // assumption.\n    isl_set *S = AS.Set.copy();\n    if (AS.Sign == AS_RESTRICTION)\n      S = isl_set_params(isl_set_intersect(S, Dom));\n    else /* (AS.Sign == AS_ASSUMPTION) */\n      S = isl_set_params(isl_set_subtract(Dom, S));\n\n    scop->addAssumption(AS.Kind, isl::manage(S), AS.Loc, AS_RESTRICTION, AS.BB,\n                        AS.RequiresRTC);\n  }\n}\n\nvoid ScopBuilder::addUserAssumptions(\n    AssumptionCache &AC, DenseMap<BasicBlock *, isl::set> &InvalidDomainMap) {\n  for (auto &Assumption : AC.assumptions()) {\n    auto *CI = dyn_cast_or_null<CallInst>(Assumption);\n    if (!CI || CI->getNumArgOperands() != 1)\n      continue;\n\n    bool InScop = scop->contains(CI);\n    if (!InScop && !scop->isDominatedBy(DT, CI->getParent()))\n      continue;\n\n    auto *L = LI.getLoopFor(CI->getParent());\n    auto *Val = CI->getArgOperand(0);\n    ParameterSetTy DetectedParams;\n    auto &R = scop->getRegion();\n    if (!isAffineConstraint(Val, &R, L, SE, DetectedParams)) {\n      ORE.emit(\n          OptimizationRemarkAnalysis(DEBUG_TYPE, \"IgnoreUserAssumption\", CI)\n          << \"Non-affine user assumption ignored.\");\n      continue;\n    }\n\n    // Collect all newly introduced parameters.\n    ParameterSetTy NewParams;\n    for (auto *Param : DetectedParams) {\n      Param = extractConstantFactor(Param, SE).second;\n      Param = scop->getRepresentingInvariantLoadSCEV(Param);\n      if (scop->isParam(Param))\n        continue;\n      NewParams.insert(Param);\n    }\n\n    SmallVector<isl_set *, 2> ConditionSets;\n    auto *TI = InScop ? CI->getParent()->getTerminator() : nullptr;\n    BasicBlock *BB = InScop ? CI->getParent() : R.getEntry();\n    auto *Dom = InScop ? isl_set_copy(scop->getDomainConditions(BB).get())\n                       : isl_set_copy(scop->getContext().get());\n    assert(Dom && \"Cannot propagate a nullptr.\");\n    bool Valid = buildConditionSets(BB, Val, TI, L, Dom, InvalidDomainMap,\n                                    ConditionSets);\n    isl_set_free(Dom);\n\n    if (!Valid)\n      continue;\n\n    isl_set *AssumptionCtx = nullptr;\n    if (InScop) {\n      AssumptionCtx = isl_set_complement(isl_set_params(ConditionSets[1]));\n      isl_set_free(ConditionSets[0]);\n    } else {\n      AssumptionCtx = isl_set_complement(ConditionSets[1]);\n      AssumptionCtx = isl_set_intersect(AssumptionCtx, ConditionSets[0]);\n    }\n\n    // Project out newly introduced parameters as they are not otherwise useful.\n    if (!NewParams.empty()) {\n      for (isl_size u = 0; u < isl_set_n_param(AssumptionCtx); u++) {\n        auto *Id = isl_set_get_dim_id(AssumptionCtx, isl_dim_param, u);\n        auto *Param = static_cast<const SCEV *>(isl_id_get_user(Id));\n        isl_id_free(Id);\n\n        if (!NewParams.count(Param))\n          continue;\n\n        AssumptionCtx =\n            isl_set_project_out(AssumptionCtx, isl_dim_param, u--, 1);\n      }\n    }\n    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"UserAssumption\", CI)\n             << \"Use user assumption: \" << stringFromIslObj(AssumptionCtx));\n    isl::set newContext =\n        scop->getContext().intersect(isl::manage(AssumptionCtx));\n    scop->setContext(newContext);\n  }\n}\n\nbool ScopBuilder::buildAccessMultiDimFixed(MemAccInst Inst, ScopStmt *Stmt) {\n  Value *Val = Inst.getValueOperand();\n  Type *ElementType = Val->getType();\n  Value *Address = Inst.getPointerOperand();\n  const SCEV *AccessFunction =\n      SE.getSCEVAtScope(Address, LI.getLoopFor(Inst->getParent()));\n  const SCEVUnknown *BasePointer =\n      dyn_cast<SCEVUnknown>(SE.getPointerBase(AccessFunction));\n  enum MemoryAccess::AccessType AccType =\n      isa<LoadInst>(Inst) ? MemoryAccess::READ : MemoryAccess::MUST_WRITE;\n\n  if (auto *BitCast = dyn_cast<BitCastInst>(Address)) {\n    auto *Src = BitCast->getOperand(0);\n    auto *SrcTy = Src->getType();\n    auto *DstTy = BitCast->getType();\n    // Do not try to delinearize non-sized (opaque) pointers.\n    if ((SrcTy->isPointerTy() && !SrcTy->getPointerElementType()->isSized()) ||\n        (DstTy->isPointerTy() && !DstTy->getPointerElementType()->isSized())) {\n      return false;\n    }\n    if (SrcTy->isPointerTy() && DstTy->isPointerTy() &&\n        DL.getTypeAllocSize(SrcTy->getPointerElementType()) ==\n            DL.getTypeAllocSize(DstTy->getPointerElementType()))\n      Address = Src;\n  }\n\n  auto *GEP = dyn_cast<GetElementPtrInst>(Address);\n  if (!GEP)\n    return false;\n\n  SmallVector<const SCEV *, 4> Subscripts;\n  SmallVector<int, 4> Sizes;\n  SE.getIndexExpressionsFromGEP(GEP, Subscripts, Sizes);\n  auto *BasePtr = GEP->getOperand(0);\n\n  if (auto *BasePtrCast = dyn_cast<BitCastInst>(BasePtr))\n    BasePtr = BasePtrCast->getOperand(0);\n\n  // Check for identical base pointers to ensure that we do not miss index\n  // offsets that have been added before this GEP is applied.\n  if (BasePtr != BasePointer->getValue())\n    return false;\n\n  std::vector<const SCEV *> SizesSCEV;\n\n  const InvariantLoadsSetTy &ScopRIL = scop->getRequiredInvariantLoads();\n\n  Loop *SurroundingLoop = Stmt->getSurroundingLoop();\n  for (auto *Subscript : Subscripts) {\n    InvariantLoadsSetTy AccessILS;\n    if (!isAffineExpr(&scop->getRegion(), SurroundingLoop, Subscript, SE,\n                      &AccessILS))\n      return false;\n\n    for (LoadInst *LInst : AccessILS)\n      if (!ScopRIL.count(LInst))\n        return false;\n  }\n\n  if (Sizes.empty())\n    return false;\n\n  SizesSCEV.push_back(nullptr);\n\n  for (auto V : Sizes)\n    SizesSCEV.push_back(SE.getSCEV(\n        ConstantInt::get(IntegerType::getInt64Ty(BasePtr->getContext()), V)));\n\n  addArrayAccess(Stmt, Inst, AccType, BasePointer->getValue(), ElementType,\n                 true, Subscripts, SizesSCEV, Val);\n  return true;\n}\n\nbool ScopBuilder::buildAccessMultiDimParam(MemAccInst Inst, ScopStmt *Stmt) {\n  if (!PollyDelinearize)\n    return false;\n\n  Value *Address = Inst.getPointerOperand();\n  Value *Val = Inst.getValueOperand();\n  Type *ElementType = Val->getType();\n  unsigned ElementSize = DL.getTypeAllocSize(ElementType);\n  enum MemoryAccess::AccessType AccType =\n      isa<LoadInst>(Inst) ? MemoryAccess::READ : MemoryAccess::MUST_WRITE;\n\n  const SCEV *AccessFunction =\n      SE.getSCEVAtScope(Address, LI.getLoopFor(Inst->getParent()));\n  const SCEVUnknown *BasePointer =\n      dyn_cast<SCEVUnknown>(SE.getPointerBase(AccessFunction));\n\n  assert(BasePointer && \"Could not find base pointer\");\n\n  auto &InsnToMemAcc = scop->getInsnToMemAccMap();\n  auto AccItr = InsnToMemAcc.find(Inst);\n  if (AccItr == InsnToMemAcc.end())\n    return false;\n\n  std::vector<const SCEV *> Sizes = {nullptr};\n\n  Sizes.insert(Sizes.end(), AccItr->second.Shape->DelinearizedSizes.begin(),\n               AccItr->second.Shape->DelinearizedSizes.end());\n\n  // In case only the element size is contained in the 'Sizes' array, the\n  // access does not access a real multi-dimensional array. Hence, we allow\n  // the normal single-dimensional access construction to handle this.\n  if (Sizes.size() == 1)\n    return false;\n\n  // Remove the element size. This information is already provided by the\n  // ElementSize parameter. In case the element size of this access and the\n  // element size used for delinearization differs the delinearization is\n  // incorrect. Hence, we invalidate the scop.\n  //\n  // TODO: Handle delinearization with differing element sizes.\n  auto DelinearizedSize =\n      cast<SCEVConstant>(Sizes.back())->getAPInt().getSExtValue();\n  Sizes.pop_back();\n  if (ElementSize != DelinearizedSize)\n    scop->invalidate(DELINEARIZATION, Inst->getDebugLoc(), Inst->getParent());\n\n  addArrayAccess(Stmt, Inst, AccType, BasePointer->getValue(), ElementType,\n                 true, AccItr->second.DelinearizedSubscripts, Sizes, Val);\n  return true;\n}\n\nbool ScopBuilder::buildAccessMemIntrinsic(MemAccInst Inst, ScopStmt *Stmt) {\n  auto *MemIntr = dyn_cast_or_null<MemIntrinsic>(Inst);\n\n  if (MemIntr == nullptr)\n    return false;\n\n  auto *L = LI.getLoopFor(Inst->getParent());\n  auto *LengthVal = SE.getSCEVAtScope(MemIntr->getLength(), L);\n  assert(LengthVal);\n\n  // Check if the length val is actually affine or if we overapproximate it\n  InvariantLoadsSetTy AccessILS;\n  const InvariantLoadsSetTy &ScopRIL = scop->getRequiredInvariantLoads();\n\n  Loop *SurroundingLoop = Stmt->getSurroundingLoop();\n  bool LengthIsAffine = isAffineExpr(&scop->getRegion(), SurroundingLoop,\n                                     LengthVal, SE, &AccessILS);\n  for (LoadInst *LInst : AccessILS)\n    if (!ScopRIL.count(LInst))\n      LengthIsAffine = false;\n  if (!LengthIsAffine)\n    LengthVal = nullptr;\n\n  auto *DestPtrVal = MemIntr->getDest();\n  assert(DestPtrVal);\n\n  auto *DestAccFunc = SE.getSCEVAtScope(DestPtrVal, L);\n  assert(DestAccFunc);\n  // Ignore accesses to \"NULL\".\n  // TODO: We could use this to optimize the region further, e.g., intersect\n  //       the context with\n  //          isl_set_complement(isl_set_params(getDomain()))\n  //       as we know it would be undefined to execute this instruction anyway.\n  if (DestAccFunc->isZero())\n    return true;\n\n  auto *DestPtrSCEV = dyn_cast<SCEVUnknown>(SE.getPointerBase(DestAccFunc));\n  assert(DestPtrSCEV);\n  DestAccFunc = SE.getMinusSCEV(DestAccFunc, DestPtrSCEV);\n  addArrayAccess(Stmt, Inst, MemoryAccess::MUST_WRITE, DestPtrSCEV->getValue(),\n                 IntegerType::getInt8Ty(DestPtrVal->getContext()),\n                 LengthIsAffine, {DestAccFunc, LengthVal}, {nullptr},\n                 Inst.getValueOperand());\n\n  auto *MemTrans = dyn_cast<MemTransferInst>(MemIntr);\n  if (!MemTrans)\n    return true;\n\n  auto *SrcPtrVal = MemTrans->getSource();\n  assert(SrcPtrVal);\n\n  auto *SrcAccFunc = SE.getSCEVAtScope(SrcPtrVal, L);\n  assert(SrcAccFunc);\n  // Ignore accesses to \"NULL\".\n  // TODO: See above TODO\n  if (SrcAccFunc->isZero())\n    return true;\n\n  auto *SrcPtrSCEV = dyn_cast<SCEVUnknown>(SE.getPointerBase(SrcAccFunc));\n  assert(SrcPtrSCEV);\n  SrcAccFunc = SE.getMinusSCEV(SrcAccFunc, SrcPtrSCEV);\n  addArrayAccess(Stmt, Inst, MemoryAccess::READ, SrcPtrSCEV->getValue(),\n                 IntegerType::getInt8Ty(SrcPtrVal->getContext()),\n                 LengthIsAffine, {SrcAccFunc, LengthVal}, {nullptr},\n                 Inst.getValueOperand());\n\n  return true;\n}\n\nbool ScopBuilder::buildAccessCallInst(MemAccInst Inst, ScopStmt *Stmt) {\n  auto *CI = dyn_cast_or_null<CallInst>(Inst);\n\n  if (CI == nullptr)\n    return false;\n\n  if (CI->doesNotAccessMemory() || isIgnoredIntrinsic(CI) || isDebugCall(CI))\n    return true;\n\n  bool ReadOnly = false;\n  auto *AF = SE.getConstant(IntegerType::getInt64Ty(CI->getContext()), 0);\n  auto *CalledFunction = CI->getCalledFunction();\n  switch (AA.getModRefBehavior(CalledFunction)) {\n  case FMRB_UnknownModRefBehavior:\n    llvm_unreachable(\"Unknown mod ref behaviour cannot be represented.\");\n  case FMRB_DoesNotAccessMemory:\n    return true;\n  case FMRB_OnlyWritesMemory:\n  case FMRB_OnlyWritesInaccessibleMem:\n  case FMRB_OnlyWritesInaccessibleOrArgMem:\n  case FMRB_OnlyAccessesInaccessibleMem:\n  case FMRB_OnlyAccessesInaccessibleOrArgMem:\n    return false;\n  case FMRB_OnlyReadsMemory:\n  case FMRB_OnlyReadsInaccessibleMem:\n  case FMRB_OnlyReadsInaccessibleOrArgMem:\n    GlobalReads.emplace_back(Stmt, CI);\n    return true;\n  case FMRB_OnlyReadsArgumentPointees:\n    ReadOnly = true;\n    LLVM_FALLTHROUGH;\n  case FMRB_OnlyWritesArgumentPointees:\n  case FMRB_OnlyAccessesArgumentPointees: {\n    auto AccType = ReadOnly ? MemoryAccess::READ : MemoryAccess::MAY_WRITE;\n    Loop *L = LI.getLoopFor(Inst->getParent());\n    for (const auto &Arg : CI->arg_operands()) {\n      if (!Arg->getType()->isPointerTy())\n        continue;\n\n      auto *ArgSCEV = SE.getSCEVAtScope(Arg, L);\n      if (ArgSCEV->isZero())\n        continue;\n\n      auto *ArgBasePtr = cast<SCEVUnknown>(SE.getPointerBase(ArgSCEV));\n      addArrayAccess(Stmt, Inst, AccType, ArgBasePtr->getValue(),\n                     ArgBasePtr->getType(), false, {AF}, {nullptr}, CI);\n    }\n    return true;\n  }\n  }\n\n  return true;\n}\n\nvoid ScopBuilder::buildAccessSingleDim(MemAccInst Inst, ScopStmt *Stmt) {\n  Value *Address = Inst.getPointerOperand();\n  Value *Val = Inst.getValueOperand();\n  Type *ElementType = Val->getType();\n  enum MemoryAccess::AccessType AccType =\n      isa<LoadInst>(Inst) ? MemoryAccess::READ : MemoryAccess::MUST_WRITE;\n\n  const SCEV *AccessFunction =\n      SE.getSCEVAtScope(Address, LI.getLoopFor(Inst->getParent()));\n  const SCEVUnknown *BasePointer =\n      dyn_cast<SCEVUnknown>(SE.getPointerBase(AccessFunction));\n\n  assert(BasePointer && \"Could not find base pointer\");\n  AccessFunction = SE.getMinusSCEV(AccessFunction, BasePointer);\n\n  // Check if the access depends on a loop contained in a non-affine subregion.\n  bool isVariantInNonAffineLoop = false;\n  SetVector<const Loop *> Loops;\n  findLoops(AccessFunction, Loops);\n  for (const Loop *L : Loops)\n    if (Stmt->contains(L)) {\n      isVariantInNonAffineLoop = true;\n      break;\n    }\n\n  InvariantLoadsSetTy AccessILS;\n\n  Loop *SurroundingLoop = Stmt->getSurroundingLoop();\n  bool IsAffine = !isVariantInNonAffineLoop &&\n                  isAffineExpr(&scop->getRegion(), SurroundingLoop,\n                               AccessFunction, SE, &AccessILS);\n\n  const InvariantLoadsSetTy &ScopRIL = scop->getRequiredInvariantLoads();\n  for (LoadInst *LInst : AccessILS)\n    if (!ScopRIL.count(LInst))\n      IsAffine = false;\n\n  if (!IsAffine && AccType == MemoryAccess::MUST_WRITE)\n    AccType = MemoryAccess::MAY_WRITE;\n\n  addArrayAccess(Stmt, Inst, AccType, BasePointer->getValue(), ElementType,\n                 IsAffine, {AccessFunction}, {nullptr}, Val);\n}\n\nvoid ScopBuilder::buildMemoryAccess(MemAccInst Inst, ScopStmt *Stmt) {\n  if (buildAccessMemIntrinsic(Inst, Stmt))\n    return;\n\n  if (buildAccessCallInst(Inst, Stmt))\n    return;\n\n  if (buildAccessMultiDimFixed(Inst, Stmt))\n    return;\n\n  if (buildAccessMultiDimParam(Inst, Stmt))\n    return;\n\n  buildAccessSingleDim(Inst, Stmt);\n}\n\nvoid ScopBuilder::buildAccessFunctions() {\n  for (auto &Stmt : *scop) {\n    if (Stmt.isBlockStmt()) {\n      buildAccessFunctions(&Stmt, *Stmt.getBasicBlock());\n      continue;\n    }\n\n    Region *R = Stmt.getRegion();\n    for (BasicBlock *BB : R->blocks())\n      buildAccessFunctions(&Stmt, *BB, R);\n  }\n\n  // Build write accesses for values that are used after the SCoP.\n  // The instructions defining them might be synthesizable and therefore not\n  // contained in any statement, hence we iterate over the original instructions\n  // to identify all escaping values.\n  for (BasicBlock *BB : scop->getRegion().blocks()) {\n    for (Instruction &Inst : *BB)\n      buildEscapingDependences(&Inst);\n  }\n}\n\nbool ScopBuilder::shouldModelInst(Instruction *Inst, Loop *L) {\n  return !Inst->isTerminator() && !isIgnoredIntrinsic(Inst) &&\n         !canSynthesize(Inst, *scop, &SE, L);\n}\n\n/// Generate a name for a statement.\n///\n/// @param BB     The basic block the statement will represent.\n/// @param BBIdx  The index of the @p BB relative to other BBs/regions.\n/// @param Count  The index of the created statement in @p BB.\n/// @param IsMain Whether this is the main of all statement for @p BB. If true,\n///               no suffix will be added.\n/// @param IsLast Uses a special indicator for the last statement of a BB.\nstatic std::string makeStmtName(BasicBlock *BB, long BBIdx, int Count,\n                                bool IsMain, bool IsLast = false) {\n  std::string Suffix;\n  if (!IsMain) {\n    if (UseInstructionNames)\n      Suffix = '_';\n    if (IsLast)\n      Suffix += \"last\";\n    else if (Count < 26)\n      Suffix += 'a' + Count;\n    else\n      Suffix += std::to_string(Count);\n  }\n  return getIslCompatibleName(\"Stmt\", BB, BBIdx, Suffix, UseInstructionNames);\n}\n\n/// Generate a name for a statement that represents a non-affine subregion.\n///\n/// @param R    The region the statement will represent.\n/// @param RIdx The index of the @p R relative to other BBs/regions.\nstatic std::string makeStmtName(Region *R, long RIdx) {\n  return getIslCompatibleName(\"Stmt\", R->getNameStr(), RIdx, \"\",\n                              UseInstructionNames);\n}\n\nvoid ScopBuilder::buildSequentialBlockStmts(BasicBlock *BB, bool SplitOnStore) {\n  Loop *SurroundingLoop = LI.getLoopFor(BB);\n\n  int Count = 0;\n  long BBIdx = scop->getNextStmtIdx();\n  std::vector<Instruction *> Instructions;\n  for (Instruction &Inst : *BB) {\n    if (shouldModelInst(&Inst, SurroundingLoop))\n      Instructions.push_back(&Inst);\n    if (Inst.getMetadata(\"polly_split_after\") ||\n        (SplitOnStore && isa<StoreInst>(Inst))) {\n      std::string Name = makeStmtName(BB, BBIdx, Count, Count == 0);\n      scop->addScopStmt(BB, Name, SurroundingLoop, Instructions);\n      Count++;\n      Instructions.clear();\n    }\n  }\n\n  std::string Name = makeStmtName(BB, BBIdx, Count, Count == 0);\n  scop->addScopStmt(BB, Name, SurroundingLoop, Instructions);\n}\n\n/// Is @p Inst an ordered instruction?\n///\n/// An unordered instruction is an instruction, such that a sequence of\n/// unordered instructions can be permuted without changing semantics. Any\n/// instruction for which this is not always the case is ordered.\nstatic bool isOrderedInstruction(Instruction *Inst) {\n  return Inst->mayHaveSideEffects() || Inst->mayReadOrWriteMemory();\n}\n\n/// Join instructions to the same statement if one uses the scalar result of the\n/// other.\nstatic void joinOperandTree(EquivalenceClasses<Instruction *> &UnionFind,\n                            ArrayRef<Instruction *> ModeledInsts) {\n  for (Instruction *Inst : ModeledInsts) {\n    if (isa<PHINode>(Inst))\n      continue;\n\n    for (Use &Op : Inst->operands()) {\n      Instruction *OpInst = dyn_cast<Instruction>(Op.get());\n      if (!OpInst)\n        continue;\n\n      // Check if OpInst is in the BB and is a modeled instruction.\n      auto OpVal = UnionFind.findValue(OpInst);\n      if (OpVal == UnionFind.end())\n        continue;\n\n      UnionFind.unionSets(Inst, OpInst);\n    }\n  }\n}\n\n/// Ensure that the order of ordered instructions does not change.\n///\n/// If we encounter an ordered instruction enclosed in instructions belonging to\n/// a different statement (which might as well contain ordered instructions, but\n/// this is not tested here), join them.\nstatic void\njoinOrderedInstructions(EquivalenceClasses<Instruction *> &UnionFind,\n                        ArrayRef<Instruction *> ModeledInsts) {\n  SetVector<Instruction *> SeenLeaders;\n  for (Instruction *Inst : ModeledInsts) {\n    if (!isOrderedInstruction(Inst))\n      continue;\n\n    Instruction *Leader = UnionFind.getLeaderValue(Inst);\n    // Since previous iterations might have merged sets, some items in\n    // SeenLeaders are not leaders anymore. However, The new leader of\n    // previously merged instructions must be one of the former leaders of\n    // these merged instructions.\n    bool Inserted = SeenLeaders.insert(Leader);\n    if (Inserted)\n      continue;\n\n    // Merge statements to close holes. Say, we have already seen statements A\n    // and B, in this order. Then we see an instruction of A again and we would\n    // see the pattern \"A B A\". This function joins all statements until the\n    // only seen occurrence of A.\n    for (Instruction *Prev : reverse(SeenLeaders)) {\n      // We are backtracking from the last element until we see Inst's leader\n      // in SeenLeaders and merge all into one set. Although leaders of\n      // instructions change during the execution of this loop, it's irrelevant\n      // as we are just searching for the element that we already confirmed is\n      // in the list.\n      if (Prev == Leader)\n        break;\n      UnionFind.unionSets(Prev, Leader);\n    }\n  }\n}\n\n/// If the BasicBlock has an edge from itself, ensure that the PHI WRITEs for\n/// the incoming values from this block are executed after the PHI READ.\n///\n/// Otherwise it could overwrite the incoming value from before the BB with the\n/// value for the next execution. This can happen if the PHI WRITE is added to\n/// the statement with the instruction that defines the incoming value (instead\n/// of the last statement of the same BB). To ensure that the PHI READ and WRITE\n/// are in order, we put both into the statement. PHI WRITEs are always executed\n/// after PHI READs when they are in the same statement.\n///\n/// TODO: This is an overpessimization. We only have to ensure that the PHI\n/// WRITE is not put into a statement containing the PHI itself. That could also\n/// be done by\n/// - having all (strongly connected) PHIs in a single statement,\n/// - unite only the PHIs in the operand tree of the PHI WRITE (because it only\n///   has a chance of being lifted before a PHI by being in a statement with a\n///   PHI that comes before in the basic block), or\n/// - when uniting statements, ensure that no (relevant) PHIs are overtaken.\nstatic void joinOrderedPHIs(EquivalenceClasses<Instruction *> &UnionFind,\n                            ArrayRef<Instruction *> ModeledInsts) {\n  for (Instruction *Inst : ModeledInsts) {\n    PHINode *PHI = dyn_cast<PHINode>(Inst);\n    if (!PHI)\n      continue;\n\n    int Idx = PHI->getBasicBlockIndex(PHI->getParent());\n    if (Idx < 0)\n      continue;\n\n    Instruction *IncomingVal =\n        dyn_cast<Instruction>(PHI->getIncomingValue(Idx));\n    if (!IncomingVal)\n      continue;\n\n    UnionFind.unionSets(PHI, IncomingVal);\n  }\n}\n\nvoid ScopBuilder::buildEqivClassBlockStmts(BasicBlock *BB) {\n  Loop *L = LI.getLoopFor(BB);\n\n  // Extracting out modeled instructions saves us from checking\n  // shouldModelInst() repeatedly.\n  SmallVector<Instruction *, 32> ModeledInsts;\n  EquivalenceClasses<Instruction *> UnionFind;\n  Instruction *MainInst = nullptr, *MainLeader = nullptr;\n  for (Instruction &Inst : *BB) {\n    if (!shouldModelInst(&Inst, L))\n      continue;\n    ModeledInsts.push_back(&Inst);\n    UnionFind.insert(&Inst);\n\n    // When a BB is split into multiple statements, the main statement is the\n    // one containing the 'main' instruction. We select the first instruction\n    // that is unlikely to be removed (because it has side-effects) as the main\n    // one. It is used to ensure that at least one statement from the bb has the\n    // same name as with -polly-stmt-granularity=bb.\n    if (!MainInst && (isa<StoreInst>(Inst) ||\n                      (isa<CallInst>(Inst) && !isa<IntrinsicInst>(Inst))))\n      MainInst = &Inst;\n  }\n\n  joinOperandTree(UnionFind, ModeledInsts);\n  joinOrderedInstructions(UnionFind, ModeledInsts);\n  joinOrderedPHIs(UnionFind, ModeledInsts);\n\n  // The list of instructions for statement (statement represented by the leader\n  // instruction).\n  MapVector<Instruction *, std::vector<Instruction *>> LeaderToInstList;\n\n  // The order of statements must be preserved w.r.t. their ordered\n  // instructions. Without this explicit scan, we would also use non-ordered\n  // instructions (whose order is arbitrary) to determine statement order.\n  for (Instruction *Inst : ModeledInsts) {\n    if (!isOrderedInstruction(Inst))\n      continue;\n\n    auto LeaderIt = UnionFind.findLeader(Inst);\n    if (LeaderIt == UnionFind.member_end())\n      continue;\n\n    // Insert element for the leader instruction.\n    (void)LeaderToInstList[*LeaderIt];\n  }\n\n  // Collect the instructions of all leaders. UnionFind's member iterator\n  // unfortunately are not in any specific order.\n  for (Instruction *Inst : ModeledInsts) {\n    auto LeaderIt = UnionFind.findLeader(Inst);\n    if (LeaderIt == UnionFind.member_end())\n      continue;\n\n    if (Inst == MainInst)\n      MainLeader = *LeaderIt;\n    std::vector<Instruction *> &InstList = LeaderToInstList[*LeaderIt];\n    InstList.push_back(Inst);\n  }\n\n  // Finally build the statements.\n  int Count = 0;\n  long BBIdx = scop->getNextStmtIdx();\n  for (auto &Instructions : LeaderToInstList) {\n    std::vector<Instruction *> &InstList = Instructions.second;\n\n    // If there is no main instruction, make the first statement the main.\n    bool IsMain = (MainInst ? MainLeader == Instructions.first : Count == 0);\n\n    std::string Name = makeStmtName(BB, BBIdx, Count, IsMain);\n    scop->addScopStmt(BB, Name, L, std::move(InstList));\n    Count += 1;\n  }\n\n  // Unconditionally add an epilogue (last statement). It contains no\n  // instructions, but holds the PHI write accesses for successor basic blocks,\n  // if the incoming value is not defined in another statement if the same BB.\n  // The epilogue becomes the main statement only if there is no other\n  // statement that could become main.\n  // The epilogue will be removed if no PHIWrite is added to it.\n  std::string EpilogueName = makeStmtName(BB, BBIdx, Count, Count == 0, true);\n  scop->addScopStmt(BB, EpilogueName, L, {});\n}\n\nvoid ScopBuilder::buildStmts(Region &SR) {\n  if (scop->isNonAffineSubRegion(&SR)) {\n    std::vector<Instruction *> Instructions;\n    Loop *SurroundingLoop =\n        getFirstNonBoxedLoopFor(SR.getEntry(), LI, scop->getBoxedLoops());\n    for (Instruction &Inst : *SR.getEntry())\n      if (shouldModelInst(&Inst, SurroundingLoop))\n        Instructions.push_back(&Inst);\n    long RIdx = scop->getNextStmtIdx();\n    std::string Name = makeStmtName(&SR, RIdx);\n    scop->addScopStmt(&SR, Name, SurroundingLoop, Instructions);\n    return;\n  }\n\n  for (auto I = SR.element_begin(), E = SR.element_end(); I != E; ++I)\n    if (I->isSubRegion())\n      buildStmts(*I->getNodeAs<Region>());\n    else {\n      BasicBlock *BB = I->getNodeAs<BasicBlock>();\n      switch (StmtGranularity) {\n      case GranularityChoice::BasicBlocks:\n        buildSequentialBlockStmts(BB);\n        break;\n      case GranularityChoice::ScalarIndependence:\n        buildEqivClassBlockStmts(BB);\n        break;\n      case GranularityChoice::Stores:\n        buildSequentialBlockStmts(BB, true);\n        break;\n      }\n    }\n}\n\nvoid ScopBuilder::buildAccessFunctions(ScopStmt *Stmt, BasicBlock &BB,\n                                       Region *NonAffineSubRegion) {\n  assert(\n      Stmt &&\n      \"The exit BB is the only one that cannot be represented by a statement\");\n  assert(Stmt->represents(&BB));\n\n  // We do not build access functions for error blocks, as they may contain\n  // instructions we can not model.\n  if (isErrorBlock(BB, scop->getRegion(), LI, DT))\n    return;\n\n  auto BuildAccessesForInst = [this, Stmt,\n                               NonAffineSubRegion](Instruction *Inst) {\n    PHINode *PHI = dyn_cast<PHINode>(Inst);\n    if (PHI)\n      buildPHIAccesses(Stmt, PHI, NonAffineSubRegion, false);\n\n    if (auto MemInst = MemAccInst::dyn_cast(*Inst)) {\n      assert(Stmt && \"Cannot build access function in non-existing statement\");\n      buildMemoryAccess(MemInst, Stmt);\n    }\n\n    // PHI nodes have already been modeled above and terminators that are\n    // not part of a non-affine subregion are fully modeled and regenerated\n    // from the polyhedral domains. Hence, they do not need to be modeled as\n    // explicit data dependences.\n    if (!PHI)\n      buildScalarDependences(Stmt, Inst);\n  };\n\n  const InvariantLoadsSetTy &RIL = scop->getRequiredInvariantLoads();\n  bool IsEntryBlock = (Stmt->getEntryBlock() == &BB);\n  if (IsEntryBlock) {\n    for (Instruction *Inst : Stmt->getInstructions())\n      BuildAccessesForInst(Inst);\n    if (Stmt->isRegionStmt())\n      BuildAccessesForInst(BB.getTerminator());\n  } else {\n    for (Instruction &Inst : BB) {\n      if (isIgnoredIntrinsic(&Inst))\n        continue;\n\n      // Invariant loads already have been processed.\n      if (isa<LoadInst>(Inst) && RIL.count(cast<LoadInst>(&Inst)))\n        continue;\n\n      BuildAccessesForInst(&Inst);\n    }\n  }\n}\n\nMemoryAccess *ScopBuilder::addMemoryAccess(\n    ScopStmt *Stmt, Instruction *Inst, MemoryAccess::AccessType AccType,\n    Value *BaseAddress, Type *ElementType, bool Affine, Value *AccessValue,\n    ArrayRef<const SCEV *> Subscripts, ArrayRef<const SCEV *> Sizes,\n    MemoryKind Kind) {\n  bool isKnownMustAccess = false;\n\n  // Accesses in single-basic block statements are always executed.\n  if (Stmt->isBlockStmt())\n    isKnownMustAccess = true;\n\n  if (Stmt->isRegionStmt()) {\n    // Accesses that dominate the exit block of a non-affine region are always\n    // executed. In non-affine regions there may exist MemoryKind::Values that\n    // do not dominate the exit. MemoryKind::Values will always dominate the\n    // exit and MemoryKind::PHIs only if there is at most one PHI_WRITE in the\n    // non-affine region.\n    if (Inst && DT.dominates(Inst->getParent(), Stmt->getRegion()->getExit()))\n      isKnownMustAccess = true;\n  }\n\n  // Non-affine PHI writes do not \"happen\" at a particular instruction, but\n  // after exiting the statement. Therefore they are guaranteed to execute and\n  // overwrite the old value.\n  if (Kind == MemoryKind::PHI || Kind == MemoryKind::ExitPHI)\n    isKnownMustAccess = true;\n\n  if (!isKnownMustAccess && AccType == MemoryAccess::MUST_WRITE)\n    AccType = MemoryAccess::MAY_WRITE;\n\n  auto *Access = new MemoryAccess(Stmt, Inst, AccType, BaseAddress, ElementType,\n                                  Affine, Subscripts, Sizes, AccessValue, Kind);\n\n  scop->addAccessFunction(Access);\n  Stmt->addAccess(Access);\n  return Access;\n}\n\nvoid ScopBuilder::addArrayAccess(ScopStmt *Stmt, MemAccInst MemAccInst,\n                                 MemoryAccess::AccessType AccType,\n                                 Value *BaseAddress, Type *ElementType,\n                                 bool IsAffine,\n                                 ArrayRef<const SCEV *> Subscripts,\n                                 ArrayRef<const SCEV *> Sizes,\n                                 Value *AccessValue) {\n  ArrayBasePointers.insert(BaseAddress);\n  auto *MemAccess = addMemoryAccess(Stmt, MemAccInst, AccType, BaseAddress,\n                                    ElementType, IsAffine, AccessValue,\n                                    Subscripts, Sizes, MemoryKind::Array);\n\n  if (!DetectFortranArrays)\n    return;\n\n  if (Value *FAD = findFADAllocationInvisible(MemAccInst))\n    MemAccess->setFortranArrayDescriptor(FAD);\n  else if (Value *FAD = findFADAllocationVisible(MemAccInst))\n    MemAccess->setFortranArrayDescriptor(FAD);\n}\n\n/// Check if @p Expr is divisible by @p Size.\nstatic bool isDivisible(const SCEV *Expr, unsigned Size, ScalarEvolution &SE) {\n  assert(Size != 0);\n  if (Size == 1)\n    return true;\n\n  // Only one factor needs to be divisible.\n  if (auto *MulExpr = dyn_cast<SCEVMulExpr>(Expr)) {\n    for (auto *FactorExpr : MulExpr->operands())\n      if (isDivisible(FactorExpr, Size, SE))\n        return true;\n    return false;\n  }\n\n  // For other n-ary expressions (Add, AddRec, Max,...) all operands need\n  // to be divisible.\n  if (auto *NAryExpr = dyn_cast<SCEVNAryExpr>(Expr)) {\n    for (auto *OpExpr : NAryExpr->operands())\n      if (!isDivisible(OpExpr, Size, SE))\n        return false;\n    return true;\n  }\n\n  auto *SizeSCEV = SE.getConstant(Expr->getType(), Size);\n  auto *UDivSCEV = SE.getUDivExpr(Expr, SizeSCEV);\n  auto *MulSCEV = SE.getMulExpr(UDivSCEV, SizeSCEV);\n  return MulSCEV == Expr;\n}\n\nvoid ScopBuilder::foldSizeConstantsToRight() {\n  isl::union_set Accessed = scop->getAccesses().range();\n\n  for (auto Array : scop->arrays()) {\n    if (Array->getNumberOfDimensions() <= 1)\n      continue;\n\n    isl::space Space = Array->getSpace();\n    Space = Space.align_params(Accessed.get_space());\n\n    if (!Accessed.contains(Space))\n      continue;\n\n    isl::set Elements = Accessed.extract_set(Space);\n    isl::map Transform = isl::map::universe(Array->getSpace().map_from_set());\n\n    std::vector<int> Int;\n    int Dims = Elements.dim(isl::dim::set);\n    for (int i = 0; i < Dims; i++) {\n      isl::set DimOnly = isl::set(Elements).project_out(isl::dim::set, 0, i);\n      DimOnly = DimOnly.project_out(isl::dim::set, 1, Dims - i - 1);\n      DimOnly = DimOnly.lower_bound_si(isl::dim::set, 0, 0);\n\n      isl::basic_set DimHull = DimOnly.affine_hull();\n\n      if (i == Dims - 1) {\n        Int.push_back(1);\n        Transform = Transform.equate(isl::dim::in, i, isl::dim::out, i);\n        continue;\n      }\n\n      if (DimHull.dim(isl::dim::div) == 1) {\n        isl::aff Diff = DimHull.get_div(0);\n        isl::val Val = Diff.get_denominator_val();\n\n        int ValInt = 1;\n        if (Val.is_int()) {\n          auto ValAPInt = APIntFromVal(Val);\n          if (ValAPInt.isSignedIntN(32))\n            ValInt = ValAPInt.getSExtValue();\n        } else {\n        }\n\n        Int.push_back(ValInt);\n        isl::constraint C = isl::constraint::alloc_equality(\n            isl::local_space(Transform.get_space()));\n        C = C.set_coefficient_si(isl::dim::out, i, ValInt);\n        C = C.set_coefficient_si(isl::dim::in, i, -1);\n        Transform = Transform.add_constraint(C);\n        continue;\n      }\n\n      isl::basic_set ZeroSet = isl::basic_set(DimHull);\n      ZeroSet = ZeroSet.fix_si(isl::dim::set, 0, 0);\n\n      int ValInt = 1;\n      if (ZeroSet.is_equal(DimHull)) {\n        ValInt = 0;\n      }\n\n      Int.push_back(ValInt);\n      Transform = Transform.equate(isl::dim::in, i, isl::dim::out, i);\n    }\n\n    isl::set MappedElements = isl::map(Transform).domain();\n    if (!Elements.is_subset(MappedElements))\n      continue;\n\n    bool CanFold = true;\n    if (Int[0] <= 1)\n      CanFold = false;\n\n    unsigned NumDims = Array->getNumberOfDimensions();\n    for (unsigned i = 1; i < NumDims - 1; i++)\n      if (Int[0] != Int[i] && Int[i])\n        CanFold = false;\n\n    if (!CanFold)\n      continue;\n\n    for (auto &Access : scop->access_functions())\n      if (Access->getScopArrayInfo() == Array)\n        Access->setAccessRelation(\n            Access->getAccessRelation().apply_range(Transform));\n\n    std::vector<const SCEV *> Sizes;\n    for (unsigned i = 0; i < NumDims; i++) {\n      auto Size = Array->getDimensionSize(i);\n\n      if (i == NumDims - 1)\n        Size = SE.getMulExpr(Size, SE.getConstant(Size->getType(), Int[0]));\n      Sizes.push_back(Size);\n    }\n\n    Array->updateSizes(Sizes, false /* CheckConsistency */);\n  }\n}\n\nvoid ScopBuilder::markFortranArrays() {\n  for (ScopStmt &Stmt : *scop) {\n    for (MemoryAccess *MemAcc : Stmt) {\n      Value *FAD = MemAcc->getFortranArrayDescriptor();\n      if (!FAD)\n        continue;\n\n      // TODO: const_cast-ing to edit\n      ScopArrayInfo *SAI =\n          const_cast<ScopArrayInfo *>(MemAcc->getLatestScopArrayInfo());\n      assert(SAI && \"memory access into a Fortran array does not \"\n                    \"have an associated ScopArrayInfo\");\n      SAI->applyAndSetFAD(FAD);\n    }\n  }\n}\n\nvoid ScopBuilder::finalizeAccesses() {\n  updateAccessDimensionality();\n  foldSizeConstantsToRight();\n  foldAccessRelations();\n  assumeNoOutOfBounds();\n  markFortranArrays();\n}\n\nvoid ScopBuilder::updateAccessDimensionality() {\n  // Check all array accesses for each base pointer and find a (virtual) element\n  // size for the base pointer that divides all access functions.\n  for (ScopStmt &Stmt : *scop)\n    for (MemoryAccess *Access : Stmt) {\n      if (!Access->isArrayKind())\n        continue;\n      ScopArrayInfo *Array =\n          const_cast<ScopArrayInfo *>(Access->getScopArrayInfo());\n\n      if (Array->getNumberOfDimensions() != 1)\n        continue;\n      unsigned DivisibleSize = Array->getElemSizeInBytes();\n      const SCEV *Subscript = Access->getSubscript(0);\n      while (!isDivisible(Subscript, DivisibleSize, SE))\n        DivisibleSize /= 2;\n      auto *Ty = IntegerType::get(SE.getContext(), DivisibleSize * 8);\n      Array->updateElementType(Ty);\n    }\n\n  for (auto &Stmt : *scop)\n    for (auto &Access : Stmt)\n      Access->updateDimensionality();\n}\n\nvoid ScopBuilder::foldAccessRelations() {\n  for (auto &Stmt : *scop)\n    for (auto &Access : Stmt)\n      Access->foldAccessRelation();\n}\n\nvoid ScopBuilder::assumeNoOutOfBounds() {\n  if (PollyIgnoreInbounds)\n    return;\n  for (auto &Stmt : *scop)\n    for (auto &Access : Stmt) {\n      isl::set Outside = Access->assumeNoOutOfBound();\n      const auto &Loc = Access->getAccessInstruction()\n                            ? Access->getAccessInstruction()->getDebugLoc()\n                            : DebugLoc();\n      recordAssumption(&RecordedAssumptions, INBOUNDS, Outside, Loc,\n                       AS_ASSUMPTION);\n    }\n}\n\nvoid ScopBuilder::ensureValueWrite(Instruction *Inst) {\n  // Find the statement that defines the value of Inst. That statement has to\n  // write the value to make it available to those statements that read it.\n  ScopStmt *Stmt = scop->getStmtFor(Inst);\n\n  // It is possible that the value is synthesizable within a loop (such that it\n  // is not part of any statement), but not after the loop (where you need the\n  // number of loop round-trips to synthesize it). In LCSSA-form a PHI node will\n  // avoid this. In case the IR has no such PHI, use the last statement (where\n  // the value is synthesizable) to write the value.\n  if (!Stmt)\n    Stmt = scop->getLastStmtFor(Inst->getParent());\n\n  // Inst not defined within this SCoP.\n  if (!Stmt)\n    return;\n\n  // Do not process further if the instruction is already written.\n  if (Stmt->lookupValueWriteOf(Inst))\n    return;\n\n  addMemoryAccess(Stmt, Inst, MemoryAccess::MUST_WRITE, Inst, Inst->getType(),\n                  true, Inst, ArrayRef<const SCEV *>(),\n                  ArrayRef<const SCEV *>(), MemoryKind::Value);\n}\n\nvoid ScopBuilder::ensureValueRead(Value *V, ScopStmt *UserStmt) {\n  // TODO: Make ScopStmt::ensureValueRead(Value*) offer the same functionality\n  // to be able to replace this one. Currently, there is a split responsibility.\n  // In a first step, the MemoryAccess is created, but without the\n  // AccessRelation. In the second step by ScopStmt::buildAccessRelations(), the\n  // AccessRelation is created. At least for scalar accesses, there is no new\n  // information available at ScopStmt::buildAccessRelations(), so we could\n  // create the AccessRelation right away. This is what\n  // ScopStmt::ensureValueRead(Value*) does.\n\n  auto *Scope = UserStmt->getSurroundingLoop();\n  auto VUse = VirtualUse::create(scop.get(), UserStmt, Scope, V, false);\n  switch (VUse.getKind()) {\n  case VirtualUse::Constant:\n  case VirtualUse::Block:\n  case VirtualUse::Synthesizable:\n  case VirtualUse::Hoisted:\n  case VirtualUse::Intra:\n    // Uses of these kinds do not need a MemoryAccess.\n    break;\n\n  case VirtualUse::ReadOnly:\n    // Add MemoryAccess for invariant values only if requested.\n    if (!ModelReadOnlyScalars)\n      break;\n\n    LLVM_FALLTHROUGH;\n  case VirtualUse::Inter:\n\n    // Do not create another MemoryAccess for reloading the value if one already\n    // exists.\n    if (UserStmt->lookupValueReadOf(V))\n      break;\n\n    addMemoryAccess(UserStmt, nullptr, MemoryAccess::READ, V, V->getType(),\n                    true, V, ArrayRef<const SCEV *>(), ArrayRef<const SCEV *>(),\n                    MemoryKind::Value);\n\n    // Inter-statement uses need to write the value in their defining statement.\n    if (VUse.isInter())\n      ensureValueWrite(cast<Instruction>(V));\n    break;\n  }\n}\n\nvoid ScopBuilder::ensurePHIWrite(PHINode *PHI, ScopStmt *IncomingStmt,\n                                 BasicBlock *IncomingBlock,\n                                 Value *IncomingValue, bool IsExitBlock) {\n  // As the incoming block might turn out to be an error statement ensure we\n  // will create an exit PHI SAI object. It is needed during code generation\n  // and would be created later anyway.\n  if (IsExitBlock)\n    scop->getOrCreateScopArrayInfo(PHI, PHI->getType(), {},\n                                   MemoryKind::ExitPHI);\n\n  // This is possible if PHI is in the SCoP's entry block. The incoming blocks\n  // from outside the SCoP's region have no statement representation.\n  if (!IncomingStmt)\n    return;\n\n  // Take care for the incoming value being available in the incoming block.\n  // This must be done before the check for multiple PHI writes because multiple\n  // exiting edges from subregion each can be the effective written value of the\n  // subregion. As such, all of them must be made available in the subregion\n  // statement.\n  ensureValueRead(IncomingValue, IncomingStmt);\n\n  // Do not add more than one MemoryAccess per PHINode and ScopStmt.\n  if (MemoryAccess *Acc = IncomingStmt->lookupPHIWriteOf(PHI)) {\n    assert(Acc->getAccessInstruction() == PHI);\n    Acc->addIncoming(IncomingBlock, IncomingValue);\n    return;\n  }\n\n  MemoryAccess *Acc = addMemoryAccess(\n      IncomingStmt, PHI, MemoryAccess::MUST_WRITE, PHI, PHI->getType(), true,\n      PHI, ArrayRef<const SCEV *>(), ArrayRef<const SCEV *>(),\n      IsExitBlock ? MemoryKind::ExitPHI : MemoryKind::PHI);\n  assert(Acc);\n  Acc->addIncoming(IncomingBlock, IncomingValue);\n}\n\nvoid ScopBuilder::addPHIReadAccess(ScopStmt *PHIStmt, PHINode *PHI) {\n  addMemoryAccess(PHIStmt, PHI, MemoryAccess::READ, PHI, PHI->getType(), true,\n                  PHI, ArrayRef<const SCEV *>(), ArrayRef<const SCEV *>(),\n                  MemoryKind::PHI);\n}\n\nvoid ScopBuilder::buildDomain(ScopStmt &Stmt) {\n  isl::id Id = isl::id::alloc(scop->getIslCtx(), Stmt.getBaseName(), &Stmt);\n\n  Stmt.Domain = scop->getDomainConditions(&Stmt);\n  Stmt.Domain = Stmt.Domain.set_tuple_id(Id);\n}\n\nvoid ScopBuilder::collectSurroundingLoops(ScopStmt &Stmt) {\n  isl::set Domain = Stmt.getDomain();\n  BasicBlock *BB = Stmt.getEntryBlock();\n\n  Loop *L = LI.getLoopFor(BB);\n\n  while (L && Stmt.isRegionStmt() && Stmt.getRegion()->contains(L))\n    L = L->getParentLoop();\n\n  SmallVector<llvm::Loop *, 8> Loops;\n\n  while (L && Stmt.getParent()->getRegion().contains(L)) {\n    Loops.push_back(L);\n    L = L->getParentLoop();\n  }\n\n  Stmt.NestLoops.insert(Stmt.NestLoops.begin(), Loops.rbegin(), Loops.rend());\n}\n\n/// Return the reduction type for a given binary operator.\nstatic MemoryAccess::ReductionType getReductionType(const BinaryOperator *BinOp,\n                                                    const Instruction *Load) {\n  if (!BinOp)\n    return MemoryAccess::RT_NONE;\n  switch (BinOp->getOpcode()) {\n  case Instruction::FAdd:\n    if (!BinOp->isFast())\n      return MemoryAccess::RT_NONE;\n    LLVM_FALLTHROUGH;\n  case Instruction::Add:\n    return MemoryAccess::RT_ADD;\n  case Instruction::Or:\n    return MemoryAccess::RT_BOR;\n  case Instruction::Xor:\n    return MemoryAccess::RT_BXOR;\n  case Instruction::And:\n    return MemoryAccess::RT_BAND;\n  case Instruction::FMul:\n    if (!BinOp->isFast())\n      return MemoryAccess::RT_NONE;\n    LLVM_FALLTHROUGH;\n  case Instruction::Mul:\n    if (DisableMultiplicativeReductions)\n      return MemoryAccess::RT_NONE;\n    return MemoryAccess::RT_MUL;\n  default:\n    return MemoryAccess::RT_NONE;\n  }\n}\n\nvoid ScopBuilder::checkForReductions(ScopStmt &Stmt) {\n  SmallVector<MemoryAccess *, 2> Loads;\n  SmallVector<std::pair<MemoryAccess *, MemoryAccess *>, 4> Candidates;\n\n  // First collect candidate load-store reduction chains by iterating over all\n  // stores and collecting possible reduction loads.\n  for (MemoryAccess *StoreMA : Stmt) {\n    if (StoreMA->isRead())\n      continue;\n\n    Loads.clear();\n    collectCandidateReductionLoads(StoreMA, Loads);\n    for (MemoryAccess *LoadMA : Loads)\n      Candidates.push_back(std::make_pair(LoadMA, StoreMA));\n  }\n\n  // Then check each possible candidate pair.\n  for (const auto &CandidatePair : Candidates) {\n    bool Valid = true;\n    isl::map LoadAccs = CandidatePair.first->getAccessRelation();\n    isl::map StoreAccs = CandidatePair.second->getAccessRelation();\n\n    // Skip those with obviously unequal base addresses.\n    if (!LoadAccs.has_equal_space(StoreAccs)) {\n      continue;\n    }\n\n    // And check if the remaining for overlap with other memory accesses.\n    isl::map AllAccsRel = LoadAccs.unite(StoreAccs);\n    AllAccsRel = AllAccsRel.intersect_domain(Stmt.getDomain());\n    isl::set AllAccs = AllAccsRel.range();\n\n    for (MemoryAccess *MA : Stmt) {\n      if (MA == CandidatePair.first || MA == CandidatePair.second)\n        continue;\n\n      isl::map AccRel =\n          MA->getAccessRelation().intersect_domain(Stmt.getDomain());\n      isl::set Accs = AccRel.range();\n\n      if (AllAccs.has_equal_space(Accs)) {\n        isl::set OverlapAccs = Accs.intersect(AllAccs);\n        Valid = Valid && OverlapAccs.is_empty();\n      }\n    }\n\n    if (!Valid)\n      continue;\n\n    const LoadInst *Load =\n        dyn_cast<const LoadInst>(CandidatePair.first->getAccessInstruction());\n    MemoryAccess::ReductionType RT =\n        getReductionType(dyn_cast<BinaryOperator>(Load->user_back()), Load);\n\n    // If no overlapping access was found we mark the load and store as\n    // reduction like.\n    CandidatePair.first->markAsReductionLike(RT);\n    CandidatePair.second->markAsReductionLike(RT);\n  }\n}\n\nvoid ScopBuilder::verifyInvariantLoads() {\n  auto &RIL = scop->getRequiredInvariantLoads();\n  for (LoadInst *LI : RIL) {\n    assert(LI && scop->contains(LI));\n    // If there exists a statement in the scop which has a memory access for\n    // @p LI, then mark this scop as infeasible for optimization.\n    for (ScopStmt &Stmt : *scop)\n      if (Stmt.getArrayAccessOrNULLFor(LI)) {\n        scop->invalidate(INVARIANTLOAD, LI->getDebugLoc(), LI->getParent());\n        return;\n      }\n  }\n}\n\nvoid ScopBuilder::hoistInvariantLoads() {\n  if (!PollyInvariantLoadHoisting)\n    return;\n\n  isl::union_map Writes = scop->getWrites();\n  for (ScopStmt &Stmt : *scop) {\n    InvariantAccessesTy InvariantAccesses;\n\n    for (MemoryAccess *Access : Stmt)\n      if (isl::set NHCtx = getNonHoistableCtx(Access, Writes))\n        InvariantAccesses.push_back({Access, NHCtx});\n\n    // Transfer the memory access from the statement to the SCoP.\n    for (auto InvMA : InvariantAccesses)\n      Stmt.removeMemoryAccess(InvMA.MA);\n    addInvariantLoads(Stmt, InvariantAccesses);\n  }\n}\n\n/// Check if an access range is too complex.\n///\n/// An access range is too complex, if it contains either many disjuncts or\n/// very complex expressions. As a simple heuristic, we assume if a set to\n/// be too complex if the sum of existentially quantified dimensions and\n/// set dimensions is larger than a threshold. This reliably detects both\n/// sets with many disjuncts as well as sets with many divisions as they\n/// arise in h264.\n///\n/// @param AccessRange The range to check for complexity.\n///\n/// @returns True if the access range is too complex.\nstatic bool isAccessRangeTooComplex(isl::set AccessRange) {\n  int NumTotalDims = 0;\n\n  for (isl::basic_set BSet : AccessRange.get_basic_set_list()) {\n    NumTotalDims += BSet.dim(isl::dim::div);\n    NumTotalDims += BSet.dim(isl::dim::set);\n  }\n\n  if (NumTotalDims > MaxDimensionsInAccessRange)\n    return true;\n\n  return false;\n}\n\nbool ScopBuilder::hasNonHoistableBasePtrInScop(MemoryAccess *MA,\n                                               isl::union_map Writes) {\n  if (auto *BasePtrMA = scop->lookupBasePtrAccess(MA)) {\n    return getNonHoistableCtx(BasePtrMA, Writes).is_null();\n  }\n\n  Value *BaseAddr = MA->getOriginalBaseAddr();\n  if (auto *BasePtrInst = dyn_cast<Instruction>(BaseAddr))\n    if (!isa<LoadInst>(BasePtrInst))\n      return scop->contains(BasePtrInst);\n\n  return false;\n}\n\nvoid ScopBuilder::addUserContext() {\n  if (UserContextStr.empty())\n    return;\n\n  isl::set UserContext = isl::set(scop->getIslCtx(), UserContextStr.c_str());\n  isl::space Space = scop->getParamSpace();\n  if (Space.dim(isl::dim::param) != UserContext.dim(isl::dim::param)) {\n    std::string SpaceStr = Space.to_str();\n    errs() << \"Error: the context provided in -polly-context has not the same \"\n           << \"number of dimensions than the computed context. Due to this \"\n           << \"mismatch, the -polly-context option is ignored. Please provide \"\n           << \"the context in the parameter space: \" << SpaceStr << \".\\n\";\n    return;\n  }\n\n  for (auto i : seq<isl_size>(0, Space.dim(isl::dim::param))) {\n    std::string NameContext =\n        scop->getContext().get_dim_name(isl::dim::param, i);\n    std::string NameUserContext = UserContext.get_dim_name(isl::dim::param, i);\n\n    if (NameContext != NameUserContext) {\n      std::string SpaceStr = Space.to_str();\n      errs() << \"Error: the name of dimension \" << i\n             << \" provided in -polly-context \"\n             << \"is '\" << NameUserContext << \"', but the name in the computed \"\n             << \"context is '\" << NameContext\n             << \"'. Due to this name mismatch, \"\n             << \"the -polly-context option is ignored. Please provide \"\n             << \"the context in the parameter space: \" << SpaceStr << \".\\n\";\n      return;\n    }\n\n    UserContext = UserContext.set_dim_id(isl::dim::param, i,\n                                         Space.get_dim_id(isl::dim::param, i));\n  }\n  isl::set newContext = scop->getContext().intersect(UserContext);\n  scop->setContext(newContext);\n}\n\nisl::set ScopBuilder::getNonHoistableCtx(MemoryAccess *Access,\n                                         isl::union_map Writes) {\n  // TODO: Loads that are not loop carried, hence are in a statement with\n  //       zero iterators, are by construction invariant, though we\n  //       currently \"hoist\" them anyway. This is necessary because we allow\n  //       them to be treated as parameters (e.g., in conditions) and our code\n  //       generation would otherwise use the old value.\n\n  auto &Stmt = *Access->getStatement();\n  BasicBlock *BB = Stmt.getEntryBlock();\n\n  if (Access->isScalarKind() || Access->isWrite() || !Access->isAffine() ||\n      Access->isMemoryIntrinsic())\n    return nullptr;\n\n  // Skip accesses that have an invariant base pointer which is defined but\n  // not loaded inside the SCoP. This can happened e.g., if a readnone call\n  // returns a pointer that is used as a base address. However, as we want\n  // to hoist indirect pointers, we allow the base pointer to be defined in\n  // the region if it is also a memory access. Each ScopArrayInfo object\n  // that has a base pointer origin has a base pointer that is loaded and\n  // that it is invariant, thus it will be hoisted too. However, if there is\n  // no base pointer origin we check that the base pointer is defined\n  // outside the region.\n  auto *LI = cast<LoadInst>(Access->getAccessInstruction());\n  if (hasNonHoistableBasePtrInScop(Access, Writes))\n    return nullptr;\n\n  isl::map AccessRelation = Access->getAccessRelation();\n  assert(!AccessRelation.is_empty());\n\n  if (AccessRelation.involves_dims(isl::dim::in, 0, Stmt.getNumIterators()))\n    return nullptr;\n\n  AccessRelation = AccessRelation.intersect_domain(Stmt.getDomain());\n  isl::set SafeToLoad;\n\n  auto &DL = scop->getFunction().getParent()->getDataLayout();\n  if (isSafeToLoadUnconditionally(LI->getPointerOperand(), LI->getType(),\n                                  LI->getAlign(), DL)) {\n    SafeToLoad = isl::set::universe(AccessRelation.get_space().range());\n  } else if (BB != LI->getParent()) {\n    // Skip accesses in non-affine subregions as they might not be executed\n    // under the same condition as the entry of the non-affine subregion.\n    return nullptr;\n  } else {\n    SafeToLoad = AccessRelation.range();\n  }\n\n  if (isAccessRangeTooComplex(AccessRelation.range()))\n    return nullptr;\n\n  isl::union_map Written = Writes.intersect_range(SafeToLoad);\n  isl::set WrittenCtx = Written.params();\n  bool IsWritten = !WrittenCtx.is_empty();\n\n  if (!IsWritten)\n    return WrittenCtx;\n\n  WrittenCtx = WrittenCtx.remove_divs();\n  bool TooComplex = WrittenCtx.n_basic_set() >= MaxDisjunctsInDomain;\n  if (TooComplex || !isRequiredInvariantLoad(LI))\n    return nullptr;\n\n  scop->addAssumption(INVARIANTLOAD, WrittenCtx, LI->getDebugLoc(),\n                      AS_RESTRICTION, LI->getParent());\n  return WrittenCtx;\n}\n\nstatic bool isAParameter(llvm::Value *maybeParam, const Function &F) {\n  for (const llvm::Argument &Arg : F.args())\n    if (&Arg == maybeParam)\n      return true;\n\n  return false;\n}\n\nbool ScopBuilder::canAlwaysBeHoisted(MemoryAccess *MA,\n                                     bool StmtInvalidCtxIsEmpty,\n                                     bool MAInvalidCtxIsEmpty,\n                                     bool NonHoistableCtxIsEmpty) {\n  LoadInst *LInst = cast<LoadInst>(MA->getAccessInstruction());\n  const DataLayout &DL = LInst->getParent()->getModule()->getDataLayout();\n  if (PollyAllowDereferenceOfAllFunctionParams &&\n      isAParameter(LInst->getPointerOperand(), scop->getFunction()))\n    return true;\n\n  // TODO: We can provide more information for better but more expensive\n  //       results.\n  if (!isDereferenceableAndAlignedPointer(\n          LInst->getPointerOperand(), LInst->getType(), LInst->getAlign(), DL))\n    return false;\n\n  // If the location might be overwritten we do not hoist it unconditionally.\n  //\n  // TODO: This is probably too conservative.\n  if (!NonHoistableCtxIsEmpty)\n    return false;\n\n  // If a dereferenceable load is in a statement that is modeled precisely we\n  // can hoist it.\n  if (StmtInvalidCtxIsEmpty && MAInvalidCtxIsEmpty)\n    return true;\n\n  // Even if the statement is not modeled precisely we can hoist the load if it\n  // does not involve any parameters that might have been specialized by the\n  // statement domain.\n  for (const SCEV *Subscript : MA->subscripts())\n    if (!isa<SCEVConstant>(Subscript))\n      return false;\n  return true;\n}\n\nvoid ScopBuilder::addInvariantLoads(ScopStmt &Stmt,\n                                    InvariantAccessesTy &InvMAs) {\n  if (InvMAs.empty())\n    return;\n\n  isl::set StmtInvalidCtx = Stmt.getInvalidContext();\n  bool StmtInvalidCtxIsEmpty = StmtInvalidCtx.is_empty();\n\n  // Get the context under which the statement is executed but remove the error\n  // context under which this statement is reached.\n  isl::set DomainCtx = Stmt.getDomain().params();\n  DomainCtx = DomainCtx.subtract(StmtInvalidCtx);\n\n  if (DomainCtx.n_basic_set() >= MaxDisjunctsInDomain) {\n    auto *AccInst = InvMAs.front().MA->getAccessInstruction();\n    scop->invalidate(COMPLEXITY, AccInst->getDebugLoc(), AccInst->getParent());\n    return;\n  }\n\n  // Project out all parameters that relate to loads in the statement. Otherwise\n  // we could have cyclic dependences on the constraints under which the\n  // hoisted loads are executed and we could not determine an order in which to\n  // pre-load them. This happens because not only lower bounds are part of the\n  // domain but also upper bounds.\n  for (auto &InvMA : InvMAs) {\n    auto *MA = InvMA.MA;\n    Instruction *AccInst = MA->getAccessInstruction();\n    if (SE.isSCEVable(AccInst->getType())) {\n      SetVector<Value *> Values;\n      for (const SCEV *Parameter : scop->parameters()) {\n        Values.clear();\n        findValues(Parameter, SE, Values);\n        if (!Values.count(AccInst))\n          continue;\n\n        if (isl::id ParamId = scop->getIdForParam(Parameter)) {\n          int Dim = DomainCtx.find_dim_by_id(isl::dim::param, ParamId);\n          if (Dim >= 0)\n            DomainCtx = DomainCtx.eliminate(isl::dim::param, Dim, 1);\n        }\n      }\n    }\n  }\n\n  for (auto &InvMA : InvMAs) {\n    auto *MA = InvMA.MA;\n    isl::set NHCtx = InvMA.NonHoistableCtx;\n\n    // Check for another invariant access that accesses the same location as\n    // MA and if found consolidate them. Otherwise create a new equivalence\n    // class at the end of InvariantEquivClasses.\n    LoadInst *LInst = cast<LoadInst>(MA->getAccessInstruction());\n    Type *Ty = LInst->getType();\n    const SCEV *PointerSCEV = SE.getSCEV(LInst->getPointerOperand());\n\n    isl::set MAInvalidCtx = MA->getInvalidContext();\n    bool NonHoistableCtxIsEmpty = NHCtx.is_empty();\n    bool MAInvalidCtxIsEmpty = MAInvalidCtx.is_empty();\n\n    isl::set MACtx;\n    // Check if we know that this pointer can be speculatively accessed.\n    if (canAlwaysBeHoisted(MA, StmtInvalidCtxIsEmpty, MAInvalidCtxIsEmpty,\n                           NonHoistableCtxIsEmpty)) {\n      MACtx = isl::set::universe(DomainCtx.get_space());\n    } else {\n      MACtx = DomainCtx;\n      MACtx = MACtx.subtract(MAInvalidCtx.unite(NHCtx));\n      MACtx = MACtx.gist_params(scop->getContext());\n    }\n\n    bool Consolidated = false;\n    for (auto &IAClass : scop->invariantEquivClasses()) {\n      if (PointerSCEV != IAClass.IdentifyingPointer || Ty != IAClass.AccessType)\n        continue;\n\n      // If the pointer and the type is equal check if the access function wrt.\n      // to the domain is equal too. It can happen that the domain fixes\n      // parameter values and these can be different for distinct part of the\n      // SCoP. If this happens we cannot consolidate the loads but need to\n      // create a new invariant load equivalence class.\n      auto &MAs = IAClass.InvariantAccesses;\n      if (!MAs.empty()) {\n        auto *LastMA = MAs.front();\n\n        isl::set AR = MA->getAccessRelation().range();\n        isl::set LastAR = LastMA->getAccessRelation().range();\n        bool SameAR = AR.is_equal(LastAR);\n\n        if (!SameAR)\n          continue;\n      }\n\n      // Add MA to the list of accesses that are in this class.\n      MAs.push_front(MA);\n\n      Consolidated = true;\n\n      // Unify the execution context of the class and this statement.\n      isl::set IAClassDomainCtx = IAClass.ExecutionContext;\n      if (IAClassDomainCtx)\n        IAClassDomainCtx = IAClassDomainCtx.unite(MACtx).coalesce();\n      else\n        IAClassDomainCtx = MACtx;\n      IAClass.ExecutionContext = IAClassDomainCtx;\n      break;\n    }\n\n    if (Consolidated)\n      continue;\n\n    MACtx = MACtx.coalesce();\n\n    // If we did not consolidate MA, thus did not find an equivalence class\n    // for it, we create a new one.\n    scop->addInvariantEquivClass(\n        InvariantEquivClassTy{PointerSCEV, MemoryAccessList{MA}, MACtx, Ty});\n  }\n}\n\nvoid ScopBuilder::collectCandidateReductionLoads(\n    MemoryAccess *StoreMA, SmallVectorImpl<MemoryAccess *> &Loads) {\n  ScopStmt *Stmt = StoreMA->getStatement();\n\n  auto *Store = dyn_cast<StoreInst>(StoreMA->getAccessInstruction());\n  if (!Store)\n    return;\n\n  // Skip if there is not one binary operator between the load and the store\n  auto *BinOp = dyn_cast<BinaryOperator>(Store->getValueOperand());\n  if (!BinOp)\n    return;\n\n  // Skip if the binary operators has multiple uses\n  if (BinOp->getNumUses() != 1)\n    return;\n\n  // Skip if the opcode of the binary operator is not commutative/associative\n  if (!BinOp->isCommutative() || !BinOp->isAssociative())\n    return;\n\n  // Skip if the binary operator is outside the current SCoP\n  if (BinOp->getParent() != Store->getParent())\n    return;\n\n  // Skip if it is a multiplicative reduction and we disabled them\n  if (DisableMultiplicativeReductions &&\n      (BinOp->getOpcode() == Instruction::Mul ||\n       BinOp->getOpcode() == Instruction::FMul))\n    return;\n\n  // Check the binary operator operands for a candidate load\n  auto *PossibleLoad0 = dyn_cast<LoadInst>(BinOp->getOperand(0));\n  auto *PossibleLoad1 = dyn_cast<LoadInst>(BinOp->getOperand(1));\n  if (!PossibleLoad0 && !PossibleLoad1)\n    return;\n\n  // A load is only a candidate if it cannot escape (thus has only this use)\n  if (PossibleLoad0 && PossibleLoad0->getNumUses() == 1)\n    if (PossibleLoad0->getParent() == Store->getParent())\n      Loads.push_back(&Stmt->getArrayAccessFor(PossibleLoad0));\n  if (PossibleLoad1 && PossibleLoad1->getNumUses() == 1)\n    if (PossibleLoad1->getParent() == Store->getParent())\n      Loads.push_back(&Stmt->getArrayAccessFor(PossibleLoad1));\n}\n\n/// Find the canonical scop array info object for a set of invariant load\n/// hoisted loads. The canonical array is the one that corresponds to the\n/// first load in the list of accesses which is used as base pointer of a\n/// scop array.\nstatic const ScopArrayInfo *findCanonicalArray(Scop &S,\n                                               MemoryAccessList &Accesses) {\n  for (MemoryAccess *Access : Accesses) {\n    const ScopArrayInfo *CanonicalArray = S.getScopArrayInfoOrNull(\n        Access->getAccessInstruction(), MemoryKind::Array);\n    if (CanonicalArray)\n      return CanonicalArray;\n  }\n  return nullptr;\n}\n\n/// Check if @p Array severs as base array in an invariant load.\nstatic bool isUsedForIndirectHoistedLoad(Scop &S, const ScopArrayInfo *Array) {\n  for (InvariantEquivClassTy &EqClass2 : S.getInvariantAccesses())\n    for (MemoryAccess *Access2 : EqClass2.InvariantAccesses)\n      if (Access2->getScopArrayInfo() == Array)\n        return true;\n  return false;\n}\n\n/// Replace the base pointer arrays in all memory accesses referencing @p Old,\n/// with a reference to @p New.\nstatic void replaceBasePtrArrays(Scop &S, const ScopArrayInfo *Old,\n                                 const ScopArrayInfo *New) {\n  for (ScopStmt &Stmt : S)\n    for (MemoryAccess *Access : Stmt) {\n      if (Access->getLatestScopArrayInfo() != Old)\n        continue;\n\n      isl::id Id = New->getBasePtrId();\n      isl::map Map = Access->getAccessRelation();\n      Map = Map.set_tuple_id(isl::dim::out, Id);\n      Access->setAccessRelation(Map);\n    }\n}\n\nvoid ScopBuilder::canonicalizeDynamicBasePtrs() {\n  for (InvariantEquivClassTy &EqClass : scop->InvariantEquivClasses) {\n    MemoryAccessList &BasePtrAccesses = EqClass.InvariantAccesses;\n\n    const ScopArrayInfo *CanonicalBasePtrSAI =\n        findCanonicalArray(*scop, BasePtrAccesses);\n\n    if (!CanonicalBasePtrSAI)\n      continue;\n\n    for (MemoryAccess *BasePtrAccess : BasePtrAccesses) {\n      const ScopArrayInfo *BasePtrSAI = scop->getScopArrayInfoOrNull(\n          BasePtrAccess->getAccessInstruction(), MemoryKind::Array);\n      if (!BasePtrSAI || BasePtrSAI == CanonicalBasePtrSAI ||\n          !BasePtrSAI->isCompatibleWith(CanonicalBasePtrSAI))\n        continue;\n\n      // we currently do not canonicalize arrays where some accesses are\n      // hoisted as invariant loads. If we would, we need to update the access\n      // function of the invariant loads as well. However, as this is not a\n      // very common situation, we leave this for now to avoid further\n      // complexity increases.\n      if (isUsedForIndirectHoistedLoad(*scop, BasePtrSAI))\n        continue;\n\n      replaceBasePtrArrays(*scop, BasePtrSAI, CanonicalBasePtrSAI);\n    }\n  }\n}\n\nvoid ScopBuilder::buildAccessRelations(ScopStmt &Stmt) {\n  for (MemoryAccess *Access : Stmt.MemAccs) {\n    Type *ElementType = Access->getElementType();\n\n    MemoryKind Ty;\n    if (Access->isPHIKind())\n      Ty = MemoryKind::PHI;\n    else if (Access->isExitPHIKind())\n      Ty = MemoryKind::ExitPHI;\n    else if (Access->isValueKind())\n      Ty = MemoryKind::Value;\n    else\n      Ty = MemoryKind::Array;\n\n    // Create isl::pw_aff for SCEVs which describe sizes. Collect all\n    // assumptions which are taken. isl::pw_aff objects are cached internally\n    // and they are used later by scop.\n    for (const SCEV *Size : Access->Sizes) {\n      if (!Size)\n        continue;\n      scop->getPwAff(Size, nullptr, false, &RecordedAssumptions);\n    }\n    auto *SAI = scop->getOrCreateScopArrayInfo(Access->getOriginalBaseAddr(),\n                                               ElementType, Access->Sizes, Ty);\n\n    // Create isl::pw_aff for SCEVs which describe subscripts. Collect all\n    // assumptions which are taken. isl::pw_aff objects are cached internally\n    // and they are used later by scop.\n    for (const SCEV *Subscript : Access->subscripts()) {\n      if (!Access->isAffine() || !Subscript)\n        continue;\n      scop->getPwAff(Subscript, Stmt.getEntryBlock(), false,\n                     &RecordedAssumptions);\n    }\n    Access->buildAccessRelation(SAI);\n    scop->addAccessData(Access);\n  }\n}\n\n/// Add the minimal/maximal access in @p Set to @p User.\n///\n/// @return True if more accesses should be added, false if we reached the\n///         maximal number of run-time checks to be generated.\nstatic bool buildMinMaxAccess(isl::set Set,\n                              Scop::MinMaxVectorTy &MinMaxAccesses, Scop &S) {\n  isl::pw_multi_aff MinPMA, MaxPMA;\n  isl::pw_aff LastDimAff;\n  isl::aff OneAff;\n  unsigned Pos;\n\n  Set = Set.remove_divs();\n  polly::simplify(Set);\n\n  if (Set.n_basic_set() > RunTimeChecksMaxAccessDisjuncts)\n    Set = Set.simple_hull();\n\n  // Restrict the number of parameters involved in the access as the lexmin/\n  // lexmax computation will take too long if this number is high.\n  //\n  // Experiments with a simple test case using an i7 4800MQ:\n  //\n  //  #Parameters involved | Time (in sec)\n  //            6          |     0.01\n  //            7          |     0.04\n  //            8          |     0.12\n  //            9          |     0.40\n  //           10          |     1.54\n  //           11          |     6.78\n  //           12          |    30.38\n  //\n  if (isl_set_n_param(Set.get()) >\n      static_cast<isl_size>(RunTimeChecksMaxParameters)) {\n    unsigned InvolvedParams = 0;\n    for (unsigned u = 0, e = isl_set_n_param(Set.get()); u < e; u++)\n      if (Set.involves_dims(isl::dim::param, u, 1))\n        InvolvedParams++;\n\n    if (InvolvedParams > RunTimeChecksMaxParameters)\n      return false;\n  }\n\n  MinPMA = Set.lexmin_pw_multi_aff();\n  MaxPMA = Set.lexmax_pw_multi_aff();\n\n  MinPMA = MinPMA.coalesce();\n  MaxPMA = MaxPMA.coalesce();\n\n  // Adjust the last dimension of the maximal access by one as we want to\n  // enclose the accessed memory region by MinPMA and MaxPMA. The pointer\n  // we test during code generation might now point after the end of the\n  // allocated array but we will never dereference it anyway.\n  assert((!MaxPMA || MaxPMA.dim(isl::dim::out)) &&\n         \"Assumed at least one output dimension\");\n\n  Pos = MaxPMA.dim(isl::dim::out) - 1;\n  LastDimAff = MaxPMA.get_pw_aff(Pos);\n  OneAff = isl::aff(isl::local_space(LastDimAff.get_domain_space()));\n  OneAff = OneAff.add_constant_si(1);\n  LastDimAff = LastDimAff.add(OneAff);\n  MaxPMA = MaxPMA.set_pw_aff(Pos, LastDimAff);\n\n  if (!MinPMA || !MaxPMA)\n    return false;\n\n  MinMaxAccesses.push_back(std::make_pair(MinPMA, MaxPMA));\n\n  return true;\n}\n\n/// Wrapper function to calculate minimal/maximal accesses to each array.\nbool ScopBuilder::calculateMinMaxAccess(AliasGroupTy AliasGroup,\n                                        Scop::MinMaxVectorTy &MinMaxAccesses) {\n  MinMaxAccesses.reserve(AliasGroup.size());\n\n  isl::union_set Domains = scop->getDomains();\n  isl::union_map Accesses = isl::union_map::empty(scop->getParamSpace());\n\n  for (MemoryAccess *MA : AliasGroup)\n    Accesses = Accesses.add_map(MA->getAccessRelation());\n\n  Accesses = Accesses.intersect_domain(Domains);\n  isl::union_set Locations = Accesses.range();\n\n  bool LimitReached = false;\n  for (isl::set Set : Locations.get_set_list()) {\n    LimitReached |= !buildMinMaxAccess(Set, MinMaxAccesses, *scop);\n    if (LimitReached)\n      break;\n  }\n\n  return !LimitReached;\n}\n\nstatic isl::set getAccessDomain(MemoryAccess *MA) {\n  isl::set Domain = MA->getStatement()->getDomain();\n  Domain = Domain.project_out(isl::dim::set, 0, Domain.n_dim());\n  return Domain.reset_tuple_id();\n}\n\nbool ScopBuilder::buildAliasChecks() {\n  if (!PollyUseRuntimeAliasChecks)\n    return true;\n\n  if (buildAliasGroups()) {\n    // Aliasing assumptions do not go through addAssumption but we still want to\n    // collect statistics so we do it here explicitly.\n    if (scop->getAliasGroups().size())\n      Scop::incrementNumberOfAliasingAssumptions(1);\n    return true;\n  }\n\n  // If a problem occurs while building the alias groups we need to delete\n  // this SCoP and pretend it wasn't valid in the first place. To this end\n  // we make the assumed context infeasible.\n  scop->invalidate(ALIASING, DebugLoc());\n\n  LLVM_DEBUG(\n      dbgs() << \"\\n\\nNOTE: Run time checks for \" << scop->getNameStr()\n             << \" could not be created as the number of parameters involved \"\n                \"is too high. The SCoP will be \"\n                \"dismissed.\\nUse:\\n\\t--polly-rtc-max-parameters=X\\nto adjust \"\n                \"the maximal number of parameters but be advised that the \"\n                \"compile time might increase exponentially.\\n\\n\");\n  return false;\n}\n\nstd::tuple<ScopBuilder::AliasGroupVectorTy, DenseSet<const ScopArrayInfo *>>\nScopBuilder::buildAliasGroupsForAccesses() {\n  AliasSetTracker AST(AA);\n\n  DenseMap<Value *, MemoryAccess *> PtrToAcc;\n  DenseSet<const ScopArrayInfo *> HasWriteAccess;\n  for (ScopStmt &Stmt : *scop) {\n\n    isl::set StmtDomain = Stmt.getDomain();\n    bool StmtDomainEmpty = StmtDomain.is_empty();\n\n    // Statements with an empty domain will never be executed.\n    if (StmtDomainEmpty)\n      continue;\n\n    for (MemoryAccess *MA : Stmt) {\n      if (MA->isScalarKind())\n        continue;\n      if (!MA->isRead())\n        HasWriteAccess.insert(MA->getScopArrayInfo());\n      MemAccInst Acc(MA->getAccessInstruction());\n      if (MA->isRead() && isa<MemTransferInst>(Acc))\n        PtrToAcc[cast<MemTransferInst>(Acc)->getRawSource()] = MA;\n      else\n        PtrToAcc[Acc.getPointerOperand()] = MA;\n      AST.add(Acc);\n    }\n  }\n\n  AliasGroupVectorTy AliasGroups;\n  for (AliasSet &AS : AST) {\n    if (AS.isMustAlias() || AS.isForwardingAliasSet())\n      continue;\n    AliasGroupTy AG;\n    for (auto &PR : AS)\n      AG.push_back(PtrToAcc[PR.getValue()]);\n    if (AG.size() < 2)\n      continue;\n    AliasGroups.push_back(std::move(AG));\n  }\n\n  return std::make_tuple(AliasGroups, HasWriteAccess);\n}\n\nbool ScopBuilder::buildAliasGroups() {\n  // To create sound alias checks we perform the following steps:\n  //   o) We partition each group into read only and non read only accesses.\n  //   o) For each group with more than one base pointer we then compute minimal\n  //      and maximal accesses to each array of a group in read only and non\n  //      read only partitions separately.\n  AliasGroupVectorTy AliasGroups;\n  DenseSet<const ScopArrayInfo *> HasWriteAccess;\n\n  std::tie(AliasGroups, HasWriteAccess) = buildAliasGroupsForAccesses();\n\n  splitAliasGroupsByDomain(AliasGroups);\n\n  for (AliasGroupTy &AG : AliasGroups) {\n    if (!scop->hasFeasibleRuntimeContext())\n      return false;\n\n    {\n      IslMaxOperationsGuard MaxOpGuard(scop->getIslCtx().get(), OptComputeOut);\n      bool Valid = buildAliasGroup(AG, HasWriteAccess);\n      if (!Valid)\n        return false;\n    }\n    if (isl_ctx_last_error(scop->getIslCtx().get()) == isl_error_quota) {\n      scop->invalidate(COMPLEXITY, DebugLoc());\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool ScopBuilder::buildAliasGroup(\n    AliasGroupTy &AliasGroup, DenseSet<const ScopArrayInfo *> HasWriteAccess) {\n  AliasGroupTy ReadOnlyAccesses;\n  AliasGroupTy ReadWriteAccesses;\n  SmallPtrSet<const ScopArrayInfo *, 4> ReadWriteArrays;\n  SmallPtrSet<const ScopArrayInfo *, 4> ReadOnlyArrays;\n\n  if (AliasGroup.size() < 2)\n    return true;\n\n  for (MemoryAccess *Access : AliasGroup) {\n    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"PossibleAlias\",\n                                        Access->getAccessInstruction())\n             << \"Possibly aliasing pointer, use restrict keyword.\");\n    const ScopArrayInfo *Array = Access->getScopArrayInfo();\n    if (HasWriteAccess.count(Array)) {\n      ReadWriteArrays.insert(Array);\n      ReadWriteAccesses.push_back(Access);\n    } else {\n      ReadOnlyArrays.insert(Array);\n      ReadOnlyAccesses.push_back(Access);\n    }\n  }\n\n  // If there are no read-only pointers, and less than two read-write pointers,\n  // no alias check is needed.\n  if (ReadOnlyAccesses.empty() && ReadWriteArrays.size() <= 1)\n    return true;\n\n  // If there is no read-write pointer, no alias check is needed.\n  if (ReadWriteArrays.empty())\n    return true;\n\n  // For non-affine accesses, no alias check can be generated as we cannot\n  // compute a sufficiently tight lower and upper bound: bail out.\n  for (MemoryAccess *MA : AliasGroup) {\n    if (!MA->isAffine()) {\n      scop->invalidate(ALIASING, MA->getAccessInstruction()->getDebugLoc(),\n                       MA->getAccessInstruction()->getParent());\n      return false;\n    }\n  }\n\n  // Ensure that for all memory accesses for which we generate alias checks,\n  // their base pointers are available.\n  for (MemoryAccess *MA : AliasGroup) {\n    if (MemoryAccess *BasePtrMA = scop->lookupBasePtrAccess(MA))\n      scop->addRequiredInvariantLoad(\n          cast<LoadInst>(BasePtrMA->getAccessInstruction()));\n  }\n\n  //  scop->getAliasGroups().emplace_back();\n  //  Scop::MinMaxVectorPairTy &pair = scop->getAliasGroups().back();\n  Scop::MinMaxVectorTy MinMaxAccessesReadWrite;\n  Scop::MinMaxVectorTy MinMaxAccessesReadOnly;\n\n  bool Valid;\n\n  Valid = calculateMinMaxAccess(ReadWriteAccesses, MinMaxAccessesReadWrite);\n\n  if (!Valid)\n    return false;\n\n  // Bail out if the number of values we need to compare is too large.\n  // This is important as the number of comparisons grows quadratically with\n  // the number of values we need to compare.\n  if (MinMaxAccessesReadWrite.size() + ReadOnlyArrays.size() >\n      RunTimeChecksMaxArraysPerGroup)\n    return false;\n\n  Valid = calculateMinMaxAccess(ReadOnlyAccesses, MinMaxAccessesReadOnly);\n\n  scop->addAliasGroup(MinMaxAccessesReadWrite, MinMaxAccessesReadOnly);\n  if (!Valid)\n    return false;\n\n  return true;\n}\n\nvoid ScopBuilder::splitAliasGroupsByDomain(AliasGroupVectorTy &AliasGroups) {\n  for (unsigned u = 0; u < AliasGroups.size(); u++) {\n    AliasGroupTy NewAG;\n    AliasGroupTy &AG = AliasGroups[u];\n    AliasGroupTy::iterator AGI = AG.begin();\n    isl::set AGDomain = getAccessDomain(*AGI);\n    while (AGI != AG.end()) {\n      MemoryAccess *MA = *AGI;\n      isl::set MADomain = getAccessDomain(MA);\n      if (AGDomain.is_disjoint(MADomain)) {\n        NewAG.push_back(MA);\n        AGI = AG.erase(AGI);\n      } else {\n        AGDomain = AGDomain.unite(MADomain);\n        AGI++;\n      }\n    }\n    if (NewAG.size() > 1)\n      AliasGroups.push_back(std::move(NewAG));\n  }\n}\n\n#ifndef NDEBUG\nstatic void verifyUse(Scop *S, Use &Op, LoopInfo &LI) {\n  auto PhysUse = VirtualUse::create(S, Op, &LI, false);\n  auto VirtUse = VirtualUse::create(S, Op, &LI, true);\n  assert(PhysUse.getKind() == VirtUse.getKind());\n}\n\n/// Check the consistency of every statement's MemoryAccesses.\n///\n/// The check is carried out by expecting the \"physical\" kind of use (derived\n/// from the BasicBlocks instructions resides in) to be same as the \"virtual\"\n/// kind of use (derived from a statement's MemoryAccess).\n///\n/// The \"physical\" uses are taken by ensureValueRead to determine whether to\n/// create MemoryAccesses. When done, the kind of scalar access should be the\n/// same no matter which way it was derived.\n///\n/// The MemoryAccesses might be changed by later SCoP-modifying passes and hence\n/// can intentionally influence on the kind of uses (not corresponding to the\n/// \"physical\" anymore, hence called \"virtual\"). The CodeGenerator therefore has\n/// to pick up the virtual uses. But here in the code generator, this has not\n/// happened yet, such that virtual and physical uses are equivalent.\nstatic void verifyUses(Scop *S, LoopInfo &LI, DominatorTree &DT) {\n  for (auto *BB : S->getRegion().blocks()) {\n    for (auto &Inst : *BB) {\n      auto *Stmt = S->getStmtFor(&Inst);\n      if (!Stmt)\n        continue;\n\n      if (isIgnoredIntrinsic(&Inst))\n        continue;\n\n      // Branch conditions are encoded in the statement domains.\n      if (Inst.isTerminator() && Stmt->isBlockStmt())\n        continue;\n\n      // Verify all uses.\n      for (auto &Op : Inst.operands())\n        verifyUse(S, Op, LI);\n\n      // Stores do not produce values used by other statements.\n      if (isa<StoreInst>(Inst))\n        continue;\n\n      // For every value defined in the block, also check that a use of that\n      // value in the same statement would not be an inter-statement use. It can\n      // still be synthesizable or load-hoisted, but these kind of instructions\n      // are not directly copied in code-generation.\n      auto VirtDef =\n          VirtualUse::create(S, Stmt, Stmt->getSurroundingLoop(), &Inst, true);\n      assert(VirtDef.getKind() == VirtualUse::Synthesizable ||\n             VirtDef.getKind() == VirtualUse::Intra ||\n             VirtDef.getKind() == VirtualUse::Hoisted);\n    }\n  }\n\n  if (S->hasSingleExitEdge())\n    return;\n\n  // PHINodes in the SCoP region's exit block are also uses to be checked.\n  if (!S->getRegion().isTopLevelRegion()) {\n    for (auto &Inst : *S->getRegion().getExit()) {\n      if (!isa<PHINode>(Inst))\n        break;\n\n      for (auto &Op : Inst.operands())\n        verifyUse(S, Op, LI);\n    }\n  }\n}\n#endif\n\nvoid ScopBuilder::buildScop(Region &R, AssumptionCache &AC) {\n  scop.reset(new Scop(R, SE, LI, DT, *SD.getDetectionContext(&R), ORE,\n                      SD.getNextID()));\n\n  buildStmts(R);\n\n  // Create all invariant load instructions first. These are categorized as\n  // 'synthesizable', therefore are not part of any ScopStmt but need to be\n  // created somewhere.\n  const InvariantLoadsSetTy &RIL = scop->getRequiredInvariantLoads();\n  for (BasicBlock *BB : scop->getRegion().blocks()) {\n    if (isErrorBlock(*BB, scop->getRegion(), LI, DT))\n      continue;\n\n    for (Instruction &Inst : *BB) {\n      LoadInst *Load = dyn_cast<LoadInst>(&Inst);\n      if (!Load)\n        continue;\n\n      if (!RIL.count(Load))\n        continue;\n\n      // Invariant loads require a MemoryAccess to be created in some statement.\n      // It is not important to which statement the MemoryAccess is added\n      // because it will later be removed from the ScopStmt again. We chose the\n      // first statement of the basic block the LoadInst is in.\n      ArrayRef<ScopStmt *> List = scop->getStmtListFor(BB);\n      assert(!List.empty());\n      ScopStmt *RILStmt = List.front();\n      buildMemoryAccess(Load, RILStmt);\n    }\n  }\n  buildAccessFunctions();\n\n  // In case the region does not have an exiting block we will later (during\n  // code generation) split the exit block. This will move potential PHI nodes\n  // from the current exit block into the new region exiting block. Hence, PHI\n  // nodes that are at this point not part of the region will be.\n  // To handle these PHI nodes later we will now model their operands as scalar\n  // accesses. Note that we do not model anything in the exit block if we have\n  // an exiting block in the region, as there will not be any splitting later.\n  if (!R.isTopLevelRegion() && !scop->hasSingleExitEdge()) {\n    for (Instruction &Inst : *R.getExit()) {\n      PHINode *PHI = dyn_cast<PHINode>(&Inst);\n      if (!PHI)\n        break;\n\n      buildPHIAccesses(nullptr, PHI, nullptr, true);\n    }\n  }\n\n  // Create memory accesses for global reads since all arrays are now known.\n  auto *AF = SE.getConstant(IntegerType::getInt64Ty(SE.getContext()), 0);\n  for (auto GlobalReadPair : GlobalReads) {\n    ScopStmt *GlobalReadStmt = GlobalReadPair.first;\n    Instruction *GlobalRead = GlobalReadPair.second;\n    for (auto *BP : ArrayBasePointers)\n      addArrayAccess(GlobalReadStmt, MemAccInst(GlobalRead), MemoryAccess::READ,\n                     BP, BP->getType(), false, {AF}, {nullptr}, GlobalRead);\n  }\n\n  buildInvariantEquivalenceClasses();\n\n  /// A map from basic blocks to their invalid domains.\n  DenseMap<BasicBlock *, isl::set> InvalidDomainMap;\n\n  if (!buildDomains(&R, InvalidDomainMap)) {\n    LLVM_DEBUG(\n        dbgs() << \"Bailing-out because buildDomains encountered problems\\n\");\n    return;\n  }\n\n  addUserAssumptions(AC, InvalidDomainMap);\n\n  // Initialize the invalid domain.\n  for (ScopStmt &Stmt : scop->Stmts)\n    if (Stmt.isBlockStmt())\n      Stmt.setInvalidDomain(InvalidDomainMap[Stmt.getEntryBlock()]);\n    else\n      Stmt.setInvalidDomain(InvalidDomainMap[getRegionNodeBasicBlock(\n          Stmt.getRegion()->getNode())]);\n\n  // Remove empty statements.\n  // Exit early in case there are no executable statements left in this scop.\n  scop->removeStmtNotInDomainMap();\n  scop->simplifySCoP(false);\n  if (scop->isEmpty()) {\n    LLVM_DEBUG(dbgs() << \"Bailing-out because SCoP is empty\\n\");\n    return;\n  }\n\n  // The ScopStmts now have enough information to initialize themselves.\n  for (ScopStmt &Stmt : *scop) {\n    collectSurroundingLoops(Stmt);\n\n    buildDomain(Stmt);\n    buildAccessRelations(Stmt);\n\n    if (DetectReductions)\n      checkForReductions(Stmt);\n  }\n\n  // Check early for a feasible runtime context.\n  if (!scop->hasFeasibleRuntimeContext()) {\n    LLVM_DEBUG(dbgs() << \"Bailing-out because of unfeasible context (early)\\n\");\n    return;\n  }\n\n  // Check early for profitability. Afterwards it cannot change anymore,\n  // only the runtime context could become infeasible.\n  if (!scop->isProfitable(UnprofitableScalarAccs)) {\n    scop->invalidate(PROFITABLE, DebugLoc());\n    LLVM_DEBUG(\n        dbgs() << \"Bailing-out because SCoP is not considered profitable\\n\");\n    return;\n  }\n\n  buildSchedule();\n\n  finalizeAccesses();\n\n  scop->realignParams();\n  addUserContext();\n\n  // After the context was fully constructed, thus all our knowledge about\n  // the parameters is in there, we add all recorded assumptions to the\n  // assumed/invalid context.\n  addRecordedAssumptions();\n\n  scop->simplifyContexts();\n  if (!buildAliasChecks()) {\n    LLVM_DEBUG(dbgs() << \"Bailing-out because could not build alias checks\\n\");\n    return;\n  }\n\n  hoistInvariantLoads();\n  canonicalizeDynamicBasePtrs();\n  verifyInvariantLoads();\n  scop->simplifySCoP(true);\n\n  // Check late for a feasible runtime context because profitability did not\n  // change.\n  if (!scop->hasFeasibleRuntimeContext()) {\n    LLVM_DEBUG(dbgs() << \"Bailing-out because of unfeasible context (late)\\n\");\n    return;\n  }\n\n#ifndef NDEBUG\n  verifyUses(scop.get(), LI, DT);\n#endif\n}\n\nScopBuilder::ScopBuilder(Region *R, AssumptionCache &AC, AliasAnalysis &AA,\n                         const DataLayout &DL, DominatorTree &DT, LoopInfo &LI,\n                         ScopDetection &SD, ScalarEvolution &SE,\n                         OptimizationRemarkEmitter &ORE)\n    : AA(AA), DL(DL), DT(DT), LI(LI), SD(SD), SE(SE), ORE(ORE) {\n  DebugLoc Beg, End;\n  auto P = getBBPairForRegion(R);\n  getDebugLocations(P, Beg, End);\n\n  std::string Msg = \"SCoP begins here.\";\n  ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"ScopEntry\", Beg, P.first)\n           << Msg);\n\n  buildScop(*R, AC);\n\n  LLVM_DEBUG(dbgs() << *scop);\n\n  if (!scop->hasFeasibleRuntimeContext()) {\n    InfeasibleScops++;\n    Msg = \"SCoP ends here but was dismissed.\";\n    LLVM_DEBUG(dbgs() << \"SCoP detected but dismissed\\n\");\n    RecordedAssumptions.clear();\n    scop.reset();\n  } else {\n    Msg = \"SCoP ends here.\";\n    ++ScopFound;\n    if (scop->getMaxLoopDepth() > 0)\n      ++RichScopFound;\n  }\n\n  if (R->isTopLevelRegion())\n    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"ScopEnd\", End, P.first)\n             << Msg);\n  else\n    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, \"ScopEnd\", End, P.second)\n             << Msg);\n}\n"}}, "reports": [{"events": [{"location": {"col": 37, "file": 60, "line": 775}, "message": "destructor '~LoopStackElement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopBuilder.h", "reportHash": "795ee5f1fde4c5eab988bbb46f818360", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 64, "line": 2231}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopBuilder.cpp", "reportHash": "40ce6d384f0415fa31b2d55628946dfe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 64, "line": 2231}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/Analysis/ScopBuilder.cpp", "reportHash": "d28bcb63d370e490c9003fa980d10d46", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
