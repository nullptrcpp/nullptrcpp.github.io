<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PatternMatch.h", "content": "//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides a simple and efficient mechanism for performing general\n// tree-based pattern matches on the LLVM IR. The power of these routines is\n// that it allows you to write concise patterns that are expressive and easy to\n// understand. The other major advantage of this is that it allows you to\n// trivially capture/bind elements in the pattern to variables. For example,\n// you can do something like this:\n//\n//  Value *Exp = ...\n//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X & C1) | (Y & C2)\n//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),\n//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {\n//    ... Pattern is matched and variables are bound ...\n//  }\n//\n// This is primarily useful to things like the instruction combiner, but can\n// also be useful for static analysis tools or code generators.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PATTERNMATCH_H\n#define LLVM_IR_PATTERNMATCH_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cstdint>\n\nnamespace llvm {\nnamespace PatternMatch {\n\ntemplate <typename Val, typename Pattern> bool match(Val *V, const Pattern &P) {\n  return const_cast<Pattern &>(P).match(V);\n}\n\ntemplate <typename Pattern> bool match(ArrayRef<int> Mask, const Pattern &P) {\n  return const_cast<Pattern &>(P).match(Mask);\n}\n\ntemplate <typename SubPattern_t> struct OneUse_match {\n  SubPattern_t SubPattern;\n\n  OneUse_match(const SubPattern_t &SP) : SubPattern(SP) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    return V->hasOneUse() && SubPattern.match(V);\n  }\n};\n\ntemplate <typename T> inline OneUse_match<T> m_OneUse(const T &SubPattern) {\n  return SubPattern;\n}\n\ntemplate <typename Class> struct class_match {\n  template <typename ITy> bool match(ITy *V) { return isa<Class>(V); }\n};\n\n/// Match an arbitrary value and ignore it.\ninline class_match<Value> m_Value() { return class_match<Value>(); }\n\n/// Match an arbitrary unary operation and ignore it.\ninline class_match<UnaryOperator> m_UnOp() {\n  return class_match<UnaryOperator>();\n}\n\n/// Match an arbitrary binary operation and ignore it.\ninline class_match<BinaryOperator> m_BinOp() {\n  return class_match<BinaryOperator>();\n}\n\n/// Matches any compare instruction and ignore it.\ninline class_match<CmpInst> m_Cmp() { return class_match<CmpInst>(); }\n\n/// Match an arbitrary undef constant.\ninline class_match<UndefValue> m_Undef() { return class_match<UndefValue>(); }\n\n/// Match an arbitrary poison constant.\ninline class_match<PoisonValue> m_Poison() { return class_match<PoisonValue>(); }\n\n/// Match an arbitrary Constant and ignore it.\ninline class_match<Constant> m_Constant() { return class_match<Constant>(); }\n\n/// Match an arbitrary ConstantInt and ignore it.\ninline class_match<ConstantInt> m_ConstantInt() {\n  return class_match<ConstantInt>();\n}\n\n/// Match an arbitrary ConstantFP and ignore it.\ninline class_match<ConstantFP> m_ConstantFP() {\n  return class_match<ConstantFP>();\n}\n\n/// Match an arbitrary ConstantExpr and ignore it.\ninline class_match<ConstantExpr> m_ConstantExpr() {\n  return class_match<ConstantExpr>();\n}\n\n/// Match an arbitrary basic block value and ignore it.\ninline class_match<BasicBlock> m_BasicBlock() {\n  return class_match<BasicBlock>();\n}\n\n/// Inverting matcher\ntemplate <typename Ty> struct match_unless {\n  Ty M;\n\n  match_unless(const Ty &Matcher) : M(Matcher) {}\n\n  template <typename ITy> bool match(ITy *V) { return !M.match(V); }\n};\n\n/// Match if the inner matcher does *NOT* match.\ntemplate <typename Ty> inline match_unless<Ty> m_Unless(const Ty &M) {\n  return match_unless<Ty>(M);\n}\n\n/// Matching combinators\ntemplate <typename LTy, typename RTy> struct match_combine_or {\n  LTy L;\n  RTy R;\n\n  match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (L.match(V))\n      return true;\n    if (R.match(V))\n      return true;\n    return false;\n  }\n};\n\ntemplate <typename LTy, typename RTy> struct match_combine_and {\n  LTy L;\n  RTy R;\n\n  match_combine_and(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (L.match(V))\n      if (R.match(V))\n        return true;\n    return false;\n  }\n};\n\n/// Combine two pattern matchers matching L || R\ntemplate <typename LTy, typename RTy>\ninline match_combine_or<LTy, RTy> m_CombineOr(const LTy &L, const RTy &R) {\n  return match_combine_or<LTy, RTy>(L, R);\n}\n\n/// Combine two pattern matchers matching L && R\ntemplate <typename LTy, typename RTy>\ninline match_combine_and<LTy, RTy> m_CombineAnd(const LTy &L, const RTy &R) {\n  return match_combine_and<LTy, RTy>(L, R);\n}\n\nstruct apint_match {\n  const APInt *&Res;\n  bool AllowUndef;\n\n  apint_match(const APInt *&Res, bool AllowUndef)\n    : Res(Res), AllowUndef(AllowUndef) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (auto *CI = dyn_cast<ConstantInt>(V)) {\n      Res = &CI->getValue();\n      return true;\n    }\n    if (V->getType()->isVectorTy())\n      if (const auto *C = dyn_cast<Constant>(V))\n        if (auto *CI = dyn_cast_or_null<ConstantInt>(\n                C->getSplatValue(AllowUndef))) {\n          Res = &CI->getValue();\n          return true;\n        }\n    return false;\n  }\n};\n// Either constexpr if or renaming ConstantFP::getValueAPF to\n// ConstantFP::getValue is needed to do it via single template\n// function for both apint/apfloat.\nstruct apfloat_match {\n  const APFloat *&Res;\n  bool AllowUndef;\n\n  apfloat_match(const APFloat *&Res, bool AllowUndef)\n      : Res(Res), AllowUndef(AllowUndef) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (auto *CI = dyn_cast<ConstantFP>(V)) {\n      Res = &CI->getValueAPF();\n      return true;\n    }\n    if (V->getType()->isVectorTy())\n      if (const auto *C = dyn_cast<Constant>(V))\n        if (auto *CI = dyn_cast_or_null<ConstantFP>(\n                C->getSplatValue(AllowUndef))) {\n          Res = &CI->getValueAPF();\n          return true;\n        }\n    return false;\n  }\n};\n\n/// Match a ConstantInt or splatted ConstantVector, binding the\n/// specified pointer to the contained APInt.\ninline apint_match m_APInt(const APInt *&Res) {\n  // Forbid undefs by default to maintain previous behavior.\n  return apint_match(Res, /* AllowUndef */ false);\n}\n\n/// Match APInt while allowing undefs in splat vector constants.\ninline apint_match m_APIntAllowUndef(const APInt *&Res) {\n  return apint_match(Res, /* AllowUndef */ true);\n}\n\n/// Match APInt while forbidding undefs in splat vector constants.\ninline apint_match m_APIntForbidUndef(const APInt *&Res) {\n  return apint_match(Res, /* AllowUndef */ false);\n}\n\n/// Match a ConstantFP or splatted ConstantVector, binding the\n/// specified pointer to the contained APFloat.\ninline apfloat_match m_APFloat(const APFloat *&Res) {\n  // Forbid undefs by default to maintain previous behavior.\n  return apfloat_match(Res, /* AllowUndef */ false);\n}\n\n/// Match APFloat while allowing undefs in splat vector constants.\ninline apfloat_match m_APFloatAllowUndef(const APFloat *&Res) {\n  return apfloat_match(Res, /* AllowUndef */ true);\n}\n\n/// Match APFloat while forbidding undefs in splat vector constants.\ninline apfloat_match m_APFloatForbidUndef(const APFloat *&Res) {\n  return apfloat_match(Res, /* AllowUndef */ false);\n}\n\ntemplate <int64_t Val> struct constantint_match {\n  template <typename ITy> bool match(ITy *V) {\n    if (const auto *CI = dyn_cast<ConstantInt>(V)) {\n      const APInt &CIV = CI->getValue();\n      if (Val >= 0)\n        return CIV == static_cast<uint64_t>(Val);\n      // If Val is negative, and CI is shorter than it, truncate to the right\n      // number of bits.  If it is larger, then we have to sign extend.  Just\n      // compare their negated values.\n      return -CIV == -Val;\n    }\n    return false;\n  }\n};\n\n/// Match a ConstantInt with a specific value.\ntemplate <int64_t Val> inline constantint_match<Val> m_ConstantInt() {\n  return constantint_match<Val>();\n}\n\n/// This helper class is used to match constant scalars, vector splats,\n/// and fixed width vectors that satisfy a specified predicate.\n/// For fixed width vector constants, undefined elements are ignored.\ntemplate <typename Predicate, typename ConstantVal>\nstruct cstval_pred_ty : public Predicate {\n  template <typename ITy> bool match(ITy *V) {\n    if (const auto *CV = dyn_cast<ConstantVal>(V))\n      return this->isValue(CV->getValue());\n    if (const auto *VTy = dyn_cast<VectorType>(V->getType())) {\n      if (const auto *C = dyn_cast<Constant>(V)) {\n        if (const auto *CV = dyn_cast_or_null<ConstantVal>(C->getSplatValue()))\n          return this->isValue(CV->getValue());\n\n        // Number of elements of a scalable vector unknown at compile time\n        auto *FVTy = dyn_cast<FixedVectorType>(VTy);\n        if (!FVTy)\n          return false;\n\n        // Non-splat vector constant: check each element for a match.\n        unsigned NumElts = FVTy->getNumElements();\n        assert(NumElts != 0 && \"Constant vector with no elements?\");\n        bool HasNonUndefElements = false;\n        for (unsigned i = 0; i != NumElts; ++i) {\n          Constant *Elt = C->getAggregateElement(i);\n          if (!Elt)\n            return false;\n          if (isa<UndefValue>(Elt))\n            continue;\n          auto *CV = dyn_cast<ConstantVal>(Elt);\n          if (!CV || !this->isValue(CV->getValue()))\n            return false;\n          HasNonUndefElements = true;\n        }\n        return HasNonUndefElements;\n      }\n    }\n    return false;\n  }\n};\n\n/// specialization of cstval_pred_ty for ConstantInt\ntemplate <typename Predicate>\nusing cst_pred_ty = cstval_pred_ty<Predicate, ConstantInt>;\n\n/// specialization of cstval_pred_ty for ConstantFP\ntemplate <typename Predicate>\nusing cstfp_pred_ty = cstval_pred_ty<Predicate, ConstantFP>;\n\n/// This helper class is used to match scalar and vector constants that\n/// satisfy a specified predicate, and bind them to an APInt.\ntemplate <typename Predicate> struct api_pred_ty : public Predicate {\n  const APInt *&Res;\n\n  api_pred_ty(const APInt *&R) : Res(R) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (const auto *CI = dyn_cast<ConstantInt>(V))\n      if (this->isValue(CI->getValue())) {\n        Res = &CI->getValue();\n        return true;\n      }\n    if (V->getType()->isVectorTy())\n      if (const auto *C = dyn_cast<Constant>(V))\n        if (auto *CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue()))\n          if (this->isValue(CI->getValue())) {\n            Res = &CI->getValue();\n            return true;\n          }\n\n    return false;\n  }\n};\n\n/// This helper class is used to match scalar and vector constants that\n/// satisfy a specified predicate, and bind them to an APFloat.\n/// Undefs are allowed in splat vector constants.\ntemplate <typename Predicate> struct apf_pred_ty : public Predicate {\n  const APFloat *&Res;\n\n  apf_pred_ty(const APFloat *&R) : Res(R) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (const auto *CI = dyn_cast<ConstantFP>(V))\n      if (this->isValue(CI->getValue())) {\n        Res = &CI->getValue();\n        return true;\n      }\n    if (V->getType()->isVectorTy())\n      if (const auto *C = dyn_cast<Constant>(V))\n        if (auto *CI = dyn_cast_or_null<ConstantFP>(\n                C->getSplatValue(/* AllowUndef */ true)))\n          if (this->isValue(CI->getValue())) {\n            Res = &CI->getValue();\n            return true;\n          }\n\n    return false;\n  }\n};\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encapsulate constant value queries for use in templated predicate matchers.\n// This allows checking if constants match using compound predicates and works\n// with vector constants, possibly with relaxed constraints. For example, ignore\n// undef values.\n//\n///////////////////////////////////////////////////////////////////////////////\n\nstruct is_any_apint {\n  bool isValue(const APInt &C) { return true; }\n};\n/// Match an integer or vector with any integral constant.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_any_apint> m_AnyIntegralConstant() {\n  return cst_pred_ty<is_any_apint>();\n}\n\nstruct is_all_ones {\n  bool isValue(const APInt &C) { return C.isAllOnesValue(); }\n};\n/// Match an integer or vector with all bits set.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_all_ones> m_AllOnes() {\n  return cst_pred_ty<is_all_ones>();\n}\n\nstruct is_maxsignedvalue {\n  bool isValue(const APInt &C) { return C.isMaxSignedValue(); }\n};\n/// Match an integer or vector with values having all bits except for the high\n/// bit set (0x7f...).\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_maxsignedvalue> m_MaxSignedValue() {\n  return cst_pred_ty<is_maxsignedvalue>();\n}\ninline api_pred_ty<is_maxsignedvalue> m_MaxSignedValue(const APInt *&V) {\n  return V;\n}\n\nstruct is_negative {\n  bool isValue(const APInt &C) { return C.isNegative(); }\n};\n/// Match an integer or vector of negative values.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_negative> m_Negative() {\n  return cst_pred_ty<is_negative>();\n}\ninline api_pred_ty<is_negative> m_Negative(const APInt *&V) {\n  return V;\n}\n\nstruct is_nonnegative {\n  bool isValue(const APInt &C) { return C.isNonNegative(); }\n};\n/// Match an integer or vector of non-negative values.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_nonnegative> m_NonNegative() {\n  return cst_pred_ty<is_nonnegative>();\n}\ninline api_pred_ty<is_nonnegative> m_NonNegative(const APInt *&V) {\n  return V;\n}\n\nstruct is_strictlypositive {\n  bool isValue(const APInt &C) { return C.isStrictlyPositive(); }\n};\n/// Match an integer or vector of strictly positive values.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_strictlypositive> m_StrictlyPositive() {\n  return cst_pred_ty<is_strictlypositive>();\n}\ninline api_pred_ty<is_strictlypositive> m_StrictlyPositive(const APInt *&V) {\n  return V;\n}\n\nstruct is_nonpositive {\n  bool isValue(const APInt &C) { return C.isNonPositive(); }\n};\n/// Match an integer or vector of non-positive values.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_nonpositive> m_NonPositive() {\n  return cst_pred_ty<is_nonpositive>();\n}\ninline api_pred_ty<is_nonpositive> m_NonPositive(const APInt *&V) { return V; }\n\nstruct is_one {\n  bool isValue(const APInt &C) { return C.isOneValue(); }\n};\n/// Match an integer 1 or a vector with all elements equal to 1.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_one> m_One() {\n  return cst_pred_ty<is_one>();\n}\n\nstruct is_zero_int {\n  bool isValue(const APInt &C) { return C.isNullValue(); }\n};\n/// Match an integer 0 or a vector with all elements equal to 0.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_zero_int> m_ZeroInt() {\n  return cst_pred_ty<is_zero_int>();\n}\n\nstruct is_zero {\n  template <typename ITy> bool match(ITy *V) {\n    auto *C = dyn_cast<Constant>(V);\n    // FIXME: this should be able to do something for scalable vectors\n    return C && (C->isNullValue() || cst_pred_ty<is_zero_int>().match(C));\n  }\n};\n/// Match any null constant or a vector with all elements equal to 0.\n/// For vectors, this includes constants with undefined elements.\ninline is_zero m_Zero() {\n  return is_zero();\n}\n\nstruct is_power2 {\n  bool isValue(const APInt &C) { return C.isPowerOf2(); }\n};\n/// Match an integer or vector power-of-2.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_power2> m_Power2() {\n  return cst_pred_ty<is_power2>();\n}\ninline api_pred_ty<is_power2> m_Power2(const APInt *&V) {\n  return V;\n}\n\nstruct is_negated_power2 {\n  bool isValue(const APInt &C) { return (-C).isPowerOf2(); }\n};\n/// Match a integer or vector negated power-of-2.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_negated_power2> m_NegatedPower2() {\n  return cst_pred_ty<is_negated_power2>();\n}\ninline api_pred_ty<is_negated_power2> m_NegatedPower2(const APInt *&V) {\n  return V;\n}\n\nstruct is_power2_or_zero {\n  bool isValue(const APInt &C) { return !C || C.isPowerOf2(); }\n};\n/// Match an integer or vector of 0 or power-of-2 values.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_power2_or_zero> m_Power2OrZero() {\n  return cst_pred_ty<is_power2_or_zero>();\n}\ninline api_pred_ty<is_power2_or_zero> m_Power2OrZero(const APInt *&V) {\n  return V;\n}\n\nstruct is_sign_mask {\n  bool isValue(const APInt &C) { return C.isSignMask(); }\n};\n/// Match an integer or vector with only the sign bit(s) set.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_sign_mask> m_SignMask() {\n  return cst_pred_ty<is_sign_mask>();\n}\n\nstruct is_lowbit_mask {\n  bool isValue(const APInt &C) { return C.isMask(); }\n};\n/// Match an integer or vector with only the low bit(s) set.\n/// For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<is_lowbit_mask> m_LowBitMask() {\n  return cst_pred_ty<is_lowbit_mask>();\n}\n\nstruct icmp_pred_with_threshold {\n  ICmpInst::Predicate Pred;\n  const APInt *Thr;\n  bool isValue(const APInt &C) {\n    switch (Pred) {\n    case ICmpInst::Predicate::ICMP_EQ:\n      return C.eq(*Thr);\n    case ICmpInst::Predicate::ICMP_NE:\n      return C.ne(*Thr);\n    case ICmpInst::Predicate::ICMP_UGT:\n      return C.ugt(*Thr);\n    case ICmpInst::Predicate::ICMP_UGE:\n      return C.uge(*Thr);\n    case ICmpInst::Predicate::ICMP_ULT:\n      return C.ult(*Thr);\n    case ICmpInst::Predicate::ICMP_ULE:\n      return C.ule(*Thr);\n    case ICmpInst::Predicate::ICMP_SGT:\n      return C.sgt(*Thr);\n    case ICmpInst::Predicate::ICMP_SGE:\n      return C.sge(*Thr);\n    case ICmpInst::Predicate::ICMP_SLT:\n      return C.slt(*Thr);\n    case ICmpInst::Predicate::ICMP_SLE:\n      return C.sle(*Thr);\n    default:\n      llvm_unreachable(\"Unhandled ICmp predicate\");\n    }\n  }\n};\n/// Match an integer or vector with every element comparing 'pred' (eg/ne/...)\n/// to Threshold. For vectors, this includes constants with undefined elements.\ninline cst_pred_ty<icmp_pred_with_threshold>\nm_SpecificInt_ICMP(ICmpInst::Predicate Predicate, const APInt &Threshold) {\n  cst_pred_ty<icmp_pred_with_threshold> P;\n  P.Pred = Predicate;\n  P.Thr = &Threshold;\n  return P;\n}\n\nstruct is_nan {\n  bool isValue(const APFloat &C) { return C.isNaN(); }\n};\n/// Match an arbitrary NaN constant. This includes quiet and signalling nans.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_nan> m_NaN() {\n  return cstfp_pred_ty<is_nan>();\n}\n\nstruct is_nonnan {\n  bool isValue(const APFloat &C) { return !C.isNaN(); }\n};\n/// Match a non-NaN FP constant.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_nonnan> m_NonNaN() {\n  return cstfp_pred_ty<is_nonnan>();\n}\n\nstruct is_inf {\n  bool isValue(const APFloat &C) { return C.isInfinity(); }\n};\n/// Match a positive or negative infinity FP constant.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_inf> m_Inf() {\n  return cstfp_pred_ty<is_inf>();\n}\n\nstruct is_noninf {\n  bool isValue(const APFloat &C) { return !C.isInfinity(); }\n};\n/// Match a non-infinity FP constant, i.e. finite or NaN.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_noninf> m_NonInf() {\n  return cstfp_pred_ty<is_noninf>();\n}\n\nstruct is_finite {\n  bool isValue(const APFloat &C) { return C.isFinite(); }\n};\n/// Match a finite FP constant, i.e. not infinity or NaN.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_finite> m_Finite() {\n  return cstfp_pred_ty<is_finite>();\n}\ninline apf_pred_ty<is_finite> m_Finite(const APFloat *&V) { return V; }\n\nstruct is_finitenonzero {\n  bool isValue(const APFloat &C) { return C.isFiniteNonZero(); }\n};\n/// Match a finite non-zero FP constant.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_finitenonzero> m_FiniteNonZero() {\n  return cstfp_pred_ty<is_finitenonzero>();\n}\ninline apf_pred_ty<is_finitenonzero> m_FiniteNonZero(const APFloat *&V) {\n  return V;\n}\n\nstruct is_any_zero_fp {\n  bool isValue(const APFloat &C) { return C.isZero(); }\n};\n/// Match a floating-point negative zero or positive zero.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_any_zero_fp> m_AnyZeroFP() {\n  return cstfp_pred_ty<is_any_zero_fp>();\n}\n\nstruct is_pos_zero_fp {\n  bool isValue(const APFloat &C) { return C.isPosZero(); }\n};\n/// Match a floating-point positive zero.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_pos_zero_fp> m_PosZeroFP() {\n  return cstfp_pred_ty<is_pos_zero_fp>();\n}\n\nstruct is_neg_zero_fp {\n  bool isValue(const APFloat &C) { return C.isNegZero(); }\n};\n/// Match a floating-point negative zero.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_neg_zero_fp> m_NegZeroFP() {\n  return cstfp_pred_ty<is_neg_zero_fp>();\n}\n\nstruct is_non_zero_fp {\n  bool isValue(const APFloat &C) { return C.isNonZero(); }\n};\n/// Match a floating-point non-zero.\n/// For vectors, this includes constants with undefined elements.\ninline cstfp_pred_ty<is_non_zero_fp> m_NonZeroFP() {\n  return cstfp_pred_ty<is_non_zero_fp>();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename Class> struct bind_ty {\n  Class *&VR;\n\n  bind_ty(Class *&V) : VR(V) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (auto *CV = dyn_cast<Class>(V)) {\n      VR = CV;\n      return true;\n    }\n    return false;\n  }\n};\n\n/// Match a value, capturing it if we match.\ninline bind_ty<Value> m_Value(Value *&V) { return V; }\ninline bind_ty<const Value> m_Value(const Value *&V) { return V; }\n\n/// Match an instruction, capturing it if we match.\ninline bind_ty<Instruction> m_Instruction(Instruction *&I) { return I; }\n/// Match a unary operator, capturing it if we match.\ninline bind_ty<UnaryOperator> m_UnOp(UnaryOperator *&I) { return I; }\n/// Match a binary operator, capturing it if we match.\ninline bind_ty<BinaryOperator> m_BinOp(BinaryOperator *&I) { return I; }\n/// Match a with overflow intrinsic, capturing it if we match.\ninline bind_ty<WithOverflowInst> m_WithOverflowInst(WithOverflowInst *&I) { return I; }\ninline bind_ty<const WithOverflowInst>\nm_WithOverflowInst(const WithOverflowInst *&I) {\n  return I;\n}\n\n/// Match a Constant, capturing the value if we match.\ninline bind_ty<Constant> m_Constant(Constant *&C) { return C; }\n\n/// Match a ConstantInt, capturing the value if we match.\ninline bind_ty<ConstantInt> m_ConstantInt(ConstantInt *&CI) { return CI; }\n\n/// Match a ConstantFP, capturing the value if we match.\ninline bind_ty<ConstantFP> m_ConstantFP(ConstantFP *&C) { return C; }\n\n/// Match a ConstantExpr, capturing the value if we match.\ninline bind_ty<ConstantExpr> m_ConstantExpr(ConstantExpr *&C) { return C; }\n\n/// Match a basic block value, capturing it if we match.\ninline bind_ty<BasicBlock> m_BasicBlock(BasicBlock *&V) { return V; }\ninline bind_ty<const BasicBlock> m_BasicBlock(const BasicBlock *&V) {\n  return V;\n}\n\n/// Match an arbitrary immediate Constant and ignore it.\ninline match_combine_and<class_match<Constant>,\n                         match_unless<class_match<ConstantExpr>>>\nm_ImmConstant() {\n  return m_CombineAnd(m_Constant(), m_Unless(m_ConstantExpr()));\n}\n\n/// Match an immediate Constant, capturing the value if we match.\ninline match_combine_and<bind_ty<Constant>,\n                         match_unless<class_match<ConstantExpr>>>\nm_ImmConstant(Constant *&C) {\n  return m_CombineAnd(m_Constant(C), m_Unless(m_ConstantExpr()));\n}\n\n/// Match a specified Value*.\nstruct specificval_ty {\n  const Value *Val;\n\n  specificval_ty(const Value *V) : Val(V) {}\n\n  template <typename ITy> bool match(ITy *V) { return V == Val; }\n};\n\n/// Match if we have a specific specified value.\ninline specificval_ty m_Specific(const Value *V) { return V; }\n\n/// Stores a reference to the Value *, not the Value * itself,\n/// thus can be used in commutative matchers.\ntemplate <typename Class> struct deferredval_ty {\n  Class *const &Val;\n\n  deferredval_ty(Class *const &V) : Val(V) {}\n\n  template <typename ITy> bool match(ITy *const V) { return V == Val; }\n};\n\n/// A commutative-friendly version of m_Specific().\ninline deferredval_ty<Value> m_Deferred(Value *const &V) { return V; }\ninline deferredval_ty<const Value> m_Deferred(const Value *const &V) {\n  return V;\n}\n\n/// Match a specified floating point value or vector of all elements of\n/// that value.\nstruct specific_fpval {\n  double Val;\n\n  specific_fpval(double V) : Val(V) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (const auto *CFP = dyn_cast<ConstantFP>(V))\n      return CFP->isExactlyValue(Val);\n    if (V->getType()->isVectorTy())\n      if (const auto *C = dyn_cast<Constant>(V))\n        if (auto *CFP = dyn_cast_or_null<ConstantFP>(C->getSplatValue()))\n          return CFP->isExactlyValue(Val);\n    return false;\n  }\n};\n\n/// Match a specific floating point value or vector with all elements\n/// equal to the value.\ninline specific_fpval m_SpecificFP(double V) { return specific_fpval(V); }\n\n/// Match a float 1.0 or vector with all elements equal to 1.0.\ninline specific_fpval m_FPOne() { return m_SpecificFP(1.0); }\n\nstruct bind_const_intval_ty {\n  uint64_t &VR;\n\n  bind_const_intval_ty(uint64_t &V) : VR(V) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (const auto *CV = dyn_cast<ConstantInt>(V))\n      if (CV->getValue().ule(UINT64_MAX)) {\n        VR = CV->getZExtValue();\n        return true;\n      }\n    return false;\n  }\n};\n\n/// Match a specified integer value or vector of all elements of that\n/// value.\ntemplate <bool AllowUndefs>\nstruct specific_intval {\n  APInt Val;\n\n  specific_intval(APInt V) : Val(std::move(V)) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    const auto *CI = dyn_cast<ConstantInt>(V);\n    if (!CI && V->getType()->isVectorTy())\n      if (const auto *C = dyn_cast<Constant>(V))\n        CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndefs));\n\n    return CI && APInt::isSameValue(CI->getValue(), Val);\n  }\n};\n\n/// Match a specific integer value or vector with all elements equal to\n/// the value.\ninline specific_intval<false> m_SpecificInt(APInt V) {\n  return specific_intval<false>(std::move(V));\n}\n\ninline specific_intval<false> m_SpecificInt(uint64_t V) {\n  return m_SpecificInt(APInt(64, V));\n}\n\ninline specific_intval<true> m_SpecificIntAllowUndef(APInt V) {\n  return specific_intval<true>(std::move(V));\n}\n\ninline specific_intval<true> m_SpecificIntAllowUndef(uint64_t V) {\n  return m_SpecificIntAllowUndef(APInt(64, V));\n}\n\n/// Match a ConstantInt and bind to its value.  This does not match\n/// ConstantInts wider than 64-bits.\ninline bind_const_intval_ty m_ConstantInt(uint64_t &V) { return V; }\n\n/// Match a specified basic block value.\nstruct specific_bbval {\n  BasicBlock *Val;\n\n  specific_bbval(BasicBlock *Val) : Val(Val) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    const auto *BB = dyn_cast<BasicBlock>(V);\n    return BB && BB == Val;\n  }\n};\n\n/// Match a specific basic block value.\ninline specific_bbval m_SpecificBB(BasicBlock *BB) {\n  return specific_bbval(BB);\n}\n\n/// A commutative-friendly version of m_Specific().\ninline deferredval_ty<BasicBlock> m_Deferred(BasicBlock *const &BB) {\n  return BB;\n}\ninline deferredval_ty<const BasicBlock>\nm_Deferred(const BasicBlock *const &BB) {\n  return BB;\n}\n\n//===----------------------------------------------------------------------===//\n// Matcher for any binary operator.\n//\ntemplate <typename LHS_t, typename RHS_t, bool Commutable = false>\nstruct AnyBinaryOp_match {\n  LHS_t L;\n  RHS_t R;\n\n  // The evaluation order is always stable, regardless of Commutability.\n  // The LHS is always matched first.\n  AnyBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<BinaryOperator>(V))\n      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||\n             (Commutable && L.match(I->getOperand(1)) &&\n              R.match(I->getOperand(0)));\n    return false;\n  }\n};\n\ntemplate <typename LHS, typename RHS>\ninline AnyBinaryOp_match<LHS, RHS> m_BinOp(const LHS &L, const RHS &R) {\n  return AnyBinaryOp_match<LHS, RHS>(L, R);\n}\n\n//===----------------------------------------------------------------------===//\n// Matcher for any unary operator.\n// TODO fuse unary, binary matcher into n-ary matcher\n//\ntemplate <typename OP_t> struct AnyUnaryOp_match {\n  OP_t X;\n\n  AnyUnaryOp_match(const OP_t &X) : X(X) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<UnaryOperator>(V))\n      return X.match(I->getOperand(0));\n    return false;\n  }\n};\n\ntemplate <typename OP_t> inline AnyUnaryOp_match<OP_t> m_UnOp(const OP_t &X) {\n  return AnyUnaryOp_match<OP_t>(X);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for specific binary operators.\n//\n\ntemplate <typename LHS_t, typename RHS_t, unsigned Opcode,\n          bool Commutable = false>\nstruct BinaryOp_match {\n  LHS_t L;\n  RHS_t R;\n\n  // The evaluation order is always stable, regardless of Commutability.\n  // The LHS is always matched first.\n  BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (V->getValueID() == Value::InstructionVal + Opcode) {\n      auto *I = cast<BinaryOperator>(V);\n      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||\n             (Commutable && L.match(I->getOperand(1)) &&\n              R.match(I->getOperand(0)));\n    }\n    if (auto *CE = dyn_cast<ConstantExpr>(V))\n      return CE->getOpcode() == Opcode &&\n             ((L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))) ||\n              (Commutable && L.match(CE->getOperand(1)) &&\n               R.match(CE->getOperand(0))));\n    return false;\n  }\n};\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Add> m_Add(const LHS &L,\n                                                        const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Add>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FAdd> m_FAdd(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FAdd>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Sub> m_Sub(const LHS &L,\n                                                        const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Sub>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FSub> m_FSub(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FSub>(L, R);\n}\n\ntemplate <typename Op_t> struct FNeg_match {\n  Op_t X;\n\n  FNeg_match(const Op_t &Op) : X(Op) {}\n  template <typename OpTy> bool match(OpTy *V) {\n    auto *FPMO = dyn_cast<FPMathOperator>(V);\n    if (!FPMO) return false;\n\n    if (FPMO->getOpcode() == Instruction::FNeg)\n      return X.match(FPMO->getOperand(0));\n\n    if (FPMO->getOpcode() == Instruction::FSub) {\n      if (FPMO->hasNoSignedZeros()) {\n        // With 'nsz', any zero goes.\n        if (!cstfp_pred_ty<is_any_zero_fp>().match(FPMO->getOperand(0)))\n          return false;\n      } else {\n        // Without 'nsz', we need fsub -0.0, X exactly.\n        if (!cstfp_pred_ty<is_neg_zero_fp>().match(FPMO->getOperand(0)))\n          return false;\n      }\n\n      return X.match(FPMO->getOperand(1));\n    }\n\n    return false;\n  }\n};\n\n/// Match 'fneg X' as 'fsub -0.0, X'.\ntemplate <typename OpTy>\ninline FNeg_match<OpTy>\nm_FNeg(const OpTy &X) {\n  return FNeg_match<OpTy>(X);\n}\n\n/// Match 'fneg X' as 'fsub +-0.0, X'.\ntemplate <typename RHS>\ninline BinaryOp_match<cstfp_pred_ty<is_any_zero_fp>, RHS, Instruction::FSub>\nm_FNegNSZ(const RHS &X) {\n  return m_FSub(m_AnyZeroFP(), X);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Mul> m_Mul(const LHS &L,\n                                                        const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Mul>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FMul> m_FMul(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FMul>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::UDiv> m_UDiv(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::UDiv>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::SDiv> m_SDiv(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::SDiv>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FDiv> m_FDiv(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FDiv>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::URem> m_URem(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::URem>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::SRem> m_SRem(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::SRem>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FRem> m_FRem(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FRem>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::And> m_And(const LHS &L,\n                                                        const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::And>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Or> m_Or(const LHS &L,\n                                                      const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Or>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Xor> m_Xor(const LHS &L,\n                                                        const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Xor>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Shl> m_Shl(const LHS &L,\n                                                        const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Shl>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::LShr> m_LShr(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::LShr>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::AShr> m_AShr(const LHS &L,\n                                                          const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::AShr>(L, R);\n}\n\ntemplate <typename LHS_t, typename RHS_t, unsigned Opcode,\n          unsigned WrapFlags = 0>\nstruct OverflowingBinaryOp_match {\n  LHS_t L;\n  RHS_t R;\n\n  OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS)\n      : L(LHS), R(RHS) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *Op = dyn_cast<OverflowingBinaryOperator>(V)) {\n      if (Op->getOpcode() != Opcode)\n        return false;\n      if (WrapFlags & OverflowingBinaryOperator::NoUnsignedWrap &&\n          !Op->hasNoUnsignedWrap())\n        return false;\n      if (WrapFlags & OverflowingBinaryOperator::NoSignedWrap &&\n          !Op->hasNoSignedWrap())\n        return false;\n      return L.match(Op->getOperand(0)) && R.match(Op->getOperand(1));\n    }\n    return false;\n  }\n};\n\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,\n                                 OverflowingBinaryOperator::NoSignedWrap>\nm_NSWAdd(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,\n                                   OverflowingBinaryOperator::NoSignedWrap>(\n      L, R);\n}\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,\n                                 OverflowingBinaryOperator::NoSignedWrap>\nm_NSWSub(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,\n                                   OverflowingBinaryOperator::NoSignedWrap>(\n      L, R);\n}\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,\n                                 OverflowingBinaryOperator::NoSignedWrap>\nm_NSWMul(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,\n                                   OverflowingBinaryOperator::NoSignedWrap>(\n      L, R);\n}\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,\n                                 OverflowingBinaryOperator::NoSignedWrap>\nm_NSWShl(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,\n                                   OverflowingBinaryOperator::NoSignedWrap>(\n      L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,\n                                 OverflowingBinaryOperator::NoUnsignedWrap>\nm_NUWAdd(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,\n                                   OverflowingBinaryOperator::NoUnsignedWrap>(\n      L, R);\n}\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,\n                                 OverflowingBinaryOperator::NoUnsignedWrap>\nm_NUWSub(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,\n                                   OverflowingBinaryOperator::NoUnsignedWrap>(\n      L, R);\n}\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,\n                                 OverflowingBinaryOperator::NoUnsignedWrap>\nm_NUWMul(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,\n                                   OverflowingBinaryOperator::NoUnsignedWrap>(\n      L, R);\n}\ntemplate <typename LHS, typename RHS>\ninline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,\n                                 OverflowingBinaryOperator::NoUnsignedWrap>\nm_NUWShl(const LHS &L, const RHS &R) {\n  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,\n                                   OverflowingBinaryOperator::NoUnsignedWrap>(\n      L, R);\n}\n\n//===----------------------------------------------------------------------===//\n// Class that matches a group of binary opcodes.\n//\ntemplate <typename LHS_t, typename RHS_t, typename Predicate>\nstruct BinOpPred_match : Predicate {\n  LHS_t L;\n  RHS_t R;\n\n  BinOpPred_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<Instruction>(V))\n      return this->isOpType(I->getOpcode()) && L.match(I->getOperand(0)) &&\n             R.match(I->getOperand(1));\n    if (auto *CE = dyn_cast<ConstantExpr>(V))\n      return this->isOpType(CE->getOpcode()) && L.match(CE->getOperand(0)) &&\n             R.match(CE->getOperand(1));\n    return false;\n  }\n};\n\nstruct is_shift_op {\n  bool isOpType(unsigned Opcode) { return Instruction::isShift(Opcode); }\n};\n\nstruct is_right_shift_op {\n  bool isOpType(unsigned Opcode) {\n    return Opcode == Instruction::LShr || Opcode == Instruction::AShr;\n  }\n};\n\nstruct is_logical_shift_op {\n  bool isOpType(unsigned Opcode) {\n    return Opcode == Instruction::LShr || Opcode == Instruction::Shl;\n  }\n};\n\nstruct is_bitwiselogic_op {\n  bool isOpType(unsigned Opcode) {\n    return Instruction::isBitwiseLogicOp(Opcode);\n  }\n};\n\nstruct is_idiv_op {\n  bool isOpType(unsigned Opcode) {\n    return Opcode == Instruction::SDiv || Opcode == Instruction::UDiv;\n  }\n};\n\nstruct is_irem_op {\n  bool isOpType(unsigned Opcode) {\n    return Opcode == Instruction::SRem || Opcode == Instruction::URem;\n  }\n};\n\n/// Matches shift operations.\ntemplate <typename LHS, typename RHS>\ninline BinOpPred_match<LHS, RHS, is_shift_op> m_Shift(const LHS &L,\n                                                      const RHS &R) {\n  return BinOpPred_match<LHS, RHS, is_shift_op>(L, R);\n}\n\n/// Matches logical shift operations.\ntemplate <typename LHS, typename RHS>\ninline BinOpPred_match<LHS, RHS, is_right_shift_op> m_Shr(const LHS &L,\n                                                          const RHS &R) {\n  return BinOpPred_match<LHS, RHS, is_right_shift_op>(L, R);\n}\n\n/// Matches logical shift operations.\ntemplate <typename LHS, typename RHS>\ninline BinOpPred_match<LHS, RHS, is_logical_shift_op>\nm_LogicalShift(const LHS &L, const RHS &R) {\n  return BinOpPred_match<LHS, RHS, is_logical_shift_op>(L, R);\n}\n\n/// Matches bitwise logic operations.\ntemplate <typename LHS, typename RHS>\ninline BinOpPred_match<LHS, RHS, is_bitwiselogic_op>\nm_BitwiseLogic(const LHS &L, const RHS &R) {\n  return BinOpPred_match<LHS, RHS, is_bitwiselogic_op>(L, R);\n}\n\n/// Matches integer division operations.\ntemplate <typename LHS, typename RHS>\ninline BinOpPred_match<LHS, RHS, is_idiv_op> m_IDiv(const LHS &L,\n                                                    const RHS &R) {\n  return BinOpPred_match<LHS, RHS, is_idiv_op>(L, R);\n}\n\n/// Matches integer remainder operations.\ntemplate <typename LHS, typename RHS>\ninline BinOpPred_match<LHS, RHS, is_irem_op> m_IRem(const LHS &L,\n                                                    const RHS &R) {\n  return BinOpPred_match<LHS, RHS, is_irem_op>(L, R);\n}\n\n//===----------------------------------------------------------------------===//\n// Class that matches exact binary ops.\n//\ntemplate <typename SubPattern_t> struct Exact_match {\n  SubPattern_t SubPattern;\n\n  Exact_match(const SubPattern_t &SP) : SubPattern(SP) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *PEO = dyn_cast<PossiblyExactOperator>(V))\n      return PEO->isExact() && SubPattern.match(V);\n    return false;\n  }\n};\n\ntemplate <typename T> inline Exact_match<T> m_Exact(const T &SubPattern) {\n  return SubPattern;\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for CmpInst classes\n//\n\ntemplate <typename LHS_t, typename RHS_t, typename Class, typename PredicateTy,\n          bool Commutable = false>\nstruct CmpClass_match {\n  PredicateTy &Predicate;\n  LHS_t L;\n  RHS_t R;\n\n  // The evaluation order is always stable, regardless of Commutability.\n  // The LHS is always matched first.\n  CmpClass_match(PredicateTy &Pred, const LHS_t &LHS, const RHS_t &RHS)\n      : Predicate(Pred), L(LHS), R(RHS) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<Class>(V)) {\n      if (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) {\n        Predicate = I->getPredicate();\n        return true;\n      } else if (Commutable && L.match(I->getOperand(1)) &&\n           R.match(I->getOperand(0))) {\n        Predicate = I->getSwappedPredicate();\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\ntemplate <typename LHS, typename RHS>\ninline CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>\nm_Cmp(CmpInst::Predicate &Pred, const LHS &L, const RHS &R) {\n  return CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>(Pred, L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>\nm_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {\n  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>(Pred, L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>\nm_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R) {\n  return CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>(Pred, L, R);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for instructions with a given opcode and number of operands.\n//\n\n/// Matches instructions with Opcode and three operands.\ntemplate <typename T0, unsigned Opcode> struct OneOps_match {\n  T0 Op1;\n\n  OneOps_match(const T0 &Op1) : Op1(Op1) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (V->getValueID() == Value::InstructionVal + Opcode) {\n      auto *I = cast<Instruction>(V);\n      return Op1.match(I->getOperand(0));\n    }\n    return false;\n  }\n};\n\n/// Matches instructions with Opcode and three operands.\ntemplate <typename T0, typename T1, unsigned Opcode> struct TwoOps_match {\n  T0 Op1;\n  T1 Op2;\n\n  TwoOps_match(const T0 &Op1, const T1 &Op2) : Op1(Op1), Op2(Op2) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (V->getValueID() == Value::InstructionVal + Opcode) {\n      auto *I = cast<Instruction>(V);\n      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1));\n    }\n    return false;\n  }\n};\n\n/// Matches instructions with Opcode and three operands.\ntemplate <typename T0, typename T1, typename T2, unsigned Opcode>\nstruct ThreeOps_match {\n  T0 Op1;\n  T1 Op2;\n  T2 Op3;\n\n  ThreeOps_match(const T0 &Op1, const T1 &Op2, const T2 &Op3)\n      : Op1(Op1), Op2(Op2), Op3(Op3) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (V->getValueID() == Value::InstructionVal + Opcode) {\n      auto *I = cast<Instruction>(V);\n      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&\n             Op3.match(I->getOperand(2));\n    }\n    return false;\n  }\n};\n\n/// Matches SelectInst.\ntemplate <typename Cond, typename LHS, typename RHS>\ninline ThreeOps_match<Cond, LHS, RHS, Instruction::Select>\nm_Select(const Cond &C, const LHS &L, const RHS &R) {\n  return ThreeOps_match<Cond, LHS, RHS, Instruction::Select>(C, L, R);\n}\n\n/// This matches a select of two constants, e.g.:\n/// m_SelectCst<-1, 0>(m_Value(V))\ntemplate <int64_t L, int64_t R, typename Cond>\ninline ThreeOps_match<Cond, constantint_match<L>, constantint_match<R>,\n                      Instruction::Select>\nm_SelectCst(const Cond &C) {\n  return m_Select(C, m_ConstantInt<L>(), m_ConstantInt<R>());\n}\n\n/// Matches FreezeInst.\ntemplate <typename OpTy>\ninline OneOps_match<OpTy, Instruction::Freeze> m_Freeze(const OpTy &Op) {\n  return OneOps_match<OpTy, Instruction::Freeze>(Op);\n}\n\n/// Matches InsertElementInst.\ntemplate <typename Val_t, typename Elt_t, typename Idx_t>\ninline ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>\nm_InsertElt(const Val_t &Val, const Elt_t &Elt, const Idx_t &Idx) {\n  return ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>(\n      Val, Elt, Idx);\n}\n\n/// Matches ExtractElementInst.\ntemplate <typename Val_t, typename Idx_t>\ninline TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>\nm_ExtractElt(const Val_t &Val, const Idx_t &Idx) {\n  return TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>(Val, Idx);\n}\n\n/// Matches shuffle.\ntemplate <typename T0, typename T1, typename T2> struct Shuffle_match {\n  T0 Op1;\n  T1 Op2;\n  T2 Mask;\n\n  Shuffle_match(const T0 &Op1, const T1 &Op2, const T2 &Mask)\n      : Op1(Op1), Op2(Op2), Mask(Mask) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<ShuffleVectorInst>(V)) {\n      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&\n             Mask.match(I->getShuffleMask());\n    }\n    return false;\n  }\n};\n\nstruct m_Mask {\n  ArrayRef<int> &MaskRef;\n  m_Mask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}\n  bool match(ArrayRef<int> Mask) {\n    MaskRef = Mask;\n    return true;\n  }\n};\n\nstruct m_ZeroMask {\n  bool match(ArrayRef<int> Mask) {\n    return all_of(Mask, [](int Elem) { return Elem == 0 || Elem == -1; });\n  }\n};\n\nstruct m_SpecificMask {\n  ArrayRef<int> &MaskRef;\n  m_SpecificMask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}\n  bool match(ArrayRef<int> Mask) { return MaskRef == Mask; }\n};\n\nstruct m_SplatOrUndefMask {\n  int &SplatIndex;\n  m_SplatOrUndefMask(int &SplatIndex) : SplatIndex(SplatIndex) {}\n  bool match(ArrayRef<int> Mask) {\n    auto First = find_if(Mask, [](int Elem) { return Elem != -1; });\n    if (First == Mask.end())\n      return false;\n    SplatIndex = *First;\n    return all_of(Mask,\n                  [First](int Elem) { return Elem == *First || Elem == -1; });\n  }\n};\n\n/// Matches ShuffleVectorInst independently of mask value.\ntemplate <typename V1_t, typename V2_t>\ninline TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>\nm_Shuffle(const V1_t &v1, const V2_t &v2) {\n  return TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>(v1, v2);\n}\n\ntemplate <typename V1_t, typename V2_t, typename Mask_t>\ninline Shuffle_match<V1_t, V2_t, Mask_t>\nm_Shuffle(const V1_t &v1, const V2_t &v2, const Mask_t &mask) {\n  return Shuffle_match<V1_t, V2_t, Mask_t>(v1, v2, mask);\n}\n\n/// Matches LoadInst.\ntemplate <typename OpTy>\ninline OneOps_match<OpTy, Instruction::Load> m_Load(const OpTy &Op) {\n  return OneOps_match<OpTy, Instruction::Load>(Op);\n}\n\n/// Matches StoreInst.\ntemplate <typename ValueOpTy, typename PointerOpTy>\ninline TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>\nm_Store(const ValueOpTy &ValueOp, const PointerOpTy &PointerOp) {\n  return TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>(ValueOp,\n                                                                  PointerOp);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for CastInst classes\n//\n\ntemplate <typename Op_t, unsigned Opcode> struct CastClass_match {\n  Op_t Op;\n\n  CastClass_match(const Op_t &OpMatch) : Op(OpMatch) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *O = dyn_cast<Operator>(V))\n      return O->getOpcode() == Opcode && Op.match(O->getOperand(0));\n    return false;\n  }\n};\n\n/// Matches BitCast.\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::BitCast> m_BitCast(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::BitCast>(Op);\n}\n\n/// Matches PtrToInt.\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::PtrToInt>(Op);\n}\n\n/// Matches IntToPtr.\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::IntToPtr>(Op);\n}\n\n/// Matches Trunc.\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::Trunc>(Op);\n}\n\ntemplate <typename OpTy>\ninline match_combine_or<CastClass_match<OpTy, Instruction::Trunc>, OpTy>\nm_TruncOrSelf(const OpTy &Op) {\n  return m_CombineOr(m_Trunc(Op), Op);\n}\n\n/// Matches SExt.\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::SExt> m_SExt(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::SExt>(Op);\n}\n\n/// Matches ZExt.\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::ZExt> m_ZExt(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::ZExt>(Op);\n}\n\ntemplate <typename OpTy>\ninline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>, OpTy>\nm_ZExtOrSelf(const OpTy &Op) {\n  return m_CombineOr(m_ZExt(Op), Op);\n}\n\ntemplate <typename OpTy>\ninline match_combine_or<CastClass_match<OpTy, Instruction::SExt>, OpTy>\nm_SExtOrSelf(const OpTy &Op) {\n  return m_CombineOr(m_SExt(Op), Op);\n}\n\ntemplate <typename OpTy>\ninline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,\n                        CastClass_match<OpTy, Instruction::SExt>>\nm_ZExtOrSExt(const OpTy &Op) {\n  return m_CombineOr(m_ZExt(Op), m_SExt(Op));\n}\n\ntemplate <typename OpTy>\ninline match_combine_or<\n    match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,\n                     CastClass_match<OpTy, Instruction::SExt>>,\n    OpTy>\nm_ZExtOrSExtOrSelf(const OpTy &Op) {\n  return m_CombineOr(m_ZExtOrSExt(Op), Op);\n}\n\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::UIToFP> m_UIToFP(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::UIToFP>(Op);\n}\n\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::SIToFP> m_SIToFP(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::SIToFP>(Op);\n}\n\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::FPToUI> m_FPToUI(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::FPToUI>(Op);\n}\n\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::FPToSI> m_FPToSI(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::FPToSI>(Op);\n}\n\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::FPTrunc> m_FPTrunc(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::FPTrunc>(Op);\n}\n\ntemplate <typename OpTy>\ninline CastClass_match<OpTy, Instruction::FPExt> m_FPExt(const OpTy &Op) {\n  return CastClass_match<OpTy, Instruction::FPExt>(Op);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for control flow.\n//\n\nstruct br_match {\n  BasicBlock *&Succ;\n\n  br_match(BasicBlock *&Succ) : Succ(Succ) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *BI = dyn_cast<BranchInst>(V))\n      if (BI->isUnconditional()) {\n        Succ = BI->getSuccessor(0);\n        return true;\n      }\n    return false;\n  }\n};\n\ninline br_match m_UnconditionalBr(BasicBlock *&Succ) { return br_match(Succ); }\n\ntemplate <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t>\nstruct brc_match {\n  Cond_t Cond;\n  TrueBlock_t T;\n  FalseBlock_t F;\n\n  brc_match(const Cond_t &C, const TrueBlock_t &t, const FalseBlock_t &f)\n      : Cond(C), T(t), F(f) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *BI = dyn_cast<BranchInst>(V))\n      if (BI->isConditional() && Cond.match(BI->getCondition()))\n        return T.match(BI->getSuccessor(0)) && F.match(BI->getSuccessor(1));\n    return false;\n  }\n};\n\ntemplate <typename Cond_t>\ninline brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>\nm_Br(const Cond_t &C, BasicBlock *&T, BasicBlock *&F) {\n  return brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>(\n      C, m_BasicBlock(T), m_BasicBlock(F));\n}\n\ntemplate <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t>\ninline brc_match<Cond_t, TrueBlock_t, FalseBlock_t>\nm_Br(const Cond_t &C, const TrueBlock_t &T, const FalseBlock_t &F) {\n  return brc_match<Cond_t, TrueBlock_t, FalseBlock_t>(C, T, F);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for max/min idioms, eg: \"select (sgt x, y), x, y\" -> smax(x,y).\n//\n\ntemplate <typename CmpInst_t, typename LHS_t, typename RHS_t, typename Pred_t,\n          bool Commutable = false>\nstruct MaxMin_match {\n  LHS_t L;\n  RHS_t R;\n\n  // The evaluation order is always stable, regardless of Commutability.\n  // The LHS is always matched first.\n  MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *II = dyn_cast<IntrinsicInst>(V)) {\n      Intrinsic::ID IID = II->getIntrinsicID();\n      if ((IID == Intrinsic::smax && Pred_t::match(ICmpInst::ICMP_SGT)) ||\n          (IID == Intrinsic::smin && Pred_t::match(ICmpInst::ICMP_SLT)) ||\n          (IID == Intrinsic::umax && Pred_t::match(ICmpInst::ICMP_UGT)) ||\n          (IID == Intrinsic::umin && Pred_t::match(ICmpInst::ICMP_ULT))) {\n        Value *LHS = II->getOperand(0), *RHS = II->getOperand(1);\n        return (L.match(LHS) && R.match(RHS)) ||\n               (Commutable && L.match(RHS) && R.match(LHS));\n      }\n    }\n    // Look for \"(x pred y) ? x : y\" or \"(x pred y) ? y : x\".\n    auto *SI = dyn_cast<SelectInst>(V);\n    if (!SI)\n      return false;\n    auto *Cmp = dyn_cast<CmpInst_t>(SI->getCondition());\n    if (!Cmp)\n      return false;\n    // At this point we have a select conditioned on a comparison.  Check that\n    // it is the values returned by the select that are being compared.\n    Value *TrueVal = SI->getTrueValue();\n    Value *FalseVal = SI->getFalseValue();\n    Value *LHS = Cmp->getOperand(0);\n    Value *RHS = Cmp->getOperand(1);\n    if ((TrueVal != LHS || FalseVal != RHS) &&\n        (TrueVal != RHS || FalseVal != LHS))\n      return false;\n    typename CmpInst_t::Predicate Pred =\n        LHS == TrueVal ? Cmp->getPredicate() : Cmp->getInversePredicate();\n    // Does \"(x pred y) ? x : y\" represent the desired max/min operation?\n    if (!Pred_t::match(Pred))\n      return false;\n    // It does!  Bind the operands.\n    return (L.match(LHS) && R.match(RHS)) ||\n           (Commutable && L.match(RHS) && R.match(LHS));\n  }\n};\n\n/// Helper class for identifying signed max predicates.\nstruct smax_pred_ty {\n  static bool match(ICmpInst::Predicate Pred) {\n    return Pred == CmpInst::ICMP_SGT || Pred == CmpInst::ICMP_SGE;\n  }\n};\n\n/// Helper class for identifying signed min predicates.\nstruct smin_pred_ty {\n  static bool match(ICmpInst::Predicate Pred) {\n    return Pred == CmpInst::ICMP_SLT || Pred == CmpInst::ICMP_SLE;\n  }\n};\n\n/// Helper class for identifying unsigned max predicates.\nstruct umax_pred_ty {\n  static bool match(ICmpInst::Predicate Pred) {\n    return Pred == CmpInst::ICMP_UGT || Pred == CmpInst::ICMP_UGE;\n  }\n};\n\n/// Helper class for identifying unsigned min predicates.\nstruct umin_pred_ty {\n  static bool match(ICmpInst::Predicate Pred) {\n    return Pred == CmpInst::ICMP_ULT || Pred == CmpInst::ICMP_ULE;\n  }\n};\n\n/// Helper class for identifying ordered max predicates.\nstruct ofmax_pred_ty {\n  static bool match(FCmpInst::Predicate Pred) {\n    return Pred == CmpInst::FCMP_OGT || Pred == CmpInst::FCMP_OGE;\n  }\n};\n\n/// Helper class for identifying ordered min predicates.\nstruct ofmin_pred_ty {\n  static bool match(FCmpInst::Predicate Pred) {\n    return Pred == CmpInst::FCMP_OLT || Pred == CmpInst::FCMP_OLE;\n  }\n};\n\n/// Helper class for identifying unordered max predicates.\nstruct ufmax_pred_ty {\n  static bool match(FCmpInst::Predicate Pred) {\n    return Pred == CmpInst::FCMP_UGT || Pred == CmpInst::FCMP_UGE;\n  }\n};\n\n/// Helper class for identifying unordered min predicates.\nstruct ufmin_pred_ty {\n  static bool match(FCmpInst::Predicate Pred) {\n    return Pred == CmpInst::FCMP_ULT || Pred == CmpInst::FCMP_ULE;\n  }\n};\n\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty> m_SMax(const LHS &L,\n                                                             const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty> m_SMin(const LHS &L,\n                                                             const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty> m_UMax(const LHS &L,\n                                                             const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty> m_UMin(const LHS &L,\n                                                             const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline match_combine_or<\n    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>,\n                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>>,\n    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>,\n                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>>>\nm_MaxOrMin(const LHS &L, const RHS &R) {\n  return m_CombineOr(m_CombineOr(m_SMax(L, R), m_SMin(L, R)),\n                     m_CombineOr(m_UMax(L, R), m_UMin(L, R)));\n}\n\n/// Match an 'ordered' floating point maximum function.\n/// Floating point has one special value 'NaN'. Therefore, there is no total\n/// order. However, if we can ignore the 'NaN' value (for example, because of a\n/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'\n/// semantics. In the presence of 'NaN' we have to preserve the original\n/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.\n///\n///                         max(L, R)  iff L and R are not NaN\n///  m_OrdFMax(L, R) =      R          iff L or R are NaN\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty> m_OrdFMax(const LHS &L,\n                                                                 const RHS &R) {\n  return MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty>(L, R);\n}\n\n/// Match an 'ordered' floating point minimum function.\n/// Floating point has one special value 'NaN'. Therefore, there is no total\n/// order. However, if we can ignore the 'NaN' value (for example, because of a\n/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'\n/// semantics. In the presence of 'NaN' we have to preserve the original\n/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.\n///\n///                         min(L, R)  iff L and R are not NaN\n///  m_OrdFMin(L, R) =      R          iff L or R are NaN\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty> m_OrdFMin(const LHS &L,\n                                                                 const RHS &R) {\n  return MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty>(L, R);\n}\n\n/// Match an 'unordered' floating point maximum function.\n/// Floating point has one special value 'NaN'. Therefore, there is no total\n/// order. However, if we can ignore the 'NaN' value (for example, because of a\n/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'\n/// semantics. In the presence of 'NaN' we have to preserve the original\n/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.\n///\n///                         max(L, R)  iff L and R are not NaN\n///  m_UnordFMax(L, R) =    L          iff L or R are NaN\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>\nm_UnordFMax(const LHS &L, const RHS &R) {\n  return MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>(L, R);\n}\n\n/// Match an 'unordered' floating point minimum function.\n/// Floating point has one special value 'NaN'. Therefore, there is no total\n/// order. However, if we can ignore the 'NaN' value (for example, because of a\n/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'\n/// semantics. In the presence of 'NaN' we have to preserve the original\n/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.\n///\n///                          min(L, R)  iff L and R are not NaN\n///  m_UnordFMin(L, R) =     L          iff L or R are NaN\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>\nm_UnordFMin(const LHS &L, const RHS &R) {\n  return MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>(L, R);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for overflow check patterns: e.g. (a + b) u< a, (a ^ -1) <u b\n// Note that S might be matched to other instructions than AddInst.\n//\n\ntemplate <typename LHS_t, typename RHS_t, typename Sum_t>\nstruct UAddWithOverflow_match {\n  LHS_t L;\n  RHS_t R;\n  Sum_t S;\n\n  UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S)\n      : L(L), R(R), S(S) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    Value *ICmpLHS, *ICmpRHS;\n    ICmpInst::Predicate Pred;\n    if (!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))\n      return false;\n\n    Value *AddLHS, *AddRHS;\n    auto AddExpr = m_Add(m_Value(AddLHS), m_Value(AddRHS));\n\n    // (a + b) u< a, (a + b) u< b\n    if (Pred == ICmpInst::ICMP_ULT)\n      if (AddExpr.match(ICmpLHS) && (ICmpRHS == AddLHS || ICmpRHS == AddRHS))\n        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);\n\n    // a >u (a + b), b >u (a + b)\n    if (Pred == ICmpInst::ICMP_UGT)\n      if (AddExpr.match(ICmpRHS) && (ICmpLHS == AddLHS || ICmpLHS == AddRHS))\n        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);\n\n    Value *Op1;\n    auto XorExpr = m_OneUse(m_Xor(m_Value(Op1), m_AllOnes()));\n    // (a ^ -1) <u b\n    if (Pred == ICmpInst::ICMP_ULT) {\n      if (XorExpr.match(ICmpLHS))\n        return L.match(Op1) && R.match(ICmpRHS) && S.match(ICmpLHS);\n    }\n    //  b > u (a ^ -1)\n    if (Pred == ICmpInst::ICMP_UGT) {\n      if (XorExpr.match(ICmpRHS))\n        return L.match(Op1) && R.match(ICmpLHS) && S.match(ICmpRHS);\n    }\n\n    // Match special-case for increment-by-1.\n    if (Pred == ICmpInst::ICMP_EQ) {\n      // (a + 1) == 0\n      // (1 + a) == 0\n      if (AddExpr.match(ICmpLHS) && m_ZeroInt().match(ICmpRHS) &&\n          (m_One().match(AddLHS) || m_One().match(AddRHS)))\n        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);\n      // 0 == (a + 1)\n      // 0 == (1 + a)\n      if (m_ZeroInt().match(ICmpLHS) && AddExpr.match(ICmpRHS) &&\n          (m_One().match(AddLHS) || m_One().match(AddRHS)))\n        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);\n    }\n\n    return false;\n  }\n};\n\n/// Match an icmp instruction checking for unsigned overflow on addition.\n///\n/// S is matched to the addition whose result is being checked for overflow, and\n/// L and R are matched to the LHS and RHS of S.\ntemplate <typename LHS_t, typename RHS_t, typename Sum_t>\nUAddWithOverflow_match<LHS_t, RHS_t, Sum_t>\nm_UAddWithOverflow(const LHS_t &L, const RHS_t &R, const Sum_t &S) {\n  return UAddWithOverflow_match<LHS_t, RHS_t, Sum_t>(L, R, S);\n}\n\ntemplate <typename Opnd_t> struct Argument_match {\n  unsigned OpI;\n  Opnd_t Val;\n\n  Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    // FIXME: Should likely be switched to use `CallBase`.\n    if (const auto *CI = dyn_cast<CallInst>(V))\n      return Val.match(CI->getArgOperand(OpI));\n    return false;\n  }\n};\n\n/// Match an argument.\ntemplate <unsigned OpI, typename Opnd_t>\ninline Argument_match<Opnd_t> m_Argument(const Opnd_t &Op) {\n  return Argument_match<Opnd_t>(OpI, Op);\n}\n\n/// Intrinsic matchers.\nstruct IntrinsicID_match {\n  unsigned ID;\n\n  IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (const auto *CI = dyn_cast<CallInst>(V))\n      if (const auto *F = CI->getCalledFunction())\n        return F->getIntrinsicID() == ID;\n    return false;\n  }\n};\n\n/// Intrinsic matches are combinations of ID matchers, and argument\n/// matchers. Higher arity matcher are defined recursively in terms of and-ing\n/// them with lower arity matchers. Here's some convenient typedefs for up to\n/// several arguments, and more can be added as needed\ntemplate <typename T0 = void, typename T1 = void, typename T2 = void,\n          typename T3 = void, typename T4 = void, typename T5 = void,\n          typename T6 = void, typename T7 = void, typename T8 = void,\n          typename T9 = void, typename T10 = void>\nstruct m_Intrinsic_Ty;\ntemplate <typename T0> struct m_Intrinsic_Ty<T0> {\n  using Ty = match_combine_and<IntrinsicID_match, Argument_match<T0>>;\n};\ntemplate <typename T0, typename T1> struct m_Intrinsic_Ty<T0, T1> {\n  using Ty =\n      match_combine_and<typename m_Intrinsic_Ty<T0>::Ty, Argument_match<T1>>;\n};\ntemplate <typename T0, typename T1, typename T2>\nstruct m_Intrinsic_Ty<T0, T1, T2> {\n  using Ty =\n      match_combine_and<typename m_Intrinsic_Ty<T0, T1>::Ty,\n                        Argument_match<T2>>;\n};\ntemplate <typename T0, typename T1, typename T2, typename T3>\nstruct m_Intrinsic_Ty<T0, T1, T2, T3> {\n  using Ty =\n      match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2>::Ty,\n                        Argument_match<T3>>;\n};\n\ntemplate <typename T0, typename T1, typename T2, typename T3, typename T4>\nstruct m_Intrinsic_Ty<T0, T1, T2, T3, T4> {\n  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty,\n                               Argument_match<T4>>;\n};\n\ntemplate <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>\nstruct m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5> {\n  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty,\n                               Argument_match<T5>>;\n};\n\n/// Match intrinsic calls like this:\n/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))\ntemplate <Intrinsic::ID IntrID> inline IntrinsicID_match m_Intrinsic() {\n  return IntrinsicID_match(IntrID);\n}\n\ntemplate <Intrinsic::ID IntrID, typename T0>\ninline typename m_Intrinsic_Ty<T0>::Ty m_Intrinsic(const T0 &Op0) {\n  return m_CombineAnd(m_Intrinsic<IntrID>(), m_Argument<0>(Op0));\n}\n\ntemplate <Intrinsic::ID IntrID, typename T0, typename T1>\ninline typename m_Intrinsic_Ty<T0, T1>::Ty m_Intrinsic(const T0 &Op0,\n                                                       const T1 &Op1) {\n  return m_CombineAnd(m_Intrinsic<IntrID>(Op0), m_Argument<1>(Op1));\n}\n\ntemplate <Intrinsic::ID IntrID, typename T0, typename T1, typename T2>\ninline typename m_Intrinsic_Ty<T0, T1, T2>::Ty\nm_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2) {\n  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1), m_Argument<2>(Op2));\n}\n\ntemplate <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,\n          typename T3>\ninline typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty\nm_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3) {\n  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2), m_Argument<3>(Op3));\n}\n\ntemplate <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,\n          typename T3, typename T4>\ninline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty\nm_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,\n            const T4 &Op4) {\n  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3),\n                      m_Argument<4>(Op4));\n}\n\ntemplate <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,\n          typename T3, typename T4, typename T5>\ninline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5>::Ty\nm_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,\n            const T4 &Op4, const T5 &Op5) {\n  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3, Op4),\n                      m_Argument<5>(Op5));\n}\n\n// Helper intrinsic matching specializations.\ntemplate <typename Opnd0>\ninline typename m_Intrinsic_Ty<Opnd0>::Ty m_BitReverse(const Opnd0 &Op0) {\n  return m_Intrinsic<Intrinsic::bitreverse>(Op0);\n}\n\ntemplate <typename Opnd0>\ninline typename m_Intrinsic_Ty<Opnd0>::Ty m_BSwap(const Opnd0 &Op0) {\n  return m_Intrinsic<Intrinsic::bswap>(Op0);\n}\n\ntemplate <typename Opnd0>\ninline typename m_Intrinsic_Ty<Opnd0>::Ty m_FAbs(const Opnd0 &Op0) {\n  return m_Intrinsic<Intrinsic::fabs>(Op0);\n}\n\ntemplate <typename Opnd0>\ninline typename m_Intrinsic_Ty<Opnd0>::Ty m_FCanonicalize(const Opnd0 &Op0) {\n  return m_Intrinsic<Intrinsic::canonicalize>(Op0);\n}\n\ntemplate <typename Opnd0, typename Opnd1>\ninline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMin(const Opnd0 &Op0,\n                                                        const Opnd1 &Op1) {\n  return m_Intrinsic<Intrinsic::minnum>(Op0, Op1);\n}\n\ntemplate <typename Opnd0, typename Opnd1>\ninline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMax(const Opnd0 &Op0,\n                                                        const Opnd1 &Op1) {\n  return m_Intrinsic<Intrinsic::maxnum>(Op0, Op1);\n}\n\ntemplate <typename Opnd0, typename Opnd1, typename Opnd2>\ninline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty\nm_FShl(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {\n  return m_Intrinsic<Intrinsic::fshl>(Op0, Op1, Op2);\n}\n\ntemplate <typename Opnd0, typename Opnd1, typename Opnd2>\ninline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty\nm_FShr(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {\n  return m_Intrinsic<Intrinsic::fshr>(Op0, Op1, Op2);\n}\n\n//===----------------------------------------------------------------------===//\n// Matchers for two-operands operators with the operators in either order\n//\n\n/// Matches a BinaryOperator with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline AnyBinaryOp_match<LHS, RHS, true> m_c_BinOp(const LHS &L, const RHS &R) {\n  return AnyBinaryOp_match<LHS, RHS, true>(L, R);\n}\n\n/// Matches an ICmp with a predicate over LHS and RHS in either order.\n/// Swaps the predicate if operands are commuted.\ntemplate <typename LHS, typename RHS>\ninline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>\nm_c_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {\n  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>(Pred, L,\n                                                                       R);\n}\n\n/// Matches a Add with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Add, true> m_c_Add(const LHS &L,\n                                                                const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Add, true>(L, R);\n}\n\n/// Matches a Mul with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Mul, true> m_c_Mul(const LHS &L,\n                                                                const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Mul, true>(L, R);\n}\n\n/// Matches an And with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::And, true> m_c_And(const LHS &L,\n                                                                const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::And, true>(L, R);\n}\n\n/// Matches an Or with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Or, true> m_c_Or(const LHS &L,\n                                                              const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Or, true>(L, R);\n}\n\n/// Matches an Xor with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::Xor, true> m_c_Xor(const LHS &L,\n                                                                const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::Xor, true>(L, R);\n}\n\n/// Matches a 'Neg' as 'sub 0, V'.\ntemplate <typename ValTy>\ninline BinaryOp_match<cst_pred_ty<is_zero_int>, ValTy, Instruction::Sub>\nm_Neg(const ValTy &V) {\n  return m_Sub(m_ZeroInt(), V);\n}\n\n/// Matches a 'Neg' as 'sub nsw 0, V'.\ntemplate <typename ValTy>\ninline OverflowingBinaryOp_match<cst_pred_ty<is_zero_int>, ValTy,\n                                 Instruction::Sub,\n                                 OverflowingBinaryOperator::NoSignedWrap>\nm_NSWNeg(const ValTy &V) {\n  return m_NSWSub(m_ZeroInt(), V);\n}\n\n/// Matches a 'Not' as 'xor V, -1' or 'xor -1, V'.\ntemplate <typename ValTy>\ninline BinaryOp_match<ValTy, cst_pred_ty<is_all_ones>, Instruction::Xor, true>\nm_Not(const ValTy &V) {\n  return m_c_Xor(V, m_AllOnes());\n}\n\n/// Matches an SMin with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>\nm_c_SMin(const LHS &L, const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>(L, R);\n}\n/// Matches an SMax with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>\nm_c_SMax(const LHS &L, const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>(L, R);\n}\n/// Matches a UMin with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>\nm_c_UMin(const LHS &L, const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>(L, R);\n}\n/// Matches a UMax with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>\nm_c_UMax(const LHS &L, const RHS &R) {\n  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>(L, R);\n}\n\ntemplate <typename LHS, typename RHS>\ninline match_combine_or<\n    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>,\n                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>>,\n    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>,\n                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>>>\nm_c_MaxOrMin(const LHS &L, const RHS &R) {\n  return m_CombineOr(m_CombineOr(m_c_SMax(L, R), m_c_SMin(L, R)),\n                     m_CombineOr(m_c_UMax(L, R), m_c_UMin(L, R)));\n}\n\n/// Matches FAdd with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FAdd, true>\nm_c_FAdd(const LHS &L, const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FAdd, true>(L, R);\n}\n\n/// Matches FMul with LHS and RHS in either order.\ntemplate <typename LHS, typename RHS>\ninline BinaryOp_match<LHS, RHS, Instruction::FMul, true>\nm_c_FMul(const LHS &L, const RHS &R) {\n  return BinaryOp_match<LHS, RHS, Instruction::FMul, true>(L, R);\n}\n\ntemplate <typename Opnd_t> struct Signum_match {\n  Opnd_t Val;\n  Signum_match(const Opnd_t &V) : Val(V) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    unsigned TypeSize = V->getType()->getScalarSizeInBits();\n    if (TypeSize == 0)\n      return false;\n\n    unsigned ShiftWidth = TypeSize - 1;\n    Value *OpL = nullptr, *OpR = nullptr;\n\n    // This is the representation of signum we match:\n    //\n    //  signum(x) == (x >> 63) | (-x >>u 63)\n    //\n    // An i1 value is its own signum, so it's correct to match\n    //\n    //  signum(x) == (x >> 0)  | (-x >>u 0)\n    //\n    // for i1 values.\n\n    auto LHS = m_AShr(m_Value(OpL), m_SpecificInt(ShiftWidth));\n    auto RHS = m_LShr(m_Neg(m_Value(OpR)), m_SpecificInt(ShiftWidth));\n    auto Signum = m_Or(LHS, RHS);\n\n    return Signum.match(V) && OpL == OpR && Val.match(OpL);\n  }\n};\n\n/// Matches a signum pattern.\n///\n/// signum(x) =\n///      x >  0  ->  1\n///      x == 0  ->  0\n///      x <  0  -> -1\ntemplate <typename Val_t> inline Signum_match<Val_t> m_Signum(const Val_t &V) {\n  return Signum_match<Val_t>(V);\n}\n\ntemplate <int Ind, typename Opnd_t> struct ExtractValue_match {\n  Opnd_t Val;\n  ExtractValue_match(const Opnd_t &V) : Val(V) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<ExtractValueInst>(V)) {\n      // If Ind is -1, don't inspect indices\n      if (Ind != -1 &&\n          !(I->getNumIndices() == 1 && I->getIndices()[0] == (unsigned)Ind))\n        return false;\n      return Val.match(I->getAggregateOperand());\n    }\n    return false;\n  }\n};\n\n/// Match a single index ExtractValue instruction.\n/// For example m_ExtractValue<1>(...)\ntemplate <int Ind, typename Val_t>\ninline ExtractValue_match<Ind, Val_t> m_ExtractValue(const Val_t &V) {\n  return ExtractValue_match<Ind, Val_t>(V);\n}\n\n/// Match an ExtractValue instruction with any index.\n/// For example m_ExtractValue(...)\ntemplate <typename Val_t>\ninline ExtractValue_match<-1, Val_t> m_ExtractValue(const Val_t &V) {\n  return ExtractValue_match<-1, Val_t>(V);\n}\n\n/// Matcher for a single index InsertValue instruction.\ntemplate <int Ind, typename T0, typename T1> struct InsertValue_match {\n  T0 Op0;\n  T1 Op1;\n\n  InsertValue_match(const T0 &Op0, const T1 &Op1) : Op0(Op0), Op1(Op1) {}\n\n  template <typename OpTy> bool match(OpTy *V) {\n    if (auto *I = dyn_cast<InsertValueInst>(V)) {\n      return Op0.match(I->getOperand(0)) && Op1.match(I->getOperand(1)) &&\n             I->getNumIndices() == 1 && Ind == I->getIndices()[0];\n    }\n    return false;\n  }\n};\n\n/// Matches a single index InsertValue instruction.\ntemplate <int Ind, typename Val_t, typename Elt_t>\ninline InsertValue_match<Ind, Val_t, Elt_t> m_InsertValue(const Val_t &Val,\n                                                          const Elt_t &Elt) {\n  return InsertValue_match<Ind, Val_t, Elt_t>(Val, Elt);\n}\n\n/// Matches patterns for `vscale`. This can either be a call to `llvm.vscale` or\n/// the constant expression\n///  `ptrtoint(gep <vscale x 1 x i8>, <vscale x 1 x i8>* null, i32 1>`\n/// under the right conditions determined by DataLayout.\nstruct VScaleVal_match {\nprivate:\n  template <typename Base, typename Offset>\n  inline BinaryOp_match<Base, Offset, Instruction::GetElementPtr>\n  m_OffsetGep(const Base &B, const Offset &O) {\n    return BinaryOp_match<Base, Offset, Instruction::GetElementPtr>(B, O);\n  }\n\npublic:\n  const DataLayout &DL;\n  VScaleVal_match(const DataLayout &DL) : DL(DL) {}\n\n  template <typename ITy> bool match(ITy *V) {\n    if (m_Intrinsic<Intrinsic::vscale>().match(V))\n      return true;\n\n    if (m_PtrToInt(m_OffsetGep(m_Zero(), m_SpecificInt(1))).match(V)) {\n      Type *PtrTy = cast<Operator>(V)->getOperand(0)->getType();\n      auto *DerefTy = PtrTy->getPointerElementType();\n      if (isa<ScalableVectorType>(DerefTy) &&\n          DL.getTypeAllocSizeInBits(DerefTy).getKnownMinSize() == 8)\n        return true;\n    }\n\n    return false;\n  }\n};\n\ninline VScaleVal_match m_VScale(const DataLayout &DL) {\n  return VScaleVal_match(DL);\n}\n\ntemplate <typename LHS, typename RHS, unsigned Opcode>\nstruct LogicalOp_match {\n  LHS L;\n  RHS R;\n\n  LogicalOp_match(const LHS &L, const RHS &R) : L(L), R(R) {}\n\n  template <typename T> bool match(T *V) {\n    if (auto *I = dyn_cast<Instruction>(V)) {\n      if (!I->getType()->isIntOrIntVectorTy(1))\n        return false;\n\n      if (I->getOpcode() == Opcode && L.match(I->getOperand(0)) &&\n          R.match(I->getOperand(1)))\n        return true;\n\n      if (auto *SI = dyn_cast<SelectInst>(I)) {\n        if (Opcode == Instruction::And) {\n          if (const auto *C = dyn_cast<Constant>(SI->getFalseValue()))\n            if (C->isNullValue() && L.match(SI->getCondition()) &&\n                R.match(SI->getTrueValue()))\n              return true;\n        } else {\n          assert(Opcode == Instruction::Or);\n          if (const auto *C = dyn_cast<Constant>(SI->getTrueValue()))\n            if (C->isOneValue() && L.match(SI->getCondition()) &&\n                R.match(SI->getFalseValue()))\n              return true;\n        }\n      }\n    }\n\n    return false;\n  }\n};\n\n/// Matches L && R either in the form of L & R or L ? R : false.\n/// Note that the latter form is poison-blocking.\ntemplate <typename LHS, typename RHS>\ninline LogicalOp_match<LHS, RHS, Instruction::And>\nm_LogicalAnd(const LHS &L, const RHS &R) {\n  return LogicalOp_match<LHS, RHS, Instruction::And>(L, R);\n}\n\n/// Matches L && R where L and R are arbitrary values.\ninline auto m_LogicalAnd() { return m_LogicalAnd(m_Value(), m_Value()); }\n\n/// Matches L || R either in the form of L | R or L ? true : R.\n/// Note that the latter form is poison-blocking.\ntemplate <typename LHS, typename RHS>\ninline LogicalOp_match<LHS, RHS, Instruction::Or>\nm_LogicalOr(const LHS &L, const RHS &R) {\n  return LogicalOp_match<LHS, RHS, Instruction::Or>(L, R);\n}\n\n/// Matches L || R where L and R are arbitrary values.\ninline auto m_LogicalOr() {\n  return m_LogicalOr(m_Value(), m_Value());\n}\n\n} // end namespace PatternMatch\n} // end namespace llvm\n\n#endif // LLVM_IR_PATTERNMATCH_H\n"}, "72": {"id": 72, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "content": "//===- InstCombineVectorOps.cpp -------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements instcombine for ExtractElement, InsertElement and\n// ShuffleVector.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"InstCombineInternal.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Transforms/InstCombine/InstCombineWorklist.h\"\n#include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nusing namespace llvm;\nusing namespace PatternMatch;\n\n#define DEBUG_TYPE \"instcombine\"\n\nSTATISTIC(NumAggregateReconstructionsSimplified,\n          \"Number of aggregate reconstructions turned into reuse of the \"\n          \"original aggregate\");\n\n/// Return true if the value is cheaper to scalarize than it is to leave as a\n/// vector operation. IsConstantExtractIndex indicates whether we are extracting\n/// one known element from a vector constant.\n///\n/// FIXME: It's possible to create more instructions than previously existed.\nstatic bool cheapToScalarize(Value *V, bool IsConstantExtractIndex) {\n  // If we can pick a scalar constant value out of a vector, that is free.\n  if (auto *C = dyn_cast<Constant>(V))\n    return IsConstantExtractIndex || C->getSplatValue();\n\n  // An insertelement to the same constant index as our extract will simplify\n  // to the scalar inserted element. An insertelement to a different constant\n  // index is irrelevant to our extract.\n  if (match(V, m_InsertElt(m_Value(), m_Value(), m_ConstantInt())))\n    return IsConstantExtractIndex;\n\n  if (match(V, m_OneUse(m_Load(m_Value()))))\n    return true;\n\n  if (match(V, m_OneUse(m_UnOp())))\n    return true;\n\n  Value *V0, *V1;\n  if (match(V, m_OneUse(m_BinOp(m_Value(V0), m_Value(V1)))))\n    if (cheapToScalarize(V0, IsConstantExtractIndex) ||\n        cheapToScalarize(V1, IsConstantExtractIndex))\n      return true;\n\n  CmpInst::Predicate UnusedPred;\n  if (match(V, m_OneUse(m_Cmp(UnusedPred, m_Value(V0), m_Value(V1)))))\n    if (cheapToScalarize(V0, IsConstantExtractIndex) ||\n        cheapToScalarize(V1, IsConstantExtractIndex))\n      return true;\n\n  return false;\n}\n\n// If we have a PHI node with a vector type that is only used to feed\n// itself and be an operand of extractelement at a constant location,\n// try to replace the PHI of the vector type with a PHI of a scalar type.\nInstruction *InstCombinerImpl::scalarizePHI(ExtractElementInst &EI,\n                                            PHINode *PN) {\n  SmallVector<Instruction *, 2> Extracts;\n  // The users we want the PHI to have are:\n  // 1) The EI ExtractElement (we already know this)\n  // 2) Possibly more ExtractElements with the same index.\n  // 3) Another operand, which will feed back into the PHI.\n  Instruction *PHIUser = nullptr;\n  for (auto U : PN->users()) {\n    if (ExtractElementInst *EU = dyn_cast<ExtractElementInst>(U)) {\n      if (EI.getIndexOperand() == EU->getIndexOperand())\n        Extracts.push_back(EU);\n      else\n        return nullptr;\n    } else if (!PHIUser) {\n      PHIUser = cast<Instruction>(U);\n    } else {\n      return nullptr;\n    }\n  }\n\n  if (!PHIUser)\n    return nullptr;\n\n  // Verify that this PHI user has one use, which is the PHI itself,\n  // and that it is a binary operation which is cheap to scalarize.\n  // otherwise return nullptr.\n  if (!PHIUser->hasOneUse() || !(PHIUser->user_back() == PN) ||\n      !(isa<BinaryOperator>(PHIUser)) || !cheapToScalarize(PHIUser, true))\n    return nullptr;\n\n  // Create a scalar PHI node that will replace the vector PHI node\n  // just before the current PHI node.\n  PHINode *scalarPHI = cast<PHINode>(InsertNewInstWith(\n      PHINode::Create(EI.getType(), PN->getNumIncomingValues(), \"\"), *PN));\n  // Scalarize each PHI operand.\n  for (unsigned i = 0; i < PN->getNumIncomingValues(); i++) {\n    Value *PHIInVal = PN->getIncomingValue(i);\n    BasicBlock *inBB = PN->getIncomingBlock(i);\n    Value *Elt = EI.getIndexOperand();\n    // If the operand is the PHI induction variable:\n    if (PHIInVal == PHIUser) {\n      // Scalarize the binary operation. Its first operand is the\n      // scalar PHI, and the second operand is extracted from the other\n      // vector operand.\n      BinaryOperator *B0 = cast<BinaryOperator>(PHIUser);\n      unsigned opId = (B0->getOperand(0) == PN) ? 1 : 0;\n      Value *Op = InsertNewInstWith(\n          ExtractElementInst::Create(B0->getOperand(opId), Elt,\n                                     B0->getOperand(opId)->getName() + \".Elt\"),\n          *B0);\n      Value *newPHIUser = InsertNewInstWith(\n          BinaryOperator::CreateWithCopiedFlags(B0->getOpcode(),\n                                                scalarPHI, Op, B0), *B0);\n      scalarPHI->addIncoming(newPHIUser, inBB);\n    } else {\n      // Scalarize PHI input:\n      Instruction *newEI = ExtractElementInst::Create(PHIInVal, Elt, \"\");\n      // Insert the new instruction into the predecessor basic block.\n      Instruction *pos = dyn_cast<Instruction>(PHIInVal);\n      BasicBlock::iterator InsertPos;\n      if (pos && !isa<PHINode>(pos)) {\n        InsertPos = ++pos->getIterator();\n      } else {\n        InsertPos = inBB->getFirstInsertionPt();\n      }\n\n      InsertNewInstWith(newEI, *InsertPos);\n\n      scalarPHI->addIncoming(newEI, inBB);\n    }\n  }\n\n  for (auto E : Extracts)\n    replaceInstUsesWith(*E, scalarPHI);\n\n  return &EI;\n}\n\nstatic Instruction *foldBitcastExtElt(ExtractElementInst &Ext,\n                                      InstCombiner::BuilderTy &Builder,\n                                      bool IsBigEndian) {\n  Value *X;\n  uint64_t ExtIndexC;\n  if (!match(Ext.getVectorOperand(), m_BitCast(m_Value(X))) ||\n      !X->getType()->isVectorTy() ||\n      !match(Ext.getIndexOperand(), m_ConstantInt(ExtIndexC)))\n    return nullptr;\n\n  // If this extractelement is using a bitcast from a vector of the same number\n  // of elements, see if we can find the source element from the source vector:\n  // extelt (bitcast VecX), IndexC --> bitcast X[IndexC]\n  auto *SrcTy = cast<VectorType>(X->getType());\n  Type *DestTy = Ext.getType();\n  ElementCount NumSrcElts = SrcTy->getElementCount();\n  ElementCount NumElts =\n      cast<VectorType>(Ext.getVectorOperandType())->getElementCount();\n  if (NumSrcElts == NumElts)\n    if (Value *Elt = findScalarElement(X, ExtIndexC))\n      return new BitCastInst(Elt, DestTy);\n\n  assert(NumSrcElts.isScalable() == NumElts.isScalable() &&\n         \"Src and Dst must be the same sort of vector type\");\n\n  // If the source elements are wider than the destination, try to shift and\n  // truncate a subset of scalar bits of an insert op.\n  if (NumSrcElts.getKnownMinValue() < NumElts.getKnownMinValue()) {\n    Value *Scalar;\n    uint64_t InsIndexC;\n    if (!match(X, m_InsertElt(m_Value(), m_Value(Scalar),\n                              m_ConstantInt(InsIndexC))))\n      return nullptr;\n\n    // The extract must be from the subset of vector elements that we inserted\n    // into. Example: if we inserted element 1 of a <2 x i64> and we are\n    // extracting an i16 (narrowing ratio = 4), then this extract must be from 1\n    // of elements 4-7 of the bitcasted vector.\n    unsigned NarrowingRatio =\n        NumElts.getKnownMinValue() / NumSrcElts.getKnownMinValue();\n    if (ExtIndexC / NarrowingRatio != InsIndexC)\n      return nullptr;\n\n    // We are extracting part of the original scalar. How that scalar is\n    // inserted into the vector depends on the endian-ness. Example:\n    //              Vector Byte Elt Index:    0  1  2  3  4  5  6  7\n    //                                       +--+--+--+--+--+--+--+--+\n    // inselt <2 x i32> V, <i32> S, 1:       |V0|V1|V2|V3|S0|S1|S2|S3|\n    // extelt <4 x i16> V', 3:               |                 |S2|S3|\n    //                                       +--+--+--+--+--+--+--+--+\n    // If this is little-endian, S2|S3 are the MSB of the 32-bit 'S' value.\n    // If this is big-endian, S2|S3 are the LSB of the 32-bit 'S' value.\n    // In this example, we must right-shift little-endian. Big-endian is just a\n    // truncate.\n    unsigned Chunk = ExtIndexC % NarrowingRatio;\n    if (IsBigEndian)\n      Chunk = NarrowingRatio - 1 - Chunk;\n\n    // Bail out if this is an FP vector to FP vector sequence. That would take\n    // more instructions than we started with unless there is no shift, and it\n    // may not be handled as well in the backend.\n    bool NeedSrcBitcast = SrcTy->getScalarType()->isFloatingPointTy();\n    bool NeedDestBitcast = DestTy->isFloatingPointTy();\n    if (NeedSrcBitcast && NeedDestBitcast)\n      return nullptr;\n\n    unsigned SrcWidth = SrcTy->getScalarSizeInBits();\n    unsigned DestWidth = DestTy->getPrimitiveSizeInBits();\n    unsigned ShAmt = Chunk * DestWidth;\n\n    // TODO: This limitation is more strict than necessary. We could sum the\n    // number of new instructions and subtract the number eliminated to know if\n    // we can proceed.\n    if (!X->hasOneUse() || !Ext.getVectorOperand()->hasOneUse())\n      if (NeedSrcBitcast || NeedDestBitcast)\n        return nullptr;\n\n    if (NeedSrcBitcast) {\n      Type *SrcIntTy = IntegerType::getIntNTy(Scalar->getContext(), SrcWidth);\n      Scalar = Builder.CreateBitCast(Scalar, SrcIntTy);\n    }\n\n    if (ShAmt) {\n      // Bail out if we could end with more instructions than we started with.\n      if (!Ext.getVectorOperand()->hasOneUse())\n        return nullptr;\n      Scalar = Builder.CreateLShr(Scalar, ShAmt);\n    }\n\n    if (NeedDestBitcast) {\n      Type *DestIntTy = IntegerType::getIntNTy(Scalar->getContext(), DestWidth);\n      return new BitCastInst(Builder.CreateTrunc(Scalar, DestIntTy), DestTy);\n    }\n    return new TruncInst(Scalar, DestTy);\n  }\n\n  return nullptr;\n}\n\n/// Find elements of V demanded by UserInstr.\nstatic APInt findDemandedEltsBySingleUser(Value *V, Instruction *UserInstr) {\n  unsigned VWidth = cast<FixedVectorType>(V->getType())->getNumElements();\n\n  // Conservatively assume that all elements are needed.\n  APInt UsedElts(APInt::getAllOnesValue(VWidth));\n\n  switch (UserInstr->getOpcode()) {\n  case Instruction::ExtractElement: {\n    ExtractElementInst *EEI = cast<ExtractElementInst>(UserInstr);\n    assert(EEI->getVectorOperand() == V);\n    ConstantInt *EEIIndexC = dyn_cast<ConstantInt>(EEI->getIndexOperand());\n    if (EEIIndexC && EEIIndexC->getValue().ult(VWidth)) {\n      UsedElts = APInt::getOneBitSet(VWidth, EEIIndexC->getZExtValue());\n    }\n    break;\n  }\n  case Instruction::ShuffleVector: {\n    ShuffleVectorInst *Shuffle = cast<ShuffleVectorInst>(UserInstr);\n    unsigned MaskNumElts =\n        cast<FixedVectorType>(UserInstr->getType())->getNumElements();\n\n    UsedElts = APInt(VWidth, 0);\n    for (unsigned i = 0; i < MaskNumElts; i++) {\n      unsigned MaskVal = Shuffle->getMaskValue(i);\n      if (MaskVal == -1u || MaskVal >= 2 * VWidth)\n        continue;\n      if (Shuffle->getOperand(0) == V && (MaskVal < VWidth))\n        UsedElts.setBit(MaskVal);\n      if (Shuffle->getOperand(1) == V &&\n          ((MaskVal >= VWidth) && (MaskVal < 2 * VWidth)))\n        UsedElts.setBit(MaskVal - VWidth);\n    }\n    break;\n  }\n  default:\n    break;\n  }\n  return UsedElts;\n}\n\n/// Find union of elements of V demanded by all its users.\n/// If it is known by querying findDemandedEltsBySingleUser that\n/// no user demands an element of V, then the corresponding bit\n/// remains unset in the returned value.\nstatic APInt findDemandedEltsByAllUsers(Value *V) {\n  unsigned VWidth = cast<FixedVectorType>(V->getType())->getNumElements();\n\n  APInt UnionUsedElts(VWidth, 0);\n  for (const Use &U : V->uses()) {\n    if (Instruction *I = dyn_cast<Instruction>(U.getUser())) {\n      UnionUsedElts |= findDemandedEltsBySingleUser(V, I);\n    } else {\n      UnionUsedElts = APInt::getAllOnesValue(VWidth);\n      break;\n    }\n\n    if (UnionUsedElts.isAllOnesValue())\n      break;\n  }\n\n  return UnionUsedElts;\n}\n\nInstruction *InstCombinerImpl::visitExtractElementInst(ExtractElementInst &EI) {\n  Value *SrcVec = EI.getVectorOperand();\n  Value *Index = EI.getIndexOperand();\n  if (Value *V = SimplifyExtractElementInst(SrcVec, Index,\n                                            SQ.getWithInstruction(&EI)))\n    return replaceInstUsesWith(EI, V);\n\n  // If extracting a specified index from the vector, see if we can recursively\n  // find a previously computed scalar that was inserted into the vector.\n  auto *IndexC = dyn_cast<ConstantInt>(Index);\n  if (IndexC) {\n    ElementCount EC = EI.getVectorOperandType()->getElementCount();\n    unsigned NumElts = EC.getKnownMinValue();\n\n    // InstSimplify should handle cases where the index is invalid.\n    // For fixed-length vector, it's invalid to extract out-of-range element.\n    if (!EC.isScalable() && IndexC->getValue().uge(NumElts))\n      return nullptr;\n\n    // This instruction only demands the single element from the input vector.\n    // Skip for scalable type, the number of elements is unknown at\n    // compile-time.\n    if (!EC.isScalable() && NumElts != 1) {\n      // If the input vector has a single use, simplify it based on this use\n      // property.\n      if (SrcVec->hasOneUse()) {\n        APInt UndefElts(NumElts, 0);\n        APInt DemandedElts(NumElts, 0);\n        DemandedElts.setBit(IndexC->getZExtValue());\n        if (Value *V =\n                SimplifyDemandedVectorElts(SrcVec, DemandedElts, UndefElts))\n          return replaceOperand(EI, 0, V);\n      } else {\n        // If the input vector has multiple uses, simplify it based on a union\n        // of all elements used.\n        APInt DemandedElts = findDemandedEltsByAllUsers(SrcVec);\n        if (!DemandedElts.isAllOnesValue()) {\n          APInt UndefElts(NumElts, 0);\n          if (Value *V = SimplifyDemandedVectorElts(\n                  SrcVec, DemandedElts, UndefElts, 0 /* Depth */,\n                  true /* AllowMultipleUsers */)) {\n            if (V != SrcVec) {\n              SrcVec->replaceAllUsesWith(V);\n              return &EI;\n            }\n          }\n        }\n      }\n    }\n    if (Instruction *I = foldBitcastExtElt(EI, Builder, DL.isBigEndian()))\n      return I;\n\n    // If there's a vector PHI feeding a scalar use through this extractelement\n    // instruction, try to scalarize the PHI.\n    if (auto *Phi = dyn_cast<PHINode>(SrcVec))\n      if (Instruction *ScalarPHI = scalarizePHI(EI, Phi))\n        return ScalarPHI;\n  }\n\n  // TODO come up with a n-ary matcher that subsumes both unary and\n  // binary matchers.\n  UnaryOperator *UO;\n  if (match(SrcVec, m_UnOp(UO)) && cheapToScalarize(SrcVec, IndexC)) {\n    // extelt (unop X), Index --> unop (extelt X, Index)\n    Value *X = UO->getOperand(0);\n    Value *E = Builder.CreateExtractElement(X, Index);\n    return UnaryOperator::CreateWithCopiedFlags(UO->getOpcode(), E, UO);\n  }\n\n  BinaryOperator *BO;\n  if (match(SrcVec, m_BinOp(BO)) && cheapToScalarize(SrcVec, IndexC)) {\n    // extelt (binop X, Y), Index --> binop (extelt X, Index), (extelt Y, Index)\n    Value *X = BO->getOperand(0), *Y = BO->getOperand(1);\n    Value *E0 = Builder.CreateExtractElement(X, Index);\n    Value *E1 = Builder.CreateExtractElement(Y, Index);\n    return BinaryOperator::CreateWithCopiedFlags(BO->getOpcode(), E0, E1, BO);\n  }\n\n  Value *X, *Y;\n  CmpInst::Predicate Pred;\n  if (match(SrcVec, m_Cmp(Pred, m_Value(X), m_Value(Y))) &&\n      cheapToScalarize(SrcVec, IndexC)) {\n    // extelt (cmp X, Y), Index --> cmp (extelt X, Index), (extelt Y, Index)\n    Value *E0 = Builder.CreateExtractElement(X, Index);\n    Value *E1 = Builder.CreateExtractElement(Y, Index);\n    return CmpInst::Create(cast<CmpInst>(SrcVec)->getOpcode(), Pred, E0, E1);\n  }\n\n  if (auto *I = dyn_cast<Instruction>(SrcVec)) {\n    if (auto *IE = dyn_cast<InsertElementInst>(I)) {\n      // Extracting the inserted element?\n      if (IE->getOperand(2) == Index)\n        return replaceInstUsesWith(EI, IE->getOperand(1));\n      // If the inserted and extracted elements are constants, they must not\n      // be the same value, extract from the pre-inserted value instead.\n      if (isa<Constant>(IE->getOperand(2)) && IndexC)\n        return replaceOperand(EI, 0, IE->getOperand(0));\n    } else if (auto *SVI = dyn_cast<ShuffleVectorInst>(I)) {\n      // If this is extracting an element from a shufflevector, figure out where\n      // it came from and extract from the appropriate input element instead.\n      // Restrict the following transformation to fixed-length vector.\n      if (isa<FixedVectorType>(SVI->getType()) && isa<ConstantInt>(Index)) {\n        int SrcIdx =\n            SVI->getMaskValue(cast<ConstantInt>(Index)->getZExtValue());\n        Value *Src;\n        unsigned LHSWidth = cast<FixedVectorType>(SVI->getOperand(0)->getType())\n                                ->getNumElements();\n\n        if (SrcIdx < 0)\n          return replaceInstUsesWith(EI, UndefValue::get(EI.getType()));\n        if (SrcIdx < (int)LHSWidth)\n          Src = SVI->getOperand(0);\n        else {\n          SrcIdx -= LHSWidth;\n          Src = SVI->getOperand(1);\n        }\n        Type *Int32Ty = Type::getInt32Ty(EI.getContext());\n        return ExtractElementInst::Create(\n            Src, ConstantInt::get(Int32Ty, SrcIdx, false));\n      }\n    } else if (auto *CI = dyn_cast<CastInst>(I)) {\n      // Canonicalize extractelement(cast) -> cast(extractelement).\n      // Bitcasts can change the number of vector elements, and they cost\n      // nothing.\n      if (CI->hasOneUse() && (CI->getOpcode() != Instruction::BitCast)) {\n        Value *EE = Builder.CreateExtractElement(CI->getOperand(0), Index);\n        return CastInst::Create(CI->getOpcode(), EE, EI.getType());\n      }\n    }\n  }\n  return nullptr;\n}\n\n/// If V is a shuffle of values that ONLY returns elements from either LHS or\n/// RHS, return the shuffle mask and true. Otherwise, return false.\nstatic bool collectSingleShuffleElements(Value *V, Value *LHS, Value *RHS,\n                                         SmallVectorImpl<int> &Mask) {\n  assert(LHS->getType() == RHS->getType() &&\n         \"Invalid CollectSingleShuffleElements\");\n  unsigned NumElts = cast<FixedVectorType>(V->getType())->getNumElements();\n\n  if (isa<UndefValue>(V)) {\n    Mask.assign(NumElts, -1);\n    return true;\n  }\n\n  if (V == LHS) {\n    for (unsigned i = 0; i != NumElts; ++i)\n      Mask.push_back(i);\n    return true;\n  }\n\n  if (V == RHS) {\n    for (unsigned i = 0; i != NumElts; ++i)\n      Mask.push_back(i + NumElts);\n    return true;\n  }\n\n  if (InsertElementInst *IEI = dyn_cast<InsertElementInst>(V)) {\n    // If this is an insert of an extract from some other vector, include it.\n    Value *VecOp    = IEI->getOperand(0);\n    Value *ScalarOp = IEI->getOperand(1);\n    Value *IdxOp    = IEI->getOperand(2);\n\n    if (!isa<ConstantInt>(IdxOp))\n      return false;\n    unsigned InsertedIdx = cast<ConstantInt>(IdxOp)->getZExtValue();\n\n    if (isa<UndefValue>(ScalarOp)) {  // inserting undef into vector.\n      // We can handle this if the vector we are inserting into is\n      // transitively ok.\n      if (collectSingleShuffleElements(VecOp, LHS, RHS, Mask)) {\n        // If so, update the mask to reflect the inserted undef.\n        Mask[InsertedIdx] = -1;\n        return true;\n      }\n    } else if (ExtractElementInst *EI = dyn_cast<ExtractElementInst>(ScalarOp)){\n      if (isa<ConstantInt>(EI->getOperand(1))) {\n        unsigned ExtractedIdx =\n        cast<ConstantInt>(EI->getOperand(1))->getZExtValue();\n        unsigned NumLHSElts =\n            cast<FixedVectorType>(LHS->getType())->getNumElements();\n\n        // This must be extracting from either LHS or RHS.\n        if (EI->getOperand(0) == LHS || EI->getOperand(0) == RHS) {\n          // We can handle this if the vector we are inserting into is\n          // transitively ok.\n          if (collectSingleShuffleElements(VecOp, LHS, RHS, Mask)) {\n            // If so, update the mask to reflect the inserted value.\n            if (EI->getOperand(0) == LHS) {\n              Mask[InsertedIdx % NumElts] = ExtractedIdx;\n            } else {\n              assert(EI->getOperand(0) == RHS);\n              Mask[InsertedIdx % NumElts] = ExtractedIdx + NumLHSElts;\n            }\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/// If we have insertion into a vector that is wider than the vector that we\n/// are extracting from, try to widen the source vector to allow a single\n/// shufflevector to replace one or more insert/extract pairs.\nstatic void replaceExtractElements(InsertElementInst *InsElt,\n                                   ExtractElementInst *ExtElt,\n                                   InstCombinerImpl &IC) {\n  auto *InsVecType = cast<FixedVectorType>(InsElt->getType());\n  auto *ExtVecType = cast<FixedVectorType>(ExtElt->getVectorOperandType());\n  unsigned NumInsElts = InsVecType->getNumElements();\n  unsigned NumExtElts = ExtVecType->getNumElements();\n\n  // The inserted-to vector must be wider than the extracted-from vector.\n  if (InsVecType->getElementType() != ExtVecType->getElementType() ||\n      NumExtElts >= NumInsElts)\n    return;\n\n  // Create a shuffle mask to widen the extended-from vector using undefined\n  // values. The mask selects all of the values of the original vector followed\n  // by as many undefined values as needed to create a vector of the same length\n  // as the inserted-to vector.\n  SmallVector<int, 16> ExtendMask;\n  for (unsigned i = 0; i < NumExtElts; ++i)\n    ExtendMask.push_back(i);\n  for (unsigned i = NumExtElts; i < NumInsElts; ++i)\n    ExtendMask.push_back(-1);\n\n  Value *ExtVecOp = ExtElt->getVectorOperand();\n  auto *ExtVecOpInst = dyn_cast<Instruction>(ExtVecOp);\n  BasicBlock *InsertionBlock = (ExtVecOpInst && !isa<PHINode>(ExtVecOpInst))\n                                   ? ExtVecOpInst->getParent()\n                                   : ExtElt->getParent();\n\n  // TODO: This restriction matches the basic block check below when creating\n  // new extractelement instructions. If that limitation is removed, this one\n  // could also be removed. But for now, we just bail out to ensure that we\n  // will replace the extractelement instruction that is feeding our\n  // insertelement instruction. This allows the insertelement to then be\n  // replaced by a shufflevector. If the insertelement is not replaced, we can\n  // induce infinite looping because there's an optimization for extractelement\n  // that will delete our widening shuffle. This would trigger another attempt\n  // here to create that shuffle, and we spin forever.\n  if (InsertionBlock != InsElt->getParent())\n    return;\n\n  // TODO: This restriction matches the check in visitInsertElementInst() and\n  // prevents an infinite loop caused by not turning the extract/insert pair\n  // into a shuffle. We really should not need either check, but we're lacking\n  // folds for shufflevectors because we're afraid to generate shuffle masks\n  // that the backend can't handle.\n  if (InsElt->hasOneUse() && isa<InsertElementInst>(InsElt->user_back()))\n    return;\n\n  auto *WideVec =\n      new ShuffleVectorInst(ExtVecOp, UndefValue::get(ExtVecType), ExtendMask);\n\n  // Insert the new shuffle after the vector operand of the extract is defined\n  // (as long as it's not a PHI) or at the start of the basic block of the\n  // extract, so any subsequent extracts in the same basic block can use it.\n  // TODO: Insert before the earliest ExtractElementInst that is replaced.\n  if (ExtVecOpInst && !isa<PHINode>(ExtVecOpInst))\n    WideVec->insertAfter(ExtVecOpInst);\n  else\n    IC.InsertNewInstWith(WideVec, *ExtElt->getParent()->getFirstInsertionPt());\n\n  // Replace extracts from the original narrow vector with extracts from the new\n  // wide vector.\n  for (User *U : ExtVecOp->users()) {\n    ExtractElementInst *OldExt = dyn_cast<ExtractElementInst>(U);\n    if (!OldExt || OldExt->getParent() != WideVec->getParent())\n      continue;\n    auto *NewExt = ExtractElementInst::Create(WideVec, OldExt->getOperand(1));\n    NewExt->insertAfter(OldExt);\n    IC.replaceInstUsesWith(*OldExt, NewExt);\n  }\n}\n\n/// We are building a shuffle to create V, which is a sequence of insertelement,\n/// extractelement pairs. If PermittedRHS is set, then we must either use it or\n/// not rely on the second vector source. Return a std::pair containing the\n/// left and right vectors of the proposed shuffle (or 0), and set the Mask\n/// parameter as required.\n///\n/// Note: we intentionally don't try to fold earlier shuffles since they have\n/// often been chosen carefully to be efficiently implementable on the target.\nusing ShuffleOps = std::pair<Value *, Value *>;\n\nstatic ShuffleOps collectShuffleElements(Value *V, SmallVectorImpl<int> &Mask,\n                                         Value *PermittedRHS,\n                                         InstCombinerImpl &IC) {\n  assert(V->getType()->isVectorTy() && \"Invalid shuffle!\");\n  unsigned NumElts = cast<FixedVectorType>(V->getType())->getNumElements();\n\n  if (isa<UndefValue>(V)) {\n    Mask.assign(NumElts, -1);\n    return std::make_pair(\n        PermittedRHS ? UndefValue::get(PermittedRHS->getType()) : V, nullptr);\n  }\n\n  if (isa<ConstantAggregateZero>(V)) {\n    Mask.assign(NumElts, 0);\n    return std::make_pair(V, nullptr);\n  }\n\n  if (InsertElementInst *IEI = dyn_cast<InsertElementInst>(V)) {\n    // If this is an insert of an extract from some other vector, include it.\n    Value *VecOp    = IEI->getOperand(0);\n    Value *ScalarOp = IEI->getOperand(1);\n    Value *IdxOp    = IEI->getOperand(2);\n\n    if (ExtractElementInst *EI = dyn_cast<ExtractElementInst>(ScalarOp)) {\n      if (isa<ConstantInt>(EI->getOperand(1)) && isa<ConstantInt>(IdxOp)) {\n        unsigned ExtractedIdx =\n          cast<ConstantInt>(EI->getOperand(1))->getZExtValue();\n        unsigned InsertedIdx = cast<ConstantInt>(IdxOp)->getZExtValue();\n\n        // Either the extracted from or inserted into vector must be RHSVec,\n        // otherwise we'd end up with a shuffle of three inputs.\n        if (EI->getOperand(0) == PermittedRHS || PermittedRHS == nullptr) {\n          Value *RHS = EI->getOperand(0);\n          ShuffleOps LR = collectShuffleElements(VecOp, Mask, RHS, IC);\n          assert(LR.second == nullptr || LR.second == RHS);\n\n          if (LR.first->getType() != RHS->getType()) {\n            // Although we are giving up for now, see if we can create extracts\n            // that match the inserts for another round of combining.\n            replaceExtractElements(IEI, EI, IC);\n\n            // We tried our best, but we can't find anything compatible with RHS\n            // further up the chain. Return a trivial shuffle.\n            for (unsigned i = 0; i < NumElts; ++i)\n              Mask[i] = i;\n            return std::make_pair(V, nullptr);\n          }\n\n          unsigned NumLHSElts =\n              cast<FixedVectorType>(RHS->getType())->getNumElements();\n          Mask[InsertedIdx % NumElts] = NumLHSElts + ExtractedIdx;\n          return std::make_pair(LR.first, RHS);\n        }\n\n        if (VecOp == PermittedRHS) {\n          // We've gone as far as we can: anything on the other side of the\n          // extractelement will already have been converted into a shuffle.\n          unsigned NumLHSElts =\n              cast<FixedVectorType>(EI->getOperand(0)->getType())\n                  ->getNumElements();\n          for (unsigned i = 0; i != NumElts; ++i)\n            Mask.push_back(i == InsertedIdx ? ExtractedIdx : NumLHSElts + i);\n          return std::make_pair(EI->getOperand(0), PermittedRHS);\n        }\n\n        // If this insertelement is a chain that comes from exactly these two\n        // vectors, return the vector and the effective shuffle.\n        if (EI->getOperand(0)->getType() == PermittedRHS->getType() &&\n            collectSingleShuffleElements(IEI, EI->getOperand(0), PermittedRHS,\n                                         Mask))\n          return std::make_pair(EI->getOperand(0), PermittedRHS);\n      }\n    }\n  }\n\n  // Otherwise, we can't do anything fancy. Return an identity vector.\n  for (unsigned i = 0; i != NumElts; ++i)\n    Mask.push_back(i);\n  return std::make_pair(V, nullptr);\n}\n\n/// Look for chain of insertvalue's that fully define an aggregate, and trace\n/// back the values inserted, see if they are all were extractvalue'd from\n/// the same source aggregate from the exact same element indexes.\n/// If they were, just reuse the source aggregate.\n/// This potentially deals with PHI indirections.\nInstruction *InstCombinerImpl::foldAggregateConstructionIntoAggregateReuse(\n    InsertValueInst &OrigIVI) {\n  Type *AggTy = OrigIVI.getType();\n  unsigned NumAggElts;\n  switch (AggTy->getTypeID()) {\n  case Type::StructTyID:\n    NumAggElts = AggTy->getStructNumElements();\n    break;\n  case Type::ArrayTyID:\n    NumAggElts = AggTy->getArrayNumElements();\n    break;\n  default:\n    llvm_unreachable(\"Unhandled aggregate type?\");\n  }\n\n  // Arbitrary aggregate size cut-off. Motivation for limit of 2 is to be able\n  // to handle clang C++ exception struct (which is hardcoded as {i8*, i32}),\n  // FIXME: any interesting patterns to be caught with larger limit?\n  assert(NumAggElts > 0 && \"Aggregate should have elements.\");\n  if (NumAggElts > 2)\n    return nullptr;\n\n  static constexpr auto NotFound = None;\n  static constexpr auto FoundMismatch = nullptr;\n\n  // Try to find a value of each element of an aggregate.\n  // FIXME: deal with more complex, not one-dimensional, aggregate types\n  SmallVector<Optional<Value *>, 2> AggElts(NumAggElts, NotFound);\n\n  // Do we know values for each element of the aggregate?\n  auto KnowAllElts = [&AggElts]() {\n    return all_of(AggElts,\n                  [](Optional<Value *> Elt) { return Elt != NotFound; });\n  };\n\n  int Depth = 0;\n\n  // Arbitrary `insertvalue` visitation depth limit. Let's be okay with\n  // every element being overwritten twice, which should never happen.\n  static const int DepthLimit = 2 * NumAggElts;\n\n  // Recurse up the chain of `insertvalue` aggregate operands until either we've\n  // reconstructed full initializer or can't visit any more `insertvalue`'s.\n  for (InsertValueInst *CurrIVI = &OrigIVI;\n       Depth < DepthLimit && CurrIVI && !KnowAllElts();\n       CurrIVI = dyn_cast<InsertValueInst>(CurrIVI->getAggregateOperand()),\n                       ++Depth) {\n    Value *InsertedValue = CurrIVI->getInsertedValueOperand();\n    ArrayRef<unsigned int> Indices = CurrIVI->getIndices();\n\n    // Don't bother with more than single-level aggregates.\n    if (Indices.size() != 1)\n      return nullptr; // FIXME: deal with more complex aggregates?\n\n    // Now, we may have already previously recorded the value for this element\n    // of an aggregate. If we did, that means the CurrIVI will later be\n    // overwritten with the already-recorded value. But if not, let's record it!\n    Optional<Value *> &Elt = AggElts[Indices.front()];\n    Elt = Elt.getValueOr(InsertedValue);\n\n    // FIXME: should we handle chain-terminating undef base operand?\n  }\n\n  // Was that sufficient to deduce the full initializer for the aggregate?\n  if (!KnowAllElts())\n    return nullptr; // Give up then.\n\n  // We now want to find the source[s] of the aggregate elements we've found.\n  // And with \"source\" we mean the original aggregate[s] from which\n  // the inserted elements were extracted. This may require PHI translation.\n\n  enum class AggregateDescription {\n    /// When analyzing the value that was inserted into an aggregate, we did\n    /// not manage to find defining `extractvalue` instruction to analyze.\n    NotFound,\n    /// When analyzing the value that was inserted into an aggregate, we did\n    /// manage to find defining `extractvalue` instruction[s], and everything\n    /// matched perfectly - aggregate type, element insertion/extraction index.\n    Found,\n    /// When analyzing the value that was inserted into an aggregate, we did\n    /// manage to find defining `extractvalue` instruction, but there was\n    /// a mismatch: either the source type from which the extraction was didn't\n    /// match the aggregate type into which the insertion was,\n    /// or the extraction/insertion channels mismatched,\n    /// or different elements had different source aggregates.\n    FoundMismatch\n  };\n  auto Describe = [](Optional<Value *> SourceAggregate) {\n    if (SourceAggregate == NotFound)\n      return AggregateDescription::NotFound;\n    if (*SourceAggregate == FoundMismatch)\n      return AggregateDescription::FoundMismatch;\n    return AggregateDescription::Found;\n  };\n\n  // Given the value \\p Elt that was being inserted into element \\p EltIdx of an\n  // aggregate AggTy, see if \\p Elt was originally defined by an\n  // appropriate extractvalue (same element index, same aggregate type).\n  // If found, return the source aggregate from which the extraction was.\n  // If \\p PredBB is provided, does PHI translation of an \\p Elt first.\n  auto FindSourceAggregate =\n      [&](Value *Elt, unsigned EltIdx, Optional<BasicBlock *> UseBB,\n          Optional<BasicBlock *> PredBB) -> Optional<Value *> {\n    // For now(?), only deal with, at most, a single level of PHI indirection.\n    if (UseBB && PredBB)\n      Elt = Elt->DoPHITranslation(*UseBB, *PredBB);\n    // FIXME: deal with multiple levels of PHI indirection?\n\n    // Did we find an extraction?\n    auto *EVI = dyn_cast<ExtractValueInst>(Elt);\n    if (!EVI)\n      return NotFound;\n\n    Value *SourceAggregate = EVI->getAggregateOperand();\n\n    // Is the extraction from the same type into which the insertion was?\n    if (SourceAggregate->getType() != AggTy)\n      return FoundMismatch;\n    // And the element index doesn't change between extraction and insertion?\n    if (EVI->getNumIndices() != 1 || EltIdx != EVI->getIndices().front())\n      return FoundMismatch;\n\n    return SourceAggregate; // AggregateDescription::Found\n  };\n\n  // Given elements AggElts that were constructing an aggregate OrigIVI,\n  // see if we can find appropriate source aggregate for each of the elements,\n  // and see it's the same aggregate for each element. If so, return it.\n  auto FindCommonSourceAggregate =\n      [&](Optional<BasicBlock *> UseBB,\n          Optional<BasicBlock *> PredBB) -> Optional<Value *> {\n    Optional<Value *> SourceAggregate;\n\n    for (auto I : enumerate(AggElts)) {\n      assert(Describe(SourceAggregate) != AggregateDescription::FoundMismatch &&\n             \"We don't store nullptr in SourceAggregate!\");\n      assert((Describe(SourceAggregate) == AggregateDescription::Found) ==\n                 (I.index() != 0) &&\n             \"SourceAggregate should be valid after the the first element,\");\n\n      // For this element, is there a plausible source aggregate?\n      // FIXME: we could special-case undef element, IFF we know that in the\n      //        source aggregate said element isn't poison.\n      Optional<Value *> SourceAggregateForElement =\n          FindSourceAggregate(*I.value(), I.index(), UseBB, PredBB);\n\n      // Okay, what have we found? Does that correlate with previous findings?\n\n      // Regardless of whether or not we have previously found source\n      // aggregate for previous elements (if any), if we didn't find one for\n      // this element, passthrough whatever we have just found.\n      if (Describe(SourceAggregateForElement) != AggregateDescription::Found)\n        return SourceAggregateForElement;\n\n      // Okay, we have found source aggregate for this element.\n      // Let's see what we already know from previous elements, if any.\n      switch (Describe(SourceAggregate)) {\n      case AggregateDescription::NotFound:\n        // This is apparently the first element that we have examined.\n        SourceAggregate = SourceAggregateForElement; // Record the aggregate!\n        continue; // Great, now look at next element.\n      case AggregateDescription::Found:\n        // We have previously already successfully examined other elements.\n        // Is this the same source aggregate we've found for other elements?\n        if (*SourceAggregateForElement != *SourceAggregate)\n          return FoundMismatch;\n        continue; // Still the same aggregate, look at next element.\n      case AggregateDescription::FoundMismatch:\n        llvm_unreachable(\"Can't happen. We would have early-exited then.\");\n      };\n    }\n\n    assert(Describe(SourceAggregate) == AggregateDescription::Found &&\n           \"Must be a valid Value\");\n    return *SourceAggregate;\n  };\n\n  Optional<Value *> SourceAggregate;\n\n  // Can we find the source aggregate without looking at predecessors?\n  SourceAggregate = FindCommonSourceAggregate(/*UseBB=*/None, /*PredBB=*/None);\n  if (Describe(SourceAggregate) != AggregateDescription::NotFound) {\n    if (Describe(SourceAggregate) == AggregateDescription::FoundMismatch)\n      return nullptr; // Conflicting source aggregates!\n    ++NumAggregateReconstructionsSimplified;\n    return replaceInstUsesWith(OrigIVI, *SourceAggregate);\n  }\n\n  // Okay, apparently we need to look at predecessors.\n\n  // We should be smart about picking the \"use\" basic block, which will be the\n  // merge point for aggregate, where we'll insert the final PHI that will be\n  // used instead of OrigIVI. Basic block of OrigIVI is *not* the right choice.\n  // We should look in which blocks each of the AggElts is being defined,\n  // they all should be defined in the same basic block.\n  BasicBlock *UseBB = nullptr;\n\n  for (const Optional<Value *> &Elt : AggElts) {\n    // If this element's value was not defined by an instruction, ignore it.\n    auto *I = dyn_cast<Instruction>(*Elt);\n    if (!I)\n      continue;\n    // Otherwise, in which basic block is this instruction located?\n    BasicBlock *BB = I->getParent();\n    // If it's the first instruction we've encountered, record the basic block.\n    if (!UseBB) {\n      UseBB = BB;\n      continue;\n    }\n    // Otherwise, this must be the same basic block we've seen previously.\n    if (UseBB != BB)\n      return nullptr;\n  }\n\n  // If *all* of the elements are basic-block-independent, meaning they are\n  // either function arguments, or constant expressions, then if we didn't\n  // handle them without predecessor-aware handling, we won't handle them now.\n  if (!UseBB)\n    return nullptr;\n\n  // If we didn't manage to find source aggregate without looking at\n  // predecessors, and there are no predecessors to look at, then we're done.\n  if (pred_empty(UseBB))\n    return nullptr;\n\n  // Arbitrary predecessor count limit.\n  static const int PredCountLimit = 64;\n\n  // Cache the (non-uniqified!) list of predecessors in a vector,\n  // checking the limit at the same time for efficiency.\n  SmallVector<BasicBlock *, 4> Preds; // May have duplicates!\n  for (BasicBlock *Pred : predecessors(UseBB)) {\n    // Don't bother if there are too many predecessors.\n    if (Preds.size() >= PredCountLimit) // FIXME: only count duplicates once?\n      return nullptr;\n    Preds.emplace_back(Pred);\n  }\n\n  // For each predecessor, what is the source aggregate,\n  // from which all the elements were originally extracted from?\n  // Note that we want for the map to have stable iteration order!\n  SmallDenseMap<BasicBlock *, Value *, 4> SourceAggregates;\n  for (BasicBlock *Pred : Preds) {\n    std::pair<decltype(SourceAggregates)::iterator, bool> IV =\n        SourceAggregates.insert({Pred, nullptr});\n    // Did we already evaluate this predecessor?\n    if (!IV.second)\n      continue;\n\n    // Let's hope that when coming from predecessor Pred, all elements of the\n    // aggregate produced by OrigIVI must have been originally extracted from\n    // the same aggregate. Is that so? Can we find said original aggregate?\n    SourceAggregate = FindCommonSourceAggregate(UseBB, Pred);\n    if (Describe(SourceAggregate) != AggregateDescription::Found)\n      return nullptr; // Give up.\n    IV.first->second = *SourceAggregate;\n  }\n\n  // All good! Now we just need to thread the source aggregates here.\n  // Note that we have to insert the new PHI here, ourselves, because we can't\n  // rely on InstCombinerImpl::run() inserting it into the right basic block.\n  // Note that the same block can be a predecessor more than once,\n  // and we need to preserve that invariant for the PHI node.\n  BuilderTy::InsertPointGuard Guard(Builder);\n  Builder.SetInsertPoint(UseBB->getFirstNonPHI());\n  auto *PHI =\n      Builder.CreatePHI(AggTy, Preds.size(), OrigIVI.getName() + \".merged\");\n  for (BasicBlock *Pred : Preds)\n    PHI->addIncoming(SourceAggregates[Pred], Pred);\n\n  ++NumAggregateReconstructionsSimplified;\n  return replaceInstUsesWith(OrigIVI, PHI);\n}\n\n/// Try to find redundant insertvalue instructions, like the following ones:\n///  %0 = insertvalue { i8, i32 } undef, i8 %x, 0\n///  %1 = insertvalue { i8, i32 } %0,    i8 %y, 0\n/// Here the second instruction inserts values at the same indices, as the\n/// first one, making the first one redundant.\n/// It should be transformed to:\n///  %0 = insertvalue { i8, i32 } undef, i8 %y, 0\nInstruction *InstCombinerImpl::visitInsertValueInst(InsertValueInst &I) {\n  bool IsRedundant = false;\n  ArrayRef<unsigned int> FirstIndices = I.getIndices();\n\n  // If there is a chain of insertvalue instructions (each of them except the\n  // last one has only one use and it's another insertvalue insn from this\n  // chain), check if any of the 'children' uses the same indices as the first\n  // instruction. In this case, the first one is redundant.\n  Value *V = &I;\n  unsigned Depth = 0;\n  while (V->hasOneUse() && Depth < 10) {\n    User *U = V->user_back();\n    auto UserInsInst = dyn_cast<InsertValueInst>(U);\n    if (!UserInsInst || U->getOperand(0) != V)\n      break;\n    if (UserInsInst->getIndices() == FirstIndices) {\n      IsRedundant = true;\n      break;\n    }\n    V = UserInsInst;\n    Depth++;\n  }\n\n  if (IsRedundant)\n    return replaceInstUsesWith(I, I.getOperand(0));\n\n  if (Instruction *NewI = foldAggregateConstructionIntoAggregateReuse(I))\n    return NewI;\n\n  return nullptr;\n}\n\nstatic bool isShuffleEquivalentToSelect(ShuffleVectorInst &Shuf) {\n  // Can not analyze scalable type, the number of elements is not a compile-time\n  // constant.\n  if (isa<ScalableVectorType>(Shuf.getOperand(0)->getType()))\n    return false;\n\n  int MaskSize = Shuf.getShuffleMask().size();\n  int VecSize =\n      cast<FixedVectorType>(Shuf.getOperand(0)->getType())->getNumElements();\n\n  // A vector select does not change the size of the operands.\n  if (MaskSize != VecSize)\n    return false;\n\n  // Each mask element must be undefined or choose a vector element from one of\n  // the source operands without crossing vector lanes.\n  for (int i = 0; i != MaskSize; ++i) {\n    int Elt = Shuf.getMaskValue(i);\n    if (Elt != -1 && Elt != i && Elt != i + VecSize)\n      return false;\n  }\n\n  return true;\n}\n\n/// Turn a chain of inserts that splats a value into an insert + shuffle:\n/// insertelt(insertelt(insertelt(insertelt X, %k, 0), %k, 1), %k, 2) ... ->\n/// shufflevector(insertelt(X, %k, 0), undef, zero)\nstatic Instruction *foldInsSequenceIntoSplat(InsertElementInst &InsElt) {\n  // We are interested in the last insert in a chain. So if this insert has a\n  // single user and that user is an insert, bail.\n  if (InsElt.hasOneUse() && isa<InsertElementInst>(InsElt.user_back()))\n    return nullptr;\n\n  VectorType *VecTy = InsElt.getType();\n  // Can not handle scalable type, the number of elements is not a compile-time\n  // constant.\n  if (isa<ScalableVectorType>(VecTy))\n    return nullptr;\n  unsigned NumElements = cast<FixedVectorType>(VecTy)->getNumElements();\n\n  // Do not try to do this for a one-element vector, since that's a nop,\n  // and will cause an inf-loop.\n  if (NumElements == 1)\n    return nullptr;\n\n  Value *SplatVal = InsElt.getOperand(1);\n  InsertElementInst *CurrIE = &InsElt;\n  SmallBitVector ElementPresent(NumElements, false);\n  InsertElementInst *FirstIE = nullptr;\n\n  // Walk the chain backwards, keeping track of which indices we inserted into,\n  // until we hit something that isn't an insert of the splatted value.\n  while (CurrIE) {\n    auto *Idx = dyn_cast<ConstantInt>(CurrIE->getOperand(2));\n    if (!Idx || CurrIE->getOperand(1) != SplatVal)\n      return nullptr;\n\n    auto *NextIE = dyn_cast<InsertElementInst>(CurrIE->getOperand(0));\n    // Check none of the intermediate steps have any additional uses, except\n    // for the root insertelement instruction, which can be re-used, if it\n    // inserts at position 0.\n    if (CurrIE != &InsElt &&\n        (!CurrIE->hasOneUse() && (NextIE != nullptr || !Idx->isZero())))\n      return nullptr;\n\n    ElementPresent[Idx->getZExtValue()] = true;\n    FirstIE = CurrIE;\n    CurrIE = NextIE;\n  }\n\n  // If this is just a single insertelement (not a sequence), we are done.\n  if (FirstIE == &InsElt)\n    return nullptr;\n\n  // If we are not inserting into an undef vector, make sure we've seen an\n  // insert into every element.\n  // TODO: If the base vector is not undef, it might be better to create a splat\n  //       and then a select-shuffle (blend) with the base vector.\n  if (!isa<UndefValue>(FirstIE->getOperand(0)))\n    if (!ElementPresent.all())\n      return nullptr;\n\n  // Create the insert + shuffle.\n  Type *Int32Ty = Type::getInt32Ty(InsElt.getContext());\n  UndefValue *UndefVec = UndefValue::get(VecTy);\n  Constant *Zero = ConstantInt::get(Int32Ty, 0);\n  if (!cast<ConstantInt>(FirstIE->getOperand(2))->isZero())\n    FirstIE = InsertElementInst::Create(UndefVec, SplatVal, Zero, \"\", &InsElt);\n\n  // Splat from element 0, but replace absent elements with undef in the mask.\n  SmallVector<int, 16> Mask(NumElements, 0);\n  for (unsigned i = 0; i != NumElements; ++i)\n    if (!ElementPresent[i])\n      Mask[i] = -1;\n\n  return new ShuffleVectorInst(FirstIE, UndefVec, Mask);\n}\n\n/// Try to fold an insert element into an existing splat shuffle by changing\n/// the shuffle's mask to include the index of this insert element.\nstatic Instruction *foldInsEltIntoSplat(InsertElementInst &InsElt) {\n  // Check if the vector operand of this insert is a canonical splat shuffle.\n  auto *Shuf = dyn_cast<ShuffleVectorInst>(InsElt.getOperand(0));\n  if (!Shuf || !Shuf->isZeroEltSplat())\n    return nullptr;\n\n  // Bail out early if shuffle is scalable type. The number of elements in\n  // shuffle mask is unknown at compile-time.\n  if (isa<ScalableVectorType>(Shuf->getType()))\n    return nullptr;\n\n  // Check for a constant insertion index.\n  uint64_t IdxC;\n  if (!match(InsElt.getOperand(2), m_ConstantInt(IdxC)))\n    return nullptr;\n\n  // Check if the splat shuffle's input is the same as this insert's scalar op.\n  Value *X = InsElt.getOperand(1);\n  Value *Op0 = Shuf->getOperand(0);\n  if (!match(Op0, m_InsertElt(m_Undef(), m_Specific(X), m_ZeroInt())))\n    return nullptr;\n\n  // Replace the shuffle mask element at the index of this insert with a zero.\n  // For example:\n  // inselt (shuf (inselt undef, X, 0), undef, <0,undef,0,undef>), X, 1\n  //   --> shuf (inselt undef, X, 0), undef, <0,0,0,undef>\n  unsigned NumMaskElts =\n      cast<FixedVectorType>(Shuf->getType())->getNumElements();\n  SmallVector<int, 16> NewMask(NumMaskElts);\n  for (unsigned i = 0; i != NumMaskElts; ++i)\n    NewMask[i] = i == IdxC ? 0 : Shuf->getMaskValue(i);\n\n  return new ShuffleVectorInst(Op0, UndefValue::get(Op0->getType()), NewMask);\n}\n\n/// Try to fold an extract+insert element into an existing identity shuffle by\n/// changing the shuffle's mask to include the index of this insert element.\nstatic Instruction *foldInsEltIntoIdentityShuffle(InsertElementInst &InsElt) {\n  // Check if the vector operand of this insert is an identity shuffle.\n  auto *Shuf = dyn_cast<ShuffleVectorInst>(InsElt.getOperand(0));\n  if (!Shuf || !isa<UndefValue>(Shuf->getOperand(1)) ||\n      !(Shuf->isIdentityWithExtract() || Shuf->isIdentityWithPadding()))\n    return nullptr;\n\n  // Bail out early if shuffle is scalable type. The number of elements in\n  // shuffle mask is unknown at compile-time.\n  if (isa<ScalableVectorType>(Shuf->getType()))\n    return nullptr;\n\n  // Check for a constant insertion index.\n  uint64_t IdxC;\n  if (!match(InsElt.getOperand(2), m_ConstantInt(IdxC)))\n    return nullptr;\n\n  // Check if this insert's scalar op is extracted from the identity shuffle's\n  // input vector.\n  Value *Scalar = InsElt.getOperand(1);\n  Value *X = Shuf->getOperand(0);\n  if (!match(Scalar, m_ExtractElt(m_Specific(X), m_SpecificInt(IdxC))))\n    return nullptr;\n\n  // Replace the shuffle mask element at the index of this extract+insert with\n  // that same index value.\n  // For example:\n  // inselt (shuf X, IdMask), (extelt X, IdxC), IdxC --> shuf X, IdMask'\n  unsigned NumMaskElts =\n      cast<FixedVectorType>(Shuf->getType())->getNumElements();\n  SmallVector<int, 16> NewMask(NumMaskElts);\n  ArrayRef<int> OldMask = Shuf->getShuffleMask();\n  for (unsigned i = 0; i != NumMaskElts; ++i) {\n    if (i != IdxC) {\n      // All mask elements besides the inserted element remain the same.\n      NewMask[i] = OldMask[i];\n    } else if (OldMask[i] == (int)IdxC) {\n      // If the mask element was already set, there's nothing to do\n      // (demanded elements analysis may unset it later).\n      return nullptr;\n    } else {\n      assert(OldMask[i] == UndefMaskElem &&\n             \"Unexpected shuffle mask element for identity shuffle\");\n      NewMask[i] = IdxC;\n    }\n  }\n\n  return new ShuffleVectorInst(X, Shuf->getOperand(1), NewMask);\n}\n\n/// If we have an insertelement instruction feeding into another insertelement\n/// and the 2nd is inserting a constant into the vector, canonicalize that\n/// constant insertion before the insertion of a variable:\n///\n/// insertelement (insertelement X, Y, IdxC1), ScalarC, IdxC2 -->\n/// insertelement (insertelement X, ScalarC, IdxC2), Y, IdxC1\n///\n/// This has the potential of eliminating the 2nd insertelement instruction\n/// via constant folding of the scalar constant into a vector constant.\nstatic Instruction *hoistInsEltConst(InsertElementInst &InsElt2,\n                                     InstCombiner::BuilderTy &Builder) {\n  auto *InsElt1 = dyn_cast<InsertElementInst>(InsElt2.getOperand(0));\n  if (!InsElt1 || !InsElt1->hasOneUse())\n    return nullptr;\n\n  Value *X, *Y;\n  Constant *ScalarC;\n  ConstantInt *IdxC1, *IdxC2;\n  if (match(InsElt1->getOperand(0), m_Value(X)) &&\n      match(InsElt1->getOperand(1), m_Value(Y)) && !isa<Constant>(Y) &&\n      match(InsElt1->getOperand(2), m_ConstantInt(IdxC1)) &&\n      match(InsElt2.getOperand(1), m_Constant(ScalarC)) &&\n      match(InsElt2.getOperand(2), m_ConstantInt(IdxC2)) && IdxC1 != IdxC2) {\n    Value *NewInsElt1 = Builder.CreateInsertElement(X, ScalarC, IdxC2);\n    return InsertElementInst::Create(NewInsElt1, Y, IdxC1);\n  }\n\n  return nullptr;\n}\n\n/// insertelt (shufflevector X, CVec, Mask|insertelt X, C1, CIndex1), C, CIndex\n/// --> shufflevector X, CVec', Mask'\nstatic Instruction *foldConstantInsEltIntoShuffle(InsertElementInst &InsElt) {\n  auto *Inst = dyn_cast<Instruction>(InsElt.getOperand(0));\n  // Bail out if the parent has more than one use. In that case, we'd be\n  // replacing the insertelt with a shuffle, and that's not a clear win.\n  if (!Inst || !Inst->hasOneUse())\n    return nullptr;\n  if (auto *Shuf = dyn_cast<ShuffleVectorInst>(InsElt.getOperand(0))) {\n    // The shuffle must have a constant vector operand. The insertelt must have\n    // a constant scalar being inserted at a constant position in the vector.\n    Constant *ShufConstVec, *InsEltScalar;\n    uint64_t InsEltIndex;\n    if (!match(Shuf->getOperand(1), m_Constant(ShufConstVec)) ||\n        !match(InsElt.getOperand(1), m_Constant(InsEltScalar)) ||\n        !match(InsElt.getOperand(2), m_ConstantInt(InsEltIndex)))\n      return nullptr;\n\n    // Adding an element to an arbitrary shuffle could be expensive, but a\n    // shuffle that selects elements from vectors without crossing lanes is\n    // assumed cheap.\n    // If we're just adding a constant into that shuffle, it will still be\n    // cheap.\n    if (!isShuffleEquivalentToSelect(*Shuf))\n      return nullptr;\n\n    // From the above 'select' check, we know that the mask has the same number\n    // of elements as the vector input operands. We also know that each constant\n    // input element is used in its lane and can not be used more than once by\n    // the shuffle. Therefore, replace the constant in the shuffle's constant\n    // vector with the insertelt constant. Replace the constant in the shuffle's\n    // mask vector with the insertelt index plus the length of the vector\n    // (because the constant vector operand of a shuffle is always the 2nd\n    // operand).\n    ArrayRef<int> Mask = Shuf->getShuffleMask();\n    unsigned NumElts = Mask.size();\n    SmallVector<Constant *, 16> NewShufElts(NumElts);\n    SmallVector<int, 16> NewMaskElts(NumElts);\n    for (unsigned I = 0; I != NumElts; ++I) {\n      if (I == InsEltIndex) {\n        NewShufElts[I] = InsEltScalar;\n        NewMaskElts[I] = InsEltIndex + NumElts;\n      } else {\n        // Copy over the existing values.\n        NewShufElts[I] = ShufConstVec->getAggregateElement(I);\n        NewMaskElts[I] = Mask[I];\n      }\n    }\n\n    // Create new operands for a shuffle that includes the constant of the\n    // original insertelt. The old shuffle will be dead now.\n    return new ShuffleVectorInst(Shuf->getOperand(0),\n                                 ConstantVector::get(NewShufElts), NewMaskElts);\n  } else if (auto *IEI = dyn_cast<InsertElementInst>(Inst)) {\n    // Transform sequences of insertelements ops with constant data/indexes into\n    // a single shuffle op.\n    // Can not handle scalable type, the number of elements needed to create\n    // shuffle mask is not a compile-time constant.\n    if (isa<ScalableVectorType>(InsElt.getType()))\n      return nullptr;\n    unsigned NumElts =\n        cast<FixedVectorType>(InsElt.getType())->getNumElements();\n\n    uint64_t InsertIdx[2];\n    Constant *Val[2];\n    if (!match(InsElt.getOperand(2), m_ConstantInt(InsertIdx[0])) ||\n        !match(InsElt.getOperand(1), m_Constant(Val[0])) ||\n        !match(IEI->getOperand(2), m_ConstantInt(InsertIdx[1])) ||\n        !match(IEI->getOperand(1), m_Constant(Val[1])))\n      return nullptr;\n    SmallVector<Constant *, 16> Values(NumElts);\n    SmallVector<int, 16> Mask(NumElts);\n    auto ValI = std::begin(Val);\n    // Generate new constant vector and mask.\n    // We have 2 values/masks from the insertelements instructions. Insert them\n    // into new value/mask vectors.\n    for (uint64_t I : InsertIdx) {\n      if (!Values[I]) {\n        Values[I] = *ValI;\n        Mask[I] = NumElts + I;\n      }\n      ++ValI;\n    }\n    // Remaining values are filled with 'undef' values.\n    for (unsigned I = 0; I < NumElts; ++I) {\n      if (!Values[I]) {\n        Values[I] = UndefValue::get(InsElt.getType()->getElementType());\n        Mask[I] = I;\n      }\n    }\n    // Create new operands for a shuffle that includes the constant of the\n    // original insertelt.\n    return new ShuffleVectorInst(IEI->getOperand(0),\n                                 ConstantVector::get(Values), Mask);\n  }\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitInsertElementInst(InsertElementInst &IE) {\n  Value *VecOp    = IE.getOperand(0);\n  Value *ScalarOp = IE.getOperand(1);\n  Value *IdxOp    = IE.getOperand(2);\n\n  if (auto *V = SimplifyInsertElementInst(\n          VecOp, ScalarOp, IdxOp, SQ.getWithInstruction(&IE)))\n    return replaceInstUsesWith(IE, V);\n\n  // If the scalar is bitcast and inserted into undef, do the insert in the\n  // source type followed by bitcast.\n  // TODO: Generalize for insert into any constant, not just undef?\n  Value *ScalarSrc;\n  if (match(VecOp, m_Undef()) &&\n      match(ScalarOp, m_OneUse(m_BitCast(m_Value(ScalarSrc)))) &&\n      (ScalarSrc->getType()->isIntegerTy() ||\n       ScalarSrc->getType()->isFloatingPointTy())) {\n    // inselt undef, (bitcast ScalarSrc), IdxOp -->\n    //   bitcast (inselt undef, ScalarSrc, IdxOp)\n    Type *ScalarTy = ScalarSrc->getType();\n    Type *VecTy = VectorType::get(ScalarTy, IE.getType()->getElementCount());\n    UndefValue *NewUndef = UndefValue::get(VecTy);\n    Value *NewInsElt = Builder.CreateInsertElement(NewUndef, ScalarSrc, IdxOp);\n    return new BitCastInst(NewInsElt, IE.getType());\n  }\n\n  // If the vector and scalar are both bitcast from the same element type, do\n  // the insert in that source type followed by bitcast.\n  Value *VecSrc;\n  if (match(VecOp, m_BitCast(m_Value(VecSrc))) &&\n      match(ScalarOp, m_BitCast(m_Value(ScalarSrc))) &&\n      (VecOp->hasOneUse() || ScalarOp->hasOneUse()) &&\n      VecSrc->getType()->isVectorTy() && !ScalarSrc->getType()->isVectorTy() &&\n      cast<VectorType>(VecSrc->getType())->getElementType() ==\n          ScalarSrc->getType()) {\n    // inselt (bitcast VecSrc), (bitcast ScalarSrc), IdxOp -->\n    //   bitcast (inselt VecSrc, ScalarSrc, IdxOp)\n    Value *NewInsElt = Builder.CreateInsertElement(VecSrc, ScalarSrc, IdxOp);\n    return new BitCastInst(NewInsElt, IE.getType());\n  }\n\n  // If the inserted element was extracted from some other fixed-length vector\n  // and both indexes are valid constants, try to turn this into a shuffle.\n  // Can not handle scalable vector type, the number of elements needed to\n  // create shuffle mask is not a compile-time constant.\n  uint64_t InsertedIdx, ExtractedIdx;\n  Value *ExtVecOp;\n  if (isa<FixedVectorType>(IE.getType()) &&\n      match(IdxOp, m_ConstantInt(InsertedIdx)) &&\n      match(ScalarOp,\n            m_ExtractElt(m_Value(ExtVecOp), m_ConstantInt(ExtractedIdx))) &&\n      isa<FixedVectorType>(ExtVecOp->getType()) &&\n      ExtractedIdx <\n          cast<FixedVectorType>(ExtVecOp->getType())->getNumElements()) {\n    // TODO: Looking at the user(s) to determine if this insert is a\n    // fold-to-shuffle opportunity does not match the usual instcombine\n    // constraints. We should decide if the transform is worthy based only\n    // on this instruction and its operands, but that may not work currently.\n    //\n    // Here, we are trying to avoid creating shuffles before reaching\n    // the end of a chain of extract-insert pairs. This is complicated because\n    // we do not generally form arbitrary shuffle masks in instcombine\n    // (because those may codegen poorly), but collectShuffleElements() does\n    // exactly that.\n    //\n    // The rules for determining what is an acceptable target-independent\n    // shuffle mask are fuzzy because they evolve based on the backend's\n    // capabilities and real-world impact.\n    auto isShuffleRootCandidate = [](InsertElementInst &Insert) {\n      if (!Insert.hasOneUse())\n        return true;\n      auto *InsertUser = dyn_cast<InsertElementInst>(Insert.user_back());\n      if (!InsertUser)\n        return true;\n      return false;\n    };\n\n    // Try to form a shuffle from a chain of extract-insert ops.\n    if (isShuffleRootCandidate(IE)) {\n      SmallVector<int, 16> Mask;\n      ShuffleOps LR = collectShuffleElements(&IE, Mask, nullptr, *this);\n\n      // The proposed shuffle may be trivial, in which case we shouldn't\n      // perform the combine.\n      if (LR.first != &IE && LR.second != &IE) {\n        // We now have a shuffle of LHS, RHS, Mask.\n        if (LR.second == nullptr)\n          LR.second = UndefValue::get(LR.first->getType());\n        return new ShuffleVectorInst(LR.first, LR.second, Mask);\n      }\n    }\n  }\n\n  if (auto VecTy = dyn_cast<FixedVectorType>(VecOp->getType())) {\n    unsigned VWidth = VecTy->getNumElements();\n    APInt UndefElts(VWidth, 0);\n    APInt AllOnesEltMask(APInt::getAllOnesValue(VWidth));\n    if (Value *V = SimplifyDemandedVectorElts(&IE, AllOnesEltMask, UndefElts)) {\n      if (V != &IE)\n        return replaceInstUsesWith(IE, V);\n      return &IE;\n    }\n  }\n\n  if (Instruction *Shuf = foldConstantInsEltIntoShuffle(IE))\n    return Shuf;\n\n  if (Instruction *NewInsElt = hoistInsEltConst(IE, Builder))\n    return NewInsElt;\n\n  if (Instruction *Broadcast = foldInsSequenceIntoSplat(IE))\n    return Broadcast;\n\n  if (Instruction *Splat = foldInsEltIntoSplat(IE))\n    return Splat;\n\n  if (Instruction *IdentityShuf = foldInsEltIntoIdentityShuffle(IE))\n    return IdentityShuf;\n\n  return nullptr;\n}\n\n/// Return true if we can evaluate the specified expression tree if the vector\n/// elements were shuffled in a different order.\nstatic bool canEvaluateShuffled(Value *V, ArrayRef<int> Mask,\n                                unsigned Depth = 5) {\n  // We can always reorder the elements of a constant.\n  if (isa<Constant>(V))\n    return true;\n\n  // We won't reorder vector arguments. No IPO here.\n  Instruction *I = dyn_cast<Instruction>(V);\n  if (!I) return false;\n\n  // Two users may expect different orders of the elements. Don't try it.\n  if (!I->hasOneUse())\n    return false;\n\n  if (Depth == 0) return false;\n\n  switch (I->getOpcode()) {\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n      // Propagating an undefined shuffle mask element to integer div/rem is not\n      // allowed because those opcodes can create immediate undefined behavior\n      // from an undefined element in an operand.\n      if (llvm::is_contained(Mask, -1))\n        return false;\n      LLVM_FALLTHROUGH;\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::FDiv:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor:\n    case Instruction::ICmp:\n    case Instruction::FCmp:\n    case Instruction::Trunc:\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::UIToFP:\n    case Instruction::SIToFP:\n    case Instruction::FPTrunc:\n    case Instruction::FPExt:\n    case Instruction::GetElementPtr: {\n      // Bail out if we would create longer vector ops. We could allow creating\n      // longer vector ops, but that may result in more expensive codegen.\n      Type *ITy = I->getType();\n      if (ITy->isVectorTy() &&\n          Mask.size() > cast<FixedVectorType>(ITy)->getNumElements())\n        return false;\n      for (Value *Operand : I->operands()) {\n        if (!canEvaluateShuffled(Operand, Mask, Depth - 1))\n          return false;\n      }\n      return true;\n    }\n    case Instruction::InsertElement: {\n      ConstantInt *CI = dyn_cast<ConstantInt>(I->getOperand(2));\n      if (!CI) return false;\n      int ElementNumber = CI->getLimitedValue();\n\n      // Verify that 'CI' does not occur twice in Mask. A single 'insertelement'\n      // can't put an element into multiple indices.\n      bool SeenOnce = false;\n      for (int i = 0, e = Mask.size(); i != e; ++i) {\n        if (Mask[i] == ElementNumber) {\n          if (SeenOnce)\n            return false;\n          SeenOnce = true;\n        }\n      }\n      return canEvaluateShuffled(I->getOperand(0), Mask, Depth - 1);\n    }\n  }\n  return false;\n}\n\n/// Rebuild a new instruction just like 'I' but with the new operands given.\n/// In the event of type mismatch, the type of the operands is correct.\nstatic Value *buildNew(Instruction *I, ArrayRef<Value*> NewOps) {\n  // We don't want to use the IRBuilder here because we want the replacement\n  // instructions to appear next to 'I', not the builder's insertion point.\n  switch (I->getOpcode()) {\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor: {\n      BinaryOperator *BO = cast<BinaryOperator>(I);\n      assert(NewOps.size() == 2 && \"binary operator with #ops != 2\");\n      BinaryOperator *New =\n          BinaryOperator::Create(cast<BinaryOperator>(I)->getOpcode(),\n                                 NewOps[0], NewOps[1], \"\", BO);\n      if (isa<OverflowingBinaryOperator>(BO)) {\n        New->setHasNoUnsignedWrap(BO->hasNoUnsignedWrap());\n        New->setHasNoSignedWrap(BO->hasNoSignedWrap());\n      }\n      if (isa<PossiblyExactOperator>(BO)) {\n        New->setIsExact(BO->isExact());\n      }\n      if (isa<FPMathOperator>(BO))\n        New->copyFastMathFlags(I);\n      return New;\n    }\n    case Instruction::ICmp:\n      assert(NewOps.size() == 2 && \"icmp with #ops != 2\");\n      return new ICmpInst(I, cast<ICmpInst>(I)->getPredicate(),\n                          NewOps[0], NewOps[1]);\n    case Instruction::FCmp:\n      assert(NewOps.size() == 2 && \"fcmp with #ops != 2\");\n      return new FCmpInst(I, cast<FCmpInst>(I)->getPredicate(),\n                          NewOps[0], NewOps[1]);\n    case Instruction::Trunc:\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::UIToFP:\n    case Instruction::SIToFP:\n    case Instruction::FPTrunc:\n    case Instruction::FPExt: {\n      // It's possible that the mask has a different number of elements from\n      // the original cast. We recompute the destination type to match the mask.\n      Type *DestTy = VectorType::get(\n          I->getType()->getScalarType(),\n          cast<VectorType>(NewOps[0]->getType())->getElementCount());\n      assert(NewOps.size() == 1 && \"cast with #ops != 1\");\n      return CastInst::Create(cast<CastInst>(I)->getOpcode(), NewOps[0], DestTy,\n                              \"\", I);\n    }\n    case Instruction::GetElementPtr: {\n      Value *Ptr = NewOps[0];\n      ArrayRef<Value*> Idx = NewOps.slice(1);\n      GetElementPtrInst *GEP = GetElementPtrInst::Create(\n          cast<GetElementPtrInst>(I)->getSourceElementType(), Ptr, Idx, \"\", I);\n      GEP->setIsInBounds(cast<GetElementPtrInst>(I)->isInBounds());\n      return GEP;\n    }\n  }\n  llvm_unreachable(\"failed to rebuild vector instructions\");\n}\n\nstatic Value *evaluateInDifferentElementOrder(Value *V, ArrayRef<int> Mask) {\n  // Mask.size() does not need to be equal to the number of vector elements.\n\n  assert(V->getType()->isVectorTy() && \"can't reorder non-vector elements\");\n  Type *EltTy = V->getType()->getScalarType();\n  Type *I32Ty = IntegerType::getInt32Ty(V->getContext());\n  if (isa<UndefValue>(V))\n    return UndefValue::get(FixedVectorType::get(EltTy, Mask.size()));\n\n  if (isa<ConstantAggregateZero>(V))\n    return ConstantAggregateZero::get(FixedVectorType::get(EltTy, Mask.size()));\n\n  if (Constant *C = dyn_cast<Constant>(V))\n    return ConstantExpr::getShuffleVector(C, UndefValue::get(C->getType()),\n                                          Mask);\n\n  Instruction *I = cast<Instruction>(V);\n  switch (I->getOpcode()) {\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor:\n    case Instruction::ICmp:\n    case Instruction::FCmp:\n    case Instruction::Trunc:\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::UIToFP:\n    case Instruction::SIToFP:\n    case Instruction::FPTrunc:\n    case Instruction::FPExt:\n    case Instruction::Select:\n    case Instruction::GetElementPtr: {\n      SmallVector<Value*, 8> NewOps;\n      bool NeedsRebuild =\n          (Mask.size() !=\n           cast<FixedVectorType>(I->getType())->getNumElements());\n      for (int i = 0, e = I->getNumOperands(); i != e; ++i) {\n        Value *V;\n        // Recursively call evaluateInDifferentElementOrder on vector arguments\n        // as well. E.g. GetElementPtr may have scalar operands even if the\n        // return value is a vector, so we need to examine the operand type.\n        if (I->getOperand(i)->getType()->isVectorTy())\n          V = evaluateInDifferentElementOrder(I->getOperand(i), Mask);\n        else\n          V = I->getOperand(i);\n        NewOps.push_back(V);\n        NeedsRebuild |= (V != I->getOperand(i));\n      }\n      if (NeedsRebuild) {\n        return buildNew(I, NewOps);\n      }\n      return I;\n    }\n    case Instruction::InsertElement: {\n      int Element = cast<ConstantInt>(I->getOperand(2))->getLimitedValue();\n\n      // The insertelement was inserting at Element. Figure out which element\n      // that becomes after shuffling. The answer is guaranteed to be unique\n      // by CanEvaluateShuffled.\n      bool Found = false;\n      int Index = 0;\n      for (int e = Mask.size(); Index != e; ++Index) {\n        if (Mask[Index] == Element) {\n          Found = true;\n          break;\n        }\n      }\n\n      // If element is not in Mask, no need to handle the operand 1 (element to\n      // be inserted). Just evaluate values in operand 0 according to Mask.\n      if (!Found)\n        return evaluateInDifferentElementOrder(I->getOperand(0), Mask);\n\n      Value *V = evaluateInDifferentElementOrder(I->getOperand(0), Mask);\n      return InsertElementInst::Create(V, I->getOperand(1),\n                                       ConstantInt::get(I32Ty, Index), \"\", I);\n    }\n  }\n  llvm_unreachable(\"failed to reorder elements of vector instruction!\");\n}\n\n// Returns true if the shuffle is extracting a contiguous range of values from\n// LHS, for example:\n//                 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n//   Input:        |AA|BB|CC|DD|EE|FF|GG|HH|II|JJ|KK|LL|MM|NN|OO|PP|\n//   Shuffles to:  |EE|FF|GG|HH|\n//                 +--+--+--+--+\nstatic bool isShuffleExtractingFromLHS(ShuffleVectorInst &SVI,\n                                       ArrayRef<int> Mask) {\n  unsigned LHSElems =\n      cast<FixedVectorType>(SVI.getOperand(0)->getType())->getNumElements();\n  unsigned MaskElems = Mask.size();\n  unsigned BegIdx = Mask.front();\n  unsigned EndIdx = Mask.back();\n  if (BegIdx > EndIdx || EndIdx >= LHSElems || EndIdx - BegIdx != MaskElems - 1)\n    return false;\n  for (unsigned I = 0; I != MaskElems; ++I)\n    if (static_cast<unsigned>(Mask[I]) != BegIdx + I)\n      return false;\n  return true;\n}\n\n/// These are the ingredients in an alternate form binary operator as described\n/// below.\nstruct BinopElts {\n  BinaryOperator::BinaryOps Opcode;\n  Value *Op0;\n  Value *Op1;\n  BinopElts(BinaryOperator::BinaryOps Opc = (BinaryOperator::BinaryOps)0,\n            Value *V0 = nullptr, Value *V1 = nullptr) :\n      Opcode(Opc), Op0(V0), Op1(V1) {}\n  operator bool() const { return Opcode != 0; }\n};\n\n/// Binops may be transformed into binops with different opcodes and operands.\n/// Reverse the usual canonicalization to enable folds with the non-canonical\n/// form of the binop. If a transform is possible, return the elements of the\n/// new binop. If not, return invalid elements.\nstatic BinopElts getAlternateBinop(BinaryOperator *BO, const DataLayout &DL) {\n  Value *BO0 = BO->getOperand(0), *BO1 = BO->getOperand(1);\n  Type *Ty = BO->getType();\n  switch (BO->getOpcode()) {\n    case Instruction::Shl: {\n      // shl X, C --> mul X, (1 << C)\n      Constant *C;\n      if (match(BO1, m_Constant(C))) {\n        Constant *ShlOne = ConstantExpr::getShl(ConstantInt::get(Ty, 1), C);\n        return { Instruction::Mul, BO0, ShlOne };\n      }\n      break;\n    }\n    case Instruction::Or: {\n      // or X, C --> add X, C (when X and C have no common bits set)\n      const APInt *C;\n      if (match(BO1, m_APInt(C)) && MaskedValueIsZero(BO0, *C, DL))\n        return { Instruction::Add, BO0, BO1 };\n      break;\n    }\n    default:\n      break;\n  }\n  return {};\n}\n\nstatic Instruction *foldSelectShuffleWith1Binop(ShuffleVectorInst &Shuf) {\n  assert(Shuf.isSelect() && \"Must have select-equivalent shuffle\");\n\n  // Are we shuffling together some value and that same value after it has been\n  // modified by a binop with a constant?\n  Value *Op0 = Shuf.getOperand(0), *Op1 = Shuf.getOperand(1);\n  Constant *C;\n  bool Op0IsBinop;\n  if (match(Op0, m_BinOp(m_Specific(Op1), m_Constant(C))))\n    Op0IsBinop = true;\n  else if (match(Op1, m_BinOp(m_Specific(Op0), m_Constant(C))))\n    Op0IsBinop = false;\n  else\n    return nullptr;\n\n  // The identity constant for a binop leaves a variable operand unchanged. For\n  // a vector, this is a splat of something like 0, -1, or 1.\n  // If there's no identity constant for this binop, we're done.\n  auto *BO = cast<BinaryOperator>(Op0IsBinop ? Op0 : Op1);\n  BinaryOperator::BinaryOps BOpcode = BO->getOpcode();\n  Constant *IdC = ConstantExpr::getBinOpIdentity(BOpcode, Shuf.getType(), true);\n  if (!IdC)\n    return nullptr;\n\n  // Shuffle identity constants into the lanes that return the original value.\n  // Example: shuf (mul X, {-1,-2,-3,-4}), X, {0,5,6,3} --> mul X, {-1,1,1,-4}\n  // Example: shuf X, (add X, {-1,-2,-3,-4}), {0,1,6,7} --> add X, {0,0,-3,-4}\n  // The existing binop constant vector remains in the same operand position.\n  ArrayRef<int> Mask = Shuf.getShuffleMask();\n  Constant *NewC = Op0IsBinop ? ConstantExpr::getShuffleVector(C, IdC, Mask) :\n                                ConstantExpr::getShuffleVector(IdC, C, Mask);\n\n  bool MightCreatePoisonOrUB =\n      is_contained(Mask, UndefMaskElem) &&\n      (Instruction::isIntDivRem(BOpcode) || Instruction::isShift(BOpcode));\n  if (MightCreatePoisonOrUB)\n    NewC = InstCombiner::getSafeVectorConstantForBinop(BOpcode, NewC, true);\n\n  // shuf (bop X, C), X, M --> bop X, C'\n  // shuf X, (bop X, C), M --> bop X, C'\n  Value *X = Op0IsBinop ? Op1 : Op0;\n  Instruction *NewBO = BinaryOperator::Create(BOpcode, X, NewC);\n  NewBO->copyIRFlags(BO);\n\n  // An undef shuffle mask element may propagate as an undef constant element in\n  // the new binop. That would produce poison where the original code might not.\n  // If we already made a safe constant, then there's no danger.\n  if (is_contained(Mask, UndefMaskElem) && !MightCreatePoisonOrUB)\n    NewBO->dropPoisonGeneratingFlags();\n  return NewBO;\n}\n\n/// If we have an insert of a scalar to a non-zero element of an undefined\n/// vector and then shuffle that value, that's the same as inserting to the zero\n/// element and shuffling. Splatting from the zero element is recognized as the\n/// canonical form of splat.\nstatic Instruction *canonicalizeInsertSplat(ShuffleVectorInst &Shuf,\n                                            InstCombiner::BuilderTy &Builder) {\n  Value *Op0 = Shuf.getOperand(0), *Op1 = Shuf.getOperand(1);\n  ArrayRef<int> Mask = Shuf.getShuffleMask();\n  Value *X;\n  uint64_t IndexC;\n\n  // Match a shuffle that is a splat to a non-zero element.\n  if (!match(Op0, m_OneUse(m_InsertElt(m_Undef(), m_Value(X),\n                                       m_ConstantInt(IndexC)))) ||\n      !match(Op1, m_Undef()) || match(Mask, m_ZeroMask()) || IndexC == 0)\n    return nullptr;\n\n  // Insert into element 0 of an undef vector.\n  UndefValue *UndefVec = UndefValue::get(Shuf.getType());\n  Constant *Zero = Builder.getInt32(0);\n  Value *NewIns = Builder.CreateInsertElement(UndefVec, X, Zero);\n\n  // Splat from element 0. Any mask element that is undefined remains undefined.\n  // For example:\n  // shuf (inselt undef, X, 2), undef, <2,2,undef>\n  //   --> shuf (inselt undef, X, 0), undef, <0,0,undef>\n  unsigned NumMaskElts =\n      cast<FixedVectorType>(Shuf.getType())->getNumElements();\n  SmallVector<int, 16> NewMask(NumMaskElts, 0);\n  for (unsigned i = 0; i != NumMaskElts; ++i)\n    if (Mask[i] == UndefMaskElem)\n      NewMask[i] = Mask[i];\n\n  return new ShuffleVectorInst(NewIns, UndefVec, NewMask);\n}\n\n/// Try to fold shuffles that are the equivalent of a vector select.\nstatic Instruction *foldSelectShuffle(ShuffleVectorInst &Shuf,\n                                      InstCombiner::BuilderTy &Builder,\n                                      const DataLayout &DL) {\n  if (!Shuf.isSelect())\n    return nullptr;\n\n  // Canonicalize to choose from operand 0 first unless operand 1 is undefined.\n  // Commuting undef to operand 0 conflicts with another canonicalization.\n  unsigned NumElts = cast<FixedVectorType>(Shuf.getType())->getNumElements();\n  if (!isa<UndefValue>(Shuf.getOperand(1)) &&\n      Shuf.getMaskValue(0) >= (int)NumElts) {\n    // TODO: Can we assert that both operands of a shuffle-select are not undef\n    // (otherwise, it would have been folded by instsimplify?\n    Shuf.commute();\n    return &Shuf;\n  }\n\n  if (Instruction *I = foldSelectShuffleWith1Binop(Shuf))\n    return I;\n\n  BinaryOperator *B0, *B1;\n  if (!match(Shuf.getOperand(0), m_BinOp(B0)) ||\n      !match(Shuf.getOperand(1), m_BinOp(B1)))\n    return nullptr;\n\n  Value *X, *Y;\n  Constant *C0, *C1;\n  bool ConstantsAreOp1;\n  if (match(B0, m_BinOp(m_Value(X), m_Constant(C0))) &&\n      match(B1, m_BinOp(m_Value(Y), m_Constant(C1))))\n    ConstantsAreOp1 = true;\n  else if (match(B0, m_BinOp(m_Constant(C0), m_Value(X))) &&\n           match(B1, m_BinOp(m_Constant(C1), m_Value(Y))))\n    ConstantsAreOp1 = false;\n  else\n    return nullptr;\n\n  // We need matching binops to fold the lanes together.\n  BinaryOperator::BinaryOps Opc0 = B0->getOpcode();\n  BinaryOperator::BinaryOps Opc1 = B1->getOpcode();\n  bool DropNSW = false;\n  if (ConstantsAreOp1 && Opc0 != Opc1) {\n    // TODO: We drop \"nsw\" if shift is converted into multiply because it may\n    // not be correct when the shift amount is BitWidth - 1. We could examine\n    // each vector element to determine if it is safe to keep that flag.\n    if (Opc0 == Instruction::Shl || Opc1 == Instruction::Shl)\n      DropNSW = true;\n    if (BinopElts AltB0 = getAlternateBinop(B0, DL)) {\n      assert(isa<Constant>(AltB0.Op1) && \"Expecting constant with alt binop\");\n      Opc0 = AltB0.Opcode;\n      C0 = cast<Constant>(AltB0.Op1);\n    } else if (BinopElts AltB1 = getAlternateBinop(B1, DL)) {\n      assert(isa<Constant>(AltB1.Op1) && \"Expecting constant with alt binop\");\n      Opc1 = AltB1.Opcode;\n      C1 = cast<Constant>(AltB1.Op1);\n    }\n  }\n\n  if (Opc0 != Opc1)\n    return nullptr;\n\n  // The opcodes must be the same. Use a new name to make that clear.\n  BinaryOperator::BinaryOps BOpc = Opc0;\n\n  // Select the constant elements needed for the single binop.\n  ArrayRef<int> Mask = Shuf.getShuffleMask();\n  Constant *NewC = ConstantExpr::getShuffleVector(C0, C1, Mask);\n\n  // We are moving a binop after a shuffle. When a shuffle has an undefined\n  // mask element, the result is undefined, but it is not poison or undefined\n  // behavior. That is not necessarily true for div/rem/shift.\n  bool MightCreatePoisonOrUB =\n      is_contained(Mask, UndefMaskElem) &&\n      (Instruction::isIntDivRem(BOpc) || Instruction::isShift(BOpc));\n  if (MightCreatePoisonOrUB)\n    NewC = InstCombiner::getSafeVectorConstantForBinop(BOpc, NewC,\n                                                       ConstantsAreOp1);\n\n  Value *V;\n  if (X == Y) {\n    // Remove a binop and the shuffle by rearranging the constant:\n    // shuffle (op V, C0), (op V, C1), M --> op V, C'\n    // shuffle (op C0, V), (op C1, V), M --> op C', V\n    V = X;\n  } else {\n    // If there are 2 different variable operands, we must create a new shuffle\n    // (select) first, so check uses to ensure that we don't end up with more\n    // instructions than we started with.\n    if (!B0->hasOneUse() && !B1->hasOneUse())\n      return nullptr;\n\n    // If we use the original shuffle mask and op1 is *variable*, we would be\n    // putting an undef into operand 1 of div/rem/shift. This is either UB or\n    // poison. We do not have to guard against UB when *constants* are op1\n    // because safe constants guarantee that we do not overflow sdiv/srem (and\n    // there's no danger for other opcodes).\n    // TODO: To allow this case, create a new shuffle mask with no undefs.\n    if (MightCreatePoisonOrUB && !ConstantsAreOp1)\n      return nullptr;\n\n    // Note: In general, we do not create new shuffles in InstCombine because we\n    // do not know if a target can lower an arbitrary shuffle optimally. In this\n    // case, the shuffle uses the existing mask, so there is no additional risk.\n\n    // Select the variable vectors first, then perform the binop:\n    // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'\n    // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)\n    V = Builder.CreateShuffleVector(X, Y, Mask);\n  }\n\n  Instruction *NewBO = ConstantsAreOp1 ? BinaryOperator::Create(BOpc, V, NewC) :\n                                         BinaryOperator::Create(BOpc, NewC, V);\n\n  // Flags are intersected from the 2 source binops. But there are 2 exceptions:\n  // 1. If we changed an opcode, poison conditions might have changed.\n  // 2. If the shuffle had undef mask elements, the new binop might have undefs\n  //    where the original code did not. But if we already made a safe constant,\n  //    then there's no danger.\n  NewBO->copyIRFlags(B0);\n  NewBO->andIRFlags(B1);\n  if (DropNSW)\n    NewBO->setHasNoSignedWrap(false);\n  if (is_contained(Mask, UndefMaskElem) && !MightCreatePoisonOrUB)\n    NewBO->dropPoisonGeneratingFlags();\n  return NewBO;\n}\n\n/// Convert a narrowing shuffle of a bitcasted vector into a vector truncate.\n/// Example (little endian):\n/// shuf (bitcast <4 x i16> X to <8 x i8>), <0, 2, 4, 6> --> trunc X to <4 x i8>\nstatic Instruction *foldTruncShuffle(ShuffleVectorInst &Shuf,\n                                     bool IsBigEndian) {\n  // This must be a bitcasted shuffle of 1 vector integer operand.\n  Type *DestType = Shuf.getType();\n  Value *X;\n  if (!match(Shuf.getOperand(0), m_BitCast(m_Value(X))) ||\n      !match(Shuf.getOperand(1), m_Undef()) || !DestType->isIntOrIntVectorTy())\n    return nullptr;\n\n  // The source type must have the same number of elements as the shuffle,\n  // and the source element type must be larger than the shuffle element type.\n  Type *SrcType = X->getType();\n  if (!SrcType->isVectorTy() || !SrcType->isIntOrIntVectorTy() ||\n      cast<FixedVectorType>(SrcType)->getNumElements() !=\n          cast<FixedVectorType>(DestType)->getNumElements() ||\n      SrcType->getScalarSizeInBits() % DestType->getScalarSizeInBits() != 0)\n    return nullptr;\n\n  assert(Shuf.changesLength() && !Shuf.increasesLength() &&\n         \"Expected a shuffle that decreases length\");\n\n  // Last, check that the mask chooses the correct low bits for each narrow\n  // element in the result.\n  uint64_t TruncRatio =\n      SrcType->getScalarSizeInBits() / DestType->getScalarSizeInBits();\n  ArrayRef<int> Mask = Shuf.getShuffleMask();\n  for (unsigned i = 0, e = Mask.size(); i != e; ++i) {\n    if (Mask[i] == UndefMaskElem)\n      continue;\n    uint64_t LSBIndex = IsBigEndian ? (i + 1) * TruncRatio - 1 : i * TruncRatio;\n    assert(LSBIndex <= INT32_MAX && \"Overflowed 32-bits\");\n    if (Mask[i] != (int)LSBIndex)\n      return nullptr;\n  }\n\n  return new TruncInst(X, DestType);\n}\n\n/// Match a shuffle-select-shuffle pattern where the shuffles are widening and\n/// narrowing (concatenating with undef and extracting back to the original\n/// length). This allows replacing the wide select with a narrow select.\nstatic Instruction *narrowVectorSelect(ShuffleVectorInst &Shuf,\n                                       InstCombiner::BuilderTy &Builder) {\n  // This must be a narrowing identity shuffle. It extracts the 1st N elements\n  // of the 1st vector operand of a shuffle.\n  if (!match(Shuf.getOperand(1), m_Undef()) || !Shuf.isIdentityWithExtract())\n    return nullptr;\n\n  // The vector being shuffled must be a vector select that we can eliminate.\n  // TODO: The one-use requirement could be eased if X and/or Y are constants.\n  Value *Cond, *X, *Y;\n  if (!match(Shuf.getOperand(0),\n             m_OneUse(m_Select(m_Value(Cond), m_Value(X), m_Value(Y)))))\n    return nullptr;\n\n  // We need a narrow condition value. It must be extended with undef elements\n  // and have the same number of elements as this shuffle.\n  unsigned NarrowNumElts =\n      cast<FixedVectorType>(Shuf.getType())->getNumElements();\n  Value *NarrowCond;\n  if (!match(Cond, m_OneUse(m_Shuffle(m_Value(NarrowCond), m_Undef()))) ||\n      cast<FixedVectorType>(NarrowCond->getType())->getNumElements() !=\n          NarrowNumElts ||\n      !cast<ShuffleVectorInst>(Cond)->isIdentityWithPadding())\n    return nullptr;\n\n  // shuf (sel (shuf NarrowCond, undef, WideMask), X, Y), undef, NarrowMask) -->\n  // sel NarrowCond, (shuf X, undef, NarrowMask), (shuf Y, undef, NarrowMask)\n  Value *NarrowX = Builder.CreateShuffleVector(X, Shuf.getShuffleMask());\n  Value *NarrowY = Builder.CreateShuffleVector(Y, Shuf.getShuffleMask());\n  return SelectInst::Create(NarrowCond, NarrowX, NarrowY);\n}\n\n/// Try to combine 2 shuffles into 1 shuffle by concatenating a shuffle mask.\nstatic Instruction *foldIdentityExtractShuffle(ShuffleVectorInst &Shuf) {\n  Value *Op0 = Shuf.getOperand(0), *Op1 = Shuf.getOperand(1);\n  if (!Shuf.isIdentityWithExtract() || !isa<UndefValue>(Op1))\n    return nullptr;\n\n  Value *X, *Y;\n  ArrayRef<int> Mask;\n  if (!match(Op0, m_Shuffle(m_Value(X), m_Value(Y), m_Mask(Mask))))\n    return nullptr;\n\n  // Be conservative with shuffle transforms. If we can't kill the 1st shuffle,\n  // then combining may result in worse codegen.\n  if (!Op0->hasOneUse())\n    return nullptr;\n\n  // We are extracting a subvector from a shuffle. Remove excess elements from\n  // the 1st shuffle mask to eliminate the extract.\n  //\n  // This transform is conservatively limited to identity extracts because we do\n  // not allow arbitrary shuffle mask creation as a target-independent transform\n  // (because we can't guarantee that will lower efficiently).\n  //\n  // If the extracting shuffle has an undef mask element, it transfers to the\n  // new shuffle mask. Otherwise, copy the original mask element. Example:\n  //   shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->\n  //   shuf X, Y, <C0, undef, C2, undef>\n  unsigned NumElts = cast<FixedVectorType>(Shuf.getType())->getNumElements();\n  SmallVector<int, 16> NewMask(NumElts);\n  assert(NumElts < Mask.size() &&\n         \"Identity with extract must have less elements than its inputs\");\n\n  for (unsigned i = 0; i != NumElts; ++i) {\n    int ExtractMaskElt = Shuf.getMaskValue(i);\n    int MaskElt = Mask[i];\n    NewMask[i] = ExtractMaskElt == UndefMaskElem ? ExtractMaskElt : MaskElt;\n  }\n  return new ShuffleVectorInst(X, Y, NewMask);\n}\n\n/// Try to replace a shuffle with an insertelement or try to replace a shuffle\n/// operand with the operand of an insertelement.\nstatic Instruction *foldShuffleWithInsert(ShuffleVectorInst &Shuf,\n                                          InstCombinerImpl &IC) {\n  Value *V0 = Shuf.getOperand(0), *V1 = Shuf.getOperand(1);\n  SmallVector<int, 16> Mask;\n  Shuf.getShuffleMask(Mask);\n\n  // The shuffle must not change vector sizes.\n  // TODO: This restriction could be removed if the insert has only one use\n  //       (because the transform would require a new length-changing shuffle).\n  int NumElts = Mask.size();\n  if (NumElts != (int)(cast<FixedVectorType>(V0->getType())->getNumElements()))\n    return nullptr;\n\n  // This is a specialization of a fold in SimplifyDemandedVectorElts. We may\n  // not be able to handle it there if the insertelement has >1 use.\n  // If the shuffle has an insertelement operand but does not choose the\n  // inserted scalar element from that value, then we can replace that shuffle\n  // operand with the source vector of the insertelement.\n  Value *X;\n  uint64_t IdxC;\n  if (match(V0, m_InsertElt(m_Value(X), m_Value(), m_ConstantInt(IdxC)))) {\n    // shuf (inselt X, ?, IdxC), ?, Mask --> shuf X, ?, Mask\n    if (!is_contained(Mask, (int)IdxC))\n      return IC.replaceOperand(Shuf, 0, X);\n  }\n  if (match(V1, m_InsertElt(m_Value(X), m_Value(), m_ConstantInt(IdxC)))) {\n    // Offset the index constant by the vector width because we are checking for\n    // accesses to the 2nd vector input of the shuffle.\n    IdxC += NumElts;\n    // shuf ?, (inselt X, ?, IdxC), Mask --> shuf ?, X, Mask\n    if (!is_contained(Mask, (int)IdxC))\n      return IC.replaceOperand(Shuf, 1, X);\n  }\n\n  // shuffle (insert ?, Scalar, IndexC), V1, Mask --> insert V1, Scalar, IndexC'\n  auto isShufflingScalarIntoOp1 = [&](Value *&Scalar, ConstantInt *&IndexC) {\n    // We need an insertelement with a constant index.\n    if (!match(V0, m_InsertElt(m_Value(), m_Value(Scalar),\n                               m_ConstantInt(IndexC))))\n      return false;\n\n    // Test the shuffle mask to see if it splices the inserted scalar into the\n    // operand 1 vector of the shuffle.\n    int NewInsIndex = -1;\n    for (int i = 0; i != NumElts; ++i) {\n      // Ignore undef mask elements.\n      if (Mask[i] == -1)\n        continue;\n\n      // The shuffle takes elements of operand 1 without lane changes.\n      if (Mask[i] == NumElts + i)\n        continue;\n\n      // The shuffle must choose the inserted scalar exactly once.\n      if (NewInsIndex != -1 || Mask[i] != IndexC->getSExtValue())\n        return false;\n\n      // The shuffle is placing the inserted scalar into element i.\n      NewInsIndex = i;\n    }\n\n    assert(NewInsIndex != -1 && \"Did not fold shuffle with unused operand?\");\n\n    // Index is updated to the potentially translated insertion lane.\n    IndexC = ConstantInt::get(IndexC->getType(), NewInsIndex);\n    return true;\n  };\n\n  // If the shuffle is unnecessary, insert the scalar operand directly into\n  // operand 1 of the shuffle. Example:\n  // shuffle (insert ?, S, 1), V1, <1, 5, 6, 7> --> insert V1, S, 0\n  Value *Scalar;\n  ConstantInt *IndexC;\n  if (isShufflingScalarIntoOp1(Scalar, IndexC))\n    return InsertElementInst::Create(V1, Scalar, IndexC);\n\n  // Try again after commuting shuffle. Example:\n  // shuffle V0, (insert ?, S, 0), <0, 1, 2, 4> -->\n  // shuffle (insert ?, S, 0), V0, <4, 5, 6, 0> --> insert V0, S, 3\n  std::swap(V0, V1);\n  ShuffleVectorInst::commuteShuffleMask(Mask, NumElts);\n  if (isShufflingScalarIntoOp1(Scalar, IndexC))\n    return InsertElementInst::Create(V1, Scalar, IndexC);\n\n  return nullptr;\n}\n\nstatic Instruction *foldIdentityPaddedShuffles(ShuffleVectorInst &Shuf) {\n  // Match the operands as identity with padding (also known as concatenation\n  // with undef) shuffles of the same source type. The backend is expected to\n  // recreate these concatenations from a shuffle of narrow operands.\n  auto *Shuffle0 = dyn_cast<ShuffleVectorInst>(Shuf.getOperand(0));\n  auto *Shuffle1 = dyn_cast<ShuffleVectorInst>(Shuf.getOperand(1));\n  if (!Shuffle0 || !Shuffle0->isIdentityWithPadding() ||\n      !Shuffle1 || !Shuffle1->isIdentityWithPadding())\n    return nullptr;\n\n  // We limit this transform to power-of-2 types because we expect that the\n  // backend can convert the simplified IR patterns to identical nodes as the\n  // original IR.\n  // TODO: If we can verify the same behavior for arbitrary types, the\n  //       power-of-2 checks can be removed.\n  Value *X = Shuffle0->getOperand(0);\n  Value *Y = Shuffle1->getOperand(0);\n  if (X->getType() != Y->getType() ||\n      !isPowerOf2_32(cast<FixedVectorType>(Shuf.getType())->getNumElements()) ||\n      !isPowerOf2_32(\n          cast<FixedVectorType>(Shuffle0->getType())->getNumElements()) ||\n      !isPowerOf2_32(cast<FixedVectorType>(X->getType())->getNumElements()) ||\n      isa<UndefValue>(X) || isa<UndefValue>(Y))\n    return nullptr;\n  assert(isa<UndefValue>(Shuffle0->getOperand(1)) &&\n         isa<UndefValue>(Shuffle1->getOperand(1)) &&\n         \"Unexpected operand for identity shuffle\");\n\n  // This is a shuffle of 2 widening shuffles. We can shuffle the narrow source\n  // operands directly by adjusting the shuffle mask to account for the narrower\n  // types:\n  // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'\n  int NarrowElts = cast<FixedVectorType>(X->getType())->getNumElements();\n  int WideElts = cast<FixedVectorType>(Shuffle0->getType())->getNumElements();\n  assert(WideElts > NarrowElts && \"Unexpected types for identity with padding\");\n\n  ArrayRef<int> Mask = Shuf.getShuffleMask();\n  SmallVector<int, 16> NewMask(Mask.size(), -1);\n  for (int i = 0, e = Mask.size(); i != e; ++i) {\n    if (Mask[i] == -1)\n      continue;\n\n    // If this shuffle is choosing an undef element from 1 of the sources, that\n    // element is undef.\n    if (Mask[i] < WideElts) {\n      if (Shuffle0->getMaskValue(Mask[i]) == -1)\n        continue;\n    } else {\n      if (Shuffle1->getMaskValue(Mask[i] - WideElts) == -1)\n        continue;\n    }\n\n    // If this shuffle is choosing from the 1st narrow op, the mask element is\n    // the same. If this shuffle is choosing from the 2nd narrow op, the mask\n    // element is offset down to adjust for the narrow vector widths.\n    if (Mask[i] < WideElts) {\n      assert(Mask[i] < NarrowElts && \"Unexpected shuffle mask\");\n      NewMask[i] = Mask[i];\n    } else {\n      assert(Mask[i] < (WideElts + NarrowElts) && \"Unexpected shuffle mask\");\n      NewMask[i] = Mask[i] - (WideElts - NarrowElts);\n    }\n  }\n  return new ShuffleVectorInst(X, Y, NewMask);\n}\n\nInstruction *InstCombinerImpl::visitShuffleVectorInst(ShuffleVectorInst &SVI) {\n  Value *LHS = SVI.getOperand(0);\n  Value *RHS = SVI.getOperand(1);\n  SimplifyQuery ShufQuery = SQ.getWithInstruction(&SVI);\n  if (auto *V = SimplifyShuffleVectorInst(LHS, RHS, SVI.getShuffleMask(),\n                                          SVI.getType(), ShufQuery))\n    return replaceInstUsesWith(SVI, V);\n\n  // Bail out for scalable vectors\n  if (isa<ScalableVectorType>(LHS->getType()))\n    return nullptr;\n\n  unsigned VWidth = cast<FixedVectorType>(SVI.getType())->getNumElements();\n  unsigned LHSWidth = cast<FixedVectorType>(LHS->getType())->getNumElements();\n\n  // shuffle (bitcast X), (bitcast Y), Mask --> bitcast (shuffle X, Y, Mask)\n  //\n  // if X and Y are of the same (vector) type, and the element size is not\n  // changed by the bitcasts, we can distribute the bitcasts through the\n  // shuffle, hopefully reducing the number of instructions. We make sure that\n  // at least one bitcast only has one use, so we don't *increase* the number of\n  // instructions here.\n  Value *X, *Y;\n  if (match(LHS, m_BitCast(m_Value(X))) && match(RHS, m_BitCast(m_Value(Y))) &&\n      X->getType()->isVectorTy() && X->getType() == Y->getType() &&\n      X->getType()->getScalarSizeInBits() ==\n          SVI.getType()->getScalarSizeInBits() &&\n      (LHS->hasOneUse() || RHS->hasOneUse())) {\n    Value *V = Builder.CreateShuffleVector(X, Y, SVI.getShuffleMask(),\n                                           SVI.getName() + \".uncasted\");\n    return new BitCastInst(V, SVI.getType());\n  }\n\n  ArrayRef<int> Mask = SVI.getShuffleMask();\n  Type *Int32Ty = Type::getInt32Ty(SVI.getContext());\n\n  // Peek through a bitcasted shuffle operand by scaling the mask. If the\n  // simulated shuffle can simplify, then this shuffle is unnecessary:\n  // shuf (bitcast X), undef, Mask --> bitcast X'\n  // TODO: This could be extended to allow length-changing shuffles.\n  //       The transform might also be obsoleted if we allowed canonicalization\n  //       of bitcasted shuffles.\n  if (match(LHS, m_BitCast(m_Value(X))) && match(RHS, m_Undef()) &&\n      X->getType()->isVectorTy() && VWidth == LHSWidth) {\n    // Try to create a scaled mask constant.\n    auto *XType = cast<FixedVectorType>(X->getType());\n    unsigned XNumElts = XType->getNumElements();\n    SmallVector<int, 16> ScaledMask;\n    if (XNumElts >= VWidth) {\n      assert(XNumElts % VWidth == 0 && \"Unexpected vector bitcast\");\n      narrowShuffleMaskElts(XNumElts / VWidth, Mask, ScaledMask);\n    } else {\n      assert(VWidth % XNumElts == 0 && \"Unexpected vector bitcast\");\n      if (!widenShuffleMaskElts(VWidth / XNumElts, Mask, ScaledMask))\n        ScaledMask.clear();\n    }\n    if (!ScaledMask.empty()) {\n      // If the shuffled source vector simplifies, cast that value to this\n      // shuffle's type.\n      if (auto *V = SimplifyShuffleVectorInst(X, UndefValue::get(XType),\n                                              ScaledMask, XType, ShufQuery))\n        return BitCastInst::Create(Instruction::BitCast, V, SVI.getType());\n    }\n  }\n\n  // shuffle x, x, mask --> shuffle x, undef, mask'\n  if (LHS == RHS) {\n    assert(!isa<UndefValue>(RHS) && \"Shuffle with 2 undef ops not simplified?\");\n    // Remap any references to RHS to use LHS.\n    SmallVector<int, 16> Elts;\n    for (unsigned i = 0; i != VWidth; ++i) {\n      // Propagate undef elements or force mask to LHS.\n      if (Mask[i] < 0)\n        Elts.push_back(UndefMaskElem);\n      else\n        Elts.push_back(Mask[i] % LHSWidth);\n    }\n    return new ShuffleVectorInst(LHS, UndefValue::get(RHS->getType()), Elts);\n  }\n\n  // shuffle undef, x, mask --> shuffle x, undef, mask'\n  if (isa<UndefValue>(LHS)) {\n    SVI.commute();\n    return &SVI;\n  }\n\n  if (Instruction *I = canonicalizeInsertSplat(SVI, Builder))\n    return I;\n\n  if (Instruction *I = foldSelectShuffle(SVI, Builder, DL))\n    return I;\n\n  if (Instruction *I = foldTruncShuffle(SVI, DL.isBigEndian()))\n    return I;\n\n  if (Instruction *I = narrowVectorSelect(SVI, Builder))\n    return I;\n\n  APInt UndefElts(VWidth, 0);\n  APInt AllOnesEltMask(APInt::getAllOnesValue(VWidth));\n  if (Value *V = SimplifyDemandedVectorElts(&SVI, AllOnesEltMask, UndefElts)) {\n    if (V != &SVI)\n      return replaceInstUsesWith(SVI, V);\n    return &SVI;\n  }\n\n  if (Instruction *I = foldIdentityExtractShuffle(SVI))\n    return I;\n\n  // These transforms have the potential to lose undef knowledge, so they are\n  // intentionally placed after SimplifyDemandedVectorElts().\n  if (Instruction *I = foldShuffleWithInsert(SVI, *this))\n    return I;\n  if (Instruction *I = foldIdentityPaddedShuffles(SVI))\n    return I;\n\n  if (isa<UndefValue>(RHS) && canEvaluateShuffled(LHS, Mask)) {\n    Value *V = evaluateInDifferentElementOrder(LHS, Mask);\n    return replaceInstUsesWith(SVI, V);\n  }\n\n  // SROA generates shuffle+bitcast when the extracted sub-vector is bitcast to\n  // a non-vector type. We can instead bitcast the original vector followed by\n  // an extract of the desired element:\n  //\n  //   %sroa = shufflevector <16 x i8> %in, <16 x i8> undef,\n  //                         <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  //   %1 = bitcast <4 x i8> %sroa to i32\n  // Becomes:\n  //   %bc = bitcast <16 x i8> %in to <4 x i32>\n  //   %ext = extractelement <4 x i32> %bc, i32 0\n  //\n  // If the shuffle is extracting a contiguous range of values from the input\n  // vector then each use which is a bitcast of the extracted size can be\n  // replaced. This will work if the vector types are compatible, and the begin\n  // index is aligned to a value in the casted vector type. If the begin index\n  // isn't aligned then we can shuffle the original vector (keeping the same\n  // vector type) before extracting.\n  //\n  // This code will bail out if the target type is fundamentally incompatible\n  // with vectors of the source type.\n  //\n  // Example of <16 x i8>, target type i32:\n  // Index range [4,8):         v-----------v Will work.\n  //                +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n  //     <16 x i8>: |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n  //     <4 x i32>: |           |           |           |           |\n  //                +-----------+-----------+-----------+-----------+\n  // Index range [6,10):              ^-----------^ Needs an extra shuffle.\n  // Target type i40:           ^--------------^ Won't work, bail.\n  bool MadeChange = false;\n  if (isShuffleExtractingFromLHS(SVI, Mask)) {\n    Value *V = LHS;\n    unsigned MaskElems = Mask.size();\n    auto *SrcTy = cast<FixedVectorType>(V->getType());\n    unsigned VecBitWidth = SrcTy->getPrimitiveSizeInBits().getFixedSize();\n    unsigned SrcElemBitWidth = DL.getTypeSizeInBits(SrcTy->getElementType());\n    assert(SrcElemBitWidth && \"vector elements must have a bitwidth\");\n    unsigned SrcNumElems = SrcTy->getNumElements();\n    SmallVector<BitCastInst *, 8> BCs;\n    DenseMap<Type *, Value *> NewBCs;\n    for (User *U : SVI.users())\n      if (BitCastInst *BC = dyn_cast<BitCastInst>(U))\n        if (!BC->use_empty())\n          // Only visit bitcasts that weren't previously handled.\n          BCs.push_back(BC);\n    for (BitCastInst *BC : BCs) {\n      unsigned BegIdx = Mask.front();\n      Type *TgtTy = BC->getDestTy();\n      unsigned TgtElemBitWidth = DL.getTypeSizeInBits(TgtTy);\n      if (!TgtElemBitWidth)\n        continue;\n      unsigned TgtNumElems = VecBitWidth / TgtElemBitWidth;\n      bool VecBitWidthsEqual = VecBitWidth == TgtNumElems * TgtElemBitWidth;\n      bool BegIsAligned = 0 == ((SrcElemBitWidth * BegIdx) % TgtElemBitWidth);\n      if (!VecBitWidthsEqual)\n        continue;\n      if (!VectorType::isValidElementType(TgtTy))\n        continue;\n      auto *CastSrcTy = FixedVectorType::get(TgtTy, TgtNumElems);\n      if (!BegIsAligned) {\n        // Shuffle the input so [0,NumElements) contains the output, and\n        // [NumElems,SrcNumElems) is undef.\n        SmallVector<int, 16> ShuffleMask(SrcNumElems, -1);\n        for (unsigned I = 0, E = MaskElems, Idx = BegIdx; I != E; ++Idx, ++I)\n          ShuffleMask[I] = Idx;\n        V = Builder.CreateShuffleVector(V, ShuffleMask,\n                                        SVI.getName() + \".extract\");\n        BegIdx = 0;\n      }\n      unsigned SrcElemsPerTgtElem = TgtElemBitWidth / SrcElemBitWidth;\n      assert(SrcElemsPerTgtElem);\n      BegIdx /= SrcElemsPerTgtElem;\n      bool BCAlreadyExists = NewBCs.find(CastSrcTy) != NewBCs.end();\n      auto *NewBC =\n          BCAlreadyExists\n              ? NewBCs[CastSrcTy]\n              : Builder.CreateBitCast(V, CastSrcTy, SVI.getName() + \".bc\");\n      if (!BCAlreadyExists)\n        NewBCs[CastSrcTy] = NewBC;\n      auto *Ext = Builder.CreateExtractElement(\n          NewBC, ConstantInt::get(Int32Ty, BegIdx), SVI.getName() + \".extract\");\n      // The shufflevector isn't being replaced: the bitcast that used it\n      // is. InstCombine will visit the newly-created instructions.\n      replaceInstUsesWith(*BC, Ext);\n      MadeChange = true;\n    }\n  }\n\n  // If the LHS is a shufflevector itself, see if we can combine it with this\n  // one without producing an unusual shuffle.\n  // Cases that might be simplified:\n  // 1.\n  // x1=shuffle(v1,v2,mask1)\n  //  x=shuffle(x1,undef,mask)\n  //        ==>\n  //  x=shuffle(v1,undef,newMask)\n  // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1\n  // 2.\n  // x1=shuffle(v1,undef,mask1)\n  //  x=shuffle(x1,x2,mask)\n  // where v1.size() == mask1.size()\n  //        ==>\n  //  x=shuffle(v1,x2,newMask)\n  // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]\n  // 3.\n  // x2=shuffle(v2,undef,mask2)\n  //  x=shuffle(x1,x2,mask)\n  // where v2.size() == mask2.size()\n  //        ==>\n  //  x=shuffle(x1,v2,newMask)\n  // newMask[i] = (mask[i] < x1.size())\n  //              ? mask[i] : mask2[mask[i]-x1.size()]+x1.size()\n  // 4.\n  // x1=shuffle(v1,undef,mask1)\n  // x2=shuffle(v2,undef,mask2)\n  //  x=shuffle(x1,x2,mask)\n  // where v1.size() == v2.size()\n  //        ==>\n  //  x=shuffle(v1,v2,newMask)\n  // newMask[i] = (mask[i] < x1.size())\n  //              ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size()\n  //\n  // Here we are really conservative:\n  // we are absolutely afraid of producing a shuffle mask not in the input\n  // program, because the code gen may not be smart enough to turn a merged\n  // shuffle into two specific shuffles: it may produce worse code.  As such,\n  // we only merge two shuffles if the result is either a splat or one of the\n  // input shuffle masks.  In this case, merging the shuffles just removes\n  // one instruction, which we know is safe.  This is good for things like\n  // turning: (splat(splat)) -> splat, or\n  // merge(V[0..n], V[n+1..2n]) -> V[0..2n]\n  ShuffleVectorInst* LHSShuffle = dyn_cast<ShuffleVectorInst>(LHS);\n  ShuffleVectorInst* RHSShuffle = dyn_cast<ShuffleVectorInst>(RHS);\n  if (LHSShuffle)\n    if (!isa<UndefValue>(LHSShuffle->getOperand(1)) && !isa<UndefValue>(RHS))\n      LHSShuffle = nullptr;\n  if (RHSShuffle)\n    if (!isa<UndefValue>(RHSShuffle->getOperand(1)))\n      RHSShuffle = nullptr;\n  if (!LHSShuffle && !RHSShuffle)\n    return MadeChange ? &SVI : nullptr;\n\n  Value* LHSOp0 = nullptr;\n  Value* LHSOp1 = nullptr;\n  Value* RHSOp0 = nullptr;\n  unsigned LHSOp0Width = 0;\n  unsigned RHSOp0Width = 0;\n  if (LHSShuffle) {\n    LHSOp0 = LHSShuffle->getOperand(0);\n    LHSOp1 = LHSShuffle->getOperand(1);\n    LHSOp0Width = cast<FixedVectorType>(LHSOp0->getType())->getNumElements();\n  }\n  if (RHSShuffle) {\n    RHSOp0 = RHSShuffle->getOperand(0);\n    RHSOp0Width = cast<FixedVectorType>(RHSOp0->getType())->getNumElements();\n  }\n  Value* newLHS = LHS;\n  Value* newRHS = RHS;\n  if (LHSShuffle) {\n    // case 1\n    if (isa<UndefValue>(RHS)) {\n      newLHS = LHSOp0;\n      newRHS = LHSOp1;\n    }\n    // case 2 or 4\n    else if (LHSOp0Width == LHSWidth) {\n      newLHS = LHSOp0;\n    }\n  }\n  // case 3 or 4\n  if (RHSShuffle && RHSOp0Width == LHSWidth) {\n    newRHS = RHSOp0;\n  }\n  // case 4\n  if (LHSOp0 == RHSOp0) {\n    newLHS = LHSOp0;\n    newRHS = nullptr;\n  }\n\n  if (newLHS == LHS && newRHS == RHS)\n    return MadeChange ? &SVI : nullptr;\n\n  ArrayRef<int> LHSMask;\n  ArrayRef<int> RHSMask;\n  if (newLHS != LHS)\n    LHSMask = LHSShuffle->getShuffleMask();\n  if (RHSShuffle && newRHS != RHS)\n    RHSMask = RHSShuffle->getShuffleMask();\n\n  unsigned newLHSWidth = (newLHS != LHS) ? LHSOp0Width : LHSWidth;\n  SmallVector<int, 16> newMask;\n  bool isSplat = true;\n  int SplatElt = -1;\n  // Create a new mask for the new ShuffleVectorInst so that the new\n  // ShuffleVectorInst is equivalent to the original one.\n  for (unsigned i = 0; i < VWidth; ++i) {\n    int eltMask;\n    if (Mask[i] < 0) {\n      // This element is an undef value.\n      eltMask = -1;\n    } else if (Mask[i] < (int)LHSWidth) {\n      // This element is from left hand side vector operand.\n      //\n      // If LHS is going to be replaced (case 1, 2, or 4), calculate the\n      // new mask value for the element.\n      if (newLHS != LHS) {\n        eltMask = LHSMask[Mask[i]];\n        // If the value selected is an undef value, explicitly specify it\n        // with a -1 mask value.\n        if (eltMask >= (int)LHSOp0Width && isa<UndefValue>(LHSOp1))\n          eltMask = -1;\n      } else\n        eltMask = Mask[i];\n    } else {\n      // This element is from right hand side vector operand\n      //\n      // If the value selected is an undef value, explicitly specify it\n      // with a -1 mask value. (case 1)\n      if (isa<UndefValue>(RHS))\n        eltMask = -1;\n      // If RHS is going to be replaced (case 3 or 4), calculate the\n      // new mask value for the element.\n      else if (newRHS != RHS) {\n        eltMask = RHSMask[Mask[i]-LHSWidth];\n        // If the value selected is an undef value, explicitly specify it\n        // with a -1 mask value.\n        if (eltMask >= (int)RHSOp0Width) {\n          assert(isa<UndefValue>(RHSShuffle->getOperand(1))\n                 && \"should have been check above\");\n          eltMask = -1;\n        }\n      } else\n        eltMask = Mask[i]-LHSWidth;\n\n      // If LHS's width is changed, shift the mask value accordingly.\n      // If newRHS == nullptr, i.e. LHSOp0 == RHSOp0, we want to remap any\n      // references from RHSOp0 to LHSOp0, so we don't need to shift the mask.\n      // If newRHS == newLHS, we want to remap any references from newRHS to\n      // newLHS so that we can properly identify splats that may occur due to\n      // obfuscation across the two vectors.\n      if (eltMask >= 0 && newRHS != nullptr && newLHS != newRHS)\n        eltMask += newLHSWidth;\n    }\n\n    // Check if this could still be a splat.\n    if (eltMask >= 0) {\n      if (SplatElt >= 0 && SplatElt != eltMask)\n        isSplat = false;\n      SplatElt = eltMask;\n    }\n\n    newMask.push_back(eltMask);\n  }\n\n  // If the result mask is equal to one of the original shuffle masks,\n  // or is a splat, do the replacement.\n  if (isSplat || newMask == LHSMask || newMask == RHSMask || newMask == Mask) {\n    if (!newRHS)\n      newRHS = UndefValue::get(newLHS->getType());\n    return new ShuffleVectorInst(newLHS, newRHS, newMask);\n  }\n\n  return MadeChange ? &SVI : nullptr;\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 49, "line": 1484}, "message": "default constructor 'm_ZeroMask' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PatternMatch.h", "reportHash": "1267398e86913ba7ec266bb2d0fcf9b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 1484}, "message": "destructor '~m_ZeroMask' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PatternMatch.h", "reportHash": "59456dbd5fdb51f92039f0a385ef6748", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 72, "line": 743}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "5ddae1ad1a7a897a92c2aab9d0471460", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 72, "line": 743}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "55263750fbb944c9de2df5f335d5024f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 72, "line": 800}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "60724d07df4a35c5289c04cf5e2e2124", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 72, "line": 800}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "35d2ccf55fd406f5a388fa3a443d51e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 72, "line": 814}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "9e2590a6c25291e5506505de45deb88e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 72, "line": 814}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "e0f21f4abc073d33f49e03e342cd6052", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 72, "line": 842}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "4f26570a31bc5296cf0b754d6ff0f2c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 72, "line": 842}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "25745b31a465c14909bca514f7bfb45d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 72, "line": 1410}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "f7a6a5a925fc75a5d185155fff50acb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 72, "line": 1410}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "6ad65a67d3ac11cab1803a5df4e4fb13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 72, "line": 1751}, "message": "destructor '~BinopElts' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "be78b4cdad743bf00f8114b00f867fd3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 72, "line": 1751}, "message": "move constructor 'BinopElts' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "04ec1ea64240d5b4d930c1daf129fe44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 72, "line": 2160}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "4e85b14da1253ca46dc429d51e0c833a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 72, "line": 2160}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp", "reportHash": "9e047a0d288509c3f2dd851fdb402ad4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
